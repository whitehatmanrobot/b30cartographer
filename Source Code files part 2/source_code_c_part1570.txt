                 Loc;
    DWORD                          Error;

    AssertRet(OptList && Opt, ERROR_INVALID_PARAMETER );

    Error = MemArrayInitLoc(OptList, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(OptList, &Loc, (LPVOID*)Opt);
        Require(ERROR_SUCCESS == Error);
        Require(*Opt);

        if( (*Opt)->OptId == OptId )
            return ERROR_SUCCESS;

        Error = MemArrayNextLoc(OptList, &Loc);
    }

    *Opt = NULL;
    return ERROR_FILE_NOT_FOUND;
}
//EndExport(inline)

//BeginExport(function)
DWORD
MemOptListDelOption(
    IN      PM_OPTLIST             OptList,
    IN      DWORD                  OptId
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    PM_OPTION                      Opt;

    AssertRet(OptList, ERROR_INVALID_PARAMETER );

    Error = MemArrayInitLoc(OptList, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(OptList, &Loc, (LPVOID*)&Opt);
        Require(ERROR_SUCCESS == Error && Opt);

        if( Opt->OptId == OptId ) {
            Error = MemArrayDelElement(OptList, &Loc, (LPVOID*)&Opt);
            Require(ERROR_SUCCESS == Error && Opt);
            Error = MemOptCleanup(Opt);
            Require(ERROR_SUCCESS == Error);
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(OptList, &Loc);
    }

    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(inline)
DWORD       _inline
MemOptListSize(
    IN      PM_OPTLIST             OptList
) {
    return MemArraySize(OptList);
}
//EndExport(inline)

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\optdefl.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

typedef struct _M_OPTDEF {
    DWORD                          OptId;
    DWORD                          Type;
    LPWSTR                         OptName;
    LPWSTR                         OptComment;
    LPBYTE                         OptVal;
    DWORD                          OptValLen;
} M_OPTDEF, *PM_OPTDEF, *LPM_OPTDEF;

typedef struct _M_OPTDEFLIST {
    ARRAY                          OptDefArray;
} M_OPTDEFLIST, *PM_OPTDEFLIST, *LPM_OPTDEFLIST;


DWORD       _inline
MemOptDefListInit(
    IN OUT  PM_OPTDEFLIST          OptDefList
) {
    AssertRet(OptDefList, ERROR_INVALID_PARAMETER);
    return MemArrayInit(&OptDefList->OptDefArray);
}


DWORD       _inline
MemOptDefListCleanup(
    IN OUT  PM_OPTDEFLIST          OptDefList
) {
    return MemArrayCleanup(&OptDefList->OptDefArray);
}


DWORD
MemOptDefListFindOptDefInternal(                  // Dont use this function out of optdefl.c
    IN      PM_OPTDEFLIST          OptDefList,
    IN      DWORD                  OptId,
    IN      LPWSTR                 OptName,       // either OptId or OptName need only be specified..
    OUT     PARRAY_LOCATION        Location
) ;


DWORD       _inline
MemOptDefListFindOptDef(
    IN      PM_OPTDEFLIST          OptDefList,
    IN      DWORD                  OptId,
    IN      LPWSTR                 OptName,       // only either the name or the option id need be given..
    OUT     PM_OPTDEF             *OptDef
) {
    ARRAY_LOCATION                 Location;
    DWORD                          Error;

    Error = MemOptDefListFindOptDefInternal(
        OptDefList,
        OptId,
        OptName,
        &Location
    );
    if( ERROR_SUCCESS != Error ) return Error;

    return MemArrayGetElement(
        &OptDefList->OptDefArray,
        &Location,
        (LPVOID *)OptDef
    );
}


DWORD
MemOptDefListAddOptDef(                           // Add or replace an option defintion for given Option Id
    IN OUT  PM_OPTDEFLIST          OptDefList,
    IN      DWORD                  OptId,
    IN      DWORD                  Type,
    IN      LPWSTR                 OptName,
    IN      LPWSTR                 OptComment,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptValLen
) ;


DWORD       _inline
MemOptDefListDelOptDef(
    IN OUT  PM_OPTDEFLIST          OptDefList,
    IN      DWORD                  OptId
) {
    ARRAY_LOCATION                 Location;
    DWORD                          Error;
    PM_OPTDEF                      OptDef;

    Error = MemOptDefListFindOptDefInternal(
        OptDefList,
        OptId,
        NULL,
        &Location
    );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemArrayDelElement(
        &OptDefList->OptDefArray,
        &Location,
        &OptDef
    );
    Require(ERROR_SUCCESS == Error && OptDef);

    MemFree(OptDef);
    return ERROR_SUCCESS;
}

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\range.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for options, including class id
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include    <mm.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>
#include    <bitmask.h>

//BeginExport(typedef)
typedef struct _M_RANGE {
    DWORD                          Start;
    DWORD                          End;
    DWORD                          Mask;
    DWORD                          State;
    ULONG                          BootpAllocated;
    ULONG                          MaxBootpAllowed;
    DWORD                          DirtyOps;      // how many unsaved ops done?
    M_OPTCLASS                     Options;
    PM_BITMASK                     BitMask;
    // Reservations?
} M_RANGE, *PM_RANGE, *LPM_RANGE;
//EndExport(typedef)

//BeginExport(inline)
DWORD       _inline
MemRangeInit(
    IN OUT  PM_RANGE               Range,
    IN      DWORD                  Start,
    IN      DWORD                  End,
    IN      DWORD                  Mask,
    IN      DWORD                  State,
    IN      ULONG                  BootpAllocated,
    IN      ULONG                  MaxBootpAllowed
) {
    DWORD                          Error;

    AssertRet(Range, ERROR_INVALID_PARAMETER);
    if( Start > End || (Start & Mask) != (End & Mask) )
        return ERROR_INVALID_PARAMETER;


    Range->Start = Start;
    Range->End = End;
    Range->Mask = Mask;
    Range->State = State;
    Range->DirtyOps = 0;
    Range->BootpAllocated = BootpAllocated;
    Range->MaxBootpAllowed = MaxBootpAllowed;

    Error = MemBitInit(&Range->BitMask, End - Start + 1);
    if( ERROR_SUCCESS != Error ) return Error;

    return MemOptClassInit(&Range->Options);
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemRangeCleanup(
    IN OUT  PM_RANGE               Range
) {
    DWORD                          Error;
    AssertRet(Range, ERROR_INVALID_PARAMETER);

    Error = MemBitCleanup(Range->BitMask);
    if( ERROR_SUCCESS != Error ) return Error;

    return MemOptClassCleanup(&Range->Options);
}
//EndExport(inline)

//BeginExport(inline)
PM_OPTCLASS _inline
MemRangeGetOptions(
    IN      PM_RANGE               Range
) {
    AssertRet(Range, NULL);

    return &Range->Options;
}
//EndExport(inline)

//BeginExport(enum)
enum /* anonymous */ {
    X_LESSTHAN_Y,
    Y_LESSTHAN_X,
    X_IN_Y,
    Y_IN_X,
    X_LESSTHAN_Y_OVERLAP,
    Y_LESSTHAN_X_OVERLAP
};
//EndExport(enum)

//BeginExport(inline)
DWORD       _inline
MemRangeCompare(
    IN      DWORD                  StartX,
    IN      DWORD                  EndX,
    IN      DWORD                  StartY,
    IN      DWORD                  EndY
) {
    if( EndX < StartY ) return X_LESSTHAN_Y;
    if( EndY < StartX ) return Y_LESSTHAN_X;

    if( StartX < StartY ) {
        if( EndX < EndY ) return X_LESSTHAN_Y_OVERLAP;
        return Y_IN_X;
    }

    if( StartX == StartY ) {
        if( EndX <= EndY ) return X_IN_Y;
        if( EndY <= EndX ) return Y_IN_X;
    }
    
    if( EndX <= EndY ) return X_IN_Y;
    return Y_LESSTHAN_X_OVERLAP;
}
//EndExport(inline)

//BeginExport(function)
DWORD
MemRangeExtendOrContract(
    IN OUT  PM_RANGE               Range,
    IN      DWORD                  nAddresses,    // to contract by or expand by
    IN      BOOL                   fExtend,       // is this extend or contract?
    IN      BOOL                   fEnd           // to expand/contract at End or ar Start?
) //EndExport(function)
{
    DWORD                          Error;

    AssertRet(Range && nAddresses > 0, ERROR_INVALID_PARAMETER);

    Error = MemBitAddOrDelBits(
        Range->BitMask,
        nAddresses,
        fExtend,
        fEnd
    );
    if( ERROR_SUCCESS != Error ) return Error;

    if( fExtend ) {
        if( fEnd ) Range->End += nAddresses;
        else Range->Start -= nAddresses;
    } else {
        if( fEnd ) Range->End -= nAddresses;
        else Range->Start += nAddresses;
    }

    return ERROR_SUCCESS;
}

//BeginExport(inline)
DWORD       _inline
MemRangeConvertToClusters(
    IN      PM_RANGE               Range,
    OUT     LPBYTE                 *InUseClusters,
    OUT     DWORD                  *InUseClustersSize,
    OUT     LPBYTE                 *UsedClusters,
    OUT     DWORD                  *UsedClustersSize
)
{
    AssertRet(Range && InUseClusters && InUseClustersSize, ERROR_INVALID_PARAMETER);
    AssertRet(UsedClusters && UsedClustersSize, ERROR_INVALID_PARAMETER);

    return MemBitConvertToCluster(
        Range->BitMask,  Range->Start,
        InUseClusters, InUseClustersSize,
        UsedClusters, UsedClustersSize
    );
}


//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\reserve.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

typedef struct _M_RESERVATION  {
    LPVOID                         SubnetPtr;
    DWORD                          Address;
    DWORD                          Flags;
    DWORD                          nBytes;
    LPBYTE                         ClientUID;
    M_OPTCLASS                     Options;
} M_RESERVATION , *PM_RESERVATION , *LPM_RESERVATION ;


typedef ARRAY                      M_RESERVATIONS;
typedef PARRAY                     PM_RESERVATIONS;
typedef LPARRAY                    LPM_RESERVATIONS;


DWORD       _inline
MemReserve1Init(
    OUT     PM_RESERVATION        *Reservation,
    IN      DWORD                  Address,
    IN      DWORD                  Flags,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  nBytesClientUID
) {
    PM_RESERVATION                 Res1;
    DWORD                          Size;
    DWORD                          Error;

    AssertRet(Reservation && ClientUID && nBytesClientUID, ERROR_INVALID_PARAMETER);
    Require(Address);

    *Reservation = NULL;

    Size = ROUND_UP_COUNT(sizeof(M_RESERVATION ), ALIGN_WORST);
    Size += nBytesClientUID;

    Res1 = MemAlloc(Size);
    if( NULL == Res1 ) return ERROR_NOT_ENOUGH_MEMORY;

    Res1->SubnetPtr = NULL;
    Res1->Address   = Address;
    Res1->Flags     = Flags;
    Res1->nBytes    = nBytesClientUID;
    Res1->ClientUID = Size - nBytesClientUID + (LPBYTE)Res1;
    memcpy(Res1->ClientUID, ClientUID, nBytesClientUID);
    Error = MemOptClassInit(&(Res1->Options));
    Require(ERROR_SUCCESS == Error);

    *Reservation = Res1;

    return ERROR_SUCCESS;
}


DWORD       _inline
MemReserve1Cleanup(
    IN      PM_RESERVATION         Reservation
) {
    DWORD                          Error;
    AssertRet(Reservation, ERROR_INVALID_PARAMETER);

    Error = MemOptClassCleanup(&(Reservation->Options));
    Require(ERROR_SUCCESS == Error);

    MemFree(Reservation);
    return ERROR_SUCCESS;
}


DWORD       _inline
MemReserveInit(
    IN OUT  PM_RESERVATIONS        Reservation
) {
    return MemArrayInit(Reservation);
}


DWORD       _inline
MemReserveCleanup(
    IN      PM_RESERVATIONS        Reservation
) {
    return MemArrayCleanup(Reservation);
}


DWORD
MemReserveAdd(                                    // new client, should not exist before
    IN OUT  PM_RESERVATIONS        Reservation,
    IN      DWORD                  Address,
    IN      DWORD                  Flags,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDSize
) ;


DWORD
MemReserveReplace(                                // old client, should exist before
    IN OUT  PM_RESERVATIONS        Reservation,
    IN      DWORD                  Address,
    IN      DWORD                  Flags,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDSize
) ;


DWORD
MemReserveDel(
    IN OUT  PM_RESERVATIONS        Reservation,
    IN      DWORD                  Address
) ;


DWORD
MemReserveFindByClientUID(
    IN      PM_RESERVATIONS        Reservation,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDSize,
    OUT     PM_RESERVATION        *Res
) ;


DWORD
MemReserveFindByAddress(
    IN      PM_RESERVATIONS        Reservation,
    IN      DWORD                  Address,
    OUT     PM_RESERVATION        *Res
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\range.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

typedef struct _M_RANGE {
    DWORD                          Start;
    DWORD                          End;
    DWORD                          Mask;
    DWORD                          State;
    ULONG                          BootpAllocated;
    ULONG                          MaxBootpAllowed;
    DWORD                          DirtyOps;      // how many unsaved ops done?
    M_OPTCLASS                     Options;
    PM_BITMASK                     BitMask;
    // Reservations?
} M_RANGE, *PM_RANGE, *LPM_RANGE;


DWORD       _inline
MemRangeInit(
    IN OUT  PM_RANGE               Range,
    IN      DWORD                  Start,
    IN      DWORD                  End,
    IN      DWORD                  Mask,
    IN      DWORD                  State,
    IN      ULONG                  BootpAllocated,
    IN      ULONG                  MaxBootpAllowed
) {
    DWORD                          Error;

    AssertRet(Range, ERROR_INVALID_PARAMETER);
    if( Start > End || (Start & Mask) != (End & Mask) )
        return ERROR_INVALID_PARAMETER;


    Range->Start = Start;
    Range->End = End;
    Range->Mask = Mask;
    Range->State = State;
    Range->DirtyOps = 0;
    Range->BootpAllocated = BootpAllocated;
    Range->MaxBootpAllowed = MaxBootpAllowed;

    Error = MemBitInit(&Range->BitMask, End - Start + 1);
    if( ERROR_SUCCESS != Error ) return Error;

    return MemOptClassInit(&Range->Options);
}


DWORD       _inline
MemRangeCleanup(
    IN OUT  PM_RANGE               Range
) {
    DWORD                          Error;
    AssertRet(Range, ERROR_INVALID_PARAMETER);

    Error = MemBitCleanup(Range->BitMask);
    if( ERROR_SUCCESS != Error ) return Error;

    return MemOptClassCleanup(&Range->Options);
}


PM_OPTCLASS _inline
MemRangeGetOptions(
    IN      PM_RANGE               Range
) {
    AssertRet(Range, NULL);

    return &Range->Options;
}


enum /* anonymous */ {
    X_LESSTHAN_Y,
    Y_LESSTHAN_X,
    X_IN_Y,
    Y_IN_X,
    X_LESSTHAN_Y_OVERLAP,
    Y_LESSTHAN_X_OVERLAP
};


DWORD       _inline
MemRangeCompare(
    IN      DWORD                  StartX,
    IN      DWORD                  EndX,
    IN      DWORD                  StartY,
    IN      DWORD                  EndY
) {
    if( EndX < StartY ) return X_LESSTHAN_Y;
    if( EndY < StartX ) return Y_LESSTHAN_X;

    if( StartX < StartY ) {
        if( EndX < EndY ) return X_LESSTHAN_Y_OVERLAP;
        return Y_IN_X;
    }

    if( StartX == StartY ) {
        if( EndX <= EndY ) return X_IN_Y;
        if( EndY <= EndX ) return Y_IN_X;
    }
        
    if( EndX <= EndY ) return X_IN_Y;
    return Y_LESSTHAN_X_OVERLAP;
}


DWORD
MemRangeExtendOrContract(
    IN OUT  PM_RANGE               Range,
    IN      DWORD                  nAddresses,    // to contract by or expand by
    IN      BOOL                   fExtend,       // is this extend or contract?
    IN      BOOL                   fEnd           // to expand/contract at End or ar Start?
) ;


DWORD       _inline
MemRangeConvertToClusters(
    IN      PM_RANGE               Range,
    OUT     LPBYTE                 *InUseClusters,
    OUT     DWORD                  *InUseClustersSize,
    OUT     LPBYTE                 *UsedClusters,
    OUT     DWORD                  *UsedClustersSize
)
{
    AssertRet(Range && InUseClusters && InUseClustersSize, ERROR_INVALID_PARAMETER);
    AssertRet(UsedClusters && UsedClustersSize, ERROR_INVALID_PARAMETER);

    return MemBitConvertToCluster(
        Range->BitMask,  Range->Start,
        InUseClusters, InUseClustersSize,
        UsedClusters, UsedClustersSize
    );
}


//================================================================================
// end of file
//================================================================================

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\server.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for a server object
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include    <mm.h>
#include    <winbase.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>
#include    <bitmask.h>
#include    <range.h>
#include    <reserve.h>
#include    <subnet.h>
#include    <optdefl.h>
#include    <classdefl.h>
#include    <oclassdl.h>
#include    <sscope.h>

//BeginExport(constants)
#include    <dhcp.h>
//EndExport(constants)

//BeginExport(typedef)
typedef struct _M_SERVER {
    DWORD                          Address;
    DWORD                          State;
    DWORD                          Policy;
    ARRAY                          Subnets;
    ARRAY                          MScopes;
    ARRAY_LOCATION                 Loc;           // if RoundRobin on, then we need this to keep track
    ARRAY                          SuperScopes;
    M_OPTCLASS                     Options;
    M_OPTCLASSDEFLIST              OptDefs;
    M_CLASSDEFLIST                 ClassDefs;
    LPWSTR                         Name;
    LPWSTR                         Comment;
} M_SERVER, *PM_SERVER, *LPM_SERVER;
//EndExport(typedef)

//BeginExport(function)
DWORD
MemServerInit(
    OUT     PM_SERVER             *Server,
    IN      DWORD                  Address,
    IN      DWORD                  State,
    IN      DWORD                  Policy,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Size;
    PM_SERVER                      Srv;

    AssertRet(Server, ERROR_INVALID_PARAMETER );

    Size = ROUND_UP_COUNT(sizeof(M_SERVER), ALIGN_WORST);
    if(Name) Size += sizeof(WCHAR)*(1+wcslen(Name));
    if(Comment) Size += sizeof(WCHAR)*(1+wcslen(Comment));

    Srv = MemAlloc(Size);
    if( NULL == Srv ) return ERROR_NOT_ENOUGH_MEMORY;

    Srv->Address = Address;
    Srv->State   = State;
    Srv->Policy  = Policy;
    Error = MemArrayInit(&Srv->Subnets);
    if( ERROR_SUCCESS != Error ) { MemFree(Srv); return Error; }

    Error = MemArrayInitLoc(&Srv->Subnets, &Srv->Loc);
    // Require(ERROR_SUCCESS == Error);           // guaranteed failure as the array is empty now..

    Error = MemArrayInit(&Srv->MScopes);
    if( ERROR_SUCCESS != Error ) { MemFree(Srv); return Error; }

    Error = MemArrayInit(&Srv->SuperScopes);
    if( ERROR_SUCCESS != Error ) { MemFree(Srv); return Error; }

    Error = MemOptClassInit(&Srv->Options);
    if( ERROR_SUCCESS != Error ) { MemFree(Srv); return Error; }

    Error = MemOptClassDefListInit(&Srv->OptDefs);
    if( ERROR_SUCCESS != Error ) { MemFree(Srv); return Error; }

    Error = MemClassDefListInit(&Srv->ClassDefs);
    if( ERROR_SUCCESS != Error ) { MemFree(Srv); return Error; }

    Size = ROUND_UP_COUNT(sizeof(M_SERVER), ALIGN_WORST);

    if( Name ) {
        Srv->Name = (LPWSTR)(Size + (LPBYTE)Srv);
        Size += sizeof(WCHAR)*(1 + wcslen(Name));
        wcscpy(Srv->Name, Name);
    }
    if( Comment ) {
        Srv->Comment = (LPWSTR)(Size + (LPBYTE)Srv);
        wcscpy(Srv->Comment, Comment);
    }

    *Server = Srv;
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
MemServerCleanup(
    IN OUT  PM_SERVER              Server
) //EndExport(function)
{
    DWORD                          Error;

    AssertRet(Server, ERROR_INVALID_PARAMETER);

    Error = MemArrayCleanup(&Server->Subnets);
    Require( ERROR_SUCCESS == Error);

    Error = MemArrayCleanup(&Server->MScopes);
    Require( ERROR_SUCCESS == Error);

    Error = MemArrayCleanup(&Server->SuperScopes);
    Require( ERROR_SUCCESS == Error);

    Error = MemOptClassCleanup(&Server->Options);
    Require( ERROR_SUCCESS == Error);

    Error = MemOptClassDefListCleanup(&Server->OptDefs);
    Require( ERROR_SUCCESS == Error);

    Error = MemClassDefListCleanup(&Server->ClassDefs);
    Require( ERROR_SUCCESS == Error);

    MemFree(Server);

    return ERROR_SUCCESS;
}

//================================================================================
//  subnet related functions on the server
//================================================================================

//BeginExport(function)
DWORD
MemServerGetUAddressInfo(
    IN      PM_SERVER              Server,
    IN      DWORD                  Address,
    OUT     PM_SUBNET             *Subnet,        // OPTIONAL
    OUT     PM_RANGE              *Range,         // OPTIONAL
    OUT     PM_EXCL               *Excl,          // OPTIONAL
    OUT     PM_RESERVATION        *Reservation    // OPTIONAL
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    PM_SUBNET                      ThisSubnet;
    DWORD                          Error;
    LONG                           Start, End, Mid;

    AssertRet(Server && (Subnet || Range || Excl || Reservation ), ERROR_INVALID_PARAMETER);
    Require( !CLASSD_HOST_ADDR( Address ) );

#if 0
    //
    // this is a linear search.  need to optimize this loop with binary search
    //

    Error = MemArrayInitLoc(&Server->Subnets, &Loc);
    while ( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Server->Subnets, &Loc, (LPVOID*)&ThisSubnet);
        Require(ERROR_SUCCESS == Error);

        if( ThisSubnet->fSubnet && ThisSubnet->Address == (ThisSubnet->Mask & Address) ) {
            if( Subnet ) {
                *Subnet = ThisSubnet;
                if( NULL == Range && NULL == Excl && NULL == Reservation )
                    return ERROR_SUCCESS;         // nothing else requested
            }
            Error = MemSubnetGetAddressInfo(
                ThisSubnet,
                Address,
                Range,
                Excl,
                Reservation
            );
            if( Subnet && *Subnet ) {
                return ERROR_SUCCESS;            // return success as we DID find the subnet
            } else {
                return Error;                    // if subnet was not requested, the retval is decided by Subnet* fn
            }
        }

        Error = MemArrayNextLoc(&Server->Subnets, &Loc);
    }
#else

    //
    // more efficient binary search
    //

    if( Subnet ) {
        *Subnet = NULL;
    }

    Start = 0;
    End = MemArraySize(&Server->Subnets) - 1;

    while( Start <= End ) {                       // still got an element to go by..
        Mid = (Start + End) /2 ;

        Error = MemArrayGetElement(&Server->Subnets, &Mid, &ThisSubnet);
        Require( ERROR_SUCCESS == Error );

        Require(ThisSubnet->fSubnet);             // can't work if something inbetween aint a subnet
        if( Address < ThisSubnet->Address) {      // not in this subnet ..
            End = Mid - 1;
        } else if( ThisSubnet->Address == (ThisSubnet->Mask & Address) ) {

            //
            // We got the subnet we're looking for..
            //

            if( Subnet ) {
                *Subnet = ThisSubnet;
                if( NULL == Range && NULL == Excl && NULL == Reservation )
                    return ERROR_SUCCESS;
            }

            if( Range || Excl || Reservation ) {
                Error = MemSubnetGetAddressInfo(
                    ThisSubnet,
                    Address,
                    Range,
                    Excl,
                    Reservation
                    );
            }

            //
            // if we got a subnet, but didn't suceed above.. still we got something
            // so return success... otherwise return whatever above returned..
            //

            return ( Subnet && (*Subnet) ) ? ERROR_SUCCESS: Error;
        } else {

            //
            // Has to be one of the furhter down subnets..
            //

            Start = Mid + 1;
        }
    }
#endif

    //
    // couldn't find it unfortunately..
    //

    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemServerGetMAddressInfo(
    IN      PM_SERVER              Server,
    IN      DWORD                  Address,
    OUT     PM_SUBNET             *Subnet,        // OPTIONAL
    OUT     PM_RANGE              *Range,         // OPTIONAL
    OUT     PM_EXCL               *Excl,          // OPTIONAL
    OUT     PM_RESERVATION        *Reservation    // OPTIONAL
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    PM_SUBNET                      ThisMScope;
    DWORD                          Error,Error2;
    PM_RANGE                       RangeTmp;

    AssertRet(Server && (Subnet || Range || Excl || Reservation ), ERROR_INVALID_PARAMETER);

    if( NULL == Range ) Range = &RangeTmp;

    Error = MemArrayInitLoc(&Server->MScopes, &Loc);
    while ( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Server->MScopes, &Loc, (LPVOID*)&ThisMScope);
        Require(ERROR_SUCCESS == Error);

        Error2 = MemSubnetGetAddressInfo(
            ThisMScope,
            Address,
            Range,
            Excl,
            Reservation
            );

        if (ERROR_SUCCESS == Error2) {
            if( Subnet ) *Subnet = ThisMScope;
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(&Server->MScopes, &Loc);
        continue;
    }

    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(inline)
DWORD       _inline
MemServerGetAddressInfo(
    IN      PM_SERVER              Server,
    IN      DWORD                  Address,
    OUT     PM_SUBNET             *Subnet,        // OPTIONAL
    OUT     PM_RANGE              *Range,         // OPTIONAL
    OUT     PM_EXCL               *Excl,          // OPTIONAL
    OUT     PM_RESERVATION        *Reservation    // OPTIONAL
) {
    if (CLASSD_HOST_ADDR( Address )) {
        return MemServerGetMAddressInfo(
                    Server,
                    Address,
                    Subnet,
                    Range,
                    Excl,
                    Reservation
                    );
    } else {
        return MemServerGetUAddressInfo(
                    Server,
                    Address,
                    Subnet,
                    Range,
                    Excl,
                    Reservation
                    );
    }

}
//EndExport(inline)

//BeginExport(function)
DWORD
MemServerAddSubnet(
    IN OUT  PM_SERVER              Server,
    IN      PM_SUBNET              Subnet         // completely created subnet, must not be in Server's list tho'
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      OldSubnet;
    ARRAY_LOCATION                 Loc;

    AssertRet(Server && Subnet, ERROR_INVALID_PARAMETER);
    AssertRet((Subnet->Mask & Subnet->Address), ERROR_INVALID_PARAMETER);

    Subnet->ServerPtr = Server;                   // set the backptr for future use

    //
    // First check if subnet duplicates exist and avoid that
    //
    //
    for(
        Error = MemArrayInitLoc(&Server->Subnets, &Loc);
        NO_ERROR == Error ;
        Error = MemArrayNextLoc(&Server->Subnets, &Loc)
        ) {

        Error = MemArrayGetElement(&Server->Subnets, &Loc, &OldSubnet);
        Require(ERROR_SUCCESS == Error);

        if( (Subnet->Address & OldSubnet->Mask) == OldSubnet->Address
            ||
            (OldSubnet->Address & Subnet->Mask) == Subnet->Address
            ) {
            return ERROR_OBJECT_ALREADY_EXISTS;
        }
    }
    
    //
    // Subnets are stored in ascending order of IP addresses.. so insert
    // at the right location
    //

    for(
        Error = MemArrayInitLoc(&Server->Subnets, &Loc)
        ; ERROR_SUCCESS == Error ;
        Error = MemArrayNextLoc(&Server->Subnets, &Loc)
    ) {
        Error = MemArrayGetElement(&Server->Subnets, &Loc, &OldSubnet);
        Require(ERROR_SUCCESS == Error);

        if( Subnet->Address == OldSubnet->Address ) {
            //
            // Subnet already present?
            //

            return ERROR_OBJECT_ALREADY_EXISTS;
        }

        if( Subnet->Address < OldSubnet->Address ) {
            //
            // right place to insert the new subnet..
            //

            Error = MemArrayInitLoc(&Server->Subnets, &Server->Loc);
            Require(ERROR_SUCCESS == Error);

            Error = MemArrayInsElement(&Server->Subnets, &Loc, Subnet);
            Require(ERROR_SUCCESS == Error);

            return Error;
        }
    }

    //
    // This subnet's address is greater than all others.. so add it at end
    //

    Error = MemArrayAddElement(&Server->Subnets, Subnet);
    if( ERROR_SUCCESS != Error) return Error;

    Error = MemArrayInitLoc(&Server->Subnets, &Server->Loc);
    Require(ERROR_SUCCESS == Error);

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
MemServerDelSubnet(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  SubnetAddress,
    OUT     PM_SUBNET             *Subnet
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      DeletedSubnet;
    ARRAY_LOCATION                 Loc;

    AssertRet(Server && Subnet, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(&Server->Subnets, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Server->Subnets, &Loc, (LPVOID*)&DeletedSubnet);
        Require(ERROR_SUCCESS == Error && DeletedSubnet);

        if( SubnetAddress == DeletedSubnet->Address) {
            Error = MemArrayDelElement(&Server->Subnets, &Loc, (LPVOID*)Subnet);
            Require(ERROR_SUCCESS == Error && Subnet);
            Require(*Subnet == DeletedSubnet);

            Error = MemArrayInitLoc(&Server->Subnets, &Server->Loc);
            // Require(ERROR_SUCCESS == Error);   // this may fail if this is the last subnet being deleted
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(&Server->Subnets, &Loc);
    }

    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemServerFindSubnetByName(
    IN      PM_SERVER              Server,
    IN      LPWSTR                 Name,
    OUT     PM_SUBNET             *Subnet
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      ThisSubnet;
    ARRAY_LOCATION                 Loc;

    AssertRet(Server && Name && Subnet, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(&Server->Subnets, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Server->Subnets, &Loc, (LPVOID*)&ThisSubnet);
        Require(ERROR_SUCCESS == Error && ThisSubnet);

        if( 0 == wcscmp(Name, ThisSubnet->Name) ) {
            *Subnet = ThisSubnet;
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(&Server->Subnets, &Loc);
    }

    return ERROR_FILE_NOT_FOUND;
}

//================================================================================
// superscope functionality
//================================================================================

//BeginExport(constant)
#define     INVALID_SSCOPE_ID      0xFFFFFFFF
#define     INVALID_SSCOPE_NAME    NULL
//EndExport(constant)

//BeginExport(function)
DWORD
MemServerFindSScope(                              // find matching with EITHER scopeid ir sscopename
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  SScopeId,      // 0xFFFFFFFF == invalid scope id, dont use for search
    IN      LPWSTR                 SScopeName,    // NULL == invalid scope name
    OUT     PM_SSCOPE             *SScope
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    PM_SSCOPE                      ThisSScope;

    AssertRet(Server && SScope, ERROR_INVALID_PARAMETER);
    AssertRet(SScopeId != INVALID_SSCOPE_ID || SScopeName != INVALID_SSCOPE_NAME, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(&Server->SuperScopes, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Server->SuperScopes, &Loc, &ThisSScope);
        Require(ERROR_SUCCESS == Error && ThisSScope);

        if( ThisSScope->SScopeId == SScopeId ||
            (INVALID_SSCOPE_NAME != SScopeName && 0 == wcscmp(ThisSScope->Name, SScopeName) )) {
            *SScope = ThisSScope;
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(&Server->SuperScopes, &Loc);
    }
    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemServerAddSScope(
    IN OUT  PM_SERVER              Server,
    IN      PM_SSCOPE              SScope
) //EndExport(function)
{
    DWORD                          Error;
    PM_SSCOPE                      OldSScope;

    AssertRet(
        Server && SScope && INVALID_SSCOPE_ID != SScope->SScopeId && INVALID_SSCOPE_NAME != SScope->Name,
        ERROR_INVALID_PARAMETER
    );

    Error = MemServerFindSScope(
        Server,
        SScope->SScopeId,
        SScope->Name,
        &OldSScope
    );
    if( ERROR_SUCCESS == Error && OldSScope ) return ERROR_OBJECT_ALREADY_EXISTS;

    Error = MemArrayAddElement(&Server->SuperScopes, SScope);
    return Error;
}

//BeginExport(function)
DWORD
MemServerDelSScope(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  SScopeId,
    OUT     PM_SSCOPE             *SScope
) //EndExport(function)
{
    DWORD                          Error;
    ARRAY_LOCATION                 Loc;
    PM_SSCOPE                      ThisSScope;

    AssertRet(Server && SScope && INVALID_SSCOPE_ID != SScopeId, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(&Server->SuperScopes, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Server->SuperScopes, &Loc, (LPVOID *)&ThisSScope);
        Require(ERROR_SUCCESS == Error && ThisSScope );

        if( ThisSScope->SScopeId == SScopeId ) {
            Error = MemArrayDelElement(&Server->SuperScopes, &Loc, (LPVOID *)SScope);
            Require(ERROR_SUCCESS == Error && *SScope == ThisSScope);

            return Error;
        }

        Error = MemArrayNextLoc(&Server->SuperScopes, &Loc);
    }
    return ERROR_FILE_NOT_FOUND;
}

//================================================================================
// MCAST scope functionality
//================================================================================

//BeginExport(constants)
#define     INVALID_MSCOPE_ID      0x0
#define     INVALID_MSCOPE_NAME    NULL
//EndExport(constants)

//BeginExport(function)
DWORD
MemServerFindMScope(                              // search either based on ScopeId or ScopeName
    IN      PM_SERVER              Server,
    IN      DWORD                  MScopeId,      // Multicast scope id, or 0 if this is not the key to search on
    IN      LPWSTR                 Name,          // Multicast scope name or NULL if this is not the key to search on
    OUT     PM_MSCOPE             *MScope
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    PM_MSCOPE                      ThisMScope;

    AssertRet(Server && MScope, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(&Server->MScopes, &Loc);
    while (ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Server->MScopes, &Loc, &ThisMScope);
        Require(ERROR_SUCCESS == Error && ThisMScope );

        if( MScopeId == ThisMScope->MScopeId ||
            (Name !=  INVALID_MSCOPE_NAME && 0 == wcscmp(Name, ThisMScope->Name)) ) {
            *MScope = ThisMScope;
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(&Server->MScopes, &Loc);
    }
    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemServerAddMScope(
    IN OUT  PM_SERVER              Server,
    IN OUT  PM_MSCOPE              MScope
) //EndExport(function)
{
    DWORD                          Error;
    PM_MSCOPE                      OldMScope;

    AssertRet(Server && MScope, ERROR_INVALID_PARAMETER);
    AssertRet(MScope->MScopeId != INVALID_MSCOPE_ID && MScope->Name != INVALID_MSCOPE_NAME, ERROR_INVALID_PARAMETER);

    MScope->ServerPtr = Server;                   // set the backptr for future use
    Error = MemServerFindMScope(
        Server,
        MScope->Address,
        MScope->Name,
        &OldMScope
    );

    if( ERROR_SUCCESS == Error && OldMScope ) return ERROR_OBJECT_ALREADY_EXISTS;

    Error = MemArrayAddElement(&Server->MScopes, (LPVOID)MScope);
    Require(ERROR_SUCCESS == Error);

    return Error;
}


//BeginExport(function)
DWORD
MemServerDelMScope(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  MScopeId,
    IN      LPWSTR                 MScopeName,
    OUT     PM_MSCOPE             *MScope
) //EndExport(function)
{
    DWORD                          Error;
    ARRAY_LOCATION                 Loc;
    PM_MSCOPE                      ThisMScope;

    AssertRet(Server && MScope && (MScopeId != INVALID_MSCOPE_ID || MScopeName != INVALID_MSCOPE_NAME),
              ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(&Server->MScopes, &Loc);
    while (ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Server->MScopes, &Loc, &ThisMScope);
        Require(ERROR_SUCCESS == Error && ThisMScope );

        if ( INVALID_MSCOPE_ID != MScopeId ) {
            if( MScopeId == ThisMScope->MScopeId ) {
                Error = MemArrayDelElement(&Server->MScopes, &Loc, MScope);
                Require(ERROR_SUCCESS == Error && *MScope == ThisMScope);

                return Error;
            }
        }

        if ( INVALID_MSCOPE_NAME != MScopeName ) {
            if( !wcscmp(MScopeName, ThisMScope->Name ) ) {
                Error = MemArrayDelElement(&Server->MScopes, &Loc, MScope);
                Require(ERROR_SUCCESS == Error && *MScope == ThisMScope);

                return Error;
            }
        }

        Error = MemArrayNextLoc(&Server->MScopes, &Loc);
    }
    return ERROR_FILE_NOT_FOUND;
}

//================================================================================
// ClassId related stuff
//================================================================================

//BeginExport(inline)
DWORD       _inline
MemServerGetClassDef(                             // look up a class id def on Key=ClassId or Key=ClassIdBytes
    IN      PM_SERVER              Server,
    IN      DWORD                  ClassId,       // OPTIONAL, 0 if not used
    IN      LPWSTR                 Name,          // OPTIONAL, NULL if not used
    IN      DWORD                  nClassIdBytes, // OPTIONAL, 0 if not used
    IN      LPBYTE                 ClassIdBytes,  // OPTIONAL, NULL if not used
    OUT     PM_CLASSDEF           *ClassDef
) {
    AssertRet(Server && ClassDef && (0 != ClassId || 0 != nClassIdBytes || Name ), ERROR_INVALID_PARAMETER);
    AssertRet( 0 == nClassIdBytes || NULL != ClassIdBytes, ERROR_INVALID_PARAMETER);
    AssertRet( 0 != nClassIdBytes || NULL == ClassIdBytes, ERROR_INVALID_PARAMETER);

    return MemClassDefListFindOptDef(
        &Server->ClassDefs,
        ClassId,
        Name,
        ClassIdBytes,
        nClassIdBytes,
        ClassDef
    );
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemServerAddClassDef(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  ClassId,
    IN      BOOL                   IsVendor,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      DWORD                  nClassIdBytes,
    IN      LPBYTE                 ClassIdBytes
) {
    AssertRet(Server, ERROR_INVALID_PARAMETER);

    return MemClassDefListAddClassDef(
        &Server->ClassDefs,
        ClassId,
        IsVendor,
        0,
        Name,
        Comment,
        ClassIdBytes,
        nClassIdBytes
    );
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemServerDelClassDef(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  ClassId,
    IN      LPWSTR                 Name,
    IN      DWORD                  nClassIdBytes,
    IN      LPBYTE                 ClassIdBytes
) {
    AssertRet(Server, ERROR_INVALID_PARAMETER);

    return MemClassDefListDelClassDef(
        &Server->ClassDefs,
        ClassId,
        Name,
        ClassIdBytes,
        nClassIdBytes
    );
}
//EndExport(inline)

//BeginExport(function)
DWORD
MemServerGetOptDef(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  ClassId,       // required, strict search, no defaulting class to zero
    IN      DWORD                  VendorId,      // required, strict search, no defaulting vendor to zero
    IN      DWORD                  OptId,         // OPTIONAL - search by this or following param
    IN      LPWSTR                 OptName,       // OPTIONAL - search by name or above param
    OUT     PM_OPTDEF             *OptDef         // if found return the opt def here
) //EndExport(function)
{
    DWORD                          Error;
    PM_OPTDEFLIST                  OptDefList;

    Require(OptDef);

    Error = MemOptClassDefListFindOptDefList(
        &Server->OptDefs,
        ClassId,
        VendorId,
        &OptDefList
    );
    if( ERROR_SUCCESS != Error ) return Error;

    Require(OptDefList);

    return MemOptDefListFindOptDef(
        OptDefList,
        OptId,
        OptName,
        OptDef
    );
}

//BeginExport(function)
DWORD
MemServerAddOptDef(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    IN      DWORD                  OptId,
    IN      LPWSTR                 OptName,
    IN      LPWSTR                 OptComment,
    IN      DWORD                  Type,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptValLen
) //EndExport(function)
{
    DWORD                          Error;
    PM_OPTDEF                      OptDef;

    //    Error = MemServerGetOptDef(
    //    IN  Server,
    //    IN  ClassId,
    //    IN  OptName,
    //    IN  &OptDef
    //    );
    //
    //    if( ERROR_SUCCESS == Error ) {
    //        return ERROR_OBJECT_ALREADY_EXISTS;
    //    }
    //
    return MemOptClassDefListAddOptDef(
        &Server->OptDefs,
        ClassId,
        VendorId,
        OptId,
        Type,
        OptName,
        OptComment,
        OptVal,
        OptValLen
    );
}

//BeginExport(function)
DWORD
MemServerDelOptDef(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    IN      DWORD                  OptId
) //EndExport(function)
{
    DWORD                          Error;
    PM_OPTDEFLIST                  OptDefList;

    Error = MemOptClassDefListFindOptDefList(
        &Server->OptDefs,
        ClassId,
        VendorId,
        &OptDefList
    );
    if( ERROR_SUCCESS != Error ) return Error;

    return MemOptDefListDelOptDef(
        OptDefList,
        OptId
    );
}


//================================================================================
// end of File
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\reserve.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for superscopes
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include    <mm.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>

//BeginExport(typedef)
typedef struct _M_RESERVATION  {
    LPVOID                         SubnetPtr;
    DWORD                          Address;
    DWORD                          Flags;
    DWORD                          nBytes;
    LPBYTE                         ClientUID;
    M_OPTCLASS                     Options;
} M_RESERVATION , *PM_RESERVATION , *LPM_RESERVATION ;
//EndExport(typedef)

//BeginExport(typedef)
typedef ARRAY                      M_RESERVATIONS;
typedef PARRAY                     PM_RESERVATIONS;
typedef LPARRAY                    LPM_RESERVATIONS;
//EndExport(typedef)

//BeginExport(inline)
DWORD       _inline
MemReserve1Init(
    OUT     PM_RESERVATION        *Reservation,
    IN      DWORD                  Address,
    IN      DWORD                  Flags,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  nBytesClientUID
) {
    PM_RESERVATION                 Res1;
    DWORD                          Size;
    DWORD                          Error;

    AssertRet(Reservation && ClientUID && nBytesClientUID, ERROR_INVALID_PARAMETER);
    Require(Address);

    *Reservation = NULL;

    Size = ROUND_UP_COUNT(sizeof(M_RESERVATION ), ALIGN_WORST);
    Size += nBytesClientUID;

    Res1 = MemAlloc(Size);
    if( NULL == Res1 ) return ERROR_NOT_ENOUGH_MEMORY;

    Res1->SubnetPtr = NULL;
    Res1->Address   = Address;
    Res1->Flags     = Flags;
    Res1->nBytes    = nBytesClientUID;
    Res1->ClientUID = Size - nBytesClientUID + (LPBYTE)Res1;
    memcpy(Res1->ClientUID, ClientUID, nBytesClientUID);
    Error = MemOptClassInit(&(Res1->Options));
    Require(ERROR_SUCCESS == Error);

    *Reservation = Res1;

    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemReserve1Cleanup(
    IN      PM_RESERVATION         Reservation
) {
    DWORD                          Error;
    AssertRet(Reservation, ERROR_INVALID_PARAMETER);

    Error = MemOptClassCleanup(&(Reservation->Options));
    Require(ERROR_SUCCESS == Error);

    MemFree(Reservation);
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemReserveInit(
    IN OUT  PM_RESERVATIONS        Reservation
) {
    return MemArrayInit(Reservation);
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemReserveCleanup(
    IN      PM_RESERVATIONS        Reservation
) {
    return MemArrayCleanup(Reservation);
}
//EndExport(inline)

//BeginExport(function)
DWORD
MemReserveAdd(                                    // new client, should not exist before
    IN OUT  PM_RESERVATIONS        Reservation,
    IN      DWORD                  Address,
    IN      DWORD                  Flags,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDSize
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          LocalError;
    PM_RESERVATION                 Res1;
    ARRAY_LOCATION                 Loc;

    AssertRet(Reservation && Address && ClientUID && ClientUIDSize, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(Reservation, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {      // check to see if this Address already exists
        Require(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(Reservation, &Loc, &Res1);
        Require(ERROR_SUCCESS == Error && Res1);

        if( Address == Res1->Address ) return ERROR_OBJECT_ALREADY_EXISTS;
        if( ClientUIDSize == Res1->nBytes && 0 == memcmp(ClientUID, Res1->ClientUID, Res1->nBytes) )
            return ERROR_OBJECT_ALREADY_EXISTS;

        Error = MemArrayNextLoc(Reservation, &Loc);
    }

    Error = MemReserve1Init(
        &Res1,
        Address,
        Flags,
        ClientUID,
        ClientUIDSize
    );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemArrayAddElement(Reservation, Res1);
    if( ERROR_SUCCESS == Error ) return ERROR_SUCCESS;

    LocalError = MemReserve1Cleanup(Res1);
    Require(ERROR_SUCCESS == LocalError);

    return Error;
}

//BeginExport(function)
DWORD
MemReserveReplace(                                // old client, should exist before
    IN OUT  PM_RESERVATIONS        Reservation,
    IN      DWORD                  Address,
    IN      DWORD                  Flags,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDSize
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          LocalError;
    PM_RESERVATION                 Res1, Res_Deleted;
    ARRAY_LOCATION                 Loc;

    AssertRet(Reservation && Address && ClientUID && ClientUIDSize, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(Reservation, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {      // check to see if this Address already exists
        Require(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(Reservation, &Loc, &Res1);
        Require(ERROR_SUCCESS == Error && Res1);

        if( Address == Res1->Address ) {
            Error = MemArrayDelElement(Reservation, &Loc, (LPVOID *)&Res_Deleted);
            Require(ERROR_SUCCESS == Error && Res_Deleted);
            break;
        }

        Error = MemArrayNextLoc(Reservation, &Loc);
    }

    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemReserve1Init(
        &Res1,
        Address,
        Flags,
        ClientUID,
        ClientUIDSize
    );
    if( ERROR_SUCCESS != Error ) {
        LocalError = MemArrayAddElement(Reservation, Res_Deleted);
        Require(ERROR_SUCCESS == LocalError);     // just deleted this guy -- should not have trouble adding back
        return Error;
    }

    Res1->Options = Res_Deleted->Options;
    
    Res1->SubnetPtr = Res_Deleted->SubnetPtr;
    MemFree(Res_Deleted);

    Error = MemArrayAddElement(Reservation, Res1);
    if( ERROR_SUCCESS == Error ) return ERROR_SUCCESS;

    LocalError = MemReserve1Cleanup(Res1);
    Require(ERROR_SUCCESS == LocalError);

    return Error;
}

//BeginExport(function)
DWORD
MemReserveDel(
    IN OUT  PM_RESERVATIONS        Reservation,
    IN      DWORD                  Address
) //EndExport(function)
{
    DWORD                          Error;
    PM_RESERVATION                 Res1;
    ARRAY_LOCATION                 Loc;

    AssertRet(Reservation && Address, ERROR_INVALID_PARAMETER);

    Error = MemArrayInitLoc(Reservation, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {      // check to see if this Address already exists
        Require(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(Reservation, &Loc, &Res1);
        Require(ERROR_SUCCESS == Error && Res1);

        if( Address == Res1->Address ) {
            Error = MemArrayDelElement(Reservation, &Loc, (LPVOID *)&Res1);
            Require(ERROR_SUCCESS == Error && Res1);

            Error = MemReserve1Cleanup(Res1);
            Require(ERROR_SUCCESS == Error);

            return Error;
        }

        Error = MemArrayNextLoc(Reservation, &Loc);
    }

    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemReserveFindByClientUID(
    IN      PM_RESERVATIONS        Reservation,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDSize,
    OUT     PM_RESERVATION        *Res
) //EndExport(function)
{
    DWORD                          Error;
    PM_RESERVATION                 Res1;
    ARRAY_LOCATION                 Loc;

    AssertRet(Reservation && Res && ClientUID && ClientUIDSize, ERROR_INVALID_PARAMETER);
    *Res = NULL;

    Error = MemArrayInitLoc(Reservation, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {      // check to see if this Address already exists
        Require(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(Reservation, &Loc, &Res1);
        Require(ERROR_SUCCESS == Error && Res1);

        if( ClientUIDSize == Res1->nBytes && 0 == memcmp(ClientUID, Res1->ClientUID, ClientUIDSize)) {
            *Res = Res1;
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(Reservation, &Loc);
    }

    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemReserveFindByAddress(
    IN      PM_RESERVATIONS        Reservation,
    IN      DWORD                  Address,
    OUT     PM_RESERVATION        *Res
) //EndExport(function)
{
    DWORD                          Error;
    PM_RESERVATION                 Res1;
    ARRAY_LOCATION                 Loc;

    AssertRet(Reservation && Address, ERROR_INVALID_PARAMETER);
    *Res = 0;

    Error = MemArrayInitLoc(Reservation, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {      // check to see if this Address already exists
        Require(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(Reservation, &Loc, &Res1);
        Require(ERROR_SUCCESS == Error && Res1);

        if( Address == Res1->Address ) {
            *Res = Res1;
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(Reservation, &Loc);
    }

    return ERROR_FILE_NOT_FOUND;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\server.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#include    <dhcp.h>


typedef struct _M_SERVER {
    DWORD                          Address;
    DWORD                          State;
    DWORD                          Policy;
    ARRAY                          Subnets;
    ARRAY                          MScopes;
    ARRAY_LOCATION                 Loc;           // if RoundRobin on, then we need this to keep track
    ARRAY                          SuperScopes;
    M_OPTCLASS                     Options;
    M_OPTCLASSDEFLIST              OptDefs;
    M_CLASSDEFLIST                 ClassDefs;
    LPWSTR                         Name;
    LPWSTR                         Comment;
} M_SERVER, *PM_SERVER, *LPM_SERVER;


DWORD
MemServerInit(
    OUT     PM_SERVER             *Server,
    IN      DWORD                  Address,
    IN      DWORD                  State,
    IN      DWORD                  Policy,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment
) ;


DWORD
MemServerCleanup(
    IN OUT  PM_SERVER              Server
) ;


DWORD
MemServerGetUAddressInfo(
    IN      PM_SERVER              Server,
    IN      DWORD                  Address,
    OUT     PM_SUBNET             *Subnet,        // OPTIONAL
    OUT     PM_RANGE              *Range,         // OPTIONAL
    OUT     PM_EXCL               *Excl,          // OPTIONAL
    OUT     PM_RESERVATION        *Reservation    // OPTIONAL
) ;


DWORD
MemServerGetMAddressInfo(
    IN      PM_SERVER              Server,
    IN      DWORD                  Address,
    OUT     PM_SUBNET             *Subnet,        // OPTIONAL
    OUT     PM_RANGE              *Range,         // OPTIONAL
    OUT     PM_EXCL               *Excl,          // OPTIONAL
    OUT     PM_RESERVATION        *Reservation    // OPTIONAL
) ;


DWORD       _inline
MemServerGetAddressInfo(
    IN      PM_SERVER              Server,
    IN      DWORD                  Address,
    OUT     PM_SUBNET             *Subnet,        // OPTIONAL
    OUT     PM_RANGE              *Range,         // OPTIONAL
    OUT     PM_EXCL               *Excl,          // OPTIONAL
    OUT     PM_RESERVATION        *Reservation    // OPTIONAL
) {
    if (CLASSD_HOST_ADDR( Address )) {
        return MemServerGetMAddressInfo(
                    Server,
                    Address,
                    Subnet,
                    Range,
                    Excl,
                    Reservation
                    );
    } else {
        return MemServerGetUAddressInfo(
                    Server,
                    Address,
                    Subnet,
                    Range,
                    Excl,
                    Reservation
                    );
    }

}


DWORD
MemServerAddSubnet(
    IN OUT  PM_SERVER              Server,
    IN      PM_SUBNET              Subnet         // completely created subnet, must not be in Server's list tho'
) ;


DWORD
MemServerDelSubnet(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  SubnetAddress,
    OUT     PM_SUBNET             *Subnet
) ;


DWORD
MemServerFindSubnetByName(
    IN      PM_SERVER              Server,
    IN      LPWSTR                 Name,
    OUT     PM_SUBNET             *Subnet
) ;


#define     INVALID_SSCOPE_ID      0xFFFFFFFF
#define     INVALID_SSCOPE_NAME    NULL


DWORD
MemServerFindSScope(                              // find matching with EITHER scopeid ir sscopename
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  SScopeId,      // 0xFFFFFFFF == invalid scope id, dont use for search
    IN      LPWSTR                 SScopeName,    // NULL == invalid scope name
    OUT     PM_SSCOPE             *SScope
) ;


DWORD
MemServerAddSScope(
    IN OUT  PM_SERVER              Server,
    IN      PM_SSCOPE              SScope
) ;


DWORD
MemServerDelSScope(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  SScopeId,
    OUT     PM_SSCOPE             *SScope
) ;


#define     INVALID_MSCOPE_ID      0x0
#define     INVALID_MSCOPE_NAME    NULL


DWORD
MemServerFindMScope(                              // search either based on ScopeId or ScopeName
    IN      PM_SERVER              Server,
    IN      DWORD                  MScopeId,      // Multicast scope id, or 0 if this is not the key to search on
    IN      LPWSTR                 Name,          // Multicast scope name or NULL if this is not the key to search on
    OUT     PM_MSCOPE             *MScope
) ;


DWORD
MemServerAddMScope(
    IN OUT  PM_SERVER              Server,
    IN OUT  PM_MSCOPE              MScope
) ;


DWORD
MemServerDelMScope(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  MScopeId,
    IN      LPWSTR                 MScopeName,
    OUT     PM_MSCOPE             *MScope
) ;


DWORD       _inline
MemServerGetClassDef(                             // look up a class id def on Key=ClassId or Key=ClassIdBytes
    IN      PM_SERVER              Server,
    IN      DWORD                  ClassId,       // OPTIONAL, 0 if not used
    IN      LPWSTR                 Name,          // OPTIONAL, NULL if not used
    IN      DWORD                  nClassIdBytes, // OPTIONAL, 0 if not used
    IN      LPBYTE                 ClassIdBytes,  // OPTIONAL, NULL if not used
    OUT     PM_CLASSDEF           *ClassDef
) {
    AssertRet(Server && ClassDef && (0 != ClassId || 0 != nClassIdBytes || Name ), ERROR_INVALID_PARAMETER);
    AssertRet( 0 == nClassIdBytes || NULL != ClassIdBytes, ERROR_INVALID_PARAMETER);
    AssertRet( 0 != nClassIdBytes || NULL == ClassIdBytes, ERROR_INVALID_PARAMETER);

    return MemClassDefListFindOptDef(
        &Server->ClassDefs,
        ClassId,
        Name,
        ClassIdBytes,
        nClassIdBytes,
        ClassDef
    );
}


DWORD       _inline
MemServerAddClassDef(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  ClassId,
    IN      BOOL                   IsVendor,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      DWORD                  nClassIdBytes,
    IN      LPBYTE                 ClassIdBytes
) {
    AssertRet(Server, ERROR_INVALID_PARAMETER);

    return MemClassDefListAddClassDef(
        &Server->ClassDefs,
        ClassId,
        IsVendor,
        0,
        Name,
        Comment,
        ClassIdBytes,
        nClassIdBytes
    );
}


DWORD       _inline
MemServerDelClassDef(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  ClassId,
    IN      LPWSTR                 Name,
    IN      DWORD                  nClassIdBytes,
    IN      LPBYTE                 ClassIdBytes
) {
    AssertRet(Server, ERROR_INVALID_PARAMETER);

    return MemClassDefListDelClassDef(
        &Server->ClassDefs,
        ClassId,
        Name,
        ClassIdBytes,
        nClassIdBytes
    );
}


DWORD
MemServerGetOptDef(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  ClassId,       // required, strict search, no defaulting class to zero
    IN      DWORD                  VendorId,      // required, strict search, no defaulting vendor to zero
    IN      DWORD                  OptId,         // OPTIONAL - search by this or following param
    IN      LPWSTR                 OptName,       // OPTIONAL - search by name or above param
    OUT     PM_OPTDEF             *OptDef         // if found return the opt def here
) ;


DWORD
MemServerAddOptDef(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    IN      DWORD                  OptId,
    IN      LPWSTR                 OptName,
    IN      LPWSTR                 OptComment,
    IN      DWORD                  Type,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptValLen
) ;


DWORD
MemServerDelOptDef(
    IN OUT  PM_SERVER              Server,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    IN      DWORD                  OptId
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\server2.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the overall access api's (most of them)
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include    <mm.h>
#include    <winbase.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>
#include    <bitmask.h>
#include    <range.h>
#include    <reserve.h>
#include    <subnet.h>
#include    <optdefl.h>
#include    <classdefl.h>
#include    <oclassdl.h>
#include    <sscope.h>
#include    <server.h>
#include    <address.h>


//BeginExport(function)
BOOL
MemServerIsSwitchedSubnet(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    Error =  MemServerGetAddressInfo(
        Server,
        AnyIpAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return FALSE;

    return IS_SWITCHED(Subnet->State);
}

//BeginExport(function)
BOOL
MemServerIsSubnetDisabled(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    Error =  MemServerGetAddressInfo(
        Server,
        AnyIpAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return FALSE;

    return IS_DISABLED(Subnet->State);
}

//BeginExport(function)
BOOL
MemServerIsExcludedAddress(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) //EndExport(function)
{
    DWORD                          Error;
    PM_EXCL                        Excl;

    Error =  MemServerGetAddressInfo(
        Server,
        AnyIpAddress,
        NULL,
        NULL,
        &Excl,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return FALSE;

    return (NULL != Excl);
}

//BeginExport(function)
BOOL
MemServerIsReservedAddress(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) //EndExport(function)
{
    DWORD                          Error;
    PM_RESERVATION                 Reservation;

    Error = MemServerGetAddressInfo(
        Server,
        AnyIpAddress,
        NULL,
        NULL,
        NULL,
        &Reservation
    );
    if( ERROR_SUCCESS != Error ) return FALSE;

    return NULL != Reservation;
}


//BeginExport(function)
BOOL
MemServerIsOutOfRangeAddress(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress,
    IN      BOOL                   fBootp
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;
    PM_RANGE                       Range;

    Error =  MemServerGetAddressInfo(
        Server,
        AnyIpAddress,
        &Subnet,
        &Range,
        NULL,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return TRUE;

    if( NULL == Range ) return TRUE;
    if( 0 == (Range->State & (fBootp? MM_FLAG_ALLOW_BOOTP : MM_FLAG_ALLOW_DHCP) ) ) {
        return TRUE;
    }
    return FALSE;
}

//BeginExport(function)
DWORD
MemServerGetSubnetMaskForAddress(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    Error =  MemServerGetAddressInfo(
        Server,
        AnyIpAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return 0;

    Require(Subnet);
    return Subnet->Mask;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\server2.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

BOOL
MemServerIsSwitchedSubnet(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) ;


BOOL
MemServerIsSubnetDisabled(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) ;


BOOL
MemServerIsExcludedAddress(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) ;


BOOL
MemServerIsReservedAddress(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) ;


BOOL
MemServerIsOutOfRangeAddress(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress,
    IN      BOOL                   fBootp
) ;


DWORD
MemServerGetSubnetMaskForAddress(
    IN      PM_SERVER              Server,
    IN      DWORD                  AnyIpAddress
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\sscope.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

typedef struct _M_SSCOPE {
    DWORD                          SScopeId;
    DWORD                          Policy;
    LPWSTR                         Name;
    M_OPTCLASS                     Options;
} M_SSCOPE, *PM_SSCOPE, *LPM_SSCOPE;


extern      ULONG                  ScopeIdCount;


DWORD       _inline
MemSScopeInit(
    OUT     PM_SSCOPE             *SScope,
    IN      DWORD                  Policy,
    IN      LPWSTR                 Name
) {
    PM_SSCOPE                      RetVal;
    DWORD                          Size;
    DWORD                          Error;

    AssertRet(SScope, ERROR_INVALID_PARAMETER);

    Size = ROUND_UP_COUNT(sizeof(M_SSCOPE), ALIGN_WORST);
    Size += (1+wcslen(Name))*sizeof(WCHAR);

    RetVal = MemAlloc(Size);
    if( NULL == RetVal ) return ERROR_NOT_ENOUGH_MEMORY;

    RetVal->SScopeId = InterlockedIncrement(&ScopeIdCount);
    RetVal->Policy   = Policy;
    RetVal->Name = (LPWSTR)(ROUND_UP_COUNT(sizeof(M_SSCOPE),ALIGN_WORST) + (LPBYTE)RetVal);
    wcscpy(RetVal->Name, Name);

    Error = MemOptClassInit(&RetVal->Options);
    if( ERROR_SUCCESS != Error ) {
        MemFree(RetVal);
        RetVal = NULL;
    }

    *SScope = RetVal;
    return Error;
}


DWORD       _inline
MemSScopeCleanup(
    IN OUT  PM_SSCOPE              SScope
) {
    DWORD                          Error;

    AssertRet(SScope, ERROR_INVALID_PARAMETER);

    Error = MemOptClassCleanup(&SScope->Options);
    MemFree(SScope);

    return Error;
}


DWORD       _inline
MemSubnetSetSuperScope(
    IN OUT  PM_SUBNET              Subnet,
    IN      PM_SSCOPE              SScope
) {
    AssertRet(Subnet && SScope, ERROR_INVALID_PARAMETER);

    Subnet->SuperScopeId = SScope->SScopeId;
    return ERROR_SUCCESS;
}

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\sscope.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for superscopes
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include    <mm.h>
#include    <winbase.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>
#include    <bitmask.h>
#include    <range.h>
#include    <reserve.h>
#include    <subnet.h>

//BeginExport(typedef)
typedef struct _M_SSCOPE {
    DWORD                          SScopeId;
    DWORD                          Policy;
    LPWSTR                         Name;
    M_OPTCLASS                     Options;
} M_SSCOPE, *PM_SSCOPE, *LPM_SSCOPE;
//EndExport(typedef)

ULONG                  ScopeIdCount = 1;
//BeginExport(extern)
extern      ULONG                  ScopeIdCount;
//EndExport(extern)

//BeginExport(inline)
DWORD       _inline
MemSScopeInit(
    OUT     PM_SSCOPE             *SScope,
    IN      DWORD                  Policy,
    IN      LPWSTR                 Name
) {
    PM_SSCOPE                      RetVal;
    DWORD                          Size;
    DWORD                          Error;

    AssertRet(SScope, ERROR_INVALID_PARAMETER);

    Size = ROUND_UP_COUNT(sizeof(M_SSCOPE), ALIGN_WORST);
    Size += (1+wcslen(Name))*sizeof(WCHAR);

    RetVal = MemAlloc(Size);
    if( NULL == RetVal ) return ERROR_NOT_ENOUGH_MEMORY;

    RetVal->SScopeId = InterlockedIncrement(&ScopeIdCount);
    RetVal->Policy   = Policy;
    RetVal->Name = (LPWSTR)(ROUND_UP_COUNT(sizeof(M_SSCOPE),ALIGN_WORST) + (LPBYTE)RetVal);
    wcscpy(RetVal->Name, Name);

    Error = MemOptClassInit(&RetVal->Options);
    if( ERROR_SUCCESS != Error ) {
        MemFree(RetVal);
        RetVal = NULL;
    }

    *SScope = RetVal;
    return Error;
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemSScopeCleanup(
    IN OUT  PM_SSCOPE              SScope
) {
    DWORD                          Error;

    AssertRet(SScope, ERROR_INVALID_PARAMETER);

    Error = MemOptClassCleanup(&SScope->Options);
    MemFree(SScope);

    return Error;
}
//EndExport(inline)

//BeginExport(inline)
DWORD       _inline
MemSubnetSetSuperScope(
    IN OUT  PM_SUBNET              Subnet,
    IN      PM_SSCOPE              SScope
) {
    AssertRet(Subnet && SScope, ERROR_INVALID_PARAMETER);

    Subnet->SuperScopeId = SScope->SScopeId;
    return ERROR_SUCCESS;
}
//EndExport(inline)

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\subnet.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This file has been generated. Pl look at the .c file
//========================================================================

typedef struct _M_SUBNET {
    LPVOID                         ServerPtr;     // Ptr to Server object
    union {
        struct {                                  // for normal subnet.
            DWORD                      Address;
            DWORD                      Mask;
            DWORD                      SuperScopeId;  // unused for MCAST scopes
        };
        struct {                                  // for multicast scope
            DWORD                      MScopeId;
            LPWSTR                     LangTag;       // the language tag for multicast scope
            BYTE                       TTL;
        };
    };
    DWORD                          fSubnet;       // TRUE => Subnet, FALSE => MSCOPE
    DWORD                          State;
    DWORD                          Policy;
    DATE_TIME                      ExpiryTime;     // Scope Lifetime. Currently used for MCast only.
    M_OPTCLASS                     Options;
    ARRAY                          Ranges;
    ARRAY                          Exclusions;
    M_RESERVATIONS                 Reservations;
    ARRAY                          Servers;       // future use, Server-Server protocol
    LPWSTR                         Name;
    LPWSTR                         Description;
} M_SUBNET, *PM_SUBNET, *LPM_SUBNET;


enum /* Anonymous */ {
    AddressPolicyNone = 0,
    AddressPolicySequential,
    AddressPolicyRoundRobin
};


DWORD
MemSubnetInit(
    OUT     PM_SUBNET             *pSubnet,
    IN      DWORD                  Address,
    IN      DWORD                  Mask,
    IN      DWORD                  State,
    IN      DWORD                  SuperScopeId,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Description
) ;


DWORD
MemMScopeInit(
    OUT     PM_SUBNET             *pMScope,
    IN      DWORD                  MScopeId,
    IN      DWORD                  State,
    IN      DWORD                  AddressPolicy,
    IN      BYTE                   TTL,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Description,
    IN      LPWSTR                 LangTag,
    IN      DATE_TIME              ExpiryTime
) ;


DWORD       _inline
MemSubnetCleanup(
    IN OUT  PM_SUBNET              Subnet
)
{
    DWORD                          Error;

    AssertRet(Subnet, ERROR_INVALID_PARAMETER);
    Require(Subnet->Address&Subnet->Mask);

    Error = MemOptClassCleanup(&Subnet->Options);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemArrayCleanup(&Subnet->Ranges);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemArrayCleanup(&Subnet->Exclusions);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemArrayCleanup(&Subnet->Servers);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemReserveCleanup(&Subnet->Reservations);
    if( ERROR_SUCCESS != Error ) return Error;

    MemFree(Subnet);
    return ERROR_SUCCESS;
}


DWORD                                             // SUCCESS if either of Excl or Range get filled, else FILE_NOT_FOUND
MemSubnetGetAddressInfo(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  Address,
    OUT     PM_RANGE              *Range,         // OPTIONAL -- filled if a range could be found -- even if excluded
    OUT     PM_EXCL               *Excl,          // OPTIONAL -- filled if an exclusion could be found
    OUT     PM_RESERVATION        *Reservation    // OPTIONAL -- filled with  a matching reservation, if found
) ;


DWORD                                             // ERROR_SUCCESS on finding a collition, else ERROR_FILE_NOT_FOUND
MemSubnetFindCollision(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start,
    IN      DWORD                  End,
    OUT     PM_RANGE              *Range,         // OPTIONAL
    OUT     PM_EXCL               *Excl           // OPTIONAL
) ;


DWORD                                             // ERROR_OBJECT_ALREADY_EXISTS on collision
MemSubnetAddRange(                                // check if the range is valid, and only then add it
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start,
    IN      DWORD                  End,
    IN      DWORD                  State,
    IN      ULONG                  BootpAllocated,
    IN      ULONG                  MaxBootpAllowed,
    OUT     PM_RANGE              *OverlappingRange
) ;


DWORD
MemSubnetAddRangeExpandOrContract(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  StartAddress,
    IN      DWORD                  EndAddress,
    OUT     DWORD                 *OldStartAddress,
    OUT     DWORD                 *OldEndAddress
) ;


DWORD
MemSubnetAddExcl(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start,
    IN      DWORD                  End,
    OUT     PM_EXCL               *OverlappingExcl
) ;


DWORD
MemSubnetDelRange(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start
) ;


DWORD
MemSubnetDelExcl(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start
) ;


DWORD
MemSubnetExtendOrContractRange(
    IN OUT  PM_SUBNET              Subnet,
    IN OUT  PM_RANGE               Range,
    IN      DWORD                  nAddresses,    // how many addresses to extend by
    IN      BOOL                   fExtend,       // is this an EXTEND? or a CONTRACT?
    IN      BOOL                   fEnd           // is this operation to be done to END of range or START?
) ;


DWORD
MemSubnetExtendOrContractExcl(
    IN OUT  PM_SUBNET              Subnet,
    IN OUT  PM_EXCL                Excl,
    IN      DWORD                  nAddresses,    // how many addresses to extend by
    IN      BOOL                   fExtend,       // is this an EXTEND? or a CONTRACT?
    IN      BOOL                   fEnd           // is this operation to be done to END of range or START?
) ;


typedef     M_SUBNET               M_MSCOPE;      // same structure for Multicast Scopes and Subnets
typedef     PM_SUBNET              PM_MSCOPE;     // still, use the correct functions for MScope
typedef     LPM_SUBNET             LPM_MSCOPE;


DWORD       _inline
MemMScopeCleanup(
    IN      PM_MSCOPE              MScope
) {
    return MemSubnetCleanup(MScope);
}


#define     MemMScopeGetAddressInfo               MemSubnetGetAddressInfo
#define     MemMScopeFindCollision                MemSubnetFindCollision
#define     MemMScopeAddExcl                      MemSubnetAddExcl
#define     MemMScopeDelRange                     MemSubnetDelRange
#define     MemMScopeDelExcl                      MemSubnetDelExcl
#define     MemMScopeExtendOrContractRange        MemSubnetExtendOrContractRange
#define     MemMScopeExtendOrContractExcl         MemSubnetExtendOrContractExcl

DWORD
MemMScopeGetAddressInfo(
    IN      PM_MSCOPE              MScope,
    IN      DWORD                  MCastAddress,
    OUT     PM_RANGE              *Range,         // OPTIONAL -- filled if a range could be found -- even if excluded
    OUT     PM_EXCL               *Excl,          // OPTIONAL -- filled if an exclusion could be found
    OUT     PM_RESERVATION        *Reservation    // OPTIONAL -- filled with  a matching reservation, if found
);

DWORD                                             // ERROR_SUCCESS on finding a collition, else ERROR_FILE_NOT_FOUND
MemMScopeFindCollision(
    IN OUT  PM_MSCOPE              Subnet,
    IN      DWORD                  MCastStart,
    IN      DWORD                  MCastEnd,
    OUT     PM_RANGE              *Range,         // OPTIONAL
    OUT     PM_EXCL               *Excl           // OPTIONAL
);



DWORD       _inline                               // ERROR_OBJECT_ALREADY_EXISTS on collision
MemMScopeAddRange(                                // check if the range is valid, and only then add it
    IN OUT  PM_MSCOPE              Subnet,
    IN      DWORD                  MCastStart,
    IN      DWORD                  MCastEnd,
    IN      DWORD                  State,
    OUT     PM_RANGE              *OverlappingRange
)
{
    return MemSubnetAddRange(Subnet,MCastStart, MCastEnd, State, 0, 0, OverlappingRange);
}


DWORD
MemMScopeAddExcl(
    IN OUT  PM_MSCOPE              Subnet,
    IN      DWORD                  MCastStart,
    IN      DWORD                  MCastEnd,
    OUT     PM_EXCL               *OverlappingExcl
);

DWORD
MemMScopeDelRange(
    IN OUT  PM_MSCOPE              Subnet,
    IN      DWORD                  MCastStart
);

DWORD
MemMScopeDelExcl(
    IN OUT  PM_MSCOPE              Subnet,
    IN      DWORD                  MCastStart
);

DWORD
MemMScopeExtendOrContractRange(
    IN OUT  PM_MSCOPE              Subnet,
    IN OUT  PM_RANGE               Range,
    IN      DWORD                  nAddresses,    // how many addresses to extend by
    IN      BOOL                   fExtend,       // is this an EXTEND? or a CONTRACT?
    IN      BOOL                   fEnd           // is this operation to be done to END of range or START?
);

DWORD
MemMScopeExtendOrContractExcl(
    IN OUT  PM_MSCOPE              Subnet,
    IN OUT  PM_EXCL                Excl,
    IN      DWORD                  nAddresses,    // how many addresses to extend by
    IN      BOOL                   fExtend,       // is this an EXTEND? or a CONTRACT?
    IN      BOOL                   fEnd           // is this operation to be done to END of range or START?
);

//========================================================================
//  end of file
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\subnet2.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements an additional subnet function that requires a server typedef..
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include    <mm.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>
#include    <bitmask.h>
#include    <range.h>
#include    <reserve.h>
#include    <subnet.h>
#include    <optdefl.h>
#include    <classdefl.h>
#include    <oclassdl.h>
#include    <sscope.h>
#include    <server.h>

//BeginExport(function)
DWORD
MemSubnetModify(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  Address,
    IN      DWORD                  Mask,
    IN      DWORD                  State,
    IN      DWORD                  SuperScopeId,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Description
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      NewSubnet, ThisSubnet;
    PARRAY                         pArray;
    ARRAY_LOCATION                 Loc;

    AssertRet(Address == Subnet->Address, ERROR_INVALID_PARAMETER);
    Error = MemSubnetInit(
        &NewSubnet,
        Address,
        Mask,
        State,
        SuperScopeId,
        Name,
        Description
    );
    if( ERROR_SUCCESS != Error) return Error;

    Require(NULL != NewSubnet && Subnet->ServerPtr );

    if( Subnet->fSubnet ) {
        pArray = &(((PM_SERVER)(Subnet->ServerPtr))->Subnets);
    } else {
        pArray = &(((PM_SERVER)(Subnet->ServerPtr))->MScopes);
    }
    Error = MemArrayInitLoc(pArray, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(pArray, &Loc, &ThisSubnet);
        Require(ERROR_SUCCESS == Error && NULL != ThisSubnet );

        if( Subnet->Address != ThisSubnet->Address ) {
            Error = MemArrayNextLoc(pArray, &Loc);
            continue;
        }

        Require(Subnet == ThisSubnet);
        Error = MemArraySetElement(pArray, &Loc, NewSubnet);
        Require(ERROR_SUCCESS == Error);

        NewSubnet -> ServerPtr = Subnet->ServerPtr;
        NewSubnet -> Policy = Subnet->Policy;
        NewSubnet -> fSubnet = Subnet->fSubnet;
        NewSubnet -> Options = Subnet->Options;
        NewSubnet -> Ranges = Subnet->Ranges;
        NewSubnet -> Exclusions = Subnet->Exclusions;
        NewSubnet -> Reservations = Subnet->Reservations;
        NewSubnet -> Servers = Subnet->Servers;

        (void) MemFree(Subnet);
        return Error;
    }

    MemFree(NewSubnet);
    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemMScopeModify(
    IN      PM_SUBNET              MScope,
    IN      DWORD                  ScopeId,
    IN      DWORD                  State,
    IN      DWORD                  Policy,
    IN      BYTE                   TTL,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Description,
    IN      LPWSTR                 LangTag,
    IN      DATE_TIME              ExpiryTime
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      NewMScope, ThisMScope;
    PARRAY                         pArray;
    ARRAY_LOCATION                 Loc;

    AssertRet(ScopeId == MScope->MScopeId, ERROR_INVALID_PARAMETER);
    Error = MemMScopeInit(
        &NewMScope,
        ScopeId,
        State,
        Policy,
        TTL,
        Name,
        Description,
        LangTag,
        ExpiryTime
    );
    if( ERROR_SUCCESS != Error) return Error;

    Require(NULL != NewMScope && MScope->ServerPtr );

    pArray = &(((PM_SERVER)(MScope->ServerPtr))->MScopes);

    Error = MemArrayInitLoc(pArray, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(pArray, &Loc, &ThisMScope);
        Require(ERROR_SUCCESS == Error && NULL != ThisMScope );

        if( MScope->MScopeId != ThisMScope->MScopeId ) {
            Error = MemArrayNextLoc(pArray, &Loc);
            continue;
        }

        Require(MScope == ThisMScope);
        Error = MemArraySetElement(pArray, &Loc, NewMScope);
        Require(ERROR_SUCCESS == Error);

        NewMScope -> ServerPtr = MScope->ServerPtr;
        NewMScope -> Options = MScope->Options;
        NewMScope -> Ranges = MScope->Ranges;
        NewMScope -> Exclusions = MScope->Exclusions;
        NewMScope -> Reservations = MScope->Reservations;
        NewMScope -> Servers = MScope->Servers;

        (void) MemFree(MScope);
        return Error;
    }

    MemFree(NewMScope);
    return ERROR_FILE_NOT_FOUND;
}

//================================================================================
// end of file
//================================================================================

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\subnet.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: implements the basic structures for managing (multicast) scopes
// ThreadSafe: no
// Locks: none
// Please read stdinfo.txt for programming style.
//================================================================================
#include    <mm.h>
#include    <array.h>
#include    <opt.h>
#include    <optl.h>
#include    <optclass.h>
#include    <bitmask.h>
#include    <range.h>
#include    <reserve.h>
#include    <dhcp.h>
#include    <winnls.h>

//BeginExport(typedef)
typedef struct _M_SUBNET {
    LPVOID                         ServerPtr;     // Ptr to Server object
    union {
        struct {                                  // for normal subnet.
            DWORD                      Address;
            DWORD                      Mask;
            DWORD                      SuperScopeId;  // unused for MCAST scopes
        };
        struct {                                  // for multicast scope
            DWORD                      MScopeId;
            LPWSTR                     LangTag;       // the language tag for multicast scope
            BYTE                       TTL;
        };
    };
    DWORD                          fSubnet;       // TRUE => Subnet, FALSE => MSCOPE
    DWORD                          State;
    DWORD                          Policy;
    DATE_TIME                      ExpiryTime;     // Scope Lifetime. Currently used for MCast only.
    M_OPTCLASS                     Options;
    ARRAY                          Ranges;
    ARRAY                          Exclusions;
    M_RESERVATIONS                 Reservations;
    ARRAY                          Servers;       // future use, Server-Server protocol
    LPWSTR                         Name;
    LPWSTR                         Description;
} M_SUBNET, *PM_SUBNET, *LPM_SUBNET;
//EndExport(typedef)

// the following are the flags bits used for subnet object.
#define DEFAULT_SCOPE   0x01
#define IS_DEFAULT_SCOPE( _subnet )     ((_subnet)->Flags & DEFAULT_SCOPE == DEFAULT_SCOPE )
#define SET_DEFAULT_SCOPE( _subnet )    ((_subnet)->Flags |= DEFAULT_SCOPE )
#define RESET_DEFAULT_SCOPE( _subnet )  ((_subnet)->Flags &= ~DEFAULT_SCOPE)


//BeginExport(enum)
enum /* Anonymous */ {
    AddressPolicyNone = 0,
    AddressPolicySequential,
    AddressPolicyRoundRobin
};
//EndExport(enum)

//BeginExport(function)
DWORD
MemSubnetInit(
    OUT     PM_SUBNET             *pSubnet,
    IN      DWORD                  Address,
    IN      DWORD                  Mask,
    IN      DWORD                  State,
    IN      DWORD                  SuperScopeId,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Description
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Size;
    PM_SUBNET                      Subnet;

    AssertRet(pSubnet, ERROR_INVALID_PARAMETER);
    AssertRet( !(CLASSD_HOST_ADDR(Address)||CLASSE_HOST_ADDR(Address)),
               ERROR_INVALID_PARAMETER );
    Require((Address&Mask));

    *pSubnet = NULL;

    Size = ROUND_UP_COUNT(sizeof(*Subnet), ALIGN_WORST);
    Size += sizeof(WCHAR) * (Name?(1+wcslen(Name)):0);
    Size += sizeof(WCHAR) * (Description?(1+wcslen(Description)):0);

    Subnet = MemAlloc(Size);
    if( NULL == Subnet) return ERROR_NOT_ENOUGH_MEMORY;

    Size = ROUND_UP_COUNT(sizeof(*Subnet), ALIGN_WORST);

    Subnet->Name = Subnet->Description = NULL;
    if( Name ) {
        Subnet->Name = (LPWSTR)(Size + (LPBYTE)Subnet);
        wcscpy(Subnet->Name, Name);
        Size += sizeof(WCHAR) * ( 1 + wcslen(Name));
    }

    if( Description ) {
        Subnet->Description = (LPWSTR)( Size + (LPBYTE)Subnet );
        wcscpy(Subnet->Description, Description);
    }

    Subnet->ServerPtr    = NULL;
    Subnet->Address      = Address;
    Subnet->Mask         = Mask;
    Subnet->State        = State;
    Subnet->SuperScopeId = SuperScopeId;
    Subnet->fSubnet      = TRUE;
    Subnet->Policy       = AddressPolicyNone;

    Error = MemOptClassInit(&Subnet->Options);
    if( ERROR_SUCCESS != Error ) { MemFree(Subnet); return Error; }

    Error = MemArrayInit(&Subnet->Ranges);
    if( ERROR_SUCCESS != Error ) { MemFree(Subnet); return Error; }

    Error = MemArrayInit(&Subnet->Exclusions);
    if( ERROR_SUCCESS != Error ) { MemFree(Subnet); return Error; }

    Error = MemArrayInit(&Subnet->Servers);
    if( ERROR_SUCCESS != Error ) { MemFree(Subnet); return Error; }

    Error = MemReserveInit(&Subnet->Reservations);
    if( ERROR_SUCCESS != Error ) { MemFree(Subnet); return Error; }

    *pSubnet = Subnet;
    return ERROR_SUCCESS;
}

VOID
GetLangTag(
    WCHAR LangTag[]
    )
{
    WCHAR b1[8], b2[8];

    b1[0] = b2[0] = L'\0';
    GetLocaleInfoW(
        LOCALE_SYSTEM_DEFAULT, LOCALE_SISO639LANGNAME,
        b1, sizeof(b1)/sizeof(b1[0])
        );
    
    GetLocaleInfoW(
        LOCALE_SYSTEM_DEFAULT, LOCALE_SISO3166CTRYNAME,
        b2, sizeof(b2)/sizeof(b2[0])
        );
    
    if (_wcsicmp(b1, b2))
        wsprintf(LangTag, L"%s-%s", b1, b2);
    else
        wcscpy(LangTag, b1);
}

//BeginExport(function)
DWORD
MemMScopeInit(
    OUT     PM_SUBNET             *pMScope,
    IN      DWORD                  MScopeId,
    IN      DWORD                  State,
    IN      DWORD                  AddressPolicy,
    IN      BYTE                   TTL,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Description,
    IN      LPWSTR                 LangTag,
    IN      DATE_TIME              ExpiryTime
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Size;
    PM_SUBNET                      MScope;
    WCHAR                          DummyLangTag[100];
    
    AssertRet(pMScope, ERROR_INVALID_PARAMETER);
    //AssertRet(MScopeId, ERROR_INVALID_PARAMETER);
    Require(LangTag);

    if( NULL == LangTag ) {
        LangTag = DummyLangTag;
        GetLangTag(DummyLangTag);
    }
    
    *pMScope = NULL;

    Size = ROUND_UP_COUNT(sizeof(*MScope), ALIGN_WORST);
    Size += sizeof(WCHAR) * (Name?(1+wcslen(Name)):0);
    Size += sizeof(WCHAR) * (Description?(1+wcslen(Description)):0);
    Size += sizeof(WCHAR) * (1+wcslen(LangTag));

    MScope = MemAlloc(Size);
    if( NULL == MScope) return ERROR_NOT_ENOUGH_MEMORY;

    Size = ROUND_UP_COUNT(sizeof(*MScope), ALIGN_WORST);

    MScope->Name = MScope->Description = MScope->LangTag = NULL;

    if( Name ) {
        MScope->Name = (LPWSTR)(Size + (LPBYTE)MScope);
        wcscpy(MScope->Name, Name);
        Size += sizeof(WCHAR) * ( 1 + wcslen(Name));
    }

    if( Description ) {
        MScope->Description = (LPWSTR)( Size + (LPBYTE)MScope );
        wcscpy(MScope->Description, Description);
        Size += sizeof(WCHAR) * ( 1 + wcslen(Description));
    }

    MScope->LangTag = (LPWSTR)( Size + (LPBYTE)MScope );
    wcscpy(MScope->LangTag, LangTag);

    MScope->ServerPtr    = NULL;
    MScope->MScopeId     = MScopeId;
    MScope->State        = State;
    MScope->TTL          = TTL;
    MScope->fSubnet      = FALSE;
    MScope->Policy       = AddressPolicy;
    MScope->ExpiryTime   = ExpiryTime;

    Error = MemOptClassInit(&MScope->Options);
    if( ERROR_SUCCESS != Error ) { MemFree(MScope); return Error; }

    Error = MemArrayInit(&MScope->Ranges);
    if( ERROR_SUCCESS != Error ) { MemFree(MScope); return Error; }

    Error = MemArrayInit(&MScope->Exclusions);
    if( ERROR_SUCCESS != Error ) { MemFree(MScope); return Error; }

    Error = MemArrayInit(&MScope->Servers);
    if( ERROR_SUCCESS != Error ) { MemFree(MScope); return Error; }

    Error = MemReserveInit(&MScope->Reservations);
    if( ERROR_SUCCESS != Error ) { MemFree(MScope); return Error; }

    *pMScope = MScope;
    return ERROR_SUCCESS;
}

//BeginExport(inline)
DWORD       _inline
MemSubnetCleanup(
    IN OUT  PM_SUBNET              Subnet
)
{
    DWORD                          Error;

    AssertRet(Subnet, ERROR_INVALID_PARAMETER);
    Require(Subnet->Address&Subnet->Mask);

    Error = MemOptClassCleanup(&Subnet->Options);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemArrayCleanup(&Subnet->Ranges);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemArrayCleanup(&Subnet->Exclusions);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemArrayCleanup(&Subnet->Servers);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemReserveCleanup(&Subnet->Reservations);
    if( ERROR_SUCCESS != Error ) return Error;

    MemFree(Subnet);
    return ERROR_SUCCESS;
}
//EndExport(inline)

//BeginExport(function)
DWORD                                             // SUCCESS if either of Excl or Range get filled, else FILE_NOT_FOUND
MemSubnetGetAddressInfo(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  Address,
    OUT     PM_RANGE              *Range,         // OPTIONAL -- filled if a range could be found -- even if excluded
    OUT     PM_EXCL               *Excl,          // OPTIONAL -- filled if an exclusion could be found
    OUT     PM_RESERVATION        *Reservation    // OPTIONAL -- filled with  a matching reservation, if found
) //EndExport(function)
{
    ARRAY_LOCATION                 Location;
    DWORD                          Error;
    DWORD                          RetError;
    PM_RANGE                       ThisRange;
    PM_EXCL                        ThisExcl;

    AssertRet(Subnet && (Range || Excl || Reservation), ERROR_INVALID_PARAMETER );

    if( Subnet->fSubnet && (Address & Subnet->Mask) != Subnet->Address )
        return ERROR_FILE_NOT_FOUND;              // it is ok for MSCOPE objects, as Address refers to ScopeId

    RetError = ERROR_FILE_NOT_FOUND;
    if( Range ) {
        *Range = NULL;
        Error = MemArrayInitLoc(&Subnet->Ranges, &Location);
        while( ERROR_FILE_NOT_FOUND != Error ) {
            Require(ERROR_SUCCESS == Error);

            Error = MemArrayGetElement(&Subnet->Ranges, &Location, (LPVOID *)&ThisRange);
            Require(ERROR_SUCCESS == Error && ThisRange);

            if( ThisRange->Start <= Address && Address <= ThisRange->End ) {
                *Range = ThisRange;
                RetError = ERROR_SUCCESS;
                break;
            }

            Error = MemArrayNextLoc(&Subnet->Ranges, &Location);
        }
    }

    if( Excl ) {
        *Excl = NULL;
        Error = MemArrayInitLoc(&Subnet->Exclusions, &Location);
        while( ERROR_FILE_NOT_FOUND != Error ) {
            Require(ERROR_SUCCESS == Error);

            Error = MemArrayGetElement(&Subnet->Exclusions, &Location, (LPVOID *)&ThisExcl);
            Require(ERROR_SUCCESS == Error && ThisExcl);

            if( ThisExcl->Start <= Address && Address <= ThisExcl->End ) {
                *Excl = ThisExcl;
                RetError = ERROR_SUCCESS;
                break;
            }

            Error = MemArrayNextLoc(&Subnet->Exclusions, &Location);
        }
    }

    if( Reservation ) {
        *Reservation = NULL;

        Error = MemReserveFindByAddress(&Subnet->Reservations, Address, Reservation);
        if( ERROR_SUCCESS == Error ) RetError = ERROR_SUCCESS;
    }

    return RetError;
}

//BeginExport(function)
DWORD                                             // ERROR_SUCCESS on finding a collition, else ERROR_FILE_NOT_FOUND
MemSubnetFindCollision(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start,
    IN      DWORD                  End,
    OUT     PM_RANGE              *Range,         // OPTIONAL
    OUT     PM_EXCL               *Excl           // OPTIONAL
) //EndExport(function)
{
    ARRAY_LOCATION                 Location;
    DWORD                          Error;
    DWORD                          RetError;
    DWORD                          Cond;
    PM_RANGE                       ThisRange;
    PM_EXCL                        ThisExcl;

    Require(Subnet && (Range || Excl));
    if( Subnet->fSubnet ) {                       // checks ommitted for MCAST scopes.
        if( (Start & Subnet->Mask) != (End & Subnet->Mask) )
            return ERROR_INVALID_PARAMETER;
        if( (Start & Subnet->Mask) != (Subnet->Address & Subnet->Mask) )
            return ERROR_INVALID_PARAMETER;
    }

    RetError = ERROR_FILE_NOT_FOUND;
    if(Range) {
        *Range = NULL;
        Error = MemArrayInitLoc(&Subnet->Ranges, &Location);
        while( ERROR_FILE_NOT_FOUND != Error ) {
            Require(ERROR_SUCCESS == Error);

            Error = MemArrayGetElement(&Subnet->Ranges, &Location, (LPVOID *)&ThisRange);
            Require(ERROR_SUCCESS == Error && ThisRange);

            Cond = MemRangeCompare(Start,End, ThisRange->Start, ThisRange->End);
            if( Cond != X_LESSTHAN_Y && Cond != Y_LESSTHAN_X ) {
                // Collision has occured
                *Range = ThisRange;
                RetError = ERROR_SUCCESS;
                break;
            }

            Error = MemArrayNextLoc(&Subnet->Ranges, &Location);
        }
    }

    if( Excl ) {
        *Excl = NULL;
        Error = MemArrayInitLoc(&Subnet->Exclusions, &Location);
        while( ERROR_FILE_NOT_FOUND != Error ) {
            Require(ERROR_SUCCESS == Error);

            Error = MemArrayGetElement(&Subnet->Exclusions, &Location, (LPVOID *)&ThisExcl);
            Require(ERROR_SUCCESS == Error && ThisExcl);

            Cond = MemRangeCompare(Start,End, ThisExcl->Start, ThisExcl->End);
            if( Cond != X_LESSTHAN_Y && Cond != Y_LESSTHAN_X ) {
                *Excl = ThisExcl;
                RetError = ERROR_SUCCESS;
                break;
            }

            Error = MemArrayNextLoc(&Subnet->Exclusions, &Location);
        }
    }

    return RetError;
}



//BeginExport(function)
DWORD                                             // ERROR_OBJECT_ALREADY_EXISTS on collision
MemSubnetAddRange(                                // check if the range is valid, and only then add it
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start,
    IN      DWORD                  End,
    IN      DWORD                  State,
    IN      ULONG                  BootpAllocated,
    IN      ULONG                  MaxBootpAllowed,
    OUT     PM_RANGE              *OverlappingRange
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          LocalError;
    PM_RANGE                       NewRange;

    AssertRet(Subnet && OverlappingRange, ERROR_INVALID_PARAMETER);

    if( Subnet->fSubnet ) {
        if( (Subnet->Address & Subnet->Mask) != (Start & Subnet->Mask) ||
            (Start & Subnet->Mask)  != (End & Subnet->Mask) )
            return ERROR_INVALID_PARAMETER;
    } else {
        if (!CLASSD_HOST_ADDR(Start) || !CLASSD_HOST_ADDR(End)) {
            return ERROR_INVALID_PARAMETER;
        }
    }

    if( Start > End ) return ERROR_INVALID_PARAMETER;

    *OverlappingRange = NULL;
    Error = MemSubnetFindCollision(
        Subnet,
        Start,
        End,
        OverlappingRange,
        NULL
    );
    if(ERROR_FILE_NOT_FOUND != Error ) {          // collision with a range?
        Require(ERROR_SUCCESS == Error);
        return ERROR_OBJECT_ALREADY_EXISTS;
    }

    NewRange = MemAlloc(sizeof(*NewRange));
    if( NULL == NewRange ) return ERROR_NOT_ENOUGH_MEMORY;

    Error = MemRangeInit(
        NewRange, Start, End, Subnet->fSubnet ? Subnet->Mask : 0, State,
        BootpAllocated, MaxBootpAllowed
        );
    if( ERROR_SUCCESS != Error ) {
        MemFree(NewRange);
        return Error;
    }

    Error = MemArrayAddElement(
        &Subnet->Ranges,
        NewRange
    );

    if( ERROR_SUCCESS != Error ) {
        LocalError = MemRangeCleanup(NewRange);
        Require(LocalError == ERROR_SUCCESS);
        MemFree(NewRange);
    }

    return Error;
}

//BeginExport(function)
DWORD
MemSubnetAddRangeExpandOrContract(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  StartAddress,
    IN      DWORD                  EndAddress,
    OUT     DWORD                 *OldStartAddress,
    OUT     DWORD                 *OldEndAddress
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          LocalError;
    DWORD                          Cond;
    DWORD                          nAddresses;
    BOOL                           fExtend;
    PM_RANGE                       OldRange;
    PM_RANGE                       ThisRange;
    PARRAY                         Ranges;
    ARRAY_LOCATION                 Loc;

    Ranges = &Subnet->Ranges;

    *OldStartAddress = *OldEndAddress = 0;
    OldRange = NULL;
    Error = MemArrayInitLoc(Ranges, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(Ranges, &Loc, (LPVOID *)&ThisRange);
        Require(ERROR_SUCCESS == Error && ThisRange);

        Cond = MemRangeCompare(StartAddress, EndAddress, ThisRange->Start, ThisRange->End);
        if( Cond != X_LESSTHAN_Y && Cond != Y_LESSTHAN_X ) {
            if( OldRange ) return ERROR_OBJECT_ALREADY_EXISTS;
            if( X_IN_Y != Cond && Y_IN_X != Cond )
                return ERROR_OBJECT_ALREADY_EXISTS;
            OldRange = ThisRange;
        }

        Error = MemArrayNextLoc(Ranges, &Loc);
    }

    if( NULL == OldRange ) return ERROR_FILE_NOT_FOUND;

    *OldStartAddress = OldRange->Start;
    *OldEndAddress = OldRange->End;

    if( OldRange->Start < StartAddress ) {
        fExtend = FALSE;
        nAddresses = StartAddress - OldRange->Start;
    } else {
        fExtend = TRUE;
        nAddresses = OldRange->Start - StartAddress;
    }

    Error = ERROR_SUCCESS;
    if( nAddresses ) Error = MemRangeExtendOrContract(
        OldRange,
        nAddresses,
        fExtend,
        FALSE
    );
    if( ERROR_SUCCESS != Error ) return Error;

    if( OldRange->End < EndAddress ) {
        fExtend = TRUE;
        nAddresses = EndAddress - OldRange->End;
    } else {
        fExtend = FALSE;
        nAddresses = OldRange->End - EndAddress;
    }

    if( nAddresses ) Error = MemRangeExtendOrContract(
        OldRange,
        nAddresses,
        fExtend,
        TRUE
    );
    return Error;
}

//BeginExport(function)
DWORD
MemSubnetAddExcl(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start,
    IN      DWORD                  End,
    OUT     PM_EXCL               *OverlappingExcl
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          LocalError;
    PM_EXCL                        NewExcl;

    AssertRet(Subnet && OverlappingExcl, ERROR_INVALID_PARAMETER);

    if( Subnet->fSubnet ) {
        if( (Subnet->Address & Subnet->Mask) != (Start & Subnet->Mask) ||
            (Start & Subnet->Mask)  != (End & Subnet->Mask) )
            return ERROR_INVALID_PARAMETER;
    }

    if( Start > End ) return ERROR_INVALID_PARAMETER;

    *OverlappingExcl = NULL;
    Error = MemSubnetFindCollision(
        Subnet,
        Start,
        End,
        NULL,
        OverlappingExcl
    );
    if(ERROR_FILE_NOT_FOUND != Error ) {          // collision with a range?
        Require(ERROR_SUCCESS == Error);
        return ERROR_OBJECT_ALREADY_EXISTS;
    }

    NewExcl = MemAlloc(sizeof(*NewExcl));
    if( NULL == NewExcl ) return ERROR_NOT_ENOUGH_MEMORY;

    NewExcl->Start = Start;
    NewExcl->End = End;

    Error = MemArrayAddElement(
        &Subnet->Exclusions,
        NewExcl
    );

    if( ERROR_SUCCESS != Error ) {
        MemFree(NewExcl);
    }

    return Error;
}

//BeginExport(function)
DWORD
MemSubnetDelRange(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start
) //EndExport(function)
{
    DWORD                          Error;
    PM_RANGE                       ThisRange;
    ARRAY_LOCATION                 Location;

    Error = MemArrayInitLoc(&Subnet->Ranges, &Location);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Subnet->Ranges, &Location, (LPVOID *)&ThisRange);
        Require(ERROR_SUCCESS == Error && ThisRange);

        if( ThisRange->Start == Start ) {         // Collision has occured
            Error = MemRangeCleanup(ThisRange);
            Require(ERROR_SUCCESS == Error);
            MemFree(ThisRange);

            Error = MemArrayDelElement(&Subnet->Ranges, &Location, (LPVOID *)&ThisRange);
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(&Subnet->Ranges, &Location);
    }
    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemSubnetDelExcl(
    IN OUT  PM_SUBNET              Subnet,
    IN      DWORD                  Start
) //EndExport(function)
{
    DWORD                          Error;
    PM_EXCL                        ThisExcl;
    ARRAY_LOCATION                 Location;

    Error = MemArrayInitLoc(&Subnet->Exclusions, &Location);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Subnet->Exclusions, &Location, (LPVOID *)&ThisExcl);
        Require(ERROR_SUCCESS == Error && ThisExcl);

        if( ThisExcl->Start == Start ) {
            Error = MemArrayDelElement(&Subnet->Exclusions, &Location, (LPVOID *)&ThisExcl);
            MemFree(ThisExcl);
            return ERROR_SUCCESS;
        }

        Error = MemArrayNextLoc(&Subnet->Exclusions, &Location);
    }
    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
MemSubnetExtendOrContractRange(
    IN OUT  PM_SUBNET              Subnet,
    IN OUT  PM_RANGE               Range,
    IN      DWORD                  nAddresses,    // how many addresses to extend by
    IN      BOOL                   fExtend,       // is this an EXTEND? or a CONTRACT?
    IN      BOOL                   fEnd           // is this operation to be done to END of range or START?
) //EndExport(function)
{
    DWORD                          Error;
    PM_RANGE                       CollidedRange;

    AssertRet(Subnet && Range, ERROR_INVALID_PARAMETER);

    if( Subnet->fSubnet ) {                       // for real subnets (non-multicast-scopes) do sanity check
        if( fExtend ) {
            if( fEnd ) {
                if( ((Range->End + nAddresses) & Subnet->Mask) != (Range->Start & Subnet->Mask) )
                    return ERROR_INVALID_PARAMETER;

                Error = MemSubnetFindCollision(
                    Subnet,
                    Range->End +1,
                    Range->End +nAddresses,
                    &CollidedRange,
                    NULL
                );
                if( ERROR_SUCCESS == Error && NULL != CollidedRange)
                    return ERROR_OBJECT_ALREADY_EXISTS;
            }  else {
                if( ((Range->Start - nAddresses) & Subnet->Mask) != (Range->End & Subnet->Mask) )
                    return ERROR_INVALID_PARAMETER;

                Error = MemSubnetFindCollision(
                    Subnet,
                    Range->Start - nAddresses,
                    Range->Start - 1,
                    &CollidedRange,
                    NULL
                );
                if( ERROR_SUCCESS == Error && NULL != CollidedRange)
                    return ERROR_OBJECT_ALREADY_EXISTS;
            }
        }
    }

    if( !fExtend && nAddresses >  Range->End - Range->Start )
        return ERROR_INVALID_PARAMETER;

    Error = MemRangeExtendOrContract(
        Range,
        nAddresses,
        fExtend,
        fEnd
    );

    return Error;
}


//BeginExport(function)
DWORD
MemSubnetExtendOrContractExcl(
    IN OUT  PM_SUBNET              Subnet,
    IN OUT  PM_EXCL                Excl,
    IN      DWORD                  nAddresses,    // how many addresses to extend by
    IN      BOOL                   fExtend,       // is this an EXTEND? or a CONTRACT?
    IN      BOOL                   fEnd           // is this operation to be done to END of range or START?
) //EndExport(function)
{
    DWORD                          Error;
    PM_EXCL                        CollidedExcl;

    AssertRet(Subnet && Excl, ERROR_INVALID_PARAMETER);

    if( Subnet->fSubnet ) {                       // for real subnets (non-multicast-scopes) do sanity check
        if( fExtend ) {
            if( fEnd ) {
                if( ((Excl->End + nAddresses) & Subnet->Mask) != (Excl->Start & Subnet->Mask) )
                    return ERROR_INVALID_PARAMETER;

                Error = MemSubnetFindCollision(
                    Subnet,
                    Excl->End +1,
                    Excl->End +nAddresses,
                    NULL,
                    &CollidedExcl
                );
                if( ERROR_SUCCESS == Error && NULL != CollidedExcl)
                    return ERROR_OBJECT_ALREADY_EXISTS;
            }  else {
                if( ((Excl->Start - nAddresses) & Subnet->Mask) != (Excl->End & Subnet->Mask) )
                    return ERROR_INVALID_PARAMETER;

                Error = MemSubnetFindCollision(
                    Subnet,
                    Excl->Start - nAddresses,
                    Excl->Start - 1,
                    NULL,
                    &CollidedExcl
                );
                if( ERROR_SUCCESS == Error && NULL != CollidedExcl)
                    return ERROR_OBJECT_ALREADY_EXISTS;
            }
        }
    }

    if( !fExtend && nAddresses >  Excl->End - Excl->Start )
        return ERROR_INVALID_PARAMETER;

    if( fExtend )
        if( fEnd )
            Excl->End += nAddresses;
        else
            Excl->Start -= nAddresses;
    else
        if( fEnd )
            Excl->End -= nAddresses;
        else
            Excl->Start += nAddresses;

    return NO_ERROR;
}


//================================================================================
//  Multicast Scopes implementation
//================================================================================

//BeginExport(typedef)
typedef     M_SUBNET               M_MSCOPE;      // same structure for Multicast Scopes and Subnets
typedef     PM_SUBNET              PM_MSCOPE;     // still, use the correct functions for MScope
typedef     LPM_SUBNET             LPM_MSCOPE;
//EndExport(typedef)

//BeginExport(inline)
DWORD       _inline
MemMScopeCleanup(
    IN      PM_MSCOPE              MScope
) {
    return MemSubnetCleanup(MScope);
}
//EndExport(inline)

//BeginExport(decl)
#define     MemMScopeGetAddressInfo               MemSubnetGetAddressInfo
#define     MemMScopeFindCollision                MemSubnetFindCollision
#define     MemMScopeAddExcl                      MemSubnetAddExcl
#define     MemMScopeDelRange                     MemSubnetDelRange
#define     MemMScopeDelExcl                      MemSubnetDelExcl
#define     MemMScopeExtendOrContractRange        MemSubnetExtendOrContractRange
#define     MemMScopeExtendOrContractExcl         MemSubnetExtendOrContractExcl

DWORD
MemMScopeGetAddressInfo(
    IN      PM_MSCOPE              MScope,
    IN      DWORD                  MCastAddress,
    OUT     PM_RANGE              *Range,         // OPTIONAL -- filled if a range could be found -- even if excluded
    OUT     PM_EXCL               *Excl,          // OPTIONAL -- filled if an exclusion could be found
    OUT     PM_RESERVATION        *Reservation    // OPTIONAL -- filled with  a matching reservation, if found
);

DWORD                                             // ERROR_SUCCESS on finding a collition, else ERROR_FILE_NOT_FOUND
MemMScopeFindCollision(
    IN OUT  PM_MSCOPE              Subnet,
    IN      DWORD                  MCastStart,
    IN      DWORD                  MCastEnd,
    OUT     PM_RANGE              *Range,         // OPTIONAL
    OUT     PM_EXCL               *Excl           // OPTIONAL
);

//EndExport(decl)

//BeginExport(inline)
DWORD       _inline                               // ERROR_OBJECT_ALREADY_EXISTS on collision
MemMScopeAddRange(                                // check if the range is valid, and only then add it
    IN OUT  PM_MSCOPE              Subnet,
    IN      DWORD                  MCastStart,
    IN      DWORD                  MCastEnd,
    IN      DWORD                  State,
    OUT     PM_RANGE              *OverlappingRange
)
{
    return MemSubnetAddRange(Subnet,MCastStart, MCastEnd, State, 0, 0, OverlappingRange);
}


DWORD
MemMScopeAddExcl(
    IN OUT  PM_MSCOPE              Subnet,
    IN      DWORD                  MCastStart,
    IN      DWORD                  MCastEnd,
    OUT     PM_EXCL               *OverlappingExcl
);

DWORD
MemMScopeDelRange(
    IN OUT  PM_MSCOPE              Subnet,
    IN      DWORD                  MCastStart
);

DWORD
MemMScopeDelExcl(
    IN OUT  PM_MSCOPE              Subnet,
    IN      DWORD                  MCastStart
);

DWORD
MemMScopeExtendOrContractRange(
    IN OUT  PM_MSCOPE              Subnet,
    IN OUT  PM_RANGE               Range,
    IN      DWORD                  nAddresses,    // how many addresses to extend by
    IN      BOOL                   fExtend,       // is this an EXTEND? or a CONTRACT?
    IN      BOOL                   fEnd           // is this operation to be done to END of range or START?
);

DWORD
MemMScopeExtendOrContractExcl(
    IN OUT  PM_MSCOPE              Subnet,
    IN OUT  PM_EXCL                Excl,
    IN      DWORD                  nAddresses,    // how many addresses to extend by
    IN      BOOL                   fExtend,       // is this an EXTEND? or a CONTRACT?
    IN      BOOL                   fEnd           // is this operation to be done to END of range or START?
);
//EndExport(decl)

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\tbitex.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: this is a short program to test the bitmask functionality
//================================================================================

#include <mm.h>
#include <array.h>
#include <bitmask.h>
#include <stdio.h>

PM_BITMASK  Bit;

VOID _cdecl
main(
    VOID
)
{
    DWORD                          Error;
    DWORD                          Offset;
    DWORD                          BitSize;
    DWORD                          ToSet;
    DWORD                          ToSet1, ToSet2;
    DWORD                          InUseSize;
    DWORD                          UsedSize;
    BOOL                           OldState;
    LPBYTE                         InUse;
    LPBYTE                         Used;

    Error = MemBitInit(&Bit, 0x01000000);
    printf("MemBitInit(0x01000000)=%ld\n", Error);

    for( ToSet = 0; ToSet < 0x01000000 ; ToSet ++ ) {
        if( 0 == ( ToSet % 35 ) ) continue;
        Error = MemBitSetOrClear(
            Bit,
            ToSet,
            TRUE,
            &OldState
        );
        if( ERROR_SUCCESS != Error || OldState ) {
            printf("MemBitSetOrClear(%ld)=%ld,OldState=%ld\n", ToSet, Error, OldState);
        }
    }
    printf("Set all stuff\n");
    Error = MemBitConvertToCluster(
        Bit,
        0,
        &InUse,
        &InUseSize,
        &Used,
        &UsedSize
    );
    printf("MemBitconvert: %ld\n", Error);
    if( ERROR_SUCCESS != Error )return;

    printf("InUseSize= %ld, UsedSize = %ld\n", InUseSize, UsedSize);

    printf("InUse[0] = %ld\n", *(LPDWORD)InUse);
    InUse += sizeof(DWORD); InUseSize -= sizeof(DWORD);
    while(InUseSize) {
        Offset = *(LPDWORD)InUse;
        InUse+= sizeof(DWORD);
        for( ToSet = 0; ToSet < 32; ToSet ++ )
            if( (1<<ToSet) & *(LPDWORD)InUse )
                printf("InUse [ %ld ] \n", Offset + ToSet );

        InUse+= sizeof(DWORD);
        InUseSize -= sizeof(DWORD)*2;
    }

    printf("Used[0] = %ld\n", *(LPDWORD)Used);
    Used += sizeof(DWORD);
    UsedSize -= sizeof(DWORD);
    while( UsedSize ) {
        Offset = *(LPDWORD)Used;
        Used += sizeof(DWORD);
        UsedSize -= sizeof(DWORD);
        printf("Used [ %ld ] \n", Offset);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\subnet2.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This file has been generated. Pl look at the .c file
//========================================================================

DWORD
MemSubnetModify(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  Address,
    IN      DWORD                  Mask,
    IN      DWORD                  State,
    IN      DWORD                  SuperScopeId,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Description
) ;


DWORD
MemMScopeModify(
    IN      PM_SUBNET              MScope,
    IN      DWORD                  ScopeId,
    IN      DWORD                  State,
    IN      DWORD                  Policy,
    IN      BYTE                   TTL,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Description,
    IN      LPWSTR                 LangTag,
    IN      DATE_TIME              ExpiryTime
) ;

//========================================================================
//  end of file
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mmreg\mmregpch.h ===
/*++

Coypright (C) 1998 Microsoft Corporation

Module name:

    mmregpch.h

Abstract:

    Precompiled header for MMREG module.

Environment:

    User mode Win32

--*/

#include    <mm\mm.h>
#include    <mm\array.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <winsock2.h>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mm\tbitmask.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: this is a short program to test the bitmask functionality
//================================================================================

#include <mm.h>
#include <array.h>
#include <bitmask.h>
#include <stdio.h>

PM_BITMASK  Bit;

VOID _cdecl
main(
    VOID
)
{
    DWORD                          Error;
    DWORD                          Offset;
    DWORD                          BitSize;
    DWORD                          ToSet;
    DWORD                          ToSet1, ToSet2;
    DWORD                          InUseSize;
    DWORD                          UsedSize;
    BOOL                           OldState;
    LPBYTE                         InUse;
    LPBYTE                         Used;

    printf("Size of bitmask: "); scanf("%ld", &BitSize);
    Error = MemBitInit(&Bit, BitSize);
    printf("MemBitInit(&Bit, %ld)=%ld\n", BitSize, Error);

    while(1) {
        printf("Enter bit to set [-1 to quit loop] from to: "); scanf("%ld %ld", &ToSet1, &ToSet2);
        if( -1 == ToSet1 || -1 == ToSet2 ) break;

        for( ToSet = ToSet1; ToSet <= ToSet2; ToSet ++ ) {
            Error = MemBitSetOrClear(
                Bit,
                ToSet,
                TRUE,
                &OldState
            );
            printf("MemBitSetOrClear(%ld)= %ld,OldState=%ld\n", ToSet, Error, OldState);
        }
    }

    Error = MemBitConvertToCluster(
        Bit,
        100,
        &InUse,
        &InUseSize,
        &Used,
        &UsedSize
    );
    printf("MemBitconvert: %ld\n", Error);
    if( ERROR_SUCCESS != Error )return;

    printf("InUseSize= %ld, UsedSize = %ld\n", InUseSize, UsedSize);

    printf("InUse[0] = %ld\n", *(LPDWORD)InUse);
    InUse += sizeof(DWORD); InUseSize -= sizeof(DWORD);
    while(InUseSize) {
        Offset = *(LPDWORD)InUse;
        InUse+= sizeof(DWORD);
        for( ToSet = 0; ToSet < 32; ToSet ++ )
            if( (1<<ToSet) & *(LPDWORD)InUse )
                printf("InUse [ %ld ] \n", Offset + ToSet );

        InUse+= sizeof(DWORD);
        InUseSize -= sizeof(DWORD)*2;
    }

    printf("Used[0] = %ld\n", *(LPDWORD)Used);
    Used += sizeof(DWORD);
    UsedSize -= sizeof(DWORD);
    while( UsedSize ) {
        Offset = *(LPDWORD)Used;
        Used += sizeof(DWORD);
        UsedSize -= sizeof(DWORD);
        printf("Used [ %ld ] \n", Offset);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mmreg\regds.c ===
//================================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This file has the functions relating to downloading stuff from
//  off the DS in a safe way onto the registry.  The solution adopted is actually
//  to dowload onto the "Config.DS" key rather than to the "Configuration" key
//  itself.  Then if the full download is successful, backup this key and restore it
//  onto the "Configuration" key -- so if anything fails, atleast the old configuration
//  would be intact.
//================================================================================

#include    <mmregpch.h>
#include    <regutil.h>
#include    <regsave.h>

#define     FreeArray1(X)          Error = LoopThruArray((X), DestroyString, NULL, NULL);Require(ERROR_SUCCESS == Error);
#define     FreeArray2(X)          Error = MemArrayCleanup((X)); Require(ERROR_SUCCESS == Error);
#define     FreeArray(X)           do{ DWORD Error; FreeArray1(X); FreeArray2(X); }while(0)

typedef     DWORD                  (*ARRAY_FN)(PREG_HANDLE, LPWSTR ArrayString, LPVOID MemObject);

extern
DWORD
DestroyString(                                       // defined in regread.c
    IN      PREG_HANDLE            Unused,
    IN      LPWSTR                 StringToFree,
    IN      LPVOID                 Unused2
);

extern
DWORD
LoopThruArray(                                    // defined in regread.c
    IN      PARRAY                 Array,
    IN      ARRAY_FN               ArrayFn,
    IN      PREG_HANDLE            Hdl,
    IN      LPVOID                 MemObject
);

DWORD                                             //  need to include headers..
DhcpDsGetEnterpriseServers(                       // defined in dhcpds\dhcpread.h.
    IN      DWORD                  Reserved,
    IN      LPWSTR                 ServerName,
    IN OUT  PARRAY                 Servers
) ;

//================================================================================
//  module files
//================================================================================
REG_HANDLE  DsConfig = { NULL, NULL, NULL };      // DsConfig key is stored here
PM_SERVER   CurrentServer;
static      const
DWORD       ZeroReserved = 0;

DWORD
PrepareRegistryForDsDownload(                     // make reg changes to download
    VOID
)
{
    DWORD                          Err, Disposition;
    REG_HANDLE                     DsConfigParent;

    if( NULL != DsConfig.Key ) return ERROR_INVALID_PARAMETER;
    memset(&DsConfigParent,0, sizeof(DsConfigParent));

    Err = RegOpenKeyEx(                           // open the parent key for DsConfig.
        HKEY_LOCAL_MACHINE,
        REG_THIS_SERVER_DS_PARENT,
        ZeroReserved,
        REG_ACCESS,
        &DsConfigParent.Key
    );
    if( ERROR_SUCCESS != Err ) return Err;        // cant do much if server key aint there.

    Err = DhcpRegRecurseDelete(&DsConfigParent, REG_THIS_SERVER_DS_VALUE);
    RegCloseKey(DsConfigParent.Key);             // this is all the parent is needed for

    if( ERROR_SUCCESS != Err && ERROR_FILE_NOT_FOUND != Err ) {
        return Err;                               // could not delete the "config_ds" trash?
    }

    Err = RegCreateKeyEx(                         // now create a fresh "config_ds" key
        HKEY_LOCAL_MACHINE,
        REG_THIS_SERVER_DS,
        ZeroReserved,
        REG_CLASS,
        REG_OPTION_NON_VOLATILE,
        REG_ACCESS,
        NULL,
        &DsConfig.Key,
        &Disposition
    );
    if( ERROR_SUCCESS != Err ) return Err;        // could not create the key, nowhere to store..

    return DhcpRegSetCurrentServer(&DsConfig);    // now set this as the default server loc to use..
}


VOID
CleanupAfterDownload(                             // keep stuff clean for other modules
    VOID
)
{
    if( NULL != DsConfig.Key ) RegCloseKey(DsConfig.Key);
    DsConfig.Key = NULL;                          // close the config_ds key and,
    DhcpRegSetCurrentServer(NULL);                // forget abt the config_ds key..
    //remote the Ds cache no matter what...
}

DWORD
CopyRegKeys(                                      // copy between reg keys
    IN      HKEY                   SrcKey,        // copy tree rooted at this key
    IN      LPWSTR                 DestKeyLoc,    // onto registry key located here
    IN      LPWSTR                 FileName       // using this as the temp file
)
{
    DWORD                          Err, Disposition;
    HKEY                           DestKey;
    BOOLEAN                        HadBackup;
    NTSTATUS                       NtStatus;

    NtStatus = RtlAdjustPrivilege (SE_BACKUP_PRIVILEGE, TRUE, FALSE, &HadBackup);
    if( ERROR_SUCCESS != NtStatus ) {             // could not request backup priv..
        return RtlNtStatusToDosError(NtStatus);
    }

    NtStatus = RtlAdjustPrivilege (SE_RESTORE_PRIVILEGE, TRUE, FALSE, &HadBackup);
    if( ERROR_SUCCESS != NtStatus ) {
        return RtlNtStatusToDosError(NtStatus);
    }

    Err = RegSaveKey(SrcKey, FileName, NULL);     // NULL ==> no security on file
    if( ERROR_SUCCESS != Err ) return Err;        // if key cant be saved, cant restore.

    Err = RegCreateKeyEx(                         // now create a fresh "config_ds" key
        HKEY_LOCAL_MACHINE,
        DestKeyLoc,
        ZeroReserved,
        REG_CLASS,
        REG_OPTION_NON_VOLATILE,
        REG_ACCESS,
        NULL,
        &DestKey,
        &Disposition
    );
    if( ERROR_SUCCESS != Err ) return Err;        // could not create the key, nowhere to store..

    Err = RegRestoreKey(DestKey, FileName, 0 );   // 0 ==> no flags, in particular, not volatile.
    RegCloseKey(DestKey);                         // dont need this key anyways.

    return Err;
}

DWORD
FixSpecificClusters(                              // this fixes a specific cluster
    IN      HKEY                   NewCfgKey,     // root cfg where to copy over
    IN      LPWSTR                 Subnet,        // the subnet to copy to
    IN      LPWSTR                 Range,         // the range to copy to
    IN      LPBYTE                 InUseClusters, // in use cluster value
    IN      ULONG                  InUseSize,
    IN      LPBYTE                 UsedClusters,  // used clusters value
    IN      ULONG                  UsedSize
)
{
    return ERROR_CALL_NOT_IMPLEMENTED;            // not done yet...

    // just concat REG_SUBNETS Subnet REG_RANGES Range and try to open that.
    // if it fails, quit, other wise just set the given values over...
}

DWORD
FixAllClusters1(                                  // copy cluster info frm old to new cfg
    IN      HKEY                   NewCfgKey,
    IN      HKEY                   OldCfgKey
)
{
    REG_HANDLE                     Cfg, Tmp1, Tmp2;
    DWORD                          Err;
    ARRAY                          Subnets, Ranges;
    LPWSTR                         ThisSubnet, ThisRange;
    ARRAY_LOCATION                 Loc1, Loc2;

    Cfg.Key = OldCfgKey;                          // Should not poke inside directly
    MemArrayInit(&Subnets);

    Err = DhcpRegServerGetList(&Cfg, NULL, NULL, &Subnets, NULL, NULL, NULL);
    if( ERROR_SUCCESS != Err ) {
        MemArrayCleanup(&Subnets);
        return Err;
    }

    for( Err = MemArrayInitLoc(&Subnets, &Loc1)
         ; ERROR_FILE_NOT_FOUND != Err ;
         Err = MemArrayNextLoc(&Subnets, &Loc1)
    ) {                                           // for each subnet, look for ranges
        Err = MemArrayGetElement(&Subnets, &Loc1, &ThisSubnet);

        Err = DhcpRegServerGetSubnetHdl(&Cfg, ThisSubnet, &Tmp1);
        if( ERROR_SUCCESS != Err ) {              // what do we do? just ignore it I think
            continue;
        }

        Err = DhcpRegSubnetGetList(&Tmp1, NULL, &Ranges, NULL, NULL, NULL, NULL );
        if( ERROR_SUCCESS != Err ) {
            DhcpRegCloseHdl(&Tmp1);
            continue;
        }

        for( Err = MemArrayInitLoc(&Ranges, &Loc2)
             ; ERROR_FILE_NOT_FOUND != Err ;
             Err = MemArrayNextLoc(&Ranges, &Loc2)
        ) {                                       // for each range try to copy it over..
            LPBYTE                 InUseClusters = NULL, UsedClusters = NULL;
            ULONG                  InUseClustersSize = 0, UsedClustersSize = 0;

            Err = MemArrayGetElement(&Ranges, &Loc2, &ThisRange);

            Err = DhcpRegSubnetGetRangeHdl(&Tmp1, ThisRange, &Tmp2);
            if( ERROR_SUCCESS != Err ) continue;

            Err = DhcpRegRangeGetAttributes(
                &Tmp2,
                NULL /* no name */,
                NULL /* no comm */,
                NULL /* no flags */,
                NULL /* no bootp alloc */,
                NULL /* no max boop allowed */,
                NULL /* no start addr */,
                NULL /* no end addr */,
                &InUseClusters,
                &InUseClustersSize,
                &UsedClusters,
                &UsedClustersSize
            );

            if( ERROR_SUCCESS == Err ) {
                Err = FixSpecificClusters(
                    NewCfgKey, ThisSubnet, ThisRange, InUseClusters, InUseClustersSize,
                    UsedClusters, UsedClustersSize
                );
                if( InUseClusters ) MemFree(InUseClusters);
                if( UsedClusters ) MemFree(UsedClusters);
            }

            DhcpRegCloseHdl(&Tmp2);
        }

        FreeArray(&Ranges);
        DhcpRegCloseHdl(&Tmp1);
    }

    FreeArray(&Subnets);
    return ERROR_SUCCESS;
}

DWORD
FixAllClusters(                                   // copy the clusters over frm existing to DS_CONFIG
    IN      HKEY                   DsKey          // so that when it is copied back nothing is lost
)
{
    HKEY                           OldCfgKey;
    ULONG                          Disposition, Err;

    return ERROR_SUCCESS;                         // Need to fix this..

    Err = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        REG_THIS_SERVER,
        ZeroReserved,
        REG_CLASS,
        REG_OPTION_NON_VOLATILE,
        REG_ACCESS,
        NULL,
        &OldCfgKey,
        &Disposition
    );
    if( ERROR_SUCCESS != Err ) {
        return Err;                               // ugh? this should not happen
    }

    Err = FixAllClusters1(DsKey, OldCfgKey);
    RegCloseKey(OldCfgKey);
    return Err;
}


VOID
CopyDsConfigToNormalConfig(                       // copy downloaded config to normal config
    VOID
)
{
    BOOL                           Status;
    DWORD                          Err;

    Status = DeleteFile(L"TempDhcpFile.Reg" );    // this file will be used for temp. storage
    if( !Status ) {                               // could not delete this file?
        Err = GetLastError();
        if( ERROR_FILE_NOT_FOUND != Err &&        // the file does exist?
            ERROR_PATH_NOT_FOUND != Err ) {       // this could also happen?

            return;                               // the nwe wont be able to do the copy!
        }
    }
    FixAllClusters(DsConfig.Key);                 // copy the ranges values over from old to new..
    CopyRegKeys(DsConfig.Key, REG_THIS_SERVER, L"TempDhcpFile.Reg");
    DeleteFile(L"TempDhcpFile.Reg" );             // dont need this file anymore..
}

#if 0
DWORD
SaveServerClasses(                                // save all class info onto registry
    IN      PREG_HANDLE            Server,        // registry handle to server config.
    IN      PM_CLASSDEFLIST        Classes        // list of defined classes
)
{
    DWORD                          Err, Err2;
    REG_HANDLE                     Hdl;
    ARRAY_LOCATION                 Loc;
    PM_CLASSDEF                    ThisClass;

    for(                                          // save each class definition
        Err = MemArrayInitLoc(&Classes->ClassDefArray, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&Classes->ClassDefArray, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Classes->ClassDefArray, &Loc, &ThisClass);
        //= require ERROR_SUCCESS == Err && NULL != ThisClass

        Err = DhcpRegServerGetClassDefHdl(Server,ThisClass->Name,&Hdl);
        if( ERROR_SUCCESS != Err ) return Err;    // registry error?

        Err = DhcpRegClassDefSetAttributes        // save this class information
        (
            /* Hdl              */ &Hdl,
            /* Name             */ &ThisClass->Name,
            /* Comment          */ &ThisClass->Comment,
            /* Flags            */ &ThisClass->Type,
            /* Value            */ &ThisClass->ActualBytes,
            /* ValueSize        */ ThisClass->nBytes
        );

        Err2 = DhcpRegCloseHdl(&Hdl);             //= require ERROR_SUCCESS == Err2
        if( ERROR_SUCCESS != Err) return Err;     // could not set-attribs in reg.
    }

    return ERROR_SUCCESS;                         // everything went fine.
}

DWORD
SaveServerOptDefs1(                               // save some option definition
    IN      PREG_HANDLE            Server,        // registry handle to server config.
    IN      LPWSTR                 ClassName,     // name of the class of option
    IN      PM_OPTDEFLIST          OptDefList     // list of option definitions
)
{
    DWORD                          Err, Err2;
    ARRAY_LOCATION                 Loc;
    PM_OPTDEF                      ThisOptDef;

    for(                                          // save each opt definition
        Err = MemArrayInitLoc(&OptDefList->OptDefArray, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&OptDefList->OptDefArray, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&OptDefList->OptDefArray, &Loc, &ThisOptDef);
        //= require ERROR_SUCCESS == Err && NULL != ThisOptDef

        Err = DhcpRegSaveOptDef                   // save the option def
        (
            /* OptId          */ ThisOptDef->OptId,
            /* ClassName      */ ClassName,
            /* Name           */ ThisOptDef->OptName,
            /* Comment        */ ThisOptDef->OptComment,
            /* OptType        */ ThisOptDef->Type,
            /* OptVal         */ ThisOptDef->OptVal,
            /* OptLen         */ ThisOptDef->OptValLen
        );
        if( ERROR_SUCCESS != Err ) return Err;    // reg. err saving opt def
    }

    return ERROR_SUCCESS;                         // everything went fine.
}

DWORD
SaveServerOptdefs(                                // save all the opt def's onto registry
    IN      PREG_HANDLE            Server,        // registry handle to server config.
    IN      PM_OPTCLASSDEFLIST     Optdefs
)
{
    DWORD                          Err, Err2;
    ARRAY_LOCATION                 Loc;
    PM_OPTCLASSDEFL_ONE            ThisOptClass;
    LPWSTR                         ClassName;
    PM_CLASSDEF                    ClassDef;

    for(                                          // save each opt definition
        Err = MemArrayInitLoc(&Optdefs->Array, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&Optdefs->Array, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Optdefs->Array, &Loc, &ThisOptClass);
        //= require ERROR_SUCCESS == Err && NULL != ThisClass

        if( 0 == ThisOptClass->ClassId ) {        // no class for this option
            ClassName = NULL;
        } else {                                  // lookup class in this server struct
            Err = MemServerGetClassDef(
                CurrentServer,                    // need to pass this as param
                ThisOptClass->ClassId,
                NULL,
                0,
                NULL,
                &ClassDef
            );
            if( ERROR_SUCCESS != Err) return Err; // could not find the class? invalid struct
            ClassName = ClassDef->Name;           // found the class, use this name
        }

        Err = SaveServerOptDefs1(Server, ClassName, &ThisOptClass->OptDefList);
        if( ERROR_SUCCESS != Err) return Err;     // could not save some opt definition..
    }

    return ERROR_SUCCESS;                         // everything went fine.
}

DWORD
SaveServerOptions1(                               // save some option
    IN      PREG_HANDLE            Server,        // registry handle to server config.
    IN      LPWSTR                 ClassName,     // name of the class of option
    IN      PM_OPTLIST             OptList        // list of options
)
{
    DWORD                          Err, Err2;
    ARRAY_LOCATION                 Loc;
    PM_OPTION                      ThisOpt;

    for(                                          // save each option
        Err = MemArrayInitLoc(OptList, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(OptList, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(OptList, &Loc, &ThisOpt);
        //= require ERROR_SUCCESS == Err && NULL != ThisOpt

        Err = DhcpRegSaveGlobalOption             // save the option
        (
            /* OptId          */ ThisOpt->OptId,
            /* ClassName      */ ClassName,
            /* Value          */ ThisOpt->Val,
            /* ValueSize      */ ThisOpt->Len
        );
        if( ERROR_SUCCESS != Err ) return Err;    // reg. err saving option
    }

    return ERROR_SUCCESS;                         // everything went fine.
}

DWORD
SaveServerOptions(                                // save all options onto registry
    IN      PREG_HANDLE            Server,        // registry handle to server config.
    IN      PM_OPTCLASS            Options
)
{
    DWORD                          Err, Err2;
    ARRAY_LOCATION                 Loc;
    PM_ONECLASS_OPTLIST            ThisOptClass;
    LPWSTR                         ClassName;
    PM_CLASSDEF                    ClassDef;

    for(                                          // save each class definition
        Err = MemArrayInitLoc(&Options->Array, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&Options->Array, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Options->Array, &Loc, &ThisOptClass);
        //= require ERROR_SUCCESS == Err && NULL != ThisOptClass

        if( 0 == ThisOptClass->ClassId ) {        // no class for this option
            ClassName = NULL;
        } else {                                  // lookup class in this server struct
            Err = MemServerGetClassDef(
                CurrentServer,                    //  need to pass this as param
                ThisOptClass->ClassId,
                NULL,
                0,
                NULL,
                &ClassDef
            );
            if( ERROR_SUCCESS != Err) return Err; // could not find the class? invalid struct
            ClassName = ClassDef->Name;           // found the class, use this name
        }

        Err = SaveServerOptions1(Server, ClassName, &ThisOptClass->OptList);
        if( ERROR_SUCCESS != Err) return Err;     // could not save some option..
    }

    return ERROR_SUCCESS;                         // everything went fine.

}

DWORD
SaveServerScope(                                  // save unicast-or-mcast scope onto reg.
    IN      PREG_HANDLE            ServerHdl,     // registry handle to server config
    IN      PM_SERVER              MemServer,     // server object in memory
    IN      LPVOID                 Scope,         // either PM_SUBNET or PM_MSCOPE object
    IN      BOOL                   fSubnet        // TRUE ==> Subnet type, FALSE ==> MScope type.
)
{
    DWORD                          Err;
    PM_SUBNET                      Subnet = Scope;
    PM_MSCOPE                      Subnet = MScope;
    PM_SSCOPE                      SScope;

    if( fSubnet ) {                               // if subnet, need to add it to superscope..
        if( 0 != Subnet->SuperScopeId ) {         // this belongs to superscope?
            Err = MemServerFindSScope(MemServer, Subnet->SuperScopeId, NULL, &SScope);
            if( ERROR_SUCCESS != Err ) {          // wrong superscope?  invlaid data
                return Err;
            }
            Err = DhcpRegSScopeSaveSubnet(SScope->Name, Subnet->Address);
            if( ERROR_SUCCESS != Err ) return Err;// could not add subnet to superscope?
        }
    }

    if( fSubnet ) {
        Err = DhcpRegSaveSubnet                   // save this subnet
        (
            /* SubnetAddress    */ Subnet->Address,
            /* SubnetMask       */ Subnet->Mask,
            /* SubnetState      */ Subnet->State,
            /* SubnetName       */ Subnet->Name
            /* SubnetComment    */ Subnet->Description
        );
    } else {
        Err = DhcpRegSaveMScope                   // save this mcast scope
        (
            /* MScopeId         */ MScope->MScopeId,
            /* SubnetState      */ MScope->State,
            /* AddressPolicy    */ MScope->Policy,
            /* TTL              */ MScope->TTL,
            /* pMScopeName      */ MScope->Name,
            /* pMScopeComment   */ MScope->Description,
            /* LangTag          */ MScope->LangTag,
            /* ExpiryTime       */ &MScope->ExpiryTime
        );
    }
    if( ERROR_SUCCESS != Err ) return Err;        // could not save subnet info?


}

DWORD
SaveServerScopes(                                 // save unicast-or-mcast scopes onto reg.
    IN      PREG_HANDLE            Server,        // registry handle to server config.
    IN      PARRAY                 Scopes,        // array of PM_SUBNET or PM_MSCOPE types
    IN      BOOL                   fSubnet        // TRUE ==> Subnet type, FALSE ==> MScope type.
)
{
    DWORD                          Err;
    ARRAY_LOCATION                 Loc;
    PM_SUBNET                      Subnet;

    for(                                          // save each scope..
        Err = MemArrayInitLoc(Scopes, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(Scopes, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(Scopes, &Loc, &Subnet);
        //= require ERROR_SUCCESS == Err && NULL != Subnet

        Err = SaveServerScope(Server, CurrentServer, Subnet, fSubnet);
        if( ERROR_SUCCESS != Err ) return Err;    // could not save the subnet/m-scope..
    }
    return ERROR_SUCCESS;
}

DWORD
SaveServerSubnets(                                // save all subnet info onto reg.
    IN      PREG_HANDLE            Server,        // registry handle to server config.
    IN      PARRAY                 Subnets        // array of type PM_SUBNET elements
)
{
    return SaveServerScopes(Server, Subnets, TRUE);  // call common routine
}

DWORD
SaveServerMScopes(                                // save all the m-cast scopes onto reg.
    IN      PREG_HANDLE            Server,        // registry handle to server config.
    IN      PARRAY                 MScopes        // array of type PM_MSCOPE elements
)
{
    return SaveServerScopes(Server, MScopes, FALSE); // call common routine
}


DWORD
DownloadServerInfoFromDs(                         // save the server info onto registry
    IN      PM_SERVER              Server         // the server to save onto registry
)
{
    DWORD                          Err;
    REG_HANDLE                     Hdl, Hdl2;
    ARRAY_LOCATION                 Loc;

    CurrentServer = Server;                       // this global used by several funcs above..

    Err = DhcpRegGetThisServer(&Hdl);             // get current server hdl
    if( ERROR_SUCCESS != Err ) return Err;

    Err = DhcpRegServerSetAttributes              // set server attributes
    (
        /* PREG_HANDLE  Hdl     */ &Hdl,
        /* LPWSTR *Name         */ &Server->Name,
        /* LPWSTR *Comment      */ &Server->Comment,
        /* DWORD  *Flags        */ &Server->State
    );
    // ignore errors..

    Err = SaveServerClasses(&Hdl, &Server->ClassDefs);
    if( ERROR_SUCCESS == Err ) {                  // saved classes? save optdefs..
        Err = SaveServerOptdefs(&Hdl, &Server->OptDefs);
    }
    if( ERROR_SUCCESS == Err ) {                  // saved optdefs? save options..
        Err = SaveServerOptions(&Hdl, &Server->Options);
    }
    if( ERROR_SUCCESS == Err ) {                  // saved options? save subnets..
        Err = SaveServerSubnets(&Hdl, &Server->Subnets);
    }
    if( ERROR_SUCCESS == Err ) {                  // saved subnets? save mcast scopes
        Err = SaveServerMScopes(&Hdl, &Server->MScopes);
    }

    (void)DhcpRegCloseHdl(&Hdl);                  // free resource
    return Err;
}

#endif  0

DWORD
DownloadServerInfoFromDs(                         // save the server info onto registry
    IN      PM_SERVER              Server         // the server to save onto registry
)
{
    return DhcpRegServerSave(Server);
}

DWORD
DownloadFromDsForReal(                            // really try to downlaod from DS
    IN      LPWSTR                 ServerName
)
{
    DWORD                          Err, Err2;
    ARRAY                          Servers;
    ARRAY_LOCATION                 Loc;
    PM_SERVER                      ThisServer;

    Err = MemArrayInit(&Servers);                 // initialize array
    if( ERROR_SUCCESS != Err ) return Err;

    Err = DhcpDsGetEnterpriseServers              // fetch the server info from DS
    (
        /* Reserved             */ ZeroReserved,
        /* ServerName           */ ServerName,
        /* Servers              */ &Servers
    );

    Err2 = ERROR_SUCCESS;                         // init return value
    for(                                          // process all the information
        Err = MemArrayInitLoc(&Servers, &Loc)
        ; ERROR_FILE_NOT_FOUND != Err ;
        Err = MemArrayNextLoc(&Servers, &Loc)
    ) {
        //= require ERROR_SUCCESS == Err
        Err = MemArrayGetElement(&Servers, &Loc, &ThisServer);
        //= require ERROR_SUCCESS == Err && NULL != ThisServer

        Err = DownloadServerInfoFromDs(ThisServer);
        if( ERROR_SUCCESS != Err ) {              // oops.. could not do it?
            Err2 = Err;                           // store error..
        }

        MemServerFree(ThisServer);                // free all this memory.
    }

    Err = MemArrayCleanup(&Servers);              // free mem allcoated for array
    if( ERROR_SUCCESS != Err ) Err2 = Err;        // something went wrong?

    return Err2;
}


//================================================================================
// the only exported function is this.
//================================================================================

VOID
DhcpRegDownloadDs(                                // safe download of stuff onto registry
    IN      LPWSTR                 ServerName     // name of dhcp servre to download for
)
{
    DWORD                          Err;


    Err = PrepareRegistryForDsDownload();         // prepare the Config.DS key and stuff..
    if( ERROR_SUCCESS != Err ) return;            // oops, could not even do this?

    Err = DownloadFromDsForReal(ServerName);      // actually try to download from DS.
    if( ERROR_SUCCESS == Err ) {                  // could actually download successfully
        CopyDsConfigToNormalConfig();             // now copy this configuration to nrml loc.
    }

    CleanupAfterDownload();                       // now cleanup the regsitry handles etc..
    DhcpRegUpdateTime();                          // fix the time stamp to now..
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mmreg\regread.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: This implements the init time reading in of the registry
// (this may/may work even when used to read at any other time.. but is not efficient)
//================================================================================

#include    <mmregpch.h>
#include    <regutil.h>
#include    <regsave.h>


#define     InitArray(X)           do{DWORD Error = MemArrayInit((X)); Require(ERROR_SUCCESS == Error); }while(0)
#define     ERRCHK                 do{if( ERROR_SUCCESS != Error ) goto Cleanup; }while(0)
#define     FreeArray1(X)          Error = LoopThruArray((X), DestroyString, NULL, NULL);Require(ERROR_SUCCESS == Error);
#define     FreeArray2(X)          Error = MemArrayCleanup((X)); Require(ERROR_SUCCESS == Error);
#define     FreeArray(X)           do{ DWORD Error; FreeArray1(X); FreeArray2(X); }while(0)

#if DBG
#define     Report(Who)            if(Error) DbgPrint("[DHCPServer] %s: %ld [0x%lx]\n", Who, Error, Error)
#define     INVALID_REG            DbgPrint
#else
#define     Report(Who)
#define     INVALID_REG            (void)
#endif


typedef     DWORD                  (*ARRAY_FN)(PREG_HANDLE, LPWSTR ArrayString, LPVOID MemObject);

DWORD
LoopThruArray(
    IN      PARRAY                 Array,
    IN      ARRAY_FN               ArrayFn,
    IN      PREG_HANDLE            Hdl,
    IN      LPVOID                 MemObject
)
{
    DWORD                          Error;
    ARRAY_LOCATION                 Loc;
    LPWSTR                         ArrayString;

    Error = MemArrayInitLoc(Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(Array, &Loc, (LPVOID *)&ArrayString);
        Require(ERROR_SUCCESS == Error && ArrayString);

        Error = ArrayFn(Hdl, ArrayString, MemObject);
        if( ERROR_SUCCESS != Error ) {
            //
            // Operation failed -- but ignore it.
            //
            // return Error;
        }

        Error = MemArrayNextLoc(Array, &Loc);
    }

    return ERROR_SUCCESS;
}

DWORD
DestroyString(
    IN      PREG_HANDLE            Unused,
    IN      LPWSTR                 StringToFree,
    IN      LPVOID                 Unused2
)
{
    MemFree(StringToFree);
    return ERROR_SUCCESS;
}

DWORD
WStringToAddress(
    IN      LPWSTR                 Str
)
{
    CHAR                           IpString[100];
    DWORD                          Count;

    Count = wcstombs(IpString, Str, sizeof(IpString)-1);
    if( -1 == Count ) return 0;

    return htonl(inet_addr(IpString));
}

DWORD
ConvertWStringToDWORD(
    IN      LPWSTR                 Str
)
{
    return  _wtoi(Str);
}

DWORD
DhcpRegpSubnetAddServer(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 ServerName,
    IN      PM_SUBNET              Subnet
)
{
    return ERROR_SUCCESS;
}

DWORD
SetBitForRange(
    IN      PM_RANGE               Range,
    IN      DWORD                  Address
)
{
    BOOL                           WasSet;
    if( Address > Range->End || Address < Range->Start )
        return ERROR_INVALID_PARAMETER;

    return MemBitSetOrClear(
        Range->BitMask,
        Address - Range->Start,
        TRUE,
        &WasSet
    );
}


DWORD GlobalWorkingOnOldStyleSubnet = 0;
DWORD GlobalWorkingOnPreWin2kMScope =  0;
const       DWORD                  One = 0x1;

DWORD
DhcpRegFillClusterAddresses(
    IN OUT  PM_RANGE               Range,
    IN      LPBYTE                 InUseClusters,
    IN      DWORD                  InUseClustersSize,
    IN      LPBYTE                 UsedClusters,
    IN      DWORD                  UsedClustersSize
) {
    DWORD                          Error;
    DWORD                          i;
    DWORD                          Address;
    DWORD   UNALIGNED*             InUseBits;
    DWORD   UNALIGNED*             UsedBits;
    DWORD                          nInUseBits;
    DWORD                          nUsedBits;

    if( InUseClusters && InUseClustersSize ) {
        nInUseBits = InUseClustersSize/sizeof(DWORD);
        InUseBits = (DWORD UNALIGNED*)InUseClusters;

        Require(nInUseBits == 2*InUseBits[0] + 1 );
        nInUseBits --; InUseBits ++;

        while(nInUseBits) {
            for(i = 0; i < sizeof(DWORD)*8; i ++ )
                if( InUseBits[1] & ( One << i ) )
                    SetBitForRange(Range, InUseBits[0] + i );
            nInUseBits -= 2;
            InUseBits += 2;
        }
    }

    if( UsedClusters && UsedClustersSize ) {
        nUsedBits = UsedClustersSize/sizeof(DWORD);
        UsedBits = (DWORD UNALIGNED*)UsedClusters;

        Require(nUsedBits == UsedBits[0] + 1);
        nUsedBits --; UsedBits ++;

        while(nUsedBits) {
            for( i = 0; i < sizeof(DWORD)*8; i ++ )
                SetBitForRange(Range, UsedBits[0] + i);
            UsedBits ++;
            nUsedBits --;
        }
    }

    return ERROR_SUCCESS;
}

static      DWORD                  Masks[] = {
    0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80
};

DWORD
DhcpRegpFillBitsForRange(
    IN      LPBYTE                 Buffer,
    IN      ULONG                  BufSize,
    IN OUT  PM_RANGE               Range,
    IN      PM_SUBNET              Subnet
)
{
    ULONG                          Size, AllocSize, nSet, Offset;
    ULONG                          nBitsSet, Index;
    ULONG                          Error;

    Size = ntohl(((UNALIGNED DWORD *)Buffer)[0]);
    AllocSize = ntohl(((UNALIGNED DWORD *)Buffer)[1]);
    nSet = ntohl(((UNALIGNED DWORD *)Buffer)[2]);
    Offset = ntohl(((UNALIGNED DWORD *)Buffer)[3]);


    //
    // do not check for validity of the offset sizes.
    // SetBitForRange does this check anyway.
    //
    
    // if( Range->Start + Offset + Size > 1+Range->End )
    //     return ERROR_INVALID_DATA;
    
    Require(nSet != 0);
    if( nSet == 0 ) return ERROR_SUCCESS;
    if( nSet == Size ) {
        Require( AllocSize == 0 );
        for( Index = 0; Index < nSet ; Index ++ ) {
            Error = SetBitForRange(Range, Range->Start + Index);
            Require( ERROR_SUCCESS == Error );
        }
        return ERROR_SUCCESS;
    }

    if( AllocSize + sizeof(DWORD)*4  != BufSize ) return ERROR_INVALID_DATA;

    nBitsSet = 0;
    Require( Size/8 <= AllocSize );
    for( Index = 0; Index < Size ; Index ++ ) {
        if( Buffer[ 4*sizeof(DWORD) + (Index/8) ] & Masks[Index%8] ) {
            nBitsSet ++;
            //
            // whistler bug 283457, offset not taken into account
            //
            Error = SetBitForRange( Range, Range->Start + Index + Offset );
            Require( ERROR_SUCCESS == Error );
        }
    }

    Require(nBitsSet == nSet);
    return ERROR_SUCCESS;
}

static
BYTE TempBuffer[MAX_BIT1SIZE + sizeof(DWORD)*4];

DWORD
DhcpRegpFillBitmasks(
    IN      HKEY                   Key,
    IN      PM_RANGE               Range,
    IN      PM_SUBNET              Subnet
)
{
    ULONG                          Error, nValues, Index;
    WCHAR                          ValueNameBuf[100];
    DWORD                          ValueNameSize, ValueType;
    DWORD                          ValueSize;
    WCHAR                          RangeStartStr[30];
    BOOL                           fPostNt5 = FALSE;
    REG_HANDLE                     Hdl;
    
    if( NULL == Key ) {
        ConvertAddressToLPWSTR( Range->Start, RangeStartStr);
        fPostNt5 = TRUE;
        Error = DhcpRegGetThisServer( &Hdl );
        if( NO_ERROR != Error ) return Error;
        Key = Hdl.Key;
    }
            
    Error = RegQueryInfoKey(
        Key, NULL, NULL, NULL, NULL, NULL, NULL, &nValues, NULL, NULL, NULL, NULL
    );
    if( ERROR_SUCCESS != Error ) goto Cleanup;

    Index = nValues -1;
    while( nValues ) {

        ValueNameSize = sizeof(ValueNameBuf)/sizeof(WCHAR);
        ValueSize = sizeof(TempBuffer)/sizeof(WCHAR);
        Error = RegEnumValue(
            Key,
            Index,
            ValueNameBuf,
            &ValueNameSize,
            NULL,
            &ValueType,
            TempBuffer,
            &ValueSize
        );
        if( ERROR_SUCCESS != Error ) goto Cleanup;

        if( fPostNt5 && 0 != wcsncmp(
            ValueNameBuf, RangeStartStr, wcslen(RangeStartStr)) ) {
    
            //
            // Skip irrelevant bitmaps
            //

            Index --;
            nValues --;
            continue;
        }
        
        if( REG_BINARY == ValueType && ValueSize >= sizeof(DWORD)*4 ) {
            Error = DhcpRegpFillBitsForRange(
                TempBuffer,
                ValueSize,
                Range,
                Subnet
            );
            if( ERROR_SUCCESS != Error ) {
                Require(FALSE);
                goto Cleanup;
            }
        }

        Index --;
        nValues --;
    }

    Cleanup:

        if( fPostNt5 ) {
            DhcpRegCloseHdl( &Hdl );
        }

        return Error;
}


DWORD
DhcpRegpSubnetAddRange(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 RangeName,
    IN      PM_SUBNET              Subnet
)
{
    DWORD                          LocalError;
    DWORD                          Error;
    REG_HANDLE                     Hdl2;
    LPWSTR                         Name = NULL;
    LPWSTR                         Comment = NULL;
    DWORD                          Flags;
    DWORD                          StartAddress;
    DWORD                          EndAddress;
    LPBYTE                         InUseClusters = NULL;
    DWORD                          InUseClustersSize;
    LPBYTE                         UsedClusters = NULL;
    DWORD                          UsedClustersSize;
    ULONG                          Alloc, MaxAlloc;
    PM_RANGE                       OverlappingRange;
    PM_RANGE                       ThisRange = NULL;
    BOOL                           fRangeAdded = FALSE;
    
    Error = DhcpRegSubnetGetRangeHdl(Hdl, RangeName, &Hdl2);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegRangeGetAttributes(
        &Hdl2,
        &Name,
        &Comment,
        &Flags,
        &Alloc,
        &MaxAlloc,
        &StartAddress,
        &EndAddress,
        &InUseClusters,
        &InUseClustersSize,
        &UsedClusters,
        &UsedClustersSize
    );
    ERRCHK;

    if( 0 == StartAddress || 0 == EndAddress ) {
        INVALID_REG("[DHCPServer] Noticed undefined range: %ws (ignored)\n", RangeName);
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    if( FALSE == Subnet->fSubnet && GlobalWorkingOnPreWin2kMScope ) {
        Subnet->MScopeId = StartAddress;
        GlobalWorkingOnPreWin2kMScope = FALSE;
    }

    Error = MemSubnetAddRange(
        Subnet,
        StartAddress,
        EndAddress,
        Flags,
        Alloc,
        MaxAlloc,
        &OverlappingRange
    );
    ERRCHK;

    fRangeAdded = TRUE;
    
    Error = MemSubnetGetAddressInfo(
        Subnet,
        StartAddress,
        &ThisRange,
        NULL,
        NULL
    );
    ERRCHK;

    if( InUseClustersSize || UsedClustersSize ) {

        //
        // Old style information?  Save it as new style
        //

        GlobalWorkingOnOldStyleSubnet ++;
        DhcpRegFillClusterAddresses(
            ThisRange,
            InUseClusters,
            InUseClustersSize,
            UsedClusters,
            UsedClustersSize
        );  // this is always returning ERROR_SUCCESS.

        //
        // Error = FlushRanges(ThisRange, FLUSH_ANYWAY, Subnet);
        // Require( ERROR_SUCCESS == Error );
        //
        // Do not actually write back the stuff to the registry..
        // This read code path is used in dhcpexim at which time
        // the registry should not be munged..
        //
        
    } else {

        //
        // Need to read new style bitmasks..
        //

        Error = DhcpRegpFillBitmasks(
            Hdl2.Key,
            ThisRange,
            Subnet
        );
        Require( ERROR_SUCCESS == Error );
    }

  Cleanup:
    Report("SubnetAddRange");

    if( ERROR_SUCCESS != Error && ThisRange ) {
        if( !fRangeAdded ) {
            LocalError = MemRangeCleanup(ThisRange);
            Require( ERROR_SUCCESS == LocalError );
        } else {
            LocalError = MemSubnetDelRange( 
                Subnet, StartAddress );
            Require( ERROR_SUCCESS == LocalError );
        }
    }
    
    if( Name ) MemFree(Name);
    if( Comment ) MemFree(Comment);
    if( InUseClusters ) MemFree(InUseClusters);
    if( UsedClusters ) MemFree(UsedClusters);

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == LocalError);

    return Error;
}

DWORD
DhcpRegpReservationAddOption(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 OptionName,
    IN      PM_RESERVATION         Reservation
)
{
    DWORD                          Error;
    DWORD                          LocalError;
    REG_HANDLE                     Hdl2;
    DWORD                          OptionId;
    LPWSTR                         ClassName = NULL;
    LPWSTR                         VendorName = NULL;
    DWORD                          Flags;
    LPBYTE                         Value = NULL;
    DWORD                          ValueSize;
    DWORD                          ClassId;
    DWORD                          VendorId;
    PM_OPTION                      Option = NULL;
    PM_OPTION                      DeletedOption = NULL;
    PM_CLASSDEF                    ThisClasDef;

    Error = DhcpRegReservationGetOptHdl(Hdl, OptionName, &Hdl2);
    if(ERROR_SUCCESS != Error) return Error;

    Error = DhcpRegOptGetAttributes(
        &Hdl2,
        &OptionId,
        &ClassName,
        &VendorName,
        &Flags,
        &Value,
        &ValueSize
    );
    ERRCHK;

    if( OptionId == 0 )  // old registry format does not contain "OptionId" value => it can be taken from the key name.
        OptionId = _wtol(OptionName);

    if( OptionId == 0 || NULL == Value || 0 == ValueSize ) {
        INVALID_REG("[DHCPServer] Found invalid option %ws (ignored)\n", OptionName);
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    if( NULL == ClassName || wcslen(ClassName) == 0) ClassId = 0;
    else {
        PM_SUBNET                  Subnet = Reservation->SubnetPtr;
        PM_SERVER                  Server = Subnet->ServerPtr;
        Error = MemServerGetClassDef(Server,0, ClassName,0,NULL,&ThisClasDef);
        if( ERROR_SUCCESS != Error ) {
            if (*(DWORD *)ClassName != OptionId)    // some registry entries were corrupted due to an old bug. Load these entries too (see bug #192933)
            {
                INVALID_REG("ReservationAddOption(%ws): unknown class (ignored)\n", OptionName);
                Error = ERROR_SUCCESS;
                goto Cleanup;
            }
            else
            {
                ClassId = 0;
            }

        } else {
            ClassId = ThisClasDef->ClassId;
            Require(ThisClasDef->IsVendor == FALSE);
        }
    }

    if( NULL == VendorName || wcslen(VendorName) == 0 ) VendorId = 0;
    else {
        PM_SUBNET                  Subnet = Reservation->SubnetPtr;
        PM_SERVER                  Server = Subnet->ServerPtr;
        Error = MemServerGetClassDef(Server,0, VendorName,0,NULL,&ThisClasDef);
        if( ERROR_SUCCESS != Error ) {
            INVALID_REG("ReservationAddOption(%ws): unknown vendor (ignored)\n", OptionName);
            Error = ERROR_SUCCESS;
            goto Cleanup;
        } else {
            VendorId = ThisClasDef->ClassId;
            Require(ThisClasDef->IsVendor == TRUE);
        }
    }

    if( 0 == OptionId ) OptionId = ConvertWStringToDWORD(OptionName);

    Error = MemOptInit(&Option, OptionId, ValueSize, Value);
    ERRCHK;

    Error = MemOptClassAddOption(&(Reservation->Options), Option, ClassId, VendorId, &DeletedOption);
    ERRCHK;

  Cleanup:
    Report("ReservationAddOption");

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == LocalError);
    if( ClassName ) MemFree(ClassName);
    if( VendorName ) MemFree(VendorName);
    if( Value ) MemFree(Value);
    if( DeletedOption ) {
        LocalError = MemOptCleanup(DeletedOption);
        Require(ERROR_SUCCESS == LocalError);
    }
    if( ERROR_SUCCESS != Error && Option ) {
        LocalError = MemOptCleanup(Option);
        Require(ERROR_SUCCESS == LocalError);
    }
    return Error;

}

DWORD
DhcpRegpSubnetAddReservation(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 ReservationName,
    IN      PM_SUBNET              Subnet
)
{
    DWORD                          LocalError;
    DWORD                          Error;
    REG_HANDLE                     Hdl2;
    LPWSTR                         Name = NULL;
    LPWSTR                         Comment = NULL;
    DWORD                          Flags;
    DWORD                          Address;
    LPBYTE                         ClientUID = NULL;
    DWORD                          ClientUIDSize;
    PM_RESERVATION                 ThisReservation;
    ARRAY                          Options;

    Error = DhcpRegSubnetGetReservationHdl(Hdl, ReservationName, &Hdl2);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegReservationGetAttributes(
        &Hdl2,
        &Name,
        &Comment,
        &Flags,
        &Address,
        &ClientUID,
        &ClientUIDSize
    );
    ERRCHK;

    if( 0 == Address || NULL == ClientUID || 0 == ClientUIDSize ) {
        INVALID_REG("[DHCPServer] Found invalid reservation %ws (ignored)\n", ReservationName);
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    Error = MemReserveAdd(
        &(Subnet->Reservations),
        Address,
        Flags,
        ClientUID,
        ClientUIDSize
    );
    // if the reservation is a duplicate ignore the error and do no further processing as the
    // reservation structure was already initialized. The duplicate reservation will simply be
    // ignored.
    if (ERROR_SUCCESS == Error)
    {
        Error = MemReserveFindByAddress(
            &(Subnet->Reservations),
            Address,
            &ThisReservation
        );
        ERRCHK;

        ThisReservation->SubnetPtr = Subnet;

        Error = MemArrayInit(&Options);
        ERRCHK;

        Error = DhcpRegReservationGetList(
            &Hdl2,
            &Options
        );
        ERRCHK;

        Error = LoopThruArray(&Options, DhcpRegpReservationAddOption, &Hdl2, ThisReservation);

    } else if ( ERROR_OBJECT_ALREADY_EXISTS == Error )
        Error = ERROR_SUCCESS;

  Cleanup:
    Report("SubnetAddReservation");

    if( Name ) MemFree(Name);
    if( Comment ) MemFree(Comment);
    if( ClientUID ) MemFree(ClientUID);

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == LocalError);

    FreeArray(&Options);
    return Error;
}


DWORD
DhcpRegpSubnetAddOption(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 OptionName,
    IN      PM_SUBNET              Subnet
)
{
    DWORD                          Error;
    DWORD                          LocalError;
    REG_HANDLE                     Hdl2;
    DWORD                          OptionId;
    LPWSTR                         ClassName = NULL;
    LPWSTR                         VendorName = NULL;
    DWORD                          Flags;
    LPBYTE                         Value = NULL;
    DWORD                          ValueSize;
    DWORD                          ClassId;
    DWORD                          VendorId;
    PM_OPTION                      Option = NULL;
    PM_OPTION                      DeletedOption = NULL;
    PM_CLASSDEF                    ThisClasDef;

    Error = DhcpRegSubnetGetOptHdl(Hdl, OptionName, &Hdl2);
    if(ERROR_SUCCESS != Error) return Error;

    Error = DhcpRegOptGetAttributes(
        &Hdl2,
        &OptionId,
        &ClassName,
        &VendorName,
        &Flags,
        &Value,
        &ValueSize
    );
    ERRCHK;

    if( OptionId == 0 )  // old registry format does not contain "OptionId" value => it can be taken from the key name.
        OptionId = _wtol(OptionName);


    if( OptionId == 0 || NULL == Value || 0 == ValueSize ) {
        INVALID_REG("[DHCPServer] Found invalid option %ws (ignored)\n", OptionName);
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    if( NULL == ClassName || wcslen(ClassName) == 0) ClassId = 0;
    else {
        Error = MemServerGetClassDef((PM_SERVER)(Subnet->ServerPtr),0, ClassName,0,NULL,&ThisClasDef);
        if( ERROR_SUCCESS != Error ) {
            if (*(DWORD *)ClassName != OptionId)    // some registry entries were corrupted due to an old bug. Load these entries too (see bug #192933)
            {
                INVALID_REG("SubnetAddOption(%ws): unknown class (ignored)\n", OptionName);
                Error =  ERROR_SUCCESS;
                goto Cleanup;
            }
            else
            {
                ClassId = 0;
            }
        } else {
            ClassId = ThisClasDef->ClassId;
            Require(ThisClasDef->IsVendor == FALSE);
        }
    }
    if( NULL == VendorName || wcslen(VendorName) == 0 ) VendorId = 0;
    else {
        Error = MemServerGetClassDef((PM_SERVER)(Subnet->ServerPtr),0, VendorName,0,NULL,&ThisClasDef);
        if( ERROR_SUCCESS != Error ) {
            INVALID_REG("SubnetAddOption(%ws): unknown class (ignored)\n", OptionName);
            Error =  ERROR_SUCCESS;
            goto Cleanup;
        } else {
            VendorId = ThisClasDef->ClassId;
            Require(ThisClasDef->IsVendor == TRUE);
        }
    }
    if( 0 == OptionId ) OptionId = ConvertWStringToDWORD(OptionName);

    Error = MemOptInit(&Option, OptionId, ValueSize, Value);
    ERRCHK;

    Error = MemOptClassAddOption(&(Subnet->Options), Option, ClassId, VendorId, &DeletedOption);
    ERRCHK;

  Cleanup:
    Report("Subnet Add Option");

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == LocalError);
    if( ClassName ) MemFree(ClassName);
    if( VendorName ) MemFree(VendorName);
    if( Value ) MemFree(Value);
    if( DeletedOption ) {
        LocalError = MemOptCleanup(DeletedOption);
        Require(ERROR_SUCCESS == LocalError);
    }
    if( ERROR_SUCCESS != Error && Option ) {
        LocalError = MemOptCleanup(Option);
        Require(ERROR_SUCCESS == LocalError);
    }
    return Error;

}

DWORD
DhcpRegSubnetAddExclusions(
    IN      PM_SUBNET              Subnet,
    IN      LPBYTE                 Excl,
    IN      DWORD                  ExclSize
)
{
    DWORD   UNALIGNED*             Addr;
    DWORD                          Count, i, j;
    DWORD                          Error;
    PM_EXCL                        OverlappingExcl;

    Count = ExclSize / sizeof(DWORD);
    Addr = (DWORD UNALIGNED*)Excl;

    if( 0 == Count || 0 == Addr[0] || 0 == Addr[1] ) {
        INVALID_REG("[DHCPServer] invalid exclusion ignored\n");
        return ERROR_SUCCESS;
    }

    Require(Count == 2*Addr[0] + 1);
    Count --; Addr ++;

    while(Count) {
        Error = MemSubnetAddExcl(
            Subnet,
            Addr[0],
            Addr[1],
            &OverlappingExcl
        );
        if( ERROR_SUCCESS != Error ) {
            INVALID_REG("[DHCPServer] DhcpRegSubnetAddExclusions:MemSubnetAddExcl;0x%lx\n", Error);
        } else {
            if( Subnet->fSubnet && GlobalWorkingOnOldStyleSubnet ) {
                //
                // For subnets alone (not mscopes), check if
                // we are upgrading from pre-win2k -- then make sure
                // all address from the excluded range are removed
                // from the bitmask
                //
            
                for( i = Addr[0]; i <= Addr[1]; i ++ ) {
                    MemSubnetReleaseAddress(
                        Subnet, i, FALSE
                        );
                }
            }
        
        }

        Addr += 2;
        Count -= 2;
    }
    return ERROR_SUCCESS;
}

DWORD
DhcpRegServerAddSubnet(
    IN      PREG_HANDLE            Hdl,
    IN      PM_SERVER              Server,
    IN      PM_SUBNET              Subnet
)
{
    DWORD                          Error;
    DWORD                          Index;
    ARRAY                          Servers;
    ARRAY                          IpRanges;
    ARRAY                          Reservations;
    ARRAY                          Options;
    LPBYTE                         Excl = NULL;
    DWORD                          ExclSize;
    struct {
        PARRAY                     Array;
        ARRAY_FN                   Fn;
    } Lists[] = {
        &Servers,                  DhcpRegpSubnetAddServer,
        &IpRanges,                 DhcpRegpSubnetAddRange,
        &Reservations,             DhcpRegpSubnetAddReservation,
        &Options,                  DhcpRegpSubnetAddOption
    };

    Subnet->ServerPtr = Server;
    for( Index = 0; Index < sizeof(Lists)/sizeof(Lists[0]); Index ++ ) {
        InitArray(Lists[Index].Array);
    }

    Error = DhcpRegSubnetGetList(
        Hdl, &Servers, &IpRanges, &Reservations, &Options, &Excl, &ExclSize
    );

    GlobalWorkingOnOldStyleSubnet = 0;
    for( Index = 0; Index < sizeof(Lists)/sizeof(Lists[0]); Index ++ ) {
        Error = LoopThruArray(Lists[Index].Array, Lists[Index].Fn, Hdl, Subnet);
        ERRCHK;
    }

    if( GlobalWorkingOnOldStyleSubnet ) {
        Report("Old style subnet found, careful with exclusions\n");
    }
    
    if( Excl ) Error = DhcpRegSubnetAddExclusions(Subnet, Excl, ExclSize);
    
    ERRCHK;

    Error = Subnet->fSubnet ? MemServerAddSubnet(Server, Subnet)
                            : MemServerAddMScope(Server, Subnet);

  Cleanup:
    GlobalWorkingOnOldStyleSubnet = 0;
    GlobalWorkingOnPreWin2kMScope = 0;
    Report("ServerAddSubnet");

    for( Index = 0; Index < sizeof(Lists)/sizeof(Lists[0]); Index ++ ) {
        FreeArray(Lists[Index].Array);
    }

    return Error;
}

DWORD
DhcpRegServerAddMScope(
    IN      PREG_HANDLE            Hdl,
    IN      PM_SERVER              Server,
    IN      PM_MSCOPE              MScope
)
{
    return DhcpRegServerAddSubnet(Hdl, Server, MScope);
}

DWORD
DhcpRegServerAddSScope(
    IN      PREG_HANDLE            Hdl,
    IN      PM_SERVER              Server,
    IN      PM_SSCOPE              SScope
)
{
    DWORD                          Error;
    ARRAY                          Subnets;
    ARRAY_LOCATION                 Loc;
    LPWSTR                         SubnetWString;
    DWORD                          SubnetAddress;
    PM_SUBNET                      Subnet;

    InitArray(&Subnets);

    Error = DhcpRegSScopeGetList(Hdl, &Subnets);
    ERRCHK;

    Error = MemArrayInitLoc(&Subnets, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Subnets, &Loc, &SubnetWString);
        Require(ERROR_SUCCESS == Error && SubnetWString);

        SubnetAddress = WStringToAddress(SubnetWString);

        Error = MemServerGetAddressInfo(
            Server,
            SubnetAddress,
            &Subnet,
            NULL,
            NULL,
            NULL
        );
        if( ERROR_SUCCESS == Error && Subnet ) {
            Error = MemSubnetSetSuperScope(Subnet,SScope);
            Require(ERROR_SUCCESS == Error);
        }

        Error = MemArrayNextLoc(&Subnets, &Loc);
    }
    Error = MemServerAddSScope(Server, SScope);

  Cleanup:
    Report("ServerAddSScope");

    FreeArray(&Subnets);

    return Error;
}

DWORD
DhcpRegpServerAddSubnet(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 SubnetName,
    IN      PM_SERVER              Server
)
{
    DWORD                          Error;
    DWORD                          LocalError;
    REG_HANDLE                     Hdl2;
    LPWSTR                         Name = NULL;
    LPWSTR                         Comment = NULL;
    DWORD                          Address;
    DWORD                          Flags;
    DWORD                          Mask;
    PM_SUBNET                      Subnet = NULL;

    Error = DhcpRegServerGetSubnetHdl(Hdl, SubnetName, &Hdl2);
    if(ERROR_SUCCESS != Error) return Error;

    Error = DhcpRegSubnetGetAttributes(
        &Hdl2,
        &Name,
        &Comment,
        &Flags,
        &Address,
        &Mask
    );
    ERRCHK;

    if( NULL == Name || 0 == Address || 0 == Mask ) {
        INVALID_REG("[DHCPServer] invalid subnet %ws ignored\n", SubnetName);
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    Error = MemSubnetInit(
        &Subnet,
        Address,
        Mask,
        Flags,
        0,
        Name,
        Comment
    );
    ERRCHK;

    Error = DhcpRegServerAddSubnet(&Hdl2, Server, Subnet);

  Cleanup:
    Report("ServerAddSubnet");

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require( ERROR_SUCCESS == LocalError);
    if( Name ) MemFree(Name);
    if( Comment ) MemFree(Comment);

    if( ERROR_SUCCESS != Error ) {
        if( Subnet ) {
            LocalError = MemSubnetCleanup(Subnet);
            Require(ERROR_SUCCESS == LocalError);
        }
    }
    return Error;
}

DWORD
DhcpRegpServerAddMScope(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 MScopeName,
    IN      PM_SERVER              Server
) {
    DWORD                          Error;
    DWORD                          LocalError;
    REG_HANDLE                     Hdl2;
    LPWSTR                         Comment = NULL;
    DWORD                          State;
    DWORD                          ScopeId;
    DWORD                          Policy;
    PM_MSCOPE                      MScope = NULL;
    LPWSTR                         LangTag = NULL;
    DWORD                          TTL = 32;
    PDATE_TIME                     ExpiryTime = NULL;

    GlobalWorkingOnPreWin2kMScope = 0;
    Error = DhcpRegServerGetMScopeHdl(Hdl, MScopeName, &Hdl2);
    if(ERROR_SUCCESS != Error) return Error;

    Error = DhcpRegMScopeGetAttributes(
        &Hdl2,
        &Comment,
        &State,
        &ScopeId,
        &Policy,
        &TTL,
        &LangTag,
        &ExpiryTime
    );
    if( ERROR_INVALID_DATA == Error ) {
        GlobalWorkingOnPreWin2kMScope = TRUE;
        //
        // hackorama isn't it? 
        //
        Error = NO_ERROR;
    }
    ERRCHK;

    if( 0 == ScopeId || GlobalWorkingOnPreWin2kMScope ) {
        INVALID_REG("[DHCPServer] invalid m-scope %ws, id %ld ignored\n", MScopeName, ScopeId);
        Error = ERROR_SUCCESS;
        //goto Cleanup;
    }

    Error = MemMScopeInit(
        &MScope,
        ScopeId,
        State,
        Policy,
        (BYTE)TTL,
        MScopeName,
        Comment,
        LangTag,
        *ExpiryTime
    );
    ERRCHK;

    Error = DhcpRegServerAddMScope(&Hdl2, Server, MScope);

  Cleanup:

    GlobalWorkingOnPreWin2kMScope = 0;
    Report("Server Add MScope");

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == LocalError);
    if( Comment ) MemFree(Comment);
    if( LangTag ) MemFree(LangTag);
    if( ExpiryTime ) MemFree(ExpiryTime);

    if( ERROR_SUCCESS != Error ) {
        if( MScope ) {
            LocalError = MemMScopeCleanup(MScope);
            Require(ERROR_SUCCESS == Error);
        }
    }
    return Error;
}

DWORD
DhcpRegpServerAddSScope(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 SScopeName,
    IN      PM_SERVER              Server
) {
    DWORD                          Error;
    DWORD                          LocalError;
    REG_HANDLE                     Hdl2;
    LPWSTR                         Name = NULL;
    LPWSTR                         Comment = NULL;
    DWORD                          Flags;
    PM_SSCOPE                      SScope = NULL;

    Error = DhcpRegServerGetSScopeHdl(Hdl, SScopeName, &Hdl2);
    if(ERROR_SUCCESS != Error) return Error;

#if 0                                             // superscope name is given above -- nothing else to be done
    Error = DhcpRegSScopeGetAttributes(
        &Hdl2,
        &Name,
        &Description,
        &Flags
    );
    ERRCHK;
#endif

    Error = MemSScopeInit(
        &SScope,
        0,
        SScopeName
    );
    ERRCHK;

    Error = DhcpRegServerAddSScope(&Hdl2, Server, SScope);

  Cleanup:
    Report("Server Add Scope");

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == LocalError);

    if( ERROR_SUCCESS != Error ) {
        if( SScope ) {
            LocalError = MemSScopeCleanup(SScope);
            Require(ERROR_SUCCESS == Error);
        }
    }
    return Error;
}

DWORD
DhcpRegpServerAddOption(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 OptionName,
    IN      PM_SERVER              Server
) {
    DWORD                          Error;
    DWORD                          LocalError;
    REG_HANDLE                     Hdl2;
    DWORD                          OptionId;
    LPWSTR                         ClassName = NULL;
    LPWSTR                         VendorName = NULL;
    DWORD                          Flags;
    LPBYTE                         Value = NULL;
    DWORD                          ValueSize;
    DWORD                          ClassId;
    DWORD                          VendorId;
    PM_OPTION                      Option = NULL;
    PM_OPTION                      DeletedOption = NULL;
    PM_CLASSDEF                    ThisClasDef;

    Error = DhcpRegServerGetOptHdl(Hdl, OptionName, &Hdl2);
    if(ERROR_SUCCESS != Error) return Error;

    Error = DhcpRegOptGetAttributes(
        &Hdl2,
        &OptionId,
        &ClassName,
        &VendorName,
        &Flags,
        &Value,
        &ValueSize
    );
    ERRCHK;

    if( OptionId == 0 )  // old registry format does not contain "OptionId" value => it can be taken from the key name.
        OptionId = _wtol(OptionName);

    if( 0 == OptionId || NULL == Value || 0 == ValueSize ) {
        INVALID_REG("[DHCPServer] found invalid option %ws (ignored)\n", OptionName );
        Error =  ERROR_SUCCESS;
        goto Cleanup;
    }

    if( NULL == ClassName || wcslen(ClassName) == 0) ClassId = 0;
    else {
        Error = MemServerGetClassDef(Server,0, ClassName,0,NULL,&ThisClasDef);
        if( ERROR_SUCCESS != Error ) {
            if (*(DWORD *)ClassName != OptionId)    // some registry entries were corrupted due to an old bug. Load these entries too (see bug #192933)
            {
                INVALID_REG("ServerAddOption(%ws): unknown class (ignored)\n", OptionName);
                Error = ERROR_SUCCESS;
                goto Cleanup;
            }
            else
            {
                ClassId = 0;
            }
        } else {
            ClassId = ThisClasDef->ClassId;
            Require(ThisClasDef->IsVendor == FALSE);
        }
    }
    if( NULL == VendorName || wcslen(VendorName) == 0) VendorId = 0;
    else {
        Error = MemServerGetClassDef(Server,0, VendorName,0,NULL,&ThisClasDef);
        if( ERROR_SUCCESS != Error ) {
            INVALID_REG("ServerAddOption(%ws): unknown class (ignored)\n", OptionName);
            Error = ERROR_SUCCESS;
            goto Cleanup;
        } else {
            VendorId = ThisClasDef->ClassId;
            Require(ThisClasDef->IsVendor == TRUE);
        }
    }

    Error = MemOptInit(&Option, OptionId, ValueSize, Value);
    ERRCHK;

    Error = MemOptClassAddOption(&(Server->Options), Option, ClassId, VendorId, &DeletedOption);
    ERRCHK;

  Cleanup:
    Report("Server Add Option");

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == LocalError);
    if( ClassName ) MemFree(ClassName);
    if( VendorName ) MemFree(VendorName);
    if( Value ) MemFree(Value);
    if( DeletedOption ) {
        LocalError = MemOptCleanup(DeletedOption);
        Require(ERROR_SUCCESS == LocalError);
    }
    if( ERROR_SUCCESS != Error && Option ) {
        LocalError = MemOptCleanup(Option);
        Require(ERROR_SUCCESS == LocalError);
    }
    return Error;
}

DWORD
DhcpRegpServerAddDefList(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 DefName,
    IN      PM_SERVER              Server
) {
    DWORD                          Error;
    DWORD                          LocalError;
    REG_HANDLE                     Hdl2;
    LPWSTR                         Name = NULL;
    LPWSTR                         Comments = NULL;
    DWORD                          Flags;
    DWORD                          OptionId;
    LPWSTR                         ClassName = NULL;
    LPWSTR                         VendorName = NULL;
    DWORD                          ClassId;
    DWORD                          VendorId;
    LPBYTE                         Value = NULL;
    DWORD                          ValueSize;
    PM_CLASSDEF                    ThisClassDef;

    Error = DhcpRegServerGetOptDefHdl(Hdl, DefName, &Hdl2);
    if(ERROR_SUCCESS != Error) return Error;

    Error = DhcpRegOptDefGetAttributes(
        &Hdl2,
        &Name,
        &Comments,
        &Flags,
        &OptionId,
        &ClassName,
        &VendorName,
        &Value,
        &ValueSize
    );
    ERRCHK;

    if( OptionId == 0)
        OptionId = _wtol(DefName);

    if( NULL == Name || 0 == OptionId ) {
        INVALID_REG("[DHCPServer] invalid option def %ws ignored\n", DefName );
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    if( NULL == ClassName || wcslen(ClassName) == 0) ClassId = 0;
    else {
        Error = MemServerGetClassDef(Server,0, ClassName,0,NULL,&ThisClassDef);
        if( ERROR_SUCCESS != Error ) ClassId = 0;
        else {
            ClassId = ThisClassDef->ClassId;
            Require(ThisClassDef->IsVendor == FALSE);
        }
    }
    if( NULL == VendorName || wcslen(VendorName) == 0 ) VendorId = 0;
    else {
        Error = MemServerGetClassDef(Server,0, VendorName,0,NULL,&ThisClassDef);
        if( ERROR_SUCCESS != Error ) VendorId = 0;
        else {
            VendorId = ThisClassDef->ClassId;
            Require(ThisClassDef->IsVendor == TRUE);
        }
    }

    Error = MemOptClassDefListAddOptDef(
        &(Server->OptDefs),
        ClassId,
        VendorId,
        OptionId,
        Flags,
        Name,
        Comments,
        Value,
        ValueSize
    );

  Cleanup:
    Report("Server Add DefList");

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == LocalError);
    if( Name ) MemFree(Name);
    if( Comments ) MemFree(Comments);
    if( ClassName ) MemFree(ClassName);
    if( VendorName ) MemFree(VendorName);
    if( Value ) MemFree(Value);

    return Error;
}

DWORD
DhcpRegpServerAddClassDef(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 ClassDefName,
    IN      PM_SERVER              Server
) {
    DWORD                          Error;
    DWORD                          LocalError;
    REG_HANDLE                     Hdl2;
    LPWSTR                         Name = NULL;
    LPWSTR                         Comment = NULL;
    DWORD                          Flags;
    LPBYTE                         Value = NULL;
    DWORD                          ValueSize;

    Error = DhcpRegServerGetClassDefHdl(Hdl, ClassDefName, &Hdl2);
    if(ERROR_SUCCESS != Error) return Error;

    Error = DhcpRegClassDefGetAttributes(
        &Hdl2,
        &Name,
        &Comment,
        &Flags,
        &Value,
        &ValueSize
    );
    ERRCHK;

    if( NULL == Name || 0 == ValueSize || NULL == Value ) {
        INVALID_REG("[DHCPServer] invalid class def %ws ignored\n", ClassDefName);
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    Error = MemClassDefListAddClassDef(
        &(Server->ClassDefs),
        MemNewClassId(),
        Flags,
        0, /* no Type... */
        Name,
        Comment,
        Value,
        ValueSize
    );
    ERRCHK;

  Cleanup:
    Report("Server Add ClassDef");

    LocalError = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == LocalError);
    if( Name ) MemFree(Name);
    if( Comment ) MemFree(Comment);
    if( Value ) MemFree(Value);
    return Error;
}

//BeginExport(function)
DWORD
DhcpRegReadSubServer(                             // read all the sub objects of a server and add 'em
    IN      PREG_HANDLE            Hdl,
    IN OUT  PM_SERVER              Server
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Index;
    ARRAY                          OptList;
    ARRAY                          DefList;
    ARRAY                          ClassDefs;
    ARRAY                          Subnets;
    ARRAY                          MScopes;
    ARRAY                          SScopes;
    struct {
        PARRAY                     Array;
        ARRAY_FN                   Fn;
    } Lists[] = {
        &ClassDefs,                DhcpRegpServerAddClassDef,
        &DefList,                  DhcpRegpServerAddDefList,
        &OptList,                  DhcpRegpServerAddOption,
        &Subnets,                  DhcpRegpServerAddSubnet,
        &MScopes,                  DhcpRegpServerAddMScope,
        &SScopes,                  DhcpRegpServerAddSScope
    };

    for( Index = 0; Index < sizeof(Lists)/sizeof(Lists[0]); Index ++ ) {
        InitArray(Lists[Index].Array);
    }

    Error = DhcpRegServerGetList(
        Hdl, &OptList, &DefList, &Subnets, &SScopes, &ClassDefs, &MScopes
    );
    ERRCHK;

    for( Index = 0; Index < sizeof(Lists)/sizeof(Lists[0]); Index ++ ) {
        Error = LoopThruArray(Lists[Index].Array, Lists[Index].Fn, Hdl, Server);
        ERRCHK;
    }

  Cleanup:

    for( Index = 0; Index < sizeof(Lists)/sizeof(Lists[0]); Index ++ ) {
        FreeArray(Lists[Index].Array);
    }

    Report("ServerAddSubServer");

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegReadServer(                                // read the server and all its sub objects
    IN      PREG_HANDLE            Hdl,
    OUT     PM_SERVER             *Server         // return the created object
) //EndExport(function)
{
    DWORD                          Error;
    LPWSTR                         Name;
    LPWSTR                         Comments;
    DWORD                          Flags;
    PM_SERVER                      ThisServer;

    Name = NULL; Comments = NULL; Flags = 0; ThisServer = NULL;

    Error = DhcpRegServerGetAttributes(
        Hdl,
        &Name,
        &Comments,
        &Flags
    );
    if( ERROR_SUCCESS != Error ) goto Cleanup;

    Error = MemServerInit(
        &ThisServer,
        0xFFFFFFFF,
        Flags,
        0,
        Name,
        Comments
    );
    if( ERROR_SUCCESS != Error ) goto Cleanup;

    Error = DhcpRegReadSubServer(Hdl, ThisServer);
    if( ERROR_SUCCESS != Error ) goto Cleanup;

    *Server = ThisServer;

  Cleanup:
    if( NULL != Name ) MemFree(Name);
    if( NULL != Comments) MemFree(Comments);
    if( ERROR_SUCCESS != Error && NULL != ThisServer) {
        MemServerCleanup(ThisServer);
    }

    return Error;
}
//BeginExport(function)
DWORD
DhcpRegReadThisServer(                            // recursively read for the current server
    OUT     PM_SERVER             *Server
) //EndExport(function)
{
    DWORD                          Error;
    REG_HANDLE                     ThisServer;
    LPWSTR                         Name;
    LPWSTR                         Comment;


    Error = DhcpRegGetThisServer(&ThisServer);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegReadServer(&ThisServer, Server);
    DhcpRegCloseHdl(&ThisServer);

    return Error;
}

DWORD
DhcpRegReadScopeBitmasks(
    IN OUT PM_SUBNET Scope
    )
{
    PM_RANGE Range;
    ARRAY_LOCATION Loc;
    DWORD Error;
    WCHAR SubnetStr[sizeof("000.000.000.000")];
    REG_HANDLE Hdl, Hdl1;

#if 0
    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;

    if( Scope->fSubnet ) {
        Error = DhcpRegServerGetSubnetHdl(
            &Hdl, ConvertAddressToLPWSTR(
                Scope->Address, SubnetStr), &Hdl1);
    } else {
        Error = DhcpRegServerGetMScopeHdl(
            &Hdl, Scope->Name, &Hdl1 );
    }

    DhcpRegCloseHdl( &Hdl );
    if( NO_ERROR != Error ) return Error;
#endif
    
    Error = MemArrayInitLoc( &Scope->Ranges, &Loc);
    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement( &Scope->Ranges, &Loc, &Range );
        Require( NO_ERROR == Error && NULL != Range );

        //
        // Fill in the range
        //

#if 0
        Error = DhcpRegSubnetGetRangeHdl(
            &Hdl1, ConvertAddressToLPWSTR(
                Range->Start, SubnetStr ), &Hdl );
        if( NO_ERROR != Error ) break;
        Error = DhcpRegpFillBitmasks(
            Hdl.Key, Range, Scope );

        DhcpRegCloseHdl( &Hdl );
        if( NO_ERROR != Error ) break;
#else

        Error = DhcpRegpFillBitmasks(
            NULL, Range, Scope );
        ASSERT( NO_ERROR == Error );
#endif
        
        Error = MemArrayNextLoc( &Scope->Ranges, &Loc );
    }

#if 0
    DhcpRegCloseHdl( &Hdl1 );
#endif
    
    if( ERROR_FILE_NOT_FOUND != Error ) return Error;
    return NO_ERROR;
}

//BeginExport(function)
DWORD
DhcpRegReadServerBitmasks(
    IN OUT PM_SERVER Server
) // EndExport(function)
{
    PM_SUBNET Scope, MScope;
    ARRAY_LOCATION Loc;
    DWORD Error;
    
    Error = MemArrayInitLoc(&Server->Subnets, &Loc);
    while( NO_ERROR == Error ) {
        Error = MemArrayGetElement( &Server->Subnets, &Loc, &Scope);
        Require( NO_ERROR == Error && NULL != Scope );

        //
        // get the keys to the scope in question
        //

        Error = DhcpRegReadScopeBitmasks(Scope);
        if( NO_ERROR != Error ) return Error;
        
        Error = MemArrayNextLoc( &Server->Subnets, &Loc );
    }

    if( ERROR_FILE_NOT_FOUND != Error ) return Error;

    Error = MemArrayInitLoc(&Server->MScopes, &Loc);
    while( NO_ERROR == Error ) {
        Require( ERROR_SUCCESS == Error );

        Error = MemArrayGetElement( &Server->MScopes, &Loc, &MScope);
        Require( NO_ERROR == Error && NULL != MScope );

        //
        // get the keys to the scope in question
        //

        Error = DhcpRegReadScopeBitmasks(MScope);
        if( NO_ERROR != Error ) return Error;

        Error = MemArrayNextLoc( &Server->MScopes, &Loc );
    }

    if( ERROR_FILE_NOT_FOUND != Error ) return Error;
    return NO_ERROR;
}


//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mmreg\regsave.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: This implements the save functionality.. whenever something needs
// to be saved onto the registry, this is the place...
// it is expected that this would be used only during API re-configuration or
// during routine "address-allocation" where the bitmask needs to be flushed to disk
//================================================================================

#include    <mmregpch.h>
#include    <regutil.h>

#define     InitArray(X)           do{DWORD Error = MemArrayInit((X)); Require(ERROR_SUCCESS == Error); }while(0)
#define     ERRCHK                 do{if( ERROR_SUCCESS != Error ) goto Cleanup; }while(0)
#define     FreeArray1(X)          Error = LoopThruArray((X), DestroyString, NULL, NULL);Require(ERROR_SUCCESS == Error);
#define     FreeArray2(X)          Error = MemArrayCleanup((X)); Require(ERROR_SUCCESS == Error);
#define     FreeArray(X)           do{ DWORD Error; FreeArray1(X); FreeArray2(X); }while(0)
#define     Report(Who)            if(Error) DbgPrint("[DHCPServer] %s: %ld [0x%lx]\n", Who, Error, Error)


typedef     DWORD                  (*ARRAY_FN)(PREG_HANDLE, LPWSTR ArrayString, LPVOID MemObject);

DWORD
LoopThruArray(
    IN      PARRAY                 Array,
    IN      ARRAY_FN               ArrayFn,
    IN      PREG_HANDLE            Hdl,
    IN      LPVOID                 MemObject
);

DWORD
DestroyString(
    IN      PREG_HANDLE            RegHdl,
    IN      LPWSTR                 Str,
    IN      LPVOID                 Something
);

//BeginExport(function)
DWORD
DhcpRegSaveOptDef(
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      DWORD                  OptType,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptLen
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    LPWSTR                         OptDefStr;

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    OptDefStr = DhcpRegCombineClassAndOption(ClassName, VendorName, OptId);
    if( NULL == OptDefStr ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        Error = DhcpRegServerGetOptDefHdl(&Hdl, OptDefStr, &Hdl2);
        MemFree(OptDefStr);
    }
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegOptDefSetAttributes(
        &Hdl2,
        &Name,
        &Comment,
        &OptType,
        &OptId,
        &ClassName,
        &VendorName,
        &OptVal,
        OptLen
    );

    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteOptDef(
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    LPWSTR                         OptDefStr;

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    OptDefStr = DhcpRegCombineClassAndOption(ClassName, VendorName, OptId);
    if( NULL == OptDefStr ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        Error = DhcpRegServerGetOptDefHdl(&Hdl, L"", &Hdl2);
        if( ERROR_SUCCESS == Error ) {
            Error = DhcpRegRecurseDelete(&Hdl2, OptDefStr);
            Error2 = DhcpRegCloseHdl(&Hdl2);
            Require(ERROR_SUCCESS == Error2);
        }
        MemFree(OptDefStr);
    }
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);
    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSaveGlobalOption(
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPBYTE                 Value,
    IN      DWORD                  ValueSize
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    LPWSTR                         OptDefStr;

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    OptDefStr = DhcpRegCombineClassAndOption(ClassName, VendorName, OptId);
    if( NULL == OptDefStr ) {
        DhcpRegCloseHdl(&Hdl);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpRegServerGetOptHdl(&Hdl, OptDefStr, &Hdl2);
    MemFree(OptDefStr);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegOptSetAttributes(
            &Hdl2,
            &OptId,
            &ClassName,
            &VendorName,
            NULL,
            &Value,
            ValueSize
        );
        Error2 = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == Error2);
    }

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteGlobalOption(
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    LPWSTR                         OptDefStr;

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    OptDefStr = DhcpRegCombineClassAndOption(ClassName, VendorName, OptId);
    if( NULL == OptDefStr ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        Error = DhcpRegServerGetOptHdl(&Hdl, L"", &Hdl2);
        if( ERROR_SUCCESS == Error ) {
            Error = DhcpRegRecurseDelete(&Hdl2, OptDefStr);
            Error2 = DhcpRegCloseHdl(&Hdl2);
            Require(ERROR_SUCCESS == Error2);
        }
        MemFree(OptDefStr);
    }
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);
    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSaveSubnetOption(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPBYTE                 Value,
    IN      DWORD                  ValueSize
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2, Hdl3;
    LPWSTR                         OptDefStr;
    WCHAR                          SubnetStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    OptDefStr = DhcpRegCombineClassAndOption(ClassName, VendorName, OptId);
    if( NULL == OptDefStr ) {
        DhcpRegCloseHdl(&Hdl);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = Subnet->fSubnet
            ? DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Subnet->Address, SubnetStr), &Hdl2)
            : DhcpRegServerGetMScopeHdl(&Hdl, Subnet->Name, &Hdl2);

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegSubnetGetOptHdl(&Hdl2, OptDefStr, &Hdl3);
        Error2 = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == Error2);
    }
    MemFree(OptDefStr);

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegOptSetAttributes(
            &Hdl3,
            &OptId,
            &ClassName,
            &VendorName,
            NULL,
            &Value,
            ValueSize
        );
        Error2 = DhcpRegCloseHdl(&Hdl3);
        Require(ERROR_SUCCESS == Error2);
    }

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteSubnetOption(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2, Hdl3;
    LPWSTR                         OptDefStr;
    WCHAR                          SubnetStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    OptDefStr = DhcpRegCombineClassAndOption(ClassName, VendorName, OptId);
    if( NULL == OptDefStr ) {
        DhcpRegCloseHdl(&Hdl);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = Subnet->fSubnet
            ? DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Subnet->Address, SubnetStr), &Hdl2)
            : DhcpRegServerGetMScopeHdl(&Hdl, Subnet->Name, &Hdl2);

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegSubnetGetOptHdl(&Hdl2, L"", &Hdl3);
        Error2 = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == Error2);
    }

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegRecurseDelete(&Hdl3, OptDefStr);
        Error2 = DhcpRegCloseHdl(&Hdl3);
        Require(ERROR_SUCCESS == Error2);
    }
    MemFree(OptDefStr);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSaveReservedOption(
    IN      DWORD                  Address,
    IN      DWORD                  ReservedAddress,
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPBYTE                 Value,
    IN      DWORD                  ValueSize
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2, Hdl3;
    LPWSTR                         OptDefStr;
    WCHAR                          SubnetStr[sizeof("000.000.000.000")];
    WCHAR                          ReservedStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    OptDefStr = DhcpRegCombineClassAndOption(ClassName, VendorName, OptId);
    if( NULL == OptDefStr ) {
        DhcpRegCloseHdl(&Hdl);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Address, SubnetStr), &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegSubnetGetReservationHdl(&Hdl2, ConvertAddressToLPWSTR(ReservedAddress, ReservedStr), &Hdl3);
        Error2 = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == Error2);
    }

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegReservationGetOptHdl(&Hdl3, OptDefStr, &Hdl2);
        Error2 = DhcpRegCloseHdl(&Hdl3);
        Require(ERROR_SUCCESS == Error2);
    }

    MemFree(OptDefStr);
    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegOptSetAttributes(
            &Hdl2,
            &OptId,
            &ClassName,
            &VendorName,
            NULL,
            &Value,
            ValueSize
        );
        Error2 = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == Error2);
    }

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteReservedOption(
    IN      DWORD                  Address,
    IN      DWORD                  ReservedAddress,
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2, Hdl3;
    LPWSTR                         OptDefStr;
    WCHAR                          SubnetStr[sizeof("000.000.000.000")];
    WCHAR                          ReservedStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    OptDefStr = DhcpRegCombineClassAndOption(ClassName, VendorName, OptId);
    if( NULL == OptDefStr ) {
        DhcpRegCloseHdl(&Hdl);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Address, SubnetStr), &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegSubnetGetReservationHdl(&Hdl2, ConvertAddressToLPWSTR(ReservedAddress, ReservedStr), &Hdl3);
        Error2 = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == Error2);
    }

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegReservationGetOptHdl(&Hdl3, L"", &Hdl2);
        Error2 = DhcpRegCloseHdl(&Hdl3);
        Require(ERROR_SUCCESS == Error2);
    }

    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegRecurseDelete(&Hdl2, OptDefStr);
        Error2 = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == Error2);
    }
    MemFree(OptDefStr);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSaveClassDef(
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      DWORD                  Flags,
    IN      LPBYTE                 Data,
    IN      DWORD                  DataLength
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;

    if( NULL == Name ) return ERROR_INVALID_PARAMETER;

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpRegServerGetClassDefHdl(&Hdl, Name, &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    Error = DhcpRegClassDefSetAttributes(
        &Hdl2,
        &Name,
        &Comment,
        &Flags,
        &Data,
        DataLength
    );
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteClassDef(
    IN      LPWSTR                 Name
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;

    if( NULL == Name ) return ERROR_INVALID_PARAMETER;

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpRegServerGetClassDefHdl(&Hdl, L"", &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    Error = DhcpRegRecurseDelete(&Hdl2, Name);
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSaveReservation(
    IN      DWORD                  Subnet,
    IN      DWORD                  Address,
    IN      DWORD                  Flags,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDLength
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2, Hdl3;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Subnet, AddressStr), &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error) return Error;

    Error = DhcpRegSubnetGetReservationHdl(&Hdl2, ConvertAddressToLPWSTR(Address, AddressStr), &Hdl3);
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegReservationSetAttributes(
        &Hdl3,
        NULL,
        NULL,
        &Flags,
        &Address,
        &ClientUID,
        ClientUIDLength
    );
    Error2 = DhcpRegCloseHdl(&Hdl3);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteReservation(
    IN      DWORD                  Subnet,
    IN      DWORD                  Address
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2, Hdl3;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Subnet, AddressStr), &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error) return Error;

    Error = DhcpRegSubnetGetReservationHdl(&Hdl2, L"", &Hdl3);
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegRecurseDelete(&Hdl3, ConvertAddressToLPWSTR(Address, AddressStr));
    Error2 = DhcpRegCloseHdl(&Hdl3);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSScopeDeleteSubnet(
    IN      LPWSTR                 SScopeName,
    IN      DWORD                  SubnetAddress
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpRegServerGetSScopeHdl(&Hdl, SScopeName, &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegRecurseDelete(&Hdl2, ConvertAddressToLPWSTR(SubnetAddress, AddressStr));
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

DWORD
DhcpRegpDelSubnetFromSScope(
    IN      PREG_HANDLE            Unused,
    IN      LPWSTR                 SScopeName,
    IN      LPVOID                 Address
)
{
    DWORD                          Error;

    Error =  DhcpRegSScopeDeleteSubnet(SScopeName, PtrToUlong(Address));
    return ERROR_SUCCESS;                         // ignore if this subnet is not found in this sscope
}

//BeginExport(function)
DWORD
DhcpRegDelSubnetFromAllSScopes(
    IN      DWORD                  Address
) //EndExport(function)
{
    DWORD                          Error, Error2;
    ARRAY                          Array;
    REG_HANDLE                     Hdl, Hdl2;

    Error = MemArrayInit(&Array);
    Require(ERROR_SUCCESS == Error);

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpRegServerGetList(&Hdl, NULL, NULL, NULL, &Array, NULL, NULL);
    if( ERROR_SUCCESS == Error ) {
        Error = LoopThruArray(
            &Array, DhcpRegpDelSubnetFromSScope, &Hdl,
            ULongToPtr(Address));
    }

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    FreeArray(&Array);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSScopeSaveSubnet(
    IN      LPWSTR                 SScopeName,
    IN      DWORD                  Address
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpRegServerGetSScopeHdl(&Hdl, SScopeName, &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegGetNextHdl(&Hdl2, ConvertAddressToLPWSTR(Address, AddressStr), &Hdl);
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteSScope(
    IN      LPWSTR                 SScopeName
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpRegServerGetSScopeHdl(&Hdl, L"", &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegRecurseDelete(&Hdl2, SScopeName );
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSaveSubnet(
    IN      DWORD                  SubnetAddress,
    IN      DWORD                  SubnetMask,
    IN      DWORD                  SubnetState,
    IN      LPWSTR                 SubnetName,
    IN      LPWSTR                 SubnetComment
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;

    Error = DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(SubnetAddress, AddressStr), &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegSubnetSetAttributes(
        &Hdl2,
        &SubnetName,
        &SubnetComment,
        &SubnetState,
        &SubnetAddress,
        &SubnetMask
    );
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteSubnet(
    IN      PM_SUBNET               Subnet
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];
    LPWSTR                         KeyName;

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;

    Error = Subnet->fSubnet ? DhcpRegServerGetSubnetHdl(&Hdl, L"" , &Hdl2)
                            : DhcpRegServerGetMScopeHdl(&Hdl, L"" , &Hdl2);

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    KeyName = Subnet->fSubnet ? ConvertAddressToLPWSTR(Subnet->Address, AddressStr) : Subnet->Name;
    Error = DhcpRegRecurseDelete(&Hdl2, KeyName);
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegAddRange(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress,
    IN      DWORD                  RangeEndAddress,
    IN      ULONG                  BootpAllocated,
    IN      ULONG                  MaxBootpAllowed,
    IN      DWORD                  Type
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];
    LPWSTR                         KeyName;

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpRegRangeSetAttributes(
        &Hdl,
        NULL,
        NULL,
        &Type,
        &BootpAllocated,
        &MaxBootpAllowed,
        &RangeStartAddress,
        &RangeEndAddress,
        NULL,
        0,
        NULL,
        0
    );

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require( ERROR_SUCCESS == Error2 );

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegAddRangeEx(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress,
    IN      DWORD                  RangeEndAddress,
    IN      DWORD                  Type,
    IN      ULONG                  BootpAllocated,
    IN      ULONG                  MaxBootpAllowed,
    IN      LPBYTE                 InUseClusters,
    IN      DWORD                  InUseClustersSize,
    IN      LPBYTE                 UsedClusters,
    IN      DWORD                  UsedClustersSize
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = Subnet->fSubnet
            ? DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Subnet->Address, AddressStr), &Hdl2)
            : DhcpRegServerGetMScopeHdl(&Hdl, Subnet->Name, &Hdl2);

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegSubnetGetRangeHdl(&Hdl2, ConvertAddressToLPWSTR(RangeStartAddress, AddressStr), &Hdl);
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegRangeSetAttributes(
        &Hdl,
        NULL,
        NULL,
        &Type,
        &BootpAllocated,
        &MaxBootpAllowed,
        &RangeStartAddress,
        &RangeEndAddress,
        &InUseClusters,
        InUseClustersSize,
        &UsedClusters,
        UsedClustersSize
    );

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteRange(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = Subnet->fSubnet
            ? DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Subnet->Address, AddressStr), &Hdl2)
            : DhcpRegServerGetMScopeHdl(&Hdl, Subnet->Name, &Hdl2);

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegSubnetGetRangeHdl(&Hdl2, L"", &Hdl);
    Error2  = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegRecurseDelete(&Hdl, ConvertAddressToLPWSTR(RangeStartAddress, AddressStr));
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegDeleteRangeEx(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress,
    OUT     LPBYTE                *InUseClusters,
    OUT     DWORD                 *InUseClustersSize,
    OUT     LPBYTE                *UsedClusters,
    OUT     DWORD                 *UsedClustersSize
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = Subnet->fSubnet
            ? DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Subnet->Address, AddressStr), &Hdl2)
            : DhcpRegServerGetMScopeHdl(&Hdl, Subnet->Name, &Hdl2);

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegSubnetGetRangeHdl(&Hdl2, ConvertAddressToLPWSTR(RangeStartAddress, AddressStr), &Hdl);
    Error2  = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegRangeGetAttributes(
        &Hdl,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        InUseClusters,
        InUseClustersSize,
        UsedClusters,
        UsedClustersSize
    );
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;
    return DhcpRegDeleteRange(Subnet, RangeStartAddress);
}

//BeginExport(function)
DWORD
DhcpRegSaveExcl(
    IN      PM_SUBNET              Subnet,
    IN      LPBYTE                 ExclBytes,
    IN      DWORD                  nBytes
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = Subnet->fSubnet
            ? DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Subnet->Address, AddressStr), &Hdl2)
            : DhcpRegServerGetMScopeHdl(&Hdl, Subnet->Name, &Hdl2);

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegSubnetSetExclusions(
        &Hdl2,
        &ExclBytes,
        nBytes
    );
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSaveBitMask(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress,
    IN      LPBYTE                 InUse,
    IN      DWORD                  InUseSize,
    IN      LPBYTE                 Used,
    IN      DWORD                  UsedSize
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;
    
    Error = Subnet->fSubnet
            ? DhcpRegServerGetSubnetHdl(&Hdl, ConvertAddressToLPWSTR(Subnet->Address, AddressStr), &Hdl2)
            : DhcpRegServerGetMScopeHdl(&Hdl, Subnet->Name, &Hdl2);

    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegSubnetGetRangeHdl(&Hdl2, ConvertAddressToLPWSTR(RangeStartAddress, AddressStr), &Hdl);
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegRangeSetAttributes(
        &Hdl,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        &InUse,
        InUseSize,
        &Used,
        UsedSize
    );
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSaveMScope(
    IN      DWORD                  MScopeId,
    IN      DWORD                  SubnetState,
    IN      DWORD                  AddressPolicy,
    IN      DWORD                  TTL,
    IN      LPWSTR                 pMScopeName,
    IN      LPWSTR                 pMScopeComment,
    IN      LPWSTR                 LangTag,
    IN      PDATE_TIME              ExpiryTime
) //EndExport(function)
{
    DWORD                          Error, Error2;
    REG_HANDLE                     Hdl, Hdl2;
    WCHAR                          AddressStr[sizeof("000.000.000.000")];

    Require( pMScopeName );

    Error = DhcpRegGetThisServer(&Hdl);
    if( NO_ERROR != Error ) return Error;

    Error = DhcpRegServerGetMScopeHdl(&Hdl, pMScopeName, &Hdl2);
    Error2 = DhcpRegCloseHdl(&Hdl);
    Require(ERROR_SUCCESS == Error2);

    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegMScopeSetAttributes(
        &Hdl2,
        &pMScopeComment,
        &SubnetState,
        &MScopeId,
        &AddressPolicy,
        &TTL,
        &LangTag,
        &ExpiryTime
    );
    Error2 = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error2);

    return Error;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mmreg\regread.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

DWORD
DhcpRegReadSubServer(                             // read all the sub objects of a server and add 'em
    IN      PREG_HANDLE            Hdl,
    IN OUT  PM_SERVER              Server
) ;


DWORD
DhcpRegReadServer(                                // read the server and all its sub objects
    IN      PREG_HANDLE            Hdl,
    OUT     PM_SERVER             *Server         // return the created object
) ;


DWORD
DhcpRegReadThisServer(                            // recursively read for the current server
    OUT     PM_SERVER             *Server
) ;

DWORD
DhcpRegReadServerBitmasks(
    IN OUT PM_SERVER Server
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mmreg\regds.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================
//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mmreg\regflush.c ===
//================================================================================
//  Copyright (c) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: this file deals with the part that keeps the registry bitmask in
//  sync.  the way, this is done is by keeping a count in each RANGE object to
//  count the # of operations that have been performed on it.. if it crosses
//  a threshold, it is saved to registry..
//================================================================================

//#include    <dhcpsrv.h>
#include    <mmregpch.h>
#include    <regutil.h>
#include    <regsave.h>

extern CRITICAL_SECTION DhcpGlobalInProgressCritSect;
extern CRITICAL_SECTION DhcpGlobalMemoryCritSect;

#define LOCK_MEMORY()            EnterCriticalSection(&DhcpGlobalMemoryCritSect)
#define UNLOCK_MEMORY()          LeaveCriticalSection(&DhcpGlobalMemoryCritSect)
#define LOCK_INPROGRESS_LIST()   EnterCriticalSection(&DhcpGlobalInProgressCritSect)
#define UNLOCK_INPROGRESS_LIST() LeaveCriticalSection(&DhcpGlobalInProgressCritSect)

#define     DIRT_THRESHOLD         10             // flush every 10 addresses

//BeginExport(defines)
#define     FLUSH_MODIFIED_DIRTY   0
#define     FLUSH_MODIFIED         1
#define     FLUSH_ANYWAY           2
//EndExport(defines)

DWORD
FlushCheckLoop(
    IN      PARRAY                 ArrayToLoopThru,
    IN      DWORD                  (*Iterator)(LPVOID Element, DWORD FlushNow, LPVOID Context),
    IN      DWORD                  FlushNow,
    IN      LPVOID                 Context
)
{
    DWORD                          LastFailure;
    DWORD                          Error;
    ARRAY_LOCATION                 Loc;
    LPVOID                         Element;

    LastFailure = ERROR_SUCCESS;
    Error = MemArrayInitLoc(ArrayToLoopThru, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(ArrayToLoopThru, &Loc, &Element);
        Require(ERROR_SUCCESS == Error && NULL != Element);

        Error = Iterator(Element, FlushNow, Context);
        Require(ERROR_SUCCESS == Error);
        if( ERROR_SUCCESS != Error ) LastFailure = Error;

        Error = MemArrayNextLoc(ArrayToLoopThru, &Loc);
    }

    return LastFailure;
}

BOOL _inline
SpecialValues(
    IN      LPWSTR                 ValueName
)
{
    return (0 == wcscmp(ValueName, REG_RANGE_START_ADDRESS) ||
            0 == wcscmp(ValueName, REG_RANGE_END_ADDRESS) ||
            0 == wcscmp(ValueName, REG_FLAGS) ||
            0 == wcscmp(ValueName, REG_SUBNET_EXCL) ||
            0 == wcscmp(ValueName, REG_SUBNET_SWITCHED_FLAG) ||
            0 == wcscmp(ValueName, REG_MSCOPE_NAME) ||
            0 == wcscmp(ValueName, REG_MSCOPE_COMMENT) ||
            0 == wcscmp(ValueName, REG_MSCOPE_SCOPEID) ||
            0 == wcscmp(ValueName, REG_MSCOPE_STATE) ||
            0 == wcscmp(ValueName, REG_MSCOPE_ADDR_POLICY) ||
            0 == wcscmp(ValueName, REG_MSCOPE_TTL) ||
            0 == wcscmp(ValueName, REG_MSCOPE_LANG_TAG) ||
            0 == wcscmp(ValueName, REG_MSCOPE_EXPIRY_TIME)
        );
}

typedef struct _FLSH_BITS_CTXT {
    REG_HANDLE                    *Hdl;
    PM_SUBNET                      Subnet;
    PM_RANGE                       Range;
    LONG                           Index;
}   FLSH_BITS_CTXT, *LPFLSH_BITS_CTXT;

static
BYTE TempBuffer[MAX_BIT1SIZE + sizeof(DWORD)*4];

DWORD
FlushBitmask(
    IN      PM_BITMASK1            Bits1,
    IN      DWORD                  FlushNow,
    IN      LPVOID                 FlushCtxt
)
{
    LPFLSH_BITS_CTXT               Ctxt = FlushCtxt;
    HKEY                           Key = Ctxt->Hdl->Key;
    WCHAR                          BitsValueName[REG_RANGE_BITS_PREFIX_WCHAR_COUNT+57];
    LONG                           Count, Index = (Ctxt->Index++);
    ULONG                          WriteSize = 4*sizeof(DWORD), Tmp;
    DWORD                          Error;
    LPWSTR                         TmpStr;
    
    if( FLUSH_ANYWAY != FlushNow && 0 == Bits1->nDirtyOps ) {
        return ERROR_SUCCESS;
    }

    Bits1->nDirtyOps = 0;

    ZeroMemory( BitsValueName, sizeof(BitsValueName));
    ConvertAddressToLPWSTR(Ctxt->Range->Start, BitsValueName);
    wcscat(BitsValueName, L" ");
    wcscat(BitsValueName, REG_RANGE_BITS_PREFIX);
    TmpStr = &BitsValueName[wcslen(BitsValueName)];
    for( Count = 5; Count >= 0; Count -- ) {
        TmpStr[Count] = (WCHAR)(L'0' + (Index%10)); Index/= 10;
    }
    TmpStr[6] = L'\0';

    if( 0 == Bits1->nSet ) {

        //
        // If no bit is set, we don't have to write this to registry -- just need to REMOVE value..
        //

        Error = RegDeleteValue(Key, (LPWSTR)BitsValueName);
        if( ERROR_FILE_NOT_FOUND == Error || ERROR_PATH_NOT_FOUND == Error ) {
            return ERROR_SUCCESS;
        }
        return Error;
    }

    //
    // compose TempBuffer -- note that this whole func is serialized, so we can use
    // TempBuffer safely..
    //

    Tmp = htonl(Bits1->Size); memcpy(&TempBuffer[0*sizeof(DWORD)], &Tmp, sizeof(DWORD));
    if( Bits1->Size == Bits1->nSet ) {
        Require(Bits1->Mask == NULL);
        Tmp = 0;
    } else Tmp = htonl(Bits1->AllocSize);
    memcpy(&TempBuffer[1*sizeof(DWORD)], &Tmp, sizeof(DWORD));
    Tmp = htonl(Bits1->nSet); memcpy(&TempBuffer[2*sizeof(DWORD)], &Tmp, sizeof(DWORD));
    Tmp = htonl(Bits1->Offset); memcpy(&TempBuffer[3*sizeof(DWORD)], &Tmp, sizeof(DWORD));
    if( Bits1->Mask ) {
        memcpy(&TempBuffer[4*sizeof(DWORD)], Bits1->Mask, Bits1->AllocSize);
        WriteSize += Bits1->AllocSize;
    }

    return RegSetValueEx(
        Key,
        (LPWSTR)BitsValueName,
        0,
        REG_BINARY,
        TempBuffer,
        WriteSize
    );
}

DWORD
DhcpRegClearupRangeValues(
    IN      PM_SUBNET              Subnet,
    IN      PM_RANGE               Range
)
/*++

Routine Description:

    This routine clears up all values for a given Range (this can be
    specified via a single Key for the range, or via the Range/Subnet
    object pair) excepting "StartAddress", "EndAddress" and "Flags".

Arguments:

    Key                            INVALID_HANDLE_VALUE if range is specified
                                   via Range, Subnet pair. Else Range key in registry.

    Subnet                         Subnet object if Key is not speificed.

    Range                          Range object if key is not specified.

Returns:

    Win32 errors (registry) or ERROR_SUCCESS on success.

--*/
{
    ULONG                          Error, nValues, Index;
    REG_HANDLE                     Hdl;
    HKEY                           UseKey;
    WCHAR                          ValueNameBuf[100], RangeStr[50];
    DWORD                          ValueNameSize, ValueType;

    Error = DhcpRegGetThisServer( &Hdl );
    if( NO_ERROR != Error ) return Error;

    ZeroMemory( RangeStr, sizeof(RangeStr));
    ConvertAddressToLPWSTR( Range->Start, RangeStr );
    
    UseKey = Hdl.Key;

    do {
        Error = RegQueryInfoKey(
            UseKey, NULL, NULL, NULL, NULL, NULL, NULL, &nValues, NULL, NULL, NULL, NULL
        );
        if( ERROR_SUCCESS != Error ) break;

        Index = nValues -1;
        while( nValues ) {

            ValueNameSize = sizeof(ValueNameBuf)/sizeof(WCHAR);
            Error = RegEnumValue(
                UseKey,
                Index,
                (LPWSTR)ValueNameBuf,
                &ValueNameSize,
                NULL,
                &ValueType,
                NULL,
                NULL
            );
            if( ERROR_SUCCESS != Error ) break;

            if( 0 == wcsncmp( ValueNameBuf, RangeStr,
                              wcslen(RangeStr) ) ) {
                RegDeleteValue(UseKey, (LPWSTR)ValueNameBuf);
            }

            Index --;
            nValues --;
        }

    } while ( 0 );

    DhcpRegCloseHdl(&Hdl);

    return Error;
}


// This function is ALSO CALLED FROM REGREAD.C while reading in a subnet info..
    
//BeginExport(function)
DWORD
FlushRanges(
    IN      PM_RANGE               Range,
    IN      DWORD                  FlushNow,
    IN      PM_SUBNET              Subnet
)   //EndExport(function)
{
    DWORD                          Error;
    REG_HANDLE                     Hdl;
    PM_BITMASK                     BitMask;
    FLSH_BITS_CTXT                 Ctxt = { &Hdl, Subnet, Range, 0};

    if( (FLUSH_ANYWAY != FlushNow && 0 == Range->DirtyOps) ||
        (FLUSH_MODIFIED_DIRTY == FlushNow && Range->DirtyOps < DIRT_THRESHOLD ) ) {
        return ERROR_SUCCESS;
    }

    Error = DhcpRegGetThisServer( &Hdl );
    if( NO_ERROR != Error ) return Error;

    //
    // Lock is needed to serialize access to memory -- shouldn't be allocating addresses
    // while we're planning to save it to registry..
    //

    LOCK_INPROGRESS_LIST();
    LOCK_MEMORY();

    Range->DirtyOps = 0;
    BitMask = Range->BitMask;

    if( FLUSH_ANYWAY == FlushNow ) {
        DhcpRegClearupRangeValues(Subnet, Range);
    }
    
    Error = FlushCheckLoop(&BitMask->Array, FlushBitmask, FlushNow, &Ctxt );

    DhcpRegCloseHdl( &Hdl );
    
    UNLOCK_MEMORY();
    UNLOCK_INPROGRESS_LIST();

    return Error;
}

DWORD
FlushSubnets(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  FlushNow,
    IN      LPVOID                 Context_UNUSED
)
{
    ULONG                          Error;

    Error = FlushCheckLoop(&Subnet->Ranges, FlushRanges, FlushNow, Subnet);
    Require( ERROR_SUCCESS == Error );

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegServerFlush(
    IN      PM_SERVER              Server,
    IN      DWORD                  FlushNow
) //EndExport(function)
{
    DWORD   Error;

    Error = FlushCheckLoop(&Server->Subnets, FlushSubnets, FlushNow, NULL);
    Require(ERROR_SUCCESS == Error);
    Error = FlushCheckLoop(&Server->MScopes, FlushSubnets, FlushNow, NULL);
    Require(ERROR_SUCCESS == Error);
    return Error;
}

//BeginExport(function)
DWORD
DhcpRegFlushServer(
    IN      DWORD                  FlushNow
) //EndExport(function)
{
    PM_SERVER                      Server;
    DWORD                          Error;
    PM_SERVER                      DhcpGetCurrentServer(VOID);

    Server = DhcpGetCurrentServer();

    Error = FlushCheckLoop(&Server->Subnets, FlushSubnets, FlushNow, NULL);
    Require(ERROR_SUCCESS == Error);
    Error = FlushCheckLoop(&Server->MScopes, FlushSubnets, FlushNow, NULL);
    Require(ERROR_SUCCESS == Error);
    return Error;
}

//================================================================================
// ds support routines -- flush a full server to disk
//================================================================================

DWORD
SaveArray(
    IN      PARRAY                 Array,
    IN      DWORD                  (*Func)(LPVOID, LPVOID, LPVOID),
    IN      LPVOID                 Arg2,
    IN      LPVOID                 Arg3
)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Result;
    LPVOID                         ThisPtr;

    Result = MemArrayInitLoc(Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Result ) {
        Result = MemArrayGetElement(Array, &Loc, &ThisPtr);
        Require(ERROR_SUCCESS == Result && NULL != ThisPtr );

        Result = Func(ThisPtr, Arg2, Arg3);
        if( ERROR_SUCCESS != Result ) return Result;

        Result = MemArrayNextLoc(Array, &Loc);
    }
    return ERROR_SUCCESS;
}

DWORD
DhcpRegSaveOptList(
    IN      PM_ONECLASS_OPTLIST    OptClassOptList,
    IN      LPVOID                 Arg1,
    IN      LPVOID                 Arg2
)
{
    DWORD                          Result;
    DWORD                          ClassId;
    DWORD                          VendorId;
    LPWSTR                         ClassName;
    LPWSTR                         VendorName;
    PM_OPTLIST                     OptList;
    PM_SERVER                      Server;
    PM_SUBNET                      Subnet;
    PM_RESERVATION                 Reservation;
    PM_SSCOPE                      SScope;
    PM_OPTION                      Option;
    PM_CLASSDEF                    ClassDef;
    ARRAY_LOCATION                 Loc;

    ClassId = OptClassOptList->ClassId;
    VendorId = OptClassOptList->VendorId;
    OptList = &OptClassOptList->OptList;

    if( NULL != Arg1 && NULL != Arg2 ) {          // reservations
        Reservation = Arg1; Subnet = Arg2;
        Server = Subnet->ServerPtr;
    } else if( NULL == Arg2 ) {                   // subnet options
        Reservation = NULL; Subnet = Arg1;
        Server = Subnet->ServerPtr;
    } else if( NULL == Arg1 ) {                   // global options
        Reservation = NULL; Subnet = NULL;
        Server = Arg2;
    } else {                                      // enterprise options?
        return ERROR_NOT_SUPPORTED;
    }

    Result = MemServerGetClassDef(                // get the vendor name first
        Server,
        VendorId,
        NULL,
        0,
        NULL,
        &ClassDef
    );
    if( ERROR_SUCCESS != Result ) {
        VendorName = NULL;
    } else {
        VendorName = ClassDef->Name;
        Require(ClassDef->IsVendor == TRUE);
    }

    Result = MemServerGetClassDef(                // get the class name for this class
        Server,
        ClassId,
        NULL,
        0,
        NULL,
        &ClassDef
    );
    if( ERROR_SUCCESS != Result ) {
        ClassName = NULL;
    } else {
        ClassName = ClassDef->Name;
        Require(ClassDef->IsVendor == FALSE);
    }

    Result = MemArrayInitLoc(OptList, &Loc);
    while( ERROR_FILE_NOT_FOUND != Result ) {
        //- ERROR_SUCCESS == Result
        Result = MemArrayGetElement(OptList, &Loc, &Option);
        //- ERROR_SUCCESS == Result && NULL != Option
        if( NULL != Reservation ) {               // save reservation options
            Result = DhcpRegSaveReservedOption(
                Subnet->Address,
                Reservation->Address,
                Option->OptId,
                ClassName,
                VendorName,
                Option->Val,
                Option->Len
            );
        } else if( NULL != Subnet ) {             // save subnet optinos
            Result = DhcpRegSaveSubnetOption(
                Subnet,
                Option->OptId,
                ClassName,
                VendorName,
                Option->Val,
                Option->Len
            );
        } else if( NULL != Server ) {             // save global options
            Result = DhcpRegSaveGlobalOption(
                Option->OptId,
                ClassName,
                VendorName,
                Option->Val,
                Option->Len
            );
        } else {                                  // save enterprise wide optinos
            return ERROR_CALL_NOT_IMPLEMENTED;
        }
        if( ERROR_SUCCESS != Result ) return Result;

        Result = MemArrayNextLoc(OptList, &Loc);
    }

    return ERROR_SUCCESS;
}

DWORD
DhcpRegSaveReservationOptions(
    IN      PM_OPTCLASS            OptClass,
    IN      PM_RESERVATION         Reservation,
    IN      PM_SUBNET              Subnet
)
{
    DWORD                          Result;
    ARRAY_LOCATION                 Loc;

    return SaveArray(&OptClass->Array, DhcpRegSaveOptList, Reservation, Subnet);
}

DWORD
DhcpRegSaveSubnetOptions(
    IN      PM_OPTCLASS            OptClass,
    IN      PM_SUBNET              Subnet,
    IN      LPVOID                 Unused
)
{
    return SaveArray(&OptClass->Array, DhcpRegSaveOptList, Subnet, NULL);
}

DWORD
DhcpRegSaveGlobalOptions(
    IN      PM_OPTCLASS            OptClass,
    IN      PM_SERVER              Server,
    IN      LPVOID                 Unused
)
{
    return SaveArray(&OptClass->Array, DhcpRegSaveOptList, NULL, Server);
}

DWORD
DhcpRegSaveOptDefList(
    IN      PM_OPTCLASSDEFL_ONE    OClassDefL,
    IN      PM_SERVER              Server,
    IN      LPVOID                 Unused
)
{
    DWORD                          Result;
    DWORD                          ClassId;
    DWORD                          VendorId;
    LPWSTR                         ClassName;
    LPWSTR                         VendorName;
    PM_OPTDEFLIST                  OptDefList;
    PM_OPTDEF                      OptDef;
    PM_CLASSDEF                    ClassDef;
    ARRAY_LOCATION                 Loc;

    ClassId = OClassDefL->ClassId;
    VendorId = OClassDefL->VendorId;
    OptDefList = &OClassDefL->OptDefList;

    Result = MemServerGetClassDef(                // first find the vendor name
        Server,
        VendorId,
        NULL,
        0,
        NULL,
        &ClassDef
    );
    if( ERROR_SUCCESS != Result ) {
        VendorName = NULL;
    } else {
        VendorName = ClassDef->Name;
        Require(ClassDef->IsVendor == TRUE);
    }

    Result = MemServerGetClassDef(                // now find the class name
        Server,
        ClassId,
        NULL,
        0,
        NULL,
        &ClassDef
    );
    if( ERROR_SUCCESS != Result ) {
        ClassName = NULL;
    } else {
        ClassName = ClassDef->Name;
        Require(ClassDef->IsVendor == FALSE);
    }

    Result = MemArrayInitLoc(&OptDefList->OptDefArray, &Loc);
    while( ERROR_FILE_NOT_FOUND != Result ) {
        //- ERROR_SUCCESS == Result
        Result = MemArrayGetElement(&OptDefList->OptDefArray, &Loc, &OptDef);
        //- ERROR_SUCCESS == Result && NULL != OptDef
        Result = DhcpRegSaveOptDef(
            OptDef->OptId,
            ClassName,
            VendorName,
            OptDef->OptName,
            OptDef->OptComment,
            OptDef->Type,
            OptDef->OptVal,
            OptDef->OptValLen
        );
        if( ERROR_SUCCESS != Result ) return Result;

        Result = MemArrayNextLoc(&OptDefList->OptDefArray, &Loc);
    }

    return ERROR_SUCCESS;
}

DWORD
DhcpRegSaveOptDefs(
    IN      PM_OPTCLASSDEFLIST     OptDefs,
    IN      PM_SERVER              Server,
    IN      LPVOID                 Unused
)
{
    return SaveArray(&OptDefs->Array, DhcpRegSaveOptDefList, Server, NULL);
}

DWORD
DhcpRegSaveClass(
    IN      PM_CLASSDEF            Class,
    IN      PM_SERVER              Server,
    IN      LPVOID                 Unused
)
{
    return DhcpRegSaveClassDef(
        Class->Name,
        Class->Comment,
        (DWORD)Class->IsVendor,
        Class->ActualBytes,
        Class->nBytes
    );
}

DWORD
DhcpRegSaveClassDefs(
    IN      PM_CLASSDEFLIST        ClassDefs,
    IN      PM_SERVER              Server,
    IN      LPVOID                 Unused
)
{
    return SaveArray(&ClassDefs->ClassDefArray, DhcpRegSaveClass, Server, NULL);
}

DWORD
DhcpRegSaveRanges(
    IN      PM_RANGE               Range,
    IN      PM_SUBNET              Subnet,
    IN      LPVOID                 Unused
)
{
    DWORD                          Result;
    DWORD                          Zero = 0;
    
    return DhcpRegAddRangeEx(
        Subnet,
        Range->Start,
        Range->End,
        Range->BootpAllocated,
        Range->MaxBootpAllowed,
        Range->State,
        (LPBYTE)&Zero,
        sizeof(Zero),
        (LPBYTE)&Zero,
        sizeof(Zero)
    );
}

DWORD
DhcpRegSaveExcls(
    IN      PM_SUBNET              Subnet,
    IN      PARRAY                 Excl
)
{
    DWORD                          Result;
    DWORD                          nElems;
    DWORD                         *ExclArray;
    DWORD                          i;
    ARRAY_LOCATION                 Loc;
    PM_RANGE                       ThisRange;

    nElems = MemArraySize(Excl);
    ExclArray = MemAlloc(( nElems*2+1) *sizeof(DWORD));
    if( NULL == ExclArray ) return ERROR_NOT_ENOUGH_MEMORY;

    ExclArray[0] = nElems;

    MemArrayInitLoc(Excl, &Loc);
    for( i = 0 ; i < nElems ; i ++ ) {
        MemArrayGetElement(Excl, &Loc, &ThisRange);
        Require(ThisRange != NULL);

        ExclArray[2*i+1] = ThisRange->Start;
        ExclArray[2*i+2] = ThisRange->End;
        MemArrayNextLoc(Excl, &Loc);
    }

    Result = DhcpRegSaveExcl(Subnet, (LPBYTE)ExclArray, sizeof(DWORD)*(nElems*2+1));
    MemFree(ExclArray);

    return Result;
}


DWORD
DhcpRegSaveReservation1(
    IN      PM_RESERVATION         Reservation,
    IN      PM_SUBNET              Subnet,
    IN      LPVOID                 Unused
)
{
    DWORD                          Result;

    Result = DhcpRegSaveReservation(
        Subnet->Address,
        Reservation->Address,
        Reservation->Flags,
        Reservation->ClientUID,
        Reservation->nBytes
    );
    if( ERROR_SUCCESS != Result ) return Result;

    return DhcpRegSaveReservationOptions(
        &Reservation->Options, Reservation, Subnet
    );
}

DWORD
DhcpRegSaveReservations(
    IN      PM_RESERVATIONS        Reservations,
    IN      PM_SUBNET              Subnet,
    IN      LPVOID                 Unused
)
{
    return SaveArray(Reservations, DhcpRegSaveReservation1, Subnet, NULL);
}


DWORD
DhcpRegSaveSubnets(
    IN      PM_SUBNET              Subnet,
    IN      PM_SERVER              Server,
    IN      LPVOID                 Unused2
)
{
    DWORD                          Result;
    PM_SSCOPE                      SScope;

    if( Subnet->fSubnet ) {
        Result = DhcpRegSaveSubnet(
            Subnet->Address,
            Subnet->Mask,
            Subnet->State,
            Subnet->Name,
            Subnet->Description
        );
    } else {
        Result = DhcpRegSaveMScope(
            Subnet->MScopeId,
            Subnet->State,
            Subnet->Policy,
            Subnet->TTL,
            Subnet->Name,
            Subnet->Description,
            Subnet->LangTag,
            &Subnet->ExpiryTime
        );
    }
    if( ERROR_SUCCESS != Result ) return Result;

    Result = SaveArray(&Subnet->Ranges, DhcpRegSaveRanges, Subnet, NULL);
    if( ERROR_SUCCESS != Result ) return Result;

    Result = DhcpRegSaveExcls(
        Subnet,
        &Subnet->Exclusions
    );
    if( ERROR_SUCCESS != Result ) return Result;

    Result = DhcpRegSaveSubnetOptions(&Subnet->Options, Subnet, NULL);
    if( ERROR_SUCCESS != Result ) return Result;

    Result = DhcpRegSaveReservations(&Subnet->Reservations, Subnet, NULL);
    if( ERROR_SUCCESS != Result ) return Result;

    if( 0 == Subnet->SuperScopeId ) return ERROR_SUCCESS;
    Result = MemServerFindSScope(
        Server,
        Subnet->SuperScopeId,
        NULL,
        &SScope
    );
    if( ERROR_FILE_NOT_FOUND == Result ) return ERROR_SUCCESS;
    if( ERROR_SUCCESS != Result ) return Result;

    Result = DhcpRegSScopeSaveSubnet(SScope->Name, Subnet->Address);
    if( ERROR_SUCCESS != Result ) return Result;

    return ERROR_SUCCESS;
}

DWORD
DhcpRegSaveMScopes(
    IN      PM_MSCOPE              MScope,
    IN      PM_SERVER              Server,
    IN      LPVOID                 Unused
)
{
    return DhcpRegSaveSubnets(MScope, Server, NULL);
}


//BeginExport(function)
DWORD
DhcpRegServerSave(
    IN      PM_SERVER              Server
)   //EndExport(function)
{
    DWORD                          Result;

#if 0
    Result = DhcpRegServerSetAttributes(
        Hdl,
        &Server->Name,
        &Server->Comment,
        &Server->State
    );
    if( ERROR_SUCCESS != Result ) return Result;
#endif

    Result = SaveArray(&Server->Subnets, DhcpRegSaveSubnets, Server, NULL);
    if( ERROR_SUCCESS != Result ) return Result;

    Result = SaveArray(&Server->MScopes, DhcpRegSaveMScopes, Server, NULL);
    if( ERROR_SUCCESS != Result ) return Result;

#if 0
    Result = SaveArray(&Server->SuperScopes, DhcpRegSaveSuperScopes, Server, NULL);
    if( ERROR_SUCCESS != Result ) return Result;
#endif

    Result = DhcpRegSaveGlobalOptions(&Server->Options, Server, NULL);
    if( ERROR_SUCCESS != Result ) return Result;

    Result = DhcpRegSaveOptDefs(&Server->OptDefs, Server, NULL);
    if( ERROR_SUCCESS != Result ) return Result;

    Result = DhcpRegSaveClassDefs(&Server->ClassDefs, Server, NULL);
    if( ERROR_SUCCESS != Result ) return Result;

    return ERROR_SUCCESS;
}

#if 0
// ---BeginExport(function)
DWORD
DhcpRegSaveThisServer(
    IN      LPWSTR                 Location,
    IN      PM_SERVER              Server
) //   ---EndExport(function)
{
    DWORD                          Result, Result2;
    REG_HANDLE                     Hdl;
    REG_HANDLE                     SaveHdl;

    Result = DhcpRegGetThisServer(&Hdl);
    if( ERROR_SUCCESS != Result ) return Result;

    Result = DhcpRegGetNextHdl(&Hdl, Location, &SaveHdl);
    Result2 = DhcpRegCloseHdl(&Hdl);
    Require( ERROR_SUCCESS == Result2 );

    if( ERROR_SUCCESS != Result ) return Result;

    DhcpRegSetCurrentServer(&SaveHdl);

    Result = DhcpRegServerSave(Server);

    DhcpRegSetCurrentServer(NULL);
    Result2 = DhcpRegCloseHdl(&SaveHdl);
    Require( ERROR_SUCCESS == Result2 );

    return Result;
}
#endif

//BeginExport(function)
DWORD
DhcpMigrateMScopes(
    IN LPCWSTR OldMscopeName,
    IN LPCWSTR NewMscopeName,
    IN DWORD (*SaveOrRestoreRoutine)(
        IN HKEY Key, IN LPWSTR ConfigName, IN BOOL fRestore
        )
    ) //EndExport(function)
/*++

Routine Description:

    This routine attempts to migrate the key stored under
    OldMscopeName to NewMscopeName name.

    N.B.  It does not delete the old key.
    
Return Values:

    Win32 error codes

--*/
{
    REG_HANDLE Hdl1, Hdl2, Hdl3;
    ULONG Error, Error2;
    
    Error = DhcpRegGetThisServer(&Hdl1);
    if( NO_ERROR != Error ) return Error;

    Error = DhcpRegServerGetMScopeHdl(
        &Hdl1, (LPWSTR)OldMscopeName, &Hdl2
        );
    if( NO_ERROR == Error ) {
        Error2 = DhcpRegServerGetMScopeHdl(
            &Hdl1, (LPWSTR)NewMscopeName, &Hdl3
            );
    }

    DhcpRegCloseHdl(&Hdl1);
    if( NO_ERROR != Error ) return Error;
    if( NO_ERROR != Error2 ) {
        DhcpRegCloseHdl(&Hdl2);
        return Error2;
    }
    
    Error = SaveOrRestoreRoutine(
        Hdl2.Key, L"DHCPMSCOPE.CFG", FALSE
        );

    if( NO_ERROR == Error ) {
        Error = SaveOrRestoreRoutine(
            Hdl3.Key, L"DHCPMSCOPE.CFG", TRUE
            );
    }

    DhcpRegCloseHdl(&Hdl2);
    DhcpRegCloseHdl(&Hdl3);

    return Error;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mmreg\regutil.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: simple registry utilities
//================================================================================

#include <mmregpch.h>

//BeginExport(typedef)
typedef struct _REG_HANDLE {
    HKEY                           Key;
    HKEY                           SubKey;
    LPWSTR                         SubKeyLocation;
} REG_HANDLE, *PREG_HANDLE, *LPREG_HANDLE;
//EndExport(typedef)

//BeginExport(constants)
#define     REG_THIS_SERVER                       L"Software\\Microsoft\\DHCPServer\\Configuration"
#define     REG_THIS_SERVER_DS                    L"Software\\Microsoft\\DHCPServer\\Config_DS"
#define     REG_THIS_SERVER_DS_VALUE              L"Config_DS"
#define     REG_THIS_SERVER_DS_PARENT             L"Software\\Microsoft\\DHCPServer"

#define     REG_SERVER_GLOBAL_OPTIONS             L"GlobalOptionValues"
#define     REG_SERVER_OPTDEFS                    L"OptionInfo"
#define     REG_SERVER_SUBNETS                    L"Subnets"
#define     REG_SERVER_SSCOPES                    L"SuperScope"
#define     REG_SERVER_CLASSDEFS                  L"ClassDefs"
#define     REG_SERVER_MSCOPES                    L"MulticastScopes"

#define     REG_SUBNET_SERVERS                    L"DHCPServers"
#define     REG_SUBNET_RANGES                     L"IpRanges"
#define     REG_SUBNET_RESERVATIONS               L"ReservedIps"
#define     REG_SUBNET_OPTIONS                    L"SubnetOptions"

#define     REG_SUBNET_EXCL                       L"ExcludedIpRanges"
#define     REG_SUBNET_ADDRESS                    L"SubnetAddress"
#define     REG_SUBNET_NAME                       L"SubnetName"
#define     REG_SUBNET_COMMENT                    L"SubnetComment"
#define     REG_SUBNET_MASK                       L"SubnetMask"
#define     REG_SUBNET_STATE                      L"SubnetState"
#define     REG_SUBNET_SWITCHED_FLAG              L"SwitchedNetworkFlag"

#define     REG_MSCOPE_NAME                       L"MScopeName"
#define     REG_MSCOPE_COMMENT                    L"MScopeComment"
//
// Win2K Beta2 and Beta3 went out with scope id param value MScopeId.
// Since their meaning is being changed, to avoid any costly upgrade
// code, this value is being changed to MScopeIdValue: to automatically
// chose a good scope id, TTL values.  Note that the default value of 
// zero is treated specially for this scope id param. It implies that
// this was probably a pre-RC1 upgrade.  In this case, the Scope ID
// defaults to first value in the range.
//
#define     REG_MSCOPE_SCOPEID                    L"MScopeIdValue"
#define     REG_MSCOPE_STATE                      L"MScopeState"
#define     REG_MSCOPE_ADDR_POLICY                L"MScopeAddressPolicy"
#define     REG_MSCOPE_TTL                        L"MScopeTTL"
#define     REG_MSCOPE_LANG_TAG                   L"MScopeLangTag"
#define     REG_MSCOPE_EXPIRY_TIME                L"MScopeExpiryTime"

#define     REG_SUB_SERVER_NAME                   L"ServerHostName"
#define     REG_SUB_SERVER_COMMENT                L"ServerComment"
#define     REG_SUB_SERVER_ADDRESS                L"ServerAddress"
#define     REG_SUB_SERVER_ROLE                   L"Role"

#define     REG_RANGE_NAME                        L"RangeName"
#define     REG_RANGE_COMMENT                     L"RangeComment"
#define     REG_RANGE_START_ADDRESS               L"StartAddress"
#define     REG_RANGE_END_ADDRESS                 L"EndAddress"
#define     REG_RANGE_INUSE_CLUSTERS              L"InUseClusters"
#define     REG_RANGE_USED_CLUSTERS               L"UsedClusters"
#define     REG_RANGE_BITS_PREFIX                 L"Bits "
#define     REG_RANGE_BITS_PREFIX_WCHAR_COUNT     (5)
#define     REG_RANGE_FLAGS                       L"RangeFlags"
#define     REG_RANGE_ALLOC                       L"RangeBootpAllocated"
#define     REG_RANGE_MAX_ALLOC                   L"RangeBootpMaxAllowed"

#define     REG_OPTION_NAME                       L"OptionName"
#define     REG_OPTION_COMMENT                    L"OptionComment"
#define     REG_OPTION_TYPE                       L"OptionType"
#define     REG_OPTION_VALUE                      L"OptionValue"
#define     REG_OPTION_ID                         L"OptionId"
#define     REG_OPTION_CLASSNAME                  L"OptionClassName"
#define     REG_OPTION_VENDORNAME                 L"OptionVendorName"

#define     REG_CLASSDEF_NAME                     L"ClassName"
#define     REG_CLASSDEF_COMMENT                  L"ClassComment"
#define     REG_CLASSDEF_TYPE                     L"ClassType"
#define     REG_CLASSDEF_VALUE                    L"ClassValue"

#define     REG_RESERVATION_ADDRESS               L"IpAddress"
#define     REG_RESERVATION_UID                   L"ClientUID"
#define     REG_RESERVATION_TYPE                  L"AllowedClientTypes"
#define     REG_RESERVATION_NAME                  L"ReservationName"
#define     REG_RESERVATION_COMMENT               L"ReservationComment"

#define     REG_FLAGS                             L"Flags"

#define     REG_ACCESS                            KEY_ALL_ACCESS
#define     REG_DEFAULT_SUBNET_STATE              0
#define     REG_DEFAULT_SUBNET_MASK               0xFFFFFFFF
#define     REG_DEFAULT_SWITCHED_FLAG             FALSE

#define     REG_CLASS                             L"DhcpClass"

#define DHCP_LAST_DOWNLOAD_TIME_VALUE             L"LastDownloadTime"
#define DHCP_LAST_DOWNLOAD_TIME_TYPE              REG_BINARY

#define     DEF_RANGE_ALLOC                       0
#define     DEF_RANGE_MAX_ALLOC                   (~(ULONG)0)

//EndExport(constants)

const       DWORD                                 ZeroReserved = 0;
const       LPVOID                                NullReserved = 0;
#define     MAX_KEY_SIZE                          512
#define     DEF_RANGE_FLAG_VAL                    (MM_FLAG_ALLOW_DHCP)
#define     DEF_RESERVATION_TYPE                  (MM_FLAG_ALLOW_DHCP|MM_FLAG_ALLOW_BOOTP)

//BeginExport(comment)
//================================================================================
//  The basic open/traverse/close functions are here
//================================================================================
//EndExport(comment)
HKEY        CurrentServerKey  = NULL;

//BeginExport(function)
DWORD
DhcpRegSetCurrentServer(
    IN OUT  PREG_HANDLE            Hdl
) //EndExport(function)
{
    CurrentServerKey = Hdl? Hdl->Key : NULL;
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRegGetThisServer(
    IN OUT  PREG_HANDLE            Hdl
) //EndExport(function)
{
    DWORD                          Disposition;

    if( NULL != CurrentServerKey ) {
        return RegOpenKeyEx(                      // duplicate key
            CurrentServerKey,
            NULL,
            ZeroReserved,
            REG_ACCESS,
            &Hdl->Key
        );
    }
    return RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        REG_THIS_SERVER,
        ZeroReserved,
        REG_CLASS,
        REG_OPTION_NON_VOLATILE,
        REG_ACCESS,
        NULL,
        &Hdl->Key,
        &Disposition
    );
}

//BeginExport(function)
DWORD
DhcpRegGetNextHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 NextLoc,
    OUT     PREG_HANDLE            OutHdl
) //EndExport(function)
{
    DWORD                          Disposition;
    DWORD                          Error;

    Error = RegCreateKeyEx(
        Hdl->Key,
        NextLoc,
        ZeroReserved,
        REG_CLASS,
        REG_OPTION_NON_VOLATILE,
        REG_ACCESS,
        NULL,
        &OutHdl->Key,
        &Disposition
    );
    return Error;
}

//BeginExport(function)
DWORD
DhcpRegCloseHdl(
    IN OUT  PREG_HANDLE            Hdl
) //EndExport(function)
{
    DWORD                          Error;

    Error = RegCloseKey(Hdl->Key);
    Hdl->Key = NULL;
    return Error;
}

//BeginExport(comment)
//================================================================================
//   MISC utilities for registry manipulation
//================================================================================
//EndExport(comment)
//BeginExport(function)
DWORD
DhcpRegFillSubKeys(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Array          // fill in a list of key names
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Index;
    DWORD                          Size;
    WCHAR                          KeyName[MAX_KEY_SIZE];
    LPWSTR                         ThisKeyName;

    Index = 0;
    do {
        Size = sizeof(KeyName)/sizeof(KeyName[0]);
        Error = RegEnumKeyEx(
            Hdl->Key,
            Index++,
            KeyName,
            &Size,
            NullReserved,
            NULL,
            NULL,
            NULL
        );
        if( ERROR_NO_MORE_ITEMS == Error ) {
            Error = ERROR_SUCCESS;
            break;
        }
        if( ERROR_SUCCESS != Error ) break;
        Require(0 != Size);
        Size += 1;                                // for the terminating L'\0' char
        Size *= sizeof(WCHAR);                    // looks like the units are WCHAR!!

        ThisKeyName = MemAlloc(Size);
        if( NULL == ThisKeyName ) return ERROR_NOT_ENOUGH_MEMORY;

        wcscpy(ThisKeyName, KeyName);

        Error = MemArrayAddElement(Array, (LPVOID)ThisKeyName);
        if( ERROR_SUCCESS != Error ) {
            MemFree(ThisKeyName);
        }
    } while( ERROR_SUCCESS == Error );

    Require(ERROR_MORE_DATA != Error);
    return Index? ERROR_SUCCESS : Error;          // if we added something, dont bother about reporting error
}

//BeginExport(function)
LPVOID                                            // DWORD or LPWSTR or LPBYTE
DhcpRegRead(                                      // read differnt values from registry and allocate if not DWORD
    IN      PREG_HANDLE            Hdl,
    IN      DWORD                  Type,          // if DWORD dont allocate memory
    IN      LPWSTR                 ValueName,
    IN      LPVOID                 RetValue       // value to use if nothing found
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Size;
    DWORD                          Dword;
    LPVOID                         Ret;

    if( REG_DWORD == Type ) {
        Size = sizeof(DWORD);
        Ret = (LPVOID)&Dword;
    } else {
        Size = 0;
        Error = RegQueryValueEx(
            Hdl->Key,
            ValueName,
            NullReserved,
            NULL,
            NULL,
            &Size
        );
        if( ERROR_SUCCESS != Error ) return RetValue;
        if (Size == 0) return RetValue;           // MemAlloc does not check the size!
        Ret = MemAlloc(Size);
        if( NULL == Ret ) return RetValue;        // should not really happen
    }

    Error = RegQueryValueEx(
        Hdl->Key,
        ValueName,
        NullReserved,
        NULL,
        Ret,
        &Size
    );
    if( ERROR_SUCCESS != Error && Ret != (LPVOID)&Dword ) {
        MemFree(Ret);
        Ret = NULL;
    }

    if( ERROR_SUCCESS != Error) return RetValue;

    if( Ret == (LPVOID)&Dword ) {
        return ULongToPtr(Dword);
    } else {
        return Ret;
    }
}

//BeginExport(function)
DWORD
DhcpRegReadBinary(                                // read binary type
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 ValueName,
    OUT     LPBYTE                *RetVal,
    OUT     DWORD                 *RetValSize
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Size;
    LPVOID                         Ret;

    *RetVal = NULL;
    *RetValSize = 0;

    Size = 0;
    Error = RegQueryValueEx(
        Hdl->Key,
        ValueName,
        NullReserved,
        NULL,
        NULL,
        &Size
    );
    if( ERROR_SUCCESS != Error ) return Error;
    if( 0 == Size ) return ERROR_SUCCESS;
    Ret = MemAlloc(Size);
    if( NULL == Ret ) return ERROR_NOT_ENOUGH_MEMORY;

    Error = RegQueryValueEx(
        Hdl->Key,
        ValueName,
        NullReserved,
        NULL,
        Ret,
        &Size
    );
    if( ERROR_SUCCESS != Error ) {
        MemFree(Ret);
        return Error;
    }

    *RetVal = Ret;
    *RetValSize = Size;
    return ERROR_SUCCESS;
}

//BeginExport(function)
LPWSTR
DhcpRegCombineClassAndOption(                     // create string based on class name and option id
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      DWORD                  OptionId
) //EndExport(function)
{
    DWORD                          Size;
    LPWSTR                         Ptr;

    if( NULL == VendorName && NULL == ClassName ) {

        //
        // Special case usual options for downward compatability with older
        // options.. (NT4 options in registry don't have any "!" in them.
        //

        Ptr = MemAlloc( 4 * sizeof(WCHAR) );
        if( NULL == Ptr ) return NULL;
        Ptr [2] = L'0' + (BYTE)(OptionId %10); OptionId /= 10;
        Ptr [1] = L'0' + (BYTE)(OptionId %10); OptionId /= 10;
        Ptr [0] = L'0' + (BYTE)(OptionId %10);
        Ptr [3] = L'\0';
        return Ptr;
    }

    if( NULL == VendorName ) VendorName = L"";
    if( NULL == ClassName ) ClassName = L"";
    Size = (wcslen(ClassName) + 1 + 5)*sizeof(WCHAR);
    Size += wcslen(VendorName)*sizeof(WCHAR);

    Ptr = MemAlloc(Size);
    if( NULL == Ptr ) return NULL;

    Size = 0;

    Ptr[2+Size] = L'0' + (BYTE)(OptionId % 10); OptionId /= 10;
    Ptr[1+Size] = L'0' + (BYTE)(OptionId % 10); OptionId /= 10;
    Ptr[0+Size] = L'0' + (BYTE)(OptionId % 10);
    Ptr[3+Size] = L'\0';
    wcscat(Ptr, L"!");
    wcscat(Ptr, VendorName);
    wcscat(Ptr, L"!");
    wcscat(Ptr, ClassName);
    return Ptr;
}

//BeginExport(function)
LPWSTR
ConvertAddressToLPWSTR(
    IN      DWORD                  Address,
    IN OUT  LPWSTR                 BufferStr      // input buffer to fill with dotted notation
) //EndExport(function)
{
    LPSTR                          AddressStr;
    DWORD                          Count;

    Address = ntohl(Address);
    AddressStr = inet_ntoa(*(struct in_addr *)&Address);
    Count = mbstowcs(BufferStr, AddressStr, sizeof("000.000.000.000"));
    if( -1 == Count ) return NULL;
    return BufferStr;
}

//BeginExport(comment)
//================================================================================
//  the following functions help traversing the registry
//================================================================================
//EndExport(comment)

DWORD
DhcpRegGetNextNextHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Loc1,
    IN      LPWSTR                 Loc2,
    OUT     PREG_HANDLE            Hdl2
)
{
    WCHAR                          Loc[MAX_KEY_SIZE*2];
    Loc[ 0 ] = L'\0';

    if ( ( wcslen(Loc1) + wcslen(Loc2) + 1 ) < ( MAX_KEY_SIZE * 2 ) )
    {
        wcscpy(Loc,Loc1);
        wcscat(Loc, L"\\");
        wcscat(Loc,Loc2);
    }

    return DhcpRegGetNextHdl(Hdl, Loc, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegServerGetSubnetHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Subnet,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SERVER_SUBNETS, Subnet, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegServerGetSScopeHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 SScope,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SERVER_SSCOPES, SScope, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegServerGetOptDefHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 OptDef,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SERVER_OPTDEFS, OptDef, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegServerGetOptHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Opt,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SERVER_GLOBAL_OPTIONS, Opt, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegServerGetMScopeHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 MScope,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SERVER_MSCOPES, MScope, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegServerGetClassDefHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 ClassDef,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SERVER_CLASSDEFS, ClassDef, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegSubnetGetOptHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Opt,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SUBNET_OPTIONS, Opt, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegSubnetGetRangeHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Range,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SUBNET_RANGES, Range, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegSubnetGetReservationHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Reservation,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SUBNET_RESERVATIONS, Reservation, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegSubnetGetServerHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Server,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextNextHdl(Hdl, REG_SUBNET_SERVERS, Server, Hdl2);
}

//BeginExport(function)
DWORD
DhcpRegReservationGetOptHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 OptionName,
    OUT     PREG_HANDLE            Hdl2
) //EndExport(function)
{
    return DhcpRegGetNextHdl(Hdl, OptionName, Hdl2);
}

//BeginExport(comment)
//================================================================================
//   List retrieval functions.. for servers, subnets, ranges etc.
//================================================================================
//EndExport(comment)

//BeginExport(function)
DWORD
DhcpRegServerGetList(
    IN      PREG_HANDLE            Hdl,           // ptr to server location
    IN OUT  PARRAY                 OptList,       // list of LPWSTR options
    IN OUT  PARRAY                 OptDefList,    // list of LPWSTR optdefs
    IN OUT  PARRAY                 Subnets,       // list of LPWSTR subnets
    IN OUT  PARRAY                 SScopes,       // list of LPWSTR sscopes
    IN OUT  PARRAY                 ClassDefs,     // list of LPWSTR classes
    IN OUT  PARRAY                 MScopes        // list of LPWSTR mscopes
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          LocalError;
    DWORD                          Index;
    REG_HANDLE                     Hdl2;
    struct {
        PARRAY                     Array;
        LPWSTR                     Location;
    } Table[] = {
        OptList,                   REG_SERVER_GLOBAL_OPTIONS,
        OptDefList,                REG_SERVER_OPTDEFS,
        Subnets,                   REG_SERVER_SUBNETS,
        SScopes,                   REG_SERVER_SSCOPES,
        ClassDefs,                 REG_SERVER_CLASSDEFS,
        MScopes,                   REG_SERVER_MSCOPES
    };

    for( Index = 0; Index < sizeof(Table)/sizeof(Table[0]); Index ++ ) {
        if( NULL == Table[Index].Array ) continue;

        Error = DhcpRegGetNextHdl(Hdl, Table[Index].Location, &Hdl2);
        if( ERROR_SUCCESS != Error ) return Error;

        Error = DhcpRegFillSubKeys(&Hdl2, Table[Index].Array);
        LocalError = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == LocalError);

        if( ERROR_SUCCESS != Error ) return Error;
    }

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSubnetGetExclusions(
    IN      PREG_HANDLE            Hdl,
    OUT     LPBYTE                *Excl,
    OUT     DWORD                 *ExclSize
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Size;
    DWORD                          Type;

    if( NULL == Excl ) return ERROR_SUCCESS;

    Size = 0;
    Error = RegQueryValueEx(
        Hdl->Key,
        REG_SUBNET_EXCL,
        NullReserved,
        &Type,
        NULL,
        &Size
    );
    if( ERROR_SUCCESS != Error ) return Error;

    *Excl = NULL;
    *ExclSize = 0;
    if( 0 == Size ) return ERROR_SUCCESS;

    *Excl = MemAlloc(Size);
    if( NULL == *Excl ) return ERROR_NOT_ENOUGH_MEMORY;
    *ExclSize = Size;
    Error = RegQueryValueEx(
        Hdl->Key,
        REG_SUBNET_EXCL,
        NullReserved,
        &Type,
        *Excl,
        ExclSize
    );
    if( ERROR_SUCCESS != Error ) {
        MemFree(*Excl);
        *Excl = NULL;
    }
    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSubnetGetList(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Servers,
    IN OUT  PARRAY                 IpRanges,
    IN OUT  PARRAY                 Reservations,
    IN OUT  PARRAY                 Options,
    OUT     LPBYTE                *Excl,
    OUT     DWORD                 *ExclSizeInBytes
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          LocalError;
    DWORD                          Index;
    REG_HANDLE                     Hdl2;
    struct {
        PARRAY                     Array;
        LPWSTR                     Location;
    } Table[] = {
        Servers,                   REG_SUBNET_SERVERS,
        IpRanges,                  REG_SUBNET_RANGES,
        Reservations,              REG_SUBNET_RESERVATIONS,
        Options,                   REG_SUBNET_OPTIONS,
        // Exclusions are to be handled a bit differently
    };

    for( Index = 0; Index < sizeof(Table)/sizeof(Table[0]); Index ++ ) {
        if( NULL == Table[Index].Array ) continue;

        Error = DhcpRegGetNextHdl(Hdl, Table[Index].Location, &Hdl2);
        if( ERROR_SUCCESS != Error ) return Error;

        Error = DhcpRegFillSubKeys(&Hdl2, Table[Index].Array);
        LocalError = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == LocalError);

        if( ERROR_SUCCESS != Error ) return Error;
    }

    // Now read the exclusions from off here
    return DhcpRegSubnetGetExclusions(Hdl, Excl, ExclSizeInBytes );
}

//BeginExport(function)
DWORD
DhcpRegSScopeGetList(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Subnets
) //EndExport(function)
{
    return DhcpRegFillSubKeys(Hdl, Subnets);
}

//BeginExport(function)
DWORD
DhcpRegReservationGetList(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Options
) //EndExport(function)
{
    return DhcpRegFillSubKeys(Hdl, Options);
}

//BeginExport(comment)
//================================================================================
//  the separate stuff are here -- these are not list stuff, but just simple
//  single valued attributes
//  some of these actually, dont even go to the registry, but that's fine alright?
//================================================================================
//EndExport(comment)

//BeginExport(function)
DWORD
DhcpRegServerGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags
    // more attributes will come here soon?
) //EndExport(function)
{
    if( Name ) *Name = NULL;
    if( Comment ) *Comment = NULL;
    if( Flags ) *Flags = 0;

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRegSubnetGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     DWORD                 *Address,
    OUT     DWORD                 *Mask
) //EndExport(function)
{
    DWORD                          fSwitched;

    if( Name )  *Name = DhcpRegRead(Hdl, REG_SZ, REG_SUBNET_NAME, NULL);
    if( Comment ) *Comment = DhcpRegRead(Hdl, REG_SZ, REG_SUBNET_COMMENT, NULL);
    if( Flags ) {
        *Flags = PtrToUlong(DhcpRegRead(Hdl, REG_DWORD, REG_SUBNET_STATE, (LPVOID)REG_DEFAULT_SUBNET_STATE));
        fSwitched = PtrToUlong(DhcpRegRead(Hdl, REG_DWORD, REG_SUBNET_SWITCHED_FLAG, (LPVOID)REG_DEFAULT_SWITCHED_FLAG));
        if(fSwitched) SWITCHED(*Flags);
    }
    if( Address )
        *Address = PtrToUlong(DhcpRegRead(Hdl, REG_DWORD, REG_SUBNET_ADDRESS, (LPVOID)0));
    if( Mask ) *Mask = PtrToUlong(DhcpRegRead(Hdl, REG_DWORD, REG_SUBNET_MASK, ULongToPtr(REG_DEFAULT_SUBNET_MASK)));

    return ERROR_SUCCESS;
}

typedef struct {
    LPVOID                     RetPtr;
    LPWSTR                     ValueName;
    DWORD                      ValueType;
    LPVOID                     Defaults;
} ATTRIB_TBL, *PATTRIB_TBL, *LPATTRIB_TBL;

VOID
DhcpRegFillAttribTable(
    IN      PREG_HANDLE            Hdl,
    IN      PATTRIB_TBL            Table,
    IN      DWORD                  TableSize
) {
    DWORD                          i;
    PVOID                          Tmp;
    
    for( i = 0; i < TableSize ; i ++ ) {
        if( NULL == Table[i].RetPtr) continue;
        Tmp = DhcpRegRead(
            Hdl,
            Table[i].ValueType,
            Table[i].ValueName,
            Table[i].Defaults
        );
        if( REG_DWORD == Table[i].ValueType ) {
            *((DWORD *)Table[i].RetPtr) = PtrToUlong(Tmp);
        } else {
            *((LPVOID *)Table[i].RetPtr) = Tmp;
        }
    }
}

//
// Hack O Rama -- This routine returns ERROR_INVALID_DATA if 
// the registry has been upgraded from pre-win2k build to win2k.
// So that defaults can be chosen for ScopeId etc.
//
//BeginExport(function)
DWORD
DhcpRegMScopeGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Comments,
    OUT     DWORD                 *State,
    OUT     DWORD                 *ScopeId,
    OUT     DWORD                 *Policy,
    OUT     DWORD                 *TTL,
    OUT     LPWSTR                *LangTag,
    OUT     PDATE_TIME            *ExpiryTime
) //EndExport(function)
{
    DATE_TIME                      DefaultExpiryTime = {DHCP_DATE_TIME_INFINIT_LOW, DHCP_DATE_TIME_INFINIT_HIGH};
    LPWSTR                         DefaultLangTag = L"en-US";
    DWORD                          ScopeIdFake1, ScopeIdFake2;

    ATTRIB_TBL                     Table[] = {
        Comments,                  REG_MSCOPE_COMMENT,          REG_SZ,        NULL,
        State,                     REG_MSCOPE_STATE,            REG_DWORD,     (LPVOID)0,
        ScopeId,                   REG_MSCOPE_SCOPEID,          REG_DWORD,     (LPVOID)0,
        &ScopeIdFake1,             REG_MSCOPE_SCOPEID,          REG_DWORD,     (LPVOID)1,
        &ScopeIdFake2,             REG_MSCOPE_SCOPEID,          REG_DWORD,     (LPVOID)2,
        Policy,                    REG_MSCOPE_ADDR_POLICY,      REG_DWORD,     (LPVOID)0,
        TTL,                       REG_MSCOPE_TTL,              REG_DWORD,     (LPVOID)DEFAULT_MCAST_TTL,
        LangTag,                   REG_MSCOPE_LANG_TAG,         REG_SZ,        (LPVOID)0,
        ExpiryTime,                REG_MSCOPE_EXPIRY_TIME,      REG_BINARY,    (LPVOID)0
    };
    DhcpRegFillAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
    if (*LangTag == 0) {
        *LangTag = MemAlloc(wcslen((DefaultLangTag)+1)*sizeof(WCHAR));
        if (*LangTag) {
            wcscpy(*LangTag, DefaultLangTag);
        } else {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    if (*ExpiryTime == 0) {
        *ExpiryTime = MemAlloc(sizeof (DefaultExpiryTime));
        if (*ExpiryTime) {
            **ExpiryTime = DefaultExpiryTime;
        } else {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

    }

    if( ScopeIdFake1 != ScopeIdFake2 ) {
        Require(ScopeIdFake1 == 1 && ScopeIdFake2 == 2);
        //
        // Basically no value for ScopeId in the registry.  return a warning.
        // such as ERROR_INVALID_DATA.
        //
        return ERROR_INVALID_DATA;
    }

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRegOptDefGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comments,
    OUT     DWORD                 *Flags,
    OUT     DWORD                 *OptionId,
    OUT     LPWSTR                *ClassName,
    OUT     LPWSTR                *VendorName,
    OUT     LPBYTE                *Value,
    OUT     DWORD                 *ValueSize
) //EndExport(function)
{
    DWORD                          Error;
    ATTRIB_TBL                     Table[] = {
        Name,                      REG_OPTION_NAME,       REG_SZ,         NULL,
        Comments,                  REG_OPTION_COMMENT,    REG_SZ,         NULL,
        ClassName,                 REG_OPTION_CLASSNAME,  REG_SZ,         NULL,
        VendorName,                REG_OPTION_VENDORNAME, REG_SZ,         NULL,
        Flags,                     REG_OPTION_TYPE,       REG_DWORD,      (LPVOID)0,
        OptionId,                  REG_OPTION_ID,         REG_DWORD,      (LPVOID)0
    };

    DhcpRegFillAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
    if( Value ) {
        Error = DhcpRegReadBinary(Hdl, REG_OPTION_VALUE, Value, ValueSize);
        Require(*Value);
    }
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRegSScopeGetAttributes(                       // superscopes dont have any information stored.. dont use this
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags
) //EndExport(function)
{
    Require(FALSE);
    return ERROR_INVALID_PARAMETER;
}

//BeginExport(function)
DWORD
DhcpRegClassDefGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     LPBYTE                *Value,
    OUT     DWORD                 *ValueSize
) //EndExport(function)
{
    DWORD                          Error;
    ATTRIB_TBL                     Table[] = {
        Name,                      REG_CLASSDEF_NAME,     REG_SZ,       NULL,
        Comment,                   REG_CLASSDEF_COMMENT,  REG_SZ,       NULL,
        Flags,                     REG_CLASSDEF_TYPE,     REG_DWORD,    (LPVOID)0
    };

    DhcpRegFillAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
    if( Value ) {
        Error = DhcpRegReadBinary(Hdl, REG_CLASSDEF_VALUE, Value, ValueSize);
        Require(*Value);
    }
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRegSubnetServerGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     DWORD                 *Address,
    OUT     DWORD                 *Role
) //EndExport(function)
{
    ATTRIB_TBL                     Table[] = {
        Name,                      REG_SUB_SERVER_NAME,   REG_SZ,       NULL,
        Comment,                   REG_SUB_SERVER_COMMENT,REG_SZ,       NULL,
        Flags,                     REG_FLAGS,             REG_DWORD,    (LPVOID)0,
        Address,                   REG_SUB_SERVER_ADDRESS,REG_DWORD,    (LPVOID)0,
        Role,                      REG_SUB_SERVER_ROLE,   REG_DWORD,    (LPVOID)0
    };

    DhcpRegFillAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRegRangeGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     ULONG                 *AllocCount,
    OUT     ULONG                 *MaxAllocCount,
    OUT     DWORD                 *StartAddress,
    OUT     DWORD                 *EndAddress,
    OUT     LPBYTE                *InUseClusters,
    OUT     DWORD                 *InUseClusterSize,
    OUT     LPBYTE                *UsedClusters,
    OUT     DWORD                 *UsedClustersSize
) //EndExport(function)
{
    DWORD                          Error;
    ATTRIB_TBL                     Table[] = {
        Name,                      REG_RANGE_NAME,        REG_SZ,       NULL,
        Comment,                   REG_RANGE_COMMENT,     REG_SZ,       NULL,
        Flags,                     REG_RANGE_FLAGS,       REG_DWORD,    (LPVOID)(DEF_RANGE_FLAG_VAL),
        AllocCount,                REG_RANGE_ALLOC,       REG_DWORD,    (LPVOID)(DEF_RANGE_ALLOC),
        MaxAllocCount,             REG_RANGE_MAX_ALLOC,   REG_DWORD,    (LPVOID)(ULONG_PTR)(DEF_RANGE_MAX_ALLOC),
        StartAddress,              REG_RANGE_START_ADDRESS, REG_DWORD,  (LPVOID)0,
        EndAddress,                REG_RANGE_END_ADDRESS, REG_DWORD,    (LPVOID)0
    };

    DhcpRegFillAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
    if( InUseClusters ) {
        Error = DhcpRegReadBinary(Hdl, REG_RANGE_INUSE_CLUSTERS, InUseClusters, InUseClusterSize);
        //Require(ERROR_SUCCESS == Error); //-- after registry changed, NO_SUCH_FILE could come up here as well.
    }
    if( UsedClusters ) {
        Error = DhcpRegReadBinary(Hdl, REG_RANGE_USED_CLUSTERS, UsedClusters, UsedClustersSize);
        //Require(ERROR_SUCCESS == Error); //-- after registry changed, NO_SUCH_FILE could come up here as well.
    }
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRegReservationGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     DWORD                 *Address,
    OUT     LPBYTE                *ClientUID,
    OUT     DWORD                 *ClientUIDSize
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          deftype = DEF_RESERVATION_TYPE;
    ATTRIB_TBL                     Table[] = {
        Name,                      REG_RESERVATION_NAME,  REG_SZ,       NULL,
        Comment,                   REG_RESERVATION_COMMENT, REG_SZ,     NULL,
        Flags,                     REG_RESERVATION_TYPE,  REG_DWORD,    ULongToPtr(deftype),
        Address,                   REG_RESERVATION_ADDRESS, REG_DWORD,  (LPVOID)0,
    };

    DhcpRegFillAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
    if( ClientUID ) {
        Error = DhcpRegReadBinary(Hdl, REG_RESERVATION_UID, ClientUID, ClientUIDSize);
        Require(ERROR_SUCCESS == Error);
    }
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRegOptGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     DWORD                 *OptionId,
    OUT     LPWSTR                *ClassName,
    OUT     LPWSTR                *VendorName,
    OUT     DWORD                 *Flags,
    OUT     LPBYTE                *Value,
    OUT     DWORD                 *ValueSize
) //EndExport(function)
{
    DWORD                          Error;
    ATTRIB_TBL                     Table[] = {
        OptionId,                  REG_OPTION_ID,         REG_DWORD,    (LPVOID)0,
        ClassName,                 REG_OPTION_CLASSNAME,  REG_SZ,       NULL,
        VendorName,                REG_OPTION_VENDORNAME, REG_SZ,       NULL,
        Flags,                     REG_OPTION_TYPE,       REG_DWORD,    (LPVOID)0,
    };

    DhcpRegFillAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
    if( Value ) {
        Error = DhcpRegReadBinary(Hdl, REG_OPTION_VALUE, Value, ValueSize);
    }
    return ERROR_SUCCESS;
}

//BeginExport(comment)
//================================================================================
//  the following functiosn help in writing to the registry
//================================================================================
//EndExport(comment)

typedef struct {
    LPVOID                         Value;
    DWORD                          Size;
    DWORD                          Type;
    LPWSTR                         ValueName;
} WATTRIB_TBL, *PWATTRIB_TBL, *LPWATTRIB_TBL;

DWORD
DhcpRegSaveAttribTable(
    IN      PREG_HANDLE            Hdl,
    IN      PWATTRIB_TBL           Table,
    IN      DWORD                  Size
)
{
    DWORD                          i;
    DWORD                          Error;
    DWORD                          PtrSize;
    LPBYTE                         Ptr;

    for(i = 0; i < Size; i ++ ) {
        if( NULL == Table[i].Value ) continue;
        PtrSize = Table[i].Size;
        Ptr = *(LPBYTE *)Table[i].Value;
        switch(Table[i].Type) {
        case REG_SZ:
            if( NULL == *(LPWSTR *)Table[i].Value) { PtrSize = sizeof(WCHAR); Ptr = (LPBYTE)L""; break; }
            PtrSize = sizeof(WCHAR)*(wcslen(*((LPWSTR *)Table[i].Value))+1);
            Ptr = *(LPBYTE *)Table[i].Value;
            break;
        case REG_DWORD:
            PtrSize = sizeof(DWORD);
            Ptr =  Table[i].Value;                // This is because we deref this ptr down below..
            break;
        }

        Error = RegSetValueEx(
            Hdl->Key,
            Table[i].ValueName,
            ZeroReserved,
            Table[i].Type,
            Ptr,
            PtrSize
        );
        if( ERROR_SUCCESS != Error ) {
            return Error;
        }
    }
    return ERROR_SUCCESS;
}

//BeginExport(functions)
DWORD
DhcpRegSaveSubKeys(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Array
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    REG_HANDLE                     Hdl2;
    LPWSTR                         KeyName;

    Error = MemArrayInitLoc(Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(Array, &Loc, (LPVOID *)&KeyName);
        Require(ERROR_SUCCESS == Error && NULL != KeyName);

        Error = DhcpRegGetNextHdl(Hdl, KeyName, &Hdl2);
        if( ERROR_SUCCESS != Error ) return Error;

        Error = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayNextLoc(Array, &Loc);
    }
    return ERROR_SUCCESS;
}

//BeginExport(functions)
DWORD
DhcpRegSaveSubKeysPrefixed(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Array,
    IN      LPWSTR                 CommonPrefix
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    REG_HANDLE                     Hdl2;
    LPWSTR                         KeyName;

    Error = MemArrayInitLoc(Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(Array, &Loc, (LPVOID *)&KeyName);
        Require(ERROR_SUCCESS == Error && NULL != KeyName);

        Error = DhcpRegGetNextNextHdl(Hdl, CommonPrefix, KeyName, &Hdl2);
        if( ERROR_SUCCESS != Error ) return Error;

        Error = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayNextLoc(Array, &Loc);
    }
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRegServerSetList(
    IN      PREG_HANDLE            Hdl,
    IN      PARRAY                 OptList,       // list of LPWSTR options
    IN      PARRAY                 OptDefList,    // list of LPWSTR optdefs
    IN      PARRAY                 Subnets,       // list of LPWSTR subnets
    IN      PARRAY                 SScopes,       // list of LPWSTR sscopes
    IN      PARRAY                 ClassDefs,     // list of LPWSTR classes
    IN      PARRAY                 MScopes        // list of LPWSTR mscopes
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          LocalError;
    DWORD                          Index;
    REG_HANDLE                     Hdl2;
    struct {
        PARRAY                     Array;
        LPWSTR                     Location;
    } Table[] = {
        OptList,                   REG_SERVER_GLOBAL_OPTIONS,
        OptDefList,                REG_SERVER_OPTDEFS,
        Subnets,                   REG_SERVER_SUBNETS,
        SScopes,                   REG_SERVER_SSCOPES,
        ClassDefs,                 REG_SERVER_CLASSDEFS,
        MScopes,                   REG_SERVER_MSCOPES
    };

    for( Index = 0; Index < sizeof(Table)/sizeof(Table[0]); Index ++ ) {
        if( NULL == Table[Index].Array ) continue;

        Error = DhcpRegGetNextHdl(Hdl, Table[Index].Location, &Hdl2);
        if( ERROR_SUCCESS != Error ) return Error;

        Error = DhcpRegSaveSubKeys(&Hdl2, Table[Index].Array);
        LocalError = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == LocalError);

        if( ERROR_SUCCESS != Error ) return Error;
    }

    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSubnetSetExclusions(
    IN      PREG_HANDLE            Hdl,
    IN      LPBYTE                *Excl,
    IN      DWORD                  ExclSize
) //EndExport(function)
{
    DWORD                          Error;
    WATTRIB_TBL                    Table[] = {
        (LPVOID*)Excl,  ExclSize, REG_BINARY, REG_SUBNET_EXCL,
    };

    return DhcpRegSaveAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
}

//BeginExport(function)
DWORD
DhcpRegSubnetSetList(
    IN      PREG_HANDLE            Hdl,
    IN      PARRAY                 Servers,
    IN      PARRAY                 IpRanges,
    IN      PARRAY                 Reservations,
    IN      PARRAY                 Options,
    IN      LPBYTE                *Excl,
    IN      DWORD                  ExclSizeInBytes
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          LocalError;
    DWORD                          Index;
    REG_HANDLE                     Hdl2;
    struct {
        PARRAY                     Array;
        LPWSTR                     Location;
    } Table[] = {
        Servers,                   REG_SUBNET_SERVERS,
        IpRanges,                  REG_SUBNET_RANGES,
        Reservations,              REG_SUBNET_RESERVATIONS,
        Options,                   REG_SUBNET_OPTIONS,
        // Exclusions are to be handled a bit differently
    };

    for( Index = 0; Index < sizeof(Table)/sizeof(Table[0]); Index ++ ) {
        if( NULL == Table[Index].Array ) continue;

        Error = DhcpRegGetNextHdl(Hdl, Table[Index].Location, &Hdl2);
        if( ERROR_SUCCESS != Error ) return Error;

        Error = DhcpRegSaveSubKeys(&Hdl2, Table[Index].Array);
        LocalError = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == LocalError);

        if( ERROR_SUCCESS != Error ) return Error;
    }

    // Now read the exclusions from off here
    return DhcpRegSubnetSetExclusions(Hdl, Excl, ExclSizeInBytes );
}

//BeginExport(function)
DWORD
DhcpRegSScopeSetList(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Subnets
) //EndExport(function)
{
    return DhcpRegSaveSubKeys(Hdl, Subnets);
}

//BeginExport(function)
DWORD
DhcpRegReservationSetList(
    IN      PREG_HANDLE            Hdl,
    IN      PARRAY                 Subnets
) //EndExport(function)
{
    return DhcpRegSaveSubKeys(Hdl, Subnets);
}

//BeginExport(comment)
//================================================================================
//  the single stuff are here -- these are not list stuff, but just simple
//  single valued attributes
//  some of these actually, dont even go to the registry, but that's fine alright?
//================================================================================
//EndExport(comment)

//BeginExport(function)
DWORD
DhcpRegServerSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags
    // more attributes will come here soon?
) //EndExport(function)
{
#if 0
    WATTRIB_TBL                    Table[] = {
        Name,    REG_SERVER_NAME
    }
    if( Name ) *Name = NULL;
    if( Comment ) *Comment = NULL;
    if( Flags ) *Flags = 0;
#endif

    return ERROR_SUCCESS;
}

DWORD
DhcpRegSubnetSetAttributesInternal(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      DWORD                 *Address,
    IN      DWORD                 *Mask,
    IN      DWORD                 *SwitchedNetwork
)
{
    DWORD                          Error, SrvIpAddress, SrvRole;
    LPWSTR                         EmptyString;
    REG_HANDLE                     Hdl2;
    WATTRIB_TBL                    Table[] = {
        Name,            0,        REG_SZ,        REG_SUBNET_NAME,
        Comment,         0,        REG_SZ,        REG_SUBNET_COMMENT,
        Flags,           0,        REG_DWORD,     REG_SUBNET_STATE,
        Address,         0,        REG_DWORD,     REG_SUBNET_ADDRESS,
        Mask,            0,        REG_DWORD,     REG_SUBNET_MASK,
        SwitchedNetwork, 0,        REG_DWORD,     REG_SUBNET_SWITCHED_FLAG
    };

    Error = DhcpRegSaveAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
    if( NO_ERROR != Error ) return Error;

    //
    // The following lines are for backward compat with NT4.
    //
    
    //
    // Create the reservation key in any case
    //

    Error = DhcpRegGetNextHdl(
        Hdl, REG_SUBNET_RESERVATIONS, &Hdl2 );
    if( NO_ERROR != Error ) return Error;

    DhcpRegCloseHdl( &Hdl2 );

    //
    // Create the servers key
    //

    Error = DhcpRegGetNextHdl(
        Hdl, L"DHCPServers", &Hdl2 );
    if( NO_ERROR != Error ) return Error;
    DhcpRegCloseHdl( &Hdl2 );

    Error = DhcpRegGetNextNextHdl(
        Hdl, L"DHCPServers", L"127.0.0.1", &Hdl2 );
    if( NO_ERROR != Error ) return Error;

    //
    // Now set the role of the newly created server as primary
    //
    SrvIpAddress = INADDR_LOOPBACK;
    SrvRole = 1; // primary
    EmptyString = L"";
    {
        WATTRIB_TBL SrvTable[] = {
            &SrvRole,  0, REG_DWORD, L"Role",
            &SrvIpAddress, 0, REG_DWORD, L"ServerIpAddress",
            &EmptyString, 0, REG_SZ, L"ServerHostName",
            &EmptyString, 0, REG_SZ, L"ServerNetBiosName"
        };

        Error = DhcpRegSaveAttribTable(
            &Hdl2, SrvTable, sizeof(SrvTable)/sizeof(SrvTable[0]));
    }

    DhcpRegCloseHdl(&Hdl2);
    return Error;
}

//BeginExport(function)
DWORD
DhcpRegSubnetSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      DWORD                 *Address,
    IN      DWORD                 *Mask
) //EndExport(function)
{
    DWORD xFlags, SwitchedNetwork = FALSE;
    OSVERSIONINFO Ver;

    Ver.dwOSVersionInfoSize = sizeof(Ver);
    if( FALSE == GetVersionEx(&Ver) ) return GetLastError();

    if( Flags && Ver.dwMajorVersion < 5 ) {
        SwitchedNetwork = IS_SWITCHED(*Flags);
        xFlags = IS_DISABLED(*Flags);
        Flags = &xFlags;
    }
    
    return DhcpRegSubnetSetAttributesInternal(
        Hdl, Name, Comment, Flags, Address, Mask,
        Flags ? &SwitchedNetwork : NULL );
}

//BeginExport(function)
DWORD
DhcpRegMScopeSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Comments,
    IN      DWORD                 *State,
    IN      DWORD                 *ScopeId,
    IN      DWORD                 *Policy,
    IN      DWORD                 *TTL,
    IN      LPWSTR                *LangTag,
    IN      PDATE_TIME             *ExpiryTime
) //EndExport(function)
{
    WATTRIB_TBL                    Table[] = {
        Comments,        0,        REG_SZ,          REG_MSCOPE_COMMENT,
        State,           0,        REG_DWORD,       REG_MSCOPE_STATE,
        ScopeId,         0,        REG_DWORD,       REG_MSCOPE_SCOPEID,
        Policy,          0,        REG_DWORD,       REG_MSCOPE_ADDR_POLICY,
        TTL,             0,        REG_DWORD,       REG_MSCOPE_TTL,
        LangTag,         0,        REG_SZ,          REG_MSCOPE_LANG_TAG,
        ExpiryTime,      sizeof(**ExpiryTime),   REG_BINARY,      REG_MSCOPE_EXPIRY_TIME
    };
    return DhcpRegSaveAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
}

//BeginExport(function)
DWORD
DhcpRegOptDefSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comments,
    IN      DWORD                 *Flags,
    IN      DWORD                 *OptionId,
    IN      LPWSTR                *ClassName,
    IN      LPWSTR                *VendorName,
    IN      LPBYTE                *Value,
    IN      DWORD                  ValueSize
) //EndExport(function)
{
    DWORD                          Error;
    WATTRIB_TBL                    Table[] = {
        Name,            0,        REG_SZ,           REG_OPTION_NAME,
        Comments,        0,        REG_SZ,           REG_OPTION_COMMENT,
        ClassName,       0,        REG_SZ,           REG_OPTION_CLASSNAME,
        VendorName,      0,        REG_SZ,           REG_OPTION_VENDORNAME,
        Flags,           0,        REG_DWORD,        REG_OPTION_TYPE,
        OptionId,        0,        REG_DWORD,        REG_OPTION_ID,
        Value,           ValueSize,REG_BINARY,       REG_OPTION_VALUE
    };

    return DhcpRegSaveAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
}

//BeginExport(function)
DWORD
DhcpRegSScopeSetAttributes(                       // superscopes dont have any information stored.. dont use this
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags
) //EndExport(function)
{
    Require(FALSE);
    return ERROR_INVALID_PARAMETER;
}

//BeginExport(function)
DWORD
DhcpRegClassDefSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      LPBYTE                *Value,
    IN      DWORD                  ValueSize
) //EndExport(function)
{
    DWORD                          Error;
    WATTRIB_TBL                    Table[] = {
        Name,            0,        REG_SZ,           REG_CLASSDEF_NAME,
        Comment,         0,        REG_SZ,           REG_CLASSDEF_COMMENT,
        Flags,           0,        REG_DWORD,        REG_CLASSDEF_TYPE,
        Value,           ValueSize,REG_BINARY,       REG_CLASSDEF_VALUE
    };

    return DhcpRegSaveAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
}

//BeginExport(function)
DWORD
DhcpRegSubnetServerSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      DWORD                 *Address,
    IN      DWORD                 *Role
) //EndExport(function)
{
    WATTRIB_TBL                    Table[] = {
        Name,            0,        REG_SZ,           REG_SUB_SERVER_NAME,
        Comment,         0,        REG_SZ,           REG_SUB_SERVER_COMMENT,
        Flags,           0,        REG_DWORD,        REG_FLAGS,
        Address,         0,        REG_DWORD,        REG_SUB_SERVER_ADDRESS,
        Role,            0,        REG_DWORD,        REG_SUB_SERVER_ROLE,
    };

    return DhcpRegSaveAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
}

//BeginExport(function)
DWORD
DhcpRegRangeSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      ULONG                 *AllocCount,
    IN      ULONG                 *MaxAllocCount,
    IN      DWORD                 *StartAddress,
    IN      DWORD                 *EndAddress,
    IN      LPBYTE                *InUseClusters,
    IN      DWORD                  InUseClusterSize,
    IN      LPBYTE                *UsedClusters,
    IN      DWORD                  UsedClustersSize
) //EndExport(function)
{
    DWORD                          Error;
    WATTRIB_TBL                     Table[] = {
        Name,            0,        REG_SZ,           REG_RANGE_NAME,
        Comment,         0,        REG_SZ,           REG_RANGE_COMMENT,
        Flags,           0,        REG_DWORD,        REG_RANGE_FLAGS,
        AllocCount,      0,        REG_DWORD,        REG_RANGE_ALLOC,
        MaxAllocCount,   0,        REG_DWORD,        REG_RANGE_MAX_ALLOC,
        StartAddress,    0,        REG_DWORD,        REG_RANGE_START_ADDRESS,
        EndAddress,      0,        REG_DWORD,        REG_RANGE_END_ADDRESS,
        InUseClusters,   InUseClusterSize, REG_BINARY, REG_RANGE_INUSE_CLUSTERS,
        UsedClusters,    UsedClustersSize, REG_BINARY, REG_RANGE_USED_CLUSTERS,
    };

    return DhcpRegSaveAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
}

//BeginExport(function)
DWORD
DhcpRegReservationSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      DWORD                 *Address,
    IN      LPBYTE                *ClientUID,
    IN      DWORD                  ClientUIDSize
) //EndExport(function)
{
    DWORD                          Error;
    WATTRIB_TBL                    Table[] = {
        Name,            0,        REG_SZ,           REG_RESERVATION_NAME,
        Comment,         0,        REG_SZ,           REG_RESERVATION_COMMENT,
        Flags,           0,        REG_DWORD,        REG_RESERVATION_TYPE,
        Address,         0,        REG_DWORD,        REG_RESERVATION_ADDRESS,
        ClientUID,       ClientUIDSize, REG_BINARY,  REG_RESERVATION_UID,
    };

    return DhcpRegSaveAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
}

//BeginExport(function)
DWORD
DhcpRegOptSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      DWORD                 *OptionId,
    IN      LPWSTR                *ClassName,
    IN      LPWSTR                *VendorName,
    IN      DWORD                 *Flags,
    IN      LPBYTE                *Value,
    IN      DWORD                  ValueSize
) //EndExport(function)
{
    DWORD                          Error;
    WATTRIB_TBL                    Table[] = {
        OptionId,        0,        REG_DWORD,        REG_OPTION_ID,
        ClassName,       0,        REG_SZ,           REG_OPTION_CLASSNAME,
        VendorName,      0,        REG_SZ,           REG_OPTION_VENDORNAME,
        Flags,           0,        REG_DWORD,        REG_OPTION_TYPE,
        Value,           ValueSize,REG_BINARY,       REG_OPTION_VALUE,
    };

    return DhcpRegSaveAttribTable(Hdl, Table, sizeof(Table)/sizeof(Table[0]));
}

//================================================================================
//  recursive deleting of keys...
//================================================================================

//BeginExport(function)
DWORD
DhcpRegRecurseDelete(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 KeyName
) //EndExport(function)
{
    REG_HANDLE                     Hdl2;
    DWORD                          Error;
    DWORD                          LocalError, RetError;
    ARRAY                          Array;         // sub keys
    ARRAY_LOCATION                 Loc;
    LPWSTR                         SubKey;

    RetError = ERROR_SUCCESS;

    Error = DhcpRegGetNextHdl(Hdl, KeyName, &Hdl2);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemArrayInit(&Array);
    if( ERROR_SUCCESS != Error ) {
        LocalError = DhcpRegCloseHdl(&Hdl2);
        Require(ERROR_SUCCESS == LocalError);
        return Error;
    }

    Error = DhcpRegFillSubKeys(&Hdl2, &Array);
    Require( ERROR_SUCCESS == Error );

    Error = MemArrayInitLoc(&Array, &Loc);
    while(ERROR_FILE_NOT_FOUND != Error) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&Array, &Loc, (LPVOID *)&SubKey);
        Require(ERROR_SUCCESS == Error && SubKey);

        Error = DhcpRegRecurseDelete(&Hdl2, SubKey);
        if( ERROR_SUCCESS != Error ) RetError = Error;

        if( SubKey ) MemFree(SubKey);

        Error = MemArrayNextLoc(&Array, &Loc);
    }

    Error = MemArrayCleanup(&Array);
    Require(ERROR_SUCCESS == Error);

    Error = DhcpRegCloseHdl(&Hdl2);
    Require(ERROR_SUCCESS == Error);

    Error = RegDeleteKey(Hdl->Key, KeyName);
    if( ERROR_SUCCESS != Error ) RetError = Error;

    return RetError;
}

//BeginExport(function)
DWORD
DhcpRegRecurseDeleteBunch(
    IN      PREG_HANDLE            Hdl,
    IN      PARRAY                 KeysArray
) //EndExport(function)
{
    ARRAY_LOCATION                 Loc;
    LPWSTR                         ThisKeyName;
    DWORD                          Error;

    Error = MemArrayInitLoc(KeysArray, &Loc);
    while( ERROR_FILE_NOT_FOUND != Error ) {
        Require(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(KeysArray, &Loc, &ThisKeyName);
        Require(ERROR_SUCCESS == Error && NULL != ThisKeyName);

        Error = DhcpRegRecurseDelete(Hdl, ThisKeyName);
        if( ERROR_SUCCESS != Error ) return Error;

        Error = MemArrayNextLoc(KeysArray, &Loc);
    }

    return ERROR_SUCCESS;
}

static
VOID
GetLocalFileTime(                                 // fill in filetime struct w/ current local time
    IN OUT  LPFILETIME             Time           // struct to fill in
)
{
    BOOL                           Status;
    SYSTEMTIME                     SysTime;

    GetSystemTime(&SysTime);                      // get sys time as UTC time.
    Status = SystemTimeToFileTime(&SysTime,Time); // conver system time to file time
    if( FALSE == Status ) {                       // convert failed?
        Time->dwLowDateTime = 0xFFFFFFFF;         // set time to weird value in case of failiure
        Time->dwHighDateTime = 0xFFFFFFFF;
    }
}

//BeginExport(function)
DWORD
DhcpRegUpdateTime(                                // update the last modified time
    VOID
)   //EndExport(function)
{
    FILETIME                       Time;
    DWORD                          Err, Size;
    HKEY                           hKey;

    GetLocalFileTime(&Time);                      // first get current time
    (*(LONGLONG *)&Time) += 10*1000*60*2;         // 2 minutes (Filetime is in 100-nano seconds)
    // HACK! the previous line is there as the DS takes a little while to update the
    // last changed time..
    Time.dwLowDateTime =Time.dwHighDateTime =0;   // set time to "long back" initially
    Err = RegOpenKeyEx                            // try to open the config key.
    (
        /* hKey                 */ HKEY_LOCAL_MACHINE,
        /* lpSubKey             */ REG_THIS_SERVER,
        /* ulOptions            */ 0 /* Reserved */ ,
        /* samDesired           */ KEY_ALL_ACCESS,
        /* phkResult            */ &hKey
    );
    if( ERROR_SUCCESS != Err ) return Err;        // time is still set to ages back

    Err = RegSetValueEx                           // now save the time value
    (
        /* hKey                 */ hKey,
        /* lpValueName          */ DHCP_LAST_DOWNLOAD_TIME_VALUE,
        /* lpReserved           */ 0,
        /* lpType               */ REG_BINARY,
        /* lpData               */ (LPBYTE)&Time,
        /* lpcData              */ sizeof(Time)
    );
    RegCloseKey(hKey);                            // close key before we forget

    return Err;
}


//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mmreg\regsave.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This file has been generated. Pl look at the .c file
//========================================================================

DWORD
DhcpRegSaveOptDef(
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      DWORD                  OptType,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptLen
) ;


DWORD
DhcpRegDeleteOptDef(
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) ;


DWORD
DhcpRegSaveGlobalOption(
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPBYTE                 Value,
    IN      DWORD                  ValueSize
) ;


DWORD
DhcpRegDeleteGlobalOption(
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) ;


DWORD
DhcpRegSaveSubnetOption(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPBYTE                 Value,
    IN      DWORD                  ValueSize
) ;


DWORD
DhcpRegDeleteSubnetOption(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) ;


DWORD
DhcpRegSaveReservedOption(
    IN      DWORD                  Address,
    IN      DWORD                  ReservedAddress,
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPBYTE                 Value,
    IN      DWORD                  ValueSize
) ;


DWORD
DhcpRegDeleteReservedOption(
    IN      DWORD                  Address,
    IN      DWORD                  ReservedAddress,
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) ;


DWORD
DhcpRegSaveClassDef(
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      DWORD                  Flags,
    IN      LPBYTE                 Data,
    IN      DWORD                  DataLength
) ;


DWORD
DhcpRegDeleteClassDef(
    IN      LPWSTR                 Name
) ;


DWORD
DhcpRegSaveReservation(
    IN      DWORD                  Subnet,
    IN      DWORD                  Address,
    IN      DWORD                  Flags,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDLength
) ;


DWORD
DhcpRegDeleteReservation(
    IN      DWORD                  Subnet,
    IN      DWORD                  Address
) ;


DWORD
DhcpRegSScopeDeleteSubnet(
    IN      LPWSTR                 SScopeName,
    IN      DWORD                  SubnetAddress
) ;


DWORD
DhcpRegDelSubnetFromAllSScopes(
    IN      DWORD                  Address
) ;


DWORD
DhcpRegSScopeSaveSubnet(
    IN      LPWSTR                 SScopeName,
    IN      DWORD                  Address
) ;


DWORD
DhcpRegDeleteSScope(
    IN      LPWSTR                 SScopeName
) ;


DWORD
DhcpRegSaveSubnet(
    IN      DWORD                  SubnetAddress,
    IN      DWORD                  SubnetMask,
    IN      DWORD                  SubnetState,
    IN      LPWSTR                 SubnetName,
    IN      LPWSTR                 SubnetComment
) ;


DWORD
DhcpRegDeleteSubnet(
    IN      PM_SUBNET               Subnet
) ;


DWORD
DhcpRegAddRange(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress,
    IN      DWORD                  RangeEndAddress,
    IN      ULONG                  BootpAllocated,
    IN      ULONG                  MaxBootpAllowed,
    IN      DWORD                  Type
) ;


DWORD
DhcpRegAddRangeEx(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress,
    IN      DWORD                  RangeEndAddress,
    IN      DWORD                  Type,
    IN      ULONG                  BootpAllocated,
    IN      ULONG                  MaxBootpAllowed,
    IN      LPBYTE                 InUseClusters,
    IN      DWORD                  InUseClustersSize,
    IN      LPBYTE                 UsedClusters,
    IN      DWORD                  UsedClustersSize
) ;


DWORD
DhcpRegDeleteRange(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress
) ;


DWORD
DhcpRegDeleteRangeEx(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress,
    OUT     LPBYTE                *InUseClusters,
    OUT     DWORD                 *InUseClustersSize,
    OUT     LPBYTE                *UsedClusters,
    OUT     DWORD                 *UsedClustersSize
) ;


DWORD
DhcpRegSaveExcl(
    IN      PM_SUBNET              Subnet,
    IN      LPBYTE                 ExclBytes,
    IN      DWORD                  nBytes
) ;


DWORD
DhcpRegSaveBitMask(
    IN      PM_SUBNET              Subnet,
    IN      DWORD                  RangeStartAddress,
    IN      LPBYTE                 InUse,
    IN      DWORD                  InUseSize,
    IN      LPBYTE                 Used,
    IN      DWORD                  UsedSize
) ;


DWORD
DhcpRegSaveMScope(
    IN      DWORD                  MScopeId,
    IN      DWORD                  SubnetState,
    IN      DWORD                  AddressPolicy,
    IN      DWORD                  TTL,
    IN      LPWSTR                 pMScopeName,
    IN      LPWSTR                 pMScopeComment,
    IN      LPWSTR                 LangTag,
    IN      PDATE_TIME              ExpiryTime
) ;

//========================================================================
//  end of file
//========================================================================
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This file has been generated. Pl look at the .c file
//========================================================================

#define     FLUSH_MODIFIED_DIRTY   0
#define     FLUSH_MODIFIED         1
#define     FLUSH_ANYWAY           2


DWORD
FlushRanges(
    IN      PM_RANGE               Range,
    IN      DWORD                  FlushNow,
    IN      PM_SUBNET              Subnet
) ;


DWORD
DhcpRegServerFlush(
    IN      PM_SERVER              Server,
    IN      DWORD                  FlushNow
) ;


DWORD
DhcpRegFlushServer(
    IN      DWORD                  FlushNow
) ;


DWORD
DhcpRegServerSave(
    IN      PM_SERVER              Server
) ;

DWORD
DhcpMigrateMScopes(
    IN LPCWSTR OldMscopeName,
    IN LPCWSTR NewMscopeName, 
    IN DWORD (*SaveOrRestoreRoutine)(
        IN HKEY Key, IN LPWSTR ConfigName, IN BOOL fRestore
        )
    ) ;

//========================================================================
//  end of file
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mmreg\regutil.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This file has been generated. Pl look at the .c file
//========================================================================

typedef struct _REG_HANDLE {
    HKEY                           Key;
    HKEY                           SubKey;
    LPWSTR                         SubKeyLocation;
} REG_HANDLE, *PREG_HANDLE, *LPREG_HANDLE;


#define     REG_THIS_SERVER                       L"Software\\Microsoft\\DHCPServer\\Configuration"
#define     REG_THIS_SERVER_DS                    L"Software\\Microsoft\\DHCPServer\\Config_DS"
#define     REG_THIS_SERVER_DS_VALUE              L"Config_DS"
#define     REG_THIS_SERVER_DS_PARENT             L"Software\\Microsoft\\DHCPServer"

#define     REG_SERVER_GLOBAL_OPTIONS             L"GlobalOptionValues"
#define     REG_SERVER_OPTDEFS                    L"OptionInfo"
#define     REG_SERVER_SUBNETS                    L"Subnets"
#define     REG_SERVER_SSCOPES                    L"SuperScope"
#define     REG_SERVER_CLASSDEFS                  L"ClassDefs"
#define     REG_SERVER_MSCOPES                    L"MulticastScopes"

#define     REG_SUBNET_SERVERS                    L"DHCPServers"
#define     REG_SUBNET_RANGES                     L"IpRanges"
#define     REG_SUBNET_RESERVATIONS               L"ReservedIps"
#define     REG_SUBNET_OPTIONS                    L"SubnetOptions"

#define     REG_SUBNET_EXCL                       L"ExcludedIpRanges"
#define     REG_SUBNET_ADDRESS                    L"SubnetAddress"
#define     REG_SUBNET_NAME                       L"SubnetName"
#define     REG_SUBNET_COMMENT                    L"SubnetComment"
#define     REG_SUBNET_MASK                       L"SubnetMask"
#define     REG_SUBNET_STATE                      L"SubnetState"
#define     REG_SUBNET_SWITCHED_FLAG              L"SwitchedNetworkFlag"

#define     REG_MSCOPE_NAME                       L"MScopeName"
#define     REG_MSCOPE_COMMENT                    L"MScopeComment"
#define     REG_MSCOPE_SCOPEID                    L"MScopeIdValue"
#define     REG_MSCOPE_STATE                      L"MScopeState"
#define     REG_MSCOPE_ADDR_POLICY                L"MScopeAddressPolicy"
#define     REG_MSCOPE_TTL                        L"MScopeTTL"
#define     REG_MSCOPE_LANG_TAG                   L"MScopeLangTag"
#define     REG_MSCOPE_EXPIRY_TIME                L"MScopeExpiryTime"

#define     REG_SUB_SERVER_NAME                   L"ServerHostName"
#define     REG_SUB_SERVER_COMMENT                L"ServerComment"
#define     REG_SUB_SERVER_ADDRESS                L"ServerAddress"
#define     REG_SUB_SERVER_ROLE                   L"Role"

#define     REG_RANGE_NAME                        L"RangeName"
#define     REG_RANGE_COMMENT                     L"RangeComment"
#define     REG_RANGE_START_ADDRESS               L"StartAddress"
#define     REG_RANGE_END_ADDRESS                 L"EndAddress"
#define     REG_RANGE_INUSE_CLUSTERS              L"InUseClusters"
#define     REG_RANGE_USED_CLUSTERS               L"UsedClusters"
#define     REG_RANGE_BITS_PREFIX                 L"Bits "
#define     REG_RANGE_BITS_PREFIX_WCHAR_COUNT     (5)
#define     REG_RANGE_FLAGS                       L"RangeFlags"
#define     REG_RANGE_ALLOC                       L"RangeBootpAllocated"
#define     REG_RANGE_MAX_ALLOC                   L"RangeBootpMaxAllowed"

#define     REG_OPTION_NAME                       L"OptionName"
#define     REG_OPTION_COMMENT                    L"OptionComment"
#define     REG_OPTION_TYPE                       L"OptionType"
#define     REG_OPTION_VALUE                      L"OptionValue"
#define     REG_OPTION_ID                         L"OptionId"
#define     REG_OPTION_CLASSNAME                  L"OptionClassName"
#define     REG_OPTION_VENDORNAME                 L"OptionVendorName"

#define     REG_CLASSDEF_NAME                     L"ClassName"
#define     REG_CLASSDEF_COMMENT                  L"ClassComment"
#define     REG_CLASSDEF_TYPE                     L"ClassType"
#define     REG_CLASSDEF_VALUE                    L"ClassValue"

#define     REG_RESERVATION_ADDRESS               L"IpAddress"
#define     REG_RESERVATION_UID                   L"ClientUID"
#define     REG_RESERVATION_TYPE                  L"AllowedClientTypes"
#define     REG_RESERVATION_NAME                  L"ReservationName"
#define     REG_RESERVATION_COMMENT               L"ReservationComment"

#define     REG_FLAGS                             L"Flags"

#define     REG_ACCESS                            KEY_ALL_ACCESS
#define     REG_DEFAULT_SUBNET_STATE              0
#define     REG_DEFAULT_SUBNET_MASK               0xFFFFFFFF
#define     REG_DEFAULT_SWITCHED_FLAG             FALSE

#define     REG_CLASS                             L"DhcpClass"

#define DHCP_LAST_DOWNLOAD_TIME_VALUE             L"LastDownloadTime"
#define DHCP_LAST_DOWNLOAD_TIME_TYPE              REG_BINARY

#define     DEF_RANGE_ALLOC                       0
#define     DEF_RANGE_MAX_ALLOC                   (~(ULONG)0)



//================================================================================
//  The basic open/traverse/close functions are here
//================================================================================


DWORD
DhcpRegSetCurrentServer(
    IN OUT  PREG_HANDLE            Hdl
) ;


DWORD
DhcpRegGetThisServer(
    IN OUT  PREG_HANDLE            Hdl
) ;


DWORD
DhcpRegGetNextHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 NextLoc,
    OUT     PREG_HANDLE            OutHdl
) ;


DWORD
DhcpRegCloseHdl(
    IN OUT  PREG_HANDLE            Hdl
) ;


//================================================================================
//   MISC utilities for registry manipulation
//================================================================================


DWORD
DhcpRegFillSubKeys(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Array          // fill in a list of key names
) ;


LPVOID                                            // DWORD or LPWSTR or LPBYTE
DhcpRegRead(                                      // read differnt values from registry and allocate if not DWORD
    IN      PREG_HANDLE            Hdl,
    IN      DWORD                  Type,          // if DWORD dont allocate memory
    IN      LPWSTR                 ValueName,
    IN      LPVOID                 RetValue       // value to use if nothing found
) ;


DWORD
DhcpRegReadBinary(                                // read binary type
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 ValueName,
    OUT     LPBYTE                *RetVal,
    OUT     DWORD                 *RetValSize
) ;


LPWSTR
DhcpRegCombineClassAndOption(                     // create string based on class name and option id
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      DWORD                  OptionId
) ;


LPWSTR
ConvertAddressToLPWSTR(
    IN      DWORD                  Address,
    IN OUT  LPWSTR                 BufferStr      // input buffer to fill with dotted notation
) ;


//================================================================================
//  the following functions help traversing the registry
//================================================================================


DWORD
DhcpRegServerGetSubnetHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Subnet,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegServerGetSScopeHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 SScope,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegServerGetOptDefHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 OptDef,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegServerGetOptHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Opt,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegServerGetMScopeHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 MScope,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegServerGetClassDefHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 ClassDef,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegSubnetGetOptHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Opt,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegSubnetGetRangeHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Range,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegSubnetGetReservationHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Reservation,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegSubnetGetServerHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 Server,
    OUT     PREG_HANDLE            Hdl2
) ;


DWORD
DhcpRegReservationGetOptHdl(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 OptionName,
    OUT     PREG_HANDLE            Hdl2
) ;


//================================================================================
//   List retrieval functions.. for servers, subnets, ranges etc.
//================================================================================


DWORD
DhcpRegServerGetList(
    IN      PREG_HANDLE            Hdl,           // ptr to server location
    IN OUT  PARRAY                 OptList,       // list of LPWSTR options
    IN OUT  PARRAY                 OptDefList,    // list of LPWSTR optdefs
    IN OUT  PARRAY                 Subnets,       // list of LPWSTR subnets
    IN OUT  PARRAY                 SScopes,       // list of LPWSTR sscopes
    IN OUT  PARRAY                 ClassDefs,     // list of LPWSTR classes
    IN OUT  PARRAY                 MScopes        // list of LPWSTR mscopes
) ;


DWORD
DhcpRegSubnetGetExclusions(
    IN      PREG_HANDLE            Hdl,
    OUT     LPBYTE                *Excl,
    OUT     DWORD                 *ExclSize
) ;


DWORD
DhcpRegSubnetGetList(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Servers,
    IN OUT  PARRAY                 IpRanges,
    IN OUT  PARRAY                 Reservations,
    IN OUT  PARRAY                 Options,
    OUT     LPBYTE                *Excl,
    OUT     DWORD                 *ExclSizeInBytes
) ;


DWORD
DhcpRegSScopeGetList(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Subnets
) ;


DWORD
DhcpRegReservationGetList(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Options
) ;


//================================================================================
//  the separate stuff are here -- these are not list stuff, but just simple
//  single valued attributes
//  some of these actually, dont even go to the registry, but that's fine alright?
//================================================================================


DWORD
DhcpRegServerGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags
    // more attributes will come here soon?
) ;


DWORD
DhcpRegSubnetGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     DWORD                 *Address,
    OUT     DWORD                 *Mask
) ;


DWORD
DhcpRegMScopeGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Comments,
    OUT     DWORD                 *State,
    OUT     DWORD                 *ScopeId,
    OUT     DWORD                 *Policy,
    OUT     DWORD                 *TTL,
    OUT     LPWSTR                *LangTag,
    OUT     PDATE_TIME            *ExpiryTime
) ;


DWORD
DhcpRegOptDefGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comments,
    OUT     DWORD                 *Flags,
    OUT     DWORD                 *OptionId,
    OUT     LPWSTR                *ClassName,
    OUT     LPWSTR                *VendorName,
    OUT     LPBYTE                *Value,
    OUT     DWORD                 *ValueSize
) ;


DWORD
DhcpRegSScopeGetAttributes(                       // superscopes dont have any information stored.. dont use this
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags
) ;


DWORD
DhcpRegClassDefGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     LPBYTE                *Value,
    OUT     DWORD                 *ValueSize
) ;


DWORD
DhcpRegSubnetServerGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     DWORD                 *Address,
    OUT     DWORD                 *Role
) ;


DWORD
DhcpRegRangeGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     ULONG                 *AllocCount,
    OUT     ULONG                 *MaxAllocCount,
    OUT     DWORD                 *StartAddress,
    OUT     DWORD                 *EndAddress,
    OUT     LPBYTE                *InUseClusters,
    OUT     DWORD                 *InUseClusterSize,
    OUT     LPBYTE                *UsedClusters,
    OUT     DWORD                 *UsedClustersSize
) ;


DWORD
DhcpRegReservationGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *Flags,
    OUT     DWORD                 *Address,
    OUT     LPBYTE                *ClientUID,
    OUT     DWORD                 *ClientUIDSize
) ;


DWORD
DhcpRegOptGetAttributes(
    IN      PREG_HANDLE            Hdl,
    OUT     DWORD                 *OptionId,
    OUT     LPWSTR                *ClassName,
    OUT     LPWSTR                *VendorName,
    OUT     DWORD                 *Flags,
    OUT     LPBYTE                *Value,
    OUT     DWORD                 *ValueSize
) ;


//================================================================================
//  the following functiosn help in writing to the registry
//================================================================================


DWORD
DhcpRegSaveSubKeys(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Array
) ;


DWORD
DhcpRegSaveSubKeysPrefixed(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Array,
    IN      LPWSTR                 CommonPrefix
) ;


DWORD
DhcpRegServerSetList(
    IN      PREG_HANDLE            Hdl,
    IN      PARRAY                 OptList,       // list of LPWSTR options
    IN      PARRAY                 OptDefList,    // list of LPWSTR optdefs
    IN      PARRAY                 Subnets,       // list of LPWSTR subnets
    IN      PARRAY                 SScopes,       // list of LPWSTR sscopes
    IN      PARRAY                 ClassDefs,     // list of LPWSTR classes
    IN      PARRAY                 MScopes        // list of LPWSTR mscopes
) ;


DWORD
DhcpRegSubnetSetExclusions(
    IN      PREG_HANDLE            Hdl,
    IN      LPBYTE                *Excl,
    IN      DWORD                  ExclSize
) ;


DWORD
DhcpRegSubnetSetList(
    IN      PREG_HANDLE            Hdl,
    IN      PARRAY                 Servers,
    IN      PARRAY                 IpRanges,
    IN      PARRAY                 Reservations,
    IN      PARRAY                 Options,
    IN      LPBYTE                *Excl,
    IN      DWORD                  ExclSizeInBytes
) ;


DWORD
DhcpRegSScopeSetList(
    IN      PREG_HANDLE            Hdl,
    IN OUT  PARRAY                 Subnets
) ;


DWORD
DhcpRegReservationSetList(
    IN      PREG_HANDLE            Hdl,
    IN      PARRAY                 Subnets
) ;


//================================================================================
//  the single stuff are here -- these are not list stuff, but just simple
//  single valued attributes
//  some of these actually, dont even go to the registry, but that's fine alright?
//================================================================================


DWORD
DhcpRegServerSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags
    // more attributes will come here soon?
) ;


DWORD
DhcpRegSubnetSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      DWORD                 *Address,
    IN      DWORD                 *Mask
) ;


DWORD
DhcpRegMScopeSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Comments,
    IN      DWORD                 *State,
    IN      DWORD                 *ScopeId,
    IN      DWORD                 *Policy,
    IN      DWORD                 *TTL,
    IN      LPWSTR                *LangTag,
    IN      PDATE_TIME             *ExpiryTime
) ;


DWORD
DhcpRegOptDefSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comments,
    IN      DWORD                 *Flags,
    IN      DWORD                 *OptionId,
    IN      LPWSTR                *ClassName,
    IN      LPWSTR                *VendorName,
    IN      LPBYTE                *Value,
    IN      DWORD                  ValueSize
) ;


DWORD
DhcpRegSScopeSetAttributes(                       // superscopes dont have any information stored.. dont use this
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags
) ;


DWORD
DhcpRegClassDefSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      LPBYTE                *Value,
    IN      DWORD                  ValueSize
) ;


DWORD
DhcpRegSubnetServerSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      DWORD                 *Address,
    IN      DWORD                 *Role
) ;


DWORD
DhcpRegRangeSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      ULONG                 *AllocCount,
    IN      ULONG                 *MaxAllocCount,
    IN      DWORD                 *StartAddress,
    IN      DWORD                 *EndAddress,
    IN      LPBYTE                *InUseClusters,
    IN      DWORD                  InUseClusterSize,
    IN      LPBYTE                *UsedClusters,
    IN      DWORD                  UsedClustersSize
) ;


DWORD
DhcpRegReservationSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                *Name,
    IN      LPWSTR                *Comment,
    IN      DWORD                 *Flags,
    IN      DWORD                 *Address,
    IN      LPBYTE                *ClientUID,
    IN      DWORD                  ClientUIDSize
) ;


DWORD
DhcpRegOptSetAttributes(
    IN      PREG_HANDLE            Hdl,
    IN      DWORD                 *OptionId,
    IN      LPWSTR                *ClassName,
    IN      LPWSTR                *VendorName,
    IN      DWORD                 *Flags,
    IN      LPBYTE                *Value,
    IN      DWORD                  ValueSize
) ;


DWORD
DhcpRegRecurseDelete(
    IN      PREG_HANDLE            Hdl,
    IN      LPWSTR                 KeyName
) ;


DWORD
DhcpRegRecurseDeleteBunch(
    IN      PREG_HANDLE            Hdl,
    IN      PARRAY                 KeysArray
) ;


DWORD
DhcpRegUpdateTime(                                // update the last modified time
    VOID
) ;

//========================================================================
//  end of file
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\auditlog.c ===
//================================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV (originally written by Cheng Yang (t-cheny))
//  Description: Implements dhcp server auditlogging in an improved way.
//================================================================================


#include "dhcppch.h"
#include "rpcapi.h"

#include <time.h>

//================================================================================
//  here are the parameters that affect the server behaviour
//================================================================================
LPWSTR   AuditLogFilePath = NULL;                 // where to log stuff
LPWSTR   AuditLogFileName = NULL;                 // full file name of audit log..
DWORD    DiskSpaceCheckInterval = 0;              // how often to check for diskspace
DWORD    CurrentDay = 0;                          // what day are we on now?
DWORD    MaxSizeOfLogFile = 0;                    // how big in MBytes can each file be?
DWORD    MinSpaceOnDisk = 0;                      // how much space should exist on disk?

static
DWORD    Initialized = 0;                         // is this module initialized yet?
DWORD    AuditLogErrorLogged = 0;                 // already logged error?
HANDLE   AuditLogHandle = INVALID_HANDLE_VALUE;   // handle to file to log in..
CRITICAL_SECTION AuditLogCritSect;                // used for serializeing multiple logs..

//================================================================================
//  here are the defaults for the above parameters where applicable..
//================================================================================
#define  DEFAULT_DISK_SPACE_CHECK_INTERVAL        50 // once every fifty messages
#define  MIN_DISK_SPACE_CHECK_INTERVAL            2  // check once every two messages
#define  MAX_DISK_SPACE_CHECK_INTERVAL            0xFFFFFFF0
#define  DEFAULT_MAX_LOG_FILE_SIZE                 7 // 7 megs for all files 7 file together
#define  DEFAULT_MIN_SPACE_ON_DISK                20 // atleast 20 megs of space must be available..

//================================================================================
//  here's the list of string names as required for reading away from the registry..
//================================================================================
#define  DHCP_REGSTR_SPACE_CHECK_INTERVAL         L"DhcpLogDiskSpaceCheckInterval"
#define  DHCP_REGSTR_MAX_SZ_OF_FILES              L"DhcpLogFilesMaxSize"
#define  DHCP_REGSTR_MIN_SPACE_ON_DISK            L"DhcpLogMinSpaceOnDisk"

//================================================================================
//  helper functions
//================================================================================
LPWSTR
DefaultLogFileName(                               // allocate space and return string
    VOID
)
{
    return DhcpOemToUnicode(DhcpGlobalOemDatabasePath, NULL);
}

BOOL
IsFileJustOldLog(                                 // is the log file just last week's log file?
    IN      LPWSTR                 FileName
)
{
    DWORD                          Error;
    BOOL                           Status;
    WIN32_FILE_ATTRIBUTE_DATA      FileAttr;
    FILETIME                       Now;
    SYSTEMTIME                     SysTime;
    LONGLONG                       ADayInFileTime;

    Status = GetFileAttributesEx(                 // get last write date on file..
        FileName,
        GetFileExInfoStandard,
        (LPVOID)&FileAttr
    );
    if( FALSE == Status ) return FALSE;           // if we cant proceed dont matter, we'll assume it is new file.

    GetLocalTime(&SysTime);                       // get local time
    Status = SystemTimeToFileTime(&SysTime, &Now);
    if( FALSE == Status ) {                       // could not convert system time to local time?
        Error = GetLastError();
        DhcpPrint((DEBUG_ERRORS, "SystemTimeToFileTime: 0x%lx\n", Error));
        DhcpAssert(FALSE);
        return FALSE;
    }

    ADayInFileTime = 24*60*60;                    // in seconds
    ADayInFileTime *= 10000000;                   // in 100 nano seconds..
    (*(LONGLONG *)&Now) = (*(LONGLONG *)&Now) - ADayInFileTime;
    if( CompareFileTime( &FileAttr.ftLastWriteTime, &Now ) <= 0 ) {
        DhcpPrint((DEBUG_AUDITLOG, "File is assumed to be old log\n"));
        return TRUE;                              // more than a day has passed since this was written to..
    }

    return FALSE;                                 // this *is* a fresh file
}

LPWSTR
FormAuditLogFileName(                             // given directory and day, form file name
    IN      LPWSTR                 FilePath,      // directory where audit log file would be
    IN      DWORD                  Day            // current day of week
)
{
    LPWSTR                         FileName;
    LPWSTR                         DayOfWeek;
    DWORD                          Size;

    DhcpAssert( Day <= 6 );                       // assuming all of us work 7 day week <grin>
    DayOfWeek = GETSTRING((Day + DHCP_LOG_FILE_NAME_SUNDAY));

    Size = wcslen(FilePath) + wcslen(DayOfWeek) + sizeof(DHCP_KEY_CONNECT);
    FileName = DhcpAllocateMemory(Size*sizeof(WCHAR));
    if( NULL == FileName ) return NULL;

    wcscpy(FileName, FilePath);                   // concat FilePath,DayOfWeek w/ L"\\" inbetweem
    wcscat(FileName, DHCP_KEY_CONNECT);
    wcscat(FileName, DayOfWeek);

    return FileName;
}

VOID
LogStartupFailure(                                // log in the system event log about auditlog startup failure
    IN      DWORD                  Error          // error code (win32) reason for failure
)
{
    DhcpServerEventLog(                           // not much to this one really. just log event.
        EVENT_SERVER_INIT_AUDIT_LOG_FAILED,
        EVENTLOG_ERROR_TYPE,
        Error
    );
}

DWORD
AuditLogStart(                                    // open file handles etc and start
    VOID
)
{
    LPWSTR                         FileName;      // file name of audit log file..
    LPWSTR                         Header;        // header that we want in the file..
    LPSTR                          szHeader;
    DWORD                          Creation;      // how to create?
    DWORD                          Tmp;
    DWORD                          Error;
    HMODULE                        SelfLibrary;   // for some string

    DhcpPrint((DEBUG_AUDITLOG, "AuditLogStart called\n"));

    if( NULL != AuditLogFileName ) {              // free old file name if exists..
        DhcpFreeMemory(AuditLogFileName);
    }

    AuditLogFileName = FormAuditLogFileName(AuditLogFilePath, CurrentDay);
    FileName = AuditLogFileName;
    if( NULL == FileName ) return ERROR_NOT_ENOUGH_MEMORY;

    if( IsFileJustOldLog(FileName) ) {            // old log file from last week?
        Creation = CREATE_ALWAYS;
    } else {                                      // this is not an old log file, but was just used recently..
        Creation = OPEN_ALWAYS;
    }

    AuditLogHandle = CreateFile(                  // now open this file
        FileName,                                 // this is "Dhcp server log for Sunday" types..
        GENERIC_WRITE,                            // access
        FILE_SHARE_READ,                          // allow others to only read this file
        NULL,                                     // default security
        Creation,                                 // start from scratch or just use it as it is?
        FILE_ATTRIBUTE_NORMAL,                    // FILE_FLAG_SEQUENTIAL_SCAN may be only for reads?
        NULL                                      // no template handle required
    );
    if( INVALID_HANDLE_VALUE == AuditLogHandle ){ // could not open the file for some strange reason?
        Error = GetLastError();
        DhcpPrint((DEBUG_AUDITLOG, "CreateFile(%ws,0x%lx) failed %ld\n", FileName, Creation, Error));
        LogStartupFailure(Error);                 // log this problem and return..
        DhcpFreeMemory(FileName);                 // dont lose this memory.. free it!
        AuditLogFileName = NULL;
        return Error;
    }

    SetFilePointer(                               // go to end of file if we're using existing file
        AuditLogHandle,
        0,
        NULL,
        FILE_END
    );

    SelfLibrary = LoadLibrary(DHCP_SERVER_MODULE_NAME);
    if( NULL == SelfLibrary ) {                   // alright, cant get our own dll handle? uhg?
        DhcpAssert(FALSE);                        // whatever the reason, i'd like to konw.. <smile>
        return ERROR_SUCCESS;                     // not that this matters... so let go
    }

    Error = FormatMessage(                        // now get the header string out
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
        SelfLibrary,                              // dhcpssvc.dll module actually.
        DHCP_IP_LOG_HEADER,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPWSTR)&Header,
        1,
        NULL
    );
    if( 0 == Error ) {                            // for some reason, we could not find this string?
        DhcpAssert(FALSE);
        FreeLibrary(SelfLibrary);
        return ERROR_SUCCESS;
    }

    szHeader = DhcpUnicodeToOem( Header, NULL);
    if( NULL != szHeader ) {                      // alright, could convert to simple ansi code page
        OemToCharBuffA(szHeader, szHeader, strlen(szHeader) );           // bug #22349 requires file to be written in ANSI
        WriteFile( AuditLogHandle, szHeader, strlen(szHeader), &Tmp, NULL);
        DhcpFreeMemory(szHeader);
    }

    (LocalFree)(Header);                          // protect from #defines for LocalFree
    FreeLibrary(SelfLibrary);                     // free library, dont need it anymore

    return ERROR_SUCCESS;                         // dunnet.
}

VOID
AuditLogStop(                                     // stop logging, release resources?
    VOID                                          // lot easier, just close handle..
)
{
    DhcpPrint((DEBUG_AUDITLOG, "AuditLogStop called\n"));
    if( INVALID_HANDLE_VALUE == AuditLogHandle ){ // never started?
        DhcpPrint((DEBUG_AUDITLOG, "AuditLog was never started..\n"));
    } else {
        CloseHandle(AuditLogHandle);
        AuditLogHandle = INVALID_HANDLE_VALUE;
    }

}

BOOL
IsFileTooBigOrDiskFull(                           // is the auditlog file too big?
    IN      HANDLE                 FileHandle,    // file to check size of
    IN      LPWSTR                 FileName,      // if no handle, use file name
    IN      DWORD                  MaxSize,       // how big can file get? (MBytes)
    IN      DWORD                  MinDiskSpace   // how much space should be left on disk (MBytes)
)
{
    BOOL                    Status;
    DWORD                   Error;
    LARGE_INTEGER           Sz;
    WCHAR                   Drive[4];
    ULARGE_INTEGER          FreeSpace, DiskSize;

    
    if( INVALID_HANDLE_VALUE == FileHandle ) {
	WIN32_FILE_ATTRIBUTE_DATA  Attributes;

        if(!GetFileAttributesEx(FileName, GetFileExInfoStandard, &Attributes) ) {
            Error = GetLastError();               // could not get file size?
            if( ERROR_FILE_NOT_FOUND == Error ) { // file does not exist?
                Attributes.nFileSizeHigh = Attributes.nFileSizeLow = 0;
            } 
	    else {
                DhcpPrint((DEBUG_ERRORS, "GetFileAttributesEx failed 0x%lx\n", Error));
                return TRUE;
            }
        } // if

	Sz.HighPart = Attributes.nFileSizeHigh;
	Sz.LowPart = Attributes.nFileSizeLow;
    }  // if
    else {    // got the file handle. do easy check.
	if ( !GetFileSizeEx( FileHandle, &Sz )) {
	    DhcpPrint(( DEBUG_ERRORS, "GetFileSizeEx() failed\n" ));
	    return TRUE;
	}

    } // else

    Sz.QuadPart >>= 20;  // In MB

    DhcpPrint(( DEBUG_AUDITLOG, "File size is %lu\n", Sz.LowPart ));

    if( Sz.LowPart >= MaxSize ) return TRUE;      // ok, file is too big..

    FileName = AuditLogFilePath;                  // use this to calculate the drive..
    while( iswspace(*FileName) ) FileName++;      // skip leading space

    Drive[0] = *FileName;                         // here goes the drive letter calculation
    Drive[1] = L':';
    Drive[2] = DHCP_KEY_CONNECT_CHAR;
    Drive[3] = L'\0';

    Status = GetDiskFreeSpaceEx( Drive, &FreeSpace, &DiskSize, NULL );
    if( FALSE == Status ) {
	// system call failed?
        Error = GetLastError();
        DhcpPrint((DEBUG_ERRORS, 
		   "GetDiskFreeSpace(%ws): 0x%lx\n",
		   Drive, Error));
        return TRUE;
    } // if 

    FreeSpace.QuadPart >>= 20;     // In MB

    DhcpPrint((DEBUG_AUDITLOG, "FreeSpace is %lu MEGS\n", FreeSpace));
    return (( DWORD ) FreeSpace.QuadPart <= MinDiskSpace );  // reqd free space left?
    
} // IsFileTooBigOrDiskFull()

BOOL
HasDayChanged(                                    // have we moved over to new day?
    IN OUT  DWORD                 *CurrentDay     // if this is not current day, set it to current day..
)
{
    SYSTEMTIME                     SysTime;

    GetLocalTime(&SysTime);                       // get current time
    if( *CurrentDay == SysTime.wDayOfWeek ) {     // no change
        return FALSE;
    }
    *CurrentDay = SysTime.wDayOfWeek;             // since there was a change, correct day..
    return TRUE;
}

//================================================================================
//  initialization and cleanup of this module
//================================================================================

//BeginExport(function)
DWORD
DhcpAuditLogInit(                                 // intialize audit log
    VOID                                          // must be called after initializing registry..
)   //EndExport(function)
{
    DWORD                Error;
    SYSTEMTIME           SysTime;
    BOOL                 BoolError;
    HKEY                 RegKey;
    DWORD                KeyDisposition;
    
    if( 0 != Initialized ) {                      // already initialized?
        return ERROR_ALREADY_INITIALIZED;
    }

    if( NULL == DhcpGlobalRegParam ) {            // registry is not initialized yet?
        DhcpAssert(FALSE);                        // should not happen really.
        return ERROR_INTERNAL_ERROR;
    }

    AuditLogFilePath = NULL;
    Error = DhcpRegGetValue(                      // get the audit log file name
        DhcpGlobalRegParam,
        DHCP_LOG_FILE_PATH_VALUE,
        DHCP_LOG_FILE_PATH_VALUE_TYPE,
        (LPBYTE)&AuditLogFilePath
    );
    if( ERROR_SUCCESS != Error   
	|| NULL == AuditLogFilePath
	|| L'\0' == *AuditLogFilePath ) {

        AuditLogFilePath = DefaultLogFileName();  // use the default file name if none specified
        if( NULL == AuditLogFilePath ) {          // could not allocate space or some such thing..
            return ERROR_NOT_ENOUGH_MEMORY;
        }
	

	DhcpPrint(( DEBUG_ERRORS,
		    "Auditlog is invalid. Defaulting to %ws\n",
		    AuditLogFilePath ));

	if ( ERROR_SUCCESS != Error ) {

	    // Key doesn't exist, create it
	    Error = DhcpRegCreateKey( DhcpGlobalRegParam,
				      DHCP_LOG_FILE_PATH_VALUE,
				      &RegKey,
				      &KeyDisposition );
	    if ( ERROR_SUCCESS == Error ) {
		RegCloseKey( RegKey );
	    }
	    
	} // if key doesn't exist

	// Add value to the key
	Error = RegSetValueEx( DhcpGlobalRegParam,
			       DHCP_LOG_FILE_PATH_VALUE,
			       0, DHCP_LOG_FILE_PATH_VALUE_TYPE,
			       ( LPBYTE ) AuditLogFilePath,
			       ( wcslen( AuditLogFilePath) + 1) * sizeof( WCHAR ));		
	
	if ( ERROR_SUCCESS != Error ) {
	    return Error;
	}
    
    } // if
    
    DhcpPrint(( DEBUG_MISC,
		"Initializing auditlog at (%ws) ... \n", 
		AuditLogFilePath ));

    BoolError = CreateDirectoryPathW(
        AuditLogFilePath,
        DhcpGlobalSecurityDescriptor
        );
    if( FALSE == BoolError ) {

	// Log an event
	DhcpServerEventLog( EVENT_SERVER_AUDITLOG_PATH_NOT_ACCESSIBLE,
			    EVENTLOG_ERROR_TYPE,
			    GetLastError());
        return Error = GetLastError();
    }
    
    GetLocalTime(&SysTime);                       // calculate current day
    CurrentDay = SysTime.wDayOfWeek;              // 0 ==> sunday, 1 ==> monday etc..

    Error = DhcpRegGetValue(                      // get the disk space check interval
        DhcpGlobalRegParam,
        DHCP_REGSTR_SPACE_CHECK_INTERVAL,
        REG_DWORD,
        (LPBYTE)&DiskSpaceCheckInterval
    );
    if( ERROR_SUCCESS != Error ) {                // no value specified? use default
        DiskSpaceCheckInterval = DEFAULT_DISK_SPACE_CHECK_INTERVAL;
    } 

    if( DiskSpaceCheckInterval < MIN_DISK_SPACE_CHECK_INTERVAL ) {
        DiskSpaceCheckInterval = MIN_DISK_SPACE_CHECK_INTERVAL;
    }

    if( DiskSpaceCheckInterval > MAX_DISK_SPACE_CHECK_INTERVAL ) {
        DiskSpaceCheckInterval = MAX_DISK_SPACE_CHECK_INTERVAL;
    }

    Error = DhcpRegGetValue(                      // get the max size of all log files etc..
        DhcpGlobalRegParam,
        DHCP_REGSTR_MAX_SZ_OF_FILES,
        REG_DWORD,
        (LPBYTE)&MaxSizeOfLogFile
    );
    if( ERROR_SUCCESS != Error ) {                // no value specified? use default
        MaxSizeOfLogFile = DEFAULT_MAX_LOG_FILE_SIZE;
    }

    Error = DhcpRegGetValue(                      // get min space on disk value
        DhcpGlobalRegParam,
        DHCP_REGSTR_MIN_SPACE_ON_DISK,
        REG_DWORD,
        (LPBYTE)&MinSpaceOnDisk
    );
    if( ERROR_SUCCESS != Error ) {                // no value specified? use defaults
        MinSpaceOnDisk = DEFAULT_MIN_SPACE_ON_DISK;
    } else if( 0 == MinSpaceOnDisk ) {
        MinSpaceOnDisk = DEFAULT_MIN_SPACE_ON_DISK; // dont allow zeroes..
    }

    try {
        InitializeCriticalSection(&AuditLogCritSect); 
    }except( EXCEPTION_EXECUTE_HANDLER ) {

        // shouldnt happen but you never know.
        Error = GetLastError( );
        return( Error );
    }

    Initialized ++;                               // mark it as initialized

    // Now get hold of the file and do the rest..
    Error = AuditLogStart();                      // start hte logging

    return ERROR_SUCCESS;                         // ignore startup errors..
}

//BeginExport(function)
VOID
DhcpAuditLogCleanup(                              // undo the effects of the init..
    VOID
)   //EndExport(function)
{
    if( 0 == Initialized ) {                      // was never initialized ...
        return;
    }

    Initialized --;                               // alright, we're as good as clean
    DhcpAssert( 0 == Initialized );

    AuditLogStop();                               // stop logging..
    if( NULL != AuditLogFilePath ) {              // cleanup any memory we got
        DhcpFreeMemory(AuditLogFilePath);
        AuditLogFilePath = NULL;
    }
    if( NULL != AuditLogFileName ) {
        DhcpFreeMemory(AuditLogFileName);
        AuditLogFileName = NULL;
    }

    DeleteCriticalSection(&AuditLogCritSect);     // freeup the crit section resources
}

//================================================================================
//  actual logging routine
//================================================================================

//DOC This routine logs the foll information: Date &Time, IpAddress, HwAddress, M/cName
//DOC and ofcourse, the task name.  All this goes into the current open auditlog file..
//DOC This routine makes absolutely no checks on file size etc.. (which is why "blind")
DWORD
DhcpUpdateAuditLogBlind(                          // do the actual logging
    IN      DWORD                  Task,          // DHCP_IP_LOG_* events..
    IN      LPWSTR                 TaskName,      // name of task
    IN      DHCP_IP_ADDRESS        IpAddress,     // ipaddr related to task
    IN      LPBYTE                 HwAddress,     // hardware addr related to task
    IN      DWORD                  HwLen,         // size of above buffer in bytes
    IN      LPWSTR                 MachineName,   // name of m/c related to task
    IN      ULONG                  ErrorCode      // Error code
)
{
    DWORD                          Error;
    DWORD                          i, n, c, Size;
    WCHAR                          DateBuf[9], TimeBuf[9], UserName[UNLEN+DNLEN+4];
    LPSTR                          Format1 = "%.2d,%ls,%ls,%ls,%hs,%ls,";
    LPSTR                          Format2 = "%.2d,%ls,%ls,%ls,%hs,%ls,%ld";
    LPSTR                          Format = (ErrorCode == 0)?Format1 : Format2;
    LPSTR                          LogEntry, Temp;
    LPSTR                          IpAddressString;

    if( !DhcpGlobalAuditLogFlag ) {               // auditlogging turned off.
        return ERROR_SUCCESS;
    }

    if( INVALID_HANDLE_VALUE == AuditLogHandle ){ // ==> could not start audit logging!!..
        DhcpPrint((DEBUG_ERRORS, "Not logging as unable to start audit logging..\n"));
        return ERROR_SUCCESS;
    }

    if( NO_ERROR != GetUserAndDomainName( (LPWSTR)UserName ) ) {
        UserName[0] = L'\0';
    }
    
    Error = ERROR_SUCCESS;

    _wstrdate( DateBuf );                          // date
    _wstrtime( TimeBuf );                          // time
    if( NULL == TaskName ) TaskName = L"";        // should not really happen.. but.
    if( NULL == MachineName ) MachineName = L"";  // like empty string better
    if( 0 == IpAddress ) IpAddressString = "";    // ditto
    else IpAddressString = DhcpIpAddressToDottedString(IpAddress);

    Size = DHCP_CB_MAX_LOG_ENTRY + HwLen*2 + wcslen(DateBuf);
    Size += wcslen(TaskName) + wcslen(TimeBuf);
    Size += strlen(IpAddressString) + wcslen(MachineName);
    Size += wcslen(UserName) + 10;
    
    LogEntry = DhcpAllocateMemory( Size );
    if( NULL == LogEntry ) {                      // unhappy state of affairs..
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Temp = LogEntry;

    Temp += wsprintfA(
        Temp, Format, Task, DateBuf, TimeBuf,
        TaskName, IpAddressString, MachineName, ErrorCode );
    for( i = 0; i < HwLen ; i ++ ) {              // now dump the hw address
        Temp += wsprintfA(Temp, "%.2X", *(HwAddress++));
    }

    Temp += wsprintfA(Temp, ",%ls", UserName );
    strcpy(Temp, "\r\n");

    DhcpAssert( strlen(LogEntry) < Size);

    if( !WriteFile(AuditLogHandle, LogEntry, strlen(LogEntry), &n, NULL) ) {
        Error = GetLastError();                   // write failed for some strange reason..

        DhcpPrint((DEBUG_ERRORS, "WriteFile: 0x%lx\n", Error));
        DhcpFreeMemory(LogEntry);
        goto Cleanup;
    }

    DhcpFreeMemory(LogEntry);
    return ERROR_SUCCESS;

  Cleanup:

    if( AuditLogErrorLogged ) {                   // nothing much to do..
        return Error;
    }

    AuditLogErrorLogged = TRUE;                   // we are just logging it..
    DhcpServerEventLog(
        EVENT_SERVER_AUDIT_LOG_APPEND_FAILED,
        EVENTLOG_ERROR_TYPE,
        Error
    );

    return Error;
}

BOOL                               DiskSpaceLow = FALSE;
DWORD                              Counter = 0;   // counter for checking dsk sp.

//DOC This routine just causes the next audit log to check for change of day..
//BeginExport(function)
VOID
DhcpChangeAuditLogs(                              // shift for new log
    VOID
)   //EndExport(function)
{
    ULONG Error, Day;
    EnterCriticalSection(&AuditLogCritSect);      // take readlocks here..
    Day = CurrentDay;
    if( HasDayChanged( &CurrentDay)) {            // ok day has changed..
        AuditLogStop();                           // stop logging
        Error = AuditLogStart();                  // pickup new stuff..
        if( ERROR_SUCCESS != Error ) {            // couldn't restart..so need to try later..
            CurrentDay = Day;
            AuditLogStop();
        }
        AuditLogErrorLogged = FALSE;              // reset it each day..
        DiskSpaceLow = FALSE;                     // reset disk space low..
    }
    LeaveCriticalSection(&AuditLogCritSect);      // use read/wrtie locks..
}

//DOC This routine logs the foll information: Date &Time, IpAddress, HwAddress, M/cName
//DOC and ofcourse, the task name.  All this goes into the current open auditlog file..
DWORD
DhcpUpdateAuditLogEx(                             // do the actual logging
    IN      DWORD                  Task,          // DHCP_IP_LOG_* events..
    IN      LPWSTR                 TaskName,      // name of task
    IN      DHCP_IP_ADDRESS        IpAddress,     // ipaddr related to task
    IN      LPBYTE                 HwAddress,     // hardware addr related to task
    IN      DWORD                  HwLen,         // size of above buffer in bytes
    IN      LPWSTR                 MachineName,   // name of m/c related to task
    IN      ULONG                  ErrorCode      // additional error code
)
{
    DWORD                          Error;
    DWORD                          Status;

    Error = ERROR_SUCCESS;

    if( !Initialized ) return ERROR_SUCCESS;

    EnterCriticalSection(&AuditLogCritSect);      // take readlocks here..

    if( 0 == Counter ) {                          // time to make checks..
        Counter = DiskSpaceCheckInterval+1;       // reset counter

        if( IsFileTooBigOrDiskFull(AuditLogHandle, AuditLogFileName, MaxSizeOfLogFile/7, MinSpaceOnDisk) ) {
            if( FALSE == DiskSpaceLow ) {         // it just got low?
                DiskSpaceLow = TRUE;
                DhcpUpdateAuditLogBlind(          // log that we are low on disk space..
                    DHCP_IP_LOG_DISK_SPACE_LOW,
                    GETSTRING(DHCP_IP_LOG_DISK_SPACE_LOW_NAME),
                    0,
                    NULL,
                    0,
                    NULL,
                    0
                );
                AuditLogStop();                   // stop logging, no poing doing this
            }
        } else {
            if( TRUE == DiskSpaceLow ) {          // was stopped before
                AuditLogStart();
                DiskSpaceLow = FALSE;
            }

        }
    }
    Counter --;                                   // decrement this once..

    if( FALSE == DiskSpaceLow ) {                 // got some space..
        Error = DhcpUpdateAuditLogBlind(          // no checks, update of log ..
            Task,
            TaskName,
            IpAddress,
            HwAddress,
            HwLen,
            MachineName,
            ErrorCode
        );
    }

    LeaveCriticalSection(&AuditLogCritSect);      // use read/wrtie locks..

    return Error;
}

DWORD
DhcpUpdateAuditLog(                               // do the actual logging
    IN      DWORD                  Task,          // DHCP_IP_LOG_* events..
    IN      LPWSTR                 TaskName,      // name of task
    IN      DHCP_IP_ADDRESS        IpAddress,     // ipaddr related to task
    IN      LPBYTE                 HwAddress,     // hardware addr related to task
    IN      DWORD                  HwLen,         // size of above buffer in bytes
    IN      LPWSTR                 MachineName    // name of m/c related to task
)
{
    return DhcpUpdateAuditLogEx(Task, TaskName, IpAddress, HwAddress, HwLen, MachineName, 0);
}

//================================================================================
//  here are audit log api calls to set the various parameters..
//================================================================================

//BeginExport(function)
DWORD
AuditLogSetParams(                                // set some auditlogging params
    IN      DWORD                  Flags,         // currently must be zero
    IN      LPWSTR                 AuditLogDir,   // directory to log files in..
    IN      DWORD                  DiskCheckInterval, // how often to check disk space?
    IN      DWORD                  MaxLogFilesSize,   // how big can all logs files be..
    IN      DWORD                  MinSpaceOnDisk     // mininum amt of free disk space
)   //EndExport(function)
{
    DWORD                          Error;

    Error = CreateDirectoryPathW(
        AuditLogDir, DhcpGlobalSecurityDescriptor );
    if( FALSE == Error ) return GetLastError();
        
    Error = RegSetValueEx(                         // write the info to the registry
        DhcpGlobalRegParam,
        DHCP_LOG_FILE_PATH_VALUE,
        0,
        DHCP_LOG_FILE_PATH_VALUE_TYPE,
        (LPBYTE)AuditLogDir,
        (NULL == AuditLogDir ) ? 0 : (wcslen(AuditLogDir)+1)*sizeof(WCHAR)
    );
    if( ERROR_SUCCESS != Error ) {                 // could not do it?
        DhcpPrint((DEBUG_ERRORS, "RegSetValueEx(LOG_FILE_PATH):0x%lx\n", Error));
        return Error;
    }

    Error = RegSetValueEx(                         // write the info to the registry
        DhcpGlobalRegParam,
        DHCP_REGSTR_SPACE_CHECK_INTERVAL,
        0,
        REG_DWORD,
        (LPBYTE)&DiskCheckInterval,
        sizeof(DiskCheckInterval)
    );
    if( ERROR_SUCCESS != Error ) {                 // could not do it?
        DhcpPrint((DEBUG_ERRORS, "RegSetValueEx(SPACE_CHECK_INTERVAL):0x%lx\n", Error));
        return Error;
    }

    Error = RegSetValueEx(                         // write the info to the registry
        DhcpGlobalRegParam,
        DHCP_REGSTR_MAX_SZ_OF_FILES,
        0,
        REG_DWORD,
        (LPBYTE)&MaxLogFilesSize,
        sizeof(MaxLogFilesSize)
    );
    if( ERROR_SUCCESS != Error ) {                 // could not do it?
        DhcpPrint((DEBUG_ERRORS, "RegSetValueEx(MAX_SZ_OF_FILES):0x%lx\n", Error));
        return Error;
    }

    Error = RegSetValueEx(                         // write the info to the registry
        DhcpGlobalRegParam,
        DHCP_REGSTR_MIN_SPACE_ON_DISK,
        0,
        REG_DWORD,
        (LPBYTE)&MinSpaceOnDisk,
        sizeof(MinSpaceOnDisk)
    );
    if( ERROR_SUCCESS != Error ) {                 // could not do it?
        DhcpPrint((DEBUG_ERRORS, "RegSetValueEx(MIN_SPACE_ON_DISK):0x%lx\n", Error));
        return Error;
    }

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
AuditLogGetParams(                                // get the auditlogging params
    IN      DWORD                  Flags,         // must be zero
    OUT     LPWSTR                *AuditLogDir,   // same meaning as in AuditLogSetParams
    OUT     DWORD                 *DiskCheckInterval, // ditto
    OUT     DWORD                 *MaxLogFilesSize,   // ditto
    OUT     DWORD                 *MinSpaceOnDiskP    // ditto
)   //EndExport(function)
{
    DWORD     Error;

    if( AuditLogDir ) {
	*AuditLogDir =  CloneLPWSTR( AuditLogFilePath );
    }

    if( DiskCheckInterval ) {
	*DiskCheckInterval = DiskSpaceCheckInterval;
    }

    if( MaxLogFilesSize ) {
	*MaxLogFilesSize = MaxSizeOfLogFile;
    }

    if( MinSpaceOnDiskP ) {
	*MinSpaceOnDiskP = MinSpaceOnDisk;
    }

    return ERROR_SUCCESS;
}

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\mmreg\test.c ===
//
//  Copyright (C) 1998 Microsoft Corporation
//

#define  UNICODE

#include    <mm\mm.h>
#include    <mm\array.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\memfree.h>
#include    <winsock2.h>
#include    <stdlib.h>

#include <regutil.h>
#include <regread.h>
#include <regsave.h>
#include <stdio.h>

CRITICAL_SECTION                   DhcpGlobalInProgressCritSect;

PM_SERVER
DhcpGetCurrentServer(
    VOID
)
{
    return NULL;
}

void _cdecl main(void) {
    DWORD                          RetVal;
    PM_SERVER                      ThisServer;

    RetVal = DhcpRegReadThisServer(&ThisServer);
    if( ERROR_SUCCESS != RetVal ) {
        printf("DhcpRegReadThisServer: %ld 0x%lx\n", RetVal, RetVal);
    }

    InitializeCriticalSection(&DhcpGlobalInProgressCritSect);
    DhcpRegServerFlush(ThisServer, TRUE);
    DeleteCriticalSection(&DhcpGlobalInProgressCritSect);
    MemServerFree(ThisServer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\binl.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    binl.c

Abstract:

    This file manages the interactions between the DHCP server service
    and the BINL service used to setup and load NetPC machines.

Author:

    Colin Watson (colinw)  28-May-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#include <dhcppch.h>

DhcpStateChange DhcpToBinl = NULL;
ReturnBinlState IsBinlRunning = NULL;
ProcessBinlDiscoverCallback BinlDiscoverCallback = NULL;
ProcessBinlRequestCallback BinlRequestCallback = NULL;
BOOL AttemptedLoad = FALSE;
BOOL Loaded = FALSE;
HINSTANCE   dllHandle = NULL;

BOOL
LoadDhcpToBinl(
    VOID
    );

VOID
UnLoadDhcpToBinl(
    VOID
    );

VOID
InformBinl(
    int NewState
    )
/*++

Routine Description:

    This routine informs BINL when to start & stop listening for broadcasts
    on the DHCP socket.

Arguments:

    NewState - Supplies a value which specifies the DHCP state

Return Value:

    None.

--*/
{
    if( DHCP_READY_TO_UNLOAD == NewState ) {
        UnLoadDhcpToBinl();
        return;
    }
    
    if (!LoadDhcpToBinl()) {
        return;
    }

    (*DhcpToBinl)(NewState);

}

BOOL
CheckForBinlOnlyRequest(
    LPDHCP_REQUEST_CONTEXT  RequestContext,
    LPDHCP_SERVER_OPTIONS   DhcpOptions
    )
{
    BOOL rc;
    LPDHCP_MESSAGE dhcpReceiveMessage;
    DWORD relayAddress;
    DWORD sourceAddress;

    //
    //  if binl is running and this client already has an IP address and
    //  the client specified PXECLIENT as an option, then we just pass this
    //  discover on to BINL
    //

    sourceAddress = ((struct sockaddr_in *)(&RequestContext->SourceName))->sin_addr.s_addr;
    dhcpReceiveMessage  = (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer;
    relayAddress = dhcpReceiveMessage->RelayAgentIpAddress;

    if ( BinlRunning() &&
         ( sourceAddress != 0 ) &&
         ( sourceAddress != relayAddress ) &&
         ( RequestContext->BinlClassIdentifierLength >= (sizeof("PXEClient") - 1) ) &&
         ( memcmp(RequestContext->BinlClassIdentifier, "PXEClient", sizeof("PXEClient") - 1) == 0 ) ) {

        rc = TRUE;

    } else {

        rc = FALSE;
    }

    return rc;
}

LPOPTION
BinlProcessRequest(
    LPDHCP_REQUEST_CONTEXT  RequestContext,
    LPDHCP_SERVER_OPTIONS   DhcpOptions,
    LPOPTION Option,
    PBYTE OptionEnd
    )
/*++

Routine Description:

    This routine takes a DHCP request packet. If it includes the PXEClient
    option and BINL is running then it updates the reply to include the
    BINL server information.

Arguments:

    RequestContext - A pointer to the current request context.

    DhcpOptions - A pointer to the DhcpOptions structure.

    Option - placeholder to put next option

    OptionEnd - end of buffer to put options

Return Value:

    ERROR_SUCCESS if binl supports this client, otherwise non-success error.

--*/
{
    //  Is this client looking for a BINL server and ours running?
    if ((RequestContext->BinlClassIdentifierLength >= (sizeof("PXEClient") -1)) &&
        (!memcmp(RequestContext->BinlClassIdentifier, "PXEClient",sizeof("PXEClient") -1)) &&
        (BinlRunning())) {

        DWORD err;
        LPDHCP_MESSAGE dhcpSendMessage;
        LPOPTION tempOption = Option;

        if (DhcpOptions->Server != NULL &&
            *DhcpOptions->Server != RequestContext->EndPointIpAddress) {

            goto ExcludeBinl;
        }

        dhcpSendMessage = (LPDHCP_MESSAGE) RequestContext->SendBuffer;

        err = (*BinlRequestCallback)(   (PDHCP_MESSAGE) RequestContext->ReceiveBuffer,
                                        DhcpOptions,
                                        &dhcpSendMessage->HostName[0],
                                        &dhcpSendMessage->BootFileName[0],
                                        &dhcpSendMessage->BootstrapServerAddress,
                                        &tempOption,
                                        OptionEnd
                                        );

        if (err != ERROR_SUCCESS) {

            goto ExcludeBinl;
        }

        //
        //  if the binl server didn't fill in the bootstrap server address
        //  but it worked, then it wants us to fill in the correct one.
        //

        if (dhcpSendMessage->BootstrapServerAddress == 0) {

            dhcpSendMessage->BootstrapServerAddress = RequestContext->EndPointIpAddress;
        }
        Option = tempOption;        // it worked and binl has added options

    } else {

ExcludeBinl:
        //  Avoid including BINL flag in the response.
        RequestContext->BinlClassIdentifierLength = 0;
        RequestContext->BinlClassIdentifier = NULL;
    }
    return Option;
}

VOID
BinlProcessDiscover(
    LPDHCP_REQUEST_CONTEXT  RequestContext,
    LPDHCP_SERVER_OPTIONS   DhcpOptions
    )
/*++

Routine Description:

    This routine takes a DHCP request packet. If it includes the PXEClient
    option and BINL is running then it updates the reply to include the
    BINL server information.

Arguments:

    RequestContext - A pointer to the current request context.

    DhcpOptions - A pointer to the DhcpOptions structure.

Return Value:

    ERROR_SUCCESS if binl supports this client, otherwise non-success error.

--*/
{
    DWORD err;

    //  Is this client looking for a BINL server and ours running?
    if ((RequestContext->BinlClassIdentifierLength >= (sizeof("PXEClient") -1)) &&
        (!memcmp(RequestContext->BinlClassIdentifier, "PXEClient",sizeof("PXEClient") -1)) &&
        (BinlRunning())) {

        if (DhcpOptions->Server != NULL &&
            *DhcpOptions->Server != RequestContext->EndPointIpAddress) {

            goto ExcludeBinl;
        }

        err = (*BinlDiscoverCallback)( (PDHCP_MESSAGE) RequestContext->ReceiveBuffer,
                                        DhcpOptions );

        if (err != ERROR_SUCCESS) {

            goto ExcludeBinl;
        }
        //  Yes so point the client at the BINL server.

        ((LPDHCP_MESSAGE)RequestContext->SendBuffer)->BootstrapServerAddress =
            RequestContext->EndPointIpAddress;

    } else {

ExcludeBinl:
        //  Avoid including BINL flag in the response.
        RequestContext->BinlClassIdentifierLength = 0;
        RequestContext->BinlClassIdentifier = NULL;
    }
    return;
}



BOOL
BinlRunning(
    VOID
    )
/*++

Routine Description:

    This routine determines if BINL is currently running. Note, The service may change
    state almost immediately so we may tell a client it's running even though it is
    stopped when it gets around to talking to it.

Arguments:

    None.

Return Value:

    True if running.

--*/
{
    if (!LoadDhcpToBinl()) {
        return FALSE;
    }

    return (*IsBinlRunning)();
}

BOOL
LoadDhcpToBinl(
    VOID
    )
/*++

Routine Description:

    This routine loads the pointers into the BINL dll

Arguments:

    None.

Return Value:

    TRUE - pointers loaded

--*/
{

    DWORD       Error;

    if (Loaded) {
        return TRUE;
    }

    if (AttemptedLoad) {
        return FALSE;   // We tried to load it once and failed.
    }

    AttemptedLoad = TRUE;

    //
    // Load the BINL DLL.
    //

    dllHandle = LoadLibrary( BINL_LIBRARY_NAME );
    if ( dllHandle == NULL ) {
        Error = GetLastError();
        DhcpPrint(( DEBUG_MISC, "Failed to load DLL %ws: %ld\n",
                     BINL_LIBRARY_NAME, Error));
        return FALSE;
    }

    //
    // Get the address of the service's main entry point.  This
    // entry point has a well-known name.
    //

    DhcpToBinl = (DhcpStateChange)GetProcAddress(dllHandle,
                                                BINL_STATE_ROUTINE_NAME);
    if ( DhcpToBinl == NULL ) {
        DhcpPrint(( DEBUG_MISC, "Failed to find entry %ws: %ld\n",
                     BINL_STATE_ROUTINE_NAME, GetLastError()));
        FreeLibrary(dllHandle);
        dllHandle = NULL;
        return FALSE;
    }

    IsBinlRunning = (ReturnBinlState)GetProcAddress(dllHandle,
                                            BINL_READ_STATE_ROUTINE_NAME);
    if ( BinlRunning == NULL ) {
        DhcpPrint(( DEBUG_MISC, "Failed to find entry %ws: %ld\n",
                     BINL_READ_STATE_ROUTINE_NAME, GetLastError()));
        FreeLibrary(dllHandle);
        dllHandle = NULL;
        return FALSE;
    }

    BinlDiscoverCallback = (ProcessBinlDiscoverCallback)GetProcAddress(dllHandle,
                                            BINL_DISCOVER_CALLBACK_ROUTINE_NAME);
    if ( BinlDiscoverCallback == NULL ) {
        DhcpPrint(( DEBUG_MISC, "Failed to find entry %ws: %ld\n",
                     BINL_DISCOVER_CALLBACK_ROUTINE_NAME, GetLastError()));
        FreeLibrary(dllHandle);
        dllHandle = NULL;
        return FALSE;
    }

    BinlRequestCallback = (ProcessBinlRequestCallback)GetProcAddress(dllHandle,
                                            BINL_REQUEST_CALLBACK_ROUTINE_NAME);
    if ( BinlRequestCallback == NULL ) {
        DhcpPrint(( DEBUG_MISC, "Failed to find entry %ws: %ld\n",
                     BINL_REQUEST_CALLBACK_ROUTINE_NAME, GetLastError()));
        FreeLibrary(dllHandle);
        dllHandle = NULL;
        return FALSE;
    }

    Loaded = TRUE;
    return TRUE;
}

VOID
UnLoadDhcpToBinl(
    VOID
    )
/*++

Routine Description:

    This routine unloads the pointers into the BINL dll

Arguments:

    None.

Return Value:

    None.

--*/
{

    if (dllHandle != NULL) {
        FreeLibrary(dllHandle);
        dllHandle = NULL;
    }

    AttemptedLoad = FALSE;
    Loaded = FALSE;
    return;
}

PCHAR
GetDhcpDomainName(
    VOID
    )
/*++

Routine Description:

    This routine returns the name of our domain to BINL.  We've discovered it
    through rogue detection.  BINL

Arguments:

    None.

Return Value:

    None.

--*/
{
    PCHAR domain = NULL;

    EnterCriticalSection( &DhcpGlobalBinlSyncCritSect );

    if ( DhcpGlobalDSDomainAnsi ) {

        domain = LocalAlloc( LPTR, strlen( DhcpGlobalDSDomainAnsi ) + 1 );

        if (domain != NULL) {
            strcpy( domain, DhcpGlobalDSDomainAnsi );
        }
    }
    LeaveCriticalSection( &DhcpGlobalBinlSyncCritSect );

    return domain;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\callout.c ===
/*++

Copyright (C) Microsoft Corporation 1997.

Module Name:

    callout.c

Abstract:

    Load and define macros for DHCP Server Callouts.

Author:

    Ramesh V K (Rameshv) Before March 1998.  Mabye in 1997.

--*/
#include <dhcppch.h>

//BeginExport(multiple-redef-prevention)
#ifndef   _CALLOUT_H_
#define   _CALLOUT_H_
//EndExport(multiple-redef-prevention)

//
// Types, Structs, Defines.
//

//BeginExport(defines)

//
// The location in registry where the REG_MULTI_SZ list of callout DLLs 
// that the DHCP Server will try to load.
//

#define   DHCP_CALLOUT_LIST_KEY    L"System\\CurrentControlSet\\Services\\DHCPServer\\Parameters"
#define   DHCP_CALLOUT_LIST_VALUE  L"CalloutDlls"
#define   DHCP_CALLOUT_LIST_TYPE   REG_MULTI_SZ
#define   DHCP_CALLOUT_ENTRY_POINT "DhcpServerCalloutEntry"
#define   DHCP_CALLOUT_ENABLE_VALUE L"CalloutEnabled"

//
// Control CODES used by DHCP Server to notify server state change.
//

#define   DHCP_CONTROL_START       0x00000001
#define   DHCP_CONTROL_STOP        0x00000002
#define   DHCP_CONTROL_PAUSE       0x00000003
#define   DHCP_CONTROL_CONTINUE    0x00000004

//
// Other ControlCodes used by various Callout HOOKS.
//

#define   DHCP_DROP_DUPLICATE      0x00000001     // duplicate of pkt being processed
#define   DHCP_DROP_NOMEM          0x00000002     // not enough server mem in queues
#define   DHCP_DROP_INTERNAL_ERROR 0x00000003     // ooops?
#define   DHCP_DROP_TIMEOUT        0x00000004     // too late, pkt is too old
#define   DHCP_DROP_UNAUTH         0x00000005     // server is not authorized to run
#define   DHCP_DROP_PAUSED         0x00000006     // service is paused
#define   DHCP_DROP_NO_SUBNETS     0x00000007     // no subnets configured on server
#define   DHCP_DROP_INVALID        0x00000008     // invalid packet or client
#define   DHCP_DROP_WRONG_SERVER   0x00000009     // client in different DS enterprise
#define   DHCP_DROP_NOADDRESS      0x0000000A     // no address available to offer
#define   DHCP_DROP_PROCESSED      0x0000000B     // packet has been processed
#define   DHCP_DROP_GEN_FAILURE    0x00000100     // catch-all error
#define   DHCP_SEND_PACKET         0x10000000     // send the packet on wire
#define   DHCP_PROB_CONFLICT       0x20000001     // address conflicted..
#define   DHCP_PROB_DECLINE        0x20000002     // an addr got declined
#define   DHCP_PROB_RELEASE        0x20000003     // an addr got released
#define   DHCP_PROB_NACKED         0x20000004     // a client is being nacked.
#define   DHCP_GIVE_ADDRESS_NEW    0x30000001     // give client a "new" address
#define   DHCP_GIVE_ADDRESS_OLD    0x30000002     // renew client's "old" address
#define   DHCP_CLIENT_BOOTP        0x30000003     // client is a BOOTP client
#define   DHCP_CLIENT_DHCP         0x30000004     // client is a DHCP client
//EndExport(defines)


//BeginExport(typedefs)

typedef
DWORD
(APIENTRY *LPDHCP_CONTROL)(
    IN DWORD dwControlCode,
    IN LPVOID lpReserved
)
/*++

Routine Description:

    This routine is called whenever the DHCP Server service is
    started, stopped, paused or continued as defined by the values of
    the dwControlCode parameter.  The lpReserved parameter is reserved
    for future use and it should not be interpreted in any way.   This
    routine should not block. 

Arguments:

    dwControlCode - one of the DHCP_CONTROL_* values
    lpReserved - reserved for future use.

--*/
;

typedef
DWORD
(APIENTRY *LPDHCP_NEWPKT)(
    IN OUT LPBYTE *Packet,
    IN OUT DWORD *PacketSize,
    IN DWORD IpAddress,
    IN LPVOID Reserved,
    IN OUT LPVOID *PktContext,
    OUT LPBOOL ProcessIt
)
/*++

Routine Description:

    This routine is called soon after the DHCP Server receives a
    packet that it attempts to process.  This routine is in the
    critical path of server execution and should return very fast, as
    otherwise server performance will be impacted.  The Callout DLL
    can modify the buffer or return a new buffer via the Packet,
    PacketSize arguments.  Also, if the callout DLL has internal
    structures to keep track of the packet and its progress, it can
    then return a context to this packet in the PktContext parameter.
    This context will be passed to almost all other hooks to indicate
    the packet being referred to.  Also, if the Callout DLL is
    planning on processing the packet or for some other reason the
    DHCP server is not expected to process this packet, then it can
    set the ProcessIt flag to FALSE to indicate that the packet is to
    be dropped. 
    
Arguments:

    Packet - This parameter points to a character buffer that holds
    the actual packet received by the DHCP Server. 

    PacketSize - This parameter points to a variable that holds the
    size of the above buffer. 

    IpAddress - This parameter points to an IPV4 host order IP address
    of the socket that this packet was received on. 

    Reserved -Reserved for future use.

    PktContect - This is an opaque pointer used by the DHCP Server for
    future references to this packet.  It is expected that the callout
    DLL will provide this pointer if it is interested in keeping track
    of the packet.  (See the descriptions for the hooks below for
    other usage of this Context). 

    ProcessIt - This is a BOOL flag that the CalloutDll can set to
    TRUE or reset to indicate if the DHCP Server should continue
    processing this packet or not, respectively. 

--*/
;

typedef
DWORD
(APIENTRY *LPDHCP_DROP_SEND)(
    IN OUT LPBYTE *Packet,
    IN OUT DWORD *PacketSize,
    IN DWORD ControlCode,
    IN DWORD IpAddress,
    IN LPVOID Reserved,
    IN LPVOID PktContext
)
/*++

Routine Description:

    This hook is called if a packet is (DropPktHook) dropped for some
    reason or if the packet is completely processed.   (If a packet is
    dropped, the hook is called twice as it is called once again to
    note that the packet has been completely processed).  The callout
    DLL should  be prepared to handle this hook multiple times for a
    packet. This routine should not block. The ControlCode parameter
    defines the reasons for the packet being dropped:  

    * DHCP_DROP_DUPLICATE - This packet is a duplicate of another
      received by the server. 
    * DHCP_DROP_NOMEM - Not enough memory to process the packet.
    * DHCP_DROP_INTERNAL_ERROR - Unexpected nternal error occurred.
    * DHCP_DROP_TIMEOUT - The packet is too old to process.
    * DHCP_DROP_UNAUTH - The server is not authorized.
    * DHCP_DROP_PAUSED - The server is paused.
    * DHCP_DROP_NO_SUBNETS - There are no subnets configured.
    * DHCP_DROP_INVALID - The packet is invalid or it came on an
      invalid socket .. 
    * DHCP_DROP_WRONG_SERVER - The packet was sent to the wrong DHCP Server.
    * DHCP_DROP_NOADDRESS - There is no address to offer.
    * DHCP_DROP_PROCESSED - The packet has been processed.
    * DHCP_DROP_GEN_FAILURE - An unknown error occurred.

    This routine is also called right before a response is sent down
    the wire (SendPktHook) and in this case the ControlCode has a
    value of DHCP_SEND_PACKET.

Arguments:

    Packet - This parameter points to a character buffer that holds
    the packet being processed by the DHCP Server. 

    PacketSize - This parameter points to a variable that holds the
    size of the above buffer. 

    ControlCode - See description for various control codes.

    IpAddress - This parameter points to an IPV4 host order IP address
    of the socket that this packet was received on. 

    Reserved - Reserved for future use.

    PktContext - This parameter is the packet context that the Callout
    DLL NewPkt Hook returned for this packet.  This can be used to
    track a packet. 
   
--*/
;

typedef 
DWORD 
(APIENTRY *LPDHCP_PROB)( 
    IN LPBYTE Packet, 
    IN DWORD PacketSize, 
    IN DWORD ControlCode, 
    IN DWORD IpAddress, 
    IN DWORD AltAddress, 
    IN LPVOID Reserved, 
    IN LPVOID PktContext 
)
/*++

Routine Description:

    This routine is called whenever special events occur that cause
    the packet to be dropped etc.  The possible ControlCodes and their
    meanings are as follows: 

    * DHCP_PROB_CONFLICT - The address attempted to be offered
      (AltAddress) is in use in the network already.  
    * DHCP_PROB_DECLINE - The packet was a DECLINE message for the
      address specified in AltAddress.
    * DHCP_PROB_RELEASE - The packet was a RELEASE message for the
      address specified in AltAddress.
    * DHCP_PROB_NACKED - The packet was a REQUEST message for address
      specified in AltAddress and it was NACKed by the server.  

    This routine should not block.  

Arguments:

    Packet - This parameter is the buffer of the packet being
    processed. 

    PacketSize - This is the size of the above buffer.

    ControlCode - Specifies the event. See description below for
    control codes and meanings. 

    IpAddress - IpV4 address of socket this packet was received on. 

    AltAddress - Request IpV4 Address or Ip address that is in
    conflict. 

    Reserved - Reserve for future use.

    PktContext - This is the context returned by the NewPkt hook for
    this packet. 

--*/
;

typedef 
DWORD 
(APIENTRY *LPDHCP_GIVE_ADDRESS)( 
    IN LPBYTE Packet, 
    IN DWORD PacketSize, 
    IN DWORD ControlCode, 
    IN DWORD IpAddress, 
    IN DWORD AltAddress, 
    IN DWORD AddrType, 
    IN DWORD LeaseTime, 
    IN LPVOID Reserved, 
    IN LPVOID PktContext 
)
/*++

Routine Description:

    This routine is called when the server is about to send an ACK to
    a REQUEST message.  The ControlCode specifies if the address is a
    totally new address or if it an renewal of an old address (with
    values DHCP_GIVE_ADDRESS_NEW and DHCP_GIVE_ADDRESS_OLD
    respectively). The address being offered is passed as the
    AltAddress parameter and the AddrType parameter can be one of
    DHCP_CLIENT_BOOTP or DHCP_CLIENT_DHCP indicating whether the
    client is using BOOTP or DHCP respectively. This call should not
    block.

Arguments:

    Packet - This parameter is the buffer of the packet being
    processed. 

    PacketSize - This is the size of the above buffer.

    ControlCode -  See description above for control codes and
    meanings. 

    IpAddress - IpV4 address of socket this packet was received on. 

    AltAddress - IpV4 address being ACKed to the client.

    AddrType - Is this a DHCP or BOOTP address?

    LeaseTime - Lease duration being passed.

    Reserved - Reserve for future use.

    PktContext - This is the context returned by the NewPkt hook for
    this packet. 

--*/
;

typedef
DWORD
(APIENTRY *LPDHCP_HANDLE_OPTIONS)(
    IN LPBYTE Packet,
    IN DWORD PacketSize,
    IN LPVOID Reserved,
    IN LPVOID PktContext,
    IN OUT LPDHCP_SERVER_OPTIONS ServerOptions
)
/*++

Routine Description:

    This routine can be utilized by the CalloutDLL to avoid parsing
    the whole packet.  The packet is parsed by the server and some
    commonly used options are returned in the parsed pointers
    structure (see header for definition of DHCP_SERVER_OPTIONS).  The
    hook is expected to make a copy of the structure pointed to by
    ServerOptions if it needs it beyond this function call.  This
    routine may be called several times for a single packet.  This
    routine should not block.

Arguments:

    Packet - This parameter is the buffer of the packet being
    processed. 

    PacketSize - This is the size of the above buffer.

    Reserved - Reserve for future use.

    PktContext - This is the context returned by the NewPkt hook for
    this packet. 

    ServerOptions - This parameter is the structure that contains a
    bunch of pointers that represent corresponding options. 

--*/
;

typedef 
DWORD 
(APIENTRY *LPDHCP_DELETE_CLIENT)( 
    IN DWORD IpAddress, 
    IN LPBYTE HwAddress, 
    IN ULONG HwAddressLength, 
    IN DWORD Reserved, 
    IN DWORD ClientType 
)
/*++

Routine Description:

    This routine is called before a client lease is deleted off the
    active leases database.  The ClientType field is currently not
    provided and this should not be used.  This routine should not
    block.  

Arguments:

    IpAddress - IpV4 address of the client lease being deleted.

    HwAddress - Buffer holding the Hardware address of the client (MAC).

    HwAddressLength - This specifies the length of the above buffer.

    Reserved - Reserved for future use.

    ClientType - Reserved for future use.
--*/
;

typedef
struct      _DHCP_CALLOUT_TABLE {
    LPDHCP_CONTROL                 DhcpControlHook;
    LPDHCP_NEWPKT                  DhcpNewPktHook;
    LPDHCP_DROP_SEND               DhcpPktDropHook;
    LPDHCP_DROP_SEND               DhcpPktSendHook;
    LPDHCP_PROB                    DhcpAddressDelHook;
    LPDHCP_GIVE_ADDRESS            DhcpAddressOfferHook;
    LPDHCP_HANDLE_OPTIONS          DhcpHandleOptionsHook;
    LPDHCP_DELETE_CLIENT           DhcpDeleteClientHook;
    LPVOID                         DhcpExtensionHook;
    LPVOID                         DhcpReservedHook;
}   DHCP_CALLOUT_TABLE, *LPDHCP_CALLOUT_TABLE;

typedef
DWORD
(APIENTRY *LPDHCP_ENTRY_POINT_FUNC) ( 
    IN LPWSTR ChainDlls, 
    IN DWORD CalloutVersion, 
    IN OUT LPDHCP_CALLOUT_TABLE CalloutTbl
)
/*++

Routine Description:

    This is the routine that is called by the DHCP Server when it
    successfully loads a DLL.    If the routine succeeds, then the
    DHCP Server does not attempt to load any of the DLLs specified in
    the ChainDlls list of DLLs.   If this function fails for some
    reason, then the DHCP Server proceeds to the next DLL in the
    ChainDlls structure.  

    Note that for version negotiation, the server may call this
    routine several times until a compatible version is found. 

    It is expected that the entrypoint routine would walk through the
    names of the dlls and attempt to load each of them and when it
    succeeds in retrieving the entry point, it attempts to get the
    cumulative set of hooks by repeating the above procedure (as done
    by the DHCP Server).  

Arguments:

    ChainDlls - This is a set of DLL names in REG_MULTI_SZ format (as
    returned by Registry function calls).  This does not contain the
    name of the current DLL itself, but only the names of all DLLs
    that follow the current DLL. 

    CalloutVersion - This is the version that the Callout DLL is
    expected to support.  The current version number is 0.

    CalloutTbl - This is the cumulative set of Hooks that is needed by
    the current DLLs as well as all the DLLs in ChainDlls.   It is the
    responsibility of the current DLL to retrive the cumulative set of
    Hooks and merge that with its own set of hooks and return that in
    this table structure.  The table structure is defined above.

--*/
;

//EndExport(typedefs)

//BeginExport(macros)

//
//  Macros for ease of use.  Lots of code to handle exceptions when
//  they happen.
//

#define    _PROTECT1               try
#define    _PROTECT2               \
except(EXCEPTION_EXECUTE_HANDLER) \
{ \
      DhcpCalloutLogAV(GetExceptionCode());\
} 

#define    _XX(Fn)                 Dhcp ## Fn ## Hook
#define    WRAPPER(Fn, Params)     \
do{ \
    _PROTECT1 { \
        if(CalloutTbl. _XX(Fn)){ \
            CalloutTbl. _XX(Fn) Params ;\
        }\
    } _PROTECT2 \
}while(0)

#define    _GiveAddrPkt(P,Code,Type,A,Time) \
WRAPPER(AddressOffer, ((P)->ReqContext.ReceiveBuffer,\
    (P)->ReqContext.ReceiveMessageSize,\
    (Code),\
    ntohl((P)->ReqContext.EndPointIpAddress),\
    (A),\
    (Type),\
    (Time),\
    (LPVOID)(P),\
    (LPVOID)((P)->CalloutContext))\
)

#define    _DropPkt(P,Drop,Code)   \
WRAPPER(PktDrop, (&((P)->ReqContext.ReceiveBuffer),\
    &((P)->ReqContext.ReceiveMessageSize),\
    (Code),\
    (P)->ReqContext.EndPointIpAddress,\
    (LPVOID)(P),\
    (LPVOID)((P)->CalloutContext))\
)

#define    _NewPkt(P,Dropit)       \
WRAPPER(NewPkt, ( &((P)->ReqContext.ReceiveBuffer),\
    &((P)->ReqContext.ReceiveMessageSize),\
    (P)->ReqContext.EndPointIpAddress,\
    (LPVOID)(P),\
    (LPVOID*)&((P)->CalloutContext),\
     Dropit)\
)

//
// CALLOUT_CONTROL( ControlCode )
//

#define    CALLOUT_CONTROL(_ccode) WRAPPER(Control, (_ccode, NULL))

//
// CALLOUT_NEWPKT( Packet, fProcessIt )
//

#define    CALLOUT_NEWPKT(P,Drop)  _NewPkt(P,Drop)

//
// CALLOUT_DROPPED(Packet, DropReason)
//

#define    CALLOUT_DROPPED(P,Code) _DropPkt(P,DropPkt, Code)

//
// CALLOUT_SENDPKT(Packet)
//

#define    CALLOUT_SENDPKT(P)      \
WRAPPER(PktSend, (&((P)->ReqContext.SendBuffer),\
    &((P)->ReqContext.SendMessageSize),\
    DHCP_SEND_PACKET,\
    (P)->ReqContext.EndPointIpAddress,\
    (LPVOID)(P),\
    (LPVOID)((P)->CalloutContext))\
)

#define    _ProbPkt(P,Code,A)      \
WRAPPER(AddressDel, ((P)->ReqContext.ReceiveBuffer,\
    (P)->ReqContext.ReceiveMessageSize,\
    (Code),\
    (P)->ReqContext.EndPointIpAddress,\
    (A),\
    (LPVOID)(P),\
    (LPVOID)((P)->CalloutContext))\
)

//
// CALLOUT_CONFLICT(Packet)
//

#define    CALLOUT_CONFLICT(P)     _ProbPkt(P, DHCP_PROB_CONFLICT,P->PingAddress)

//
// CALLOUT_DECLINED(Packet, Address)
//

#define    CALLOUT_DECLINED(P,A)   _ProbPkt(P, DHCP_PROB_DECLINE, A)

//
// CALLOUT_RELEASE(Packet, Address)
//

#define    CALLOUT_RELEASE(P,A)    _ProbPkt(P, DHCP_PROB_RELEASE, A)

//
// CALLOUT_NACK_DHCP(Packet, Address)
//

#define    CALLOUT_NACK_DHCP(P,A)  _ProbPkt(P, DHCP_PROB_NACKED, A)

//
// CALLOUT_RENEW_BOOTP(Packet, Address, LeaseTime)
//

#define    CALLOUT_RENEW_BOOTP(P,Addr,Time) \
    _GiveAddrPkt(P, DHCP_GIVE_ADDRESS_OLD, DHCP_CLIENT_BOOTP, Addr, Time)

//
// CALLOUT_RENEW_DHCP(Packet, Address, Time, fExists)
//

#define    CALLOUT_RENEW_DHCP(P,Addr,Time,Exists) \
    _GiveAddrPkt(P, (Exists)?DHCP_GIVE_ADDRESS_OLD: \
       DHCP_GIVE_ADDRESS_NEW,DHCP_CLIENT_DHCP, Addr, Time)

//
// CALLOUT_MARK_OPTIONS(Packet, DhcpServerOptions)
//

#define    CALLOUT_MARK_OPTIONS(P,DhcpOptions) \
WRAPPER(HandleOptions, ((P)->ReqContext.ReceiveBuffer,\
    (P)->ReqContext.ReceiveMessageSize,\
    (P), (LPVOID)((P)->CalloutContext), (DhcpOptions)))

//
// CALLOUT_PINGING(Packet)
//

#define    CALLOUT_PINGING(P)

//
// CALLOUT_DELETED(Address, HwAddress, HwLength, ClientType)
//

#define    CALLOUT_DELETED(Addr, HwAddr, HwLen, Type) \
    WRAPPER(DeleteClient, ((Addr), (HwAddr), (HwLen), 0, (Type)))

//EndExport(macros)

//BeginExport(externs)
extern
DHCP_CALLOUT_TABLE                 CalloutTbl;   // globals are init'ed to NULL
//EndExport(externs)

//BeginExport(multiple-redef-prevention)
#endif     _CALLOUT_H_
//EndExport(multiple-redef-prevention)

//
// Static Variables for this module
//

static BOOL Excepted = FALSE;
static DWORD Initialized = 0;
DHCP_CALLOUT_TABLE CalloutTbl;
HMODULE CalloutDll = NULL;

//
// Helper routines.
//

//BeginExport(fucntion)
VOID
DhcpCalloutLogAV(
    IN ULONG ExceptionCode
)   //EndExport(function)
/*++

Routine Description:

    This routine logs an event in the system event log about the fact
    that there was an exception in some of the callout DLLs.   It
    makes sure that this is done exactly once per server invocation. 

Arguments:

    ExceptionCode -- This ULONG value gives the exception number to log.

--*/
{
    DhcpPrint((DEBUG_ERRORS, "Callout caused 0x%lx"
               " exception. ignored\n",  ExceptionCode));
    if( FALSE == Excepted ) {
        Excepted = TRUE;
        DhcpServerEventLog(
            EVENT_SERVER_CALLOUT_UNHANDLED_EXCEPTION,
            EVENTLOG_ERROR_TYPE,
            ExceptionCode
        );
    }
}

//BeginExport(fucntion)
VOID
DhcpCalloutLogLoadFailure(
    IN      ULONG                  ExceptionCode
)   //EndExport(function)
/*++

Routine Description:

    This routine logs an event in the System event log.

Arguments:

    The exception code when the DLL LoadLibrary was attempted.

--*/
{
    DhcpPrint((DEBUG_ERRORS, "Callout caused 0x%lx " 
               "exception while loading. ignored\n", ExceptionCode));

    DhcpServerEventLog(
        EVENT_SERVER_CALLOUT_LOAD_EXCEPTION,
        EVENTLOG_ERROR_TYPE,
        ExceptionCode
        );
}

VOID
DhcpCalloutLogLoadSuccess(
    VOID
)
/*++

Routine Description:

   This routine logs the fact that a Callout DLL has been successfully
   loaded. 

--*/
{
    DhcpServerEventLog(
        EVENT_SERVER_CALLOUT_LOAD_SUCCESS,
        EVENTLOG_INFORMATION_TYPE,
        0
    );
}

DWORD
LoadDll(
    IN LPWSTR DllName,
    OUT HMODULE *Dll,
    OUT LPDHCP_ENTRY_POINT_FUNC *EntryPoint
)
/*++

Routine Description:

   This routine tries to load a DLL specified by the DllName parameter
   and retrive its entrypoint procedure.   It traps any exceptions
   generated by LoadLibrary and in case of error it returns the error
   code and also logs an event to this effect.

Arguments:

   DllName - wide character name of the DLL to load.
   Dll - output pointer where the module handle will be stored.
   EntryPoint - pointer to entrypoint procedure, filled in if
   successful.

Return Values:

   If the function succeeds, it returns ERROR_SUCCESS and fills in the
   paramters Dll and Entrypoint.

   On error, it returns Win32 errors.

--*/
{
    DWORD Err;

    try {
        //
        // Protect from any exceptions by the callout DLL
        //

        *Dll = NULL;
        *EntryPoint = NULL;

        *Dll = LoadLibrary(DllName);
        if( NULL != *Dll ) {
            *EntryPoint = (LPDHCP_ENTRY_POINT_FUNC)GetProcAddress( 
                *Dll, 
                DHCP_CALLOUT_ENTRY_POINT
                );
        } else {
            *EntryPoint = NULL;
        }

        if( NULL != *EntryPoint ) return ERROR_SUCCESS;

        //
        // Load failed.
        //

        Err = GetLastError();
        DhcpServerEventLog(
            EVENT_SERVER_CALLOUT_LOAD_FAILED,
            EVENTLOG_WARNING_TYPE,
            Err
            );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        DhcpCalloutLogLoadFailure(Err = GetExceptionCode());
    }
    
    if( *Dll ) FreeLibrary(*Dll);
    *Dll = NULL;
    *EntryPoint = NULL;
    return Err;
}

DWORD
GetTable(
    IN HMODULE Dll,
    IN LPWSTR DllList,
    IN LPDHCP_ENTRY_POINT_FUNC EntryPoint
)
/*++

Routine Description:

    This routine attempts to get the table of hooks from the
    entrypoint routine, and if it succeeds, it also remembers the Dll
    handle in the file-static variable CalloutDll.  It traps
    exceptions and returns the exception code as error.

Arguments:

    Dll -- DLL module handle
    
    DllList -- REG_MULTI_SZ format of Dll names of those that follow
    current DLL.

    EntryPoint -- entrypoint routine.

Returns:

    Returns ERROR_SUCCESS on Success and Win32 errors on failure.

--*/
{
    DWORD Err;

    try {
        //
        // Protect from exceptions caused by entrypoint table ..
        //

        DllList += wcslen(DllList) + 1;
        Err = EntryPoint(
            DllList,
            0,
            &CalloutTbl
            );
        if( ERROR_SUCCESS == Err ) {
            CALLOUT_CONTROL(DHCP_CONTROL_START);
            CalloutDll = Dll;
            DhcpCalloutLogLoadSuccess();
            return ERROR_SUCCESS;
        }

    } except( EXCEPTION_EXECUTE_HANDLER ) { 
        DhcpCalloutLogLoadFailure(Err = GetExceptionCode());
    }

    //
    // Cleanup on error
    //

    memset(&CalloutTbl,0,sizeof(CalloutTbl));
    CalloutDll = NULL;
    
    return Err;
}

VOID
FreeTable(                                        // free table and module..
    VOID
)
/*++

Routine description:

    This routine frees the library and cleans up the callout table. 

--*/
{
    DhcpAssert(NULL != CalloutDll); 
    if( NULL != CalloutDll ) {
        CALLOUT_CONTROL(DHCP_CONTROL_STOP);
        memset(&CalloutTbl,0,sizeof(CalloutTbl));
        FreeLibrary(CalloutDll);
        CalloutDll = NULL;
    }
}

//
// Exported Routines.
//

//BeginExport(function)
DWORD
CalloutInit(                                      // init callout fn table etc..
    VOID
)   //EndExport(function)
/*++

Routine Description:

    This routine reads the registry, initializes callout tables etc.
    It can be called multiple times (it executes only once).

    It is not thread safe, and it depends on debug module and the 
    eventlogger module, registry module.

Return Value:

    In case of failure, it returns Win32 errors and also cleans up its
    internal structures.

--*/
{
    DWORD Err;
    HKEY ParamKey;
    LPWSTR AllocedMem, DllList;
    LPDHCP_ENTRY_POINT_FUNC EntryPoint;
    HMODULE Dll;
    DWORD fEnabled;
    
    if( 0 != Initialized ) {
        return ERROR_SUCCESS;
    }

    Excepted = FALSE;

    Err = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        DHCP_CALLOUT_LIST_KEY,
        0,
        KEY_ALL_ACCESS,
        &ParamKey
    );
    if( ERROR_SUCCESS != Err ) {
        return ERROR_SUCCESS;
    }

    //
    // Do not load the callout DLLs if callouts are not enabled.
    //
    
    Err = DhcpRegGetValue(
        ParamKey, DHCP_CALLOUT_ENABLE_VALUE, REG_DWORD,
        (LPBYTE)&fEnabled );
    if( ERROR_SUCCESS == Err && 0 == fEnabled ) {
        RegCloseKey(ParamKey);
        return ERROR_SUCCESS;
    }
    
    DllList = NULL;
    Err = DhcpRegGetValue(
        ParamKey,
        DHCP_CALLOUT_LIST_VALUE,
        DHCP_CALLOUT_LIST_TYPE,
        (LPBYTE)&DllList
    );
    RegCloseKey(ParamKey);
    if( ERROR_SUCCESS != Err ) {
        return ERROR_SUCCESS;
    }

    for(  AllocedMem = DllList ;
          0 != wcslen(DllList) ; 
          DllList += 1 + wcslen(DllList)
        ) {

        Dll = NULL;
        Err = LoadDll(DllList, &Dll, &EntryPoint);
        if( ERROR_SUCCESS != Err ) {
            DhcpPrint((DEBUG_ERRORS, "Could not load dll:"
                       " %ws (0x%lx)\n", DllList, Err));
            continue; 
        }
        Err = GetTable(Dll, DllList, EntryPoint);
        if( ERROR_SUCCESS != Err ) {
            DhcpPrint((DEBUG_ERRORS, "Could not get tbl for" 
                       "  dll: %ws (0x%lx)\n", DllList, Err));
            FreeLibrary(Dll);
        } else {
            //
            // Loaded library, got entrypoint and callout tables..
            //

            Initialized ++;
            DhcpPrint((DEBUG_ERRORS, "Initialized callout dll"
                       " successfully\n")); 
            break;
        }
    }

    MIDL_user_free(AllocedMem);
    return ERROR_SUCCESS;
}

//BeginExport(function)
VOID
CalloutCleanup(
    VOID
)   //EndExport(function)
/*++

Routine Description:

    This routine is the converse of the Initialize routine and it
    cleans up any handles and the callout table.

--*/
{
    Initialized --;
    if(0 != Initialized) return ;
    FreeTable(); 
    Excepted = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\access.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    _access.c

Abstract:

    This module contains the dhcpserver security support routines
    which create security objects and enforce security _access checking.

Author:

    Madan Appiah (madana) 4-Apr-1994

Revision History:

--*/

#include "dhcppch.h"
#include <lmaccess.h>
#include <lmerr.h>

DWORD
DhcpCreateAndLookupSid(
    IN OUT PSID *Sid,
    IN GROUP_INFO_1 *GroupInfo
    )
/*++

Routine Description:
    This routine tries to create the SID required if it
    isn't already present. Also, it tries to lookup the SID
    if it isn't already present.

Arguments:
    Sid -- the sid to fill.
    GroupInfo -- the group information to create.
    
Return Values:
    Win32 errors.

--*/
{
    ULONG Status, Error;
    ULONG SidSize, ReferencedDomainNameSize;
    LPWSTR ReferencedDomainName;
    SID_NAME_USE SidNameUse;
    
    try {
        Status = NetLocalGroupAdd(
            NULL,
            1,
            (PVOID)GroupInfo,
            NULL
            );
        if( NERR_Success != Status
            && NERR_GroupExists != Status
            && ERROR_ALIAS_EXISTS != Status ) {
            //
            // Didn't create the group and group doesn't exist either.
            //
            Error = Status;
            
            DhcpPrint((DEBUG_ERRORS, "NetLocalGroupAdd(%ws) : 0x%lx\n",
                       GroupInfo->grpi1_name, Error));
            return Error;
        }
        
        //
        // Group created. Now lookup the SID.
        //
        SidSize = ReferencedDomainNameSize = 0;
        ReferencedDomainName = NULL;
        Status = LookupAccountName(
            NULL,
            GroupInfo->grpi1_name,
            (*Sid),
            &SidSize,
            ReferencedDomainName,
            &ReferencedDomainNameSize,
            &SidNameUse
            );
        if( Status ) return ERROR_SUCCESS;
        
        Error = GetLastError();
        if( ERROR_INSUFFICIENT_BUFFER != Error ) return Error;
        
        (*Sid) = DhcpAllocateMemory(SidSize);
        ReferencedDomainName = DhcpAllocateMemory(
            sizeof(WCHAR)*(1+ReferencedDomainNameSize)
            );
        if( NULL == (*Sid) || NULL == ReferencedDomainName ) {
            if( *Sid ) DhcpFreeMemory(*Sid);
            *Sid = NULL;
            if( ReferencedDomainNameSize ) {
                DhcpFreeMemory(ReferencedDomainName);
            }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        Status = LookupAccountName(
            NULL,
            GroupInfo->grpi1_name,
            (*Sid),
            &SidSize,
            ReferencedDomainName,
            &ReferencedDomainNameSize,
            &SidNameUse
            );
        if( 0 == Status ) {
            //
            // Failed.
            //
            Error = GetLastError();
            
            if( ReferencedDomainName ) {
                DhcpFreeMemory(ReferencedDomainName);
            }
            if( (*Sid ) ) DhcpFreeMemory( *Sid );
            (*Sid) = NULL;
            return Error;
        }
        
        if( ReferencedDomainName ) {
            DhcpFreeMemory(ReferencedDomainName);
        }
        Error = ERROR_SUCCESS;
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Error = GetExceptionCode();
    }
    
    return Error;
}
    
DWORD
DhcpCreateSecurityObjects(
    VOID
    )
/*++

Routine Description:

    This function creates the dhcpserver user-mode objects which are
    represented by security descriptors.

Arguments:

    None.

Return Value:

    WIN32 status code

--*/
{
    NTSTATUS Status;
    ULONG Error;

    //
    // Order matters!  These ACEs are inserted into the DACL in the
    // following order.  Security access is granted or denied based on
    // the order of the ACEs in the DACL.
    //
    //
    ACE_DATA AceData[] = {
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, GENERIC_ALL, &AliasAdminsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, DHCP_ALL_ACCESS, &AliasAccountOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, DHCP_ALL_ACCESS, &AliasSystemOpsSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, DHCP_ALL_ACCESS, &AliasPowerUsersSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, DHCP_ALL_ACCESS, &DhcpAdminSid},
        {ACCESS_ALLOWED_ACE_TYPE, 0, 0, DHCP_VIEW_ACCESS, &DhcpSid}
    };
    GROUP_INFO_1 DhcpGroupInfo = { 
        GETSTRING(DHCP_USERS_GROUP_NAME),
        GETSTRING(DHCP_USERS_GROUP_DESCRIPTION),
    };
    GROUP_INFO_1 DhcpAdminGroupInfo = {
        GETSTRING(DHCP_ADMINS_GROUP_NAME),
        GETSTRING(DHCP_ADMINS_GROUP_DESCRIPTION)
    };

    //
    // First try to create the DhcpReadOnly group..
    //

    Error = DhcpCreateAndLookupSid(
        &DhcpSid,
        &DhcpGroupInfo
        );

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "CreateAndLookupSid: %ld\n", Error));
        DhcpReportEventW(
            DHCP_EVENT_SERVER,
            EVENT_SERVER_READ_ONLY_GROUP_ERROR,
            EVENTLOG_ERROR_TYPE,
            0,
            sizeof(ULONG),
            NULL,
            (PVOID)&Error
            );
        return Error;
    }

    Error = DhcpCreateAndLookupSid(
        &DhcpAdminSid,
        &DhcpAdminGroupInfo
        );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "CreateAndLookupSid: %ld\n", Error));
        DhcpReportEventW(
            DHCP_EVENT_SERVER,
            EVENT_SERVER_ADMIN_GROUP_ERROR,
            EVENTLOG_ERROR_TYPE,
            0,
            sizeof(ULONG),
            NULL,
            (PVOID)&Error
            );
        return Error;
    }
    
    //
    // Actually create the security descriptor.
    //

    Status = NetpCreateSecurityObject(
        AceData,
        sizeof(AceData)/sizeof(AceData[0]),
        NULL, //LocalSystemSid,
        NULL, //LocalSystemSid,
        &DhcpGlobalSecurityInfoMapping,
        &DhcpGlobalSecurityDescriptor
        );
    
    // DhcpFreeMemory(Sid);
    return RtlNtStatusToDosError( Status );
}

DWORD
DhcpApiAccessCheck(
    ACCESS_MASK DesiredAccess
    )
/*++

Routine Description:

    This function checks to see the caller has required access to
    execute the calling API.

Arguments:

    DesiredAccess - required access to call the API.

Return Value:

    WIN32 status code

--*/
{
    DWORD Error;

    Error = NetpAccessCheckAndAudit(
                DHCP_SERVER,                        // Subsystem name
                DHCP_SERVER_SERVICE_OBJECT,         // Object typedef name
                DhcpGlobalSecurityDescriptor,       // Security descriptor
                DesiredAccess,                      // Desired access
                &DhcpGlobalSecurityInfoMapping );   // Generic mapping

    if(Error != ERROR_SUCCESS) {
        return( ERROR_ACCESS_DENIED );
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\callout.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

#ifndef   _CALLOUT_H_
#define   _CALLOUT_H_



//
// The location in registry where the REG_MULTI_SZ list of callout DLLs 
// that the DHCP Server will try to load.
//

#define   DHCP_CALLOUT_LIST_KEY    L"System\\CurrentControlSet\\Services\\DHCPServer\\Parameters"
#define   DHCP_CALLOUT_LIST_VALUE  L"CalloutDlls"
#define   DHCP_CALLOUT_LIST_TYPE   REG_MULTI_SZ
#define   DHCP_CALLOUT_ENTRY_POINT "DhcpServerCalloutEntry"
#define   DHCP_CALLOUT_ENABLE_VALUE L"CalloutEnabled"

//
// Control CODES used by DHCP Server to notify server state change.
//

#define   DHCP_CONTROL_START       0x00000001
#define   DHCP_CONTROL_STOP        0x00000002
#define   DHCP_CONTROL_PAUSE       0x00000003
#define   DHCP_CONTROL_CONTINUE    0x00000004

//
// Other ControlCodes used by various Callout HOOKS.
//

#define   DHCP_DROP_DUPLICATE      0x00000001     // duplicate of pkt being processed
#define   DHCP_DROP_NOMEM          0x00000002     // not enough server mem in queues
#define   DHCP_DROP_INTERNAL_ERROR 0x00000003     // ooops?
#define   DHCP_DROP_TIMEOUT        0x00000004     // too late, pkt is too old
#define   DHCP_DROP_UNAUTH         0x00000005     // server is not authorized to run
#define   DHCP_DROP_PAUSED         0x00000006     // service is paused
#define   DHCP_DROP_NO_SUBNETS     0x00000007     // no subnets configured on server
#define   DHCP_DROP_INVALID        0x00000008     // invalid packet or client
#define   DHCP_DROP_WRONG_SERVER   0x00000009     // client in different DS enterprise
#define   DHCP_DROP_NOADDRESS      0x0000000A     // no address available to offer
#define   DHCP_DROP_PROCESSED      0x0000000B     // packet has been processed
#define   DHCP_DROP_GEN_FAILURE    0x00000100     // catch-all error
#define   DHCP_SEND_PACKET         0x10000000     // send the packet on wire
#define   DHCP_PROB_CONFLICT       0x20000001     // address conflicted..
#define   DHCP_PROB_DECLINE        0x20000002     // an addr got declined
#define   DHCP_PROB_RELEASE        0x20000003     // an addr got released
#define   DHCP_PROB_NACKED         0x20000004     // a client is being nacked.
#define   DHCP_GIVE_ADDRESS_NEW    0x30000001     // give client a "new" address
#define   DHCP_GIVE_ADDRESS_OLD    0x30000002     // renew client's "old" address
#define   DHCP_CLIENT_BOOTP        0x30000003     // client is a BOOTP client
#define   DHCP_CLIENT_DHCP         0x30000004     // client is a DHCP client



typedef
DWORD
(APIENTRY *LPDHCP_CONTROL)(
    IN DWORD dwControlCode,
    IN LPVOID lpReserved
)
/*++

Routine Description:

    This routine is called whenever the DHCP Server service is
    started, stopped, paused or continued as defined by the values of
    the dwControlCode parameter.  The lpReserved parameter is reserved
    for future use and it should not be interpreted in any way.   This
    routine should not block. 

Arguments:

    dwControlCode - one of the DHCP_CONTROL_* values
    lpReserved - reserved for future use.

--*/
;

typedef
DWORD
(APIENTRY *LPDHCP_NEWPKT)(
    IN OUT LPBYTE *Packet,
    IN OUT DWORD *PacketSize,
    IN DWORD IpAddress,
    IN LPVOID Reserved,
    IN OUT LPVOID *PktContext,
    OUT LPBOOL ProcessIt
)
/*++

Routine Description:

    This routine is called soon after the DHCP Server receives a
    packet that it attempts to process.  This routine is in the
    critical path of server execution and should return very fast, as
    otherwise server performance will be impacted.  The Callout DLL
    can modify the buffer or return a new buffer via the Packet,
    PacketSize arguments.  Also, if the callout DLL has internal
    structures to keep track of the packet and its progress, it can
    then return a context to this packet in the PktContext parameter.
    This context will be passed to almost all other hooks to indicate
    the packet being referred to.  Also, if the Callout DLL is
    planning on processing the packet or for some other reason the
    DHCP server is not expected to process this packet, then it can
    set the ProcessIt flag to FALSE to indicate that the packet is to
    be dropped. 
    
Arguments:

    Packet - This parameter points to a character buffer that holds
    the actual packet received by the DHCP Server. 

    PacketSize - This parameter points to a variable that holds the
    size of the above buffer. 

    IpAddress - This parameter points to an IPV4 host order IP address
    of the socket that this packet was received on. 

    Reserved -Reserved for future use.

    PktContect - This is an opaque pointer used by the DHCP Server for
    future references to this packet.  It is expected that the callout
    DLL will provide this pointer if it is interested in keeping track
    of the packet.  (See the descriptions for the hooks below for
    other usage of this Context). 

    ProcessIt - This is a BOOL flag that the CalloutDll can set to
    TRUE or reset to indicate if the DHCP Server should continue
    processing this packet or not, respectively. 

--*/
;

typedef
DWORD
(APIENTRY *LPDHCP_DROP_SEND)(
    IN OUT LPBYTE *Packet,
    IN OUT DWORD *PacketSize,
    IN DWORD ControlCode,
    IN DWORD IpAddress,
    IN LPVOID Reserved,
    IN LPVOID PktContext
)
/*++

Routine Description:

    This hook is called if a packet is (DropPktHook) dropped for some
    reason or if the packet is completely processed.   (If a packet is
    dropped, the hook is called twice as it is called once again to
    note that the packet has been completely processed).  The callout
    DLL should  be prepared to handle this hook multiple times for a
    packet. This routine should not block. The ControlCode parameter
    defines the reasons for the packet being dropped:  

    * DHCP_DROP_DUPLICATE - This packet is a duplicate of another
      received by the server. 
    * DHCP_DROP_NOMEM - Not enough memory to process the packet.
    * DHCP_DROP_INTERNAL_ERROR - Unexpected nternal error occurred.
    * DHCP_DROP_TIMEOUT - The packet is too old to process.
    * DHCP_DROP_UNAUTH - The server is not authorized.
    * DHCP_DROP_PAUSED - The server is paused.
    * DHCP_DROP_NO_SUBNETS - There are no subnets configured.
    * DHCP_DROP_INVALID - The packet is invalid or it came on an
      invalid socket .. 
    * DHCP_DROP_WRONG_SERVER - The packet was sent to the wrong DHCP Server.
    * DHCP_DROP_NOADDRESS - There is no address to offer.
    * DHCP_DROP_PROCESSED - The packet has been processed.
    * DHCP_DROP_GEN_FAILURE - An unknown error occurred.

    This routine is also called right before a response is sent down
    the wire (SendPktHook) and in this case the ControlCode has a
    value of DHCP_SEND_PACKET.

Arguments:

    Packet - This parameter points to a character buffer that holds
    the packet being processed by the DHCP Server. 

    PacketSize - This parameter points to a variable that holds the
    size of the above buffer. 

    ControlCode - See description for various control codes.

    IpAddress - This parameter points to an IPV4 host order IP address
    of the socket that this packet was received on. 

    Reserved - Reserved for future use.

    PktContext - This parameter is the packet context that the Callout
    DLL NewPkt Hook returned for this packet.  This can be used to
    track a packet. 
   
--*/
;

typedef 
DWORD 
(APIENTRY *LPDHCP_PROB)( 
    IN LPBYTE Packet, 
    IN DWORD PacketSize, 
    IN DWORD ControlCode, 
    IN DWORD IpAddress, 
    IN DWORD AltAddress, 
    IN LPVOID Reserved, 
    IN LPVOID PktContext 
)
/*++

Routine Description:

    This routine is called whenever special events occur that cause
    the packet to be dropped etc.  The possible ControlCodes and their
    meanings are as follows: 

    * DHCP_PROB_CONFLICT - The address attempted to be offered
      (AltAddress) is in use in the network already.  
    * DHCP_PROB_DECLINE - The packet was a DECLINE message for the
      address specified in AltAddress.
    * DHCP_PROB_RELEASE - The packet was a RELEASE message for the
      address specified in AltAddress.
    * DHCP_PROB_NACKED - The packet was a REQUEST message for address
      specified in AltAddress and it was NACKed by the server.  

    This routine should not block.  

Arguments:

    Packet - This parameter is the buffer of the packet being
    processed. 

    PacketSize - This is the size of the above buffer.

    ControlCode - Specifies the event. See description below for
    control codes and meanings. 

    IpAddress - IpV4 address of socket this packet was received on. 

    AltAddress - Request IpV4 Address or Ip address that is in
    conflict. 

    Reserved - Reserve for future use.

    PktContext - This is the context returned by the NewPkt hook for
    this packet. 

--*/
;

typedef 
DWORD 
(APIENTRY *LPDHCP_GIVE_ADDRESS)( 
    IN LPBYTE Packet, 
    IN DWORD PacketSize, 
    IN DWORD ControlCode, 
    IN DWORD IpAddress, 
    IN DWORD AltAddress, 
    IN DWORD AddrType, 
    IN DWORD LeaseTime, 
    IN LPVOID Reserved, 
    IN LPVOID PktContext 
)
/*++

Routine Description:

    This routine is called when the server is about to send an ACK to
    a REQUEST message.  The ControlCode specifies if the address is a
    totally new address or if it an renewal of an old address (with
    values DHCP_GIVE_ADDRESS_NEW and DHCP_GIVE_ADDRESS_OLD
    respectively). The address being offered is passed as the
    AltAddress parameter and the AddrType parameter can be one of
    DHCP_CLIENT_BOOTP or DHCP_CLIENT_DHCP indicating whether the
    client is using BOOTP or DHCP respectively. This call should not
    block.

Arguments:

    Packet - This parameter is the buffer of the packet being
    processed. 

    PacketSize - This is the size of the above buffer.

    ControlCode -  See description above for control codes and
    meanings. 

    IpAddress - IpV4 address of socket this packet was received on. 

    AltAddress - IpV4 address being ACKed to the client.

    AddrType - Is this a DHCP or BOOTP address?

    LeaseTime - Lease duration being passed.

    Reserved - Reserve for future use.

    PktContext - This is the context returned by the NewPkt hook for
    this packet. 

--*/
;

typedef
DWORD
(APIENTRY *LPDHCP_HANDLE_OPTIONS)(
    IN LPBYTE Packet,
    IN DWORD PacketSize,
    IN LPVOID Reserved,
    IN LPVOID PktContext,
    IN OUT LPDHCP_SERVER_OPTIONS ServerOptions
)
/*++

Routine Description:

    This routine can be utilized by the CalloutDLL to avoid parsing
    the whole packet.  The packet is parsed by the server and some
    commonly used options are returned in the parsed pointers
    structure (see header for definition of DHCP_SERVER_OPTIONS).  The
    hook is expected to make a copy of the structure pointed to by
    ServerOptions if it needs it beyond this function call.  This
    routine may be called several times for a single packet.  This
    routine should not block.

Arguments:

    Packet - This parameter is the buffer of the packet being
    processed. 

    PacketSize - This is the size of the above buffer.

    Reserved - Reserve for future use.

    PktContext - This is the context returned by the NewPkt hook for
    this packet. 

    ServerOptions - This parameter is the structure that contains a
    bunch of pointers that represent corresponding options. 

--*/
;

typedef 
DWORD 
(APIENTRY *LPDHCP_DELETE_CLIENT)( 
    IN DWORD IpAddress, 
    IN LPBYTE HwAddress, 
    IN ULONG HwAddressLength, 
    IN DWORD Reserved, 
    IN DWORD ClientType 
)
/*++

Routine Description:

    This routine is called before a client lease is deleted off the
    active leases database.  The ClientType field is currently not
    provided and this should not be used.  This routine should not
    block.  

Arguments:

    IpAddress - IpV4 address of the client lease being deleted.

    HwAddress - Buffer holding the Hardware address of the client (MAC).

    HwAddressLength - This specifies the length of the above buffer.

    Reserved - Reserved for future use.

    ClientType - Reserved for future use.
--*/
;

typedef
struct      _DHCP_CALLOUT_TABLE {
    LPDHCP_CONTROL                 DhcpControlHook;
    LPDHCP_NEWPKT                  DhcpNewPktHook;
    LPDHCP_DROP_SEND               DhcpPktDropHook;
    LPDHCP_DROP_SEND               DhcpPktSendHook;
    LPDHCP_PROB                    DhcpAddressDelHook;
    LPDHCP_GIVE_ADDRESS            DhcpAddressOfferHook;
    LPDHCP_HANDLE_OPTIONS          DhcpHandleOptionsHook;
    LPDHCP_DELETE_CLIENT           DhcpDeleteClientHook;
    LPVOID                         DhcpExtensionHook;
    LPVOID                         DhcpReservedHook;
}   DHCP_CALLOUT_TABLE, *LPDHCP_CALLOUT_TABLE;

typedef
DWORD
(APIENTRY *LPDHCP_ENTRY_POINT_FUNC) ( 
    IN LPWSTR ChainDlls, 
    IN DWORD CalloutVersion, 
    IN OUT LPDHCP_CALLOUT_TABLE CalloutTbl
)
/*++

Routine Description:

    This is the routine that is called by the DHCP Server when it
    successfully loads a DLL.    If the routine succeeds, then the
    DHCP Server does not attempt to load any of the DLLs specified in
    the ChainDlls list of DLLs.   If this function fails for some
    reason, then the DHCP Server proceeds to the next DLL in the
    ChainDlls structure.  

    Note that for version negotiation, the server may call this
    routine several times until a compatible version is found. 

    It is expected that the entrypoint routine would walk through the
    names of the dlls and attempt to load each of them and when it
    succeeds in retrieving the entry point, it attempts to get the
    cumulative set of hooks by repeating the above procedure (as done
    by the DHCP Server).  

Arguments:

    ChainDlls - This is a set of DLL names in REG_MULTI_SZ format (as
    returned by Registry function calls).  This does not contain the
    name of the current DLL itself, but only the names of all DLLs
    that follow the current DLL. 

    CalloutVersion - This is the version that the Callout DLL is
    expected to support.  The current version number is 0.

    CalloutTbl - This is the cumulative set of Hooks that is needed by
    the current DLLs as well as all the DLLs in ChainDlls.   It is the
    responsibility of the current DLL to retrive the cumulative set of
    Hooks and merge that with its own set of hooks and return that in
    this table structure.  The table structure is defined above.

--*/
;




//
//  Macros for ease of use.  Lots of code to handle exceptions when
//  they happen.
//

#define    _PROTECT1               try
#define    _PROTECT2               \
except(EXCEPTION_EXECUTE_HANDLER) \
{ \
      DhcpCalloutLogAV(GetExceptionCode());\
} 

#define    _XX(Fn)                 Dhcp ## Fn ## Hook
#define    WRAPPER(Fn, Params)     \
do{ \
    _PROTECT1 { \
        if(CalloutTbl. _XX(Fn)){ \
            CalloutTbl. _XX(Fn) Params ;\
        }\
    } _PROTECT2 \
}while(0)

#define    _GiveAddrPkt(P,Code,Type,A,Time) \
WRAPPER(AddressOffer, ((P)->ReqContext.ReceiveBuffer,\
    (P)->ReqContext.ReceiveMessageSize,\
    (Code),\
    ntohl((P)->ReqContext.EndPointIpAddress),\
    (A),\
    (Type),\
    (Time),\
    (LPVOID)(P),\
    (LPVOID)((P)->CalloutContext))\
)

#define    _DropPkt(P,Drop,Code)   \
WRAPPER(PktDrop, (&((P)->ReqContext.ReceiveBuffer),\
    &((P)->ReqContext.ReceiveMessageSize),\
    (Code),\
    (P)->ReqContext.EndPointIpAddress,\
    (LPVOID)(P),\
    (LPVOID)((P)->CalloutContext))\
)

#define    _NewPkt(P,Dropit)       \
WRAPPER(NewPkt, ( &((P)->ReqContext.ReceiveBuffer),\
    &((P)->ReqContext.ReceiveMessageSize),\
    (P)->ReqContext.EndPointIpAddress,\
    (LPVOID)(P),\
    (LPVOID*)&((P)->CalloutContext),\
     Dropit)\
)

//
// CALLOUT_CONTROL( ControlCode )
//

#define    CALLOUT_CONTROL(_ccode) WRAPPER(Control, (_ccode, NULL))

//
// CALLOUT_NEWPKT( Packet, fProcessIt )
//

#define    CALLOUT_NEWPKT(P,Drop)  _NewPkt(P,Drop)

//
// CALLOUT_DROPPED(Packet, DropReason)
//

#define    CALLOUT_DROPPED(P,Code) _DropPkt(P,DropPkt, Code)

//
// CALLOUT_SENDPKT(Packet)
//

#define    CALLOUT_SENDPKT(P)      \
WRAPPER(PktSend, (&((P)->ReqContext.SendBuffer),\
    &((P)->ReqContext.SendMessageSize),\
    DHCP_SEND_PACKET,\
    (P)->ReqContext.EndPointIpAddress,\
    (LPVOID)(P),\
    (LPVOID)((P)->CalloutContext))\
)

#define    _ProbPkt(P,Code,A)      \
WRAPPER(AddressDel, ((P)->ReqContext.ReceiveBuffer,\
    (P)->ReqContext.ReceiveMessageSize,\
    (Code),\
    (P)->ReqContext.EndPointIpAddress,\
    (A),\
    (LPVOID)(P),\
    (LPVOID)((P)->CalloutContext))\
)

//
// CALLOUT_CONFLICT(Packet)
//

#define    CALLOUT_CONFLICT(P)     _ProbPkt(P, DHCP_PROB_CONFLICT,P->PingAddress)

//
// CALLOUT_DECLINED(Packet, Address)
//

#define    CALLOUT_DECLINED(P,A)   _ProbPkt(P, DHCP_PROB_DECLINE, A)

//
// CALLOUT_RELEASE(Packet, Address)
//

#define    CALLOUT_RELEASE(P,A)    _ProbPkt(P, DHCP_PROB_RELEASE, A)

//
// CALLOUT_NACK_DHCP(Packet, Address)
//

#define    CALLOUT_NACK_DHCP(P,A)  _ProbPkt(P, DHCP_PROB_NACKED, A)

//
// CALLOUT_RENEW_BOOTP(Packet, Address, LeaseTime)
//

#define    CALLOUT_RENEW_BOOTP(P,Addr,Time) \
    _GiveAddrPkt(P, DHCP_GIVE_ADDRESS_OLD, DHCP_CLIENT_BOOTP, Addr, Time)

//
// CALLOUT_RENEW_DHCP(Packet, Address, Time, fExists)
//

#define    CALLOUT_RENEW_DHCP(P,Addr,Time,Exists) \
    _GiveAddrPkt(P, (Exists)?DHCP_GIVE_ADDRESS_OLD: \
       DHCP_GIVE_ADDRESS_NEW,DHCP_CLIENT_DHCP, Addr, Time)

//
// CALLOUT_MARK_OPTIONS(Packet, DhcpServerOptions)
//

#define    CALLOUT_MARK_OPTIONS(P,DhcpOptions) \
WRAPPER(HandleOptions, ((P)->ReqContext.ReceiveBuffer,\
    (P)->ReqContext.ReceiveMessageSize,\
    (P), (LPVOID)((P)->CalloutContext), (DhcpOptions)))

//
// CALLOUT_PINGING(Packet)
//

#define    CALLOUT_PINGING(P)

//
// CALLOUT_DELETED(Address, HwAddress, HwLength, ClientType)
//

#define    CALLOUT_DELETED(Addr, HwAddr, HwLen, Type) \
    WRAPPER(DeleteClient, ((Addr), (HwAddr), (HwLen), 0, (Type)))



extern
DHCP_CALLOUT_TABLE                 CalloutTbl;   // globals are init'ed to NULL


#endif     _CALLOUT_H_


VOID
DhcpCalloutLogAV(
    IN ULONG ExceptionCode
) ;


VOID
DhcpCalloutLogLoadFailure(
    IN      ULONG                  ExceptionCode
) ;


DWORD
CalloutInit(                                      // init callout fn table etc..
    VOID
) ;


VOID
CalloutCleanup(
    VOID
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\cltapi.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cltapi.c

Abstract:

    This module contains the implementation of DHCP Client APIs.

Author:

    Madan Appiah (madana)  27-Sep-1993

Environment:

    User Mode - Win32

Revision History:

    Cheng Yang (t-cheny)  30-May-1996  superscope
    Cheng Yang (t-cheny)  24-Jun-1996  IP address detection, audit log


--*/

#include "dhcppch.h"
#include <ipexport.h>
#include <icmpif.h>
#include <icmpapi.h>
#include <thread.h>
#include <rpcapi.h>

#define IS_INFINITE_LEASE(DateTime)  \
    ( (DateTime).dwLowDateTime == DHCP_DATE_TIME_INFINIT_LOW && \
      (DateTime).dwHighDateTime == DHCP_DATE_TIME_INFINIT_HIGH )

#define IS_ZERO_LEASE(DateTime) \
    ((DateTime).dwLowDateTime == 0 && (DateTime).dwHighDateTime == 0)

DWORD
DhcpDeleteSubnetClients(
    DHCP_IP_ADDRESS SubnetAddress
    )
/*++

Routine Description:

    This functions cleans up all clients records of the specified subnet
    from the database.

Arguments:

    SubnetAddress : subnet address whose clients should be cleaned off.

Return Value:

    Database error code or ERROR_SUCCESS.

--*/
{
    DWORD Error, Count = 0;
    DWORD ReturnError = ERROR_SUCCESS;

    LOCK_DATABASE();

    Error = DhcpJetPrepareSearch(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                TRUE,   // Search from start
                NULL,
                0 );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // Walk through the entire database looking looking for the
    // specified subnet clients.
    //
    //

    for ( ;; ) {

        DWORD Size;
        DHCP_IP_ADDRESS IpAddress;
        DHCP_IP_ADDRESS SubnetMask;

        //
        // read IpAddress and SubnetMask to filter unwanted clients.
        //

        Size = sizeof(IpAddress);
        Error = DhcpJetGetValue(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
                    &IpAddress,
                    &Size );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
        DhcpAssert( Size == sizeof(IpAddress) );

        Size = sizeof(SubnetMask);
        Error = DhcpJetGetValue(
                    DhcpGlobalClientTable[SUBNET_MASK_INDEX].ColHandle,
                    &SubnetMask,
                    &Size );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
        DhcpAssert( Size == sizeof(SubnetMask) );

        if( (IpAddress & SubnetMask) == SubnetAddress ) {

            //
            // found a specified subnet client record , delete it.
            //

            Error = DhcpJetBeginTransaction();

            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }

            // Check if we can delete this IpAddress - should be able to do it
            // only if DynDns is already done..
            (void) DhcpDoDynDnsCheckDelete(IpAddress) ;

            // Actually, give DNS a chance and delete these anyway.
            Error = DhcpJetDeleteCurrentRecord();

            if( Error != ERROR_SUCCESS ) {

                DhcpPrint((DEBUG_ERRORS, "Deleting current record failed:%ld\n",  Error ));
                Error = DhcpJetRollBack();
                if( Error != ERROR_SUCCESS ) {
                    goto Cleanup;
                }

                goto ContinueError;
            }

            Error = DhcpJetCommitTransaction();

            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }

            Count ++;
        }

ContinueError:

        if( Error != ERROR_SUCCESS ) {

            DhcpPrint(( DEBUG_ERRORS,
                "Cleanup current database record failed, %ld.\n",
                    Error ));

            ReturnError = Error;
        }

        //
        // move to next record.
        //

        Error = DhcpJetNextRecord();

        if( Error != ERROR_SUCCESS ) {

            if( Error == ERROR_NO_MORE_ITEMS ) {
                Error = ERROR_SUCCESS;
                break;
            }

            goto Cleanup;
        }
    }

Cleanup:

    if( Error == ERROR_SUCCESS ) {
        Error = ReturnError;
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS,
            "DhcpDeleteSubnetClients failed, %ld.\n", Error ));
    }
    else  {
        DhcpPrint(( DEBUG_APIS,
            "DhcpDeleteSubnetClients finished successfully.\n" ));
    }

    DhcpPrint((DEBUG_APIS, "DhcpDeleteSubnetClients: deleted %ld  clients\n",
               Count));
    UNLOCK_DATABASE();
    return(Error);
}


DhcpGetCurrentClientInfo(
    LPDHCP_CLIENT_INFO_V4 *ClientInfo,
    LPDWORD InfoSize, // optional parameter.
    LPBOOL ValidClient, // optional parameter.
    DWORD SubnetAddress // optional parameter.
    )
/*++

Routine Description:

    This function retrieves current client information information. It
    allocates MIDL memory for the client structure (and for variable
    length structure fields). The caller is responsible to lock the
    database when this function is called.

Arguments:

    ClientInfo - pointer to a location where the client info structure
                    pointer is returned.

    InfoSize - pointer to a DWORD location where the number of bytes
                    consumed in the ClientInfo is returned.

    ValidClient - when this parameter is specified this
        function packs the current record only if the client

            1. belongs to the specified subnet.
            2. address state is ADDRESS_STATE_ACTIVE.

    SubnetAddress - the subnet address to filter client.

Return Value:

    Jet Errors.

--*/
{
    DWORD Error;
    LPDHCP_CLIENT_INFO_V4 LocalClientInfo = NULL;
    DWORD LocalInfoSize = 0;
    DWORD Size;
    DHCP_IP_ADDRESS IpAddress;
    DHCP_IP_ADDRESS SubnetMask;
    DHCP_IP_ADDRESS ClientSubnetAddress;
    BYTE AddressState;

    DhcpAssert( *ClientInfo == NULL );

    //
    // read IpAddress and SubnetMask to filter unwanted clients.
    //

    Size = sizeof(IpAddress);
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
                &IpAddress,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(IpAddress) );

    Size = sizeof(SubnetMask);
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[SUBNET_MASK_INDEX].ColHandle,
                &SubnetMask,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(SubnetMask) );

    Size = sizeof(AddressState);
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[STATE_INDEX].ColHandle,
                &AddressState,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(AddressState) );

    //
    // filter client if we are asked to do so.
    //

    if( ValidClient != NULL ) {

        //
        // don't filter client if the SubnetAddress is zero.
        //

        if( (SubnetAddress != 0) &&
                (IpAddress & SubnetMask) != SubnetAddress ) {
            *ValidClient = FALSE;
            Error = ERROR_SUCCESS;
            goto Cleanup;
        }

        // NT40 caller => should not return DELETED clients.
        if( IsAddressDeleted(AddressState) ) {
            *ValidClient = FALSE;
            Error = ERROR_SUCCESS;
            goto Cleanup;
        }

        *ValidClient = TRUE;
    }

    //
    // allocate return Buffer.
    //

    LocalClientInfo = MIDL_user_allocate( sizeof(DHCP_CLIENT_INFO_V4) );

    if( LocalClientInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalInfoSize = sizeof(DHCP_CLIENT_INFO_V4);

    LocalClientInfo->ClientIpAddress = IpAddress;
    LocalClientInfo->SubnetMask = SubnetMask;

    //
    // read additional client info from database.
    //

    LocalClientInfo->ClientHardwareAddress.DataLength = 0;
        // let DhcpJetGetValue allocates name buffer.
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
                &LocalClientInfo->ClientHardwareAddress.Data,
                &LocalClientInfo->ClientHardwareAddress.DataLength );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    LocalInfoSize += LocalClientInfo->ClientHardwareAddress.DataLength;

    //
    // strip off the client UID prefix.
    //

    ClientSubnetAddress = IpAddress & SubnetMask;

    if( (LocalClientInfo->ClientHardwareAddress.DataLength >
            sizeof(ClientSubnetAddress)) &&
         (memcmp( LocalClientInfo->ClientHardwareAddress.Data,
                    &ClientSubnetAddress,
                    sizeof(ClientSubnetAddress)) == 0) ) {

        DWORD PrefixSize;

        PrefixSize = sizeof(ClientSubnetAddress) + sizeof(BYTE);

        LocalClientInfo->ClientHardwareAddress.DataLength -= PrefixSize;

        memmove( LocalClientInfo->ClientHardwareAddress.Data,
                    (LPBYTE)LocalClientInfo->ClientHardwareAddress.Data +
                            PrefixSize,
                    LocalClientInfo->ClientHardwareAddress.DataLength );
    }

    Size = 0; // let DhcpJetGetValue allocates name buffer.
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
                &LocalClientInfo->ClientName,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if( LocalClientInfo->ClientName != NULL ) {
        DhcpAssert( (wcslen(LocalClientInfo->ClientName) + 1) *
                        sizeof(WCHAR) == Size );
    }
    else {
        DhcpAssert( Size == 0 );
    }

    LocalInfoSize += Size;

    Size = 0; // let DhcpJetGetValue allocates name buffer.
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[MACHINE_INFO_INDEX].ColHandle,
                &LocalClientInfo->ClientComment,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if( LocalClientInfo->ClientComment != NULL ) {
        DhcpAssert( (wcslen(LocalClientInfo->ClientComment) + 1) *
                        sizeof(WCHAR) == Size );
    }
    else {
        DhcpAssert( Size == 0 );
    }

    LocalInfoSize += Size;


    Size = sizeof( LocalClientInfo->bClientType );
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[ CLIENT_TYPE_INDEX ].ColHandle,
                &LocalClientInfo->bClientType,
                &Size );
    if ( ERROR_SUCCESS != Error )
        goto Cleanup;

    DhcpAssert( Size <=1 );

    if ( !Size )
    {
        //
        // this is a record that was present when the db was updated, and
        // doesn't yet have a client id.  Since the previous version of
        // DHCP server didn't support BOOTP, we know this must be a DHCP
        // lease.
        //

        Size = sizeof( LocalClientInfo->bClientType );
        LocalClientInfo->bClientType = CLIENT_TYPE_DHCP;
    }

    LocalInfoSize += Size;

    Size = sizeof( LocalClientInfo->ClientLeaseExpires );
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[LEASE_TERMINATE_INDEX].ColHandle,
                &LocalClientInfo->ClientLeaseExpires,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(LocalClientInfo->ClientLeaseExpires ) );

    RtlZeroMemory(
        &LocalClientInfo->OwnerHost, sizeof(LocalClientInfo->OwnerHost)
        );

    Size = sizeof( LocalClientInfo->OwnerHost.IpAddress );
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[SERVER_IP_ADDRESS_INDEX].ColHandle,
                &LocalClientInfo->OwnerHost.IpAddress,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    //DhcpAssert( Size == sizeof(LocalClientInfo->OwnerHost.IpAddress) );



    Size = 0;
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[SERVER_NAME_INDEX].ColHandle,
                &LocalClientInfo->OwnerHost.NetBiosName,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if ( LocalClientInfo->OwnerHost.NetBiosName != NULL ) {
        DhcpAssert( Size ==
            (wcslen(LocalClientInfo->OwnerHost.NetBiosName) + 1) *
                sizeof(WCHAR) );

    }
    else {
        DhcpAssert( Size == 0 );
    }
    
    LocalInfoSize += Size;

    *ClientInfo = LocalClientInfo;

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // if we aren't successful, return alloted memory.
        //

        if( LocalClientInfo != NULL ) {
            _fgs__DHCP_CLIENT_INFO ( LocalClientInfo );
        }
        LocalInfoSize = 0;
    }

    if( InfoSize != NULL ) {
        *InfoSize =  LocalInfoSize;
    }

    return( Error );
}

// same as above but for NT50.
DhcpGetCurrentClientInfoV5(
    LPDHCP_CLIENT_INFO_V5 *ClientInfo,
    LPDWORD InfoSize, // optional parameter.
    LPBOOL ValidClient, // optional parameter.
    DWORD SubnetAddress // optional parameter.
    )
/*++

Routine Description:

    This function retrieves current client information information. It
    allocates MIDL memory for the client structure (and for variable
    length structure fields). The caller is responsible to lock the
    database when this function is called.

Arguments:

    ClientInfo - pointer to a location where the client info structure
                    pointer is returned.

    InfoSize - pointer to a DWORD location where the number of bytes
                    consumed in the ClientInfo is returned.

    ValidClient - when this parameter is specified this
        function packs the current record only if the client

            1. belongs to the specified subnet.
            2. address state is ADDRESS_STATE_ACTIVE.

    SubnetAddress - the subnet address to filter client.

Return Value:

    Jet Errors.

--*/
{
    DWORD Error;
    LPDHCP_CLIENT_INFO_V5 LocalClientInfo = NULL;
    DWORD LocalInfoSize = 0;
    DWORD Size;
    DHCP_IP_ADDRESS IpAddress;
    DHCP_IP_ADDRESS SubnetMask;
    DHCP_IP_ADDRESS ClientSubnetAddress;
    DHCP_IP_ADDRESS realSubnetMask;
    BYTE AddressState;

    DhcpAssert( *ClientInfo == NULL );

    //
    // read IpAddress and SubnetMask to filter unwanted clients.
    //

    Size = sizeof(IpAddress);
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
                &IpAddress,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(IpAddress) );

    Size = sizeof(SubnetMask);
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[SUBNET_MASK_INDEX].ColHandle,
                &SubnetMask,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(SubnetMask) );

    Size = sizeof(AddressState);
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[STATE_INDEX].ColHandle,
                &AddressState,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(AddressState) );

    //
    // for several reasons, the subnet mask could be wrong?
    //

    realSubnetMask = DhcpGetSubnetMaskForAddress(IpAddress);
    // need to investigate those on a case by case basis.
    if( realSubnetMask != SubnetMask ) {
        DhcpPrint((DEBUG_ERRORS, "Ip Address <%s> ",inet_ntoa(*(struct in_addr *)&IpAddress)));
        DhcpPrint((DEBUG_ERRORS, "has subnet mask <%s> in db, must be ",inet_ntoa(*(struct in_addr *)&SubnetMask)));
        DhcpPrint((DEBUG_ERRORS, " <%s>\n",inet_ntoa(*(struct in_addr *)&realSubnetMask)));

        DhcpAssert(realSubnetMask == SubnetMask);
    }

    //
    // filter client if we are asked to do so.
    //

    if( ValidClient != NULL ) {

        //
        // don't filter client if the SubnetAddress is zero.
        //

        if( (SubnetAddress != 0) &&
                (IpAddress & realSubnetMask) != SubnetAddress ) {
            *ValidClient = FALSE;
            Error = ERROR_SUCCESS;
            goto Cleanup;
        }

        *ValidClient = TRUE;
    }

    //
    // allocate return Buffer.
    //

    LocalClientInfo = MIDL_user_allocate( sizeof(DHCP_CLIENT_INFO_V5) );

    if( LocalClientInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalInfoSize = sizeof(DHCP_CLIENT_INFO_V5);

    LocalClientInfo->ClientIpAddress = IpAddress;
    LocalClientInfo->SubnetMask = SubnetMask;
    LocalClientInfo->AddressState = AddressState;

    //
    // read additional client info from database.
    //

    LocalClientInfo->ClientHardwareAddress.DataLength = 0;
        // let DhcpJetGetValue allocates name buffer.
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
                &LocalClientInfo->ClientHardwareAddress.Data,
                &LocalClientInfo->ClientHardwareAddress.DataLength );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    LocalInfoSize += LocalClientInfo->ClientHardwareAddress.DataLength;

    //
    // strip off the client UID prefix.
    //

    ClientSubnetAddress = IpAddress & SubnetMask;

    if( (LocalClientInfo->ClientHardwareAddress.DataLength >
            sizeof(ClientSubnetAddress)) &&
         (memcmp( LocalClientInfo->ClientHardwareAddress.Data,
                    &ClientSubnetAddress,
                    sizeof(ClientSubnetAddress)) == 0) ) {

        DWORD PrefixSize;

        PrefixSize = sizeof(ClientSubnetAddress) + sizeof(BYTE);

        LocalClientInfo->ClientHardwareAddress.DataLength -= PrefixSize;

        memmove( LocalClientInfo->ClientHardwareAddress.Data,
                    (LPBYTE)LocalClientInfo->ClientHardwareAddress.Data +
                            PrefixSize,
                    LocalClientInfo->ClientHardwareAddress.DataLength );
    }

    Size = 0; // let DhcpJetGetValue allocates name buffer.
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
                &LocalClientInfo->ClientName,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if( LocalClientInfo->ClientName != NULL ) {
        DhcpAssert( (wcslen(LocalClientInfo->ClientName) + 1) *
                    sizeof(WCHAR) == Size );
    }
    else {
        DhcpAssert( Size == 0 );
    }

    LocalInfoSize += Size;

    Size = 0; // let DhcpJetGetValue allocates name buffer.
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[MACHINE_INFO_INDEX].ColHandle,
                &LocalClientInfo->ClientComment,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if( LocalClientInfo->ClientComment != NULL ) {
        DhcpAssert( (wcslen(LocalClientInfo->ClientComment) + 1) *
                        sizeof(WCHAR) == Size );
    }
    else {
        DhcpAssert( Size == 0 );
    }

    LocalInfoSize += Size;


    Size = sizeof( LocalClientInfo->bClientType );
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[ CLIENT_TYPE_INDEX ].ColHandle,
                &LocalClientInfo->bClientType,
                &Size );
    if ( ERROR_SUCCESS != Error )
        goto Cleanup;

    DhcpAssert( Size <=1 );

    if ( !Size )
    {
        //
        // this is a record that was present when the db was updated, and
        // doesn't yet have a client id.  Since the previous version of
        // DHCP server didn't support BOOTP, we know this must be a DHCP
        // lease.
        //

        Size = sizeof( LocalClientInfo->bClientType );
        LocalClientInfo->bClientType = CLIENT_TYPE_DHCP;
    }

    LocalInfoSize += Size;

    Size = sizeof( LocalClientInfo->ClientLeaseExpires );
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[LEASE_TERMINATE_INDEX].ColHandle,
                &LocalClientInfo->ClientLeaseExpires,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(LocalClientInfo->ClientLeaseExpires ) );

    RtlZeroMemory(
        &LocalClientInfo->OwnerHost, sizeof(LocalClientInfo->OwnerHost)
        );

    Size = sizeof( LocalClientInfo->OwnerHost.IpAddress );
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[SERVER_IP_ADDRESS_INDEX].ColHandle,
                &LocalClientInfo->OwnerHost.IpAddress,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(LocalClientInfo->OwnerHost.IpAddress) );



    Size = 0;
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[SERVER_NAME_INDEX].ColHandle,
                &LocalClientInfo->OwnerHost.NetBiosName,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if ( LocalClientInfo->OwnerHost.NetBiosName != NULL ) {
        DhcpAssert( Size ==
            (wcslen(LocalClientInfo->OwnerHost.NetBiosName) + 1) *
                sizeof(WCHAR) );

    }
    else {
        DhcpAssert( Size == 0 );
    }

    LocalInfoSize += Size;

    *ClientInfo = LocalClientInfo;

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // if we aren't successful, return alloted memory.
        //

        if( LocalClientInfo != NULL ) {
            _fgs__DHCP_CLIENT_INFO_V5 ( LocalClientInfo );
        }
        LocalInfoSize = 0;
    } else if( LocalClientInfo ) {
        //
        // Irrespective of leasetime we have to check ?
        //
        if( DhcpServerIsAddressReserved(
            DhcpGetCurrentServer(), IpAddress
        ) ){
            LocalClientInfo->bClientType |= CLIENT_TYPE_RESERVATION_FLAG;
        }

    }

    if( InfoSize != NULL ) {
        *InfoSize =  LocalInfoSize;
    }

    return( Error );
}

DWORD                                                  // DATABASE locks must be taken
DhcpCreateClientEntry(                                 // create a client record for a specific ip address
    IN      DHCP_IP_ADDRESS        ClientIpAddress,    // the address to create record for
    IN      LPBYTE                 ClientHardwareAddress,
    IN      DWORD                  HardwareAddressLength, // the hardware address --UID of the client
    IN      DATE_TIME              LeaseTerminates,    // when does the lease terminate
    IN      LPWSTR                 MachineName,        // machine name?
    IN      LPWSTR                 ClientInformation,  // other comment?
    IN      BYTE                   bClientType,        // DHCP_CLIENT_TYPE_ DHCP/BOOTP  [BOTH/NONE]
    IN      DHCP_IP_ADDRESS        ServerIpAddress,    // which server is this?
    IN      BYTE                   AddressState,       // what is the state of the address anyways?
    IN      BOOL                   OpenExisting        // is this record a totally fresh one or updating an old one?
)
{
    DHCP_IP_ADDRESS                RequestedClientAddress = ClientIpAddress;
    DHCP_IP_ADDRESS                SubnetMask;
    DWORD                          Error;
    DWORD                          LocalError;
    DATE_TIME                      LocalLeaseTerminates;
    JET_ERR                        JetError = JET_errSuccess;
    LPWSTR                         OldMachineName;
    BOOL                           BadAddress = FALSE;
    BYTE                           bAllowedClientTypes;
    BYTE                           PreviousAddressState;
    DWORD                          Size;

    DhcpAssert(0 != ClientIpAddress);
    if( ADDRESS_STATE_DECLINED == AddressState ) BadAddress = TRUE;

    LOCK_DATABASE();
    Error = DhcpJetBeginTransaction();
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    // Do any dirty work needed for DynDns stuff.
    // Essentially, if this address/hostname is getting overwritten (for some
    // reason), and if this address has not completed DynDns work yet, then
    // do that now.  On the other hand, if we are giving this address away
    // to someone else.. this should not really happen.
    DhcpDoDynDnsCreateEntryWork(
        &ClientIpAddress,                              // IpAddress for Update
        bClientType,                                   // Dhcp or Bootp or both?
        MachineName,                                   // Client Name, if known. else NULL
        &AddressState,                                 // New address state
        &OpenExisting,                                 // Do we expect a record to exist?
        BadAddress                                     // Is this a bad address
    );

    // Note that both AddressState and OpenExisting could get changed by the above function...

    Error = DhcpJetPrepareUpdate(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        (LPBYTE)&ClientIpAddress,
        sizeof( ClientIpAddress ),
        !OpenExisting
    );

    if( Error != ERROR_SUCCESS ) goto Cleanup;

    if( !OpenExisting ) {                              // update fixed info for new records
        Error = DhcpJetSetValue(
            DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
            (LPBYTE)&ClientIpAddress,
            sizeof( ClientIpAddress ) );

        if( Error != ERROR_SUCCESS )  goto Cleanup;
    }

    SubnetMask = DhcpGetSubnetMaskForAddress(ClientIpAddress);
    Error = DhcpJetSetValue(
        DhcpGlobalClientTable[SUBNET_MASK_INDEX].ColHandle,
        &SubnetMask,
        sizeof(SubnetMask)
    );

    if( Error != ERROR_SUCCESS ) goto Cleanup;

    //
    // bug #65666
    //
    // it was possible for dhcp server to lease the same address to multiple
    // clients in the following case:
    //
    // 1. dhcp server leases ip1 to client1.
    // 2. dhcp server receives a late arriving dhcpdiscover from client1.
    //    In response, the server changes the address state of ip1 to
    //    ADDRESS_STATE_OFFERED and sends an offer.
    // 3. Since client1 already received a lease, it doesn't reply to the offer.
    // 4. The scavenger thread runs and deletes the lease for ip1 ( since its state is
    //    ADDRESS_STATE_OFFERED.
    // 5. dhcp server leases ip1 to client2.
    //
    //
    // The solution is to check avoid changing an address from ADDRESS_STATE_ACTIVE
    // to ADDRESS_STATE_OFFERED.  This will prevent the scavenger thread from deleting
    // the lease.  Note that this requires a change to ProcessDhcpRequest - see the comments
    // in that function for details.
    //
    // The above is currently handled in DhcpDoDynDnsCreateEntryWork... so see there for info.
    // The function changes AddressState correctly, so we can always do the following.

    Error = DhcpJetSetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &AddressState,
        sizeof(AddressState)
    );

    DhcpAssert( (ClientHardwareAddress != NULL) && (HardwareAddressLength > 0) );

    // see cltapi.c@v27 for an #if0 re: #66286 bad address by ping

    if ( !BadAddress ) {
        Error = DhcpJetSetValue(
            DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
            ClientHardwareAddress,
            HardwareAddressLength
        );

        if( Error != ERROR_SUCCESS ) goto Cleanup;
    } else {
        Error = DhcpJetSetValue(
            DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
            (LPBYTE)&ClientIpAddress,
            sizeof(ClientIpAddress)
        );

        if( Error != ERROR_SUCCESS ) goto Cleanup;
    }

    // see cltapi.c@v27 for an #if0 re: #66286 (I think)

    if (BadAddress) {                                  // this address is in use somewhere
        Error = DhcpJetSetValue(
            DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
            GETSTRING( DHCP_BAD_ADDRESS_NAME ),
            (wcslen(GETSTRING(DHCP_BAD_ADDRESS_NAME)) + 1) * sizeof(WCHAR)
        );
        if( Error != ERROR_SUCCESS ) goto Cleanup;

        Error = DhcpJetSetValue(
            DhcpGlobalClientTable[MACHINE_INFO_INDEX].ColHandle,
            GETSTRING( DHCP_BAD_ADDRESS_INFO ),
            (wcslen(GETSTRING( DHCP_BAD_ADDRESS_INFO )) + 1) * sizeof(WCHAR)
        );
        if( Error != ERROR_SUCCESS ) goto Cleanup;

        LocalLeaseTerminates = LeaseTerminates;
        Error = DhcpJetSetValue(
            DhcpGlobalClientTable[LEASE_TERMINATE_INDEX].ColHandle,
            &LocalLeaseTerminates,
            sizeof(LeaseTerminates)
        );
        if( Error != ERROR_SUCCESS ) goto Cleanup;
    } else {
        // During DISCOVER time if machine name is not supplied and if
        // this is an existing record, dont overwrite the original name with NULL

        if ( !OpenExisting || MachineName ) {
            Error = DhcpJetSetValue(
                DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
                MachineName,
                (MachineName == NULL) ? 0 :
                (wcslen(MachineName) + 1) * sizeof(WCHAR)
            );
        }
        if( Error != ERROR_SUCCESS ) goto Cleanup;

        if ( !OpenExisting || ClientInformation ) {
            Error = DhcpJetSetValue(
                DhcpGlobalClientTable[MACHINE_INFO_INDEX].ColHandle,
                ClientInformation,
                (ClientInformation == NULL) ? 0 :
                (wcslen(ClientInformation) + 1) * sizeof(WCHAR)
            );
        }
        if( Error != ERROR_SUCCESS ) goto Cleanup;

        // For reserved clients set the time to a large value so that
        // they will not expire anytime. However zero lease time is
        // special case for unused reservations.
        //

        if( (LeaseTerminates.dwLowDateTime != DHCP_DATE_TIME_ZERO_LOW) &&
            (LeaseTerminates.dwHighDateTime != DHCP_DATE_TIME_ZERO_HIGH) &&
            DhcpServerIsAddressReserved(DhcpGetCurrentServer(), ClientIpAddress) ) {
            LocalLeaseTerminates.dwLowDateTime = DHCP_DATE_TIME_INFINIT_LOW;
            LocalLeaseTerminates.dwHighDateTime = DHCP_DATE_TIME_INFINIT_HIGH;
        } else {
            LocalLeaseTerminates = LeaseTerminates;
        }

        // If we are opening an existing client, we make sure that we don't
        // reset the lease to DHCP_CLIENT_REQUESTS_EXPIRE*2 time when we receive
        // a delayed/rogue discover packet. We also make sure that expiration time
        // is at least DHCP_CLIENT_REQUESTS_EXPIRE*2.

        // NOTE: this code has been removed as this would no longer occur -- no database entries
        // exists for clients who are just offered addresses -- only on requests do we fill in the db at all

        Error = DhcpJetSetValue(
            DhcpGlobalClientTable[LEASE_TERMINATE_INDEX].ColHandle,
            &LocalLeaseTerminates,
            sizeof(LeaseTerminates)
        );
        if( Error != ERROR_SUCCESS ) goto Cleanup;
    }

    Error = DhcpJetSetValue(
        DhcpGlobalClientTable[SERVER_NAME_INDEX].ColHandle,
        DhcpGlobalServerName,
        DhcpGlobalServerNameLen
    );
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    Error = DhcpJetSetValue(
        DhcpGlobalClientTable[SERVER_IP_ADDRESS_INDEX].ColHandle,
        &ServerIpAddress,
        sizeof(ServerIpAddress)
    );
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    Error = DhcpJetSetValue(
        DhcpGlobalClientTable[CLIENT_TYPE_INDEX].ColHandle,
        &bClientType,
        sizeof(bClientType )
    );
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    JetError = JetUpdate(                              // commit the changes
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        NULL,
        0,
        NULL
    );

    if( JET_errKeyDuplicate == JetError ) {
        DhcpAssert(FALSE);
        Error = ERROR_DHCP_JET_ERROR;
    } else Error = DhcpMapJetError(JetError, "CreateClientEntry:JetUpdate");

    if( Error != ERROR_SUCCESS ) goto Cleanup;

    if (BadAddress) {                                  // commit the transaction to record the bad address
        LocalError = DhcpJetCommitTransaction();
        DhcpAssert( LocalError == ERROR_SUCCESS );

        DhcpUpdateAuditLog(                        // log this activity
            DHCP_IP_LOG_CONFLICT,
            GETSTRING( DHCP_IP_LOG_CONFLICT_NAME ),
            ClientIpAddress,
            NULL,
            0,
            GETSTRING( DHCP_BAD_ADDRESS_NAME )
        );

        UNLOCK_DATABASE();
        return Error;
    }

Cleanup:

    if( ERROR_SUCCESS != Error ) {
        LocalError = DhcpJetRollBack();
        DhcpAssert(ERROR_SUCCESS == LocalError);
    } else {
        LocalError = DhcpJetCommitTransaction();
        DhcpAssert(ERROR_SUCCESS == LocalError);
    }
    UNLOCK_DATABASE();
    return Error;
}

DWORD
DhcpRemoveClientEntry(
    DHCP_IP_ADDRESS ClientIpAddress,
    LPBYTE HardwareAddress,
    DWORD HardwareAddressLength,
    BOOL ReleaseAddress,
    BOOL DeletePendingRecord
    )
/*++

Routine Description:

    This function removes a client entry from the client database.

Arguments:

    ClientIpAddress - The IP address of the client.

    HardwareAddress - client's hardware address.

    HardwareAddressLength - client's hardware address length.

    ReleaseAddress - if this flag is TRUE, release the address bit from
        registry, otherwise don't.

    DeletePendingRecord - if this flag is TRUE, the record is deleted
        only if the state of the record is ADDRESS_STATE_OFFERED.

Return Value:

    The status of the operation.

--*/
{
    JET_ERR JetError;
    DWORD Error;
    BOOL TransactBegin = FALSE;
    BYTE bAllowedClientTypes, bClientType;
    LPWSTR OldClientName = NULL;
    BYTE State;
    DWORD Size = sizeof(State);
    BOOL  Reserved = FALSE;

    LOCK_DATABASE();

    // start transaction before a create/update database record.
    Error = DhcpJetBeginTransaction();

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    TransactBegin = TRUE;

    JetError = JetSetCurrentIndex(
                    DhcpGlobalJetServerSession,
                    DhcpGlobalClientTableHandle,
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColName );

    Error = DhcpMapJetError( JetError, "RemoveClientEntry:SetCurrentIndex" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    JetError = JetMakeKey(
                    DhcpGlobalJetServerSession,
                    DhcpGlobalClientTableHandle,
                    &ClientIpAddress,
                    sizeof(ClientIpAddress),
                    JET_bitNewKey );

    Error = DhcpMapJetError( JetError, "RemoveClientEntry:MakeKey" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    JetError = JetSeek(
                    DhcpGlobalJetServerSession,
                    DhcpGlobalClientTableHandle,
                    JET_bitSeekEQ );

    Error = DhcpMapJetError( JetError, "RemoveClientEntry:Seek" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    // HARDWARE address match check removed.. see cltapi.c@v27 for other details.
    // (was already #if0'd)

    //
    // Get Client type -- we need that to figure out what kind of client it is
    // that we are trying to delete..
    //
    Size = sizeof(bClientType);
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[CLIENT_TYPE_INDEX].ColHandle,
        &bClientType,
        &Size
        );
    if( ERROR_SUCCESS != Error ) {
        bClientType = CLIENT_TYPE_DHCP;
    }

    //
    // if we are asked to delete only pending records, check it now.
    //
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &State,
        &Size );

    if( DeletePendingRecord ) {
        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        if(!IS_ADDRESS_STATE_OFFERED(State) )
        {
            DhcpPrint( ( DEBUG_ERRORS,
                         "DhcpRemoveClientEntry: Attempting to remove record with state == %d\n",
                          State )
                     );

            Error = ERROR_SUCCESS;
            goto Cleanup;
        }
    }

    //
    // if this is reserved entry, so don't remove.
    //

    { // get the machine name (required for Dyn Dns stuff) for possibly existing stuff.
        DWORD Size = 0; // DhcpJetGetValue would allocate space.
        Error = DhcpJetGetValue(
            DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
            &OldClientName,
            &Size );
    }

    if(Reserved = DhcpServerIsAddressReserved(DhcpGetCurrentServer(), ClientIpAddress )) {
        DATE_TIME ZeroDateTime;

        //
        // set the time value to zero to indicate that this reserved
        // address and it is no more in use.
        //

        ZeroDateTime.dwLowDateTime = DHCP_DATE_TIME_ZERO_LOW;
        ZeroDateTime.dwHighDateTime = DHCP_DATE_TIME_ZERO_HIGH;

        Error = DhcpJetPrepareUpdate(
            DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
            &ClientIpAddress,
            sizeof( ClientIpAddress ),
            FALSE
        );

        if( Error == ERROR_SUCCESS ) {
            Error = DhcpJetSetValue(
                DhcpGlobalClientTable[LEASE_TERMINATE_INDEX].ColHandle,
                &ZeroDateTime,
                sizeof(ZeroDateTime)
            );
            DhcpDoDynDnsReservationWork(ClientIpAddress, OldClientName, State);
            if( Error == ERROR_SUCCESS ) {
                Error = DhcpJetCommitUpdate();
            }
        }

        if( Error == ERROR_SUCCESS ) {
            Error = ERROR_DHCP_RESERVED_CLIENT;
        }

        goto Cleanup;
    }

    // Check if delete is safe from Dyn Dns point of view.
    if( DhcpDoDynDnsCheckDelete(ClientIpAddress) ) {
        JetError = JetDelete(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle );
        Error = DhcpMapJetError( JetError, "RemoveClientEntry:Delete" );
    } else Error = ERROR_SUCCESS;

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_ERRORS, "Could not delete client entry: %ld\n", JetError));
        goto Cleanup;
    }

    //
    // Finally, mark the IP address available
    //

    if( ReleaseAddress == TRUE ) {

        if( CLIENT_TYPE_BOOTP != bClientType ) {
            Error = DhcpReleaseAddress( ClientIpAddress );
        } else {
            Error = DhcpReleaseBootpAddress( ClientIpAddress );
        }

        //
        // it is ok if this address is not in the bit map.
        //

        if( ERROR_SUCCESS != Error ) {
            Error = ERROR_SUCCESS;
        }
    }

Cleanup:

    if ( (Error != ERROR_SUCCESS) &&
            (Error != ERROR_DHCP_RESERVED_CLIENT) ) {

        //
        // if the transaction has been started, than roll back to the
        // start point, so that we will not leave the database
        // inconsistence.
        //
        if( TransactBegin == TRUE ) {
            DWORD LocalError;

            LocalError = DhcpJetRollBack();
            DhcpAssert( LocalError == ERROR_SUCCESS );
        }

        DhcpPrint(( DEBUG_ERRORS, "Can't remove client entry from the "
                    "database, %ld.\n", Error));

    }
    else {

        //
        // commit the transaction before we return.
        //

        DWORD LocalError;

        DhcpAssert( TransactBegin == TRUE );

        LocalError = DhcpJetCommitTransaction();
        DhcpAssert( LocalError == ERROR_SUCCESS );
    }

    UNLOCK_DATABASE();

    if(OldClientName) DhcpFreeMemory(OldClientName);
    return( Error );
}

// return TRUE if address given out to this client, address not given out in DB or bad/declined/reconciled address
BOOL
DhcpIsClientValid(                                     // is it acceptable to offer this client the ipaddress?
    IN      DHCP_IP_ADDRESS        ClientIpAddress,
    IN      LPBYTE                 OptionHardwareAddress,
    IN      DWORD                  OptionHardwareAddressLength,
    OUT     BOOL                  *fReconciled
) {
    LPBYTE                         LocalHardwareAddress = NULL;
    LPSTR                          IpAddressString;
    DWORD                          Length;
    DWORD                          Error;
    BOOL                           ReturnStatus = TRUE;

    (*fReconciled) = FALSE;
    LOCK_DATABASE();

    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        &ClientIpAddress,
        sizeof( ClientIpAddress )
    );

    if ( Error != ERROR_SUCCESS ) goto Cleanup;

    Length = 0;
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
        &LocalHardwareAddress,
        &Length
    );

    DhcpAssert( Length != 0 );

    if (Length == OptionHardwareAddressLength + sizeof(ClientIpAddress) + sizeof(BYTE) &&
        (RtlCompareMemory(
            (LPBYTE) LocalHardwareAddress + sizeof(DHCP_IP_ADDRESS) + sizeof(BYTE),
            OptionHardwareAddress,
            Length - sizeof(DHCP_IP_ADDRESS) - sizeof(BYTE)
        ) == Length - sizeof(DHCP_IP_ADDRESS) - sizeof(BYTE))) {
        goto Cleanup;
    }

#if 1

    //
    // ?? this can be removed when all client UIDs are converted from
    // old farmat to new. OldFormat - just hardware address
    // NewFormat- Subnet + HWType + HWAddress.
    //

    if( Length == OptionHardwareAddressLength &&
        (RtlCompareMemory(LocalHardwareAddress,OptionHardwareAddress,Length) == Length) ) {
        goto Cleanup;
    }

#endif

    if( Length >= sizeof(ClientIpAddress) &&
        RtlCompareMemory(LocalHardwareAddress, (LPBYTE)&ClientIpAddress, sizeof(ClientIpAddress)) == sizeof(ClientIpAddress)) {
        // Bad address
        (*fReconciled) = TRUE;
        goto Cleanup;
    }

    IpAddressString = DhcpIpAddressToDottedString(ClientIpAddress);
    if( Length >= strlen(IpAddressString) &&
        RtlCompareMemory(LocalHardwareAddress, IpAddressString, strlen(IpAddressString)) == strlen(IpAddressString)) {
        // reconciled address?
        (*fReconciled) = TRUE;
        goto Cleanup;
    }

    ReturnStatus = FALSE;

Cleanup:

    UNLOCK_DATABASE();

    if( LocalHardwareAddress != NULL ) {
        MIDL_user_free( LocalHardwareAddress );
    }

    return( ReturnStatus );
}


BOOL
DhcpValidateClient(
    DHCP_IP_ADDRESS ClientIpAddress,
    PVOID HardwareAddress,
    DWORD HardwareAddressLength
    )
/*++

Routine Description:

    This function verifies that an IP address and hardware address match.

Arguments:

    ClientIpAddress - The IP address of the client.

    HardwareAddress - The hardware address of the client

    HardwareAddressLenght - The length, in bytes, of the hardware address.

Return Value:

    The status of the operation.

--*/
{
    LPBYTE LocalHardwareAddress = NULL;
    DWORD Length;
    DWORD Error;
    BOOL ReturnStatus = FALSE;

    LOCK_DATABASE();

    Error = DhcpJetOpenKey(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                &ClientIpAddress,
                sizeof( ClientIpAddress ) );

    if ( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Length = 0;
    Error = DhcpJetGetValue(
                DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
                &LocalHardwareAddress,
                &Length );

    DhcpAssert( Length != 0 );

    if (Length == HardwareAddressLength &&
        DhcpInSameSuperScope(
                *((LPDHCP_IP_ADDRESS) LocalHardwareAddress),
                *((LPDHCP_IP_ADDRESS) HardwareAddress))       &&
        (RtlCompareMemory(
                (LPBYTE) LocalHardwareAddress + sizeof(DHCP_IP_ADDRESS),
                (LPBYTE) HardwareAddress + sizeof(DHCP_IP_ADDRESS),
                Length - sizeof(DHCP_IP_ADDRESS) )
                    == Length - sizeof(DHCP_IP_ADDRESS)))
    {
        ReturnStatus = TRUE;
        goto Cleanup;
    }

#if 1

    //
    // ?? this can be removed when all client UIDs are converted from
    // old farmat to new. OldFormat - just hardware address
    // NewFormat- Subnet + HWType + HWAddress.
    //

    if ( (Length == (HardwareAddressLength -
                        sizeof(DHCP_IP_ADDRESS) - sizeof(BYTE))) &&
            (RtlCompareMemory(
                LocalHardwareAddress,
                (LPBYTE)HardwareAddress +
                    sizeof(DHCP_IP_ADDRESS) + sizeof(BYTE),
                Length ) == Length) ) {

        ReturnStatus = TRUE;
        goto Cleanup;
    }

#endif

Cleanup:

    UNLOCK_DATABASE();

    if( LocalHardwareAddress != NULL ) {
        MIDL_user_free( LocalHardwareAddress );
    }

    return( ReturnStatus );
}

//
// Client APIs
//


DWORD
R_DhcpCreateClientInfo(
    DHCP_SRV_HANDLE     ServerIpAddress,
    LPDHCP_CLIENT_INFO  ClientInfo
    )
/*++

Routine Description:
    This function is provided for use by older versions of the DHCP
    Manager application.  It's semantics are identical to
    R_DhcpCreateClientInfoV4.


Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_IP_ADDRESS_NOT_MANAGED - if the specified client
        IP address is not managed by the server.

    ERROR_DHCP_IP_ADDRESS_NOT_AVAILABLE - if the specified client IP
        address is not available. May be in use by some other client.

    ERROR_DHCP_CLIENT_EXISTS - if the client record exists already in
        server's database.

    Other WINDOWS errors.
--*/

{
    DWORD                dwResult;
    DHCP_CLIENT_INFO_V4 *pClientInfoV4;

    pClientInfoV4 = CopyClientInfoToV4( ClientInfo );

    if ( pClientInfoV4 )
    {
        pClientInfoV4->bClientType = CLIENT_TYPE_NONE;

        dwResult = R_DhcpCreateClientInfoV4(
                            ServerIpAddress,
                            pClientInfoV4
                            );
        _fgs__DHCP_CLIENT_INFO( pClientInfoV4 );
        MIDL_user_free( pClientInfoV4 );

    }
    else
        dwResult = ERROR_NOT_ENOUGH_MEMORY;


    return dwResult;
}


DWORD
R_DhcpCreateClientInfoV4(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPDHCP_CLIENT_INFO_V4 ClientInfo
    )
/*++

Routine Description:

    This function creates a client record in server's database. Also
    this marks the specified client IP address as unavailable (or
    distributed). This function returns error under the following cases :

    1. If the specified client IP address is not within the server
        management.

    2. If the specified client IP address is already unavailable.

    3. If the specified client record is already in the server's
        database.

    This function may be used to distribute IP addresses manually.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_IP_ADDRESS_NOT_MANAGED - if the specified client
        IP address is not managed by the server.

    ERROR_DHCP_IP_ADDRESS_NOT_AVAILABLE - if the specified client IP
        address is not available. May be in use by some other client.

    ERROR_DHCP_CLIENT_EXISTS - if the client record exists already in
        server's database.

    Other WINDOWS errors.
--*/
{
    DWORD Error;
    DHCP_IP_ADDRESS IpAddress;
    DHCP_IP_ADDRESS ClientSubnetMask;

    BYTE *ClientUID = NULL;
    DWORD ClientUIDLength;


    DhcpAssert( ClientInfo != NULL );

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    IpAddress = ClientInfo->ClientIpAddress;
    DhcpPrint(( DEBUG_APIS, "DhcpCreateClientInfo is called, (%s).\n",
                    DhcpIpAddressToDottedString(IpAddress) ));

    if( (ClientInfo->ClientHardwareAddress.Data == NULL) ||
            (ClientInfo->ClientHardwareAddress.DataLength == 0 )) {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // make client UID from client hardware address.
    //

    ClientSubnetMask = DhcpGetSubnetMaskForAddress( IpAddress );
    if( ClientSubnetMask == 0) {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    ClientUID = NULL;
    Error = DhcpMakeClientUID(
        ClientInfo->ClientHardwareAddress.Data,
        (BYTE)ClientInfo->ClientHardwareAddress.DataLength,
        HARDWARE_TYPE_10MB_EITHERNET,
        IpAddress & ClientSubnetMask,
        &ClientUID,
        &ClientUIDLength
    );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    DhcpAssert( (ClientUID != NULL) && (ClientUIDLength != 0) );

    //
    // DhcpCreateClientEntry locks database.
    //

    Error = DhcpCreateClientEntry(
        IpAddress,
        ClientUID,
        ClientUIDLength,
        ClientInfo->ClientLeaseExpires,
        ClientInfo->ClientName,
        ClientInfo->ClientComment,
        CLIENT_TYPE_NONE,
        DhcpRegKeyToIpAddress(ServerIpAddress),
        // IpAddress of the server
        ADDRESS_STATE_ACTIVE,   // make active immediately.
        FALSE                   // not existing..
    );

    if( Error == ERROR_SUCCESS ) {
        DhcpAssert( IpAddress == ClientInfo->ClientIpAddress);
    }
    else {

        //
        // if the specified address exists, then the client
        // already exists.
        //

        if( Error == ERROR_DHCP_ADDRESS_NOT_AVAILABLE ) {

            Error = ERROR_DHCP_CLIENT_EXISTS;
        }
    }

Cleanup:

    if( ClientUID != NULL ) {
        DhcpFreeMemory( ClientUID );
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_APIS, "DhcpCreateClientInfo failed, %ld.\n",
                        Error ));
    }

    return( Error );
}

DWORD
R_DhcpSetClientInfo(
    DHCP_SRV_HANDLE     ServerIpAddress,
    LPDHCP_CLIENT_INFO  ClientInfo
    )
/*++

Routine Description:

    This function sets client information record on the server's
    database.  It is provided for compatibility with older versions of
    the DHCP Administrator application.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the client information structure
        contains inconsistent data.

    Other WINDOWS errors.
--*/

{
    DHCP_CLIENT_INFO_V4 *pClientInfoV4 = NULL;
    DHCP_SEARCH_INFO    SearchInfo;
    DWORD               dwResult;


    //
    // first retrieve the existing client info
    //

    SearchInfo.SearchType                 = DhcpClientIpAddress;
    SearchInfo.SearchInfo.ClientIpAddress = ClientInfo->ClientIpAddress;


    dwResult = R_DhcpGetClientInfoV4(
                        ServerIpAddress,
                        &SearchInfo,
                        &pClientInfoV4
                        );

    //
    // the fields below are causing whistler bug 221104
    // setting them explicitly to NULL.
    //

    if ( pClientInfoV4 )
    {
        pClientInfoV4 -> OwnerHost.NetBiosName = NULL;
        pClientInfoV4 -> OwnerHost.HostName = NULL;
    }

    if ( ERROR_SUCCESS == dwResult )
    {
        BYTE bClientType;

        //
        // save the client type
        //

        bClientType = pClientInfoV4->bClientType;
        _fgs__DHCP_CLIENT_INFO( pClientInfoV4 );
        MIDL_user_free( pClientInfoV4 );

        pClientInfoV4 = CopyClientInfoToV4( ClientInfo );
        if ( pClientInfoV4 )
        {
            pClientInfoV4->bClientType = bClientType;

            dwResult = R_DhcpSetClientInfoV4(
                            ServerIpAddress,
                            pClientInfoV4
                            );

            _fgs__DHCP_CLIENT_INFO( pClientInfoV4 );
            MIDL_user_free( pClientInfoV4 );
        }
        else dwResult = ERROR_NOT_ENOUGH_MEMORY;

    }
    else
    {
        DhcpPrint( (DEBUG_APIS, "R_DhcpGetClientInfo failed from R_DhcpSetClientInfo: %d\n",
                                dwResult ));
    }

    return dwResult;
}


DWORD
R_DhcpSetClientInfoV4(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPDHCP_CLIENT_INFO_V4 ClientInfo
    )
/*++

Routine Description:

    This function sets client information record on the server's
    database.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the client information structure
        contains inconsistent data.

    Other WINDOWS errors.
--*/
{
    DWORD Error;
    DHCP_REQUEST_CONTEXT   DummyCtxt;
    DHCP_IP_ADDRESS IpAddress;
    DHCP_IP_ADDRESS ClientSubnetMask;
    DHCP_IP_ADDRESS ClientSubnetAddress;

    BYTE *ClientUID = NULL;
    DWORD ClientUIDLength;

    BYTE *SetClientUID = NULL;
    DWORD SetClientUIDLength;

    WCHAR KeyBuffer[DHCP_IP_KEY_LEN * 5];
    LPWSTR KeyName;

    HKEY ReservedIpHandle = NULL;

    DhcpAssert( ClientInfo != NULL );

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    IpAddress = ClientInfo->ClientIpAddress;
    DhcpPrint(( DEBUG_APIS, "DhcpSetClientInfo is called, (%s).\n",
                    DhcpIpAddressToDottedString(IpAddress) ));

    if( (ClientInfo->ClientHardwareAddress.Data == NULL) ||
            (ClientInfo->ClientHardwareAddress.DataLength == 0 )) {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // make client UID from client hardware address, if the caller just
    // specified hardware address.
    //

    ClientSubnetMask = DhcpGetSubnetMaskForAddress( IpAddress );
    if( ClientSubnetMask == 0) {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    ClientSubnetAddress = IpAddress & ClientSubnetMask;

    if( (ClientInfo->ClientHardwareAddress.DataLength >
            sizeof(ClientSubnetAddress)) &&
         (memcmp( ClientInfo->ClientHardwareAddress.Data,
                    &ClientSubnetAddress,
                    sizeof(ClientSubnetAddress)) == 0) ) {

        SetClientUID = ClientInfo->ClientHardwareAddress.Data;
        SetClientUIDLength =
            (BYTE)ClientInfo->ClientHardwareAddress.DataLength;
    }
    else {
        ClientUID = NULL;
        Error = DhcpMakeClientUID(
            ClientInfo->ClientHardwareAddress.Data,
            (BYTE)ClientInfo->ClientHardwareAddress.DataLength,
            HARDWARE_TYPE_10MB_EITHERNET,
            IpAddress & ClientSubnetMask,
            &ClientUID,
            &ClientUIDLength
        );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        DhcpAssert( (ClientUID != NULL) && (ClientUIDLength != 0) );

        SetClientUID = ClientUID;
        SetClientUIDLength = ClientUIDLength;
    }

    //
    // DhcpCreateClientEntry locks database.
    //

    IpAddress = ClientInfo->ClientIpAddress;
    DummyCtxt.Server = DhcpGetCurrentServer();
    Error = DhcpRequestSpecificAddress(
        &DummyCtxt,
        IpAddress
    );
    // if( ERROR_SUCCESS != Error ) goto Cleanup;

    Error = DhcpCreateClientEntry(
                IpAddress,
                SetClientUID,
                SetClientUIDLength,
                ClientInfo->ClientLeaseExpires,
                ClientInfo->ClientName,
                ClientInfo->ClientComment,
                CLIENT_TYPE_NONE,
                ClientInfo->OwnerHost.IpAddress,
                ADDRESS_STATE_ACTIVE,   // make active immediately.
                TRUE );                 // Existing

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    DhcpAssert( IpAddress == ClientInfo->ClientIpAddress);


    Error = DhcpBeginWriteApi("DhcpSetClientInfoV4");
    if( NO_ERROR != Error ) goto Cleanup;
    
    if( DhcpServerIsAddressReserved(DhcpGetCurrentServer(), IpAddress ) ) {
        Error = DhcpUpdateReservationInfo(
            IpAddress,
            SetClientUID,
            SetClientUIDLength
        );

        Error = DhcpEndWriteApiEx(
            "DhcpSetClientInfoV4", Error, FALSE, FALSE, 0, 0,
            IpAddress );
    } else {

        Error = DhcpEndWriteApi("DhcpSetClientInfoV4", Error);
    }

    if( Error != ERROR_SUCCESS ) goto Cleanup;

Cleanup:

    if( ClientUID != NULL ) {
        DhcpFreeMemory( ClientUID );
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_APIS, "DhcpSetClientInfo failed, %ld.\n",
                        Error ));
    }

    if( ReservedIpHandle != NULL ) {
        RegCloseKey( ReservedIpHandle );
    }

    return( Error );
}

DWORD
R_DhcpGetClientInfo(
    DHCP_SRV_HANDLE     ServerIpAddress,
    LPDHCP_SEARCH_INFO  SearchInfo,
    LPDHCP_CLIENT_INFO  *ClientInfo
    )
/*++

Routine Description:

    This function sets client information record on the server's
    database.  It is provided for use by older versions of the DHCP
    Administrator application.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the client information structure
        contains inconsistent data.

    Other WINDOWS errors.
--*/

{
    DHCP_CLIENT_INFO_V4 *pClientInfoV4 = NULL;
    DWORD                dwResult;

    dwResult = R_DhcpGetClientInfoV4(
                    ServerIpAddress,
                    SearchInfo,
                    &pClientInfoV4
                    );

    if ( ERROR_SUCCESS == dwResult )
    {
        //
        // since the V4 fields are at the end of the struct, it is safe to
        // simply return the V4 struct
        //

        *ClientInfo = ( DHCP_CLIENT_INFO *) pClientInfoV4;
    }

    return dwResult;
}


DWORD
R_DhcpGetClientInfoV4(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPDHCP_SEARCH_INFO SearchInfo,
    LPDHCP_CLIENT_INFO_V4 *ClientInfo
    )
/*++

Routine Description:

    This function retrieves client information record from the server's
    database.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SearchInfo : Pointer to a search information record which is the key
        for the client's record search.

    ClientInfo : Pointer to a location where the pointer to the client
        information structure is returned. This caller should free up
        this buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the search information invalid.

    Other WINDOWS errors.
--*/
{
    DWORD Error;
    LPDHCP_CLIENT_INFO_V4 LocalClientInfo = NULL;

    DhcpAssert( SearchInfo != NULL );

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    LOCK_DATABASE();

    //
    // open appropriate record and set current position.
    //

    switch( SearchInfo->SearchType ) {
    case DhcpClientIpAddress:
        DhcpPrint(( DEBUG_APIS, "DhcpGetClientInfo is called, (%s).\n",
                        DhcpIpAddressToDottedString(
                            SearchInfo->SearchInfo.ClientIpAddress) ));
        Error = DhcpJetOpenKey(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                    &SearchInfo->SearchInfo.ClientIpAddress,
                    sizeof( DHCP_IP_ADDRESS ) );

        break;
    case DhcpClientHardwareAddress:
        DhcpPrint(( DEBUG_APIS, "DhcpGetClientInfo is called "
                        "with HW address.\n"));
        Error = DhcpJetOpenKey(
                    DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColName,
                    SearchInfo->SearchInfo.ClientHardwareAddress.Data,
                    SearchInfo->SearchInfo.ClientHardwareAddress.DataLength );

        break;
    case DhcpClientName:
        DhcpPrint(( DEBUG_APIS, "DhcpGetClientInfo is called, (%ws).\n",
                        SearchInfo->SearchInfo.ClientName ));

        if( SearchInfo->SearchInfo.ClientName == NULL ) {
            Error = ERROR_INVALID_PARAMETER;
            break;
        }

        Error = DhcpJetOpenKey(
                    DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColName,
                    SearchInfo->SearchInfo.ClientName,
                    (wcslen(SearchInfo->SearchInfo.ClientName) + 1) *
                        sizeof(WCHAR) );

        break;
    default:
        DhcpPrint(( DEBUG_APIS, "DhcpGetClientInfo is called "
                        "with invalid parameter.\n"));
        Error = ERROR_INVALID_PARAMETER;
        break;
    }


    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpGetCurrentClientInfo( ClientInfo, NULL, NULL, 0 );

Cleanup:

    UNLOCK_DATABASE();

    if( Error != ERROR_SUCCESS ) {

        DhcpPrint(( DEBUG_APIS, "DhcpGetClientInfo failed, %ld.\n",
                        Error ));
    }

    return( Error );
}


DWORD
R_DhcpDeleteClientInfo(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPDHCP_SEARCH_INFO ClientInfo
    )
/*++

Routine Description:

    This function deletes the specified client record. Also it frees up
    the client IP address for redistribution.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to a client information which is the key for
        the client's record search.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    Other WINDOWS errors.
--*/
{
    DWORD Error;
    DHCP_IP_ADDRESS FreeIpAddress, SubnetAddress;
    DWORD Size;
    LPBYTE HardwareAddress = NULL, Hw;
    DWORD HardwareAddressLength = 0, HwLen, HwType;
    BOOL TransactBegin = FALSE;
    BYTE bAllowedClientTypes, bClientType;
    BYTE AddressState;
    BOOL AlreadyDeleted = FALSE;

    DhcpAssert( ClientInfo != NULL );

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    // lock both registry and database locks here to avoid dead lock.
    //

    LOCK_DATABASE();

    //
    // start transaction before a create/update database record.
    //

    Error = DhcpJetBeginTransaction();

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    TransactBegin = TRUE;

    //
    // open appropriate record and set current position.
    //

    switch( ClientInfo->SearchType ) {
    case DhcpClientIpAddress:
        DhcpPrint(( DEBUG_APIS, "DhcpDeleteClientInfo is called, (%s).\n",
                        DhcpIpAddressToDottedString(
                            ClientInfo->SearchInfo.ClientIpAddress) ));
        Error = DhcpJetOpenKey(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                    &ClientInfo->SearchInfo.ClientIpAddress,
                    sizeof( DHCP_IP_ADDRESS ) );
        break;
    case DhcpClientHardwareAddress:
        DhcpPrint(( DEBUG_APIS, "DhcpDeleteClientInfo is called "
                        "with HW address.\n"));
        Error = DhcpJetOpenKey(
                    DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColName,
                    ClientInfo->SearchInfo.ClientHardwareAddress.Data,
                    ClientInfo->SearchInfo.ClientHardwareAddress.DataLength );
        break;
    case DhcpClientName:
        DhcpPrint(( DEBUG_APIS, "DhcpDeleteClientInfo is called, (%ws).\n",
                        ClientInfo->SearchInfo.ClientName ));

        if( ClientInfo->SearchInfo.ClientName == NULL ) {
            Error = ERROR_INVALID_PARAMETER;
            break;
        }

        Error = DhcpJetOpenKey(
                    DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColName,
                    ClientInfo->SearchInfo.ClientName,
                    (wcslen(ClientInfo->SearchInfo.ClientName) + 1) *
                        sizeof(WCHAR) );
        break;

    default:
        DhcpPrint(( DEBUG_APIS, "DhcpDeleteClientInfo is called "
                        "with invalid parameter.\n"));
        Error = ERROR_INVALID_PARAMETER;
        break;
    }


    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // read IpAddress and Hardware Address info from database.
    //

    Size = sizeof(DHCP_IP_ADDRESS);
    Error = DhcpJetGetValue(
            DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
            &FreeIpAddress,
            &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpJetGetValue(
            DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
            &HardwareAddress,
            &HardwareAddressLength );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }


#if DBG

    switch( ClientInfo->SearchType ) {
    case DhcpClientIpAddress:
        DhcpAssert(
            FreeIpAddress ==
                ClientInfo->SearchInfo.ClientIpAddress );
        break;
    case DhcpClientHardwareAddress:

        DhcpAssert(
            HardwareAddressLength ==
                ClientInfo->SearchInfo.ClientHardwareAddress.DataLength );

        DhcpAssert(
            RtlCompareMemory(
                HardwareAddress,
                ClientInfo->SearchInfo.ClientHardwareAddress.Data,
                HardwareAddressLength ) ==
                    HardwareAddressLength );

        break;

    case DhcpClientName:
        break;
    }

#endif // DBG

    //
    // if this IP address is reserved, we shouldn't be deleting the entry.
    //

    if( DhcpServerIsAddressReserved(DhcpGetCurrentServer(), FreeIpAddress )) {
        Error = ERROR_DHCP_RESERVED_CLIENT;
        goto Cleanup;
    }

    //
    // Get Client type -- we need that to figure out what kind of client it is
    // that we are trying to delete..
    //
    Size = sizeof(bClientType);
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[CLIENT_TYPE_INDEX].ColHandle,
        &bClientType,
        &Size
        );
    if( ERROR_SUCCESS != Error ) {
        bClientType = CLIENT_TYPE_DHCP;
    }

    Size = sizeof(AddressState);
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &AddressState,
        &Size
    );

    if( ERROR_SUCCESS != Error ) goto Cleanup;

    DhcpUpdateAuditLog(
        DHCP_IP_LOG_DELETED,
        GETSTRING( DHCP_IP_LOG_DELETED_NAME),
        FreeIpAddress,
        HardwareAddress,
        HardwareAddressLength,
        NULL
    );

    SubnetAddress = (
        DhcpGetSubnetMaskForAddress(FreeIpAddress) & FreeIpAddress
        );
    if( HardwareAddressLength > sizeof(SubnetAddress) &&
        0 == memcmp((LPBYTE)&SubnetAddress, HardwareAddress, sizeof(SubnetAddress) )) {
        //
        // First four characters are subnet address.. So, we will strip that...
        //
        Hw = HardwareAddress + sizeof(SubnetAddress);
        HwLen = HardwareAddressLength - sizeof(SubnetAddress);
    } else {
        Hw = HardwareAddress ;
        HwLen = HardwareAddressLength;
    }

    if( HwLen ) {
        HwLen --;
        HwType = *Hw++;
    } else {
        HwType = 0;
        Hw = NULL;
    }
    
    CALLOUT_DELETED( FreeIpAddress, Hw, HwLen, 0);

    if( IsAddressDeleted(AddressState) ) {
        DhcpDoDynDnsCheckDelete(FreeIpAddress);
        DhcpPrint((DEBUG_ERRORS, "Forcibly deleting entry for ip-address %s\n",
                   inet_ntoa(*(struct in_addr *)&FreeIpAddress)));
        AlreadyDeleted = TRUE;
    } else if( !DhcpDoDynDnsCheckDelete(FreeIpAddress) ) {
        // Dont delete if not asked to
        DhcpPrint((DEBUG_ERRORS, "Not deleting record because of DNS de-registration pending!\n"));
    } else {
        Error = DhcpMapJetError(
            JetDelete(
                DhcpGlobalJetServerSession,
                DhcpGlobalClientTableHandle ),
            "DeleteClientInfo:Delete");

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
    }

    //
    // Finally, mark the IP address available
    //

    if( AlreadyDeleted ) {
        Error = ERROR_SUCCESS;                         // if this deleted, address wont be there in bitmap..
    } else {
        if( CLIENT_TYPE_BOOTP == bClientType ) {
            Error = DhcpReleaseBootpAddress( FreeIpAddress );
            if( ERROR_SUCCESS != Error ) {
                DhcpReleaseAddress( FreeIpAddress );
            }
        } else {
            Error = DhcpReleaseAddress( FreeIpAddress );
            if( ERROR_SUCCESS != Error ) {
                DhcpReleaseBootpAddress( FreeIpAddress );
            }
        }

        if( ERROR_FILE_NOT_FOUND == Error )
            Error = ERROR_SUCCESS;                     // ok -- may be deleting deleted records..
    }

Cleanup:

    if ( Error != ERROR_SUCCESS ) {

        //
        // if the transaction has been started, than roll back to the
        // start point, so that we will not leave the database
        // inconsistence.
        //

        if( TransactBegin == TRUE ) {
            DWORD LocalError;

            LocalError = DhcpJetRollBack();
            DhcpAssert( LocalError == ERROR_SUCCESS );
        }

        DhcpPrint(( DEBUG_APIS, "DhcpDeleteClientInfo failed, %ld.\n",
                        Error ));
    }
    else {

        //
        // commit the transaction before we return.
        //

        DWORD LocalError;

        DhcpAssert( TransactBegin == TRUE );

        LocalError = DhcpJetCommitTransaction();
        DhcpAssert( LocalError == ERROR_SUCCESS );
    }

    UNLOCK_DATABASE();

    return(Error);
}

DWORD
R_DhcpEnumSubnetClients(
    DHCP_SRV_HANDLE             ServerIpAddress,
    DHCP_IP_ADDRESS             SubnetAddress,
    DHCP_RESUME_HANDLE         *ResumeHandle,
    DWORD                       PreferredMaximum,
    DHCP_CLIENT_INFO_ARRAY    **ClientInfo,
    DWORD                      *ClientsRead,
    DWORD                      *ClientsTotal
    )

/*++

Routine Description:

    This function returns all registered clients of the specified
    subnet. However it returns clients from all subnets if the subnet
    address specified is zero.   This function is provided for use by
    older version of the DHCP Administrator application.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet. Client filter is disabled
        and clients from all subnet are returned if this subnet address
        is zero.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to zero on
        first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    ClientInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    ClientsRead : Pointer to a DWORD where the number of clients
        that in the above buffer is returned.

    ClientsTotal : Pointer to a DWORD where the total number of
        clients remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DHCP_CLIENT_INFO_ARRAY_V4 *pClientInfoV4 = NULL;
    DWORD                      dwResult;

    dwResult = R_DhcpEnumSubnetClientsV4(
                        ServerIpAddress,
                        SubnetAddress,
                        ResumeHandle,
                        PreferredMaximum,
                        &pClientInfoV4,
                        ClientsRead,
                        ClientsTotal
                        );

    if ( ERROR_SUCCESS == dwResult || ERROR_MORE_DATA == dwResult )
    {
        *ClientInfo = ( DHCP_CLIENT_INFO_ARRAY * )
                            pClientInfoV4;
    }
    else
    {
        //
        // if R_DhcpEnumSubnetClientsV4 failed, pClientInfoV4 should be NULL.
        //

        DhcpAssert( !pClientInfoV4 );
        DhcpPrint( ( DEBUG_ERRORS,
                    "R_DhcpEnumSubnetClients failed.\n" ));
    }


    DhcpPrint( ( DEBUG_MISC,
                "R_DhcpEnumSubnetClients returns %x\n", dwResult ));

    DhcpPrint( ( DEBUG_MISC,
                "R_DhcpEnumSubnetClients: Clients read =%d, ClientsTotal = %d\n",
                *ClientsRead,
                *ClientsTotal ) );

    return dwResult;
}


DWORD
R_DhcpEnumSubnetClientsV4(
    DHCP_SRV_HANDLE ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY_V4 *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    )
/*++

Routine Description:

    This function returns all registered clients of the specified
    subnet. However it returns clients from all subnets if the subnet
    address specified is zero.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet. Client filter is disabled
        and clients from all subnet are returned if this subnet address
        is zero.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to zero on
        first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    ClientInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    ClientsRead : Pointer to a DWORD where the number of clients
        that in the above buffer is returned.

    ClientsTotal : Pointer to a DWORD where the total number of
        clients remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Error;
    JET_ERR JetError;
    DWORD i;
    JET_RECPOS JetRecordPosition;
    LPDHCP_CLIENT_INFO_ARRAY_V4 LocalEnumInfo = NULL;
    DWORD ElementsCount;

    DWORD RemainingRecords;
    DWORD ConsumedSize;
    DHCP_RESUME_HANDLE LocalResumeHandle = 0;

    DhcpPrint(( DEBUG_APIS, "DhcpEnumSubnetClients is called, (%s).\n",
                    DhcpIpAddressToDottedString(SubnetAddress) ));

    DhcpAssert( *ClientInfo == NULL );

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    LOCK_DATABASE();

    //
    // position the current record pointer to appropriate position.
    //

    if( *ResumeHandle == 0 ) {

        //
        // fresh enumeration, start from begining.
        //

        Error = DhcpJetPrepareSearch(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                    TRUE,   // Search from start
                    NULL,
                    0
                    );
    }
    else {

        //
        // start from the record where we stopped last time.
        //

        //
        // we place the IpAddress of last record in the resume handle.
        //

        DhcpAssert( sizeof(*ResumeHandle) == sizeof(DHCP_IP_ADDRESS) );

        Error = DhcpJetPrepareSearch(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                    FALSE,
                    ResumeHandle,
                    sizeof(*ResumeHandle) );

     }

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }


    //
    // now query remaining records in the database.
    //

    JetError = JetGetRecordPosition(
                    DhcpGlobalJetServerSession,
                    DhcpGlobalClientTableHandle,
                    &JetRecordPosition,
                    sizeof(JET_RECPOS) );

    Error = DhcpMapJetError( JetError, "EnumClientsV4:GetRecordPosition" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    DhcpPrint(( DEBUG_APIS, "JetGetRecordPosition returned, "
                    "entriesLT = %ld, "
                    "entriesInRange = %ld, "
                    "entriesTotal = %ld.\n",
                        JetRecordPosition.centriesLT,
                        JetRecordPosition.centriesInRange,
                        JetRecordPosition.centriesTotal ));

#if 0
    //
    // IpAddress is unique, we find exactly one record for this key.
    //

    DhcpAssert( JetRecordPosition.centriesInRange == 1 );

    RemainingRecords = JetRecordPosition.centriesTotal -
                            JetRecordPosition.centriesLT;

    DhcpAssert( (INT)RemainingRecords > 0 );

    if( RemainingRecords == 0 ) {
        Error = ERROR_NO_MORE_ITEMS;
        goto Cleanup;
    }

#else

    //
    // ?? always return big value, until we know a reliable way to
    // determine the remaining records.
    //

    RemainingRecords = 0x7FFFFFFF;

#endif


    //
    // limit resource.
    //

    if( PreferredMaximum > DHCP_ENUM_BUFFER_SIZE_LIMIT ) {
        PreferredMaximum = DHCP_ENUM_BUFFER_SIZE_LIMIT;
    }

    //
    // if the PreferredMaximum buffer size is too small ..
    //

    if( PreferredMaximum < DHCP_ENUM_BUFFER_SIZE_LIMIT_MIN ) {
        PreferredMaximum = DHCP_ENUM_BUFFER_SIZE_LIMIT_MIN;
    }

    //
    // allocate enum array.
    //

    //
    // determine possible number of records that can be returned in
    // PreferredMaximum buffer;
    //

    ElementsCount =
        ( PreferredMaximum - sizeof(DHCP_CLIENT_INFO_ARRAY_V4) ) /
            (sizeof(LPDHCP_CLIENT_INFO_V4) + sizeof(DHCP_CLIENT_INFO_V4));

    LocalEnumInfo = MIDL_user_allocate( sizeof(DHCP_CLIENT_INFO_ARRAY_V4) );

    if( LocalEnumInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalEnumInfo->NumElements = 0;

    LocalEnumInfo->Clients =
        MIDL_user_allocate(sizeof(LPDHCP_CLIENT_INFO_V4) * ElementsCount);

    if( LocalEnumInfo->Clients == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    ConsumedSize = sizeof(DHCP_CLIENT_INFO_ARRAY_V4);
    for( i = 0;
                // if we have filled up the return buffer.
            (LocalEnumInfo->NumElements < ElementsCount) &&
                // no more record in the database.
            (i < RemainingRecords);
                        i++ ) {

        LPDHCP_CLIENT_INFO_V4 CurrentClientInfo;
        DWORD CurrentInfoSize;
        DWORD NewSize;
        BOOL ValidClient;

        //
        // read current record.
        //


        CurrentClientInfo = NULL;
        CurrentInfoSize = 0;
        ValidClient = FALSE;

        Error = DhcpGetCurrentClientInfo(
                    &CurrentClientInfo,
                    &CurrentInfoSize,
                    &ValidClient,
                    SubnetAddress );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        if( ValidClient ) {

            //
            // client belongs to the requested subnet, so pack it.
            //

            NewSize =
                ConsumedSize +
                    CurrentInfoSize +
                        sizeof(LPDHCP_CLIENT_INFO_V4); // for pointer.

            if( NewSize < PreferredMaximum ) {

                //
                // we have space for the current record.
                //

                LocalEnumInfo->Clients[LocalEnumInfo->NumElements] =
                    CurrentClientInfo;
                LocalEnumInfo->NumElements++;

                ConsumedSize = NewSize;
            }
            else {

                //
                // we have filled the buffer.
                //

                Error = ERROR_MORE_DATA;

                if( 0 ) {
                    //
                    //  resume handle has to be the LAST ip address RETURNED.
                    //  this is the next one.. so don't do this..
                    //
                    LocalResumeHandle =
                       (DHCP_RESUME_HANDLE)CurrentClientInfo->ClientIpAddress;
                }

                //
                // free last record.
                //

                _fgs__DHCP_CLIENT_INFO ( CurrentClientInfo );

                break;
            }

        }

        //
        // move to next record.
        //

        Error = DhcpJetNextRecord();

        if( Error != ERROR_SUCCESS ) {

            if( Error == ERROR_NO_MORE_ITEMS ) {
                break;
            }

            goto Cleanup;
        }
    }

    *ClientInfo = LocalEnumInfo;
    *ClientsRead = LocalEnumInfo->NumElements;

    if( Error == ERROR_NO_MORE_ITEMS ) {

        *ClientsTotal = LocalEnumInfo->NumElements;
        *ResumeHandle = 0;
        Error = ERROR_SUCCESS;

#if 0
        //
        // when we have right RemainingRecords count.
        //

        DhcpAssert( RemainingRecords == LocalEnumInfo->NumElements );
#endif

    }
    else {

        *ClientsTotal = RemainingRecords;
        if( LocalResumeHandle != 0 ) {

            *ResumeHandle = LocalResumeHandle;
        }
        else {

            *ResumeHandle =
                LocalEnumInfo->Clients
                    [LocalEnumInfo->NumElements - 1]->ClientIpAddress;
        }

        Error = ERROR_MORE_DATA;
    }

Cleanup:

    UNLOCK_DATABASE();

    if( (Error != ERROR_SUCCESS) &&
        (Error != ERROR_MORE_DATA) ) {

        //
        // if we aren't succssful return locally allocated buffer.
        //

        if( LocalEnumInfo != NULL ) {
            _fgs__DHCP_CLIENT_INFO_ARRAY( LocalEnumInfo );
            MIDL_user_free( LocalEnumInfo );
        }

        DhcpPrint(( DEBUG_APIS, "DhcpEnumSubnetClients failed, %ld.\n",
                        Error ));
    }

    return(Error);
}


DWORD
R_DhcpEnumSubnetClientsV5(
    DHCP_SRV_HANDLE ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_CLIENT_INFO_ARRAY_V5 *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    )
/*++

Routine Description:

    This function returns all registered clients of the specified
    subnet. However it returns clients from all subnets if the subnet
    address specified is zero.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet. Client filter is disabled
        and clients from all subnet are returned if this subnet address
        is zero.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to zero on
        first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    ClientInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    ClientsRead : Pointer to a DWORD where the number of clients
        that in the above buffer is returned.

    ClientsTotal : Pointer to a DWORD where the total number of
        clients remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Error;
    JET_ERR JetError;
    DWORD i;
    JET_RECPOS JetRecordPosition;
    LPDHCP_CLIENT_INFO_ARRAY_V5 LocalEnumInfo = NULL;
    DWORD ElementsCount;

    DWORD RemainingRecords;
    DWORD ConsumedSize;
    DHCP_RESUME_HANDLE LocalResumeHandle = 0;

    DhcpPrint(( DEBUG_APIS, "DhcpEnumSubnetClients is called, (%s).\n",
                    DhcpIpAddressToDottedString(SubnetAddress) ));

    DhcpAssert( *ClientInfo == NULL );

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    LOCK_DATABASE();

    //
    // position the current record pointer to appropriate position.
    //

    if( *ResumeHandle == 0 ) {

        //
        // fresh enumeration, start from begining.
        //

        Error = DhcpJetPrepareSearch(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                    TRUE,   // Search from start
                    NULL,
                    0
                    );
    }
    else {

        //
        // start from the record where we stopped last time.
        //

        //
        // we place the IpAddress of last record in the resume handle.
        //

        DhcpAssert( sizeof(*ResumeHandle) == sizeof(DHCP_IP_ADDRESS) );

        Error = DhcpJetPrepareSearch(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                    FALSE,
                    ResumeHandle,
                    sizeof(*ResumeHandle) );

     }

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }


    //
    // now query remaining records in the database.
    //

    JetError = JetGetRecordPosition(
                    DhcpGlobalJetServerSession,
                    DhcpGlobalClientTableHandle,
                    &JetRecordPosition,
                    sizeof(JET_RECPOS) );

    Error = DhcpMapJetError( JetError, "EnumClientsV5:GetRecordPosition" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    DhcpPrint(( DEBUG_APIS, "JetGetRecordPosition returned, "
                    "entriesLT = %ld, "
                    "entriesInRange = %ld, "
                    "entriesTotal = %ld.\n",
                        JetRecordPosition.centriesLT,
                        JetRecordPosition.centriesInRange,
                        JetRecordPosition.centriesTotal ));

#if 0
    //
    // IpAddress is unique, we find exactly one record for this key.
    //

    DhcpAssert( JetRecordPosition.centriesInRange == 1 );

    RemainingRecords = JetRecordPosition.centriesTotal -
                            JetRecordPosition.centriesLT;

    DhcpAssert( (INT)RemainingRecords > 0 );

    if( RemainingRecords == 0 ) {
        Error = ERROR_NO_MORE_ITEMS;
        goto Cleanup;
    }

#else

    //
    // ?? always return big value, until we know a reliable way to
    // determine the remaining records.
    //

    RemainingRecords = 0x7FFFFFFF;

#endif


    //
    // limit resource.
    //

    if( PreferredMaximum > DHCP_ENUM_BUFFER_SIZE_LIMIT ) {
        PreferredMaximum = DHCP_ENUM_BUFFER_SIZE_LIMIT;
    }

    //
    // if the PreferredMaximum buffer size is too small ..
    //

    if( PreferredMaximum < DHCP_ENUM_BUFFER_SIZE_LIMIT_MIN ) {
        PreferredMaximum = DHCP_ENUM_BUFFER_SIZE_LIMIT_MIN;
    }

    //
    // allocate enum array.
    //

    //
    // determine possible number of records that can be returned in
    // PreferredMaximum buffer;
    //

    ElementsCount =
        ( PreferredMaximum - sizeof(DHCP_CLIENT_INFO_ARRAY_V5) ) /
            (sizeof(LPDHCP_CLIENT_INFO_V5) + sizeof(DHCP_CLIENT_INFO_V5));

    LocalEnumInfo = MIDL_user_allocate( sizeof(DHCP_CLIENT_INFO_ARRAY_V5) );

    if( LocalEnumInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalEnumInfo->NumElements = 0;

    LocalEnumInfo->Clients =
        MIDL_user_allocate(sizeof(LPDHCP_CLIENT_INFO_V5) * ElementsCount);

    if( LocalEnumInfo->Clients == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    ConsumedSize = sizeof(DHCP_CLIENT_INFO_ARRAY_V5);
    for( i = 0;
                // if we have filled up the return buffer.
            (LocalEnumInfo->NumElements < ElementsCount) &&
                // no more record in the database.
            (i < RemainingRecords);
                        i++ ) {

        LPDHCP_CLIENT_INFO_V5 CurrentClientInfo;
        DWORD CurrentInfoSize;
        DWORD NewSize;
        BOOL ValidClient;

        //
        // read current record.
        //


        CurrentClientInfo = NULL;
        CurrentInfoSize = 0;
        ValidClient = FALSE;

        Error = DhcpGetCurrentClientInfoV5(
                    &CurrentClientInfo,
                    &CurrentInfoSize,
                    &ValidClient,
                    SubnetAddress );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        if( ValidClient ) {

            //
            // client belongs to the requested subnet, so pack it.
            //

            NewSize =
                ConsumedSize +
                    CurrentInfoSize +
                        sizeof(LPDHCP_CLIENT_INFO_V5); // for pointer.

            if( NewSize < PreferredMaximum ) {

                //
                // we have space for the current record.
                //

                LocalEnumInfo->Clients[LocalEnumInfo->NumElements] =
                    CurrentClientInfo;
                LocalEnumInfo->NumElements++;

                ConsumedSize = NewSize;
            }
            else {

                //
                // we have filled the buffer.
                //

                Error = ERROR_MORE_DATA;

                if( 0 ) {
                    //
                    //  resume handle has to be the LAST ip address RETURNED.
                    //  this is the next one.. so don't do this..
                    //
                    LocalResumeHandle =
                       (DHCP_RESUME_HANDLE)CurrentClientInfo->ClientIpAddress;
                }

                //
                // free last record.
                //

                _fgs__DHCP_CLIENT_INFO_V5 ( CurrentClientInfo );

                break;
            }

        }

        //
        // move to next record.
        //

        Error = DhcpJetNextRecord();

        if( Error != ERROR_SUCCESS ) {

            if( Error == ERROR_NO_MORE_ITEMS ) {
                break;
            }

            goto Cleanup;
        }
    }

    *ClientInfo = LocalEnumInfo;
    *ClientsRead = LocalEnumInfo->NumElements;

    if( Error == ERROR_NO_MORE_ITEMS ) {

        *ClientsTotal = LocalEnumInfo->NumElements;
        *ResumeHandle = 0;
        Error = ERROR_SUCCESS;

#if 0
        //
        // when we have right RemainingRecords count.
        //

        DhcpAssert( RemainingRecords == LocalEnumInfo->NumElements );
#endif

    }
    else {

        *ClientsTotal = RemainingRecords;
        if( LocalResumeHandle != 0 ) {

            *ResumeHandle = LocalResumeHandle;
        }
        else {

            *ResumeHandle =
                LocalEnumInfo->Clients
                    [LocalEnumInfo->NumElements - 1]->ClientIpAddress;
        }

        Error = ERROR_MORE_DATA;
    }

Cleanup:

    UNLOCK_DATABASE();

    if( (Error != ERROR_SUCCESS) &&
        (Error != ERROR_MORE_DATA) ) {

        //
        // if we aren't succssful return locally allocated buffer.
        //

        if( LocalEnumInfo != NULL ) {
            _fgs__DHCP_CLIENT_INFO_ARRAY_V5( LocalEnumInfo );
            MIDL_user_free( LocalEnumInfo );
        }

        DhcpPrint(( DEBUG_APIS, "DhcpEnumSubnetClients failed, %ld.\n",
                        Error ));
    }

    return(Error);
}


DWORD
R_DhcpGetClientOptions(
    DHCP_SRV_HANDLE ServerIpAddress,
    DHCP_IP_ADDRESS ClientIpAddress,
    DHCP_IP_MASK ClientSubnetMask,
    LPDHCP_OPTION_LIST *ClientOptions
    )
/*++

Routine Description:

    This function retrieves the options that are given to the
    specified client on boot request.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientIpAddress : IP Address of the client whose options to be
        retrieved

    ClientSubnetMask : Subnet mask of the client.

    ClientOptions : Pointer to a location where the retrieved option
        structure pointer is returned. Caller should free up
        the buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the specified client subnet is
        not managed by the server.

    ERROR_DHCP_IP_ADDRESS_NOT_MANAGED - if the specified client
        IP address is not managed by the server.

    Other WINDOWS errors.
--*/
{
    DWORD Error;

    DhcpPrint(( DEBUG_APIS, "DhcpGetClientOptions is called.\n"));

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    Error = ERROR_CALL_NOT_IMPLEMENTED;

// Cleanup:

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_APIS, "DhcpGetClientOptions  failed, %ld.\n",
                        Error ));
    }

    return(Error);
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\bootphlp.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    optapi.c --> modified to bootphlp.c

Abstract:

    This module contains the implementation of DHCP Option APIs.

Author:

    Madan Appiah (madana)  27-Sep-1993

Environment:

    User Mode - Win32

Revision History:

    Cheng Yang (t-cheny)  17-Jul-1996  vendor specific information
    Frankbee              9/6/96       #ifdef'd vendor specific stuff for sp1

--*/

#include "dhcppch.h"

BOOL
ScanBootFileTable(
    WCHAR *wszTable,
    char *szRequest,
    char *szBootfile,
    char  *szServer
    )
/*++

Routine Description:

    Searches the specified boot file table for the specified request.

    As a side effect, commas in wszTable are replaced with L'\0'

    .
Arguments:

    wszTable - Boot file table, stored as follows:
               <generic boot file name1>,[<boot server1>],<boot file name1>L\0
               <generic boot file name1>,[<boot server1>],<boot file name1>L\0
               \0
    szRequest   - the generic boot file name requested by the caller
    szBootfile  - if the function was successful, stores the boot file name
                  associated with szRequest.
    szServer    - if the function was successful, stores the boot server name
                  associated with szRequest.


Return Value:
        Success  - TRUE
        Failure  - FALSE
  .

--*/
{
    char szGenericName[ BOOT_FILE_SIZE ];

    DhcpAssert( strlen( szRequest ) <= BOOT_FILE_SIZE );

	while( *wszTable )
	{
		size_t cbEntry;
        DWORD  dwResult;

        cbEntry = wcslen( wszTable ) + 1;

        dwResult = DhcpParseBootFileString(
                                   wszTable,
                                   szGenericName,
                                   szBootfile,
                                   szServer
                                   );

        if ( ERROR_SUCCESS != dwResult )
        {
            *szBootfile = '\0';
            *szServer   = '\0';
            return FALSE;
        }

        if ( !_strcmpi( szGenericName, szRequest ) )
        {
            return TRUE;
        }

		// no match, skip to the next record
		wszTable += cbEntry;
	}

	// no match

    *szBootfile = '\0';
    *szServer   = '\0';
	return FALSE;
}

DWORD
LoadBootFileTable(
    WCHAR **ppwszTable,
    DWORD  *pcb
    )
/*++

Routine Description:

    Loads the boot file table string from the registry.
    .
Arguments:

    ppwszTable - points to the location of the pointer to the boot file
        table string.

Return Value:
    Success -  ERROR_SUCCESS

    Failure -  ERROR_NOT_ENOUGH_MEMORY
               Windows registry error.

    .

--*/

{
	DWORD	dwType;
    DWORD   dwResult;

    *ppwszTable = NULL;
    *pcb       = 0;

    dwResult = RegQueryValueEx( DhcpGlobalRegGlobalOptions, DHCP_BOOT_FILE_TABLE, 0,
                                &dwType, NULL, pcb );

    if ( ERROR_SUCCESS != dwResult || dwType != DHCP_BOOT_FILE_TABLE_TYPE )
    {
        dwResult = ERROR_SERVER_INVALID_BOOT_FILE_TABLE;
        goto done;
    }

    *ppwszTable = (WCHAR *) MIDL_user_allocate( *pcb );

    if ( !*ppwszTable )
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    dwResult = RegQueryValueEx( DhcpGlobalRegGlobalOptions, DHCP_BOOT_FILE_TABLE, 0,
                                &dwType, (BYTE *) *ppwszTable, pcb );

done:
    if ( ERROR_SUCCESS != dwResult && *ppwszTable )
    {
        MIDL_user_free( *ppwszTable );
        *ppwszTable = NULL;
        *pcb = 0;
    }

    return dwResult;
}


DWORD
DhcpParseBootFileString(
    WCHAR *wszBootFileString,
    char  *szGenericName OPTIONAL,
    char  *szBootFileName,
    char  *szServerName
    )
/*++

Routine Description:

    Takes as input a Unicode string with the following format:

    [<generic boot file name>,][<boot server>],<boot file name>

    The function extracts the generic boot file name, boot server and boot file
    name and stores them as Ansi strings in buffers supplied by the caller.

Arguments:

    wszBootFileString -  Unicode string with the format desribed above.
    szGenericName - if supplied, stores generic boot file name

    szBootFileName - stores the boot file name

    szServerName - stores the boot server name

Return Value:
    Success -  ERROR_SUCCESS

    Failure -  ERROR_INVALID_PARAMETER
               Unicode conversion error

    .

--*/
{

    struct _DHCP_PARSE_RESULTS
    {
        char *sz;
        int   cb;
    };

    int   i;

    struct _DHCP_PARSE_RESULTS pResults[3] =
    {
       { szGenericName,  BOOT_FILE_SIZE },
       { szServerName,   BOOT_SERVER_SIZE },
       { szBootFileName, BOOT_FILE_SIZE }
    };

    int cResults = sizeof( pResults ) / sizeof( struct _DHCP_PARSE_RESULTS );
    WCHAR *pwch  = wszBootFileString;
    DWORD dwResult = ERROR_SUCCESS;

    for ( i = ( szGenericName ) ? 0 : 1 ; i < cResults; i++ )
    {
        while( *pwch && *pwch != BOOT_FILE_STRING_DELIMITER_W )
            if ( !*pwch++ )
                return ERROR_INVALID_PARAMETER;

        //
        // protect the input buffer
        //

        if ( pwch - wszBootFileString >= pResults[i].cb )
        {
            dwResult = ERROR_INVALID_PARAMETER;
            goto done;
        }

        if (  pwch - wszBootFileString )
        {
            if ( !WideCharToMultiByte(  CP_ACP,
                                        0,
                                        wszBootFileString,
                                        (int)(pwch - wszBootFileString), // # of unicode chars
                                                                   // to convert
                                        pResults[i].sz,
                                        BOOT_SERVER_SIZE,
                                        NULL,
                                        FALSE ))
            {
                dwResult = GetLastError();
                goto done;
            }
        }

        //
        // null terminate ansi representation
        //

        pResults[i].sz[ pwch - wszBootFileString ] = '\0';

        //
        // skip over delimiter
        //

        pwch++;
        wszBootFileString = pwch;
    }

done:

    if ( !strlen( szBootFileName ) )
    {
        dwResult = ERROR_INVALID_PARAMETER;
    }

    return dwResult;
}

VOID
DhcpGetBootpInfo(
    IN LPDHCP_REQUEST_CONTEXT Ctxt,
    IN DHCP_IP_ADDRESS IpAddress,
    IN DHCP_IP_ADDRESS Mask,
    IN CHAR *szRequest,
    OUT CHAR *szBootFileName,
    OUT DHCP_IP_ADDRESS *pBootpServerAddress
        )
/*++

Routine Description:

    Retrieves the boot file name and boot server name for the specified
    client.
    
Arguments:
    Ctxt - dhcp client context
    IpAddress - The client's IP address
    Mask - The client's subnet mask
    szRequest - the generic boot file name requested by the client
    szBootFileName - If the function is successful, stores a copy of the
        boot file name that the client is configured to use.  Otherwise,
        stores a null string.
    pBootpServerAddress - When the fuction returns, this will point to one
        of three values:
        INADDR_NONE   - the admin specified an invalid
                        server name
        0             - no bootp server was specified for
                        the specified client
        any           - a valid IP address.

--*/
{
    DWORD dwResult,
          dwBootfileOptionLevel,
          dwUnused;
    BYTE  *pbBootFileName   = NULL,
          *pbBootServerName = NULL;
    CHAR   szBootServerName[ BOOT_SERVER_SIZE ];

    //
    // this routine does not work for multicast address.
    //
    DhcpAssert( !CLASSD_HOST_ADDR(IpAddress) );

    *szBootFileName = '\0';

    dwBootfileOptionLevel = DHCP_OPTION_LEVEL_GLOBAL;

    dwResult = DhcpGetParameter(
        IpAddress,
        Ctxt,
        OPTION_BOOTFILE_NAME,
        &pbBootFileName,
        &dwUnused,
        &dwBootfileOptionLevel
    );
    if ( ERROR_SUCCESS == dwResult ) {
        DhcpGetParameter(
            IpAddress,
            Ctxt,
            OPTION_TFTP_SERVER_NAME,
            &pbBootServerName,
            &dwUnused,
            &dwUnused
        );
    }

    if ( ERROR_SUCCESS != DhcpLookupBootpInfo(szRequest,szBootFileName,szBootServerName ) ||
         DHCP_OPTION_LEVEL_GLOBAL != dwBootfileOptionLevel ) {
        if ( pbBootFileName )  {
            strncpy( szBootFileName, pbBootFileName, BOOT_FILE_SIZE );

            if ( pbBootServerName ) {
                strncpy( szBootServerName, pbBootServerName, BOOT_SERVER_SIZE );
            }
        }
    }

    if ( pBootpServerAddress ) {
        *pBootpServerAddress = DhcpResolveName( szBootServerName );
    }

    if ( pbBootServerName ) {
        DhcpFreeMemory( pbBootServerName );
    }

    if ( pbBootFileName ) {
        DhcpFreeMemory( pbBootFileName );
    }
}

DWORD
DhcpLookupBootpInfo(
    LPBYTE ReceivedBootFileName,
    LPBYTE BootFileName,
    LPBYTE BootFileServer
    )
/*++

Routine Description:

    This function gets the value of BootFileName for the bootp clients.

Arguments:

    IpAddress - The IP address of the client requesting the parameter.

    ReceivedBootFileName - Pointer to the BootFileName field in the client request.

    BootFileName - Pointer to where the BootFileName is to be returned.

    BootFileServer - Receives the optional Boot file server name

Return Value:

    Registry Errors.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    LPWSTR BootFileNameRegValue = NULL;

    *BootFileServer = 0;
    *BootFileName   = 0;

    if ( !*ReceivedBootFileName )  {
        //
        // the client didn't specify a boot file name.
        //
        Error = ERROR_SERVER_UNKNOWN_BOOT_FILE_NAME;

    } else  {
        //
        // the client specified a generic boot file name.  attempt
        // to satisfy this request from the global boot file table
        //
        WCHAR   *pwszTable;
        DWORD   cb;

        Error = LoadBootFileTable( &pwszTable, &cb );
        if ( ERROR_SUCCESS != Error )   {
            static s_fLogEvent = TRUE;

            // log the event once to avoid filling the event log

            if ( s_fLogEvent ) {
                DhcpServerEventLog(
                    EVENT_SERVER_BOOT_FILE_TABLE,
                    EVENTLOG_WARNING_TYPE,
                    Error );
                s_fLogEvent = FALSE;
            }

            return Error;
        }

        if ( !ScanBootFileTable(
            pwszTable, ReceivedBootFileName,
            BootFileName, BootFileServer ) )  {

            Error = ERROR_SERVER_UNKNOWN_BOOT_FILE_NAME;
        }

        MIDL_user_free( pwszTable );
    }

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\convguid.c ===
/*++

Copyright (c) 1998  Microsoft Corporation


Module Name:

    dhcpm\server\server\convguid.c
    (was iphlpapi\guid.c)

Abstract:

    Cut-n-Paste of rtl\guid.c but without UNICODE_STRINGs

Revision History:

    AmritanR Created 

--*/

#include <dhcppch.h>
#include <guiddef.h>

#define GUID_FORMAT_W   L"{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"

int
__cdecl
ScanHexFormat(
    IN const WCHAR* pwszBuffer,
    IN ULONG        ulCharCount,
    IN const WCHAR* pwszFormat,
    ...
    )

/*++

Routine Description:

    Scans a source Buffer and places values from that buffer into the parameters
    as specified by Format.

Arguments:

    pwszBuffer  Source buffer which is to be scanned.

    ulCharCount Maximum length in characters for which Buffer is searched.
                This implies that Buffer need not be UNICODE_NULL terminated.

    Format      Format string which defines both the acceptable string form as
                contained in pwszBuffer


Return Value:

    Returns the number of parameters filled if the end of the Buffer is reached,
    else -1 on an error.

--*/
{
    va_list ArgList;
    int     iFormatItems;

    va_start(ArgList, pwszFormat);

    //
    // Count of number of parameters filled
    //

    iFormatItems = 0;

    while(TRUE)
    {
        switch (*pwszFormat) 
        {
            case UNICODE_NULL:
            {
                //
                // end of string
                //

                return (*pwszBuffer && ulCharCount) ? -1 : iFormatItems;
            }

            case L'%':
            {
                //
                // Format specifier
                //

                pwszFormat++;

                if (*pwszFormat != L'%') 
                {
                    ULONG   ulNumber;
                    int     iWidth;
                    int     iLong;
                    PVOID   pvPointer;

                    //
                    // So it isnt a %%
                    //

                    iLong = 0;
                    iWidth = 0;

                    while(TRUE)
                    {
                        if((*pwszFormat >= L'0') && 
                           (*pwszFormat <= L'9')) 
                        {
                            iWidth = iWidth * 10 + *pwszFormat - '0';
                        } 
                        else
                        {
                            if(*pwszFormat == L'l') 
                            {
                                iLong++;
                            } 
                            else 
                            {
                                if((*pwszFormat == L'X') || 
                                   (*pwszFormat == L'x')) 
                                {
                                    break;
                                }
                            }
                        }
                       
                        //
                        // Move to the next specifier
                        //
 
                        pwszFormat++;
                    }

                    pwszFormat++;

                    for(ulNumber = 0; iWidth--; pwszBuffer++, ulCharCount--) 
                    {
                        if(!ulCharCount)
                        {
                            return -1;
                        }

                        ulNumber *= 16;

                        if((*pwszBuffer >= L'0') && 
                           (*pwszBuffer <= L'9')) 
                        {
                            ulNumber += (*pwszBuffer - L'0');
                        } 
                        else
                        {
                            if((*pwszBuffer >= L'a') && 
                               (*pwszBuffer <= L'f')) 
                            {
                                ulNumber += (*pwszBuffer - L'a' + 10);
                            }
                            else
                            {
                                if((*pwszBuffer >= L'A') && 
                                   (*pwszBuffer <= L'F')) 
                                {
                                    ulNumber += (*pwszBuffer - L'A' + 10);
                                } 
                                else 
                                {
                                    return -1;
                                }
                            }
                        }
                    }

                    pvPointer = va_arg(ArgList, PVOID);

                    if(iLong) 
                    {
                        *(PULONG)pvPointer = ulNumber;
                    } 
                    else 
                    {
                        *(PUSHORT)pvPointer = (USHORT)ulNumber;
                    }

                    iFormatItems++;

                    break;
                }
           
                //
                // NO BREAK
                // 

            }

            default:
            {
                if (!ulCharCount || (*pwszBuffer != *pwszFormat))
                {
                    return -1;
                }

                pwszBuffer++;

                ulCharCount--;

                pwszFormat++;

                break;
            }
        }
    }
}

DWORD
ConvertGuidToString(
    IN  GUID    *pGuid,
    OUT PWCHAR  pwszBuffer
    )

/*++

Routine Description:

    Constructs the standard string version of a GUID, in the form:
    "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    pGuid       Contains the GUID to translate.

    pwszBuffer  Space for storing the string. Must be >= 39 * sizeof(WCHAR)

Return Value:


--*/

{
    return swprintf(pwszBuffer, 
                    (LPCWSTR)GUID_FORMAT_W, 
                    pGuid->Data1, 
                    pGuid->Data2, 
                    pGuid->Data3, 
                    pGuid->Data4[0], 
                    pGuid->Data4[1], 
                    pGuid->Data4[2], 
                    pGuid->Data4[3], 
                    pGuid->Data4[4], 
                    pGuid->Data4[5], 
                    pGuid->Data4[6], 
                    pGuid->Data4[7]);
}

DWORD
ConvertStringToGuid(
    IN  const WCHAR  *pwszGuid,
    IN  ULONG   ulStringLen,
    OUT GUID    *pGuid
    )

/*++

Routine Description:

    Retrieves a the binary format of a textual GUID presented in the standard
    string version of a GUID: "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}".

Arguments:

    GuidString -
        Place from which to retrieve the textual form of the GUID.

    Guid -
        Place in which to put the binary form of the GUID.

Return Value:

    Returns STATUS_SUCCESS if the buffer contained a valid GUID, else
    STATUS_INVALID_PARAMETER if the string was invalid.

--*/

{
    USHORT    Data4[8];
    int       Count;

    if (ScanHexFormat(pwszGuid,
                      ulStringLen/sizeof(WCHAR),
                      (LPCWSTR)GUID_FORMAT_W,
                      &pGuid->Data1, 
                      &pGuid->Data2, 
                      &pGuid->Data3, 
                      &Data4[0], 
                      &Data4[1], 
                      &Data4[2], 
                      &Data4[3], 
                      &Data4[4], 
                      &Data4[5], 
                      &Data4[6], 
                      &Data4[7]) == -1) 
    {
        return ERROR_INVALID_PARAMETER;
    }

    for(Count = 0; Count < sizeof(Data4)/sizeof(Data4[0]); Count++) 
    {
        pGuid->Data4[Count] = (UCHAR)Data4[Count];
    }

    return NO_ERROR;
}


BOOL
ConvertGuidToIfNameString(
    IN GUID *Guid,
    IN OUT LPWSTR Buffer,
    IN ULONG BufSize
    )
{
    if( BufSize < sizeof(GUID)*2 + 3 + 4 ) return FALSE;
    ConvertGuidToString(Guid, Buffer);
    return TRUE;
}
    

BOOL
ConvertGuidFromIfNameString(
    OUT GUID *Guid,
    IN LPCWSTR IfName
    )
{
    return (
        NO_ERROR == ConvertStringToGuid(IfName, wcslen(IfName)*sizeof(WCHAR),Guid)
        );
}

//
// end of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\convguid.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

Module Name:
    convguid.h

Abstract:
    conversion between guids and interface names.

Environment:
    Any

--*/

#ifndef CONVGUID_H_INCLUDED
#define CONVGUID_H_INCLUDED

#ifdef _cplusplus
extern "C" {
#endif


BOOL
ConvertGuidToIfNameString(
    IN GUID *Guid,
    IN OUT LPWSTR Buffer,
    IN ULONG BufSize
    );
    
BOOL
ConvertGuidFromIfNameString(
    OUT GUID *Guid,
    IN LPCWSTR IfName
    );

#ifdef _cplusplus
}
#endif


#endif  CONVGUID_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\database.c ===
/*++

  Copyright (c) 1994  Microsoft Corporation

  Module Name:

  database.c

  Abstract:

  This module contains the functions for interfacing with the JET
  database API.

  Author:

  Madan Appiah (madana)  10-Sep-1993
  Manny Weiser (mannyw)  14-Dec-1992

  Environment:

  User Mode - Win32

  Revision History:

  --*/

#include "dhcppch.h"
#include <dhcpupg.h>
#include <mdhcpsrv.h>

extern
DWORD
DhcpOpenMCastDbTable(
    JET_SESID   SessId,
    JET_DBID    DbId
);

#define MAX_NO_SESSIONS         10
#define DATABASE_SYS_FILE       "system.mdb"
#define DATABASE_LOG_FILE       "Dhcp.log"
#define DATABASE_TMP_FILE       "Dhcp.tmp"
#define DATABASE_BASE_NAME      "j50"

#define CLIENT_TABLE_NAME       "ClientTable"

#define IPADDRESS_STRING        "IpAddress"
#define HARDWARE_ADDRESS_STRING "HardwareAddress"
#define STATE_STRING            "State"
#define MACHINE_INFO_STRING     "MachineInformation"
#define MACHINE_NAME_STRING     "MachineName"
#define LEASE_TERMINATE_STRING  "LeaseTerminates"
#define SUBNET_MASK_STRING      "SubnetMask"
#define SERVER_IP_ADDRESS_STRING "ServerIpAddress"
#define SERVER_NAME_STRING      "ServerName"
#define CLIENT_TYPE             "ClientType"

    //
    //  Structure of the DHCP database is as below.
    //
    //  Tables - currently DHCP has only one table.
    //
    //      1. ClientTable - this table has 6 columns.
    //
    //      Columns :
    //
    //          Name                Type
    //
    //      1. IpAddress            JET_coltypLong - 4-byte integer, signed.
    //      2. HwAddress            JET_coltypBinary - Binary data, < 255 bytes.
    //      3. State                JET_coltypUnsignedByte - 1-byte integer, unsigned.
    //      4. MachineInfo          JET_coltypBinary - Binary data, < 255 bytes.
    //      5. MachineName          JET_coltypBinary - Binary data, < 255 bytes.
    //      6. LeaseTermination     JET_coltypCurrency - 8-byte integer, signed
    //      7. SubnetMask           JET_coltypLong - 4-byte integer, signed
    //      8. ServerIpAddress      JET_coltypLong - 4-byte integer, signed
    //      9. ServerName           JET_coltypBinary - Binary data, < 255 bytes
    //      10 ClientType           JET_coltypUnsignedByte - 1-byte integer, unsigned
    //

    //
    // global data structure.
    // ColName and ColType are constant, so they are initialized here.
    // ColType is initialized when the database is created or reopened.
    //


    STATIC TABLE_INFO ClientTable[] = {
        { IPADDRESS_STRING        , 0, JET_coltypLong },
        { HARDWARE_ADDRESS_STRING , 0, JET_coltypBinary },
        { STATE_STRING            , 0, JET_coltypUnsignedByte },
        { MACHINE_INFO_STRING     , 0, JET_coltypBinary }, // must modify MACHINE_INFO_SIZE if this changes
        { MACHINE_NAME_STRING     , 0, JET_coltypBinary },
        { LEASE_TERMINATE_STRING  , 0, JET_coltypCurrency },
        { SUBNET_MASK_STRING      , 0, JET_coltypLong },
        { SERVER_IP_ADDRESS_STRING, 0, JET_coltypLong },
        { SERVER_NAME_STRING      , 0, JET_coltypBinary },
        { CLIENT_TYPE             , 0, JET_coltypUnsignedByte }
    };

JET_INSTANCE JetInstance = 0;

#define CLIENT_TABLE_NUM_COLS   (sizeof(ClientTable) / sizeof(TABLE_INFO))

DWORD
DhcpMapJetError(
    JET_ERR JetError,
    LPSTR CallerInfo OPTIONAL
)
    /*++

      Routine Description:

      This function maps the Jet database errors to Windows error.

      Arguments:

      JetError - an error JET function call.

      Return Value:

      Windows Error.

      --*/
{
    if( JetError == JET_errSuccess ) {
        return(ERROR_SUCCESS);
    }

    if( JetError < 0 ) {

        DWORD Error;

        //
        // Jet Errors.
        //

        switch( JetError ) {
        case JET_errNoCurrentRecord:
            Error = ERROR_NO_MORE_ITEMS;
            break;

        case JET_errRecordNotFound: // record not found
            DhcpPrint(( DEBUG_JET, "Jet Record not found.\n" ));

            Error = ERROR_DHCP_JET_ERROR;
            break;

        case JET_errKeyDuplicate :
            DhcpAssert(FALSE);
            Error = ERROR_DHCP_JET_ERROR;
            
            break;

        default:
            DhcpPrint(( DEBUG_JET, "Jet Function call failed, %ld.\n",
                        JetError ));

            DhcpServerJetEventLog(
                EVENT_SERVER_JET_ERROR,
                EVENTLOG_ERROR_TYPE,
                JetError,
                CallerInfo);

            Error = ERROR_DHCP_JET_ERROR;
        }

        return(Error);
    }

    //
    // Jet Warnings.
    //

    DhcpPrint(( DEBUG_JET, "Jet Function call retured warning %ld.\n",
                JetError ));

    switch( JetError ) {

    case JET_wrnColumnNull:
    case JET_wrnDatabaseAttached:
        break;

    default:
        DhcpServerJetEventLog(
            EVENT_SERVER_JET_WARNING,
            EVENTLOG_WARNING_TYPE,
            JetError,
            CallerInfo);
    }

    return(ERROR_SUCCESS);
}



DWORD
DhcpJetOpenKey(
    char *ColumnName,
    PVOID Key,
    DWORD KeySize
)
    /*++

      Routine Description:

      This function opens a key for the named index.

      Arguments:

      ColumnName - The column name of an index column.

      Key - The key to look up.

      KeySize - The size of the specified key, in bytes.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetSetCurrentIndex(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        ColumnName );

    Error = DhcpMapJetError( JetError, "DhcpJetOpenKey:SetCurrentIndex" );
    if( Error != ERROR_SUCCESS ) {
        DhcpMapJetError( JetError, ColumnName );
        return(Error);
    }

    JetError = JetMakeKey(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        Key,
        KeySize,
        JET_bitNewKey );

    Error = DhcpMapJetError( JetError, "DhcpJetOpenKey:MakeKey" );
    if( Error != ERROR_SUCCESS ) {
        DhcpMapJetError( JetError, ColumnName );
        return(Error);
    }

    JetError = JetSeek( DhcpGlobalJetServerSession, DhcpGlobalClientTableHandle, JET_bitSeekEQ );
    return( DhcpMapJetError( JetError, "DhcpJetOpenKey:JetSeek" ));
}



DWORD
DhcpJetBeginTransaction(
    VOID
)
    /*++

      Routine Description:

      This functions starts a dhcp database transaction.

      Arguments:

      none.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetBeginTransaction( DhcpGlobalJetServerSession );

    Error = DhcpMapJetError( JetError, "DhcpJetBeginTransaction" );
    return(Error);
}



DWORD
DhcpJetRollBack(
    VOID
)
    /*++

      Routine Description:

      This functions rolls back a dhcp database transaction.

      Arguments:

      none.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetRollback(
        DhcpGlobalJetServerSession,
        0 ); // Rollback the last transaction.

    Error = DhcpMapJetError( JetError, "DhcpJetRollBack" );
    return(Error);
}




DWORD
DhcpJetCommitTransaction(
    VOID
)
    /*++

      Routine Description:

      This functions commits a dhcp database transaction.

      Arguments:

      none.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetCommitTransaction(
        DhcpGlobalJetServerSession,
        JET_bitCommitLazyFlush);

    Error = DhcpMapJetError( JetError, "DhcpJetCommitTransaction" );
    return(Error);
}




DWORD
DhcpJetPrepareUpdate(
    char *ColumnName,
    PVOID Key,
    DWORD KeySize,
    BOOL NewRecord
)
    /*++

      Routine Description:

      This function prepares the database for the creation of a new record,
      or updating an existing record.

      Arguments:

      ColumnName - The column name of an index column.

      Key - The key to update/create.

      KeySize - The size of the specified key, in bytes.

      NewRecord - TRUE to create the key, FALSE to update an existing key.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    if ( !NewRecord ) {
        JetError = JetSetCurrentIndex(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            ColumnName );

        Error = DhcpMapJetError( JetError, "JetPrepareUpdate:SetCurrentIndex" );
        if( Error != ERROR_SUCCESS ) {
            DhcpMapJetError( JetError, ColumnName );
            return( Error );
        }

        JetError = JetMakeKey(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            Key,
            KeySize,
            JET_bitNewKey );

        Error = DhcpMapJetError( JetError, "JetPrepareUpdate:MakeKey" );
        if( Error != ERROR_SUCCESS ) {
            DhcpMapJetError( JetError, ColumnName );
            return( Error );
        }

        JetError = JetSeek(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            JET_bitSeekEQ );

        Error = DhcpMapJetError( JetError, "JetPrepareUpdate:Seek");
        if( Error != ERROR_SUCCESS ) {
            DhcpMapJetError( JetError, ColumnName );
            return( Error );
        }

    }

    JetError = JetPrepareUpdate(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        NewRecord ? JET_prepInsert : JET_prepReplace );

    return( DhcpMapJetError( JetError, "JetPrepareUpdate:PrepareUpdate" ));
}



DWORD
DhcpJetCommitUpdate(
    VOID
)
    /*++

      Routine Description:

      This function commits an update to the database.  The record specified
      by the last call to DhcpJetPrepareUpdate() is committed.

      Arguments:

      None.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;

    JetError = JetUpdate(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        NULL,
        0,
        NULL );

    return( DhcpMapJetError( JetError, "DhcpJetCommitUpdate" ));
}



DWORD
DhcpJetSetValue(
    JET_COLUMNID KeyColumnId,
    PVOID Data,
    DWORD DataSize
)
    /*++

      Routine Description:

      This function updates the value of an entry in the current record.

      Arguments:

      KeyColumnId - The Id of the column (value) to update.

      Data - A pointer to the new value for the column.

      DataSize - The size of the data, in bytes.

      Return Value:

      None.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetSetColumn(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        KeyColumnId,
        Data,
        DataSize,
        0,
        NULL );

    Error = DhcpMapJetError( JetError, "JetSetValue:Setcolumn") ;
    return Error;
}



DWORD
DhcpJetGetValue(
    JET_COLUMNID ColumnId,
    PVOID Data,
    PDWORD DataSize
)
    /*++

      Routine Description:

      This function read the value of an entry in the current record.

      Arguments:

      ColumnId - The Id of the column (value) to read.

      Data - Pointer to a location where the data that is read from the
      database returned,  or pointer to a location where data is.

      DataSize - if the pointed value is non-zero then the Data points to
      a buffer otherwise this function allocates buffer for return data
      and returns buffer pointer in Data.

      Return Value:

      None.

      --*/
{
    JET_ERR JetError;
    DWORD Error;
    DWORD ActualDataSize;
    DWORD NewActualDataSize;
    LPBYTE DataBuffer = NULL;

    if( *DataSize  != 0 ) {

        JetError = JetRetrieveColumn(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            ColumnId,
            Data,
            *DataSize,
            DataSize,
            0,
            NULL );

        Error = DhcpMapJetError( JetError, "JetGetValue:RetrieveColumn1" );
        goto Cleanup;
    }

    //
    // determine the size of data.
    //

    JetError = JetRetrieveColumn(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        ColumnId,
        NULL,
        0,
        &ActualDataSize,
        0,
        NULL );

    //
    // JET_wrnBufferTruncated is expected warning.
    //

    if( JetError != JET_wrnBufferTruncated ) {
        Error = DhcpMapJetError( JetError, "JetGetValue:RetrieveColumn2" );
        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
    }
    else {
        Error = ERROR_SUCCESS;
    }

    if( ActualDataSize == 0 ) {
        //
        // field is NULL.
        //
        *(LPBYTE *)Data = NULL;
        goto Cleanup;
    }

    DataBuffer = MIDL_user_allocate( ActualDataSize );

    if( DataBuffer == NULL ) {
        *(LPBYTE *)Data = NULL;
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    JetError = JetRetrieveColumn(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        ColumnId,
        DataBuffer,
        ActualDataSize,
        &NewActualDataSize,
        0,
        NULL );

    Error = DhcpMapJetError( JetError, "JetGetValue:RetrieveColumn3" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    DhcpAssert( ActualDataSize == NewActualDataSize );
    *(LPBYTE *)Data = DataBuffer;
    *DataSize = ActualDataSize;

    Error = ERROR_SUCCESS;

  Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // freeup local buffer.
        //

        if( DataBuffer != NULL ) {
            MIDL_user_free( DataBuffer );
        }
    }

    return( Error );
}



DWORD
DhcpJetPrepareSearch(
    char *ColumnName,
    BOOL SearchFromStart,
    PVOID Key,
    DWORD KeySize
)
    /*++

      Routine Description:

      This function prepares for a search of the client database.

      Arguments:

      ColumnName - The column name to use as the index column.

      SearchFromStart - If TRUE, search from the first record in the
      database.  If FALSE, search from the specified key.

      Key - The key to start the search.

      KeySize - The size, in bytes, of key.

      Return Value:

      None.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetSetCurrentIndex(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        ColumnName );

    Error = DhcpMapJetError( JetError, "PrepareSearch:SetCurrentIndex" );
    if( Error != ERROR_SUCCESS ) {
        DhcpMapJetError(JetError, ColumnName );
        return( Error );
    }

    if ( SearchFromStart ) {
        JetError = JetMove(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            JET_MoveFirst,
            0 );
    } else {
        JetError =  JetMakeKey(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            Key,
            KeySize,
            JET_bitNewKey );

        Error = DhcpMapJetError( JetError, "PrepareSearch:MakeKey" );
        if( Error != ERROR_SUCCESS ) {
            DhcpMapJetError(JetError, ColumnName);
            return( Error );
        }

        JetError = JetSeek(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            JET_bitSeekGT );
    }

    return( DhcpMapJetError( JetError, "PrepareSearch:Move/Seek" ));
}



DWORD
DhcpJetNextRecord(
    VOID
)
    /*++

      Routine Description:

      This function advances to the next record in a search.

      Arguments:

      None.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;

    JetError = JetMove(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        JET_MoveNext,
        0 );

    return( DhcpMapJetError( JetError, "JetNextRecord" ) );
}



DWORD
DhcpJetDeleteCurrentRecord(
    VOID
)
    /*++

      Routine Description:

      This function deletes the current record.

      Arguments:

      None.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;

    JetError = JetDelete( DhcpGlobalJetServerSession, DhcpGlobalClientTableHandle );
    return( DhcpMapJetError( JetError, "DeleteCurrentRecord:Delete" ) );
}



DHCP_IP_ADDRESS
DhcpJetGetSubnetMaskFromIpAddress(
    DHCP_IP_ADDRESS IpAddress
)
    /*++

      Routine Description:

      This function returns the SubnetMask of the specified client.

      Arguments:

      IpAddress - Client address.


      Return Value:

      SubnetMask of the client.

      --*/
{

    DWORD Error;
    DWORD Size;
    DHCP_IP_ADDRESS SubnetAddress = 0;

    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        &IpAddress,
        sizeof(IpAddress) );

    if ( Error != ERROR_SUCCESS ) {
        return( SubnetAddress );
    }

    Size = sizeof(SubnetAddress);
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[SUBNET_MASK_INDEX].ColHandle,
        (LPBYTE)&SubnetAddress,
        &Size );

    if ( Error != ERROR_SUCCESS ) {
        SubnetAddress = 0;
        return( SubnetAddress );
    }

    DhcpAssert( Size == sizeof(SubnetAddress) );

    return( SubnetAddress );
}


BOOL
DhcpGetIpAddressFromHwAddress(
    LPBYTE HardwareAddress,
    BYTE HardwareAddressLength,
    LPDHCP_IP_ADDRESS IpAddress
)
    /*++

      Routine Description:

      This function looks up the IP address corresponding to the given
      hardware address.

      Arguments:

      HardwareAddress - The hardware to look up.
      HardwareAddressLength - The length of the hardware address.
      IpAddress - Returns the corresponding IP address.

      Return Value:

      TRUE - The IP address was found.
      FALSE - The IP address could not be found.  *IpAddress = -1.


      --*/
{
    DWORD Error;
    DWORD Size;

    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColName,
        HardwareAddress,
        HardwareAddressLength );

    if ( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }

    //
    // Get the ip address information for this client.
    //

    Size = sizeof( *IpAddress );

    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
        (LPBYTE)IpAddress,
        &Size );

    if ( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }

    return( TRUE );
}



BOOL
DhcpGetHwAddressFromIpAddress(
    DHCP_IP_ADDRESS IpAddress,
    PBYTE HardwareAddress,
    DWORD HardwareAddressLength
)
    /*++

      Routine Description:

      This function looks up the IP address corresponding to the given
      hardware address.

      Arguments:

      IpAddress - Ipaddress of a record whose hw address is requested.
      HardwareAddress - pointer to a buffer where the hw address is returned.
      HardwareAddressLength - length of the above buffer.

      Return Value:

      TRUE - The IP address was found.
      FALSE - The IP address could not be found.  *IpAddress = -1.


      --*/
{
    DWORD Error;
    DWORD Size;

    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        &IpAddress,
        sizeof(IpAddress) );

    if ( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }

    //
    // Get the ip address information for this client.
    //

    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
        HardwareAddress,
        &HardwareAddressLength );

    if ( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }

    return( TRUE );
}




DWORD
DhcpCreateAndInitDatabase(
    CHAR *Connect,
    JET_DBID *DatabaseHandle,
    JET_GRBIT JetBits
)
    /*++

      Routine Description:

      This routine creates DHCP database and initializes it.

      Arguments:

      Connect - database type. NULL specifies the default engine (blue).

      DatabaseHandle - pointer database handle returned.

      JetBits - Create flags.

      Return Value:

      JET errors.

      --*/
{

    JET_ERR JetError;
    DWORD Error;
    JET_COLUMNDEF   ColumnDef;
    CHAR *IndexKey;
    DWORD i;
    CHAR DBFilePath[MAX_PATH];

    DBFilePath[ 0 ] = '\0';

    //
    // Create Database.
    //

    if ( ( strlen( DhcpGlobalOemDatabasePath ) + strlen( DhcpGlobalOemDatabaseName ) + 2 ) < MAX_PATH )
    {
        strcpy( DBFilePath, DhcpGlobalOemDatabasePath );
        strcat( DBFilePath, DHCP_KEY_CONNECT_ANSI );
        strcat( DBFilePath, DhcpGlobalOemDatabaseName );
    }

    //
    // Convert name to ANSI
    //
    OemToCharBuffA(DBFilePath, DBFilePath, strlen(DBFilePath) );
    
    JetError = JetCreateDatabase(
        DhcpGlobalJetServerSession,
        DBFilePath,
        Connect,
        DatabaseHandle,
        JetBits );

    Error = DhcpMapJetError( JetError, "CreateDatabase" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // Create Table.
    //

    JetError = JetCreateTable(
        DhcpGlobalJetServerSession,
        *DatabaseHandle,
        CLIENT_TABLE_NAME,
        DB_TABLE_SIZE,
        DB_TABLE_DENSITY,
        &DhcpGlobalClientTableHandle );

    Error = DhcpMapJetError( JetError, "CreateTable" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // Create columns.
    //

    //
    // Init fields of columndef that do not change between addition of
    // columns
    //

    ColumnDef.cbStruct  = sizeof(ColumnDef);
    ColumnDef.columnid  = 0;
    ColumnDef.wCountry  = 1;
    ColumnDef.langid    = DB_LANGID;
    ColumnDef.cp        = DB_CP;
    ColumnDef.wCollate  = 0;
    ColumnDef.cbMax     = 0;
    ColumnDef.grbit     = 0; // variable length binary and text data.


    for ( i = 0; i < CLIENT_TABLE_NUM_COLS; i++ ) {

        ColumnDef.coltyp   = DhcpGlobalClientTable[i].ColType;
        JetError = JetAddColumn(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            DhcpGlobalClientTable[i].ColName,
            &ColumnDef,
            NULL, // no optinal value.
            0,
            &DhcpGlobalClientTable[i].ColHandle );

        Error = DhcpMapJetError( JetError, "AddColumn" );
        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
    }

    //
    // finally create index.
    //

    IndexKey =  "+" IPADDRESS_STRING "\0";
    JetError = JetCreateIndex(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        JET_bitIndexPrimary,
        // ?? JET_bitIndexClustered will degrade frequent
        // update response time.
        IndexKey,
        strlen(IndexKey) + 2, // for two termination chars
        50
    );

    Error = DhcpMapJetError( JetError, "CreateIndex" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    IndexKey =  "+" HARDWARE_ADDRESS_STRING "\0";
    JetError = JetCreateIndex(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColName,
        JET_bitIndexUnique,
        IndexKey,
        strlen(IndexKey) + 2, // for two termination chars
        50
    );

    Error = DhcpMapJetError( JetError, "CreateIndex" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    IndexKey =  "+" MACHINE_NAME_STRING "\0";
    JetError = JetCreateIndex(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle,
        DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColName,
        JET_bitIndexIgnoreNull,
        IndexKey,
        strlen(IndexKey) + 2, // for two termination chars + 2, // for two termination chars
        50
    );

    Error = DhcpMapJetError( JetError, "CreateIndex" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpOpenMCastDbTable(
                 DhcpGlobalJetServerSession,
                 DhcpGlobalDatabaseHandle);

  Cleanup:

    if( Error != ERROR_SUCCESS ) {

        DhcpPrint(( DEBUG_JET, "Database creation failed, %ld.\n", Error ));
    }
    else {

        DhcpPrint(( DEBUG_JET, "Succssfully Created DHCP database ..\n" ));
    }

    return(Error);
}

DWORD
DhcpSetJetParameters(
    VOID
)
    /*++

      Routine Description:

      This routine sets all the jet system params.

      Arguments:

      none.

      Return Value:

      Windows Error.

      --*/
{

    JET_ERR JetError;
    CHAR DBFilePath[MAX_PATH];
    DWORD Error;

    DBFilePath[ 0 ] = '\0';

    // First check registry DynLoadJet parameter for value:
    // If it does not exist, then proceed, otherwise,
    // set DhcpGlobalDynLoadJet to this value!
    // Delete the key afterwards, anyways... so that things
    // work right the next time dhcp comes up.

    // this is to be done.

    DhcpPrint((DEBUG_MISC, "DhcpJetSetParameters: entered\n"));

    //
    // set checkpoint file path.
    //
    if ( ( strlen( DhcpGlobalOemDatabasePath ) + 2 ) < MAX_PATH )
    {
        strcpy( DBFilePath, DhcpGlobalOemDatabasePath );
        strcat( DBFilePath, DHCP_KEY_CONNECT_ANSI );
    }
    
    //
    // Convert OemPath to Ansi..
    //
    OemToCharBuffA(DBFilePath, DBFilePath, strlen(DBFilePath) );

    DhcpPrint(( DEBUG_MISC, 
		"Jet: Using the filepath: %s \n",
		DBFilePath ));

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,       //SesId - ignored
        JET_paramSystemPath,
        0,
        DBFilePath );
    
    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam SystemPath : %ld\n", JetError));
        goto Cleanup;
    }
    
    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,       //SesId - ignored
        JET_paramBaseName,
        0,
        DATABASE_BASE_NAME );
    
    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam paramBaseName : %ld\n", JetError ));
        goto Cleanup;
    }
    
    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,       //SesId - ignored
        JET_paramLogFileSize,
        1024,               // 1024kb - default is 5mb
        NULL );

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam paramLogFileSize : %ld\n", JetError ));
        goto Cleanup;
    }

    strcpy( DBFilePath, DhcpGlobalOemDatabasePath );
    strcat( DBFilePath, DHCP_KEY_CONNECT_ANSI );

    //
    // Convert OEM to ANSI
    //
    OemToCharBuffA(DBFilePath, DBFilePath, strlen(DBFilePath) );

    // maybe TempPath is just a directory name!!
    // the upgrade.doc Appendix is not very clear..
    // It says: TempPath is a pathname and not a filename
    // anymore.... (JET97)
    // Clarification from: cheen liao: pathnames should
    // end in '\' ==> only directory names allowed.

    DhcpPrint(( DEBUG_MISC, "Jet: tempPath = %s\n", 
		DBFilePath ));
    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,       //SesId - ignored
        JET_paramTempPath,
        0,
        DBFilePath );

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam: TempPath : %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // The max number of buffers for database usage
    //
    // The default number is 500.  600 events are allocated for 500
    // buffers -- Ian 10/21/93.  Each buffer is 4K.  By keeping the
    // number small, we impact performamce
    //

    // If you change the # of buffers, be sure to change
    // JET_paramStartFlushThreshold and StopFlushThreshold also!!!
    // Those numbers are percentages of this!

    // Note that for JET97, JET_paramMaxBuffers has been redefined
    // as JET_paramCacheSizeMax!

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,       //SesId - ignored
        JET_paramCacheSizeMax,
        500,                // larger buffers take more space but are good for perf
        NULL );             //ignored
    
    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam CacheSizeMax : %ld\n", JetError));
        goto Cleanup;
    }
    
    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,       //SesId - ignored
        JET_paramCacheSizeMin,
        4 * MAX_NO_SESSIONS,//see comment near JET_paramMaxSessions on this number
        NULL
        );

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam MaxBuffers : %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // The max. number of buffers to store old version of a record
    // (snapshot at the start of a transaction) Each version store is 16k
    // bytes.  A version store stores structures that hold information
    // derived from a snapshot of the database prior to an insert (20 bytes
    // roughly) or update (size of the record + 20 bytes).
    //
    // For small transactions (i.e. a transaction around each update),
    // this number should be >= the max. number of sessions that can be
    // updating/inserting at the same time.  Each session will have one
    // version bucket.  Since 16k of version bucket size can result in a
    // lot of wastage per session (since each record is < .5k, and on the
    // average around 50 bytes), it may be better to specify the max.  size
    // of the version bucket (<< 16k).  Ian will provide a system param for
    // this if we absolutely need it
    //
    // since we serialize the database access with the dhcp server, num.
    // of session will be one.
    //

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,
        JET_paramMaxVerPages,
        1500, // 1
        NULL);

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam paramMaxVerPages: %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // Set the File Control Block Param
    //
    // This is the max. number of tables that can be open at any time.
    // If multiple threads open the same table they use the same FCB.
    // FCB is 1 per table/index. Now, for a create database, we need
    // atleast 18 FCBS and 18 IDBS.  However apart from create database
    // and ddl operations, we don't need to have these tables open.
    // Default value is 300. Size of an FCB is 112 bytes.
    //
    // we have just one table.
    //

    // For __JET97, maxopentables and maxopentableindexes are combined
    // here .. So, the # here should be 18 + maxopentableindexes.

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,
        JET_paramMaxOpenTables,
        18 + 18 , //10
        NULL );

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam MaxOpenTables: %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // Set the File Usage Control Block to 100.  This parameter indicates
    // the max.  number of cursors that can be open at any one time.  This
    // is therefore dependent on the the max.  number of sessions that we
    // can have running concurrently.  For each session, there would be 4
    // cursors (for the two tables) + a certain number of internal cursors.
    // For good measure we add a pad.  Default value is 300.  Size of each
    // is 200 bytes.  We use MAX_SESSIONS * 4 + pad (around 100)
    //
    // MAX_SESSION = 1
    //

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,
        JET_paramMaxCursors,
        100, //32
        NULL );

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam MaxCursors: %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // Set the number of index description blocks. This is one per
    // table/index.  We have two tables each with two indices.  We use 9i
    // (see comment for FCBs above).  Default value is 300.  Size of each
    // is 128 bytes.
    //
    // We have only 2 indices.
    //

    // note that this parameter is subsumed in JET_paramMaxOpenTables.
    // so, to change this, a corresponding change must be effected there.
    // : JET97



    //
    // Set the Sort Control block.  This should be 1 per concurrent Create
    // Index.  Default value is 20.  Size of each is 612 bytes.  In the
    // case of WINS, the main thread creates the indices.  We therefore set
    // it to 1.
    //

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,
        JET_paramMaxTemporaryTables,
        1,
        NULL );

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam MaxTemporaryTables : %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // Set the Number for the Database Attribute Block
    //
    // This is max.  number of Open Databases done.  Since we can have a
    // max of MAX_NO_SESSIONS at one time.  This should be equal to that
    // number (since we have just one database) Default number is 100.
    // Size is 14 bytes
    //

    //
    // The min percentage of buffers not yet dirtied before
    // background flushing begins
    //

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,
        JET_paramStartFlushThreshold,
        (unsigned int) (0.80 * 50) , // 50 is JET_paramMaxBuffer
        NULL );

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam BfThrshldLowPrcnt : %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // The max percentage of buffers not yet dirtied before
    // background flushing begins
    //

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,
        JET_paramStopFlushThreshold,
        (unsigned int) (1.00 * 50 ) , // 50 is JET_parmaMaxBuffer
        NULL );

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetSetSysParam ThrshldHiPrcnt : %ld\n", JetError ));
        goto Cleanup;
    }


    //
    // The max.  number of sessions that can be open at any time
    //
    // Note: Jet does not preallocate resources corresponding to the max.
    // value.  It allocates them dynamically upto the limit -- according to
    // Ian Jose 7/12/93
    //
    // When checked with Ian again on 10/21, he said that they are
    // allocated statically
    //

    //
    // Note that paramMaxSessions mut be atleast fourtimes > MinBufferSize
    //  according to Cheen Liao (10/30/97) - RameshV
    // Just looked at wins code and it appears like
    //   Min cache size must be atlast 4 times the size of # of sessions
    //   according to Cheen.  Presume its my fault in inverting the ienqueality..
    // -- RameshV 05/18/98.
    // so we carefully fix the MinBufferSize variable..
    //

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID)0,
        JET_paramMaxSessions,
        MAX_NO_SESSIONS,
        NULL );


    if( DhcpGlobalDatabaseLoggingFlag ) {

        JetError = JetSetSystemParameter(
            &JetInstance, (JET_SESID)0, JET_paramRecovery, 0,
            "on"
            );
        Error = DhcpMapJetError( JetError, "SetSysParam" );
        if( Error != ERROR_SUCCESS ) {
            DhcpPrint((DEBUG_MISC, "JetSetSysParam Recovery %ld\n", JetError ));
            goto Cleanup;
        }
            
        //
        // The number of log sectors.  Each sector is 512 bytes.  We should
        // keep the size more than the threshold so that if the threshold is
        // reached and flushing starts, Jet can still continue to log in the
        // spare sectors.  Point to note is that if the log rate is faster than
        // the flush rate, then the Jet engine thread will not be able to log
        // when the entire buffer is filled up.  It will then wait until
        // space becomes available.
        //

        JetError = JetSetSystemParameter(
            &JetInstance,
            (JET_SESID)0,           //SesId - ignored
            JET_paramLogBuffers,
            30,                    // 30 sectors
            NULL );                 //ignored

        Error = DhcpMapJetError( JetError, "SetSysParam" );
        if( Error != ERROR_SUCCESS ) {
            DhcpPrint((DEBUG_MISC, "JetSetSysParam LogBuffers %ld\n", JetError ));
            goto Cleanup;
        }


        //
        // Set the number of log buffers dirtied before they are
        // flushed.  This number should always be less than the number
        // for LogBuffers so that spare sectors are there for concurrent
        // logging.  Also, we should make this number high enough to
        // handle burst of traffic.
        //

        // For JET97 this is automaticall set as half of LogBuffers.. and
        // cannot be set by user..

        //
        // Set the wait time (in msecs) to wait prior to flushing the
        // log on commit transaction to allow other users (sessions) to
        // share the flush
        //
        // This is the time after which the user (a session) will ask
        // the log manager to flush.  If we specify 0 here than it means
        // flush every time a transaction commits.  In the DHCP server
        // case, every insertion or modification is done under an
        // implicit transaction.  So, it means that there will be
        // a flush after every such transaction.  It has been seen on a
        // 486/66 (Cheen Liao) machine that it takes roughly 16 msecs to
        // do the flush.  The time it takes to do the flush is dependent
        // upon the type of disk (how fast it is), the CPU speed,
        // the type of file system etc. We can for now go with the
        // assumption that it is in the range 15-25 msecs. I am pushing
        // for this WaitTime to be made a session specific param so that
        // it can be changed on the fly if the admin. finds that
        // the DHCP server is slow due to the WaitTime being very low or
        // if it finds it to be so large that in case of a crash, there
        // is possibility to loose a lot of data.


        //
        // Making this session specific is also very important for
        // replication where we do want to set it to a high value (high
        // enough to ensure that most of the records that need to be
        // inserted are inserted before a flush action takes place.  The
        // wait time would be set every time a bunch of records are pulled
        // in for replication.  It will be computed based on the number of
        // records pulled in and the time it takes to insert one record in
        // the jet buffer.  The wait time should preferably be < than the
        // above computed time (it does not have to be).

        // NOTE: In the Pull thread, I will need to start two sessions,
        // one for updating the OwnerId-Version number table (0 wait time)
        // and the other to update the name-address mapping table (wait
        // time computed based on the factors mentioned above)


        //
        // The following will set the WaitLogFlush time for all sessions.
        //

        JetError = JetSetSystemParameter(
            &JetInstance,
            (JET_SESID)0,        //SesId - ignored
            JET_paramWaitLogFlush,
            100,        //wait 100 msecs after commit
            //before flushing
            NULL);      //ignored

        Error = DhcpMapJetError( JetError, "SetSysParam" );
        if( Error != ERROR_SUCCESS ) {
            DhcpPrint((DEBUG_MISC, "JetSetSysParam: WaitLogFlush : %ld\n", JetError ));
            goto Cleanup;
        }

        //
        // There does not seem to be any need to set Log Flush Period.
        //

        //
        // set the log file path
        //

        strcpy( DBFilePath, DhcpGlobalOemDatabasePath );
        strcat( DBFilePath, DHCP_KEY_CONNECT_ANSI );

        //
        // Convert OEM to ANSI
        //
        OemToCharBuffA(DBFilePath, DBFilePath, strlen( DBFilePath) );
        
        //
        // jet does't allow us to set the LOG file name for some
        // technical resons.
        //
        // strcat( DBFilePath, DATABASE_LOG_FILE );
        //

        JetError = JetSetSystemParameter(
            &JetInstance,
            (JET_SESID)0,       //SesId - ignored
            JET_paramLogFilePath,
            0,
            DBFilePath );

        Error = DhcpMapJetError( JetError, "SetSysParam" );
        if( NO_ERROR != Error ) {
            goto Cleanup;
        }
    }

    // Now set the JET_paramCheckFormatWhenOpenFail so that opening
    // the oldformat database would retrun JET_errDatabaseXXXFormat

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID) 0,
        JET_paramCheckFormatWhenOpenFail,
        1,
        NULL);

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS,
                    "JetSetSystemParmater failed on ChkFmtWhnOpnFail\n"));
        goto Cleanup;
    }

    //
    // dont restore if the old logs are not matching
    //

    JetError = JetSetSystemParameter(
        &JetInstance,
        (JET_SESID) 0,
        JET_paramDeleteOutOfRangeLogs,
        1,
        NULL );

    Error = DhcpMapJetError( JetError, "SetSysParam" );
    if ( Error != ERROR_SUCCESS )
    {
        DhcpPrint( ( DEBUG_ERRORS,
                    "JetSetSystemParameter failed on DeleteOutOfRangeLogs\n"));
        
        goto Cleanup;
    }
                    
  Cleanup:

    if ( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS,
                    "DhcpJetSetParameters failed, %ld.\n", Error ));
    }
    return( Error );
}

VOID
DhcpTerminateJet()
/*++
    This routine ends the jet session and terminates the jet engine.
--*/
{
    DWORD   JetError;

    if( DhcpGlobalJetServerSession != 0 ) {
        JetError = JetEndSession( DhcpGlobalJetServerSession, 0 );
        DhcpPrint((DEBUG_MISC, "JetEndSession\n")); // JET TRACE
        DhcpMapJetError( JetError, "EndSession" );
        DhcpGlobalJetServerSession = 0;
    }
    JetError = JetTerm2( JetInstance, JET_bitTermComplete );
    DhcpMapJetError( JetError, "JetTerm/JetTerm2" );
}

static ULONG InitCount = 0;


DWORD __stdcall
DhcpUpgradeAddDbEntry(
    IN PDHCP_RECORD Rec
    );

DWORD
UpgradeDhcpDatabase(
    VOID
    )
{
    DWORD Error;
    
    Error = DhcpUpgConvertTempToDhcpDb( DhcpUpgradeAddDbEntry );
    
    if( NO_ERROR != Error ) {

        DhcpServerEventLog(
            EVENT_SERVER_DATABASE_CONVERSION,
            EVENTLOG_ERROR_TYPE,
            Error );
        
    }

    return Error;
}


DWORD
DhcpDeleteFiles(
    LPSTR DatabasePath,
    LPSTR Files
)
    /*++

      Routine Description:

      Delete files .

      Arguments:

      DatabasePath - full path name where the database is restored.

      Files - files to be deleted (can have wild char. in filename).

      Return Value:

      Windows Error.

      --*/
{
    DWORD Error;
    CHAR CurrentDir[ MAX_PATH ];
    HANDLE HSearch = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAA FileData;

    CHAR DstFile[ MAX_PATH ];
    LPSTR DstFileNamePtr;

    //
    // Read and save current directory to restore CD at the end.
    //

    if( GetCurrentDirectoryA( MAX_PATH, CurrentDir ) == 0 ) {
        Error = GetLastError();
        DhcpPrint(( DEBUG_JET,
                    "GetCurrentDirctoryA failed, Error = %ld.\n", Error ));
        return( Error );
    }

    //
    // set current directory to backup path.
    //

    if( SetCurrentDirectoryA( DatabasePath ) == FALSE ) {
        Error = GetLastError();
        DhcpPrint(( DEBUG_JET,
                    "SetCurrentDirctoryA failed, Error = %ld.\n", Error ));
        goto Cleanup;
    }

    //
    // Start file serach on current dir.
    //

    HSearch = FindFirstFileA( Files, &FileData );

    if( HSearch == INVALID_HANDLE_VALUE ) {
        Error = GetLastError();
        DhcpPrint(( DEBUG_JET,
                    "FindFirstFileA failed (Files = %s), Error = %ld.\n",
		    Files, Error ));
        goto Cleanup;
    }

    //
    // delete files.
    //

    for( ;; ) {

        if( DeleteFileA( FileData.cFileName ) == FALSE ) {

            Error = GetLastError();
            DhcpPrint(( DEBUG_JET,
                        "CopyFileA failed, Error = %ld.\n", Error ));
            goto Cleanup;
        }

        //
        // Find next file.
        //

        if ( FindNextFileA( HSearch, &FileData ) == FALSE ) {

            Error = GetLastError();

            if( Error == ERROR_NO_MORE_FILES ) {
                break;
            }

            DhcpPrint(( DEBUG_JET,
                        "FindNextFileA failed, Error = %ld.\n", Error ));
            goto Cleanup;
        }
    }

  Cleanup:

    if( HSearch != INVALID_HANDLE_VALUE ) {
        FindClose( HSearch );
    }

    if( ERROR_NO_MORE_FILES == Error ) Error = NO_ERROR;
    if( ERROR_FILE_NOT_FOUND == Error ) Error = NO_ERROR;
    
    //
    // reset current currectory.
    //

    SetCurrentDirectoryA( CurrentDir );

    return( Error );
}

DWORD
DhcpInitializeDatabaseEx(
    IN BOOL fReadOnly
)
/*++

Routine Description:
    This function initializes the DHCP database. If the DHCP database
    exists then it open the database and initialize all ColumnIds,
    otherwise it creates a new database and obtains ColumnsIds.

Arguments:
    fReadOnly -- this parameter is set to TRUE only if it is
    called from outside the service -- in this case nothing new
    must be created..

Return Value:
    Windows Error.

--*/
{
    JET_ERR JetError;
    JET_COLUMNDEF columnDef;
    DWORD Error;
    DWORD i;
    CHAR DBFilePath[MAX_PATH];
    BOOL fRunUpgradeStuff = FALSE;
    
    DBFilePath[ 0 ] = '\0';

    if( 0 != InitCount ) return ERROR_SUCCESS;

    //
    // If upgrade is not completed yet, delete all the log files
    // and remember this so that soon after the database is
    // created, the upgrade code can be run
    //
    
    if( !fReadOnly && TRUE == DhcpCheckIfDatabaseUpgraded(FALSE) ) {
        CHAR DBFilePath[MAX_PATH];

        fRunUpgradeStuff = TRUE;

        if ( strlen( DhcpGlobalOemDatabasePath ) < MAX_PATH )
            strcpy( DBFilePath, DhcpGlobalOemDatabasePath );

        OemToCharBuffA(DBFilePath, DBFilePath, strlen(DBFilePath) );
        
        Error = DhcpDeleteFiles( DBFilePath, "j50*.log" );
        if( NO_ERROR != Error ) {
            DhcpPrint((DEBUG_ERRORS, "Delete log files: 0x%lx\n",
                       Error));
            return Error;
        }

        Error = DhcpDeleteFiles( DBFilePath, "*.mdb" );
        if( NO_ERROR != Error ) {
            DhcpPrint((DEBUG_ERRORS, "Delete mdb files: 0x%lx\n",
                       Error ));
            return Error;
        }
    } // if upgrade
        
    LOCK_DATABASE();

    DhcpPrint((DEBUG_MISC, "Entering DhcpInitializeDatabase\n"));
    Error = DhcpSetJetParameters();
    if ( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // -------------------------------------------------------------------
    //
    DhcpPrint(( DEBUG_ERRORS,
                "Calling JetInit\n" ));
    JetError = JetInit( &JetInstance );
    DhcpPrint((DEBUG_MISC,"DhcpInitializeDatabase: JetInit(_): %ld\n", JetError));

    DhcpPrint(( DEBUG_ERRORS,
                "After Calling JetInit\n" ));

    Error = DhcpMapJetError( JetError, "JetInit" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    JetError = JetBeginSession(
        JetInstance,
        &DhcpGlobalJetServerSession,
        "admin",
        "" );

    if( *(DWORD *)(DhcpGlobalJetServerSession) == -1 ) {
        DhcpPrint((DEBUG_MISC, "JetBeginSession returned -1 session!\n"));
    }

    DhcpPrint((DEBUG_MISC, "JetBeginSession\n")); //JET TRACE
    Error = DhcpMapJetError( JetError, "JetBeginSEssion" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "JetBeginSession: %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // Attach the database so that it always looks at the place where
    // we want to.
    //

    DBFilePath[ 0 ] = '\0';

    if ( ( strlen( DhcpGlobalOemDatabasePath ) + strlen( DhcpGlobalOemDatabaseName) + 2 ) < MAX_PATH )
    {
        strcpy(DBFilePath, DhcpGlobalOemDatabasePath );
        strcat(DBFilePath, DHCP_KEY_CONNECT_ANSI );
        strcat(DBFilePath, DhcpGlobalOemDatabaseName );
    }

    //
    // Convert OEM to ANSI
    //
    OemToCharBuffA(DBFilePath, DBFilePath, strlen(DBFilePath) );
    
    //
    // detach all previous installation of dhcp databases.
    //

    DhcpPrint((DEBUG_MISC, "Trying to JetDetachDb(%ld)\n", DhcpGlobalJetServerSession)); // JET TRACE
    JetError = JetDetachDatabase(
        DhcpGlobalJetServerSession,
        NULL );

    DhcpPrint((DEBUG_MISC, "JetDetachDatabase\n")); // JET TRACE

    Error = DhcpMapJetError( JetError, "JetDetachDatabase" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "DhcpDetachDatabase: %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // attach current dhcp database file.
    //

    DhcpPrint((DEBUG_MISC, "Trying to JetAttachDatabase %s\n", DBFilePath));
    JetError = JetAttachDatabase(
        DhcpGlobalJetServerSession,
        DBFilePath,
        0 );

    DhcpPrint((DEBUG_MISC, "JetAttachDatabase\n")); // JET TRACE

    //
    // if the database is not found, it is ok. We will create it later.
    //

    if ( JetError != JET_errFileNotFound ) {

        Error = DhcpMapJetError( JetError, "AttachDatabase" );
        if( Error != ERROR_SUCCESS ) {
            DhcpPrint((DEBUG_MISC, "DhcpMapJetError %ld\n", JetError ));
            goto Cleanup;
        }
    }

    //
    // hook the client table pointer.
    //

    DhcpGlobalClientTable = ClientTable;
    DhcpAssert( CLIENT_TABLE_NUM_COLS == MAX_INDEX );

    JetError = JetOpenDatabase(
        DhcpGlobalJetServerSession,
        DBFilePath,  // full path and file name.
        NULL, // default engine
        &DhcpGlobalDatabaseHandle,
	0 );

    DhcpPrint((DEBUG_MISC, "JetOpenDatabase\n")); // JET TRACE
    //
    // if no database exists then create one and also initize it for
    // use.
    //

    if( !fReadOnly && JetError == JET_errDatabaseNotFound ) {

        Error = DhcpCreateAndInitDatabase(
            NULL, // default engine
            &DhcpGlobalDatabaseHandle,
            0 );


        DhcpPrint((DEBUG_MISC, "JetCreateAndInitDatabase\n")); // JET TRACE
        goto Cleanup;
    }

    Error = DhcpMapJetError( JetError, "CreateAndInitDb" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "DhcpOpenDatabase %ld\n", JetError ));
        goto Cleanup;
    }

    //
    // database is successfully opened, open table and columns now.
    //

    JetError = JetOpenTable(
        DhcpGlobalJetServerSession,
        DhcpGlobalDatabaseHandle,
        CLIENT_TABLE_NAME,
        NULL,
        0,
        0,
        &DhcpGlobalClientTableHandle );
    DhcpPrint((DEBUG_MISC, "JetOpenTable\n")); // JET TRACE

    Error = DhcpMapJetError( JetError, "OpenTable" );
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_MISC, "DhcpOpenTable %ld\n", JetError ));
        goto Cleanup;
    }

    for ( i = 0; i < CLIENT_TABLE_NUM_COLS; i++ ) {

        JetError = JetGetTableColumnInfo(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            DhcpGlobalClientTable[i].ColName,
            &columnDef,
            sizeof(columnDef),
            0);
        DhcpPrint((DEBUG_MISC, "JetCreateTableColumnInfo\n")); // JET TRACE

        //
        // if the column doesn't exist, add it now.
        //

        if ( JET_errColumnNotFound == JetError )
        {
            JET_COLUMNDEF   ColumnDef;

            ColumnDef.cbStruct = sizeof( ColumnDef );
            ColumnDef.columnid = 0;
            ColumnDef.wCountry = 1;
            ColumnDef.langid   = DB_LANGID;
            ColumnDef.cp       = DB_CP;
            ColumnDef.wCollate = 0;
            ColumnDef.cbMax    = 0;
            ColumnDef.grbit    = 0;

            ColumnDef.coltyp   = DhcpGlobalClientTable[i].ColType;
            JetError = JetAddColumn(
                DhcpGlobalJetServerSession,
                DhcpGlobalClientTableHandle,
                DhcpGlobalClientTable[i].ColName,
                &ColumnDef,
                NULL,
                0,
                &DhcpGlobalClientTable[i].ColHandle );
            DhcpPrint((DEBUG_MISC, "JetAddColumn\n")); // JET TRACE
        }

        Error = DhcpMapJetError( JetError, "AddColumn" );
        if( Error != ERROR_SUCCESS ) {
            DhcpPrint((DEBUG_MISC, "JetTableColumnInfo %ld\n", Error ));
            goto Cleanup;
        }

        DhcpGlobalClientTable[i].ColHandle  = columnDef.columnid;
    }

    Error = DhcpOpenMCastDbTable(
                 DhcpGlobalJetServerSession,
                 DhcpGlobalDatabaseHandle);

  Cleanup:
    DhcpPrint((DEBUG_MISC, "Exiting DhcpInitializeDatabase %ld\n", Error));

    if( ERROR_SUCCESS == Error ) {
        InitCount ++;
        if( fRunUpgradeStuff ) {
            Error = UpgradeDhcpDatabase();
            if( NO_ERROR != Error ) {
                DhcpPrint((DEBUG_MISC, "UpgradeDhcpDatabase: 0x%lx\n", Error));
            }
        }
    }
    
    if( NO_ERROR != Error ) {
        
        //
        // terminate/cleanup jet session, if we are not successful.
        //

        if( DhcpGlobalClientTableHandle != 0 ) {
            JetError = JetCloseTable(
                DhcpGlobalJetServerSession,
                DhcpGlobalClientTableHandle );
            DhcpMapJetError( JetError, "CloseTable" );
            DhcpPrint((DEBUG_MISC, "JetCloseTable\n")); // JET TRACE
            DhcpGlobalClientTableHandle = 0;
        }

        if( DhcpGlobalDatabaseHandle != 0 ) {
            JetError = JetCloseDatabase(
                DhcpGlobalJetServerSession,
                DhcpGlobalDatabaseHandle,
                0 );
            DhcpPrint((DEBUG_MISC, "JetCloseDatabase\n")); // JET TRACE
            DhcpMapJetError( JetError, "CloseDatabse" );
            DhcpGlobalDatabaseHandle = 0;
        }

        DhcpTerminateJet();
    }

    UNLOCK_DATABASE();
    return( Error );
}

DWORD
DhcpInitializeDatabase(
    VOID
)
{
    return DhcpInitializeDatabaseEx( FALSE );
}

VOID
DhcpCleanupDatabase(
    IN DWORD ErrorCode
)
/*++

Routine Description:
    This function cleans up the JET database data structures after
    gracefully shutting down the JET.

Arguments:
    ErrorCode - Supplies the error code of the failure

Return Value:
    none.

 --*/
{
    DWORD Error;
    JET_ERR JetError;
    CHAR DBFilePath[MAX_PATH];
    char *backupPrefix = "\\New";

    DBFilePath[ 0 ] = '\0';

    //
    // Convert path to ANSI
    //
    if( NULL != DhcpGlobalOemJetBackupPath ) {
    if ( ( strlen( DhcpGlobalOemJetBackupPath ) + strlen( backupPrefix ) ) < MAX_PATH )
        strcpy(DBFilePath, DhcpGlobalOemJetBackupPath );
        strcat(DBFilePath, backupPrefix );

        OemToCharBuffA(DBFilePath, DBFilePath, strlen(DBFilePath) );
    }

    if( 0 == InitCount ) return;
    InitCount --;
    if( 0 != InitCount ) return;

    LOCK_DATABASE();

    //
    // do full database backup before shutdown, so that it can
    // restored to another machine without loss of any database changes.
    //

    if( (DhcpGlobalClientTableHandle != 0) &&
        (DhcpGlobalDatabaseHandle != 0) ) {

        //
        // backup the database only if we are not halting the system due
        // to a database error, otherwise we may potentially spoil the
        // good backup database.
        //

        if( ErrorCode != ERROR_DHCP_JET_ERROR ) {

            //
            // don't backup the data while the system is shutting down
            // since the backup may take several mins.
            //

            if ( !DhcpGlobalSystemShuttingDown ) {

                Error = DhcpBackupDatabase( DhcpGlobalOemJetBackupPath, TRUE );

                if( Error != ERROR_SUCCESS ) {

                    DhcpServerEventLog(
                        EVENT_SERVER_DATABASE_BACKUP,
                        EVENTLOG_ERROR_TYPE,
                        Error );

                    DhcpPrint(( DEBUG_ERRORS,
                                "DhcpBackupDatabase failed, %ld.\n", Error ));
                }
            }
        }
    } // if

    if( DhcpGlobalClientTableHandle != 0 ) {
        JetError = JetCloseTable(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle );
        DhcpMapJetError( JetError, "CloseTable" );
        DhcpGlobalClientTableHandle = 0;
    }

    if( DhcpGlobalDatabaseHandle != 0 ) {
        JetError = JetCloseDatabase(
            DhcpGlobalJetServerSession,
            DhcpGlobalDatabaseHandle,
            0 );
        DhcpMapJetError( JetError, "CloseDatabase" );
        DhcpGlobalDatabaseHandle = 0;
    }


    DhcpTerminateJet();

    UNLOCK_DATABASE();

    DeleteCriticalSection(&DhcpGlobalJetDatabaseCritSect);

    //
    // HACK: Delete jet log files as restore sometimes seems to cause
    // corruption as old log files are copied back this needs dhcp server
    // to be started twice
    //

   Error =  DhcpDeleteFiles( DhcpGlobalOemDatabasePath, "j50*.log" );
   if ( Error == ERROR_SUCCESS )
   {
        //
        // delete the ancient logs from the backup directory as well
        //

        Error = DhcpDeleteFiles( DBFilePath, "j50*.log" );
   }
    
}

DWORD
DhcpBackupDatabase(
    LPSTR BackupPath,
    BOOL FullBackup
)
    /*++

      Routine Description:

      This functions backup the JET database. FullBackup copies the
      database file and all log files. Incremental backup copies only
      the log files that are modified since the last backup.

      Arguments:

      BackupPath - full path name where the database is backed up.

      FullBackup - set to TRUE if full backup is required.

      Return Value:

      Windows Error.

      --*/
{
    DWORD Error;
    JET_ERR JetError;
    JET_GRBIT BackupBits = 0;
    CHAR DBFilePath[MAX_PATH];

    DBFilePath[ 0 ] = '\0';

    //
    // Convert path to ANSI
    //
    if( NULL != BackupPath ) {
        if ( strlen( BackupPath ) < MAX_PATH ) 
            strcpy(DBFilePath, BackupPath);

        OemToCharBuffA(DBFilePath, DBFilePath, strlen(DBFilePath) );
        BackupPath = DBFilePath;
    }
    
    //
    // According to the jetapi.doc, we don't need to take any locks while backing up..
    //

    DhcpPrint(( DEBUG_JET,
                "DhcpBackupDatabase (%s) called.\n", BackupPath ));
    
    BackupBits  =   JET_bitBackupAtomic | JET_bitBackupFullWithAllLogs;

    JetError = JetBackup( BackupPath, BackupBits, NULL );

    Error = DhcpMapJetError( JetError, (BackupPath)? "JetBackup" : "JetBackupToNULL");

    DhcpPrint(( DEBUG_JET,
                "DhcpBackupDatabase (FULL) completed.\n" ));

    return( Error );
} // DhcpBackupDatabase()
DWORD
DhcpRestoreDatabase(
    LPSTR BackupPath
)
    /*++

      Routine Description:

      This function restores the database from the backup path to
      the working directory. It also plays pack the log files from the
      backup path first and then the log files from working path. After
      this restore the database should be brought back to the state when
      the last successful update on the database was performed.

      Arguments:

      BackupPath - full path name where the database is backed up.

      Return Value:

      Windows Error.

      --*/
{
    DWORD Error;
    JET_ERR JetError;
    CHAR DBFilePath[MAX_PATH];

    //
    // Convert path to ANSI
    //

    ASSERT( NULL != BackupPath );
    strcpy(DBFilePath, BackupPath);
    OemToCharBuffA(DBFilePath, DBFilePath, strlen(DBFilePath) );
    BackupPath = DBFilePath;
    
    DhcpPrint(( DEBUG_JET, "DhcpRestoreDatabase(%s) called.\n", BackupPath ));
    
    LOCK_DATABASE();

    Error = DhcpSetJetParameters();

    do {
	if ( Error != ERROR_SUCCESS ) {
//  	    goto Cleanup;
	    break;
	}
	
	//
	// HACK! delete all log files in the database directory. The
	// reason for doing this is because, JetRestore just copies
	// over the backed up database and log files and replays all
	// the logfiles -- including the ones present before the restore.
	// This is obviously no good as the logs could have been
	// there after the backup...  
	//
	
	DhcpPrint(( DEBUG_MISC, 
		    "BackupPath = %s, DhcpGlobalOemJetBackupPath = %s\n",
		    BackupPath, DhcpGlobalOemJetBackupPath ));
	
	if( _stricmp(BackupPath, DhcpGlobalOemJetBackupPath) ) {
	    
	    Error = DhcpDeleteFiles( DhcpGlobalOemDatabasePath, "j50*.log" );
	    if( NO_ERROR != Error ) {
//  		goto Cleanup;
		break;
	    }
	} // if 
	
	//
	// Since DHCP has only one database and we need to restore it, it is
	// not necessary to specify the list of databases to restore, so the
	// parameters 2, 3, and 4 are set to ZERO.
	//
	JetError = JetRestore( BackupPath,
			       0);      // restore all databases.
	
	Error = DhcpMapJetError( JetError, "JetRestore" );
    } // do
    while ( FALSE );
    
//   Cleanup:

    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS, "Restore failed: 0x%lx\n", Error));

//          if( _stricmp( DhcpGlobalOemJetBackupPath, BackupPath )) {
//              JetError = DhcpRestoreDatabase(
//                  DhcpGlobalOemBackupPath );
//              ASSERT( NO_ERROR != JetError );
//          }
    } // if
    
    UNLOCK_DATABASE();
    return( Error );
} // DhcpRestoreDatabase()

DWORD __stdcall
DhcpUpgradeAddDbEntry(
    IN PDHCP_RECORD Rec
    )
{
    WCHAR Name[512], Info[512];
    WCHAR *pName, *pInfo;
    DWORD Address, ScopeId;
    
    pName = pInfo = NULL;
    
    //
    // Add a DHCP or madcap record
    //
    
    if( Rec->fMcast == FALSE ) {
        if( NULL != Rec->Info.Dhcp.Name ) {
            pName = Name;
            while( *pName = *Rec->Info.Dhcp.Name ) {
                pName ++; Rec->Info.Dhcp.Name ++;
            }
            pName = Name;
        }

        if( NULL != Rec->Info.Dhcp.Info ) {
            pInfo = Info;
            while( *pInfo = *Rec->Info.Dhcp.Info ) {
                pInfo ++; Rec->Info.Dhcp.Info ++;
            }
            pInfo = Info;
        }
        
        return CreateClientDBEntry(
            ntohl(Rec->Info.Dhcp.Address),
            ntohl(Rec->Info.Dhcp.Mask),
            Rec->Info.Dhcp.HwAddr, Rec->Info.Dhcp.HwLen, 
            *(DATE_TIME *)&Rec->Info.Dhcp.ExpTime, pName, pInfo,
            INADDR_LOOPBACK, Rec->Info.Dhcp.State,
            Rec->Info.Dhcp.Type );
        
    } else {

        //
        // Fake name and info for madcap
        //
        
        if( NULL != Rec->Info.Mcast.Info ) {
            pInfo = Info;
            while( *pInfo = *Rec->Info.Mcast.Info ) {
                pInfo ++; Rec->Info.Mcast.Info ++;
            }
            pInfo = Info;
        }

        Address = ntohl(Rec->Info.Mcast.Address);
        ScopeId = ntohl(Rec->Info.Mcast.ScopeId);

        return MadcapCreateClientEntry(
            (PVOID)&Address, sizeof(Address), ScopeId, 
            Rec->Info.Mcast.ClientId, Rec->Info.Mcast.HwLen, 
            pInfo, *(DATE_TIME *)&Rec->Info.Mcast.Start,
            *(DATE_TIME *)&Rec->Info.Mcast.End,
            INADDR_ANY, Rec->Info.Mcast.State, 0, FALSE );
    }
}

DWORD
DhcpOpenAndReadDatabaseConfig(
    IN LPSTR OemDatabaseName,
    IN LPSTR OemDatabasePath,
    OUT PM_SERVER *Server
    )
{
    BOOL LoadStrings(VOID);
    VOID FreeStrings(VOID);
    DWORD Error;

    //
    // Initialize required globals so that InitDatabase can be called.
    //
    
    DhcpGlobalOemDatabasePath = OemDatabasePath;
    DhcpGlobalOemDatabaseName = OemDatabaseName;
    if( FALSE == LoadStrings() ) return ERROR_NOT_ENOUGH_MEMORY;
    DhcpGlobalDatabaseLoggingFlag = TRUE;
    DhcpGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;

    try {
        InitializeCriticalSection(&DhcpGlobalJetDatabaseCritSect);
    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        Error = GetLastError( );
        return Error;
    }

    Error = DhcpInitializeDatabaseEx(TRUE);
    DeleteCriticalSection(&DhcpGlobalJetDatabaseCritSect);

    //
    // Read config, uninitialize everything and return
    //
    
    if( NO_ERROR == Error ) Error = DhcpReadConfigInfo( Server );
            
    FreeStrings();
    DhcpTerminateJet();
    DhcpGlobalOemDatabasePath = NULL;
    DhcpGlobalOemDatabaseName = NULL;
    
    return Error;
}

DWORD
DhcpOpenAndWriteDatabaseConfig(
    IN LPSTR OemDatabaseName,
    IN LPSTR OemDatabasePath,
    IN PM_SERVER Server
    )
{
    BOOL LoadStrings(VOID);
    VOID FreeStrings(VOID);
    DWORD Error;

    //
    // Initialize required globals so that InitDatabase can be called.
    //
    
    DhcpGlobalOemDatabasePath = OemDatabasePath;
    DhcpGlobalOemDatabaseName = OemDatabaseName;
    if( FALSE == LoadStrings() ) return ERROR_NOT_ENOUGH_MEMORY;
    DhcpGlobalDatabaseLoggingFlag = TRUE;
    DhcpGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;
    
    try {
        InitializeCriticalSection(&DhcpGlobalJetDatabaseCritSect);
    } except ( EXCEPTION_EXECUTE_HANDLER ) {
        Error = GetLastError( );
        return Error;
    }

    Error = DhcpInitializeDatabaseEx(TRUE);
    DeleteCriticalSection(&DhcpGlobalJetDatabaseCritSect);

    //
    // write config, uninitialize everything and return
    //
    
    if( NO_ERROR == Error ) {
        Error = DhcpOpenConfigTable(
            DhcpGlobalJetServerSession, DhcpGlobalDatabaseHandle );

        if( NO_ERROR == Error ) {
            
            Error = DhcpSaveConfigInfo(
                Server, FALSE, FALSE, 0, 0, 0 );
        }
    }
    
    FreeStrings();
    DhcpTerminateJet();
    DhcpGlobalOemDatabasePath = NULL;
    DhcpGlobalOemDatabaseName = NULL;
    
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\dbconfig.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    dbconfig.c

Abstract:

    implements the routines needed to read and write
    configuration information to the database.

--*/

#include <dhcppch.h>

#define DBCFG_INDEX_STR "DbcfgIndex"
#define DBCFG_TYPE_STR "DbcfgType"
#define DBCFG_SUBTYPE_STR "DbcfgSubType"
#define DBCFG_FLAGS_STR "DbcfgFlags"

#define DBCFG_NAME_STR "DbcfgName"
#define DBCFG_COMMENT_STR "DbcfgComment"
#define DBCFG_INFO_STR "DbcfgInfo"

//
// class definitions
//

//
// Option definitions
//

#define DBCFG_OPTION_ID_STR "DbcfgOptionId"
#define DBCFG_OPTION_USER_STR "DbcfgUserClass"
#define DBCFG_OPTION_VENDOR_STR "DbcfgVendorClass"

//
// Subnet defintions
//

#define DBCFG_IPADDRESS_STR "DbcfgIpAddress"
#define DBCFG_MASK_STR "DbcfgMaskStr"
#define DBCFG_SUPERSCOPE_STR "DbcfgSuperScopeName"

//
// Mscope definitions
//

#define DBCFG_MSCOPEID_STR "DbcfgMscopeId"
#define DBCFG_MSCOPELANG_STR "DbcfgMscopeLang"
#define DBCFG_MSCOPETTL_STR "DbcfgMscopeTtl"
#define DBCFG_MSCOPE_EXPIRY_STR "DbcfgMscopeExpiry"

//
// Range definitions
//

#define DBCFG_RANGE_START_STR "DbcfgRangeStart"
#define DBCFG_RANGE_END_STR "DbcfgRangeEnd"
#define DBCFG_RANGE_MASK_STR "DbcfgRangeMask"
#define DBCFG_BOOTP_ALLOCATED_STR "DbcfgBootpAlloc"
#define DBCFG_BOOTP_MAX_STR "DbcfgBootMax"

//
// Reservation definitions
//

//
// types of records
//

enum {
    DBCFG_CLASS,
    DBCFG_OPT,
    DBCFG_OPTDEF,
    DBCFG_SCOPE,
    DBCFG_MSCOPE,
    DBCFG_RANGE,
    DBCFG_EXCL,
    DBCFG_RESERVATION
};

TABLE_INFO DbcfgTable[] = {
    DBCFG_INDEX_STR,0, JET_coltypLong,
    DBCFG_TYPE_STR,0, JET_coltypLong,
    DBCFG_SUBTYPE_STR,0, JET_coltypLong,
    DBCFG_FLAGS_STR,0, JET_coltypLong,
    DBCFG_NAME_STR,0, JET_coltypLongBinary,
    DBCFG_COMMENT_STR,0, JET_coltypLongBinary,
    DBCFG_INFO_STR,0, JET_coltypLongBinary,
    DBCFG_OPTION_ID_STR,0, JET_coltypLong,
    DBCFG_OPTION_USER_STR,0, JET_coltypLongBinary,
    DBCFG_OPTION_VENDOR_STR,0, JET_coltypLongBinary,
    DBCFG_IPADDRESS_STR,0, JET_coltypLong,
    DBCFG_MASK_STR,0, JET_coltypLong,
    DBCFG_SUPERSCOPE_STR,0, JET_coltypLongBinary,
    DBCFG_MSCOPEID_STR,0, JET_coltypLong,
    DBCFG_MSCOPELANG_STR,0, JET_coltypLongBinary,
    DBCFG_MSCOPETTL_STR,0, JET_coltypLong,
    DBCFG_MSCOPE_EXPIRY_STR,0, JET_coltypCurrency,
    DBCFG_RANGE_START_STR,0, JET_coltypLong,
    DBCFG_RANGE_END_STR,0, JET_coltypLong,
    DBCFG_RANGE_MASK_STR,0, JET_coltypLong,
    DBCFG_BOOTP_ALLOCATED_STR,0, JET_coltypLong,
    DBCFG_BOOTP_MAX_STR,0, JET_coltypLong,
};

enum {
    DBCFG_INDEX,
    DBCFG_TYPE,
    DBCFG_SUBTYPE,
    DBCFG_FLAGS,
    DBCFG_NAME,
    DBCFG_COMMENT,
    DBCFG_INFO,
    DBCFG_OPTION_ID,
    DBCFG_OPTION_USER,
    DBCFG_OPTION_VENDOR,
    DBCFG_IPADDRESS,
    DBCFG_MASK,
    DBCFG_SUPERSCOPE,
    DBCFG_MSCOPEID,
    DBCFG_MSCOPELANG,
    DBCFG_MSCOPETTL,
    DBCFG_MSCOPE_EXPIRY,
    DBCFG_RANGE_START,
    DBCFG_RANGE_END,
    DBCFG_RANGE_MASK,
    DBCFG_BOOTP_ALLOCATED,
    DBCFG_BOOTP_MAX,
    DBCFG_LAST_COLUMN
};

JET_TABLEID DbcfgTbl;

#define DBCFG_TABLE_NAME "DbcfgTable"


typedef struct _DB_CREATE_CONTEXT {
    IN JET_SESID SesId;
    IN ULONG Index;
    IN PM_SERVER Server;
    
    IN PM_CLASSDEF UserClass, VendorClass;
    IN PM_SUBNET Subnet;
    IN PM_RESERVATION Reservation;

    //
    // If all of the below are zero, then it is a complete
    // wildcard. If fClassChanged or fOptionsChanged changed,
    // then only classes or options are changed.  In case of the
    // latter, AffectedSubnet or AffectedMscope or
    // AffectedReservation indicates only the specific options got
    // affected (if none specified, "global" is assumed).
    // If no options/class changed, but subnet/mscope/reservation
    // specified, only those are affected.
    //
    IN BOOL fClassChanged;
    IN BOOL fOptionsChanged;
    IN DWORD AffectedSubnet;
    IN DWORD AffectedMscope;
    IN DWORD AffectedReservation;
} DB_CREATE_CONTEXT, *PDB_CREATE_CONTEXT;

typedef struct _DBCFG_ENTRY {
    ULONG Bitmasks; // indicates which of the fields below is present
    ULONG Index;
    ULONG Type, SubType, Flags;
    LPWSTR Name, Comment;
    PUCHAR Info;
    ULONG OptionId;
    LPWSTR UserClass, VendorClass;
    ULONG IpAddress, Mask;
    LPWSTR SuperScope;
    ULONG MscopeId;
    LPWSTR MscopeLang;
    ULONG Ttl;
    FILETIME ExpiryTime;
    ULONG RangeStart, RangeEnd, RangeMask;
    ULONG BootpAllocated, BootpMax;

    ULONG InfoSize;
    PVOID Buf;
} DBCFG_ENTRY, *PDBCFG_ENTRY;

typedef struct _DBCFG_MAP {
    DWORD Offset, Size;
} DBCFG_MAP;

DBCFG_MAP EntryMap[] = {
    FIELD_OFFSET(DBCFG_ENTRY,Index), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,Type), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,SubType), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,Flags), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,Name), 0,
    FIELD_OFFSET(DBCFG_ENTRY,Comment), 0,
    FIELD_OFFSET(DBCFG_ENTRY,Info), 0,
    FIELD_OFFSET(DBCFG_ENTRY,OptionId), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,UserClass), 0,
    FIELD_OFFSET(DBCFG_ENTRY,VendorClass), 0,
    FIELD_OFFSET(DBCFG_ENTRY,IpAddress), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,Mask), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,SuperScope), 0,
    FIELD_OFFSET(DBCFG_ENTRY,MscopeId), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,MscopeLang), 0,
    FIELD_OFFSET(DBCFG_ENTRY,Ttl), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,ExpiryTime), sizeof(FILETIME),
    FIELD_OFFSET(DBCFG_ENTRY,RangeStart), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,RangeEnd), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,RangeMask), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,BootpAllocated), sizeof(DWORD),
    FIELD_OFFSET(DBCFG_ENTRY,BootpMax), sizeof(DWORD)
};

DWORD Bitmasks[] = {
    0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80,
    0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000,
    0x010000, 0x020000, 0x040000, 0x080000, 0x100000, 0x200000,
    0x400000, 0x80000,
};

DWORD
DhcpOpenConfigTable(
    IN JET_SESID SessId,
    IN JET_DBID DbId
    )
{

    JET_ERR JetError;
    DWORD Error = NO_ERROR;
    JET_COLUMNDEF   ColumnDef;
    CHAR *IndexKey;
    DWORD i;

    for( i = 0; i < DBCFG_LAST_COLUMN ; i ++ ) {
        DbcfgTable[i].ColHandle = 0;
    }

    DbcfgTbl = 0;
    
    //
    // Try to create Table.
    //

    JetError = JetOpenTable(
        SessId, DbId, DBCFG_TABLE_NAME, NULL, 0, 0, &DbcfgTbl );

    //
    // if table exist, read the table columns; else create it
    //
    
    if ( JET_errSuccess == JetError) {

        for ( i = 0; i < DBCFG_LAST_COLUMN; i++ ) {

            JetError = JetGetTableColumnInfo(
                SessId, DbcfgTbl, DbcfgTable[i].ColName, 
                &ColumnDef, sizeof(ColumnDef), 0 );

            Error = DhcpMapJetError( JetError, "C:GetTableColumnInfo" );
            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }

            DbcfgTable[i].ColHandle  = ColumnDef.columnid;
        }

    } else if ( JET_errObjectNotFound != JetError ) {
        
        Error = DhcpMapJetError( JetError, "C:OpenTable" );
        if( Error != ERROR_SUCCESS ) goto Cleanup;
        
    } else {

        JetError = JetCreateTable(
            SessId, DbId, DBCFG_TABLE_NAME, DB_TABLE_SIZE,
            DB_TABLE_DENSITY, &DbcfgTbl );

        Error = DhcpMapJetError( JetError, "C:CreateTAble" );
        if( Error != ERROR_SUCCESS ) goto Cleanup;

        //
        // Now create the columns as well
        //
                                     
        ColumnDef.cbStruct  = sizeof(ColumnDef);
        ColumnDef.columnid  = 0;
        ColumnDef.wCountry  = 1;
        ColumnDef.langid    = DB_LANGID;
        ColumnDef.cp        = DB_CP;
        ColumnDef.wCollate  = 0;
        ColumnDef.cbMax     = 0;
        ColumnDef.grbit     = 0;

        for ( i = 0; i < DBCFG_LAST_COLUMN; i++ ) {

            ColumnDef.coltyp   = DbcfgTable[i].ColType;

            JetError = JetAddColumn(
                SessId, DbcfgTbl, DbcfgTable[i].ColName, &ColumnDef,
                NULL, 0, &DbcfgTable[i].ColHandle );

            Error = DhcpMapJetError( JetError, "C:AddColumn" );
            if( Error != ERROR_SUCCESS ) goto Cleanup;
        }

        //
        // Now create the index
        //
        
        IndexKey =  "+" DBCFG_INDEX_STR "\0";

        JetError = JetCreateIndex(
            SessId, DbcfgTbl, DBCFG_INDEX_STR,
            JET_bitIndexPrimary, 
            // ?? JET_bitIndexClustered will degrade frequent
            // update response time.
            IndexKey, strlen(IndexKey) + 2, 50 );

        Error = DhcpMapJetError( JetError, "C:CreateIndex" );
        if( Error != ERROR_SUCCESS ) goto Cleanup;

    }

  Cleanup:

    if( Error != ERROR_SUCCESS ) {

        DhcpPrint(( DEBUG_JET, "Initializing config table: %ld.\n", Error ));

        for( i = 0; i < DBCFG_LAST_COLUMN ; i ++ ) {
            DbcfgTable[i].ColHandle = 0;
        }
        
        DbcfgTbl = 0;
        
    } else {

        DhcpPrint(( DEBUG_JET, "Initialized config table\n" ));
    }

    return Error;
}

BOOL
EntryCanBeIgnoredInternal(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PDBCFG_ENTRY Entry
    )
{

    //
    // If the entry specifies an IP address and the specified IP
    // address doesn't exist, then the entry can't be ignored..
    //

    if( Entry->Bitmasks & Bitmasks[DBCFG_IPADDRESS] && Entry->IpAddress ) {
        PM_SUBNET Subnet;
        PM_RESERVATION Res;
        DWORD Error;
        
        Error = MemServerGetAddressInfo(
            Ctxt->Server, Entry->IpAddress, &Subnet,
            NULL, NULL, &Res );
        if( ERROR_FILE_NOT_FOUND == Error ) return FALSE;
    }
    
    //
    // If class got changed, then this entry can be ignored if it
    // isn't a class def, or if it has no classes related.
    //
    
    if( Ctxt->fClassChanged ){
        return ( NULL == Entry->UserClass &&
                 NULL == Entry->VendorClass &&
                 Entry->Type != DBCFG_CLASS );
    }

    //
    // If options got changed and the current entry isnt an option
    // then it can be ignored
    //

    if( Ctxt->fOptionsChanged &&
        Entry->Type != DBCFG_OPTDEF && Entry->Type != DBCFG_OPT ) {
        return TRUE;
    }

    //
    // If subnet/mscope got changed, then the entry can be
    // ignored unless it is related
    //
    
    if( Ctxt->AffectedSubnet ) {
        return (Entry->IpAddress != Ctxt->AffectedSubnet );
    }

    if( Ctxt->AffectedMscope ) {
        //
        // Hack: AffectedMscope is set to INVALID_MSCOPE_ID if it
        // has a real value of 0 (as INVALID_MSCOPE_ID == -1)
        //
        
        if( Ctxt->AffectedMscope == INVALID_MSCOPE_ID ) {
            return (Entry->MscopeId != 0);
        }
        
        return (Entry->MscopeId != Ctxt->AffectedMscope );
    }
    
    if( Ctxt->AffectedReservation ) {
        return (Entry->IpAddress != Ctxt->AffectedReservation );
    }

    if( Ctxt->fOptionsChanged ) {
        //
        // If none of the above is specified, then it applies
        // only to global options. So, allow this only if neither
        // ip address nor mscope id is set.
        //

        if( (Entry->Bitmasks & Bitmasks[DBCFG_IPADDRESS]) ||
            (Entry->Bitmasks & Bitmasks[DBCFG_MSCOPEID]) ) {
            return TRUE;
        }

        return FALSE;
    }
        
    //
    // If none of the above are specified, then basically 
    // nothing can be ignored.
    //

    return FALSE;
}

BOOL
EntryCanBeIgnored(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PDBCFG_ENTRY Entry
    )
{
    LPSTR EntryTypes[] = {
        "Class", "Opt", "OptDef", "Scope", "Mscope", "Range",
        "Excl", "Reservation", "Unknown1", "Unknown2", "Unknown3"
    };

    if( FALSE == EntryCanBeIgnoredInternal( Ctxt, Entry ) ) {
        return FALSE;
    }

    if( Entry->Name ) {
        DhcpPrint((DEBUG_TRACE, "Ignoring: %ws\n", Entry->Name));
    } else {
        DhcpPrint((DEBUG_TRACE, "Ignoring %s [0x%lx, 0x%lx, 0x%lx]\n",
                   EntryTypes[Entry->Type], Entry->IpAddress,
                   Entry->MscopeId, Entry->SubType));
    }

    return TRUE;
}

DWORD
ReadDbEntryEx(
    IN JET_SESID SesId,
    IN PDBCFG_ENTRY Entry
    );

DWORD
DeleteConfigRecords(
    IN JET_SESID SesId,
    IN ULONG Index,
    IN BOOL fDeleteFromEnd,
    IN PDB_CREATE_CONTEXT Ctxt
    )
{
    DWORD Error, Move, CopiedSize;
    JET_ERR JetError;
    ULONG Index2;
    DBCFG_ENTRY Entry;
    BOOL fDelete;
    
    JetError = JetSetCurrentIndex(
        SesId, DbcfgTbl, NULL );

    Error = DhcpMapJetError( JetError, "C:SetIndex" );
    if( Error != NO_ERROR ) {
        
        DhcpPrint((DEBUG_JET, "JetSetCurrentIndex: %ld\n", Error));
        return Error;
    }

    Move = fDeleteFromEnd ? JET_MoveLast : JET_MoveFirst;
    
    JetError = JetMove( SesId, DbcfgTbl, Move, 0 );
    Error = DhcpMapJetError( JetError, "C:JetMoveFirstOrLast");

    Move = fDeleteFromEnd ? JET_MovePrevious : JET_MoveNext;
    
    while( Error == NO_ERROR ) {
        
        JetError = JetRetrieveColumn(
            SesId, DbcfgTbl, DbcfgTable[DBCFG_INDEX].ColHandle,
            &Index2, sizeof(Index2), &CopiedSize, 0, NULL );
        ASSERT( NO_ERROR == JetError &&
                CopiedSize == sizeof(Index2) );

        Error = DhcpMapJetError(JetError, "C:JetRetrieveIndex2");
        if( NO_ERROR != Error ) break;
        
        if( (fDeleteFromEnd && Index2 <= Index) ||
            (!fDeleteFromEnd && Index2 > Index ) ) {
            break;
        }

        fDelete = TRUE;
        
        Error = ReadDbEntryEx( SesId, &Entry );
        if( NO_ERROR != Error ) {
            DhcpPrint((DEBUG_ERRORS, "ReadDbEntryEx: 0x%lx\n", Error));
            DhcpAssert( FALSE );
        } else {
            if( EntryCanBeIgnored( Ctxt, &Entry ) ) {
                fDelete = FALSE;
            }
            if( NULL != Entry.Buf ) DhcpFreeMemory( Entry.Buf );
        }
        
        if( fDelete ) {
            JetError = JetDelete( SesId, DbcfgTbl );
            Error = DhcpMapJetError( JetError, "C:JetDelete" );
            if( NO_ERROR != Error ) {
                DhcpPrint((DEBUG_JET, "JetDelete: %ld\n", Error ));
                return Error;
            }
        }

        JetError = JetMove( SesId, DbcfgTbl, Move, 0 );
        Error = DhcpMapJetError( JetError, "C:JetMove" );
    }
    
    if( ERROR_NO_MORE_ITEMS == Error ) return NO_ERROR;
    
    if( NO_ERROR != Error ) {

        DhcpPrint((DEBUG_JET, "DeleteConfigRecords: %ld\n", Error ));
    }

    return Error;
}


DWORD
CreateDbEntry(
    IN JET_SESID SesId,
    IN PDBCFG_ENTRY Entry
    )
{
    DWORD Error, Size, i;
    JET_ERR JetError;
    LPVOID Data;

    //
    // First begin a transaction to keep the changes atomic.
    //

    JetError = JetBeginTransaction( SesId );
    Error = DhcpMapJetError( JetError, "C:JetBeginTransaction");
    if( NO_ERROR != Error ) return Error;
        
    JetError = JetPrepareUpdate(
        SesId, DbcfgTbl, JET_prepInsert );
    Error = DhcpMapJetError( JetError, "C:JetPrepareUpdate");
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS, "JetPrepareUpdate: %ld\n", Error ));
        goto Cleanup;
    }
    
    for( i = 0; i < DBCFG_LAST_COLUMN; i ++ ) {
        if( (Entry->Bitmasks & Bitmasks[i]) == 0 ) {
            continue;
        }

        Size = EntryMap[i].Size;
        Data = EntryMap[i].Offset + (LPBYTE)Entry;

        if( i == DBCFG_INFO ) {
            Data = *(PUCHAR *)Data;

            if( NULL != Data ) Size = Entry->InfoSize;

        } else if( 0 == Size ) {
            //
            // Calculate the size of the string
            //
            Data = *(LPWSTR *)Data;

            if( NULL != Data ) Size = sizeof(WCHAR)*(
                1 + wcslen(Data));
        }

        if( 0 == Size ) continue;
        
        JetError = JetSetColumn(
            SesId, DbcfgTbl, DbcfgTable[i].ColHandle, Data, Size,
            0, NULL );

        Error = DhcpMapJetError( JetError, "C:JetSetColumn");
        if( NO_ERROR != Error ) {
            DhcpPrint((
                DEBUG_ERRORS, "JetSetColumn(%s):%ld\n",
                DbcfgTable[i].ColName, Error ));
            goto Cleanup;
        }
    }

    JetError = JetUpdate(
        SesId, DbcfgTbl, NULL, 0, NULL );
    Error = DhcpMapJetError( JetError, "C:CommitUpdate" );

 Cleanup:
    
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS, "JetUpdate: %ld\n", Error ));
        JetError = JetRollback( SesId, 0 );
        ASSERT( 0 == JetError );        
    } else {
        JetError = JetCommitTransaction(
            SesId, JET_bitCommitLazyFlush );
        Error = DhcpMapJetError(
            JetError, "C:JetCommitTransaction" );
    }
    
    return Error;
}

DWORD
CreateClassEntry(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN JET_SESID SesId,
    IN ULONG Index,
    IN PM_CLASSDEF Class
    )
{
    DBCFG_ENTRY Entry;

    //
    // IsVendor, Type, Name, Comment, nBytes, ActualBytes
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_SUBTYPE] |
        Bitmasks[DBCFG_FLAGS] | Bitmasks[DBCFG_SUBTYPE] |
        Bitmasks[DBCFG_NAME] | Bitmasks[DBCFG_COMMENT] |
        Bitmasks[DBCFG_INFO] ); 

    Entry.Index = Index;
    Entry.Type = DBCFG_CLASS;

    Entry.Flags = Class->IsVendor;
    Entry.SubType = Class->Type;
    Entry.Name = Class->Name;
    Entry.Comment = Class->Comment;
    Entry.Info = Class->ActualBytes;
    Entry.InfoSize = Class->nBytes;

    if( EntryCanBeIgnored( Ctxt, &Entry ) ) return NO_ERROR;
    return CreateDbEntry( SesId, &Entry );
}

DWORD
CreateOptDefEntry(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN JET_SESID SesId,
    IN ULONG Index,
    IN PM_OPTDEF OptDef,
    IN PM_CLASSDEF UserClass,
    IN PM_CLASSDEF VendorClass
    )
{
    DBCFG_ENTRY Entry;

    //
    // OptId, Type, OptName, OptComment, OptVal, OptValLen,
    // User, Vendor
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_SUBTYPE] | Bitmasks[DBCFG_OPTION_ID] |
        Bitmasks[DBCFG_NAME] | Bitmasks[DBCFG_COMMENT] |
        Bitmasks[DBCFG_INFO] | Bitmasks[DBCFG_OPTION_USER] |
        Bitmasks[DBCFG_OPTION_VENDOR] );  

    Entry.Index = Index;
    Entry.Type = DBCFG_OPTDEF;

    Entry.OptionId = OptDef->OptId;
    Entry.SubType = OptDef->Type;
    Entry.Name = OptDef->OptName;
    Entry.Comment = OptDef->OptComment;
    Entry.Info = OptDef->OptVal;
    Entry.InfoSize = OptDef->OptValLen;
    if( UserClass) Entry.UserClass = UserClass->Name;
    if( VendorClass) Entry.VendorClass = VendorClass->Name;
    
    if( EntryCanBeIgnored( Ctxt, &Entry ) ) return NO_ERROR;
    return CreateDbEntry( SesId, &Entry );
}

DWORD
CreateOptionEntry(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN JET_SESID SesId,
    IN ULONG Index,
    IN PM_OPTION Option,
    IN PM_CLASSDEF UserClass,
    IN PM_CLASSDEF VendorClass,
    IN PM_SUBNET Subnet,
    IN PM_RESERVATION Reservation
    )
{
    DBCFG_ENTRY Entry;
    
    //
    // OptId, Len, Val, User, Vendor
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_OPTION_ID] | Bitmasks[DBCFG_INFO] |
        Bitmasks[DBCFG_OPTION_USER] |
        Bitmasks[DBCFG_OPTION_VENDOR] ); 

    if( Reservation ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_IPADDRESS];
        Entry.IpAddress = Reservation->Address;
    } else if( Subnet && Subnet->fSubnet ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_IPADDRESS];
        Entry.IpAddress = Subnet->Address;
    } else if( Subnet && !Subnet->fSubnet ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_MSCOPEID];
        Entry.MscopeId = Subnet->MScopeId;
    }
    
    Entry.Index = Index;
    Entry.Type = DBCFG_OPT;

    Entry.OptionId = Option->OptId;
    Entry.Info = Option->Val;
    Entry.InfoSize = Option->Len;
    if( UserClass) Entry.UserClass = UserClass->Name;
    if( VendorClass) Entry.VendorClass = VendorClass->Name;

    if( EntryCanBeIgnored( Ctxt, &Entry ) ) return NO_ERROR;
    return CreateDbEntry( SesId, &Entry );
}
    
DWORD
CreateScopeEntry(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN JET_SESID SesId,
    IN ULONG Index,
    IN PM_SUBNET Subnet,
    IN PM_SSCOPE SScope
    )
{
    DBCFG_ENTRY Entry;

    //
    // State, Policy, ExpiryTime, Name, Description
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_SUBTYPE] | Bitmasks[DBCFG_FLAGS] | 
        Bitmasks[DBCFG_NAME] | Bitmasks[DBCFG_COMMENT] );

    if( Subnet->fSubnet ) {
        Entry.Bitmasks |= (
            Bitmasks[DBCFG_IPADDRESS] | Bitmasks[DBCFG_MASK] |
            Bitmasks[DBCFG_SUPERSCOPE] );
        Entry.IpAddress = Subnet->Address;
        Entry.Mask = Subnet->Mask;
        if( SScope ) Entry.SuperScope = SScope->Name;
    } else {
        Entry.Bitmasks |= (
            Bitmasks[DBCFG_MSCOPEID] | Bitmasks[DBCFG_MSCOPETTL] |
            Bitmasks[DBCFG_MSCOPELANG] |
            Bitmasks[DBCFG_MSCOPE_EXPIRY] );

        Entry.MscopeId = Subnet->MScopeId;
        Entry.Ttl = Subnet->TTL;
        Entry.MscopeLang = Subnet->LangTag;
        Entry.ExpiryTime = *(FILETIME *)&Subnet->ExpiryTime;
    }
    
    Entry.Index = Index;
    Entry.Type = Subnet->fSubnet ? DBCFG_SCOPE : DBCFG_MSCOPE ;

    Entry.SubType = Subnet->State;
    Entry.Flags = Subnet->Policy;
    Entry.Name = Subnet->Name;
    Entry.Comment = Subnet->Description;
    
    if( EntryCanBeIgnored( Ctxt, &Entry ) ) return NO_ERROR;
    return CreateDbEntry( SesId, &Entry );    
}
    
DWORD
CreateRangeEntry(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN JET_SESID SesId,
    IN ULONG Index,
    IN PM_RANGE Range,
    IN PM_SUBNET Subnet
    )
{
    DBCFG_ENTRY Entry;

    //
    // Start, End, Mask, State, BootpAllocated, MaxBootpAllowed
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_RANGE_START] | Bitmasks[DBCFG_RANGE_END] |
        Bitmasks[DBCFG_RANGE_MASK] | Bitmasks[DBCFG_FLAGS] |
        Bitmasks[DBCFG_BOOTP_ALLOCATED] | Bitmasks[DBCFG_BOOTP_MAX] ); 

    if( Subnet->fSubnet ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_IPADDRESS];
        Entry.IpAddress = Subnet->Address;
    } else {
        Entry.Bitmasks |= Bitmasks[DBCFG_MSCOPEID];
        Entry.MscopeId = Subnet->MScopeId;
    }
    
    Entry.Index = Index;
    Entry.Type = DBCFG_RANGE;

    Entry.RangeStart = Range->Start;
    Entry.RangeEnd = Range->End;
    Entry.RangeMask = Range->Mask;
    Entry.Flags = Range->State;
    Entry.BootpAllocated = Range->BootpAllocated;
    Entry.BootpMax = Range->MaxBootpAllowed;
    
    if( EntryCanBeIgnored( Ctxt, &Entry ) ) return NO_ERROR;
    return CreateDbEntry( SesId, &Entry );
}

DWORD
CreateExclEntry(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN JET_SESID SesId,
    IN ULONG Index,
    IN PM_EXCL Excl,
    IN PM_SUBNET Subnet
    )
{
    DBCFG_ENTRY Entry;

    //
    // Start, End
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_RANGE_START] | Bitmasks[DBCFG_RANGE_END] );

    if( Subnet->fSubnet ) {
        Entry.Bitmasks |= Bitmasks[DBCFG_IPADDRESS];
        Entry.IpAddress = Subnet->Address;
    } else {
        Entry.Bitmasks |= Bitmasks[DBCFG_MSCOPEID];
        Entry.MscopeId = Subnet->MScopeId;
    }
    
    Entry.Index = Index;
    Entry.Type = DBCFG_EXCL;

    Entry.RangeStart = Excl->Start;
    Entry.RangeEnd = Excl->End;
    
    if( EntryCanBeIgnored( Ctxt, &Entry ) ) return NO_ERROR;
    return CreateDbEntry( SesId, &Entry );
}

DWORD
CreateReservationEntry(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN JET_SESID SesId,
    IN ULONG Index,
    IN PM_RESERVATION Reservation
    )
{
    DBCFG_ENTRY Entry;

    //
    // Address, Flags, nBytes, ClientUID
    //

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.Bitmasks = (
        Bitmasks[DBCFG_INDEX] | Bitmasks[DBCFG_TYPE] |
        Bitmasks[DBCFG_IPADDRESS] | Bitmasks[DBCFG_INFO] |
        Bitmasks[DBCFG_FLAGS] );

    Entry.Index = Index;
    Entry.Type = DBCFG_RESERVATION;

    Entry.IpAddress = Reservation->Address;
    Entry.Flags = Reservation->Flags;
    Entry.Info = Reservation->ClientUID;
    Entry.InfoSize = Reservation->nBytes;
    
    if( EntryCanBeIgnored( Ctxt, &Entry ) ) return NO_ERROR;
    return CreateDbEntry( SesId, &Entry );
}

DWORD
IterateArrayWithDbCreateRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PARRAY Array,
    IN DWORD (*Routine)(
        IN PDB_CREATE_CONTEXT Ctxt,
        IN PVOID ArrayElement
        )
    )
{
    ARRAY_LOCATION Loc;
    DWORD Error;
    PVOID Element;
    
    Error = MemArrayInitLoc( Array, &Loc );
    while( NO_ERROR == Error ) {

        Error = MemArrayGetElement(
            Array, &Loc, &Element );
        ASSERT( NO_ERROR == Error && NULL != Element );

        Ctxt->Index ++;

        Error = Routine( Ctxt, Element );
        if( NO_ERROR != Error ) return Error;

        Error = MemArrayNextLoc( Array, &Loc );
    }

    if( ERROR_FILE_NOT_FOUND == Error ) return NO_ERROR;
    return Error;
}
    
DWORD
DbCreateClassRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_CLASSDEF Class
    )
{
    return CreateClassEntry(
        Ctxt, Ctxt->SesId, Ctxt->Index, Class );
}

DWORD
DbCreateOptDefRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_OPTDEF OptDef
    )
{
    return CreateOptDefEntry(
        Ctxt, Ctxt->SesId, Ctxt->Index, OptDef, Ctxt->UserClass,
        Ctxt->VendorClass );
}

DWORD
DbCreateOptClassDefRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_OPTCLASSDEFL_ONE OptClassDef
    )
{
    DWORD Error;
    
    if( 0 == OptClassDef->ClassId ) {
        Ctxt->UserClass = NULL;
    } else {
        Error = MemServerGetClassDef(
            Ctxt->Server, OptClassDef->ClassId, NULL, 0, NULL,
            &Ctxt->UserClass );
        if( NO_ERROR != Error ) return Error;
    }

    if( 0 == OptClassDef->VendorId ) {
        Ctxt->VendorClass = NULL;
    } else {
        Error = MemServerGetClassDef(
            Ctxt->Server, OptClassDef->VendorId, NULL, 0, NULL,
            &Ctxt->VendorClass );
        if( NO_ERROR != Error ) return Error;
    }

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &OptClassDef->OptDefList.OptDefArray,
        DbCreateOptDefRoutine );

    return Error;
}

DWORD
DbCreateOptionRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_OPTION Option
    )
{
    return CreateOptionEntry(
        Ctxt, Ctxt->SesId, Ctxt->Index, Option, Ctxt->UserClass,
        Ctxt->VendorClass, Ctxt->Subnet, Ctxt->Reservation );
}

DWORD
DbCreateOptListRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_ONECLASS_OPTLIST OptList
    )
{
    DWORD Error;
    
    if( 0 == OptList->ClassId ) {
        Ctxt->UserClass = NULL;
    } else {
        Error = MemServerGetClassDef(
            Ctxt->Server, OptList->ClassId, NULL, 0, NULL,
            &Ctxt->UserClass );
        if( NO_ERROR != Error ) return Error;
    }

    if( 0 == OptList->VendorId ) {
        Ctxt->VendorClass = NULL;
    } else {
        Error = MemServerGetClassDef(
            Ctxt->Server, OptList->VendorId, NULL, 0, NULL,
            &Ctxt->VendorClass );
        if( NO_ERROR != Error ) return Error;
    }

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &OptList->OptList, DbCreateOptionRoutine );

    return Error;
}

DWORD
DbCreateRangeRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_RANGE Range
    )
{
    return CreateRangeEntry(
        Ctxt, Ctxt->SesId, Ctxt->Index, Range, Ctxt->Subnet );
}

DWORD
DbCreateExclRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_EXCL Excl
    )
{
    return CreateExclEntry(
        Ctxt, Ctxt->SesId, Ctxt->Index, Excl, Ctxt->Subnet );
}

DWORD
DbCreateReservationRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_RESERVATION Reservation
    )
{
    DWORD Error;
    
    Error = CreateReservationEntry(
        Ctxt, Ctxt->SesId, Ctxt->Index, Reservation );
    if( NO_ERROR != Error ) return Error;

    Ctxt->Reservation = Reservation;
    
    //
    // Now add the options for this reservation
    //
    
    return IterateArrayWithDbCreateRoutine(
        Ctxt, &Reservation->Options.Array,
        DbCreateOptListRoutine );
}

DWORD
DbCreateScopeRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_SUBNET Subnet
    )
{
    PM_SSCOPE SScope = NULL;
    DWORD Error;
    
    if( Subnet->fSubnet && Subnet->SuperScopeId ) {
        DWORD Error;

        Error = MemServerFindSScope(
            Ctxt->Server, Subnet->SuperScopeId, NULL, &SScope );
        if( NO_ERROR != Error ) {
            SScope = NULL;
        }
    }

    Error = CreateScopeEntry(
        Ctxt, Ctxt->SesId, Ctxt->Index, Subnet, SScope );
    if( NO_ERROR != Error ) return Error;

    //
    // Initialize the two fields that will get used later 
    //
    
    Ctxt->Subnet = Subnet;
    Ctxt->Reservation = NULL;

    //
    // Now add the options for this scope
    //

    
    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Subnet->Options.Array,
        DbCreateOptListRoutine );
    if( NO_ERROR != Error ) return Error;

    //
    // Now add the ranges and exclusions
    //

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Subnet->Ranges, DbCreateRangeRoutine );
    if( NO_ERROR != Error ) return Error;

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Subnet->Exclusions, DbCreateExclRoutine );
    if( NO_ERROR != Error ) return Error;

    //
    // Finally, add the reservations
    //

    return IterateArrayWithDbCreateRoutine(
        Ctxt, &Subnet->Reservations,
        DbCreateReservationRoutine );
}


DWORD
DbCreateServerRoutine(
    IN PDB_CREATE_CONTEXT Ctxt,
    IN PM_SERVER Server
    )
{
    DWORD Error;
    
    Ctxt->Server = Server;

    //
    // First look through the classes
    //

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Server->ClassDefs.ClassDefArray,
        DbCreateClassRoutine );
    if( NO_ERROR != Error ) return Error;

    //
    // Next save the option defs
    //
    
    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Server->OptDefs.Array,
        DbCreateOptClassDefRoutine );
    if( NO_ERROR != Error ) return Error;

    // 
    // Next save the options
    //

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Server->Options.Array,
        DbCreateOptListRoutine );
    if( NO_ERROR != Error ) return Error;

    //
    // Next save the scopes and mcast scopes
    //

    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Server->Subnets, DbCreateScopeRoutine );
    if( NO_ERROR != Error ) return Error;
    
    Error = IterateArrayWithDbCreateRoutine(
        Ctxt, &Server->MScopes, DbCreateScopeRoutine );
    if( NO_ERROR != Error ) return Error;

    return NO_ERROR;
}

DWORD
GetNextIndexValue(
    IN OUT PULONG Index,
    IN JET_SESID SesId
    )
{
    DWORD Error, CopiedSize;
    JET_ERR JetError;

    (*Index) = 0;
    
    JetError = JetSetCurrentIndex(
        SesId, DbcfgTbl, NULL );

    Error = DhcpMapJetError( JetError, "C:GetIndex" );
    if( Error != NO_ERROR ) {
        
        DhcpPrint((DEBUG_JET, "JetSetCurrentIndex: %ld\n", Error));
        return Error;
    }

    JetError = JetMove( SesId, DbcfgTbl, JET_MoveLast, 0 );
    Error = DhcpMapJetError( JetError, "C:JetMoveLast");

    if( ERROR_NO_MORE_ITEMS == Error ) return NO_ERROR;
    if( NO_ERROR != Error ) return Error;

    //
    // Read the db entry
    //

    JetError = JetRetrieveColumn(
        SesId, DbcfgTbl, DbcfgTable[DBCFG_INDEX].ColHandle, Index,
        sizeof(*Index), &CopiedSize, 0, NULL );

    ASSERT( NO_ERROR == JetError && CopiedSize == sizeof(*Index));
    Error = DhcpMapJetError( JetError, "C:JetRetrieveIndex");

    return Error;
}

DWORD
DhcpSaveConfigTableEx(
    IN JET_SESID SesId,
    IN JET_DBID DbId,
    IN PM_SERVER Server,
    IN BOOL fClassChanged,
    IN BOOL fOptionsChanged,
    IN DWORD AffectedSubnet OPTIONAL,
    IN DWORD AffectedMscope OPTIONAL,
    IN DWORD AffectedReservation OPTIONAL
    )
{
    DB_CREATE_CONTEXT Ctxt;
    DWORD Error, Index;
    JET_ERR JetError;
    
    ZeroMemory( &Ctxt, sizeof(Ctxt) );
    Ctxt.SesId = SesId;
    Ctxt.fClassChanged = fClassChanged;
    Ctxt.fOptionsChanged = fOptionsChanged;
    Ctxt.AffectedSubnet = AffectedSubnet;
    Ctxt.AffectedMscope = AffectedMscope;
    Ctxt.AffectedReservation = AffectedReservation;
    
    //
    // No transactions are used in here because the number of
    // updates to be done is so high that using transactions
    // usually ends up bursting Jet's version store limits.
    //
    // Instead, the new records are all added at the end and if
    // everything goes fine, the old records are all deleted.
    //

    Error = GetNextIndexValue( &Index, SesId );
    if( NO_ERROR != Error ) return Error;
    
    Ctxt.Index = Index+1;
    
    //
    // Now create all the new records.  If this fails, delete
    // only the new records.  If this works fine, delete all
    // the old records only.
    //
    
    Error = DbCreateServerRoutine(
        &Ctxt, Server );
    
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS, "DbCreateServerRoutine: 0x%lx\n", Error ));
        
        DeleteConfigRecords( SesId, Index, TRUE, &Ctxt );
    } else {
        Error = DeleteConfigRecords( SesId, Index, FALSE, &Ctxt );
    }
        

    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS, "DhcpSaveConfigTable: %ld\n",
                   Error ));
    }

    return Error;
}

    
DWORD
DhcpSaveConfigTable(
    IN JET_SESID SesId,
    IN JET_DBID DbId,
    IN PM_SERVER Server
    )
{
    return DhcpSaveConfigTableEx(
        SesId, DbId, Server, FALSE, FALSE, 0, 0, 0 );
}
        
DWORD
ReadDbEntry(
    IN JET_SESID SesId,
    IN PDBCFG_ENTRY Entry,
    IN PVOID Buffer,
    IN ULONG BufSize
    )
{
    DWORD Error, Size, CopiedSize, i;
    JET_ERR JetError;
    LPVOID Data, Ptr;

    ZeroMemory( Entry, sizeof(*Entry) );
    ZeroMemory( Buffer, BufSize );
    
    for( i = 0; i < DBCFG_LAST_COLUMN; i ++ ) {

        //
        // Info should be read at the very end to avoid screwing
        // up alignment as info is binary while the rest of the
        // variable size columns are all WCHAR strings
        //
        
        if( i == DBCFG_INFO ) continue;
        
        Size = EntryMap[i].Size;
        Data = EntryMap[i].Offset + (LPBYTE)Entry;
        Ptr = Data;
        
        if( 0 == Size ) {
            //
            // Calculate the size of the string
            //
            Data = Buffer;
            Size = BufSize;
        }

        JetError = JetRetrieveColumn(
            SesId, DbcfgTbl, DbcfgTable[i].ColHandle, Data, Size,
            &CopiedSize, 0 , NULL );

        //
        // If the column doesn't exist, continue
        //
       
        if( JET_wrnColumnNull == JetError ) continue;
            
        if( JET_wrnBufferTruncated == JetError &&
            Data == Buffer ) {
            
            return ERROR_INSUFFICIENT_BUFFER;
        }
        
        Error = DhcpMapJetError( JetError, "C:JetRetrieveColumn");
        if( NO_ERROR != Error ) {
            DhcpPrint((
                DEBUG_ERRORS, "JetRetrieveColumn(%s):%ld\n",
                DbcfgTable[i].ColName, Error ));
            return Error;
        }

        //
        // If it is any of the variable sized params, then
        // set the ptr to point to the buffer where the data is
        // copied, and also update the buffer.
        //
        
        if( Data == Buffer ) {
            (*(LPVOID *)Ptr) = Buffer;
            BufSize -= CopiedSize;
            Buffer = (PVOID)(((PUCHAR)Buffer) + CopiedSize);
        } else {
            ASSERT( CopiedSize == Size );
        }

        //
        // Indicate that the column was retrieved successfully
        //

        Entry->Bitmasks |= Bitmasks[i];
    }

    //
    // Read the info field
    //

    Size = BufSize;
    JetError = JetRetrieveColumn(
        SesId, DbcfgTbl, DbcfgTable[DBCFG_INFO].ColHandle, Buffer, Size,
        &CopiedSize, 0 , NULL );

    if( JET_wrnColumnNull == JetError ) return NO_ERROR;
    if( JET_wrnBufferTruncated == JetError ) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    Error = DhcpMapJetError(JetError, "C:JetRetrieveColumn1");
    if( NO_ERROR != Error ) {
        DhcpPrint((
            DEBUG_ERRORS, "JetRetrieveColumn1(%s):%ld\n",
            DbcfgTable[DBCFG_INFO].ColName, Error ));
        return Error;
    }

    Entry->Info = Buffer;
    Entry->InfoSize = CopiedSize;
    Entry->Bitmasks  |= Bitmasks[DBCFG_INFO];
    
    return NO_ERROR;
}

DWORD
ReadDbEntryEx(
    IN JET_SESID SesId,
    IN PDBCFG_ENTRY Entry
    )
{
    PVOID Buffer;
    ULONG BufSize;
    DWORD Error;

    Buffer = NULL;
    BufSize = 512;
    
    do {
        if( NULL != Buffer ) DhcpFreeMemory(Buffer);

        BufSize *= 2;
        Buffer = DhcpAllocateMemory( BufSize );
        if( NULL == Buffer ) return ERROR_NOT_ENOUGH_MEMORY;
        
        Error = ReadDbEntry(SesId, Entry, Buffer, BufSize);

    } while( ERROR_INSUFFICIENT_BUFFER == Error );

    if( !(Entry->Bitmasks & Bitmasks[DBCFG_INDEX]) ||
        !(Entry->Bitmasks & Bitmasks[DBCFG_TYPE]) ) {
        if( NO_ERROR == Error ) {
            ASSERT( FALSE );
            Error = ERROR_INTERNAL_ERROR;
        }
    }
    
    if( NO_ERROR != Error ) {
        DhcpFreeMemory( Buffer );
        return Error;
    }

    Entry->Buf = Buffer;
    return NO_ERROR;
}

DWORD
AddDbEntry(
    IN PM_SERVER Server,
    IN PDBCFG_ENTRY Entry
    )
{
    DWORD UserId, VendorId, SScopeId, Error;
    PM_SUBNET Subnet;
    PM_OPTCLASS OptClass;
    PM_OPTION Option, DelOpt;
    PM_RANGE DelRange;
    PM_EXCL DelExcl;
    PM_RESERVATION Reservation;
    PM_CLASSDEF ClassDef;
    PM_SSCOPE SScope;
    
    Subnet = NULL;
    OptClass = NULL;
    Option = DelOpt = NULL;
    Reservation = NULL;
    DelRange = NULL;
    DelExcl = NULL;
    UserId = 0;
    VendorId = 0;
    SScopeId = 0;
    
    if( Entry->UserClass ) {
        Error = MemServerGetClassDef(
            Server, 0, Entry->UserClass, 0, NULL, &ClassDef );
        if( NO_ERROR != Error ) return Error;

        ASSERT( ClassDef->IsVendor == FALSE );
        UserId = ClassDef->ClassId;
    }

    if( Entry->VendorClass ) {
        Error = MemServerGetClassDef(
            Server, 0, Entry->VendorClass, 0, NULL, &ClassDef );
        if( NO_ERROR != Error ) return Error;

        ASSERT( ClassDef->IsVendor == TRUE);
        VendorId = ClassDef->ClassId;
    }

    if( Entry->SuperScope ) {
        Error = MemServerFindSScope(
            Server, INVALID_SSCOPE_ID, Entry->SuperScope, &SScope );
        if( NO_ERROR == Error ) {
            SScopeId = SScope->SScopeId;
        } else if( ERROR_FILE_NOT_FOUND != Error ) {
            return Error;
        } else {
            Error = MemSScopeInit( &SScope, 0, Entry->SuperScope );
            if( NO_ERROR != Error ) return Error;

            Error = MemServerAddSScope( Server, SScope );
            if( NO_ERROR != Error ) {
                MemSScopeCleanup( SScope );
                return Error;
            }
            SScopeId = SScope->SScopeId;
        }
    }
    
    switch( Entry->Type ) {
    case DBCFG_CLASS :
        //
        // Flags = IsVendor, SubType =Type, Info = ActualBytes
        //
        
        return MemServerAddClassDef(
            Server, MemNewClassId(), Entry->Flags, Entry->Name,
            Entry->Comment, Entry->InfoSize, Entry->Info );

    case DBCFG_OPTDEF :
        //
        // OptionId = OptId, SubType = Type, Info = OptVal
        //
        
        return MemServerAddOptDef(
            Server, UserId, VendorId, Entry->OptionId,
            Entry->Name, Entry->Comment, Entry->SubType,
            Entry->Info, Entry->InfoSize );

    case DBCFG_OPT:
        //
        // OptionId = OptId, Info = Val
        // If this is a reservation option, address is set to
        // reserved client address. If this is a subnet option,
        // address is set to subnet address. If this is a mscope
        // option, scopeid is set to mscope scopeid.  If it is a
        // global option, neither address not scopeid is set.
        //

        if( Entry->Bitmasks & Bitmasks[DBCFG_MSCOPEID] ) {
            Error = MemServerFindMScope(
                Server, Entry->MscopeId, NULL, &Subnet );
            if( NO_ERROR != Error ) return Error;

            OptClass = &Subnet->Options;
        } else if( 0 == (Entry->Bitmasks & Bitmasks[DBCFG_IPADDRESS] )) {
            OptClass = &Server->Options;
        } else {
            Error = MemServerGetUAddressInfo(
                Server, Entry->IpAddress, &Subnet, NULL, NULL,
                &Reservation );
            if( NO_ERROR != Error ) return Error;

            if( NULL != Reservation ) {
                OptClass = &Reservation->Options;
            } else OptClass = &Subnet->Options;
        }
        
        Error = MemOptInit(
            &Option, Entry->OptionId, Entry->InfoSize,
            Entry->Info );
        if( NO_ERROR != Error ) return Error;
            
        Error = MemOptClassAddOption(
            OptClass,  Option, UserId, VendorId, &DelOpt );

        ASSERT( NULL == DelOpt );
        if( NO_ERROR != Error ) MemFree( Option );

        return Error;

    case DBCFG_SCOPE:
        //
        // IpAddress = Address, Mask = Mask, SubType = State,
        // Flags = Policy
        //

        Error = MemSubnetInit(
            &Subnet, Entry->IpAddress, Entry->Mask,
            Entry->SubType, SScopeId, Entry->Name, Entry->Comment );
        if( NO_ERROR != Error ) return Error;

        Error = MemServerAddSubnet( Server, Subnet );
        if( NO_ERROR != Error ) MemSubnetCleanup( Subnet );

        return Error;
            
    case DBCFG_MSCOPE :
        //
        // MscopeId = MScopeId, Ttl = TTL, MscopeLang = LangTag,
        // ExpiryTime = ExpiryTime, SubType = State, Flags =
        // Policy..
        //

        Error = MemMScopeInit(
            &Subnet, Entry->MscopeId, Entry->SubType,
            Entry->Flags, (BYTE)Entry->Ttl, Entry->Name,
            Entry->Comment, Entry->MscopeLang,
            *(DATE_TIME *)&Entry->ExpiryTime );
        if( NO_ERROR != Error ) return Error;

        Error = MemServerAddMScope( Server, Subnet );
        if( NO_ERROR != Error ) MemSubnetCleanup( Subnet );

        return Error;

    case DBCFG_RANGE :

        //
        // RangeStart = Start, RangeEnd = End, RangeMask = Mask,
        // Flags = State, BootpAllocated, BootpMax =
        // MaxBootpAllowed... Also, IpAddress or MscopeId
        //

        if( Entry->Bitmasks & Bitmasks[DBCFG_IPADDRESS] ) {
            Error = MemServerGetUAddressInfo(
                Server, Entry->IpAddress, &Subnet, NULL, NULL,
                NULL );
        } else {
            Error = MemServerFindMScope(
                Server, Entry->MscopeId, NULL, &Subnet );
        }
        if( NO_ERROR != Error ) return Error;

        return MemSubnetAddRange(
            Subnet, Entry->RangeStart, Entry->RangeEnd,
            Entry->Flags, Entry->BootpAllocated, Entry->BootpMax,
            &DelRange );
        
    case DBCFG_EXCL:
        //
        // RangeStart = Start, RangeEnd = End
        //

        if( Entry->Bitmasks & Bitmasks[DBCFG_IPADDRESS] ) {
            Error = MemServerGetUAddressInfo(
                Server, Entry->IpAddress, &Subnet, NULL, NULL,
                NULL );
        } else {
            Error = MemServerFindMScope(
                Server, Entry->MscopeId, NULL, &Subnet );
        }
        if( NO_ERROR != Error ) return Error;

        return MemSubnetAddExcl(
            Subnet, Entry->RangeStart, Entry->RangeEnd, &DelExcl
            );

    case DBCFG_RESERVATION :
        //
        // IpAddress = Address, Flags = Flags, Info = ClientUID
        //

        Error = MemServerGetAddressInfo(
            Server, Entry->IpAddress, &Subnet, NULL, NULL, NULL );
        if( NO_ERROR != Error ) return Error;

        Error = MemReserveAdd(
            &Subnet->Reservations, Entry->IpAddress,
            Entry->Flags, Entry->Info, Entry->InfoSize );

        if ( NO_ERROR != Error ) return Error;

        Error = MemSubnetRequestAddress( Subnet,
                                         Entry -> IpAddress,
                                         TRUE,
                                         FALSE,
                                         NULL,
                                         NULL );

        //
        // if the reservation cant be marked in the mem bitmask
        // correctly, return NO_ERROR. This happens when a reservation
        // is defined outside the defined IP ranges.
        // eg: ip range 10.0.0.1 - 10.0.0.100 with mask 255.255.255.0
        // a resv can be added for ip address 10.0.0.101
        // this is particularly a problem with upgrades.
        //

	Error = NO_ERROR;

        return Error;

    default:

        return ERROR_INTERNAL_ERROR;
    }        
}

DWORD
AddDbEntryEx(
    IN PM_SERVER Server,
    IN PDBCFG_ENTRY Entry
    )
{
    DWORD Error;
    LPSTR EntryTypes[] = {
        "Class", "Opt", "OptDef", "Scope", "Mscope", "Range",
        "Excl", "Reservation", "Unknown1", "Unknown2", "Unknown3"
    };
    
    Error = AddDbEntry( Server, Entry );
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS,
                   "Error adding entry[%ld] %s: 0x%lx\n",
                   Entry->Index, EntryTypes[Entry->Type], Error ));
    }

    if( SERVICE_RUNNING != DhcpGlobalServiceStatus.dwCurrentState ) {
        DhcpGlobalServiceStatus.dwCheckPoint ++;
        SetServiceStatus(
            DhcpGlobalServiceStatusHandle,
            &DhcpGlobalServiceStatus );
    }
    
    return Error;
}

DWORD
ReadDbEntriesInternal(
    IN JET_SESID SesId,
    IN JET_DBID DbId,
    IN OUT PM_SERVER Server,
    IN DWORD CurrentDbType
    )
{
    DBCFG_ENTRY Entry;
    DWORD Error;
    JET_ERR JetError;

    JetError = JetSetCurrentIndex(
        SesId, DbcfgTbl, NULL );

    Error = DhcpMapJetError( JetError, "C:SetIndex2" );
    if( Error != NO_ERROR ) {
        
        DhcpPrint((DEBUG_JET, "JetSetCurrentIndex2: %ld\n", Error));
        return Error;
    }

    JetError = JetMove( SesId, DbcfgTbl, JET_MoveFirst, 0 );
    Error = DhcpMapJetError( JetError, "C:JetMoveFirst2");

    while( Error == NO_ERROR ) {

        Error = ReadDbEntryEx( SesId, &Entry );
        if( NO_ERROR != Error ) {
            DhcpPrint((DEBUG_JET, "ReadDbEntryEx: %ld\n", Error ));
            return Error;
        }

        if( CurrentDbType == Entry.Type ) {
            Error = AddDbEntryEx( Server, &Entry );
        }

        if( NULL != Entry.Buf ) DhcpFreeMemory( Entry.Buf );
        if( NO_ERROR != Error ) return Error;
        
        JetError = JetMove( SesId, DbcfgTbl, JET_MoveNext, 0 );
        Error = DhcpMapJetError( JetError, "C:JetMove2" );
    }
    
    if( ERROR_NO_MORE_ITEMS == Error ) return NO_ERROR;
    
    if( NO_ERROR != Error ) {

        DhcpPrint((DEBUG_JET, "JetMove2: %ld\n", Error ));
    }

    return Error;
}


DWORD
ReadDbEntries(
    IN JET_SESID SesId,
    IN JET_DBID DbId,
    IN OUT PM_SERVER Server
    )
{
    DWORD Error;

    Error = ReadDbEntriesInternal(
        SesId, DbId, Server, DBCFG_CLASS );
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_JET, "ReadDbEntriesInternal:Class: 0x%lx\n", Error));
        return Error;
    }


    Error = ReadDbEntriesInternal(
        SesId, DbId, Server, DBCFG_OPTDEF );
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_JET, "ReadDbEntriesInternal:OptDef: 0x%lx\n", Error));
        return Error;
    }


    Error = ReadDbEntriesInternal(
        SesId, DbId, Server, DBCFG_SCOPE );
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_JET, "ReadDbEntriesInternal:Scope: 0x%lx\n", Error));
        return Error;
    }


    Error = ReadDbEntriesInternal(
        SesId, DbId, Server, DBCFG_MSCOPE );
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_JET, "ReadDbEntriesInternal:Mscope: 0x%lx\n", Error));
        return Error;
    }


    Error = ReadDbEntriesInternal(
        SesId, DbId, Server, DBCFG_RANGE);
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_JET, "ReadDbEntriesInternal:Range: 0x%lx\n", Error));
        return Error;
    }


    Error = ReadDbEntriesInternal(
        SesId, DbId, Server, DBCFG_EXCL );
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_JET, "ReadDbEntriesInternal:Excl: 0x%lx\n", Error));
        return Error;
    }


    Error = ReadDbEntriesInternal(
        SesId, DbId, Server, DBCFG_RESERVATION );
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_JET, "ReadDbEntriesInternal:Resv: 0x%lx\n", Error));
        return Error;
    }


    Error = ReadDbEntriesInternal(
        SesId, DbId, Server, DBCFG_OPT );
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_JET, "ReadDbEntriesInternal:Opt: 0x%lx\n", Error));
        return Error;
    }

    return NO_ERROR;
}

DWORD
DhcpReadConfigTable(
    IN JET_SESID SesId,
    IN JET_DBID DbId,
    IN OUT PM_SERVER *Server
    )
{
    DWORD Error;
    PM_SERVER ThisServer;
    
    (*Server) = NULL;
    
    Error = DhcpOpenConfigTable( SesId, DbId );
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS, "DhcpOpenConfigTable: 0x%lx\n", Error));
        return Error;
    }

    //
    // Check the registry to see if the config is stored in db or
    // not.  If it is stored in registry, this needs to be
    // migrated to the database 
    //

    if( DhcpCheckIfDatabaseUpgraded(TRUE) ) {
        //
        // Registry has not been converted to database format
        //
        Error = DhcpRegistryInitOld();

        if( NO_ERROR != Error ) {
            DhcpPrint((DEBUG_ERRORS, "DhcpRegistryInitOld: 0x%lx\n", Error));
            return Error;
        }

        do { 
            Error = DhcpSaveConfigTable(SesId, DbId, DhcpGlobalThisServer);
            
            if( NO_ERROR != Error ) {
                DhcpPrint((DEBUG_ERRORS, "DhcpSaveConfigTable: 0x%lx\n", Error));
                break;
            }

            //
            // Attempt to record the fact that the registry has been
            // copied over before.
            //
            
            Error = DhcpSetRegistryUpgradedToDatabaseStatus();
            if( NO_ERROR != Error ) {
                DhcpPrint((DEBUG_ERRORS,
                           "DhcpSetRegistryUpgradedToDatabaseStatus: 0x%lx",
                           Error));
                break;
            }
            
            //
            // If we successfully converted the registry, we can
            // safely delete the registry configuration key.
            //
            
            Error = DeleteSoftwareRootKey();
            if( NO_ERROR != Error ) {
                DhcpPrint((DEBUG_ERRORS,
                           "DeleteSoftwareRootKey: %ld\n", Error ));
                break;
            }

            DhcpRegFlushServer(FLUSH_ANYWAY);

        } while( 0 );

        MemServerFree( DhcpGlobalThisServer );
        DhcpGlobalThisServer = NULL;

        if( NO_ERROR != Error ) return Error;
    }
    
    //
    // If the table already existed, need to read the entries.
    //

    Error = MemServerInit( &ThisServer, -1, 0, 0, NULL, NULL );
    if( NO_ERROR != Error ) return Error;

    Error = ReadDbEntries(SesId, DbId, ThisServer );
    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS, "ReadDbEntries: 0x%lx\n", Error ));
        MemServerCleanup( ThisServer );
        return Error;
    }

    (*Server) = ThisServer;
    return NO_ERROR;
}


DWORD
DhcpReadConfigInfo(
    IN OUT PM_SERVER *Server
    )
{
    return DhcpReadConfigTable(
        DhcpGlobalJetServerSession, DhcpGlobalDatabaseHandle,
        Server );
}

DWORD
DhcpSaveConfigInfo(
    IN OUT PM_SERVER Server,
    IN BOOL fClassChanged,
    IN BOOL fOptionsChanged,
    IN DWORD AffectedSubnet, OPTIONAL
    IN DWORD AffectedMscope, OPTIONAL
    IN DWORD AffectedReservation OPTIONAL
    )
{
    return DhcpSaveConfigTableEx(
        DhcpGlobalJetServerSession, DhcpGlobalDatabaseHandle,
        Server, fClassChanged, fOptionsChanged, AffectedSubnet,
        AffectedMscope, AffectedReservation );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\debug.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This file contains debugging macros for the DHCP server.

Author:

    Madan Appiah  (madana)  10-Sep-1993

Environment:

    User Mode - Win32

Revision History:


--*/

#include "dhcppch.h"

#if DBG
VOID
DhcpOpenDebugFile(
    IN BOOL ReopenFlag
    )
/*++

Routine Description:

    Opens or re-opens the debug file

Arguments:

    ReopenFlag - TRUE to indicate the debug file is to be closed, renamed,
        and recreated.

Return Value:

    None

--*/

{
    WCHAR LogFileName[500];
    WCHAR BakFileName[500];
    DWORD FileAttributes;
    DWORD PathLength;
    DWORD WinError;

    //
    // Close the handle to the debug file, if it is currently open
    //

    EnterCriticalSection( &DhcpGlobalDebugFileCritSect );
    if ( DhcpGlobalDebugFileHandle != NULL ) {
        CloseHandle( DhcpGlobalDebugFileHandle );
        DhcpGlobalDebugFileHandle = NULL;
    }
    LeaveCriticalSection( &DhcpGlobalDebugFileCritSect );

    //
    // make debug directory path first, if it is not made before.
    //
    if( DhcpGlobalDebugSharePath == NULL ) {

        if ( !GetWindowsDirectoryW(
                LogFileName,
                sizeof(LogFileName)/sizeof(WCHAR) ) ) {
            DhcpPrint((DEBUG_ERRORS, "Window Directory Path can't be "
                        "retrieved, %lu.\n", GetLastError() ));
            return;
        }

        //
        // check debug path length.
        //

        PathLength = wcslen(LogFileName) * sizeof(WCHAR) +
                        sizeof(DEBUG_DIR) + sizeof(WCHAR);

        if( (PathLength + sizeof(DEBUG_FILE) > sizeof(LogFileName) )  ||
            (PathLength + sizeof(DEBUG_BAK_FILE) > sizeof(BakFileName) ) ) {

            DhcpPrint((DEBUG_ERRORS, "Debug directory path (%ws) length is too long.\n",
                        LogFileName));
            goto ErrorReturn;
        }

        wcscat(LogFileName, DEBUG_DIR);

        //
        // copy debug directory name to global var.
        //

        DhcpGlobalDebugSharePath =
            DhcpAllocateMemory( (wcslen(LogFileName) + 1) * sizeof(WCHAR) );

        if( DhcpGlobalDebugSharePath == NULL ) {
            DhcpPrint((DEBUG_ERRORS, "Can't allocated memory for debug share "
                                    "(%ws).\n", LogFileName));
            goto ErrorReturn;
        }

        wcscpy(DhcpGlobalDebugSharePath, LogFileName);
    }
    else {
        wcscpy(LogFileName, DhcpGlobalDebugSharePath);
    }

    //
    // Check this path exists.
    //

    FileAttributes = GetFileAttributesW( LogFileName );

    if( FileAttributes == 0xFFFFFFFF ) {

        WinError = GetLastError();
        if( WinError == ERROR_FILE_NOT_FOUND ) {

            //
            // Create debug directory.
            //

            if( !CreateDirectoryW( LogFileName, NULL) ) {
                DhcpPrint((DEBUG_ERRORS, "Can't create Debug directory (%ws), "
                            "%lu.\n", LogFileName, GetLastError() ));
                goto ErrorReturn;
            }

        }
        else {
            DhcpPrint((DEBUG_ERRORS, "Can't Get File attributes(%ws), "
                        "%lu.\n", LogFileName, WinError ));
            goto ErrorReturn;
        }
    }
    else {

        //
        // if this is not a directory.
        //

        if(!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

            DhcpPrint((DEBUG_ERRORS, "Debug directory path (%ws) exists "
                         "as file.\n", LogFileName));
            goto ErrorReturn;
        }
    }

    //
    // Create the name of the old and new log file names
    //

    (VOID) wcscpy( BakFileName, LogFileName );
    (VOID) wcscat( LogFileName, DEBUG_FILE );
    (VOID) wcscat( BakFileName, DEBUG_BAK_FILE );


    //
    // If this is a re-open,
    //  delete the backup file,
    //  rename the current file to the backup file.
    //

    if ( ReopenFlag ) {

        if ( !DeleteFile( BakFileName ) ) {
            WinError = GetLastError();
            if ( WinError != ERROR_FILE_NOT_FOUND ) {
                DhcpPrint((DEBUG_ERRORS,
                    "Cannot delete %ws (%ld)\n",
                    BakFileName,
                    WinError ));
                DhcpPrint((DEBUG_ERRORS, "   Try to re-open the file.\n"));
                ReopenFlag = FALSE;     // Don't truncate the file
            }
        }
    }

    if ( ReopenFlag ) {
        if ( !MoveFile( LogFileName, BakFileName ) ) {
            DhcpPrint((DEBUG_ERRORS,
                    "Cannot rename %ws to %ws (%ld)\n",
                    LogFileName,
                    BakFileName,
                    GetLastError() ));
            DhcpPrint((DEBUG_ERRORS,
                "   Try to re-open the file.\n"));
            ReopenFlag = FALSE;     // Don't truncate the file
        }
    }

    //
    // Open the file.
    //

    EnterCriticalSection( &DhcpGlobalDebugFileCritSect );
    DhcpGlobalDebugFileHandle = CreateFileW( LogFileName,
                                  GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  ReopenFlag ? CREATE_ALWAYS : OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL );


    if ( DhcpGlobalDebugFileHandle == NULL 
	 || INVALID_HANDLE_VALUE == DhcpGlobalDebugFileHandle ) {
        DhcpPrint((DEBUG_ERRORS,  "cannot open %ws ,\n",
                    LogFileName ));
        LeaveCriticalSection( &DhcpGlobalDebugFileCritSect );
        goto ErrorReturn;
    } else {
        // Position the log file at the end
        (VOID) SetFilePointer( DhcpGlobalDebugFileHandle,
                               0,
                               NULL,
                               FILE_END );
    }

    LeaveCriticalSection( &DhcpGlobalDebugFileCritSect );
    return;

ErrorReturn:
    DhcpPrint((DEBUG_ERRORS,
            "   Debug output will be written to debug terminal.\n"));
    return;
}


VOID
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length;
    DWORD BytesWritten;
    static BeginningOfLine = TRUE;
    static LineCount = 0;
    static TruncateLogFileInProgress = FALSE;
    LPSTR Text;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( DebugFlag != 0 && (DhcpGlobalDebugFlag & DebugFlag) == 0 ) {
        return;
    }

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    EnterCriticalSection( &DhcpGlobalDebugFileCritSect );
    length = 0;

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        //
        // If the log file is getting huge,
        //  truncate it.
        //

        if ( DhcpGlobalDebugFileHandle != NULL &&
             !TruncateLogFileInProgress ) {

            //
            // Only check every 50 lines,
            //

            LineCount++;
            if ( LineCount >= 50 ) {
                DWORD FileSize;
                LineCount = 0;

                //
                // Is the log file too big?
                //

                FileSize = GetFileSize( DhcpGlobalDebugFileHandle, NULL );
                if ( FileSize == 0xFFFFFFFF ) {
                    (void) DbgPrint( "[DhcpServer] Cannot GetFileSize %ld\n",
                                     GetLastError() );
                } else if ( FileSize > DhcpGlobalDebugFileMaxSize ) {
                    TruncateLogFileInProgress = TRUE;
                    LeaveCriticalSection( &DhcpGlobalDebugFileCritSect );
                    DhcpOpenDebugFile( TRUE );
                    DhcpPrint(( DEBUG_MISC,
                              "Logfile truncated because it was larger than %ld bytes\n",
                              DhcpGlobalDebugFileMaxSize ));
                    EnterCriticalSection( &DhcpGlobalDebugFileCritSect );
                    TruncateLogFileInProgress = FALSE;
                }

            }
        }

        //
        // If we're writing to the debug terminal,
        //  indicate this is a DHCP server's message.
        //

        if ( DhcpGlobalDebugFileHandle == NULL ) {
            length += (ULONG) sprintf( &OutputBuffer[length], "[DhcpServer] " );
        }

        //
        // Put the timestamp at the begining of the line.
        //
        IF_DEBUG( TIMESTAMP ) {
            SYSTEMTIME SystemTime;
            GetLocalTime( &SystemTime );
            length += (ULONG) sprintf( &OutputBuffer[length],
                                  "%02u/%02u %02u:%02u:%02u ",
                                  SystemTime.wMonth,
                                  SystemTime.wDay,
                                  SystemTime.wHour,
                                  SystemTime.wMinute,
                                  SystemTime.wSecond );
        }

        //
        // Indicate the type of message on the line
        //
        switch (DebugFlag) {
        case DEBUG_ADDRESS:
            Text = "ADDRESS";
            break;

        case DEBUG_CLIENT:
            Text = "CLIENT";
            break;

        case DEBUG_PARAMETERS:
            Text = "PARAMETERS";
            break;

        case DEBUG_OPTIONS:
            Text = "OPTIONS";
            break;

        case DEBUG_ERRORS:
            Text = "ERRORS";
            break;

        case DEBUG_STOC:
            Text = "STOC";
            break;

        case DEBUG_INIT:
            Text = "INIT";
            break;

        case DEBUG_SCAVENGER:
            Text = "SCAVENGER";
            break;

        case DEBUG_TIMESTAMP:
            Text = "TIMESTAMP";
            break;

        case DEBUG_APIS:
            Text = "APIS";
            break;

        case DEBUG_REGISTRY:
            Text = "REGISTRY";
            break;

        case DEBUG_JET:
            Text = "JET";
            break;

        case DEBUG_THREADPOOL:
            Text = "THREADPOOL";
            break;

        case DEBUG_AUDITLOG:
            Text = "AUDITLOG" ;
            break;

        case DEBUG_MISC:
            Text = "MISC";
            break;

        case DEBUG_MESSAGE:
            Text = "MESSAGE";
            break;

        case DEBUG_API_VERBOSE:
            Text = "API_VERBOSE";
            break;

        case DEBUG_DNS :
            Text = "DNS" ;
            break;

        case DEBUG_MSTOC:
            Text = "MSTOC";
            break;
            
        case DEBUG_ROGUE:
            Text = "ROGUE" ;
            break;

        case DEBUG_PNP:
            Text = "PNP";
            break;
            
        case DEBUG_PERF:
            Text = "PERF";
            break;

        case DEBUG_PING:
            Text = "PING";
            break;

        case DEBUG_THREAD:
            Text = "THREAD";
            break;
            
        case DEBUG_TRACE :
            Text = "TRACE";
            break;

        case DEBUG_LOG_IN_FILE:
            Text = "LOG_IN_FILE";
            break;

        default:
            Text = NULL;
            break;
        }

        if ( Text != NULL ) {
            length += (ULONG) sprintf( &OutputBuffer[length], "[%s] ", Text );
        }
    }

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);

    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    BeginningOfLine = (length > 0 && OutputBuffer[length-1] == '\n' );

    va_end(arglist);

    DhcpAssert(length <= MAX_PRINTF_LEN);


    //
    // Output to the debug terminal,
    //  if the log file isn't open or we are asked to do so.
    //

    if ( (DhcpGlobalDebugFileHandle == NULL) ||
         !(DhcpGlobalDebugFlag & DEBUG_LOG_IN_FILE) ) {

        (void) DbgPrint( (PCH) OutputBuffer);

    //
    // Write the debug info to the log file.
    //

    } else {
        if ( !WriteFile( DhcpGlobalDebugFileHandle,
                         OutputBuffer,
                         lstrlenA( OutputBuffer ),
                         &BytesWritten,
                         NULL ) ) {
            (void) DbgPrint( (PCH) OutputBuffer);
        }

    }

    LeaveCriticalSection( &DhcpGlobalDebugFileCritSect );

}

//
// for debug builds these symbols will be redefined to dbg_calloc
// and dbg_free.
//

#undef MIDL_user_allocate
#undef MIDL_user_free


void __RPC_FAR * __RPC_USER MIDL_user_allocate( size_t n )
/*++

Routine Description:
    Allocate memory for use by the RPC stubs.
    .
Arguments:

    n   - # of bytes to allocate .

Return Value:

    Success - A pointer to the new block
    Failure - NULL

--*/
{
    return DhcpAllocateMemory( n );
}

void __RPC_USER MIDL_user_free( void __RPC_FAR *pv )
/*++

Routine Description:

    Free memory allocated by MIDL_user_allocate.

    .
Arguments:

    pv - A pointer to the block.

Return Value:

    void

    .

--*/

{
    DhcpFreeMemory( pv );
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\debug.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This file contains debugging macros for the DHCP server.

Author:

    Madan Appiah  (madana)  10-Sep-1993
    Manny Weiser  (mannyw)  10-Oct-1992

Environment:

    User Mode - Win32

Revision History:


--*/

#define DEBUG_DIR           L"\\debug"
#define DEBUG_FILE          L"\\dhcpssvc.log"
#define DEBUG_BAK_FILE      L"\\dhcpssvc.bak"

//
// LOW WORD bit mask (0x0000FFFF) for low frequency debug output.
//

#define DEBUG_ADDRESS           0x00000001  // subnet address
#define DEBUG_CLIENT            0x00000002  // client API
#define DEBUG_PARAMETERS        0x00000004  // dhcp server parameter
#define DEBUG_OPTIONS           0x00000008  // dhcp option

#define DEBUG_ERRORS            0x00000010  // hard error
#define DEBUG_STOC              0x00000020  // protocol error
#define DEBUG_INIT              0x00000040  // init error
#define DEBUG_SCAVENGER         0x00000080  // sacvenger error

#define DEBUG_TIMESTAMP         0x00000100  // debug message timing
#define DEBUG_APIS              0x00000200  // Dhcp APIs
#define DEBUG_REGISTRY          0x00000400  // Registry operation
#define DEBUG_JET               0x00000800  // JET error

#define DEBUG_THREADPOOL        0x00001000  // thread pool operation
#define DEBUG_AUDITLOG          0x00002000  // audit log operation
// unused flag.
#define DEBUG_MISC              0x00008000  // misc info.

//
// HIGH WORD bit mask (0x0000FFFF) for high frequency debug output.
// ie more verbose.
//

#define DEBUG_MESSAGE           0x00010000  // dhcp message output.
#define DEBUG_API_VERBOSE       0x00020000  // Dhcp API verbose
#define DEBUG_DNS               0x00040000  // Dns related messages
#define DEBUG_MSTOC             0x00080000  // multicast stoc

#define DEBUG_TRACK             0x00100000  // tracking specific problems
#define DEBUG_ROGUE             0x00200000  // rogue stuff printed out
#define DEBUG_PNP               0x00400000  // pnp interface stuff

#define DEBUG_PERF              0x01000000  // Printfs for performance work.
#define DEBUG_ALLOC             0x02000000  // Print allocations de-allocations..
#define DEBUG_PING              0x04000000  // Asynchronous ping details
#define DEBUG_THREAD            0x08000000  // Thread.c stuff

#define DEBUG_TRACE             0x10000000  // Printfs for tracing throug code.
#define DEBUG_TRACE_CALLS       0x20000000  // Trace through piles of junk
#define DEBUG_STARTUP_BRK       0x40000000  // breakin debugger during startup.
#define DEBUG_LOG_IN_FILE       0x80000000  // log debug output in a file.


VOID
DhcpOpenDebugFile(
    IN BOOL ReopenFlag
    );



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\dhcpdef.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpdef.h

Abstract:

    This file contains manifest constants and internal data structures
    for the DHCP server.

Author:

    Madan Appiah  (madana)  10-Sep-1993

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/


#if DBG
#define STATIC
#else
#define STATIC static
#endif // DBG

//
// useful macros
//

#define WSTRSIZE( wsz ) (( wcslen( wsz ) + 1 ) * sizeof( WCHAR ))
#define STRSIZE( sz ) (( strlen( sz ) + 1 ) * sizeof( char ))

//
// calculates the size of a field
//

#define GET_SIZEOF_FIELD( struct, field ) ( sizeof(((struct*)0)->field))


//
// Constants
//

#define DHCP_SERVER                                    L"DhcpServer"
#define DHCP_SERVER_FULL_NAME                          L"DHCP Server"
#define DHCP_SERVER_MODULE_NAME                        L"dhcpssvc.dll"

#define DHCP_SERVER_MAJOR_VERSION_NUMBER               5
#define DHCP_SERVER_MINOR_VERSION_NUMBER               6

#define DHCP_SAMSRV_SUITENAME                          L"Small Business(Restricted)"

//
// database table and field names.
//

#define IPADDRESS_INDEX                                0
#define HARDWARE_ADDRESS_INDEX                         1
#define STATE_INDEX                                    2
#define MACHINE_INFO_INDEX                             3
#define MACHINE_NAME_INDEX                             4
#define LEASE_TERMINATE_INDEX                          5
#define SUBNET_MASK_INDEX                              6
#define SERVER_IP_ADDRESS_INDEX                        7
#define SERVER_NAME_INDEX                              8
#define CLIENT_TYPE_INDEX                              9
#define MAX_INDEX                                      10

//
// This is the max size of client comment field.
//
#define MACHINE_INFO_SIZE                              JET_cbColumnMost

//
//  All the access DHCP needs to registry keys.
//

#define  DHCP_KEY_ACCESS_VALUE                         (KEY_QUERY_VALUE|KEY_SET_VALUE)
#define  DHCP_KEY_ACCESS_KEY                           (KEY_CREATE_SUB_KEY|KEY_ENUMERATE_SUB_KEYS)
#define  DHCP_KEY_ACCESS                               (DHCP_KEY_ACCESS_KEY|DHCP_KEY_ACCESS_VALUE)

//
// timeout (in seconds) used when we wait to see if there are
// other dhcp servers on the net (SAM case)
//
#define DHCP_ROGUE_INIT_DELTA                          3
#define DHCP_ROGUE_RUNTIME_DELTA_SAM                   5*60

// timeout (in milliseconds) used before retrying search for other DHCP servers
#define DHCP_ROGUE_RUNTIME_DELTA                       5*60*1000

// timeout (in milliseconds) used before retrying search for other DHCP servers
// this is the extended version, with a longer timeout
#define DHCP_ROGUE_RUNTIME_DELTA_LONG                  10*60*1000

// # times we send out a discover packet before deciding no other dhcp exists
#define DHCP_ROGUE_MAXRETRIES_SAM                      4

// # times we send out a DHCPINFORM packets at each attempt
#define DHCP_ROGUE_MAXRETRIES                          3

//
// IP Address states
//

//
// The address has been offered to the client, and the server is waiting
// for a request.
//

#define  ADDRESS_STATE_OFFERED                         0

//
// The address is in use.  This is the normal state for an address
//

#define  ADDRESS_STATE_ACTIVE                          1

//
// The address was offered, but was declined by a client.
//

#define  ADDRESS_STATE_DECLINED                        2

//
// The lease for this address has expired, but the record is maintained
// for extended period in this state.
//

#define  ADDRESS_STATE_DOOM                            3

// DynDns address state bits
// The mask for ignoring the status bits that follow.
#define  ADDRESS_BIT_MASK_IGN                          0xF0

//
// The lease has expired and has been deleted.  But DynDns registration is
// not done yet.  So, at startup time these will be cleaned up.
//
#define  ADDRESS_BIT_DELETED                           0x80

//
// The lease is as it is, but for some reason it has not yet been successfully
// registered with the Dns Server
//
#define  ADDRESS_BIT_UNREGISTERED                      0x40

//
// Both A and PTR records have to be dealt with for this guy.
//
#define  ADDRESS_BIT_BOTH_REC                          0x20

//
// Cleanup records on expiry of lease (i.e. do DNS-de-registrations)
//
#define  ADDRESS_BIT_CLEANUP                           0x10


// GetAddressState would get the actual state, ignoring bits in ADDRESS_BIT_MASK_IGN
// IsAddressDeleted  would tell if the delete bit above is set
// IsAddressUnRegistered would tell if the unregistered bit is set
// Similarly the set functions would set these..

#define  GetAddressState(st)                           ((st)&~ADDRESS_BIT_MASK_IGN)
#define  SetAddressState(st,NewSt)                     ((st) = ((st)&ADDRESS_BIT_MASK_IGN) | ((NewSt)&~ADDRESS_BIT_MASK_IGN))
#define  IsAddressDeleted(st)                          (((st)&ADDRESS_BIT_DELETED)==ADDRESS_BIT_DELETED)
#define  IsAddressUnRegistered(st)                     (((st)&ADDRESS_BIT_UNREGISTERED)==ADDRESS_BIT_UNREGISTERED)
#define  IsUpdateAPTRRequired(st)                      (((st)&ADDRESS_BIT_BOTH_REC)==ADDRESS_BIT_BOTH_REC)
#define  IsAddressCleanupRequired(st)                  (((st)&ADDRESS_BIT_CLEANUP)==ADDRESS_BIT_CLEANUP)
#define  AddressDeleted(st)                            ((st)|ADDRESS_BIT_DELETED)
#define  AddressUnRegistered(st)                       ((st)|ADDRESS_BIT_UNREGISTERED)
#define  AddressUpdateAPTR(st)                         ((st)|ADDRESS_BIT_BOTH_REC)
#define  AddressCleanupRequired(st)                    ((st)|ADDRESS_BIT_CLEANUP)
#define  IS_ADDRESS_STATE_OFFERED(st)                  (GetAddressState(st) == ADDRESS_STATE_OFFERED)
#define  IS_ADDRESS_STATE_DECLINED(st)                 (GetAddressState(st) == ADDRESS_STATE_DECLINED)
#define  IS_ADDRESS_STATE_ACTIVE(st)                   (GetAddressState(st) == ADDRESS_STATE_ACTIVE)
#define  IS_ADDRESS_STATE_DOOMED(st)                   (GetAddressState(st) == ADDRESS_STATE_DOOM)
#define  SetAddressStateOffered(st)                    SetAddressState((st), ADDRESS_STATE_OFFERED)
#define  SetAddressStateDeclined(st)                   SetAddressState((st), ADDRESS_STATE_DECLINED)
#define  SetAddressStateActive(st)                     SetAddressState((st), ADDRESS_STATE_ACTIVE)
#define  SetAddressStateDoomed(st)                     SetAddressState((st), ADDRESS_STATE_DOOM)

#define  DOWN_LEVEL(st)                                AddressUpdateAPTR(st)
#define  IS_DOWN_LEVEL(st)                             IsUpdateAPTRRequired(st)

#if DBG
// the following number is in 100-MICRO-SECONDS;
// for debug reasons, it is currently 15 minutes.
#define  MAX_RETRY_DNS_REGISTRATION_TIME               (( ULONGLONG) (120*60*1000*10))

#else
// Retail builds it is 3.5 hours = 60*2+30 = 120 minutes
#define  MAX_RETRY_DNS_REGISTRATION_TIME               (( ULONGLONG) (24*120*60*1000*10))
#endif


#define  USE_NO_DNS                                    DhcpGlobalUseNoDns

#define  DHCP_DNS_DEFAULT_TTL                          (15*60)  // 15 minutes


// See \nt\private\inc\dhcpapi.h for meanings of these items..

#define DNS_FLAG_ENABLED               0x01
#define DNS_FLAG_UPDATE_DOWNLEVEL      0x02
#define DNS_FLAG_CLEANUP_EXPIRED       0x04
#define DNS_FLAG_UPDATE_BOTH_ALWAYS    0x10

//
// error value for "subnet not found"
//      added by t-cheny for superscope
//

#define DHCP_ERROR_SUBNET_NOT_FOUND                    (DWORD)(-1)

//
// for IP address detection
//

#define DHCP_ICMP_WAIT_TIME                            1000
#define DHCP_ICMP_RCV_BUF_SIZE                         0x2000
#define DHCP_ICMP_SEND_MESSAGE                         "DhcpAddressCheck"


//
// for audit log
//

#define DHCP_IP_LOG_ASSIGN                             10
#define DHCP_IP_LOG_RENEW                              11
#define DHCP_IP_LOG_RELEASE                            12
#define DHCP_IP_LOG_CONFLICT                           13
#define DHCP_IP_LOG_RANGE_FULL                         14
#define DHCP_IP_LOG_NACK                               15
#define DHCP_IP_LOG_DELETED                            16
#define DHCP_IP_LOG_EXPIRED                            17
#define DHCP_IP_LOG_START                               0
#define DHCP_IP_LOG_STOP                                1
#define DHCP_IP_LOG_DISK_SPACE_LOW                      2
#define DHCP_IP_LOG_BOOTP                              20
#define DHCP_IP_LOG_DYNBOOTP                           21
#define DHCP_IP_BOOTP_LOG_RANGE_FULL                   22
#define DHCP_IP_BOOTP_LOG_DELETED                      23

#define DHCP_CB_MAX_LOG_ENTRY                          320

#define DHCP_IP_LOG_ROGUE_BASE                         50
#define DHCP_IP_LOG_ROGUE_FIRST                        DHCP_ROGUE_LOG_COULDNT_SEE_DS


//
// these manifests are used to indicate the level that a
// dhcp option was obtain from
//

#define DHCP_OPTION_LEVEL_GLOBAL                       1
#define DHCP_OPTION_LEVEL_SCOPE                        2
#define DHCP_OPTION_LEVEL_RESERVATION                  3


//
// Timeouts, make sure WAIT_FOR_MESSAGE_TIMEOUT is less than
// THREAD_TERMINATION_TIMEOUT.
//

#define THREAD_TERMINATION_TIMEOUT                     60000    // in msecs. 60 secs
#define WAIT_FOR_MESSAGE_TIMEOUT                       4        // in secs.  4 secs

#define ZERO_TIME                                      0x0      // in secs.

#if DBG // used for testing
#define DHCP_SCAVENGER_INTERVAL                         2*60*1000       // in msecs. 2 mins
#define DHCP_DATABASE_CLEANUP_INTERVAL                  5*60*1000       // in msecs. 5 mins.
#define DEFAULT_BACKUP_INTERVAL                         5*60*1000       // in msecs. 5 mins
#define DHCP_LEASE_EXTENSION                            10*60           // in secs.  10 mins
#define DHCP_SCAVENGE_IP_ADDRESS                        15*60*1000      // in msecs. 15 mins
#define CLOCK_SKEW_ALLOWANCE                            5*60            // in secs,  5 mins
#else
#define DHCP_SCAVENGER_INTERVAL                         3*60*1000       // in msecs. 3 mins
#define DHCP_DATABASE_CLEANUP_INTERVAL                  3*60*60*1000    // in msecs. 3hrs
#define DEFAULT_BACKUP_INTERVAL                         15*60*1000      // in msecs. 15 mins
#define DHCP_LEASE_EXTENSION                            4*60*60         // in secs.  4hrs
#define DHCP_SCAVENGE_IP_ADDRESS                        60*60*1000      // in msecs. 1 hr.
#define CLOCK_SKEW_ALLOWANCE                            30*60           // in secs,  30 mins
#endif

#define DHCP_CLIENT_REQUESTS_EXPIRE                     10*60           // in secs. 10 mins
#define DHCP_MINIMUM_LEASE_DURATION                     60*60           // in secs. 1hr
#define EXTRA_ALLOCATION_TIME                           60*60           // in secs. 1hr
#define MADCAP_OFFER_HOLD                               60              // in secs. 1mins

#define DEFAULT_LOGGING_FLAG                            TRUE
#define DEFAULT_RESTORE_FLAG                            FALSE

#define DEFAULT_AUDIT_LOG_FLAG                          1
#define DEFAULT_AUDIT_LOG_MAX_SIZE                      (4*1024*1024)   // 4 M bytes
#define DEFAULT_DETECT_CONFLICT_RETRIES                 0
#define MAX_DETECT_CONFLICT_RETRIES                     5
#define MIN_DETECT_CONFLICT_RETRIES                     0

#define MAX_THREADS                                     20

//
// maximum buffer size that DHCP API will return.
//

#define DHCP_ENUM_BUFFER_SIZE_LIMIT                     64 * 1024 // 64 K
#define DHCP_ENUM_BUFFER_SIZE_LIMIT_MIN                 1024 // 1 K

//
// The minumum count and percentage of remaining address before we will
// log a warning event that the scope is running low on addresses.
//

#define DHCP_DEFAULT_ALERT_COUNT                        80
#define DHCP_DEFAULT_ALERT_PERCENTAGE                   80

#define DHCP_DEFAULT_ROGUE_LOG_EVENTS_LEVEL             1

//
// message queue length.
//

#define DHCP_RECV_QUEUE_LENGTH                          50
#define DHCP_MAX_PROCESSING_THREADS                     20
#define DHCP_MAX_ACTIVE_THREADS                         15

#define DHCP_ASYNC_PING_TYPE                            1
#define DHCP_SYNC_PING_TYPE                             0
#define DHCP_DEFAULT_PING_TYPE                          1

//
// pre-defined MSFT class..
//

#define DHCP_MSFT_VENDOR_CLASS_PREFIX_SIZE              4
#define DHCP_MSFT_VENDOR_CLASS_PREFIX                   "MSFT"

//
// macros
//

#if DBG
// lease the EnterCriticalSectionX as it is to be used..
#else
#define EnterCriticalSectionX(X,Y,Z)                     EnterCriticalSection(X)
#define LeaveCriticalSectionX(X,Y,Z)                     LeaveCriticalSection(X)
#endif

#define LOCK_INPROGRESS_LIST()                           EnterCriticalSectionX(&DhcpGlobalInProgressCritSect, __LINE__, __FILE__)
#define UNLOCK_INPROGRESS_LIST()                         LeaveCriticalSectionX(&DhcpGlobalInProgressCritSect, __LINE__, __FILE__)

#define LOCK_DATABASE()                                  EnterCriticalSectionX(&DhcpGlobalJetDatabaseCritSect, __LINE__, __FILE__)
#define UNLOCK_DATABASE()                                LeaveCriticalSectionX(&DhcpGlobalJetDatabaseCritSect, __LINE__, __FILE__)

#define LOCK_MEMORY()                                    EnterCriticalSectionX(&DhcpGlobalMemoryCritSect, __LINE__, __FILE__)
#define UNLOCK_MEMORY()                                  LeaveCriticalSectionX(&DhcpGlobalMemoryCritSect, __LINE__, __FILE__)

#define ADD_EXTENSION( _x_, _y_ ) \
    ((DWORD)_x_ + (DWORD)_y_) < ((DWORD)_x_) ? \
    INFINIT_LEASE : ((DWORD)(_x_) + (DWORD)_y_)


//
// Structures
//

#include <dhcprog.h>

//
// structure used while collecting info about neighboring DHCP servers
//
typedef struct _NEIGHBORINFO
{
    DWORD   NextOffset;     // self-relative form
    DWORD   IpAddress;      // ipaddr of the DHCP server responding
    CHAR    DomainName[1];
} NEIGHBORINFO, *PNEIGHBORINFO;


//
// A request context, one per processing thread.
//

typedef struct _DHCP_REQUEST_CONTEXT {
    LPBYTE                         ReceiveBuffer;      //  The buffer where a message comes in
    LPBYTE                         SendBuffer;         //  This is where the message is sent out thru
    DWORD                          ReceiveMessageSize; //  The # of bytes received
    DWORD                          ReceiveBufferSize;  //  The size of the receive buffer..
    DWORD                          SendMessageSize;    //  The # of while sending buffer out
    DHCP_IP_ADDRESS                EndPointIpAddress;  //  The Address of the endpoint.
    DHCP_IP_ADDRESS                EndPointMask;       //  The mask for the interface.
    SOCKET                         EndPointSocket;     //  Socket this was received on.
    struct sockaddr                SourceName;
    DWORD                          SourceNameLength;   //  length of above field
    DWORD                          TimeArrived;        //  Timestamp
    DWORD                          MessageType;        //  what kind of msg is this?
    PM_SERVER                      Server;
    PM_SUBNET                      Subnet;
    PM_RANGE                       Range;
    PM_EXCL                        Excl;
    PM_RESERVATION                 Reservation;
    DWORD                          ClassId;
    DWORD                          VendorId;
    BOOL                           fMSFTClient;
    BOOL                           fMadcap;
    LPBYTE                         BinlClassIdentifier;// hack for binl -- need this here..
    DWORD                          BinlClassIdentifierLength;
} DHCP_REQUEST_CONTEXT, *LPDHCP_REQUEST_CONTEXT, *PDHCP_REQUEST_CONTEXT;



//
// The pending context remembers information offered in response
// to a DHCP discover.
//

typedef struct _PENDING_CONTEXT {
    LIST_ENTRY       ListEntry;         //  This is used to string it up in a list?
    DHCP_IP_ADDRESS  IpAddress;         //  The remembered ip address etc
    DHCP_IP_ADDRESS  SubnetMask;
    DWORD            LeaseDuration;
    DWORD            T1;
    DWORD            T2;
    LPSTR            MachineName;
    LPBYTE           HardwareAddress;
    DWORD            HardwareAddressLength;
    DATE_TIME        ExpiresAt;         //  Time stamp it so we can clear it when it stales
    DWORD            HashValue;         //  For quick lookups
} PENDING_CONTEXT, *LPPENDING_CONTEXT;


#include <pendingc.h>                                  // pending context structure and functions

//
// DHCP database table info.
//

typedef struct _TABLE_INFO {
    CHAR           * ColName;
    JET_COLUMNID     ColHandle;
    JET_COLTYP       ColType;
} TABLE_INFO, *LPTABLE_INFO;

//
// DHCP timer block.
//

typedef struct _DHCP_TIMER {
    DWORD           *Period;            // in msecs.
    DATE_TIME        LastFiredTime;     // time when last time this timer was fired.
} DHCP_TIMER, *LPDHCP_TIMER;

//
// TCPIP instance table
//
typedef struct _AddressToInstanceMap {
    DWORD            dwIndex;
    DWORD            dwInstance;
    DWORD            dwIPAddress;
} AddressToInstanceMap;


//
// Exported Jet function from database.c
//

DHCP_IP_ADDRESS
DhcpJetGetSubnetMaskFromIpAddress(
    DHCP_IP_ADDRESS IpAddress
);


//
// perfmon defines
//

#define DhcpGlobalNumDiscovers             (PerfStats->dwNumDiscoversReceived)
#define DhcpGlobalNumOffers                (PerfStats->dwNumOffersSent)
#define DhcpGlobalNumRequests              (PerfStats->dwNumRequestsReceived)
#define DhcpGlobalNumInforms               (PerfStats->dwNumInformsReceived)
#define DhcpGlobalNumAcks                  (PerfStats->dwNumAcksSent)
#define DhcpGlobalNumNaks                  (PerfStats->dwNumNacksSent)
#define DhcpGlobalNumDeclines              (PerfStats->dwNumDeclinesReceived)
#define DhcpGlobalNumReleases              (PerfStats->dwNumReleasesReceived)
#define DhcpGlobalNumPacketsReceived       (PerfStats->dwNumPacketsReceived)
#define DhcpGlobalNumPacketsDuplicate      (PerfStats->dwNumPacketsDuplicate)
#define DhcpGlobalNumPacketsExpired        (PerfStats->dwNumPacketsExpired)
#define DhcpGlobalNumPacketsProcessed      (PerfStats->dwNumPacketsProcessed)
#define DhcpGlobalNumPacketsInPingQueue    (PerfStats->dwNumPacketsInPingQueue)
#define DhcpGlobalNumPacketsInActiveQueue  (PerfStats->dwNumPacketsInActiveQueue)
#define DhcpGlobalNumMilliSecondsProcessed (PerfStats->dwNumMilliSecondsProcessed)

//
// Default class IDs..
//

//
// This is the default class Id for bootp clients, when they don't specify any.
//

#define  DEFAULT_BOOTP_CLASSID        DHCP_BOOTP_CLASS_TXT
#define  DEFAULT_BOOTP_CLASSID_LENGTH (sizeof(DEFAULT_BOOTP_CLASSID)-1)

//
//  This is the signature we look for as a prefix in the hardware
//  address to identify RAS clients.  We need to identify RAS clients
//  currently so that we treat them as low-level clients so far as
//  DNS integration is concerned so that we do not do any registrations
//  for them whatsoever.
//

#define  DHCP_RAS_PREPEND          "RAS "

#define  ERROR_FIRST_DHCP_SERVER_ERROR ERROR_DHCP_REGISTRY_INIT_FAILED
//
// ERROR_LAST_DHCP_SERVER_ERROR already defined in dhcpmsg.mc
//

#define  DHCP_SECRET_PASSWD_KEY    L"_SC_DhcpServer Pass Key"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\dhcpacc.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    access.h

Abstract:

    Private header file to be included by dhcp server service modules
    that need to enforce security.

Author:

    Madan Appiah (madana) 4-Apr-1994

Revision History:

--*/

#ifndef _DHCP_SECURE_INCLUDED_
#define _DHCP_SECURE_INCLUDED_

//-------------------------------------------------------------------//
//                                                                   //
// Object specific access masks                                      //
//                                                                   //
//-------------------------------------------------------------------//

//
// ConfigurationInfo specific access masks
//
#define DHCP_VIEW_ACCESS     (FILE_GENERIC_READ)
#define DHCP_ADMIN_ACCESS    (FILE_GENERIC_WRITE)

#define DHCP_ALL_ACCESS  (FILE_ALL_ACCESS | STANDARD_RIGHTS_REQUIRED |\
                            DHCP_VIEW_ACCESS       |\
                            DHCP_ADMIN_ACCESS )


//
// Object type names for audit alarm tracking
//

#define DHCP_SERVER_SERVICE_OBJECT       TEXT("DhcpServerService")


DWORD
DhcpCreateSecurityObjects(
    VOID
    );

DWORD
DhcpApiAccessCheck(
    ACCESS_MASK DesiredAccess
    );

#endif // ifndef _DHCP_SECURE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\dhcppch.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcppch.h

Abstract:

    This file is the central include file for the DHCP server service.

Author:

    Madan Appiah  (madana)  10-Sep-1993
    Manny Weiser  (mannyw)  11-Aug-1992

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

//#define __DHCP_USE_DEBUG_HEAP__

//#pragma warning(disable : 4115 )
//#pragma warning(disable : 4214 )
//#pragma warning(disable : 4200 )
//#pragma warning(disable : 4213 )
//#pragma warning(disable : 4211 )
//#pragma warning(disable : 4310 )

//
//  NT public header files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <windows.h>
#include <align.h>
#include <activeds.h>
#include <time.h>

//#pragma warning(disable : 4115 )
//#pragma warning(disable : 4214 )
//#pragma warning(disable : 4200 )
//#pragma warning(disable : 4213 )
//#pragma warning(disable : 4211 )
//#pragma warning(disable : 4310 )

#include <lmcons.h>
#include <netlib.h>
#include <lmapibuf.h>
#include <dsgetdc.h>
#include <dnsapi.h>
#include <adsi.h>

#include <winsock2.h>
#include <smbgtpt.h>
#include <excpt.h>

//
// C Runtime library includes.
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>


//
// RPC files
//

#include <rpc.h>

//
// netlib header.
//

#include <lmcons.h>
#include <secobj.h>

//
// database header files.
//

#include <esent.h>
//
// used to include jet.h, but now esent.h
//

//
// tcp services control hander file
//

#include <tcpsvcs.h>

//
// MM header files
//
#include    <mm\mm.h>
#include    <mm\array.h>
#include    <mm\opt.h>
#include    <mm\optl.h>
#include    <mm\optdefl.h>
#include    <mm\optclass.h>
#include    <mm\classdefl.h>
#include    <mm\bitmask.h>
#include    <mm\reserve.h>
#include    <mm\range.h>
#include    <mm\subnet.h>
#include    <mm\sscope.h>
#include    <mm\oclassdl.h>
#include    <mm\server.h>
#include    <mm\address.h>
#include    <mm\server2.h>
#include    <mm\subnet2.h>
#include    <mm\memfree.h>
#include    <mmreg\regutil.h>
#include    <mmreg\regread.h>
#include    <mmreg\regsave.h>

//
//  Local header files
//

#include <dhcpapi.h>
#include <dhcpdef.h>
#include <thread.h>
#include <global.h>
#include <debug.h>
#include <proto.h>
#include <dhcpmsg.h>
#include <dhcpreg.h>
#include <dhcpacc.h>
#include <oldstub.h>

//
//  DHCP library header files
//

#include <dhcp.h>
#include <dhcplib.h>
#include <lock.h>

//
//  global macros.
//

#include <gmacros.h>


// missed define in global.h
#ifndef OPTION_DYNDNS_BOTH
#define OPTION_DYNDNS_BOTH    81
#endif

//
// server callouts
//
#include <callout.h>

//
// DHCP to BINL header file
//

#include <dhcpbinl.h>


//
// debug heap support
//

#include <heapx.h>

#ifdef DBG
#ifdef __DHCP_USE_DEBUG_HEAP__

#pragma message ( "*** DHCP Server will use debug heap ***" )

#define DhcpAllocateMemory(x) calloc(1,x)
#define DhcpFreeMemory(x)     free(x)

#endif
#endif

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\dhcpinst.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpinst.c

Abstract:

    Test program to install dhcp server service.

Author:

    Madan Appiah (madana)  10-Sep-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include <dhcpsrv.h>

DWORD GlobalDebugFlag = 0x8000FFFF;

#define DHCP_NET_KEY    L"Net"

#if DBG

VOID
DhcpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{

#define MAX_PRINTF_LEN 1024        // Arbitrary.

    va_list arglist;
    char OutputBuffer[MAX_PRINTF_LEN];
    ULONG length = 0;

    //
    // Put a the information requested by the caller onto the line
    //

    va_start(arglist, Format);
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    va_end(arglist);

    DhcpAssert(length <= MAX_PRINTF_LEN);

    //
    // Output to the debug terminal,
    //

    printf( "%s", OutputBuffer);
}

#endif // DBG
//
// utility to install the DHCP Server service.
//

DWORD
InstallService(
    VOID
    )
{
    LPWSTR lpszBinaryPathName = L"%SystemRoot%\\system32\\ntsd -g -G tcpsvcs";
    SC_HANDLE ManagerHandle, ServiceHandle;
    DWORD Error;

    ManagerHandle = OpenSCManager(NULL, NULL, GENERIC_WRITE );
    if ( ManagerHandle == NULL ) {
        Error = GetLastError();
        return( Error );
    }

    ServiceHandle = CreateService(
                        ManagerHandle,             /* SCManager database  */
                        L"DhcpServer",             /* name of service     */
                        L"DhcpServer",             /* display name        */
                        SERVICE_ALL_ACCESS,        /* desired access      */
                        SERVICE_WIN32_SHARE_PROCESS, /* service type        */
                        SERVICE_DEMAND_START,      /* start type          */
                        SERVICE_ERROR_NORMAL,      /* error control type  */
                        lpszBinaryPathName,        /* service's binary    */
                        NULL,                      /* no load order group */
                        NULL,                      /* no tag ID           */
                        NULL,                      /* no dependencies     */
                        NULL,                      /* LocalSystem account */
                        NULL);                     /* no password         */

    if ( ServiceHandle == NULL ) {
        Error = GetLastError();
        return( Error );
    }

    CloseServiceHandle( ServiceHandle );
    CloseServiceHandle( ManagerHandle );

    return( ERROR_SUCCESS );
}

DWORD
InitializeAddresses(
    INT argc,
    LPSTR argv[]
    )
{
    DWORD Error;
    HKEY ParametersHandle = NULL;
    HKEY NetKeyHandle = NULL;
    WCHAR NetKeyBuffer[DHCP_IP_KEY_LEN];
    LPWSTR NetKeyAppend;
    DWORD KeyDisposition;
    DWORD NetNum;

    //
    // open PARAMETER ROOT key.
    //

    Error = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                DHCP_ROOT_KEY DHCP_KEY_CONNECT DHCP_PARAM_KEY, // concat
                0,
                DHCP_CLASS,
                REG_OPTION_NON_VOLATILE,
                DHCP_KEY_ACCESS,
                NULL,
                &ParametersHandle,
                &KeyDisposition );

    if ( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // create debug flag.
    //

    Error = RegSetValueEx(
                ParametersHandle,
                DHCP_DEBUG_FLAG_VALUE,
                0,
                DHCP_DEBUG_FLAG_VALUE_TYPE,
                (LPBYTE)&GlobalDebugFlag,
                sizeof(DWORD) );

    if ( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    wcscpy( NetKeyBuffer, DHCP_NET_KEY);
    NetKeyAppend = NetKeyBuffer + wcslen(NetKeyBuffer);

    for( NetNum = 0; NetNum < (DWORD)(argc / 2); NetNum++) {

        DWORD IpAddress;
        DWORD SubnetMask;

        //
        // make net key. DHCP_NET_KEY + NumNet
        //

        DhcpRegOptionIdToKey( (BYTE)NetNum, NetKeyAppend );

        Error = RegCreateKeyEx(
                    ParametersHandle,
                    NetKeyBuffer,
                    0,
                    DHCP_CLASS,
                    REG_OPTION_NON_VOLATILE,
                    DHCP_KEY_ACCESS,
                    NULL,
                    &NetKeyHandle,
                    &KeyDisposition );

        if ( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        IpAddress = DhcpDottedStringToIpAddress(argv[NetNum*2]);
        Error = RegSetValueEx(
                    NetKeyHandle,
                    DHCP_NET_IPADDRESS_VALUE,
                    0,
                    DHCP_NET_IPADDRESS_VALUE_TYPE,
                    (LPBYTE)&IpAddress,
                    sizeof(DHCP_IP_ADDRESS) );

        if ( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        SubnetMask = DhcpDottedStringToIpAddress(argv[NetNum * 2 + 1]);
        Error = RegSetValueEx(
                    NetKeyHandle,
                    DHCP_NET_SUBNET_MASK_VALUE,
                    0,
                    DHCP_NET_SUBNET_MASK_VALUE_TYPE,
                    (LPBYTE)&SubnetMask,
                    sizeof(DHCP_IP_ADDRESS) );

        if ( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        printf("Dhcp Parameter key %ws is successfully created.\n",
                    NetKeyBuffer );
        printf("\tIpAddress = %s, SubnetMask = %s\n",
                    argv[NetNum * 2], argv[NetNum * 2 + 1] );

        RegCloseKey( NetKeyHandle );
        NetKeyHandle = NULL;
    }

Cleanup:

    if( ParametersHandle != NULL ) {
        RegCloseKey( ParametersHandle );
    }

    if( NetKeyHandle != NULL ) {
        RegCloseKey( NetKeyHandle );
    }

    return( Error );
}

VOID
DisplayUsage(
    VOID
    )
{
    printf( "Usage:  dhcpinst address0 subnet0 "
                "[address1 subnet1] ...\n");
    return;
}

VOID __cdecl
main(
    int argc,
    char *argv[]
    )
{
    DWORD Error;

    if( argc < 3 ) {
        DisplayUsage();
        return;
    }


    //
    // Record addresses specified in the Registry.
    //

    Error = InitializeAddresses( argc - 1, &argv[1]);

    if( Error != ERROR_SUCCESS ) {
        printf( "Falied to initialize addresses, %ld.\n", Error );
        return;
    }

    Error = InstallService();

    if( Error != ERROR_SUCCESS ) {
        printf( "Falied to install service, %ld.\n", Error );
        return;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\dhcprpc2.c ===
/*++

Copyright (C) 1998 Microsoft Corporation

Module Name:
    dhcprpc2.c

Abstract:
    This module just includes some rpc files to get
    over pre-compilation woes.

--*/

#include <dhcppch.h>

#include "dhcp2_srv_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\dhcpreg.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Dhcpreg.h

Abstract:

    This file contains registry definitions that are required to hold
    dhcp configuration parameters.

Author:

    Madan Appiah  (madana)  19-Sep-1993

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/
#define DHCP_SERVER_PRIMARY                       1
#define DHCP_SERVER_SECONDARY                     2

#define SERVICES_KEY                              L"System\\CurrentControlSet\\Services\\"

#define ADAPTER_TCPIP_PARMS_KEY                   L"TCPIP\\Parameters\\Interfaces\\"
#define ADAPTER_TCPIP_PREFIX                      L"\\Device\\"

#define DHCP_SWROOT_KEY                           L"Software\\Microsoft\\DhcpServer"
#define DHCP_ROOT_KEY                             L"System\\CurrentControlSet\\Services\\DhcpServer"
#define DHCP_CLASS                                L"DhcpClass"
#define DHCP_CLASS_SIZE                           sizeof(DHCP_CLASS)
#define DHCP_KEY_CONNECT                          L"\\"
#define DHCP_KEY_CONNECT_ANSI                     "\\"
#define DHCP_KEY_CONNECT_CHAR                     L'\\'
#define DHCP_DEFAULT_BACKUP_PATH_NAME             "Backup"
#define DHCP_BACKUP_CONFIG_FILE_NAME              L"DhcpCfg"
#define DHCP_JET_BACKUP_PATH                      "Jet"

#define DHCP_DEFAULT_BACKUP_DB_PATH               L"%SystemRoot%\\System32\\dhcp\\backup"
#define DHCP_DEFAULT_DB_PATH                      L"%SystemRoot%\\System32\\dhcp"
#define DHCP_DEFAULT_LOG_FILE_PATH                L"%SystemRoot%\\System32\\dhcp\\backup"

//
// DHCP subkey names.
//

#define DHCP_CONFIG_KEY                           L"Configuration"
#define DHCP_PARAM_KEY                            L"Parameters"

//
// Subkeys of configuration
//

#define DHCP_SUBNETS_KEY                          L"Subnets"
#define DHCP_MSCOPES_KEY                          L"MulticastScopes"
#define DHCP_SERVERS_KEY                          L"DHCPServers"
#define DHCP_IPRANGES_KEY                         L"IpRanges"
#define DHCP_RESERVED_IPS_KEY                     L"ReservedIps"
#define DHCP_SUBNET_OPTIONS_KEY                   L"SubnetOptions"

#define DHCP_OPTION_INFO_KEY                      L"OptionInfo"
#define DHCP_GLOBAL_OPTIONS_KEY                   L"GlobalOptionValues"
#define DHCP_RESERVED_OPTIONS_KEY                 L"ReservedOptionValues"
#define DHCP_SUPERSCOPE_KEY                       L"SuperScope"

//
// DHCP value field names.
//

#define DHCP_LAST_DOWNLOAD_TIME_VALUE             L"LastDownloadTime"
#define DHCP_LAST_DOWNLOAD_TIME_TYPE              REG_BINARY

#define DHCP_BOOT_FILE_TABLE                      L"BootFileTable"
#define DHCP_BOOT_FILE_TABLE_TYPE                 REG_MULTI_SZ

//
// Option value field names.
//

#define DHCP_OPTION_ID_VALUE                      L"OptionID"
#define DHCP_OPTION_ID_VALUE_TYPE                 REG_DWORD

#define DHCP_OPTION_NAME_VALUE                    L"OptionName"
#define DHCP_OPTION_NAME_VALUE_TYPE               REG_SZ

#define DHCP_OPTION_COMMENT_VALUE                 L"OptionComment"
#define DHCP_OPTION_COMMENT_VALUE_TYPE            REG_SZ

#define DHCP_OPTION_VALUE_REG                     L"OptionValue"
#define DHCP_OPTION_VALUE_TYPE                    REG_BINARY

#define DHCP_OPTION_TYPE_VALUE                    L"OptionType"
#define DHCP_OPTION_TYPE_VALUE_TYPE               REG_DWORD
//
// subnet value field names.
//

#define DHCP_SUBNET_ADDRESS_VALUE                 L"SubnetAddress"
#define DHCP_SUBNET_ADDRESS_VALUE_TYPE            REG_DWORD

#define DHCP_SUBNET_MASK_VALUE                    L"SubnetMask"
#define DHCP_SUBNET_MASK_VALUE_TYPE               REG_DWORD

#define DHCP_SUBNET_NAME_VALUE                    L"SubnetName"
#define DHCP_SUBNET_NAME_VALUE_TYPE               REG_SZ

#define DHCP_SUBNET_COMMENT_VALUE                 L"SubnetComment"
#define DHCP_SUBNET_COMMENT_VALUE_TYPE            REG_SZ

#define DHCP_SUBNET_EXIP_VALUE                    L"ExcludedIpRanges"
#define DHCP_SUBNET_EXIP_VALUE_TYPE               REG_BINARY

#define DHCP_SUBNET_STATE_VALUE                   L"SubnetState"
#define DHCP_SUBNET_STATE_VALUE_TYPE              REG_DWORD

#define DHCP_SUBNET_SWITCHED_NETWORK_VALUE        L"SwitchedNetworkFlag"
#define DHCP_SUBNET_SWITCHED_NETWORK_VALUE_TYPE   REG_DWORD

//
// DHCP server info fields names.
//

#define DHCP_SRV_ROLE_VALUE                       L"Role"
#define DHCP_SRV_ROLE_VALUE_TYPE                  REG_DWORD

#define DHCP_SRV_IP_ADDRESS_VALUE                 L"ServerIpAddress"
#define DHCP_SRV_IP_ADDRESS_VALUE_TYPE            REG_DWORD

#define DHCP_SRV_HOST_NAME                        L"ServerHostName"
#define DHCP_SRV_HOST_NAME_TYPE                   REG_SZ

#define DHCP_SRV_NB_NAME                          L"ServerNetBiosName"
#define DHCP_SRV_NB_NAME_TYPE                     REG_SZ

//
// IpRange info fields names.
//

#define DHCP_IPRANGE_START_VALUE                  L"StartAddress"
#define DHCP_IPRANGE_START_VALUE_TYPE             REG_DWORD

#define DHCP_IPRANGE_END_VALUE                    L"EndAddress"
#define DHCP_IPRANGE_END_VALUE_TYPE               REG_DWORD

#define DHCP_IP_USED_CLUSTERS_VALUE               L"UsedClusters"
#define DHCP_IP_USED_CLUSTERS_VALUE_TYPE          REG_BINARY

#define DHCP_IP_INUSE_CLUSTERS_VALUE              L"InUseClusters"
#define DHCP_IP_INUSE_CLUSTERS_VALUE_TYPE         REG_BINARY

//
// Reserved IP info field names.
//

#define DHCP_RIP_ADDRESS_VALUE                    L"IpAddress"
#define DHCP_RIP_ADDRESS_VALUE_TYPE               REG_DWORD

#define DHCP_RIP_CLIENT_UID_VALUE                 L"ClientUID"
#define DHCP_RIP_CLIENT_UID_VALUE_TYPE            REG_BINARY

#define DHCP_RIP_ALLOWED_CLIENT_TYPES_VALUE       L"AllowedClientTypes"
#define DHCP_RIP_ALLOWED_CLIENT_TYPES_VALUE_TYPE  REG_BINARY

//
//  Parameter Key, Value fields names.
//

#define DHCP_API_PROTOCOL_VALUE                   L"APIProtocolSupport"
#define DHCP_API_PROTOCOL_VALUE_TYPE              REG_DWORD

#define DHCP_DB_NAME_VALUE                        L"DatabaseName"
#define DHCP_DB_NAME_VALUE_TYPE                   REG_SZ

#define DHCP_DB_PATH_VALUE                        L"DatabasePath"
#define DHCP_DB_PATH_VALUE_TYPE                   REG_EXPAND_SZ

#define DHCP_LOG_FILE_PATH_VALUE                  L"DhcpLogFilePath"
#define DHCP_LOG_FILE_PATH_VALUE_TYPE             REG_EXPAND_SZ

#define DHCP_BACKUP_PATH_VALUE                    L"BackupDatabasePath"
#define DHCP_BACKUP_PATH_VALUE_TYPE               REG_EXPAND_SZ

#define DHCP_RESTORE_PATH_VALUE                   L"RestoreDatabasePath"
#define DHCP_RESTORE_PATH_VALUE_TYPE              REG_SZ

#define DHCP_BACKUP_INTERVAL_VALUE                L"BackupInterval"
#define DHCP_BACKUP_INTERVAL_VALUE_TYPE           REG_DWORD

#define DHCP_DB_LOGGING_FLAG_VALUE                L"DatabaseLoggingFlag"
#define DHCP_DB_LOGGING_FLAG_VALUE_TYPE           REG_DWORD

#define DHCP_DB_DOOM_TIME_VALUE                   L"LeaseExtension"
#define DHCP_DB_DOOM_TIME_VALUE_TYPE              REG_DWORD

#define DHCP_RESTORE_FLAG_VALUE                   L"RestoreFlag"
#define DHCP_RESTORE_FLAG_VALUE_TYPE              REG_DWORD

#define DHCP_DB_CLEANUP_INTERVAL_VALUE            L"DatabaseCleanupInterval"
#define DHCP_DB_CLEANUP_INTERVAL_VALUE_TYPE       REG_DWORD

#define DHCP_MESSAGE_QUEUE_LENGTH_VALUE           L"MessageQueueLength"
#define DHCP_MESSAGE_QUEUE_LENGTH_VALUE_TYPE      REG_DWORD

#define DHCP_DEBUG_FLAG_VALUE                     L"DebugFlag"
#define DHCP_DEBUG_FLAG_VALUE_TYPE                REG_DWORD

#define DHCP_AUDIT_LOG_FLAG_VALUE                 L"ActivityLogFlag"
#define DHCP_AUDIT_LOG_FLAG_VALUE_TYPE            REG_DWORD

#define DHCP_AUDIT_LOG_MAX_SIZE_VALUE             L"ActivityLogMaxSize"
#define DHCP_AUDIT_LOG_MAX_SIZE_VALUE_TYPE        REG_DWORD

#define DHCP_DETECT_CONFLICT_RETRIES_VALUE        L"DetectConflictRetries"
#define DHCP_DETECT_CONFLICT_RETRIES_VALUE_TYPE   REG_DWORD

#define DHCP_USE351DB_FLAG_VALUE                  L"Use351Db"
#define DHCP_USE351DB_FLAG_VALUE_TYPE             REG_DWORD

#define DHCP_DBTYPE_VALUE                         L"DbType"
#define DHCP_DBTYPE_VALUE_TYPE                    REG_DWORD

#define DHCP_IGNORE_BROADCAST_FLAG_VALUE          L"IgnoreBroadcastFlag"
#define DHCP_IGNORE_BROADCAST_VALUE_TYPE          REG_DWORD

#define DHCP_MAX_PROCESSING_THREADS_VALUE         L"MaxProcessingThreads"
#define DHCP_MAX_PROCESSING_THREADS_TYPE          REG_DWORD

#define DHCP_MAX_ACTIVE_THREADS_VALUE             L"MaxActiveThreads"
#define DHCP_MAX_ACTIVE_THREADS_TYPE              REG_DWORD

#define DHCP_BCAST_ADDRESS_VALUE                  L"BroadcastAddress"
#define DHCP_BCAST_ADDRESS_VALUE_TYPE             REG_DWORD

#define DHCP_PING_TYPE_VALUE                      L"DhcpPingType"
#define DHCP_PING_TYPE_TYPE                       REG_DWORD

//
// define linkage key values.
//

#define DHCP_LINKAGE_KEY                          L"Linkage"
#define TCPIP_LINKAGE_KEY                         L"System\\CurrentControlSet\\Services\\Tcpip\\Linkage"

#define DHCP_BIND_VALUE                           L"Bind"
#define DHCP_BIND_VALUE_TYPE                      REG_MULTI_SZ

#define DHCP_NET_BIND_DHCDSERVER_FLAG_VALUE       L"BindToDHCPServer"
#define DHCP_NET_BIND_DHCPSERVER_FLAG_VALUE_TYPE  REG_DWORD

#define DHCP_NET_IPADDRESS_VALUE                  L"IpAddress"
#define DHCP_NET_SUBNET_MASK_VALUE                L"SubnetMask"

#define DHCP_NET_IPADDRESS_VALUE_TYPE             REG_MULTI_SZ
#define DHCP_NET_SUBNET_MASK_VALUE_TYPE           REG_MULTI_SZ

#define DHCP_NET_DHCP_ENABLE_VALUE                L"EnableDHCP"
#define DHCP_NET_DHCP_ENABLE_VALUE_TYPE           REG_DWORD

#define DHCP_QUICK_BIND_VALUE                     L"Bind"
#define DHCP_QUICK_BIND_VALUE_TYPE                REG_MULTI_SZ

#define DHCP_PROCESS_INFORMS_ONLY_FLAG            L"DhcpProcessInformsOnlyFlag"
#define DHCP_PROCESS_INFORMS_ONLY_FLAG_TYPE       REG_DWORD

#define DHCP_ALERT_PERCENTAGE_VALUE               L"DhcpAlertPercentage"
#define DHCP_ALERT_PERCENTAGE_VALUE_TYPE          REG_DWORD

#define DHCP_ALERT_COUNT_VALUE                    L"DhcpAlertCount"
#define DHCP_ALERT_COUNT_VALUE_TYPE               REG_DWORD

#define DHCP_DISABLE_ROGUE_DETECTION              L"DisableRogueDetection"
#define DHCP_DISABLE_ROGUE_DETECTION_TYPE         REG_DWORD

#define DHCP_ROGUE_AUTH_RECHECK_TIME              L"RogueAuthorizationRecheckInterval"
#define DHCP_ROGUE_AUTH_RECHECK_TIME_TYPE         REG_DWORD

#define DHCP_ROGUE_LOG_EVENTS                     L"DhcpRogueLogLevel"
#define DHCP_ROGUE_LOG_EVENTS_TYPE                REG_DWORD

#define DHCP_ENABLE_DYNBOOTP                      L"EnableDynamicBOOTP"
#define DHCP_ENABLE_DYNBOOTP_TYPE                 REG_DWORD

#define DHCP_GLOBAL_SERVER_PORT                   L"ServerPort"
#define DHCP_GLOBAL_SERVER_PORT_TYPE              REG_DWORD

#define DHCP_GLOBAL_CLIENT_PORT                   L"ClientPort"
#define DHCP_GLOBAL_CLIENT_PORT_TYPE              REG_DWORD

#define DHCP_CLOCK_SKEW_ALLOWANCE                 L"ClockSkewAllowance"
#define DHCP_CLOCK_SKEW_ALLOWANCE_TYPE            REG_DWORD

#define DHCP_EXTRA_ALLOCATION_TIME                L"ExtraAllocationTime"
#define DHCP_EXTRA_ALLOCATION_TIME_TYPE           REG_DWORD

//
// macros.
//

#define LOCK_REGISTRY()                           EnterCriticalSection(&DhcpGlobalRegCritSect)
#define UNLOCK_REGISTRY()                         LeaveCriticalSection(&DhcpGlobalRegCritSect)

#define DHCP_IP_OVERLAP(_s_, _e_, _ips_, _ipe_ ) \
    ((((_s_ >= _ips_) && (_s_ <= _ipe_)) || \
            ((_e_ >= _ips_) && (_e_ <= _ipe_)))) || \
    ((((_ips_ >= _s_) && (_ips_ <= _e_)) || \
            ((_ipe_ >= _s_) && (_ipe_ <= _e_))))

//
// binary data structues.
//

//
// Excluded IpRanges.
//

typedef struct _EXCLUDED_IP_RANGES {
    DWORD NumRanges;
    DHCP_IP_RANGE Ranges[0];    // embedded array.
} EXCLUDED_IP_RANGES, *LPEXCLUDED_IP_RANGES;

//
// Used clusters.
//

typedef struct _USED_CLUSTERS {
    DWORD NumUsedClusters;
    DHCP_IP_ADDRESS Clusters[0]; // embedded array.
} USED_CLUSTERS, *LPUSED_CLUSTERS;

//
// in use clusters.
//

#define CLUSTER_SIZE    (1 * sizeof(DWORD) * 8)  // one dword, ie 32 addresses.??

typedef struct _IN_USE_CLUSTER_ENTRY {
    DHCP_IP_ADDRESS ClusterAddress;
    DWORD   ClusterBitMap;
} IN_USE_CLUSTER_ENTRY, *LPIN_USE_CLUSTER_ENTRY;

typedef struct _IN_USE_CLUSTERS {
    DWORD NumInUseClusters;
    IN_USE_CLUSTER_ENTRY Clusters[0];    // embedded array.
} IN_USE_CLUSTERS, *LPIN_USE_CLUSTERS;


//
// Key query Info.
//

typedef struct _DHCP_KEY_QUERY_INFO {
    WCHAR Class[DHCP_CLASS_SIZE];
    DWORD ClassSize;
    DWORD NumSubKeys;
    DWORD MaxSubKeyLen;
    DWORD MaxClassLen;
    DWORD NumValues;
    DWORD MaxValueNameLen;
    DWORD MaxValueLen;
    DWORD SecurityDescriptorLen;
    FILETIME LastWriteTime;
} DHCP_KEY_QUERY_INFO, *LPDHCP_KEY_QUERY_INFO;


//
// protos
//

DWORD
DhcpRegQueryInfoKey(
    HKEY KeyHandle,
    LPDHCP_KEY_QUERY_INFO QueryInfo
    );

DWORD
DhcpRegGetValue(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    LPBYTE BufferPtr
    );

DWORD
DhcpRegCreateKey(
    HKEY RootKey,
    LPWSTR KeyName,
    PHKEY KeyHandle,
    LPDWORD KeyDisposition
    );

DWORD
DhcpRegDeleteKey(
    HKEY ParentKeyHandle,
    LPWSTR KeyName
    );

DWORD
DhcpInitializeRegistry(
    VOID
    );

VOID
DhcpCleanupRegistry(
    VOID
    );

DWORD
DhcpBackupConfiguration(
    LPWSTR BackupFileName
    );

DWORD
DhcpRestoreConfiguration(
    LPWSTR BackupFileName
    );


DWORD
DhcpOpenInterfaceByName(
    IN LPCWSTR InterfaceName,
    OUT HKEY *Key
    );


//
// for superscope  (added by t-cheny)
//

VOID
DhcpCleanUpSuperScopeTable(
    VOID
);

DWORD
DhcpInitializeSuperScopeTable(
    VOID
);

BOOL
CheckKeyForBinding(
    IN HKEY Key,
    IN ULONG IpAddress
    );

BOOL
CheckKeyForBindability(
    IN HKEY Key,
    IN ULONG IpAddress
    );

ULONG
SetKeyForBinding(
    IN HKEY Key,
    IN ULONG IpAddress,
    IN BOOL fBind
    );

DWORD
DhcpSaveOrRestoreConfigToFile(
    IN HKEY hKey,
    IN LPWSTR ConfigFileName,
    IN BOOL fRestore
    );

DWORD
DeleteSoftwareRootKey(
    VOID
    );

//
// end of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\dhcpreg.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Dhcpreg.c

Abstract:

    This file contains functions that manipulate dhcp configuration
    info. in and out from system registry.

Author:

    Madan Appiah  (madana)  19-Sep-1993

Environment:

    User Mode - Win32 - MIDL

Revision History:

    Cheng Yang (t-cheny)  28-May-1996 superscope
    Cheng Yang (t-cheny)  27-Jun-1996 IP address detection, audit log

--*/

#include <dhcppch.h>

//
//  Local storage
//
DWORD     nQuickBindAddresses = 0;
LPDWORD   QuickBindAddresses = NULL;
LPDWORD   QuickBindMasks = NULL;

DWORD
DhcpUpgradeConfiguration(
    VOID
    );
    
DWORD
DhcpRegQueryInfoKey(
    HKEY KeyHandle,
    LPDHCP_KEY_QUERY_INFO QueryInfo
    )
/*++

Routine Description:

    This function retrieves information about given key.

Arguments:

    KeyHandle - handle to a registry key whose info will be retrieved.

    QueryInfo - pointer to a info structure where the key info will be
                returned.

Return Value:

    Registry Errors.

--*/
{
    DWORD Error;

    QueryInfo->ClassSize = DHCP_CLASS_SIZE;
    Error = RegQueryInfoKey(
                KeyHandle,
                QueryInfo->Class,
                &QueryInfo->ClassSize,
                NULL,
                &QueryInfo->NumSubKeys,
                &QueryInfo->MaxSubKeyLen,
                &QueryInfo->MaxClassLen,
                &QueryInfo->NumValues,
                &QueryInfo->MaxValueNameLen,
                &QueryInfo->MaxValueLen,
                &QueryInfo->SecurityDescriptorLen,
                &QueryInfo->LastWriteTime
                );

    return( Error );
} // DhcpRegQueryInfoKey()

DWORD
DhcpRegGetValue(
    HKEY KeyHandle,
    LPWSTR ValueName,
    DWORD ValueType,
    LPBYTE BufferPtr
    )
/*++

Routine Description:

    This function retrieves the value of the specified value field. This
    function allocates memory for variable length field such as REG_SZ.
    For REG_DWORD data type, it copies the field value directly into
    BufferPtr. Currently it can handle only the following fields :

    REG_DWORD,
    REG_SZ,
    REG_BINARY

Arguments:

    KeyHandle : handle of the key whose value field is retrieved.

    ValueName : name of the value field.

    ValueType : Expected type of the value field.

    BufferPtr : Pointer to DWORD location where a DWORD datatype value
                is returned or a buffer pointer for REG_SZ or REG_BINARY
                datatype value is returned.

Return Value:

    Registry Errors.

--*/
{
    DWORD Error;
    DWORD LocalValueType;
    DWORD ValueSize;
    LPBYTE DataBuffer;
    LPBYTE AllotedBuffer = NULL;
    LPDHCP_BINARY_DATA BinaryData;

    //
    // Query DataType and BufferSize.
    //

    Error = RegQueryValueEx(
                KeyHandle,
                ValueName,
                0,
                &LocalValueType,
                NULL,
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        return(Error);
    }

    DhcpAssert( LocalValueType == ValueType );
    switch( ValueType ) {
    case REG_DWORD:
        DhcpAssert( ValueSize == sizeof(DWORD) );

        DataBuffer = BufferPtr;
        break;

    case REG_SZ:
    case REG_MULTI_SZ:
    case REG_EXPAND_SZ:

        if( ValueSize == 0 ) {

            //
            // if string no found in the registry,
            // allocate space for null string.
            //

            ValueSize = sizeof(WCHAR);
        }

        //
        // fall through.
        //

    case REG_BINARY:
        AllotedBuffer = DataBuffer = MIDL_user_allocate( ValueSize );

        if( DataBuffer == NULL ) {
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        break;

    default:
        DhcpPrint(( DEBUG_REGISTRY, "Unexpected ValueType in"
                        "DhcpRegGetValue function, %ld\n", ValueType ));
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // retrieve data.
    //

    Error = RegQueryValueEx(
                KeyHandle,
                ValueName,
                0,
                &LocalValueType,
                DataBuffer,
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        if( NULL != AllotedBuffer ) {
            MIDL_user_free( AllotedBuffer );
            AllotedBuffer = NULL;
        }
        
        *(DWORD *)BufferPtr = 0;
        return(Error);
    }

    switch( ValueType ) {
    case REG_SZ:
    case REG_MULTI_SZ:
    case REG_EXPAND_SZ:

        if( ValueSize == 0 ) {

            //
            // if string no found in the registry,
            // return null string.
            //

            *(LPWSTR)DataBuffer = '\0';
        }

        *(LPBYTE *)BufferPtr = DataBuffer;
        break;

    case REG_BINARY:
        BinaryData = MIDL_user_allocate(sizeof(DHCP_BINARY_DATA));

        if( BinaryData == NULL ) {
            MIDL_user_free( AllotedBuffer );
            *(DWORD *)BufferPtr = 0;
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        BinaryData->DataLength = ValueSize;
        BinaryData->Data = DataBuffer;
        *(LPBYTE *)BufferPtr = (LPBYTE)BinaryData;

    default:
        break;
    }

    return(Error);
} // DhcpRegGetValue()

// OLD
DWORD
DhcpRegCreateKey(
    HKEY RootKey,
    LPWSTR KeyName,
    PHKEY KeyHandle,
    LPDWORD KeyDisposition
    )
/*++

Routine Description:

    This function opens a registry key for DHCP service.

Arguments:

    RootKey : Registry handle of the parent key.

    KeyName : Name of the key to be opened.

    KeyHandle : Handle of the open key.

    KeyDisposition : pointer to a location where the disposition value
                        is returned.

Return Value:

    Registry Errors.

--*/
{
    DWORD Error;

    //
    // Create/Open Registry keys.
    //

    Error = RegCreateKeyEx(
                RootKey,
                KeyName,
                0,
                DHCP_CLASS,
                REG_OPTION_NON_VOLATILE,
                DHCP_KEY_ACCESS,
                NULL,
                KeyHandle,
                KeyDisposition );

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_REGISTRY, "RegCreateKeyEx failed to create "
                        "%ws, %ld.\n", KeyName, Error));
        return( Error );
    }

#if DBG
    if( *KeyDisposition == REG_CREATED_NEW_KEY ) {
        DhcpPrint(( DEBUG_REGISTRY,
            "%ws registry key is created.\n",
             KeyName));
    }
#endif // DBG

    return( Error );
}

BOOL
QuickBound(
    DHCP_IP_ADDRESS Address,
    DHCP_IP_ADDRESS *SubnetMask,
    DHCP_IP_ADDRESS *SubnetAddress,
    BOOL *fBind
)
/*++

Routine Description:
    This routine tells if the interface is bound or if there is another
    IPAddress in the same subnet to which the interface is bound.

Return Value:
    TRUE --> quick bound or have another quickbound if on subnet..

--*/
{
    ULONG i;
    BOOL fRetVal = FALSE;

    (*fBind) = FALSE;
    for( i = 0; i < nQuickBindAddresses ; i ++ ) {
        if( Address == QuickBindAddresses[i] ) {
            *SubnetMask = QuickBindMasks[i];
            *SubnetAddress = Address & *SubnetMask;
            (*fBind) = TRUE;
            return TRUE;
        }
        if( (Address & QuickBindMasks[i]) ==
            (QuickBindAddresses[i] & QuickBindMasks[i]) ) {
            (*fBind) = FALSE;
            fRetVal = TRUE;
        }
    }
    return fRetVal;
}

DWORD
DhcpRegFillQuickBindInfo(
    VOID
    )
/*++

Routine Description:

    This function initializes EndPoint array from the registry
    information.

    The "parameter" key for DHCP service specifies the QUICK BIND info.
    This is a MULTI_SZ string of ipaddresses followed by the subnet
    masks.  This is read to initialize the endpoints. If this succeeds,
    then the usual BIND info is NOT read. On the other hand, if anything
    fails here, the usual information is read, and this information here
    is totally ignored.

Arguments:

    none.

Return Value:

    Registry Error.

--*/
{
    DWORD Error;

    HKEY LinkageKeyHandle = NULL;
    LPWSTR BindString = NULL;
    LPWSTR StringPtr, TmpString;
    DWORD StringLen;
    DWORD Index;
    DWORD NumberOfNets;
    DWORD   i;

    HKEY AdapterKeyHandle = NULL;
    LPWSTR IpAddressString = NULL;
    LPWSTR SubnetMaskString = NULL;

    QuickBindAddresses = QuickBindMasks = NULL;
    nQuickBindAddresses = 0;

    //
    // open linkage key in the to determine the the nets we are bound
    // to.
    //

    Error = RegOpenKeyEx(
                DhcpGlobalRegRoot,
                DHCP_PARAM_KEY,
                0,
                DHCP_KEY_ACCESS,
                &LinkageKeyHandle );

    if( Error != ERROR_SUCCESS ) {
         goto Cleanup;
    }

    //
    // read BIND value.
    //

    Error =  DhcpRegGetValue(
                LinkageKeyHandle,
                DHCP_QUICK_BIND_VALUE,
                DHCP_QUICK_BIND_VALUE_TYPE,
                (LPBYTE)&BindString );

    if( Error != ERROR_SUCCESS ) {
         goto Cleanup;
    }

    //
    // determine number of string in BindStrings, that many NETs are
    // bound.
    //

    StringPtr = BindString;
    NumberOfNets = 0;
    while( (StringLen = wcslen(StringPtr)) != 0) {

        //
        // found another NET.
        //

        NumberOfNets++;

        TmpString = wcschr(StringPtr, L' ');
        if( NULL != TmpString ) {
            *TmpString = L'\0';
            NumberOfNets ++;
        }

        StringPtr += (StringLen + 1); // move to next string.
    }

    if((NumberOfNets % 2)) { // ODD # is not possible.
        DhcpPrint((DEBUG_ERRORS, "Format of QuickBind value is incorrect. Has Odd subnets.\n"));
        // Some random error... does not matter which.
        Error = ERROR_PATH_NOT_FOUND;
        goto Cleanup;
    }

    NumberOfNets /= 2; // the network has a pair of address: ip addr, subnet mask.

    //
    // allocate memory for the QuickBindAddresses array
    //

    QuickBindAddresses = DhcpAllocateMemory ( NumberOfNets * sizeof(*QuickBindAddresses));
    QuickBindMasks = DhcpAllocateMemory ( NumberOfNets * sizeof(*QuickBindMasks));

    if( NULL == QuickBindAddresses || NULL == QuickBindMasks ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // enum the NETs.
    //

    StringPtr = BindString,
    nQuickBindAddresses = NumberOfNets;

    for(Index = 0, StringPtr = BindString;
            ((StringLen = wcslen(StringPtr)) != 0);
                Index++, StringPtr += (StringLen + 1) ) {

        CHAR OemString[ DHCP_IP_KEY_LEN ];
        LPSTR OemStringPtr;
        DWORD EnableDHCPFlag;

        // read IpAddress and SubnetMask.
        //

        IpAddressString = StringPtr;
        StringPtr += StringLen +1;
        SubnetMaskString = StringPtr;
        StringLen = wcslen(StringPtr);


        //
        // we found another net we can work on.
        //

        OemStringPtr = DhcpUnicodeToOem( IpAddressString, OemString);

        if( 0 == inet_addr( OemStringPtr ) ) {
            Error = ERROR_BAD_FORMAT;
            goto Cleanup;
        }

        QuickBindAddresses[Index] = inet_addr(OemStringPtr);

        OemStringPtr = DhcpUnicodeToOem( SubnetMaskString, OemString);

        if( 0 == inet_addr( OemStringPtr ) ) {
            Error = ERROR_BAD_FORMAT;
            goto Cleanup;
        }

        QuickBindMasks[Index] = inet_addr(OemStringPtr);

        if( 0 == (QuickBindAddresses[Index] & QuickBindMasks[Index]) ) {
            Error = ERROR_BAD_FORMAT;
            goto Cleanup;
        }

        IpAddressString = NULL;
        SubnetMaskString = NULL;
    }

Cleanup:

    if( LinkageKeyHandle != NULL ) {
        RegCloseKey( LinkageKeyHandle );
    }

    if( BindString != NULL ) {
        MIDL_user_free( BindString );
    }

    if( Error != ERROR_SUCCESS ) {

        if( NULL != QuickBindAddresses ) DhcpFreeMemory(QuickBindAddresses);
        if( NULL != QuickBindMasks ) DhcpFreeMemory(QuickBindMasks);
        QuickBindAddresses = QuickBindMasks = NULL;
        nQuickBindAddresses = 0;

        DhcpPrint(( DEBUG_INIT,
            "Couldn't initialize Endpoint List, %ld.\n",
                Error ));
    }

    return( Error );
}

// OLD
DWORD
DhcpRegDeleteKey(
    HKEY ParentKeyHandle,
    LPWSTR KeyName
    )
/*++

Routine Description:

    This function deletes the specified key and all its subkeys.

Arguments:

    ParentKeyHandle : handle of the parent key.

    KeyName : name of the key to be deleted.

Return Value:

    Registry Errors.

--*/
{
    DWORD Error;
    HKEY KeyHandle = NULL;
    DHCP_KEY_QUERY_INFO QueryInfo;


    //
    // open key.
    //

    Error = RegOpenKeyEx(
                ParentKeyHandle,
                KeyName,
                0,
                DHCP_KEY_ACCESS,
                &KeyHandle );

    if ( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // query key info.
    //

    Error = DhcpRegQueryInfoKey(
                KeyHandle,
                &QueryInfo );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // delete all its subkeys if they exist.
    //

    if( QueryInfo.NumSubKeys != 0 ) {
        DWORD Index;
        DWORD KeyLength;
        WCHAR KeyBuffer[100];
        FILETIME KeyLastWrite;

        for(Index = 0;  Index < QueryInfo.NumSubKeys ; Index++ ) {

            //
            // read next subkey name.
            //
            // Note : specify '0' as index each time, since  deleting
            // first element causes the next element as first
            // element after delete.
            //

            KeyLength = sizeof(KeyBuffer)/sizeof(WCHAR);
            Error = RegEnumKeyEx(
                KeyHandle,
                0,                  // index.
                KeyBuffer,
                &KeyLength,
                0,                  // reserved.
                NULL,               // class string not required.
                0,                  // class string buffer size.
                &KeyLastWrite );
            
            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }

            //
            // delete this key recursively.
            //

            Error = DhcpRegDeleteKey(
                KeyHandle,
                KeyBuffer );
            
            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }
        }
    }

    //
    // close the key before delete.
    //

    RegCloseKey( KeyHandle );
    KeyHandle = NULL;

    //
    // at last delete this key.
    //

    Error = RegDeleteKey( ParentKeyHandle, KeyName );

Cleanup:

    if( KeyHandle == NULL ) {
        RegCloseKey( KeyHandle );
    }

    return( Error );
}

DWORD
DhcpGetBindingList(
    LPWSTR  *bindingList
    )
/*++

Routine Description:


Arguments:

    none.

Return Value:

    Registry Error.

--*/
{
    DWORD Error;

    HKEY LinkageKeyHandle = NULL;

    //
    // open linkage key in the to determine the the nets we are bound
    // to.
    //

    Error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TCPIP_LINKAGE_KEY,
                0,
                DHCP_KEY_ACCESS,
                &LinkageKeyHandle );

    if( Error != ERROR_SUCCESS ) {
         goto Cleanup;
    }

    //
    // read BIND value.
    //

    Error =  DhcpRegGetValue(
                LinkageKeyHandle,
                DHCP_BIND_VALUE,
                DHCP_BIND_VALUE_TYPE,
                (LPBYTE)bindingList);

    if( Error != ERROR_SUCCESS ) {
         goto Cleanup;
    }

Cleanup:
    if( LinkageKeyHandle != NULL ) {
        RegCloseKey( LinkageKeyHandle );
    }


    return Error;

}

DWORD
DhcpOpenInterfaceByName(
    IN LPCWSTR InterfaceName,
    OUT HKEY *Key
    )
/*++

Routine Description:
    This routine opens the tcpip\parameters\interfaces\ key for the
    specified interface.

Arguments:
    InterfaceName -- name of interface
    Key -- return value variable to fill with key handle

Return Value:
    Win32 errors

--*/
{
    WCHAR AdapterParamKey[
        sizeof(SERVICES_KEY) + sizeof(ADAPTER_TCPIP_PARMS_KEY)
        + DHCP_IP_KEY_LEN * 8
        ];

    AdapterParamKey[ 0 ] = L'\0';

    if ( ( wcslen( SERVICES_KEY ) + wcslen( ADAPTER_TCPIP_PARMS_KEY ) + wcslen( InterfaceName ) ) < ( sizeof( AdapterParamKey )/sizeof( AdapterParamKey[ 0 ] ) ))
    {
        wcscpy( AdapterParamKey, SERVICES_KEY);
        wcscat( AdapterParamKey, ADAPTER_TCPIP_PARMS_KEY );
        wcscat( AdapterParamKey, InterfaceName);
    }

    return RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        AdapterParamKey,
        0,
        DHCP_KEY_ACCESS,
        Key
        );    
}

DWORD
DhcpOpenAdapterConfigKey(
    LPWSTR  AdapterStr,
    HKEY *AdapterKeyHandle
    )
/*++

Routine Description:
    Opens the registry key handle for the given adapter string.
    (the string is expected to have a prefix given by
    ADAPTER_TCPIP_PREFIX )

Arguments:
    AdapterStr -- string name as found in bindings key.
    AdapterKeyHandle -- the handle to return.
    
Return Value:
    Registry Error.

--*/
{
    return DhcpOpenInterfaceByName(
        AdapterStr + wcslen( ADAPTER_TCPIP_PREFIX ),
        AdapterKeyHandle
        );
}



BOOL
IsAdapterStaticIP(
    HKEY AdapterKeyHandle
    )
/*++

Routine Description:


Arguments:

    none.

Return Value:

    Registry Error.

--*/
{
    DWORD Error, EnableDHCPFlag;
    //
    // read DHCPEnableFlag.
    //


    Error =  DhcpRegGetValue(
                AdapterKeyHandle,
                DHCP_NET_DHCP_ENABLE_VALUE,
                DHCP_NET_DHCP_ENABLE_VALUE_TYPE,
                (LPBYTE)&EnableDHCPFlag );

    if( Error == ERROR_SUCCESS ) {

        //
        // if DHCP is enabled on this cord, we can't do DHCP server
        // functionality, so ignore this adapter.
        //

        if( EnableDHCPFlag ) {

            return FALSE;
        }
    }
    return TRUE;
}

BOOL
IsAdapterBoundToDHCPServer(
    HKEY AdapterKeyHandle
    )
/*++

Routine Description:
    This routine checks to see if the given adapter is bound to 
    DHCP Server or not by looking at a registry variable..

Arguments:
    AdapterKeyHandle -- key to search for

Return Value:
    TRUE indicates the adapter is bound, FALSE indicates not bound

--*/
{
    DWORD Error, EnableFlag;

    //
    // read "BindToDHCPServer" flag
    //

    Error =  DhcpRegGetValue(
        AdapterKeyHandle,
        DHCP_NET_BIND_DHCDSERVER_FLAG_VALUE,
        DHCP_NET_BIND_DHCPSERVER_FLAG_VALUE_TYPE,
        (LPBYTE)&EnableFlag 
        );

    //
    // If this flag is non-zero, then bind.. else don't bind.
    // 
    //

    return (ERROR_SUCCESS == Error && EnableFlag != 0 );
}

DWORD
SetBindingToDHCPServer(
    HKEY AdapterKeyHandle,
    BOOL fBind
    )
/*++

Routine Description:
    This routine sets the binding information for the dhcp server..

Arguments:
    AdapterKeyHandle -- key to use to store bind info
    fBind -- TRUE indicates the adapter is bound, FALSE indicates not bound

Return Values:
    Win32 errors

--*/
{
    DWORD Error, EnableFlag;

    EnableFlag = (fBind)?1:0;

    return RegSetValueEx(
        AdapterKeyHandle,
        DHCP_NET_BIND_DHCDSERVER_FLAG_VALUE,
        0,
        DHCP_NET_BIND_DHCPSERVER_FLAG_VALUE_TYPE,
        (LPBYTE)&EnableFlag,
        sizeof(EnableFlag)
        );

}


DWORD
DhcpGetAdapterIPAddr(
    HKEY AdapterKeyHandle,
    DHCP_IP_ADDRESS *IpAddress,
    DHCP_IP_ADDRESS *SubnetMask,
    DHCP_IP_ADDRESS *SubnetAddress

    )
/*++

Routine Description:


Arguments:

    none.

Return Value:

    Registry Error.

--*/
{
    DWORD Error;
    CHAR OemString[ DHCP_IP_KEY_LEN ];
    LPSTR OemStringPtr;
    LPWSTR IpAddressString = NULL;
    LPWSTR SubnetMaskString = NULL;

    //
    // read IpAddress and SubnetMask.
    //

    Error =  DhcpRegGetValue(
        AdapterKeyHandle,
        DHCP_NET_IPADDRESS_VALUE,
        DHCP_NET_IPADDRESS_VALUE_TYPE,
        (LPBYTE)&IpAddressString );

    if( Error != ERROR_SUCCESS ) {
         goto Cleanup;
    }

    Error =  DhcpRegGetValue(
        AdapterKeyHandle,
        DHCP_NET_SUBNET_MASK_VALUE,
        DHCP_NET_SUBNET_MASK_VALUE_TYPE,
        (LPBYTE)&SubnetMaskString );

    if( Error != ERROR_SUCCESS ) {
         goto Cleanup;
    }

    //
    // we found another net we can work on.
    //

    OemStringPtr = DhcpUnicodeToOem( IpAddressString, OemString);
    *IpAddress = inet_addr( OemStringPtr );

    //
    // add this adpter to the list only if the ip address is
    // non-zero.
    //

    if ( *IpAddress != 0 ) {

        OemStringPtr = DhcpUnicodeToOem( SubnetMaskString, OemString);
        *SubnetMask = inet_addr( OemStringPtr );

        *SubnetAddress = *IpAddress & *SubnetMask;

    }

Cleanup:

    MIDL_user_free( IpAddressString );
    IpAddressString = NULL;

    MIDL_user_free( SubnetMaskString );
    SubnetMaskString = NULL;

    return Error;
} // DhcpGetAdapterIPAddr()

BOOL                                    //  TRUE ==> IpAddress has been matched
QuickBindableAddressExists(             //  Check if one of the qbind addresses is in IpString
    IN      LPWSTR       IpString,      //  MultiSz string of ip addresses
    IN      LPWSTR       MaskString,    //  MultiSZ string of subnet masks
    OUT     LPDWORD      IpAddress,     //  Output ip address chosen
    OUT     LPDWORD      SubnetMask     //  Output subnet mask chosen
)
{
    DWORD                i;
    CHAR                 OemString[ DHCP_IP_KEY_LEN ];
    LPSTR                OemStringPtr;
    DHCP_IP_ADDRESS      Addr;

    if( !nQuickBindAddresses ) {        //  If there are no quick bind addresses
        return FALSE;                   //  Then return FALSE ==> no matches found
    }
    
    while( wcslen(IpString) ) {
        OemStringPtr = DhcpUnicodeToOem( IpString, OemString );
        if( NULL == OemStringPtr ) {
            DhcpPrint((DEBUG_ERRORS, "Could not convert %ws to OEM\n", IpString));
            IpString += wcslen(IpString) + 1;
            MaskString += wcslen(MaskString) + 1;
            continue;
        }
        Addr = inet_addr(OemStringPtr);
        for( i = 0 ; i < nQuickBindAddresses ; i ++ )
            if( Addr == QuickBindAddresses[i] )
                break;
        if( i >= nQuickBindAddresses ) {
            IpString += wcslen(IpString) + 1;
            MaskString += wcslen(MaskString) + 1;
            continue;
        }

        OemStringPtr = DhcpUnicodeToOem(MaskString, OemString);
        if( NULL == OemStringPtr ) {
            DhcpPrint((DEBUG_ERRORS, "Could not convert %ws to OEM\n", MaskString));
            Addr = QuickBindMasks[i];
        } else {
            Addr = inet_addr(OemStringPtr);
        }

        if( Addr != QuickBindMasks[i] ){//  This should not happen: Mis configuration
            DhcpPrint((DEBUG_ERRORS, "Mask mismatch: WSOCK: %x, QBIND: %x\n",
                       Addr, QuickBindMasks[i]));
        }
        *IpAddress = QuickBindAddresses[i];
        *SubnetMask = QuickBindMasks[i];//  Trust the qBind info over wsock? Maybe some hack..
        return TRUE;
    }
    return FALSE;
} // QuickBindableAddressExists()

//  This function chooses either the first ip address of the card, or the quickbind ip
//  address for the card, preferring the latter.
DWORD
DhcpGetAdapterIPAddrQuickBind(
    HKEY             AdapterKeyHandle,
    DHCP_IP_ADDRESS *IpAddress,
    DHCP_IP_ADDRESS *SubnetMask,
    DHCP_IP_ADDRESS *SubnetAddress
) {
    DWORD Error;
    CHAR OemString[ DHCP_IP_KEY_LEN ];
    LPSTR OemStringPtr;
    LPWSTR IpAddressString = NULL;
    LPWSTR SubnetMaskString = NULL;
    BOOL             Status;

    //
    // read IpAddress and SubnetMask.
    //

    Error =  DhcpRegGetValue(
                AdapterKeyHandle,
                DHCP_NET_IPADDRESS_VALUE,
                DHCP_NET_IPADDRESS_VALUE_TYPE,
                (LPBYTE)&IpAddressString );

    if( Error != ERROR_SUCCESS ) {
         goto Cleanup;
    }

    Error =  DhcpRegGetValue(
                AdapterKeyHandle,
                DHCP_NET_SUBNET_MASK_VALUE,
                DHCP_NET_SUBNET_MASK_VALUE_TYPE,
                (LPBYTE)&SubnetMaskString );

    if( Error != ERROR_SUCCESS ) {
         goto Cleanup;
    }

    //
    // we found another net we can work on.
    //

    Status = QuickBindableAddressExists(
        IpAddressString,
        SubnetMaskString,
        IpAddress,
        SubnetMask
    );

    if( Status ) {
        *SubnetAddress = *IpAddress & *SubnetMask ;
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    OemStringPtr = DhcpUnicodeToOem( IpAddressString, OemString);
    *IpAddress = inet_addr( OemStringPtr );

    //
    // add this adpter to the list only if the ip address is
    // non-zero.
    //

    if ( *IpAddress != 0 ) {

        OemStringPtr = DhcpUnicodeToOem( SubnetMaskString, OemString);
        *SubnetMask = inet_addr( OemStringPtr );

        *SubnetAddress = *IpAddress & *SubnetMask;

    }

Cleanup:

    MIDL_user_free( IpAddressString );
    IpAddressString = NULL;

    MIDL_user_free( SubnetMaskString );
    SubnetMaskString = NULL;

    return Error;
}


//
//  This function coverts the unicode string (or what ever is stored in
//  the registry) to ASCII. Change it so it is nolonger needed.
//
DWORD
DhcpRegGetExpandValue(
    LPWSTR KeyName,
    DWORD KeyType,
    LPSTR *RetExpandPath
)
{

    DWORD Error;
    LPWSTR Path = NULL;
    LPSTR OemPath = NULL;
    DWORD PathLength;
    DWORD Length;
    LPSTR ExpandPath = NULL;
    LPWSTR ExpandWidePath = NULL;

    *RetExpandPath = NULL;

    Error = DhcpRegGetValue(
                DhcpGlobalRegParam,
                KeyName,
                KeyType,
                (LPBYTE)&Path );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    OemPath = DhcpUnicodeToOem( Path, NULL ); // allocate memory.

    if( OemPath == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    PathLength = strlen( OemPath ) + MAX_PATH + 1;

    ExpandPath = DhcpAllocateMemory( PathLength );
    if( ExpandPath == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    if ( ( wcscmp( KeyName, DHCP_DB_PATH_VALUE ) == 0 ) || 
         ( wcscmp( KeyName, DHCP_BACKUP_PATH_VALUE ) == 0 ) )
    {
        ExpandWidePath = DhcpAllocateMemory( PathLength * sizeof( WCHAR ) );
        if ( ExpandWidePath == NULL )
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        Length = ExpandEnvironmentStringsW( Path, ExpandWidePath, PathLength );
        if ( ( Length == 0 ) || ( Length > PathLength ) )
        {
            if ( Length == 0 )
            {
                Error = GetLastError( );
            }
            else
            {
                Error = ERROR_META_EXPANSION_TOO_LONG;
            }
            goto Cleanup;
        }

        Error = RegSetValueEx( DhcpGlobalRegParam,
                               KeyName,
                               0,
                               KeyType,
                               (LPBYTE)ExpandWidePath,
                               ( wcslen( ExpandWidePath ) + 1 ) * sizeof( WCHAR ) );

        if ( Error != ERROR_SUCCESS )
            goto Cleanup;
   
    }

    Length = ExpandEnvironmentStringsA( OemPath, ExpandPath, PathLength );

    DhcpAssert( Length <= PathLength );
    if( (Length == 0) || (Length > PathLength) ) {

        if( Length == 0 ) {
            Error = GetLastError();
        }
        else {
            Error = ERROR_META_EXPANSION_TOO_LONG;
        }

        goto Cleanup;
    }

    *RetExpandPath = ExpandPath;
    ExpandPath = NULL;

Cleanup:

    if( Path != NULL ) {
        DhcpFreeMemory( Path );
    }

    if( OemPath != NULL ) {
        DhcpFreeMemory( OemPath );
    }

    if( ExpandPath != NULL ) {
        DhcpFreeMemory( ExpandPath );
    }

    if ( ExpandWidePath != NULL ) {
        DhcpFreeMemory( ExpandWidePath );
    }

    return( Error );
}

#define VAL_REQD   0x01
#define VAL_EXPAND 0x02

ULONG DbType, Use351Db, EnableDynBootp;
LPWSTR DatabaseName;

struct {
    LPTSTR ValueName;
    ULONG ValueType;
    PVOID ResultBuf;
    ULONG Flags;
    ULONG dwDefault;
} RegParamsArray[] = {
    // 
    // Flags, Name, Type, ResultPtr, DEFAULT value if DWORD
    //
    DHCP_API_PROTOCOL_VALUE, DHCP_API_PROTOCOL_VALUE_TYPE, 
    &DhcpGlobalRpcProtocols, VAL_REQD, 0,

    DHCP_DB_PATH_VALUE, DHCP_DB_PATH_VALUE_TYPE, 
    &DhcpGlobalOemDatabasePath, VAL_REQD|VAL_EXPAND, 0,

    DHCP_BACKUP_PATH_VALUE, DHCP_BACKUP_PATH_VALUE_TYPE, 
    &DhcpGlobalOemBackupPath, VAL_EXPAND, 0,
    
    DHCP_RESTORE_PATH_VALUE, DHCP_RESTORE_PATH_VALUE_TYPE,  // RestoreDatabasePath
    &DhcpGlobalOemRestorePath, VAL_EXPAND, 0,

    DHCP_DB_NAME_VALUE, DHCP_DB_NAME_VALUE_TYPE, 
    &DatabaseName, VAL_REQD, 0,

    DHCP_DB_DOOM_TIME_VALUE, DHCP_DB_DOOM_TIME_VALUE_TYPE,
    &DhcpLeaseExtension, 0, DHCP_LEASE_EXTENSION,
    
    DHCP_BACKUP_INTERVAL_VALUE, DHCP_BACKUP_INTERVAL_VALUE_TYPE, 
    &DhcpGlobalBackupInterval,0, (DEFAULT_BACKUP_INTERVAL/60000),

    DHCP_DB_LOGGING_FLAG_VALUE, DHCP_DB_LOGGING_FLAG_VALUE_TYPE, 
    &DhcpGlobalDatabaseLoggingFlag, 0, DEFAULT_LOGGING_FLAG,

    DHCP_AUDIT_LOG_FLAG_VALUE, DHCP_AUDIT_LOG_FLAG_VALUE_TYPE,
    &DhcpGlobalAuditLogFlag, 0, DEFAULT_AUDIT_LOG_FLAG,

    DHCP_AUDIT_LOG_MAX_SIZE_VALUE, DHCP_AUDIT_LOG_MAX_SIZE_VALUE_TYPE,
    &DhcpGlobalAuditLogMaxSizeInBytes, 0, DEFAULT_AUDIT_LOG_MAX_SIZE,

    DHCP_DETECT_CONFLICT_RETRIES_VALUE, DHCP_DETECT_CONFLICT_RETRIES_VALUE_TYPE,
    &DhcpGlobalDetectConflictRetries, 0, DEFAULT_DETECT_CONFLICT_RETRIES,

    DHCP_RESTORE_FLAG_VALUE, DHCP_RESTORE_FLAG_VALUE_TYPE, 
    &DhcpGlobalRestoreFlag, 0, DEFAULT_RESTORE_FLAG,

    DHCP_DB_CLEANUP_INTERVAL_VALUE, DHCP_DB_CLEANUP_INTERVAL_VALUE_TYPE,
    &DhcpGlobalCleanupInterval, 0, (DHCP_DATABASE_CLEANUP_INTERVAL/60000),

    DHCP_MESSAGE_QUEUE_LENGTH_VALUE, DHCP_MESSAGE_QUEUE_LENGTH_VALUE_TYPE,
    &DhcpGlobalMessageQueueLength, 0, DHCP_RECV_QUEUE_LENGTH,

#if DBG
    DHCP_DEBUG_FLAG_VALUE, DHCP_DEBUG_FLAG_VALUE_TYPE,
    &DhcpGlobalDebugFlag, 0, 0,

    DHCP_PROCESS_INFORMS_ONLY_FLAG, DHCP_PROCESS_INFORMS_ONLY_FLAG_TYPE,
    &fDhcpGlobalProcessInformsOnlyFlag, 0, FALSE,

    DHCP_GLOBAL_SERVER_PORT, DHCP_GLOBAL_SERVER_PORT_TYPE,
    &DhcpGlobalServerPort, 0, DHCP_SERVR_PORT, 

    DHCP_GLOBAL_CLIENT_PORT, DHCP_GLOBAL_CLIENT_PORT_TYPE,
    &DhcpGlobalClientPort, 0, DHCP_CLIENT_PORT,
    
#endif DBG

    DHCP_USE351DB_FLAG_VALUE, DHCP_USE351DB_FLAG_VALUE_TYPE,
    &Use351Db, 0, 0,

    DHCP_DBTYPE_VALUE, DHCP_DBTYPE_VALUE_TYPE,
    &DbType, 0, 5,

    DHCP_IGNORE_BROADCAST_FLAG_VALUE, DHCP_IGNORE_BROADCAST_VALUE_TYPE,
    &DhcpGlobalIgnoreBroadcastFlag, 0, TRUE,

    DHCP_MAX_PROCESSING_THREADS_VALUE, DHCP_MAX_PROCESSING_THREADS_TYPE,
    &g_cMaxProcessingThreads, 0, 0xFFFFFFFF,

    DHCP_MAX_ACTIVE_THREADS_VALUE, DHCP_MAX_ACTIVE_THREADS_TYPE,
    &g_cMaxActiveThreads, 0, 0xFFFFFFFF,

    DHCP_PING_TYPE_VALUE, DHCP_PING_TYPE_TYPE,
    &DhcpGlobalPingType, 0, DHCP_DEFAULT_PING_TYPE,

    DHCP_ALERT_PERCENTAGE_VALUE, DHCP_ALERT_PERCENTAGE_VALUE_TYPE,
    &DhcpGlobalAlertPercentage, 0, DHCP_DEFAULT_ALERT_PERCENTAGE,

    DHCP_ALERT_COUNT_VALUE, DHCP_ALERT_COUNT_VALUE_TYPE,
    &DhcpGlobalAlertCount, 0, DHCP_DEFAULT_ALERT_COUNT,

    DHCP_ROGUE_LOG_EVENTS, DHCP_ROGUE_LOG_EVENTS_TYPE,
    &DhcpGlobalRogueLogEventsLevel, 0, DHCP_DEFAULT_ROGUE_LOG_EVENTS_LEVEL,

    DHCP_ENABLE_DYNBOOTP, DHCP_ENABLE_DYNBOOTP_TYPE,
    &EnableDynBootp, 0, 1,

    DHCP_CLOCK_SKEW_ALLOWANCE, DHCP_CLOCK_SKEW_ALLOWANCE_TYPE,
    &DhcpGlobalClockSkewAllowance, 0, CLOCK_SKEW_ALLOWANCE,

    DHCP_EXTRA_ALLOCATION_TIME, DHCP_EXTRA_ALLOCATION_TIME_TYPE,
    &DhcpGlobalExtraAllocationTime, 0, EXTRA_ALLOCATION_TIME,
    
    // S E N T I N E L
    NULL, 0, NULL, 0, 0
};

struct {
    HKEY *KeyBase;
    LPTSTR KeyName;
    HKEY *Key;
} ReadKeyArray[] = {
    NULL, DHCP_ROOT_KEY, &DhcpGlobalRegRoot,
    NULL, DHCP_SWROOT_KEY, &DhcpGlobalRegSoftwareRoot,
    &DhcpGlobalRegSoftwareRoot,  DHCP_CONFIG_KEY, &DhcpGlobalRegConfig,
    &DhcpGlobalRegRoot,  DHCP_PARAM_KEY, &DhcpGlobalRegParam,
    &DhcpGlobalRegConfig, DHCP_SUBNETS_KEY, &DhcpGlobalRegSubnets,
    &DhcpGlobalRegConfig, DHCP_MSCOPES_KEY, &DhcpGlobalRegMScopes,
    &DhcpGlobalRegConfig, DHCP_OPTION_INFO_KEY, &DhcpGlobalRegOptionInfo,
    &DhcpGlobalRegConfig, DHCP_GLOBAL_OPTIONS_KEY, &DhcpGlobalRegGlobalOptions,
    &DhcpGlobalRegConfig, DHCP_SUPERSCOPE_KEY, &DhcpGlobalRegSuperScope,
    
    // S E N T I N E L
    NULL, NULL, NULL
};

ULONG
OpenGlobalRegKeys(
    VOID
)
/*++

Routine Description

    This routine opens the list of keys as specified in the ReadKeyArray
    structure above.  Each key is attempted to be created/opened and if 
    that fails for some reason, then the routine returns the error

    The routine is atomic -- in case of failure all the keys are closed.

Return Value

    Registry Errors

--*/
{
    ULONG i, Error, KeyDisposition;

    Error = ERROR_SUCCESS;
    for( i = 0 ; NULL !=  ReadKeyArray[i].Key ; i ++ ) {
        Error = DhcpRegCreateKey(
            ( (NULL == ReadKeyArray[i].KeyBase) ? 
              HKEY_LOCAL_MACHINE : *(ReadKeyArray[i].KeyBase) ),
            ReadKeyArray[i].KeyName,
            ReadKeyArray[i].Key,
            &KeyDisposition
            );

        if( ERROR_SUCCESS != Error ) break;
    }

    if( ERROR_SUCCESS == Error ) return ERROR_SUCCESS;

    DhcpPrint((DEBUG_ERRORS, "RegCreateKeyEx(%ws): %ld\n", 
               ReadKeyArray[i].KeyName, Error));
    while ( i != 0 ) {
        i --;

        RegCloseKey( *(ReadKeyArray[i].Key) );
        *(ReadKeyArray[i].Key) = NULL;
    }

    return Error;
}

VOID
CloseGlobalRegKeys(
    VOID
)
/*++

Routine Description

   This routine undoes the effect of the previous routine.
   It closes any open key handles in the array.

--*/
{
    ULONG i;

    for(i = 0; NULL != ReadKeyArray[i].Key ; i ++ ) {
        if( NULL != *(ReadKeyArray[i].Key) 
            && INVALID_HANDLE_VALUE != *(ReadKeyArray[i].Key) ) {
            RegCloseKey( *(ReadKeyArray[i].Key) );
            *(ReadKeyArray[i].Key) = NULL;
        }
    }
}

BOOL
InterfaceInBindList(
    IN LPCWSTR If,
    IN LPCWSTR BindList
    )
/*++

Routine Description:
    This routine makes a quick check to see if a given interface
    is present in the BIND list or not..

Return Values:
    TRUE -- yes
    FALSE -- no

--*/
{
    for(; wcslen(BindList) != 0; BindList += wcslen(BindList)+1 ) {
        LPWSTR IfString = wcsrchr(BindList, DHCP_KEY_CONNECT_CHAR);
        if( NULL == IfString ) continue;
        IfString ++;
        
        if( 0 == wcscmp(If, IfString) ) return TRUE;
    }
    return FALSE;
}        

DWORD
DhcpInitializeRegistry(
    VOID
    )
/*++

Routine Description:

    This function initializes DHCP registry information when the
    service boots. 
    
    Also creates the directories specified for various paths if they
    are not already created.

Arguments:

    none.

Return Value:

    Registry Errors.

--*/
{
    ULONG i, Error, Tmp;
    BOOL BoolError;

    DatabaseName = NULL;

    //
    // Create/Open Registry keys.
    //

    Error = OpenGlobalRegKeys();
    if( ERROR_SUCCESS != Error ) goto Cleanup;

    //
    // Read in the quick bind information for Wolfpack
    //

    Error = DhcpRegFillQuickBindInfo();
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "Fill QuickBindInfo : %ld\n", Error ));
        Error = ERROR_SUCCESS;
    }

    //
    // Init reg parameters..
    //
    DhcpGlobalOemBackupPath = NULL;
    DhcpGlobalOemRestorePath = NULL;
    
    //
    // read registry parameters.
    //

    for( i = 0 ; NULL != RegParamsArray[i].ValueName ; i ++ ) {
        if( RegParamsArray[i].Flags & VAL_EXPAND ) {
            Error = DhcpRegGetExpandValue(
                RegParamsArray[i].ValueName,
                RegParamsArray[i].ValueType,
                RegParamsArray[i].ResultBuf
                );
            if( ERROR_SUCCESS != Error && ERROR_FILE_NOT_FOUND != Error ) {
                DhcpPrint((DEBUG_ERRORS, "RegGetExpandValue(%ws):%ld\n",
                           RegParamsArray[i].ValueName, Error));
                goto Cleanup;
            }
        } else {
            Error = DhcpRegGetValue(
                DhcpGlobalRegParam,
                RegParamsArray[i].ValueName,
                RegParamsArray[i].ValueType,
                RegParamsArray[i].ResultBuf
                );
        }

        if( ERROR_SUCCESS != Error ) {
            if( VAL_REQD & (RegParamsArray[i].Flags ) ) {
                DhcpPrint((DEBUG_ERRORS, "Value: %ws, Error %ld\n",
                           RegParamsArray[i].ValueName, Error ));
                goto Cleanup;
            } else if( REG_DWORD == RegParamsArray[i].ValueType ) {
                *((PULONG)RegParamsArray[i].ResultBuf) = RegParamsArray[i].dwDefault;
            }
        }
    } // for i

    if( NULL == DhcpGlobalOemBackupPath ) {
        //
        // if the backup path is not specified, use database path +
        // "\backup".
        //
        
        DhcpGlobalOemBackupPath = DhcpAllocateMemory(
            strlen(DhcpGlobalOemDatabasePath) +
            strlen(DHCP_DEFAULT_BACKUP_PATH_NAME) + 1
            );
        
        if( NULL == DhcpGlobalOemBackupPath ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        strcpy( DhcpGlobalOemBackupPath, DhcpGlobalOemDatabasePath );
        strcat( DhcpGlobalOemBackupPath, DHCP_KEY_CONNECT_ANSI );
        strcat( DhcpGlobalOemBackupPath, DHCP_DEFAULT_BACKUP_PATH_NAME );
    }

    //
    // Create database directory if not there..
    //
    BoolError = CreateDirectoryPathOem(
        DhcpGlobalOemDatabasePath, DhcpGlobalSecurityDescriptor
        );
    Error = ( BoolError ? ERROR_SUCCESS : GetLastError() );
    if( ERROR_SUCCESS != Error && ERROR_ALREADY_EXISTS != Error ) {
	DhcpServerEventLog( EVENT_SERVER_DB_PATH_NOT_ACCESSIBLE,
			    EVENTLOG_ERROR_TYPE,
			    Error );
        DhcpPrint((DEBUG_ERRORS,
                   "Can't create database directory, %ld.\n", Error ));
        goto Cleanup;
    }

    //
    // create the backup directory if it is not there.
    //

    BoolError = CreateDirectoryPathOem(
        DhcpGlobalOemBackupPath, DhcpGlobalSecurityDescriptor
        );
    Error = ( BoolError ? ERROR_SUCCESS : GetLastError() );
    if( ERROR_SUCCESS != Error && ERROR_ALREADY_EXISTS != Error ) {

	DhcpServerEventLog( EVENT_SERVER_BACKUP_PATH_NOT_ACCESSIBLE,
			    EVENTLOG_ERROR_TYPE,
			    Error );

        DhcpPrint((DEBUG_ERRORS,
                   "Can't create backup directory, %ld.\n", Error ));
        goto Cleanup;
    }

    //
    // make jet backup path name.
    //

    DhcpGlobalOemJetBackupPath = DhcpAllocateMemory(
        strlen(DhcpGlobalOemBackupPath)
        + strlen(DHCP_KEY_CONNECT_ANSI)
        + strlen(DHCP_JET_BACKUP_PATH) + 1
        );
    
    if( DhcpGlobalOemJetBackupPath == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    strcpy( DhcpGlobalOemJetBackupPath, DhcpGlobalOemBackupPath );
    strcat( DhcpGlobalOemJetBackupPath, DHCP_KEY_CONNECT_ANSI );
    strcat( DhcpGlobalOemJetBackupPath, DHCP_JET_BACKUP_PATH );

    if( NULL != DhcpGlobalOemRestorePath ) {
        DhcpGlobalOemJetRestorePath = DhcpAllocateMemory(
            strlen(DhcpGlobalOemRestorePath)
            + strlen(DHCP_KEY_CONNECT_ANSI)
            + strlen(DHCP_JET_BACKUP_PATH) + 1
            );
    
        if( DhcpGlobalOemJetRestorePath == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        strcpy( DhcpGlobalOemJetRestorePath, DhcpGlobalOemRestorePath );
    } // if 
    
    //
    // create the JET backup directory if it is not there.
    //

    BoolError = CreateDirectoryPathOem(
        DhcpGlobalOemJetBackupPath, DhcpGlobalSecurityDescriptor
        );
    Error = ( BoolError ? ERROR_SUCCESS : GetLastError() );
    if( ERROR_SUCCESS != Error && ERROR_ALREADY_EXISTS != Error ) {
	DhcpServerEventLog( EVENT_SERVER_BACKUP_PATH_NOT_ACCESSIBLE,
			    EVENTLOG_ERROR_TYPE,
			    Error );

        DhcpPrint(( DEBUG_ERRORS,
                    "Can't create JET backup directory, %ld.\n", Error ));
        goto Cleanup;
    }

    //
    // make backup configuration (full) file name.
    //

    DhcpGlobalBackupConfigFileName =  DhcpAllocateMemory(( 
        strlen(DhcpGlobalOemBackupPath)
        + wcslen(DHCP_KEY_CONNECT)
        + wcslen(DHCP_BACKUP_CONFIG_FILE_NAME) + 1  
        ) * sizeof(WCHAR) );

    if( DhcpGlobalBackupConfigFileName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // convert oem path to unicode path.
    //

    DhcpGlobalBackupConfigFileName =  DhcpOemToUnicode(
        DhcpGlobalOemBackupPath,
        DhcpGlobalBackupConfigFileName 
        );

    DhcpAssert( DhcpGlobalBackupConfigFileName != NULL );

    //
    // add file name.
    //

    wcscat( DhcpGlobalBackupConfigFileName, DHCP_KEY_CONNECT );
    wcscat( DhcpGlobalBackupConfigFileName, DHCP_BACKUP_CONFIG_FILE_NAME );

    DhcpGlobalOemDatabaseName = DhcpUnicodeToOem(
        DatabaseName, NULL 
        );

    if( DhcpGlobalOemDatabaseName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Upgrade from old fmt to new fmt..
    //
    CloseGlobalRegKeys();
    
    Error = DhcpUpgradeConfiguration();
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "Upgrade registry failed: 0x%lx\n",
                   Error));
        goto Cleanup;
    }

    Error = OpenGlobalRegKeys();
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "Registry reopen failed: 0x%lx\n",
                   Error));
        goto Cleanup;
    }

    //
    // convert from mins to msecs.
    //

    Tmp = DhcpGlobalBackupInterval * 60000;
    if( 0 == Tmp || (Tmp / 60000) != DhcpGlobalBackupInterval ) {
        Tmp = DEFAULT_BACKUP_INTERVAL;
    }

    DhcpGlobalBackupInterval = Tmp;

    Tmp = DhcpGlobalCleanupInterval * 60000;
    if( 0 == Tmp || (Tmp / 60000) != DhcpGlobalCleanupInterval ) {
        Tmp = DHCP_DATABASE_CLEANUP_INTERVAL;
    }

    DhcpGlobalCleanupInterval = Tmp;

    //
    // validate
    //
    
    if( DhcpGlobalDetectConflictRetries > MAX_DETECT_CONFLICT_RETRIES ) {
        DhcpGlobalDetectConflictRetries = MAX_DETECT_CONFLICT_RETRIES;
    }

    DhcpGlobalDynamicBOOTPEnabled = (EnableDynBootp)? TRUE: FALSE;

    Error = ERROR_SUCCESS;

Cleanup:

    if( DatabaseName != NULL ) {
        MIDL_user_free( DatabaseName );
    }

    return(Error);
}



VOID
DhcpCleanupRegistry(
    VOID
    )
/*++

Routine Description:

    This function closes DHCP registry information when the service
    shuts down.

Arguments:

    none.

Return Value:

    Registry Errors.

--*/
{
    DWORD Error;

    //
    // perform a configuration backup when the service is manually
    // stopped. Don't perform this backup during system shutdown since
    // we will not have enough time to do so.
    //

    if ( !DhcpGlobalSystemShuttingDown &&
         NULL != DhcpGlobalBackupConfigFileName  ) {

        Error = DhcpBackupConfiguration( DhcpGlobalBackupConfigFileName );

        if( Error != ERROR_SUCCESS ) {

            DhcpServerEventLog(
                EVENT_SERVER_CONFIG_BACKUP,
                EVENTLOG_ERROR_TYPE,
                Error );

            DhcpPrint(( DEBUG_ERRORS,
                "DhcpBackupConfiguration failed, %ld.\n", Error ));
        }
    }

    if( DhcpGlobalRegSuperScope != NULL) {              // added by t-cheny:
        Error = RegCloseKey( DhcpGlobalRegSuperScope ); // superscope
        DhcpAssert( Error == ERROR_SUCCESS );
        DhcpGlobalRegSuperScope = NULL;
    }

    if( DhcpGlobalRegGlobalOptions != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegGlobalOptions );
        DhcpAssert( Error == ERROR_SUCCESS );
        DhcpGlobalRegGlobalOptions = NULL;
    }

    if( DhcpGlobalRegOptionInfo != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegOptionInfo );
        DhcpAssert( Error == ERROR_SUCCESS );
        DhcpGlobalRegOptionInfo = NULL;
    }

    if( DhcpGlobalRegSubnets != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegSubnets );
        DhcpAssert( Error == ERROR_SUCCESS );
        DhcpGlobalRegSubnets = NULL;
    }

    if( DhcpGlobalRegMScopes != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegMScopes );
        DhcpAssert( Error == ERROR_SUCCESS );
        DhcpGlobalRegMScopes = NULL;
    }

    if( DhcpGlobalRegParam != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegParam );
        DhcpAssert( Error == ERROR_SUCCESS );
        DhcpGlobalRegParam = NULL;
    }

    if( DhcpGlobalRegConfig != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegConfig );
        DhcpAssert( Error == ERROR_SUCCESS );
        DhcpGlobalRegConfig = NULL;
    }

    if( DhcpGlobalRegRoot != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegRoot );
        DhcpAssert( Error == ERROR_SUCCESS );
        DhcpGlobalRegRoot = NULL;
    }

    if( DhcpGlobalRegSoftwareRoot != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegSoftwareRoot );
        DhcpAssert( ERROR_SUCCESS == Error );
        DhcpGlobalRegSoftwareRoot = NULL;
    }
    
} // DhcpCleanupRegistry()

DWORD
DhcpSaveOrRestoreConfigToFile(
    IN HKEY hKey,
    IN LPWSTR ConfigFileName,
    IN BOOL fRestore
    )
/*++

Routine Description:
    This routine backs up or restores the dhcp configuration between
    the registry and the file.

Arguments:
    hKey -- key to backup or restore onto
    ConfigFileName -- file name to use to backup onto or restore from.
        This must be full path name.
    fRestore -- TRUE ==> do a restore from file; FALSE => do backup to
        file.

Return Values:
    Win32 errors...

--*/
{
    DWORD Error;
    BOOL fError;
    BOOLEAN WasEnable;
    NTSTATUS NtStatus;
    HANDLE ImpersonationToken;

    DhcpPrint((DEBUG_REGISTRY, "DhcpSaveOrRestoreConfigToFile called:"
               " %ws, 0x%lx\n", ConfigFileName, fRestore ));

    if( FALSE == fRestore ) {
        //
        // If backing up, delete the old file.
        //
        fError = DeleteFile( ConfigFileName );
        if(FALSE == fError ) {
            Error = GetLastError();
            if( ERROR_FILE_NOT_FOUND != Error &&
                ERROR_PATH_NOT_FOUND != Error ) {
                DhcpPrint((DEBUG_ERRORS, "Can't delete old "
                           "configuration file: 0x%ld\n", Error));
                DhcpAssert(FALSE);
                return Error;
            }
        }
    } // if not restore

    //
    // Impersonate to self.
    //
    NtStatus = RtlImpersonateSelf( SecurityImpersonation );
    if( !NT_SUCCESS(NtStatus) ) {

        DhcpPrint((DEBUG_ERRORS, "Impersonation failed: 0x%lx\n",
                   NtStatus));
        Error = RtlNtStatusToDosError( NtStatus );
        return Error;
    }
    
    NtStatus = RtlAdjustPrivilege(
        SE_BACKUP_PRIVILEGE,
        TRUE, // enable privilege
        TRUE, // adjust client token
        &WasEnable
        );
    if( !NT_SUCCESS (NtStatus ) ) {
        
        DhcpPrint((DEBUG_ERRORS, "RtlAdjustPrivilege: 0x%lx\n",
                   NtStatus ));
        Error = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }
    
    NtStatus = RtlAdjustPrivilege(
        SE_RESTORE_PRIVILEGE,
        TRUE, // enable privilege
        TRUE, // adjust client token
        &WasEnable
        );
    if( !NT_SUCCESS (NtStatus ) ) {

        DhcpPrint((DEBUG_ERRORS, "RtlAdjustPrivilege: 0x%lx\n",
                   NtStatus ));
        Error = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }
    
    //
    // Backup or restore appropriately.
    //
    
    if( FALSE == fRestore ) {
        Error = RegSaveKey( hKey, ConfigFileName, NULL );
    } else {
        Error = RegRestoreKey( hKey, ConfigFileName, REG_FORCE_RESTORE );
    }

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "Backup/Restore: 0x%lx\n", Error));
    }
    
    //
    // revert impersonation.
    //

Cleanup:
    
    ImpersonationToken = NULL;
    NtStatus = NtSetInformationThread(
        NtCurrentThread(),
        ThreadImpersonationToken,
        (PVOID)&ImpersonationToken,
        sizeof(ImpersonationToken)
        );
    if( !NT_SUCCESS(NtStatus ) ) {
        DhcpPrint((DEBUG_ERRORS, "NtSetInfo: 0x%lx\n", NtStatus));
        if( ERROR_SUCCESS == Error ) {
            Error = RtlNtStatusToDosError(NtStatus);
        }
    }
    
    return Error;
}

DWORD
DhcpSaveOrRestoreConfigToFileEx(
    IN LPWSTR KeyName,
    IN LPWSTR ConfigFileName,
    IN BOOL fRestore
    )
/*++

Routine Description:
    This is the same as DhcpSaveOrRestoreConfigToFile except that the
    required registry key is opened within this routine.

    See DhcpSaveOrRestoreConfigToFile for details.

--*/
{
    HKEY hKey;
    ULONG Error, KeyDisp;

    if( TRUE == fRestore ) {
        Error = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            KeyName,
            0,
            DHCP_CLASS,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &hKey,
            &KeyDisp
            );
    } else {
        Error = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            KeyName,
            0,
            DHCP_KEY_ACCESS,
            &hKey
            );
    }
    
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((
            DEBUG_ERRORS, "DhcpSaveOrRestoreConfigToFileEx: 0x%lx\n",
            Error));
        return Error;
    }

    Error = DhcpSaveOrRestoreConfigToFile(
        hKey, ConfigFileName, fRestore
        );

    RegCloseKey(hKey);
    return Error;
}

DWORD
DhcpRegDeleteKeyByName
(
    IN LPWSTR Parent,
    IN LPWSTR SubKey
)
{
    HKEY hKey;
    ULONG Error;
    
    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        Parent,
        0,
        DHCP_KEY_ACCESS,
        &hKey
        );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpRegDeleteKey(hKey, SubKey);
    RegCloseKey(hKey);

    return Error;
}
        
DWORD
DhcpUpgradeConfiguration(
    VOID
    )
/*++

Routine Description:
    This routine attempts to upgrade the registry key from 4.0
    location to Nt 5.0 location by doing the foll steps:
    1.  First attempt to save the current configuration key..
    2.  If key doesn't exist, done.  Else if success delete key.
    3.  If delete failed, restore key and return error. else
        restore key in new location and return error..

--*/
{
    ULONG Error;
    LPWSTR ConfigFileName = DhcpGlobalBackupConfigFileName;

    //
    // First save current configuration..
    //
    Error = DhcpSaveOrRestoreConfigToFileEx(
        DHCP_ROOT_KEY L"\\" DHCP_CONFIG_KEY,
        ConfigFileName,
        /* fRestore */ FALSE
        );
    if( ERROR_SUCCESS != Error ) {
        if( ERROR_FILE_NOT_FOUND == Error ) {
            //
            // No key at all..
            //
            return ERROR_SUCCESS;
        }
        DhcpPrint((DEBUG_ERRORS, "Saving registry: 0x%lx\n", Error));
    }

    //
    // now try to restore onto new location..
    //
    Error = DhcpSaveOrRestoreConfigToFileEx(
        DHCP_SWROOT_KEY L"\\" DHCP_CONFIG_KEY,
        ConfigFileName,
        /* fRestore */ TRUE
        );
    if( ERROR_SUCCESS != Error ) {
        //
        // Aargh. this is a pain.
        //
        DhcpPrint((DEBUG_ERRORS, "Restore registry: 0x%lx\n", Error));
        return Error;
    }

    //
    // Now just delete the old key so that we don't read it next time.
    //
    Error = DhcpRegDeleteKeyByName(
        DHCP_ROOT_KEY,
        DHCP_CONFIG_KEY
        );
    if( ERROR_SUCCESS != Error ) {
        ULONG NextError = DhcpSaveOrRestoreConfigToFileEx(
            DHCP_ROOT_KEY L"\\" DHCP_CONFIG_KEY,
            ConfigFileName,
            /* fRestore */ TRUE
            );

        DhcpPrint((DEBUG_ERRORS, "Delete old registry: 0x%lx\n", Error));
        if( ERROR_SUCCESS == NextError ) return Error;
    }

    return Error;
} // DhcpUpgradeConfiguration()

DWORD
DhcpBackupConfiguration(
    LPWSTR BackupFileName
    )
/*++

Routine Description:

    This function backups/saves the dhcp configuration key and its
    subkeys in the specified file. This file may be used later to
    restore this key.

Arguments:

    BackupFileName : full qualified path name + file name where the key
        is saved.

Return Value:

    Windows Error.

--*/
{
    DWORD Error;
    BOOL BoolError;
    NTSTATUS NtStatus;
    BOOLEAN WasEnable;
    HANDLE ImpersonationToken;

    DhcpPrint(( DEBUG_REGISTRY, "DhcpBackupConfiguration called.\n" ));

    //
    // Delete old backup configuration file if exits.
    //

    BoolError = DeleteFile( BackupFileName );

    if( BoolError == FALSE ) {

        Error = GetLastError();
        if( ERROR_FILE_NOT_FOUND != Error 
            && ERROR_PATH_NOT_FOUND != Error  ) {
            DhcpPrint(( DEBUG_ERRORS,
                        "Can't delete old backup configuration file %ws, %ld.\n",
                        BackupFileName, Error ));
            DhcpAssert( FALSE );
            goto Cleanup;
        }
    } // if DeleteFile failed

    //
    // impersonate to self.
    //

    NtStatus = RtlImpersonateSelf( SecurityImpersonation );

    if ( !NT_SUCCESS(NtStatus) ) {

        DhcpPrint(( DEBUG_ERRORS,
            "RtlImpersonateSelf failed,%lx.\n",
                NtStatus ));

        Error = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    } // if impersonation failed


    NtStatus = RtlAdjustPrivilege(
        SE_BACKUP_PRIVILEGE,
        TRUE,           // enable privilege.
        TRUE,           // adjust the client token.
        &WasEnable );
    
    if ( !NT_SUCCESS(NtStatus) ) {
        
        DhcpPrint(( DEBUG_ERRORS,
            "RtlAdjustPrivilege failed,%lx.\n",
                NtStatus ));

        Error = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    } // if

    LOCK_REGISTRY();

    //
    // backup configuation key.
    //

    Error = RegSaveKey(
		       DhcpGlobalRegParam,
		       BackupFileName,
		       NULL );
    
    UNLOCK_REGISTRY();

    if( Error != ERROR_SUCCESS ) {
       DhcpPrint(( DEBUG_ERRORS, "RegSaveKey failed for %ws Error: %ld.\n",
		   BackupFileName, Error ));
    }

    //
    // revert impersonation.
    //

    ImpersonationToken = NULL;
    NtStatus = NtSetInformationThread(
        NtCurrentThread(),
        ThreadImpersonationToken,
        (PVOID)&ImpersonationToken,
        sizeof(ImpersonationToken) );

    if ( !NT_SUCCESS(NtStatus) ) {

        DhcpPrint(( DEBUG_ERRORS,
            "RtlAdjustPrivilege failed,%lx.\n",
                NtStatus ));

        goto Cleanup;
    } // if

Cleanup:

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_REGISTRY,
            "DhcpBackupConfiguration failed, %ld.\n",
                Error ));
    }

    return( Error );
} // DhcpBackupConfiguration()

DWORD
DhcpCheckPathForRegKey
(
   LPWSTR RegKey,
   DWORD  Type
)
{
#define UNICODE_MAX_PATH_LEN   1000

    LPWSTR             DirPath;
    DWORD              DirPathLen;
    LPWSTR             ExpandedPath;
    DWORD              ExpPathLen;
    DWORD              Error;
    HKEY               Key;
    HANDLE             fHandle;
    WIN32_FILE_ATTRIBUTE_DATA AttribData;
    BOOL               Success;
    
    DhcpAssert( NULL != RegKey );

    Error = ERROR_SUCCESS;

    // Get a handle for the key
    DhcpPrint(( DEBUG_REGISTRY,
		"Checking %ws....\n", RegKey ));
    
    // Read the contents
    // mem is allocated for DirPath
    Error = DhcpRegGetValue( DhcpGlobalRegParam,
			     RegKey, Type,
			     ( LPBYTE ) &DirPath );

    if ( ERROR_SUCCESS != Error) {
	return Error;
    }

//      DhcpPrint(( DEBUG_REGISTRY,
//  		"Checking DirPathh : %ws\n", DirPath ));

    // Expand DirPath
    
    DirPathLen = ( wcslen( DirPath ) + 1 ) * sizeof( WCHAR );

    ExpandedPath = DhcpAllocateMemory( UNICODE_MAX_PATH_LEN );
    if ( NULL == ExpandedPath ) {
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    ExpPathLen = ExpandEnvironmentStrings( DirPath, ExpandedPath, wcslen( DirPath ) + 1);
    // ExpPathLen contains # of unicode chars 
    DhcpAssert( ExpPathLen < UNICODE_MAX_PATH_LEN / sizeof( WCHAR ));

    DhcpPrint(( DEBUG_REGISTRY, 
		"Expanded String = %ws\n",
		ExpandedPath ));

    // The path may no longer exist or may not be accessible. In this
    // case, reset the key to the default value.
    // 

    // Search for the path. We are searching for the directory, not the files
    // in that directory.

    Success = GetFileAttributesEx( ExpandedPath,
				   GetFileExInfoStandard,
				   & AttribData );
    if ( Success ) {
	// Search is successful. Check for the attributes.
	// It should be a directory and not read-only
	if ( !( AttribData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) ||
	     ( AttribData.dwFileAttributes & FILE_ATTRIBUTE_READONLY )) {
	    
	    Error = ERROR_ACCESS_DENIED;

	    DhcpPrint(( DEBUG_ERRORS,
			"Access denied for %ws\n", ExpandedPath ));
	} // if

	DhcpPrint(( DEBUG_REGISTRY, 
		    "GetFileAttributesEx(%ws) is successful\n",
		    ExpandedPath ));
    } // if found handle
    else {
	DhcpPrint(( DEBUG_ERRORS,
		    "GetFileAttributesEx() failed for %ws\n", ExpandedPath ));
	Error = GetLastError();
    } // else path is invalid

    // Free the allocated memory
    DhcpFreeMemory( ExpandedPath );
    MIDL_user_free( DirPath );

    return Error;
} // DhcpCheckPathForRegKey()

// 
// When the parameters are restored, the backup paths and other
// file related keys may point to non-existant sources or read-only
// shares/drives. In that case reset these keys to point to the
// standard %SystemRoot%\\System32\\dhcp directory.
// 

DWORD
DhcpCheckPaths( VOID )
{
    DWORD Error;
    DWORD RetVal;

    RetVal = ERROR_SUCCESS;

    DhcpPrint(( DEBUG_REGISTRY, "Checking (%ws) .. \n",
		DHCP_BACKUP_PATH_VALUE ));

    Error = DhcpCheckPathForRegKey( DHCP_BACKUP_PATH_VALUE,
				    DHCP_BACKUP_PATH_VALUE_TYPE );    
    if ( ERROR_SUCCESS != Error ) {
	RetVal = Error;

	DhcpServerEventLog( EVENT_SERVER_BACKUP_PATH_NOT_ACCESSIBLE,
			    EVENTLOG_ERROR_TYPE, Error );
    }
    DhcpPrint(( DEBUG_REGISTRY, "Returned %ld\n", Error ));

    DhcpPrint(( DEBUG_REGISTRY, "Checking (%ws) .. \n",
		DHCP_DB_PATH_VALUE ));
    Error = DhcpCheckPathForRegKey( DHCP_DB_PATH_VALUE,
				    DHCP_DB_PATH_VALUE_TYPE );
    if ( ERROR_SUCCESS != Error ) {
	RetVal = Error;

	DhcpServerEventLog( EVENT_SERVER_DB_PATH_NOT_ACCESSIBLE,
			    EVENTLOG_ERROR_TYPE, Error );
    }
    DhcpPrint(( DEBUG_REGISTRY, "Returned %ld\n", Error ));
	
    DhcpPrint(( DEBUG_REGISTRY, "Checking (%ws) .. \n",
		DHCP_LOG_FILE_PATH_VALUE ));
    Error = DhcpCheckPathForRegKey( DHCP_LOG_FILE_PATH_VALUE,
				    DHCP_LOG_FILE_PATH_VALUE_TYPE );
    if ( ERROR_SUCCESS != Error ) {
	RetVal = Error;

	DhcpServerEventLog( EVENT_SERVER_AUDITLOG_PATH_NOT_ACCESSIBLE,
			    EVENTLOG_ERROR_TYPE, Error );
    }
    DhcpPrint(( DEBUG_REGISTRY, "Returned %ld\n", Error ));
	
    return RetVal;
} // DhcpCheckPaths()

BOOL DhcpCloseAllSubKeys( VOID )
{
    DWORD Error;

    if( DhcpGlobalRegSubnets != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegSubnets );

        if( Error != ERROR_SUCCESS ) {
            return FALSE;
        }
        DhcpGlobalRegSubnets = NULL;
    } // if

    if( DhcpGlobalRegMScopes != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegMScopes );

        if( Error != ERROR_SUCCESS ) {
	    return FALSE;
        }
        DhcpGlobalRegMScopes = NULL;
    } // if

    if( DhcpGlobalRegOptionInfo != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegOptionInfo );

        if( Error != ERROR_SUCCESS ) {
            return FALSE;
        }
        DhcpGlobalRegOptionInfo = NULL;
    } // if


    if( DhcpGlobalRegGlobalOptions != NULL ) {
        Error = RegCloseKey( DhcpGlobalRegGlobalOptions );

        if( Error != ERROR_SUCCESS ) {
            return FALSE;
        }
        DhcpGlobalRegGlobalOptions = NULL;
    } // if 

    if( DhcpGlobalRegSuperScope != NULL ) {              // added by t-cheny:
        Error = RegCloseKey( DhcpGlobalRegSuperScope );  // superscope

        if( Error != ERROR_SUCCESS ) {
            return FALSE;
        }
        DhcpGlobalRegSuperScope = NULL;
    } // false

    return TRUE;

} //DhcpCloseAllSubKeys()

DWORD
DhcpReOpenAllSubKeys ( VOID )
{
    DWORD KeyDisposition;
    DWORD Error;

    
    Error = DhcpRegCreateKey(
                DhcpGlobalRegConfig,
                DHCP_SUBNETS_KEY,
                &DhcpGlobalRegSubnets,
                &KeyDisposition );

    if( Error != ERROR_SUCCESS ) {
        return Error;
    } 

    Error = DhcpRegCreateKey(
                DhcpGlobalRegConfig,
                DHCP_MSCOPES_KEY,
                &DhcpGlobalRegMScopes,
                &KeyDisposition );

    if( Error != ERROR_SUCCESS ) {
	return Error;
    }

    Error = DhcpRegCreateKey(
                DhcpGlobalRegConfig,
                DHCP_OPTION_INFO_KEY,
                &DhcpGlobalRegOptionInfo,
                &KeyDisposition );

    if( Error != ERROR_SUCCESS ) {
	return Error;
    }

    Error = DhcpRegCreateKey(
                DhcpGlobalRegConfig,
                DHCP_GLOBAL_OPTIONS_KEY,
                &DhcpGlobalRegGlobalOptions,
                &KeyDisposition );

    if( Error != ERROR_SUCCESS ) {
        return Error;
    }

    Error = DhcpRegCreateKey(        // added by t-cheny:  superscope
                DhcpGlobalRegConfig,
                DHCP_SUPERSCOPE_KEY,
                &DhcpGlobalRegSuperScope,
                &KeyDisposition );

    if( Error != ERROR_SUCCESS ) {
        return Error;
    }

    return ERROR_SUCCESS;
} // DhcpReOpenAllSubKeys()


DWORD
DhcpRestoreConfiguration(
    LPWSTR BackupFileName
    )
/*++

Routine Description:

    This function restores the dhcp configuration key and its
    subkeys in the specified file.

Arguments:

    BackupFileName : full qualified path name + file name from where the
        key is restored.

Return Value:

    Windows Error.

--*/
{
    DWORD Error;
    NTSTATUS NtStatus;
    BOOLEAN WasEnable;
    HANDLE ImpersonationToken;
    BOOL RegistryLocked = FALSE;
    BOOL Impersonated = FALSE;


    DhcpPrint(( DEBUG_REGISTRY, "DhcpRestoreConfiguration(%ws) called.\n",
		BackupFileName ));

    do {
	//
	// impersonate to self.
	//

	NtStatus = RtlImpersonateSelf( SecurityImpersonation );
	if ( !NT_SUCCESS(NtStatus) ) {

	    DhcpPrint(( DEBUG_ERRORS,
			"RtlImpersonateSelf failed,%lx.\n",
			NtStatus ));

	    Error = RtlNtStatusToDosError( NtStatus );
	    break;
	} // if 

	Impersonated = TRUE;
	NtStatus = RtlAdjustPrivilege(
				      SE_RESTORE_PRIVILEGE,
				      TRUE,           // enable privilege.
				      TRUE,           // adjust the client token.
				      &WasEnable );

	if ( !NT_SUCCESS(NtStatus) ) {

	    DhcpPrint(( DEBUG_ERRORS,
			"RtlAdjustPrivilege failed,%lx.\n",
			NtStatus ));

	    Error = RtlNtStatusToDosError( NtStatus );
	    break;
	} // if

	LOCK_REGISTRY();
	RegistryLocked = TRUE;

	//
	// Restore configuation key.
	//

	DhcpPrint(( DEBUG_REGISTRY,
		    "DhcpRestoreConfiguration(): Restoring Parameters from (%ls)\n", BackupFileName ));
	DhcpAssert( DhcpGlobalRegParam != NULL );
	Error = RegRestoreKey( DhcpGlobalRegParam,
			       BackupFileName,
			       REG_FORCE_RESTORE );

	if( Error != ERROR_SUCCESS ) {
	    DhcpPrint((DEBUG_ERRORS, "DhcpRestoreConfiguration() failed in RegRestoreKey. Error :%ld (%ld)\n",
		       Error, GetLastError()));
	    break;
	} // if

	//
	// Check for valid log paths. Log into eventlog if they are bad
	//

	Error = DhcpCheckPaths();
	DhcpPrint(( DEBUG_REGISTRY, "DhcpCheckPaths() returned : %ld\n", Error ));

	if ( ERROR_SUCCESS != Error ) {
	    break;
	}
    } // do
    while ( FALSE );

    // Cleanup:
    
    if( RegistryLocked ) {
        UNLOCK_REGISTRY();
    }
    
    if( Impersonated ) {
	
        //
        // revert impersonation.
        //

        ImpersonationToken = NULL;
        NtStatus = NtSetInformationThread(
                        NtCurrentThread(),
                        ThreadImpersonationToken,
                        (PVOID)&ImpersonationToken,
                        sizeof(ImpersonationToken) );

        if ( !NT_SUCCESS(NtStatus) ) {

            DhcpPrint(( DEBUG_ERRORS,
                "RtlAdjustPrivilege failed,%lx.\n",
                    NtStatus ));
        }
    } // if impersonated

    return( Error );
} // DhcpRestoreConfiguration()

DHCP_IP_ADDRESS
DhcpRegGetBcastAddress(
    VOID
    )
/*++

Routine Description:
    This routine reads the broadcast address specified for the
    interface in registry. This is used to fake a different broadcast
    address in case of check builds.  Not really that useful...

--*/
{
    HKEY   LinkageKeyHandle = NULL;
    DWORD  Addr = (DWORD)-1, Error;

    //
    // Try to read the parameters key
    //
    Error = RegOpenKeyEx(
        DhcpGlobalRegRoot,
        DHCP_PARAM_KEY,
        0,
        DHCP_KEY_ACCESS,
        &LinkageKeyHandle
        );
    if( ERROR_SUCCESS != Error) {
        return Addr;
    }

    //
    // Try to get the BCAST value.
    //
    Error =  DhcpRegGetValue(
        LinkageKeyHandle,
        DHCP_BCAST_ADDRESS_VALUE,
        DHCP_BCAST_ADDRESS_VALUE_TYPE,
        (LPBYTE)&Addr
        );
    
    RegCloseKey(LinkageKeyHandle);
    if( ERROR_SUCCESS != Error ) {
        return (DWORD)-1;
    }
    return Addr;
}

BOOL
CheckKeyForBindability(
    IN HKEY Key,
    IN ULONG IpAddress
    )
{
    DWORD fBound, Error;
    LPWSTR IpAddressString;

    Error = DhcpRegGetValue(
        Key,
        DHCP_NET_IPADDRESS_VALUE,
        DHCP_NET_IPADDRESS_VALUE_TYPE,
        (LPBYTE)&IpAddressString
        );

    if( NO_ERROR != Error ) return FALSE;
    if( NULL == IpAddressString ) return FALSE;

    fBound = FALSE;
    do {
        LPSTR OemStringPtr;
        CHAR OemString[500];
        
        if( wcslen(IpAddressString) == 0 ) {
            break;
        }

        OemStringPtr = DhcpUnicodeToOem( IpAddressString, OemString );
        fBound = ( IpAddress == inet_addr( OemStringPtr ) );
        
    } while ( 0 );

    if( IpAddressString ) MIDL_user_free(IpAddressString);
    return fBound;
}    
    
BOOL
CheckKeyForBinding(
    IN HKEY Key,
    IN ULONG IpAddress
    )
/*++

Routine Description:
    This routine attempts to check the given interface key to see
    if there is a binding for the dhcp server.

    It does this in two steps: first sees if there is a
    "BindToDHCPServer" regvalue with zero value. If so, it
    then returns FALSE.

    Secondly, it looks through the IP Address values and tries to
    see if the given IP address is the first in that list.

Arguments:
    Key -- the key to use for reading values
    IpAddress -- the Ip address that is to be checked for binding

Return Values:
    TRUE -- binding does exist.
    FALSE -- no binding exists for this IP address.

--*/
{
    DWORD fBound, Error;
    
    Error = DhcpRegGetValue(
        Key,
        DHCP_NET_BIND_DHCDSERVER_FLAG_VALUE,
        DHCP_NET_BIND_DHCPSERVER_FLAG_VALUE_TYPE,
        (PVOID)&fBound
        );
    if( NO_ERROR == Error && 0 == fBound ) {
        return FALSE;
    }

    return CheckKeyForBindability(Key, IpAddress);
} // CheckKeyForBinding()

ULONG
SetKeyForBinding(
    IN HKEY Key,
    IN ULONG IpAddress,
    IN BOOL fBind
    )
/*++

Routine Description:
    This routine sets the binding for the given key as per the fBind
    flag.  Currently the IpAddress field is ignored as the binding is
    not per IP address.

    The binding is just per interface.

Arguments:
    Key -- interface key.
    IpAddress -- the ip address to add to binding list.
    fBind -- interface to bind to.

Return Value:
    Registry errors.

--*/
{
    ULONG Error;
    
    if( TRUE == fBind ) {
        //
        // If we are binding, we can just remove the fBind key.
        //
        Error = RegDeleteValue(
            Key,
            DHCP_NET_BIND_DHCDSERVER_FLAG_VALUE
            );
        if( ERROR_FILE_NOT_FOUND == Error
            || ERROR_PATH_NOT_FOUND == Error ) {
            Error = NO_ERROR;
        }
        
    } else {
        DWORD dwBind = fBind;
        //
        // We are _not_ binding. Explicity set the registry flag.
        //
        Error = RegSetValueEx(
            Key,
            DHCP_NET_BIND_DHCDSERVER_FLAG_VALUE,
            0, /* Reserved */
            DHCP_NET_BIND_DHCPSERVER_FLAG_VALUE_TYPE,
            (PVOID)&dwBind,
            sizeof(dwBind)
        );
    }

    return Error;
}

BOOL
DhcpCheckIfDatabaseUpgraded(
    BOOL fRegUpgrade
    )
/*++

Routine Description:

    This routine tries to check if an upgrade is needed or not.

Arguments:

    fRegUpgrade -- If this is TRUE, the the upgrade check is to
    see if there is need for converting the registry to
    database.  If it is FALSE, then the check is to see if a
    conversion needs to be done for just the database.
    
    Note: The database conversion should always be attempted
    before the registry conversion.

Return Values:

    FALSE -- this is not the required upgrade path.
    TRUE -- yes, the upgrade path must be executed.
    
--*/
{
    HKEY hKey;
    DWORD Error, Type, Value, Size;

    
    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("SYSTEM\\CurrentControlSet\\Services\\DHCPServer\\Parameters"),
        0, KEY_READ, &hKey );

    if( NO_ERROR != Error ) return FALSE;

    Type = REG_DWORD; Value = 0; Size = sizeof(Value);
    Error = RegQueryValueEx(
        hKey, TEXT("Version"), NULL, &Type, (PVOID)&Value, &Size );

    RegCloseKey( hKey );

    //
    // if this value is not present, then upgrade is needed.  If
    // the value is zero then only a Registry upgrade is needed
    // and the database upgrade has been taken care of
    //

    if( NO_ERROR != Error ) return TRUE;
    if( fRegUpgrade && Value == 0 ) return TRUE;

    //
    // No upgrades needed, all have been taken care of
    //
    
    return FALSE;
} // DhcpCheckIfDatabaseUpgraded()


DWORD
DhcpSetRegistryUpgradedToDatabaseStatus(
    VOID
    )
{
    DWORD Error;
    HKEY hKey;
    
    //
    // Attempt to write the version key
    //
    
    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("SYSTEM\\CurrentControlSet\\Services\\DHCPServer\\Parameters"),
        0, KEY_WRITE, &hKey );

    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS, "OpenKeyEx: %ld\n", Error ));
    } else {
        DWORD Version = GetVersion(), Size = sizeof(Version);

        Error = RegSetValueEx(
            hKey, TEXT("Version"), 0, REG_DWORD, (PVOID)&Version,
            Size );

        DhcpPrint((DEBUG_ERRORS, "RegSetValueEx: %ld\n", Error));
        RegCloseKey( hKey );
    } // else

    return Error;
} // DhcpSetRegistryUpgradedToDatabaseStatus()

DWORD
DeleteSoftwareRootKey(
    VOID
    )
{
    DWORD Error;
    
    DhcpCleanupRegistry();
    Error = DhcpRegDeleteKeyByName( DHCP_SWROOT_KEY, DHCP_CONFIG_KEY );
    if( NO_ERROR != Error ) return Error;
    
    return OpenGlobalRegKeys();
} // DeleteSoftwareRootKey()

//
//  End of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\dhcpsrv.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpsrv.h

Abstract:

    This file is the central include file for the DHCP server service.

Author:

    Madan Appiah  (madana)  10-Sep-1993
    Manny Weiser  (mannyw)  11-Aug-1992

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

#include <dhcppch.h>
#include <dhcp_srv.h>
#include <dhcp2_srv.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\dhcprpc.c ===
/*++

Copyright (C) 1998 Microsoft Corporation

Module Name:
    dhcprpc.c

Abstract:
    This module just includes some rpc files to get
    over pre-compilation woes.

--*/

#include <dhcppch.h>

#include "dhcp_srv.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\dhcptest.c ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/
#include <dhcppch.h>

VOID Test1(LPCSTR P) {
}

VOID Test2(LPCSTR P) {
}
VOID Test(LPCSTR P) {
   Test1(P);
   Test2(P);
}

VOID
_declspec(dllexport)
MainLoop(VOID);

VOID __cdecl
main (VOID ) {

    MainLoop();

    Test(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\dhcp_srv.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0323 */
/* Compiler settings for dhcp_srv.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, oldnames, robust dhcp_bug_compatibility
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#include <string.h>
#include "dhcp_srv.h"

#define TYPE_FORMAT_STRING_SIZE   1519                              
#define PROC_FORMAT_STRING_SIZE   2359                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: dhcpsrv, ver. 1.0,
   GUID={0x6BFFD098,0xA112,0x3610,{0x98,0x33,0x46,0xC3,0xF8,0x74,0x53,0x2D}} */


extern const MIDL_SERVER_INFO dhcpsrv_ServerInfo;

extern RPC_DISPATCH_TABLE dhcpsrv_DispatchTable;

static const RPC_SERVER_INTERFACE dhcpsrv___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x6BFFD098,0xA112,0x3610,{0x98,0x33,0x46,0xC3,0xF8,0x74,0x53,0x2D}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &dhcpsrv_DispatchTable,
    0,
    0,
    0,
    &dhcpsrv_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE dhcpsrv_ServerIfHandle = (RPC_IF_HANDLE)& dhcpsrv___RpcServerInterface;

extern const MIDL_STUB_DESC dhcpsrv_StubDesc;

extern const EXPR_EVAL ExprEvalRoutines[];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT50_OR_LATER)
#error You need a Windows 2000 Professional or later to run this stub because it uses these features:
#error   /robust command line switch.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure R_DhcpCreateSubnet */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
#ifndef _ALPHA_
/*  8 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 10 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 12 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 14 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 22 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 30 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 32 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 34 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 36 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 38 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 40 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 42 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 44 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 46 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Return value */

/* 48 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 50 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 52 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetSubnetInfo */

/* 54 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 56 */	NdrFcLong( 0x0 ),	/* 0 */
/* 60 */	NdrFcShort( 0x1 ),	/* 1 */
#ifndef _ALPHA_
/* 62 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 64 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 66 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 68 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 70 */	NdrFcShort( 0x8 ),	/* 8 */
/* 72 */	NdrFcShort( 0x8 ),	/* 8 */
/* 74 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 76 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 78 */	NdrFcShort( 0x0 ),	/* 0 */
/* 80 */	NdrFcShort( 0x0 ),	/* 0 */
/* 82 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 84 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 86 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 88 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 90 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 92 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 94 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 96 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 98 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 100 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Return value */

/* 102 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 104 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 106 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetSubnetInfo */

/* 108 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 110 */	NdrFcLong( 0x0 ),	/* 0 */
/* 114 */	NdrFcShort( 0x2 ),	/* 2 */
#ifndef _ALPHA_
/* 116 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 118 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 120 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 122 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 124 */	NdrFcShort( 0x8 ),	/* 8 */
/* 126 */	NdrFcShort( 0x8 ),	/* 8 */
/* 128 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 130 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x0 ),	/* 0 */
/* 136 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 138 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 140 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 142 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 144 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 146 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 148 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 150 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 152 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 154 */	NdrFcShort( 0x44 ),	/* Type Offset=68 */

	/* Return value */

/* 156 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 158 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 160 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnets */

/* 162 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 164 */	NdrFcLong( 0x0 ),	/* 0 */
/* 168 */	NdrFcShort( 0x3 ),	/* 3 */
#ifndef _ALPHA_
/* 170 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 172 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 174 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 176 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 178 */	NdrFcShort( 0x24 ),	/* 36 */
/* 180 */	NdrFcShort( 0x5c ),	/* 92 */
/* 182 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 184 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 186 */	NdrFcShort( 0x1 ),	/* 1 */
/* 188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 190 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 192 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 194 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 196 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ResumeHandle */

/* 198 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 200 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 202 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 204 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 206 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 208 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumInfo */

/* 210 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 212 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 214 */	NdrFcShort( 0x50 ),	/* Type Offset=80 */

	/* Parameter ElementsRead */

/* 216 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 218 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 220 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 222 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 224 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 226 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 228 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 230 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 232 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpAddSubnetElement */

/* 234 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 236 */	NdrFcLong( 0x0 ),	/* 0 */
/* 240 */	NdrFcShort( 0x4 ),	/* 4 */
#ifndef _ALPHA_
/* 242 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 244 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 246 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 248 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 250 */	NdrFcShort( 0x8 ),	/* 8 */
/* 252 */	NdrFcShort( 0x8 ),	/* 8 */
/* 254 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 256 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 260 */	NdrFcShort( 0x2 ),	/* 2 */
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 264 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 266 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 268 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 270 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 272 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 274 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter AddElementInfo */

/* 276 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 278 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 280 */	NdrFcShort( 0xf6 ),	/* Type Offset=246 */

	/* Return value */

/* 282 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 284 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 286 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetElements */

/* 288 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 290 */	NdrFcLong( 0x0 ),	/* 0 */
/* 294 */	NdrFcShort( 0x5 ),	/* 5 */
#ifndef _ALPHA_
/* 296 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
#else
			NdrFcShort( 0x48 ),	/* Alpha Stack size/offset = 72 */
#endif
/* 298 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 300 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 302 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 304 */	NdrFcShort( 0x32 ),	/* 50 */
/* 306 */	NdrFcShort( 0x5c ),	/* 92 */
/* 308 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x9,		/* 9 */
/* 310 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 312 */	NdrFcShort( 0x3 ),	/* 3 */
/* 314 */	NdrFcShort( 0x0 ),	/* 0 */
/* 316 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 318 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 320 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 322 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 324 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 326 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 328 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementType */

/* 330 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 332 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 334 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 336 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 338 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 340 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 342 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 344 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 346 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementInfo */

/* 348 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 350 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 352 */	NdrFcShort( 0x104 ),	/* Type Offset=260 */

	/* Parameter ElementsRead */

/* 354 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 356 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 358 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 360 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 362 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 364 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 366 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 368 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 370 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveSubnetElement */

/* 372 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 374 */	NdrFcLong( 0x0 ),	/* 0 */
/* 378 */	NdrFcShort( 0x6 ),	/* 6 */
#ifndef _ALPHA_
/* 380 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 382 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 384 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 386 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 388 */	NdrFcShort( 0xe ),	/* 14 */
/* 390 */	NdrFcShort( 0x8 ),	/* 8 */
/* 392 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 394 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 396 */	NdrFcShort( 0x0 ),	/* 0 */
/* 398 */	NdrFcShort( 0x2 ),	/* 2 */
/* 400 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 402 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 404 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 406 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 408 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 410 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 412 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter RemoveElementInfo */

/* 414 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 416 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 418 */	NdrFcShort( 0xf6 ),	/* Type Offset=246 */

	/* Parameter ForceFlag */

/* 420 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 422 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 424 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 426 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 428 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 430 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteSubnet */

/* 432 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 434 */	NdrFcLong( 0x0 ),	/* 0 */
/* 438 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/* 440 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 442 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 444 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 446 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 448 */	NdrFcShort( 0xe ),	/* 14 */
/* 450 */	NdrFcShort( 0x8 ),	/* 8 */
/* 452 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 454 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 458 */	NdrFcShort( 0x0 ),	/* 0 */
/* 460 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 462 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 464 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 466 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 468 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 470 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 472 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ForceFlag */

/* 474 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 476 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 478 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 480 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 482 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 484 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateOption */

/* 486 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 488 */	NdrFcLong( 0x0 ),	/* 0 */
/* 492 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 494 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 496 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 498 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 500 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 502 */	NdrFcShort( 0x8 ),	/* 8 */
/* 504 */	NdrFcShort( 0x8 ),	/* 8 */
/* 506 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 508 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 510 */	NdrFcShort( 0x0 ),	/* 0 */
/* 512 */	NdrFcShort( 0x4 ),	/* 4 */
/* 514 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 516 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 518 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 520 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 522 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 524 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 526 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 528 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 530 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 532 */	NdrFcShort( 0x1b2 ),	/* Type Offset=434 */

	/* Return value */

/* 534 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 536 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 538 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionInfo */

/* 540 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 542 */	NdrFcLong( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0x9 ),	/* 9 */
#ifndef _ALPHA_
/* 548 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 550 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 552 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 554 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 556 */	NdrFcShort( 0x8 ),	/* 8 */
/* 558 */	NdrFcShort( 0x8 ),	/* 8 */
/* 560 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 562 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 564 */	NdrFcShort( 0x0 ),	/* 0 */
/* 566 */	NdrFcShort( 0x4 ),	/* 4 */
/* 568 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 570 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 572 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 574 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 576 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 578 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 580 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 582 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 584 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 586 */	NdrFcShort( 0x1b2 ),	/* Type Offset=434 */

	/* Return value */

/* 588 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 590 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 592 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetOptionInfo */

/* 594 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 596 */	NdrFcLong( 0x0 ),	/* 0 */
/* 600 */	NdrFcShort( 0xa ),	/* 10 */
#ifndef _ALPHA_
/* 602 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 604 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 606 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 608 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 610 */	NdrFcShort( 0x8 ),	/* 8 */
/* 612 */	NdrFcShort( 0x8 ),	/* 8 */
/* 614 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 616 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 618 */	NdrFcShort( 0x4 ),	/* 4 */
/* 620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 622 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 624 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 626 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 628 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 630 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 632 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 634 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 636 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 638 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 640 */	NdrFcShort( 0x1cc ),	/* Type Offset=460 */

	/* Return value */

/* 642 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 644 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveOption */

/* 648 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 650 */	NdrFcLong( 0x0 ),	/* 0 */
/* 654 */	NdrFcShort( 0xb ),	/* 11 */
#ifndef _ALPHA_
/* 656 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 658 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 660 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 662 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 664 */	NdrFcShort( 0x8 ),	/* 8 */
/* 666 */	NdrFcShort( 0x8 ),	/* 8 */
/* 668 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 670 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 672 */	NdrFcShort( 0x0 ),	/* 0 */
/* 674 */	NdrFcShort( 0x0 ),	/* 0 */
/* 676 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 678 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 680 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 682 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 684 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 686 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 688 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 690 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 692 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 694 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionValue */

/* 696 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 698 */	NdrFcLong( 0x0 ),	/* 0 */
/* 702 */	NdrFcShort( 0xc ),	/* 12 */
#ifndef _ALPHA_
/* 704 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 706 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 708 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 710 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 712 */	NdrFcShort( 0x8 ),	/* 8 */
/* 714 */	NdrFcShort( 0x8 ),	/* 8 */
/* 716 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 718 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 720 */	NdrFcShort( 0x0 ),	/* 0 */
/* 722 */	NdrFcShort( 0x5 ),	/* 5 */
/* 724 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 726 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 728 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 730 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 732 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 734 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 736 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 738 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 740 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 742 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Parameter OptionValue */

/* 744 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 746 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 748 */	NdrFcShort( 0x19e ),	/* Type Offset=414 */

	/* Return value */

/* 750 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 752 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 754 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetOptionValue */

/* 756 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 758 */	NdrFcLong( 0x0 ),	/* 0 */
/* 762 */	NdrFcShort( 0xd ),	/* 13 */
#ifndef _ALPHA_
/* 764 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 766 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 768 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 770 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 772 */	NdrFcShort( 0x8 ),	/* 8 */
/* 774 */	NdrFcShort( 0x8 ),	/* 8 */
/* 776 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 778 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 780 */	NdrFcShort( 0x4 ),	/* 4 */
/* 782 */	NdrFcShort( 0x1 ),	/* 1 */
/* 784 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 786 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 788 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 790 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 792 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 794 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 796 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 798 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 800 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 802 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Parameter OptionValue */

/* 804 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 806 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 808 */	NdrFcShort( 0x218 ),	/* Type Offset=536 */

	/* Return value */

/* 810 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 812 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 814 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumOptionValues */

/* 816 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 818 */	NdrFcLong( 0x0 ),	/* 0 */
/* 822 */	NdrFcShort( 0xe ),	/* 14 */
#ifndef _ALPHA_
/* 824 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 826 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 828 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 830 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 832 */	NdrFcShort( 0x24 ),	/* 36 */
/* 834 */	NdrFcShort( 0x5c ),	/* 92 */
/* 836 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 838 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 840 */	NdrFcShort( 0x5 ),	/* 5 */
/* 842 */	NdrFcShort( 0x1 ),	/* 1 */
/* 844 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 846 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 848 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 850 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ScopeInfo */

/* 852 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 854 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 856 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Parameter ResumeHandle */

/* 858 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 860 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 862 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 864 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 866 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 868 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionValues */

/* 870 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 872 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 874 */	NdrFcShort( 0x24c ),	/* Type Offset=588 */

	/* Parameter OptionsRead */

/* 876 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 878 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 880 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionsTotal */

/* 882 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 884 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 886 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 888 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 890 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 892 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveOptionValue */

/* 894 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 896 */	NdrFcLong( 0x0 ),	/* 0 */
/* 900 */	NdrFcShort( 0xf ),	/* 15 */
#ifndef _ALPHA_
/* 902 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 904 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 906 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 908 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 910 */	NdrFcShort( 0x8 ),	/* 8 */
/* 912 */	NdrFcShort( 0x8 ),	/* 8 */
/* 914 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 916 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 918 */	NdrFcShort( 0x0 ),	/* 0 */
/* 920 */	NdrFcShort( 0x1 ),	/* 1 */
/* 922 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 924 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 926 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 928 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 930 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 932 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 934 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 936 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 938 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 940 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Return value */

/* 942 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 944 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 946 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateClientInfo */

/* 948 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 950 */	NdrFcLong( 0x0 ),	/* 0 */
/* 954 */	NdrFcShort( 0x10 ),	/* 16 */
#ifndef _ALPHA_
/* 956 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 958 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 960 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 962 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 964 */	NdrFcShort( 0x0 ),	/* 0 */
/* 966 */	NdrFcShort( 0x8 ),	/* 8 */
/* 968 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 970 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 972 */	NdrFcShort( 0x0 ),	/* 0 */
/* 974 */	NdrFcShort( 0x1 ),	/* 1 */
/* 976 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 978 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 980 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 982 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 984 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 986 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 988 */	NdrFcShort( 0x29a ),	/* Type Offset=666 */

	/* Return value */

/* 990 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 992 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 994 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetClientInfo */

/* 996 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 998 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1002 */	NdrFcShort( 0x11 ),	/* 17 */
#ifndef _ALPHA_
/* 1004 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1006 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1008 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1010 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1012 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1014 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1016 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1018 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1020 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1022 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1024 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1026 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1028 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1030 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1032 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1034 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1036 */	NdrFcShort( 0x29a ),	/* Type Offset=666 */

	/* Return value */

/* 1038 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1040 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1042 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientInfo */

/* 1044 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1046 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1050 */	NdrFcShort( 0x12 ),	/* 18 */
#ifndef _ALPHA_
/* 1052 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1054 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1056 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1058 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1060 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1062 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1064 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1066 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1068 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1070 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1072 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1074 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1076 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1078 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SearchInfo */

/* 1080 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1082 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1084 */	NdrFcShort( 0x308 ),	/* Type Offset=776 */

	/* Parameter ClientInfo */

/* 1086 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1088 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1090 */	NdrFcShort( 0x316 ),	/* Type Offset=790 */

	/* Return value */

/* 1092 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1094 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1096 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteClientInfo */

/* 1098 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1100 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1104 */	NdrFcShort( 0x13 ),	/* 19 */
#ifndef _ALPHA_
/* 1106 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1108 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1110 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1112 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1114 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1116 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1118 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1120 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1122 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1124 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1126 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1128 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1130 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1132 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1134 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1136 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1138 */	NdrFcShort( 0x308 ),	/* Type Offset=776 */

	/* Return value */

/* 1140 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1142 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1144 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetClients */

/* 1146 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1148 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1152 */	NdrFcShort( 0x14 ),	/* 20 */
#ifndef _ALPHA_
/* 1154 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 1156 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1158 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1160 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1162 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1164 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1166 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1168 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1170 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1172 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1174 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1176 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1178 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1180 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1182 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1184 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1186 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 1188 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 1190 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1192 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1194 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1196 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1198 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientInfo */

/* 1200 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1202 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1204 */	NdrFcShort( 0x31e ),	/* Type Offset=798 */

	/* Parameter ClientsRead */

/* 1206 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1208 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1210 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientsTotal */

/* 1212 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1214 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 1216 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1218 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1220 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 1222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientOptions */

/* 1224 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1226 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1230 */	NdrFcShort( 0x15 ),	/* 21 */
#ifndef _ALPHA_
/* 1232 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1234 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1236 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1238 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1240 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1242 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1244 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1246 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1248 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1252 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1254 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1256 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1258 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientIpAddress */

/* 1260 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1262 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1264 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientSubnetMask */

/* 1266 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1268 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1270 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientOptions */

/* 1272 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1274 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1276 */	NdrFcShort( 0x24c ),	/* Type Offset=588 */

	/* Return value */

/* 1278 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1280 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetMibInfo */

/* 1284 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1290 */	NdrFcShort( 0x16 ),	/* 22 */
#ifndef _ALPHA_
/* 1292 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1294 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1296 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1298 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1302 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1304 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1306 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1308 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1312 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1314 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1316 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1318 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter MibInfo */

/* 1320 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1322 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1324 */	NdrFcShort( 0x35a ),	/* Type Offset=858 */

	/* Return value */

/* 1326 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1328 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1330 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumOptions */

/* 1332 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1334 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1338 */	NdrFcShort( 0x17 ),	/* 23 */
#ifndef _ALPHA_
/* 1340 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 1342 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1344 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1346 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1348 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1350 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1352 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 1354 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1356 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1360 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1362 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1364 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1366 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ResumeHandle */

/* 1368 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 1370 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1372 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1374 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1376 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1378 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Options */

/* 1380 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1382 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1384 */	NdrFcShort( 0x39c ),	/* Type Offset=924 */

	/* Parameter OptionsRead */

/* 1386 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1388 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1390 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionsTotal */

/* 1392 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1394 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1396 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1398 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1400 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 1402 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionValues */

/* 1404 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1406 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1410 */	NdrFcShort( 0x18 ),	/* 24 */
#ifndef _ALPHA_
/* 1412 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1414 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1416 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1418 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1420 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1422 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1424 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1426 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1428 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1430 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1432 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1434 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1436 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1438 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ScopeInfo */

/* 1440 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1442 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1444 */	NdrFcShort( 0x206 ),	/* Type Offset=518 */

	/* Parameter OptionValues */

/* 1446 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1448 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1450 */	NdrFcShort( 0x276 ),	/* Type Offset=630 */

	/* Return value */

/* 1452 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1454 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1456 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerSetConfig */

/* 1458 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1460 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1464 */	NdrFcShort( 0x19 ),	/* 25 */
#ifndef _ALPHA_
/* 1466 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1468 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1470 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1472 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1474 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1476 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1478 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1480 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1482 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1484 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1486 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1488 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1490 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1492 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter FieldsToSet */

/* 1494 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1496 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1498 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ConfigInfo */

/* 1500 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1502 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1504 */	NdrFcShort( 0x3d6 ),	/* Type Offset=982 */

	/* Return value */

/* 1506 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1508 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1510 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerGetConfig */

/* 1512 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1514 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1518 */	NdrFcShort( 0x1a ),	/* 26 */
#ifndef _ALPHA_
/* 1520 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1522 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1524 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1526 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1528 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1530 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1532 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1534 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1536 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1538 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1540 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1542 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1544 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1546 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ConfigInfo */

/* 1548 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1550 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1552 */	NdrFcShort( 0x406 ),	/* Type Offset=1030 */

	/* Return value */

/* 1554 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1556 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1558 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpScanDatabase */

/* 1560 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1562 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1566 */	NdrFcShort( 0x1b ),	/* 27 */
#ifndef _ALPHA_
/* 1568 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1570 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1572 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1574 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1576 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1578 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1580 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1582 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1584 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1586 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1588 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1590 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1592 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1594 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1596 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1598 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1600 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter FixFlag */

/* 1602 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1604 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1606 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScanList */

/* 1608 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1610 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1612 */	NdrFcShort( 0x40e ),	/* Type Offset=1038 */

	/* Return value */

/* 1614 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1616 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1618 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetVersion */

/* 1620 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1622 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1626 */	NdrFcShort( 0x1c ),	/* 28 */
#ifndef _ALPHA_
/* 1628 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1630 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1632 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1634 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1636 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1638 */	NdrFcShort( 0x40 ),	/* 64 */
/* 1640 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1642 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1644 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1646 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1648 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1650 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1652 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1654 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter MajorVersion */

/* 1656 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1658 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1660 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter MinorVersion */

/* 1662 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1664 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1666 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1668 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1670 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1672 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpAddSubnetElementV4 */

/* 1674 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1676 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1680 */	NdrFcShort( 0x1d ),	/* 29 */
#ifndef _ALPHA_
/* 1682 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1684 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1686 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1688 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1690 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1692 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1694 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1696 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1698 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1700 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1702 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1704 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1706 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1708 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1710 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1712 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1714 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter AddElementInfo */

/* 1716 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1718 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1720 */	NdrFcShort( 0x494 ),	/* Type Offset=1172 */

	/* Return value */

/* 1722 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1724 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1726 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetElementsV4 */

/* 1728 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1730 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1734 */	NdrFcShort( 0x1e ),	/* 30 */
#ifndef _ALPHA_
/* 1736 */	NdrFcShort( 0x24 ),	/* x86 Stack size/offset = 36 */
#else
			NdrFcShort( 0x48 ),	/* Alpha Stack size/offset = 72 */
#endif
/* 1738 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1740 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1742 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1744 */	NdrFcShort( 0x32 ),	/* 50 */
/* 1746 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1748 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x9,		/* 9 */
/* 1750 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1752 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1754 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1756 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1758 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1760 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1762 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1764 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1766 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1768 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementType */

/* 1770 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1772 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1774 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 1776 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 1778 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1780 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1782 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1784 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1786 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementInfo */

/* 1788 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 1790 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1792 */	NdrFcShort( 0x4a2 ),	/* Type Offset=1186 */

	/* Parameter ElementsRead */

/* 1794 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1796 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 1798 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 1800 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 1802 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 1804 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1806 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1808 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 1810 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveSubnetElementV4 */

/* 1812 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1814 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1818 */	NdrFcShort( 0x1f ),	/* 31 */
#ifndef _ALPHA_
/* 1820 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 1822 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1824 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1826 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1828 */	NdrFcShort( 0xe ),	/* 14 */
/* 1830 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1832 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1834 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1836 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1838 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1840 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1842 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1844 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1846 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1848 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1850 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1852 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter RemoveElementInfo */

/* 1854 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1856 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1858 */	NdrFcShort( 0x494 ),	/* Type Offset=1172 */

	/* Parameter ForceFlag */

/* 1860 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 1862 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1864 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 1866 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1868 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1870 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateClientInfoV4 */

/* 1872 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1874 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1878 */	NdrFcShort( 0x20 ),	/* 32 */
#ifndef _ALPHA_
/* 1880 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1882 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1884 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1886 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1888 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1890 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1892 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1894 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1896 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1898 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1900 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1902 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1904 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1906 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1908 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1910 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1912 */	NdrFcShort( 0x4d8 ),	/* Type Offset=1240 */

	/* Return value */

/* 1914 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1916 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1918 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetClientInfoV4 */

/* 1920 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1922 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1926 */	NdrFcShort( 0x21 ),	/* 33 */
#ifndef _ALPHA_
/* 1928 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 1930 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1932 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1934 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1936 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1938 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1940 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1942 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1944 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1946 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1948 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1950 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1952 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1954 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1956 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 1958 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 1960 */	NdrFcShort( 0x4d8 ),	/* Type Offset=1240 */

	/* Return value */

/* 1962 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 1964 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 1966 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientInfoV4 */

/* 1968 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1970 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1974 */	NdrFcShort( 0x22 ),	/* 34 */
#ifndef _ALPHA_
/* 1976 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 1978 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 1980 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 1982 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1984 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1986 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1988 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1990 */	0x8,		/* 8 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1992 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1994 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1996 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1998 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2000 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2002 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SearchInfo */

/* 2004 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 2006 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2008 */	NdrFcShort( 0x308 ),	/* Type Offset=776 */

	/* Parameter ClientInfo */

/* 2010 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2012 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2014 */	NdrFcShort( 0x4fc ),	/* Type Offset=1276 */

	/* Return value */

/* 2016 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2018 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2020 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetClientsV4 */

/* 2022 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2024 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2028 */	NdrFcShort( 0x23 ),	/* 35 */
#ifndef _ALPHA_
/* 2030 */	NdrFcShort( 0x20 ),	/* x86 Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 2032 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2034 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2036 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2038 */	NdrFcShort( 0x2c ),	/* 44 */
/* 2040 */	NdrFcShort( 0x5c ),	/* 92 */
/* 2042 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 2044 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2046 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2048 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2050 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2052 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2054 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2056 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 2058 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2060 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2062 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 2064 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
#ifndef _ALPHA_
/* 2066 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2068 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 2070 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2072 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2074 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientInfo */

/* 2076 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2078 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2080 */	NdrFcShort( 0x504 ),	/* Type Offset=1284 */

	/* Parameter ClientsRead */

/* 2082 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 2084 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2086 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientsTotal */

/* 2088 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
#ifndef _ALPHA_
/* 2090 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 2092 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2094 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2096 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 2098 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetSuperScopeV4 */

/* 2100 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2102 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2106 */	NdrFcShort( 0x24 ),	/* 36 */
#ifndef _ALPHA_
/* 2108 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 2110 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2112 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2114 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2116 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2118 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2120 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2122 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2124 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2126 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2128 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2130 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2132 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2134 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 2136 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2138 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2140 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SuperScopeName */

/* 2142 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
#ifndef _ALPHA_
/* 2144 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2146 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ChangeExisting */

/* 2148 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2150 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2152 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2154 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2156 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2158 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetSuperScopeInfoV4 */

/* 2160 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2162 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2166 */	NdrFcShort( 0x25 ),	/* 37 */
#ifndef _ALPHA_
/* 2168 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2170 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2172 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2174 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2178 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2180 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2182 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2184 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2188 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2190 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2192 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2194 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SuperScopeTable */

/* 2196 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2198 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2200 */	NdrFcShort( 0x540 ),	/* Type Offset=1344 */

	/* Return value */

/* 2202 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2204 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2206 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteSuperScopeV4 */

/* 2208 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2210 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2214 */	NdrFcShort( 0x26 ),	/* 38 */
#ifndef _ALPHA_
/* 2216 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2218 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2220 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2222 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2226 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2228 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2230 */	0x8,		/* 8 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2232 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2236 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2238 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2240 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2242 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SuperScopeName */

/* 2244 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 2246 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2248 */	NdrFcShort( 0x596 ),	/* Type Offset=1430 */

	/* Return value */

/* 2250 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2252 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2254 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerSetConfigV4 */

/* 2256 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2258 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2262 */	NdrFcShort( 0x27 ),	/* 39 */
#ifndef _ALPHA_
/* 2264 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 2266 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2268 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2270 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2272 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2274 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2276 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 2278 */	0x8,		/* 8 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 2280 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2282 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2284 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2286 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2288 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2290 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter FieldsToSet */

/* 2292 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
#ifndef _ALPHA_
/* 2294 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2296 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ConfigInfo */

/* 2298 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 2300 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2302 */	NdrFcShort( 0x5a8 ),	/* Type Offset=1448 */

	/* Return value */

/* 2304 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2306 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2308 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerGetConfigV4 */

/* 2310 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2312 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2316 */	NdrFcShort( 0x28 ),	/* 40 */
#ifndef _ALPHA_
/* 2318 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 2320 */	0x31,		/* FC_BIND_GENERIC */
			0x4,		/* 4 */
/* 2322 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2324 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2328 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2330 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2332 */	0x8,		/* 8 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2334 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2338 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2340 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2342 */	NdrFcShort( 0x0 ),	/* x86, alpha Stack size/offset = 0 */
/* 2344 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ConfigInfo */

/* 2346 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
#ifndef _ALPHA_
/* 2348 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 2350 */	NdrFcShort( 0x5e6 ),	/* Type Offset=1510 */

	/* Return value */

/* 2352 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 2354 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 2356 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  4 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x11, 0x0,	/* FC_RP */
/*  8 */	NdrFcShort( 0x22 ),	/* Offset= 34 (42) */
/* 10 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 12 */	NdrFcShort( 0xc ),	/* 12 */
/* 14 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 16 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 18 */	NdrFcShort( 0x4 ),	/* 4 */
/* 20 */	NdrFcShort( 0x4 ),	/* 4 */
/* 22 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 24 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 26 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 28 */	NdrFcShort( 0x8 ),	/* 8 */
/* 30 */	NdrFcShort( 0x8 ),	/* 8 */
/* 32 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 34 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 36 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 38 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 40 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 42 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 44 */	NdrFcShort( 0x20 ),	/* 32 */
/* 46 */	NdrFcShort( 0x0 ),	/* 0 */
/* 48 */	NdrFcShort( 0xc ),	/* Offset= 12 (60) */
/* 50 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 52 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 54 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 56 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (10) */
/* 58 */	0xd,		/* FC_ENUM16 */
			0x5b,		/* FC_END */
/* 60 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 62 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 64 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 66 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 68 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 70 */	NdrFcShort( 0x2 ),	/* Offset= 2 (72) */
/* 72 */	
			0x12, 0x0,	/* FC_UP */
/* 74 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (42) */
/* 76 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 78 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 80 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 82 */	NdrFcShort( 0x2 ),	/* Offset= 2 (84) */
/* 84 */	
			0x12, 0x0,	/* FC_UP */
/* 86 */	NdrFcShort( 0xe ),	/* Offset= 14 (100) */
/* 88 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 90 */	NdrFcShort( 0x4 ),	/* 4 */
/* 92 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 98 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 100 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 102 */	NdrFcShort( 0x8 ),	/* 8 */
/* 104 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 106 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 108 */	NdrFcShort( 0x4 ),	/* 4 */
/* 110 */	NdrFcShort( 0x4 ),	/* 4 */
/* 112 */	0x12, 0x0,	/* FC_UP */
/* 114 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (88) */
/* 116 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 118 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 120 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 122 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 124 */	
			0x11, 0x0,	/* FC_RP */
/* 126 */	NdrFcShort( 0x78 ),	/* Offset= 120 (246) */
/* 128 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 130 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 132 */	NdrFcShort( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 136 */	NdrFcShort( 0x2 ),	/* Offset= 2 (138) */
/* 138 */	NdrFcShort( 0x4 ),	/* 4 */
/* 140 */	NdrFcShort( 0x5 ),	/* 5 */
/* 142 */	NdrFcLong( 0x0 ),	/* 0 */
/* 146 */	NdrFcShort( 0x1c ),	/* Offset= 28 (174) */
/* 148 */	NdrFcLong( 0x1 ),	/* 1 */
/* 152 */	NdrFcShort( 0x22 ),	/* Offset= 34 (186) */
/* 154 */	NdrFcLong( 0x2 ),	/* 2 */
/* 158 */	NdrFcShort( 0x20 ),	/* Offset= 32 (190) */
/* 160 */	NdrFcLong( 0x3 ),	/* 3 */
/* 164 */	NdrFcShort( 0xa ),	/* Offset= 10 (174) */
/* 166 */	NdrFcLong( 0x4 ),	/* 4 */
/* 170 */	NdrFcShort( 0x4 ),	/* Offset= 4 (174) */
/* 172 */	NdrFcShort( 0x0 ),	/* Offset= 0 (172) */
/* 174 */	
			0x12, 0x0,	/* FC_UP */
/* 176 */	NdrFcShort( 0x2 ),	/* Offset= 2 (178) */
/* 178 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 180 */	NdrFcShort( 0x8 ),	/* 8 */
/* 182 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 184 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 186 */	
			0x12, 0x0,	/* FC_UP */
/* 188 */	NdrFcShort( 0xffffff4e ),	/* Offset= -178 (10) */
/* 190 */	
			0x12, 0x0,	/* FC_UP */
/* 192 */	NdrFcShort( 0x22 ),	/* Offset= 34 (226) */
/* 194 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 196 */	NdrFcShort( 0x1 ),	/* 1 */
/* 198 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 202 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 204 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 206 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 208 */	NdrFcShort( 0x8 ),	/* 8 */
/* 210 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 212 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 214 */	NdrFcShort( 0x4 ),	/* 4 */
/* 216 */	NdrFcShort( 0x4 ),	/* 4 */
/* 218 */	0x12, 0x0,	/* FC_UP */
/* 220 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (194) */
/* 222 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 224 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 226 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 228 */	NdrFcShort( 0x8 ),	/* 8 */
/* 230 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 232 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 234 */	NdrFcShort( 0x4 ),	/* 4 */
/* 236 */	NdrFcShort( 0x4 ),	/* 4 */
/* 238 */	0x12, 0x0,	/* FC_UP */
/* 240 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (206) */
/* 242 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 244 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 246 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 248 */	NdrFcShort( 0x8 ),	/* 8 */
/* 250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 252 */	NdrFcShort( 0x0 ),	/* Offset= 0 (252) */
/* 254 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 256 */	0x0,		/* 0 */
			NdrFcShort( 0xffffff7f ),	/* Offset= -129 (128) */
			0x5b,		/* FC_END */
/* 260 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 262 */	NdrFcShort( 0x2 ),	/* Offset= 2 (264) */
/* 264 */	
			0x12, 0x0,	/* FC_UP */
/* 266 */	NdrFcShort( 0x18 ),	/* Offset= 24 (290) */
/* 268 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 272 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 274 */	NdrFcShort( 0x0 ),	/* 0 */
/* 276 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 278 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 282 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 284 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 286 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (246) */
/* 288 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 290 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 292 */	NdrFcShort( 0x8 ),	/* 8 */
/* 294 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 296 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 298 */	NdrFcShort( 0x4 ),	/* 4 */
/* 300 */	NdrFcShort( 0x4 ),	/* 4 */
/* 302 */	0x12, 0x0,	/* FC_UP */
/* 304 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (268) */
/* 306 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 308 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 310 */	
			0x11, 0x0,	/* FC_RP */
/* 312 */	NdrFcShort( 0x7a ),	/* Offset= 122 (434) */
/* 314 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 316 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 318 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 320 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 322 */	NdrFcShort( 0x2 ),	/* Offset= 2 (324) */
/* 324 */	NdrFcShort( 0x8 ),	/* 8 */
/* 326 */	NdrFcShort( 0x8 ),	/* 8 */
/* 328 */	NdrFcLong( 0x0 ),	/* 0 */
/* 332 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 334 */	NdrFcLong( 0x1 ),	/* 1 */
/* 338 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 340 */	NdrFcLong( 0x2 ),	/* 2 */
/* 344 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 346 */	NdrFcLong( 0x3 ),	/* 3 */
/* 350 */	NdrFcShort( 0xffffff54 ),	/* Offset= -172 (178) */
/* 352 */	NdrFcLong( 0x4 ),	/* 4 */
/* 356 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 358 */	NdrFcLong( 0x5 ),	/* 5 */
/* 362 */	NdrFcShort( 0xfffffe98 ),	/* Offset= -360 (2) */
/* 364 */	NdrFcLong( 0x6 ),	/* 6 */
/* 368 */	NdrFcShort( 0xffffff5e ),	/* Offset= -162 (206) */
/* 370 */	NdrFcLong( 0x7 ),	/* 7 */
/* 374 */	NdrFcShort( 0xffffff58 ),	/* Offset= -168 (206) */
/* 376 */	NdrFcShort( 0x0 ),	/* Offset= 0 (376) */
/* 378 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 380 */	NdrFcShort( 0xc ),	/* 12 */
/* 382 */	NdrFcShort( 0x0 ),	/* 0 */
/* 384 */	NdrFcShort( 0x0 ),	/* Offset= 0 (384) */
/* 386 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 388 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffb5 ),	/* Offset= -75 (314) */
			0x5b,		/* FC_END */
/* 392 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 394 */	NdrFcShort( 0x0 ),	/* 0 */
/* 396 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 398 */	NdrFcShort( 0x0 ),	/* 0 */
/* 400 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 402 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 406 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 408 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 410 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (378) */
/* 412 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 414 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 416 */	NdrFcShort( 0x8 ),	/* 8 */
/* 418 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 420 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 422 */	NdrFcShort( 0x4 ),	/* 4 */
/* 424 */	NdrFcShort( 0x4 ),	/* 4 */
/* 426 */	0x12, 0x0,	/* FC_UP */
/* 428 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (392) */
/* 430 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 432 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 434 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 436 */	NdrFcShort( 0x18 ),	/* 24 */
/* 438 */	NdrFcShort( 0x0 ),	/* 0 */
/* 440 */	NdrFcShort( 0xc ),	/* Offset= 12 (452) */
/* 442 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 444 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 446 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffdf ),	/* Offset= -33 (414) */
			0xd,		/* FC_ENUM16 */
/* 450 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 452 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 454 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 456 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 458 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 460 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 462 */	NdrFcShort( 0x2 ),	/* Offset= 2 (464) */
/* 464 */	
			0x12, 0x0,	/* FC_UP */
/* 466 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (434) */
/* 468 */	
			0x11, 0x0,	/* FC_RP */
/* 470 */	NdrFcShort( 0x30 ),	/* Offset= 48 (518) */
/* 472 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 474 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 476 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 478 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 480 */	NdrFcShort( 0x2 ),	/* Offset= 2 (482) */
/* 482 */	NdrFcShort( 0x8 ),	/* 8 */
/* 484 */	NdrFcShort( 0x5 ),	/* 5 */
/* 486 */	NdrFcLong( 0x0 ),	/* 0 */
/* 490 */	NdrFcShort( 0x0 ),	/* Offset= 0 (490) */
/* 492 */	NdrFcLong( 0x1 ),	/* 1 */
/* 496 */	NdrFcShort( 0x0 ),	/* Offset= 0 (496) */
/* 498 */	NdrFcLong( 0x2 ),	/* 2 */
/* 502 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 504 */	NdrFcLong( 0x3 ),	/* 3 */
/* 508 */	NdrFcShort( 0xfffffeb6 ),	/* Offset= -330 (178) */
/* 510 */	NdrFcLong( 0x4 ),	/* 4 */
/* 514 */	NdrFcShort( 0xfffffe00 ),	/* Offset= -512 (2) */
/* 516 */	NdrFcShort( 0x0 ),	/* Offset= 0 (516) */
/* 518 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 520 */	NdrFcShort( 0xc ),	/* 12 */
/* 522 */	NdrFcShort( 0x0 ),	/* 0 */
/* 524 */	NdrFcShort( 0x0 ),	/* Offset= 0 (524) */
/* 526 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 528 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffc7 ),	/* Offset= -57 (472) */
			0x5b,		/* FC_END */
/* 532 */	
			0x11, 0x0,	/* FC_RP */
/* 534 */	NdrFcShort( 0xffffff88 ),	/* Offset= -120 (414) */
/* 536 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 538 */	NdrFcShort( 0x2 ),	/* Offset= 2 (540) */
/* 540 */	
			0x12, 0x0,	/* FC_UP */
/* 542 */	NdrFcShort( 0x18 ),	/* Offset= 24 (566) */
/* 544 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 546 */	NdrFcShort( 0x0 ),	/* 0 */
/* 548 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 550 */	NdrFcShort( 0x4 ),	/* 4 */
/* 552 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 554 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 558 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 560 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 562 */	NdrFcShort( 0xffffff48 ),	/* Offset= -184 (378) */
/* 564 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 566 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 568 */	NdrFcShort( 0xc ),	/* 12 */
/* 570 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 572 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 574 */	NdrFcShort( 0x8 ),	/* 8 */
/* 576 */	NdrFcShort( 0x8 ),	/* 8 */
/* 578 */	0x12, 0x0,	/* FC_UP */
/* 580 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (544) */
/* 582 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 584 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 586 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 588 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 590 */	NdrFcShort( 0x2 ),	/* Offset= 2 (592) */
/* 592 */	
			0x12, 0x0,	/* FC_UP */
/* 594 */	NdrFcShort( 0x24 ),	/* Offset= 36 (630) */
/* 596 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 598 */	NdrFcShort( 0xc ),	/* 12 */
/* 600 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 602 */	NdrFcShort( 0x0 ),	/* 0 */
/* 604 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 606 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 608 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 610 */	NdrFcShort( 0xc ),	/* 12 */
/* 612 */	NdrFcShort( 0x0 ),	/* 0 */
/* 614 */	NdrFcShort( 0x1 ),	/* 1 */
/* 616 */	NdrFcShort( 0x8 ),	/* 8 */
/* 618 */	NdrFcShort( 0x8 ),	/* 8 */
/* 620 */	0x12, 0x0,	/* FC_UP */
/* 622 */	NdrFcShort( 0xffffffb2 ),	/* Offset= -78 (544) */
/* 624 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 626 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffc3 ),	/* Offset= -61 (566) */
			0x5b,		/* FC_END */
/* 630 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 632 */	NdrFcShort( 0x8 ),	/* 8 */
/* 634 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 636 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 638 */	NdrFcShort( 0x4 ),	/* 4 */
/* 640 */	NdrFcShort( 0x4 ),	/* 4 */
/* 642 */	0x12, 0x0,	/* FC_UP */
/* 644 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (596) */
/* 646 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 648 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 650 */	
			0x11, 0x0,	/* FC_RP */
/* 652 */	NdrFcShort( 0xe ),	/* Offset= 14 (666) */
/* 654 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 656 */	NdrFcShort( 0x1 ),	/* 1 */
/* 658 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 660 */	NdrFcShort( 0x8 ),	/* 8 */
/* 662 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 664 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 666 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 668 */	NdrFcShort( 0x2c ),	/* 44 */
/* 670 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 672 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 674 */	NdrFcShort( 0xc ),	/* 12 */
/* 676 */	NdrFcShort( 0xc ),	/* 12 */
/* 678 */	0x12, 0x0,	/* FC_UP */
/* 680 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (654) */
/* 682 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 684 */	NdrFcShort( 0x10 ),	/* 16 */
/* 686 */	NdrFcShort( 0x10 ),	/* 16 */
/* 688 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 690 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 692 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 694 */	NdrFcShort( 0x14 ),	/* 20 */
/* 696 */	NdrFcShort( 0x14 ),	/* 20 */
/* 698 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 700 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 702 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 704 */	NdrFcShort( 0x24 ),	/* 36 */
/* 706 */	NdrFcShort( 0x24 ),	/* 36 */
/* 708 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 710 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 712 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 714 */	NdrFcShort( 0x28 ),	/* 40 */
/* 716 */	NdrFcShort( 0x28 ),	/* 40 */
/* 718 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 720 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 722 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 724 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 726 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 728 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 730 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffdd7 ),	/* Offset= -553 (178) */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 734 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd2b ),	/* Offset= -725 (10) */
			0x5b,		/* FC_END */
/* 738 */	
			0x11, 0x0,	/* FC_RP */
/* 740 */	NdrFcShort( 0x24 ),	/* Offset= 36 (776) */
/* 742 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 744 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 746 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 748 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 750 */	NdrFcShort( 0x2 ),	/* Offset= 2 (752) */
/* 752 */	NdrFcShort( 0x8 ),	/* 8 */
/* 754 */	NdrFcShort( 0x3 ),	/* 3 */
/* 756 */	NdrFcLong( 0x0 ),	/* 0 */
/* 760 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 762 */	NdrFcLong( 0x1 ),	/* 1 */
/* 766 */	NdrFcShort( 0xfffffdd0 ),	/* Offset= -560 (206) */
/* 768 */	NdrFcLong( 0x2 ),	/* 2 */
/* 772 */	NdrFcShort( 0xfffffcfe ),	/* Offset= -770 (2) */
/* 774 */	NdrFcShort( 0x0 ),	/* Offset= 0 (774) */
/* 776 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 778 */	NdrFcShort( 0xc ),	/* 12 */
/* 780 */	NdrFcShort( 0x0 ),	/* 0 */
/* 782 */	NdrFcShort( 0x0 ),	/* Offset= 0 (782) */
/* 784 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 786 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffd3 ),	/* Offset= -45 (742) */
			0x5b,		/* FC_END */
/* 790 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 792 */	NdrFcShort( 0x2 ),	/* Offset= 2 (794) */
/* 794 */	
			0x12, 0x0,	/* FC_UP */
/* 796 */	NdrFcShort( 0xffffff7e ),	/* Offset= -130 (666) */
/* 798 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 800 */	NdrFcShort( 0x2 ),	/* Offset= 2 (802) */
/* 802 */	
			0x12, 0x0,	/* FC_UP */
/* 804 */	NdrFcShort( 0x22 ),	/* Offset= 34 (838) */
/* 806 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 808 */	NdrFcShort( 0x4 ),	/* 4 */
/* 810 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 812 */	NdrFcShort( 0x0 ),	/* 0 */
/* 814 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 816 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 818 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 820 */	NdrFcShort( 0x4 ),	/* 4 */
/* 822 */	NdrFcShort( 0x0 ),	/* 0 */
/* 824 */	NdrFcShort( 0x1 ),	/* 1 */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 828 */	NdrFcShort( 0x0 ),	/* 0 */
/* 830 */	0x12, 0x0,	/* FC_UP */
/* 832 */	NdrFcShort( 0xffffff5a ),	/* Offset= -166 (666) */
/* 834 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 836 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 838 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 840 */	NdrFcShort( 0x8 ),	/* 8 */
/* 842 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 844 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 846 */	NdrFcShort( 0x4 ),	/* 4 */
/* 848 */	NdrFcShort( 0x4 ),	/* 4 */
/* 850 */	0x12, 0x0,	/* FC_UP */
/* 852 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (806) */
/* 854 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 856 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 858 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 860 */	NdrFcShort( 0x2 ),	/* Offset= 2 (862) */
/* 862 */	
			0x12, 0x0,	/* FC_UP */
/* 864 */	NdrFcShort( 0x1c ),	/* Offset= 28 (892) */
/* 866 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 868 */	NdrFcShort( 0x10 ),	/* 16 */
/* 870 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 872 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 874 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 876 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 878 */	NdrFcShort( 0x10 ),	/* 16 */
/* 880 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 882 */	NdrFcShort( 0x24 ),	/* 36 */
/* 884 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 886 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 888 */	NdrFcShort( 0xffffffea ),	/* Offset= -22 (866) */
/* 890 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 892 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 894 */	NdrFcShort( 0x2c ),	/* 44 */
/* 896 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 898 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 900 */	NdrFcShort( 0x28 ),	/* 40 */
/* 902 */	NdrFcShort( 0x28 ),	/* 40 */
/* 904 */	0x12, 0x0,	/* FC_UP */
/* 906 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (876) */
/* 908 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 910 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 912 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 914 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 916 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 918 */	NdrFcShort( 0xfffffd1c ),	/* Offset= -740 (178) */
/* 920 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 922 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 924 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 926 */	NdrFcShort( 0x2 ),	/* Offset= 2 (928) */
/* 928 */	
			0x12, 0x0,	/* FC_UP */
/* 930 */	NdrFcShort( 0x18 ),	/* Offset= 24 (954) */
/* 932 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 934 */	NdrFcShort( 0x0 ),	/* 0 */
/* 936 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 938 */	NdrFcShort( 0x0 ),	/* 0 */
/* 940 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 942 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 946 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 948 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 950 */	NdrFcShort( 0xfffffdfc ),	/* Offset= -516 (434) */
/* 952 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 954 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 956 */	NdrFcShort( 0x8 ),	/* 8 */
/* 958 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 960 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 962 */	NdrFcShort( 0x4 ),	/* 4 */
/* 964 */	NdrFcShort( 0x4 ),	/* 4 */
/* 966 */	0x12, 0x0,	/* FC_UP */
/* 968 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (932) */
/* 970 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 972 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 974 */	
			0x11, 0x0,	/* FC_RP */
/* 976 */	NdrFcShort( 0xfffffea6 ),	/* Offset= -346 (630) */
/* 978 */	
			0x11, 0x0,	/* FC_RP */
/* 980 */	NdrFcShort( 0x2 ),	/* Offset= 2 (982) */
/* 982 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 984 */	NdrFcShort( 0x24 ),	/* 36 */
/* 986 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 988 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 990 */	NdrFcShort( 0x4 ),	/* 4 */
/* 992 */	NdrFcShort( 0x4 ),	/* 4 */
/* 994 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 996 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 998 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1000 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1002 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1004 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1006 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1008 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1010 */	NdrFcShort( 0xc ),	/* 12 */
/* 1012 */	NdrFcShort( 0xc ),	/* 12 */
/* 1014 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1016 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1018 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1020 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1022 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1024 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1026 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1028 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1030 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1032 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1034) */
/* 1034 */	
			0x12, 0x0,	/* FC_UP */
/* 1036 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (982) */
/* 1038 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1040 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1042) */
/* 1042 */	
			0x12, 0x0,	/* FC_UP */
/* 1044 */	NdrFcShort( 0x24 ),	/* Offset= 36 (1080) */
/* 1046 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1048 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1050 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1052 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1052) */
/* 1054 */	0x8,		/* FC_LONG */
			0xd,		/* FC_ENUM16 */
/* 1056 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1058 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1060 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1062 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1064 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1066 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1068 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1072 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1074 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1076 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1046) */
/* 1078 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1080 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1082 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1084 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1086 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1088 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1090 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1092 */	0x12, 0x0,	/* FC_UP */
/* 1094 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1058) */
/* 1096 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1098 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1100 */	
			0x11, 0x0,	/* FC_RP */
/* 1102 */	NdrFcShort( 0x46 ),	/* Offset= 70 (1172) */
/* 1104 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 1106 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 1108 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1110 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1112 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1114) */
/* 1114 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1116 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1118 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1122 */	NdrFcShort( 0xfffffc4c ),	/* Offset= -948 (174) */
/* 1124 */	NdrFcLong( 0x1 ),	/* 1 */
/* 1128 */	NdrFcShort( 0xfffffc52 ),	/* Offset= -942 (186) */
/* 1130 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1134 */	NdrFcShort( 0x10 ),	/* Offset= 16 (1150) */
/* 1136 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1140 */	NdrFcShort( 0xfffffc3a ),	/* Offset= -966 (174) */
/* 1142 */	NdrFcLong( 0x4 ),	/* 4 */
/* 1146 */	NdrFcShort( 0xfffffc34 ),	/* Offset= -972 (174) */
/* 1148 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1148) */
/* 1150 */	
			0x12, 0x0,	/* FC_UP */
/* 1152 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1154) */
/* 1154 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1156 */	NdrFcShort( 0xc ),	/* 12 */
/* 1158 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1160 */	NdrFcShort( 0x8 ),	/* Offset= 8 (1168) */
/* 1162 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 1164 */	0x2,		/* FC_CHAR */
			0x3f,		/* FC_STRUCTPAD3 */
/* 1166 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1168 */	
			0x12, 0x0,	/* FC_UP */
/* 1170 */	NdrFcShort( 0xfffffc3c ),	/* Offset= -964 (206) */
/* 1172 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 1174 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1178 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1178) */
/* 1180 */	0xd,		/* FC_ENUM16 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1182 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffb1 ),	/* Offset= -79 (1104) */
			0x5b,		/* FC_END */
/* 1186 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1188 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1190) */
/* 1190 */	
			0x12, 0x0,	/* FC_UP */
/* 1192 */	NdrFcShort( 0x18 ),	/* Offset= 24 (1216) */
/* 1194 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1198 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1202 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1204 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1208 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1210 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1212 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (1172) */
/* 1214 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1216 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1218 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1220 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1222 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1224 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1226 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1228 */	0x12, 0x0,	/* FC_UP */
/* 1230 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1194) */
/* 1232 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1234 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1236 */	
			0x11, 0x0,	/* FC_RP */
/* 1238 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1240) */
/* 1240 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1242 */	NdrFcShort( 0x30 ),	/* 48 */
/* 1244 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1246 */	NdrFcShort( 0x16 ),	/* Offset= 22 (1268) */
/* 1248 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1250 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1252 */	NdrFcShort( 0xfffffbea ),	/* Offset= -1046 (206) */
/* 1254 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 1256 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1258 */	NdrFcShort( 0xfffffbc8 ),	/* Offset= -1080 (178) */
/* 1260 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1262 */	NdrFcShort( 0xfffffb1c ),	/* Offset= -1252 (10) */
/* 1264 */	0x2,		/* FC_CHAR */
			0x3f,		/* FC_STRUCTPAD3 */
/* 1266 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1268 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1270 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1272 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1274 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1276 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1278 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1280) */
/* 1280 */	
			0x12, 0x0,	/* FC_UP */
/* 1282 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1240) */
/* 1284 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1286 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1288) */
/* 1288 */	
			0x12, 0x0,	/* FC_UP */
/* 1290 */	NdrFcShort( 0x22 ),	/* Offset= 34 (1324) */
/* 1292 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1294 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1296 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1298 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1300 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1302 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1304 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1306 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1308 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1310 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1312 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1314 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1316 */	0x12, 0x0,	/* FC_UP */
/* 1318 */	NdrFcShort( 0xffffffb2 ),	/* Offset= -78 (1240) */
/* 1320 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1322 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1324 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1326 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1328 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1330 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1332 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1334 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1336 */	0x12, 0x0,	/* FC_UP */
/* 1338 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (1292) */
/* 1340 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1342 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1344 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1346 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1348) */
/* 1348 */	
			0x12, 0x0,	/* FC_UP */
/* 1350 */	NdrFcShort( 0x3a ),	/* Offset= 58 (1408) */
/* 1352 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1354 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1356 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1358 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1360 */	NdrFcShort( 0xc ),	/* 12 */
/* 1362 */	NdrFcShort( 0xc ),	/* 12 */
/* 1364 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1366 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1368 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1370 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1372 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1374 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1376 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1378 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1380 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1382 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1384 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1386 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 1388 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1390 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1392 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1394 */	NdrFcShort( 0xc ),	/* 12 */
/* 1396 */	NdrFcShort( 0xc ),	/* 12 */
/* 1398 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1400 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1402 */	
			0x5b,		/* FC_END */

			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1404 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffcb ),	/* Offset= -53 (1352) */
			0x5b,		/* FC_END */
/* 1408 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1410 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1412 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1414 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1416 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1418 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1420 */	0x12, 0x0,	/* FC_UP */
/* 1422 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (1374) */
/* 1424 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1426 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1428 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1430 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1432 */	
			0x11, 0x0,	/* FC_RP */
/* 1434 */	NdrFcShort( 0xe ),	/* Offset= 14 (1448) */
/* 1436 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1438 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1440 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1442 */	NdrFcShort( 0x28 ),	/* 40 */
/* 1444 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1446 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 1448 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1450 */	NdrFcShort( 0x34 ),	/* 52 */
/* 1452 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1454 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1456 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1458 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1460 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1462 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1464 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1466 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1468 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1470 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1472 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1474 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1476 */	NdrFcShort( 0xc ),	/* 12 */
/* 1478 */	NdrFcShort( 0xc ),	/* 12 */
/* 1480 */	0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1482 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1484 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1486 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1488 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1490 */	0x12, 0x0,	/* FC_UP */
/* 1492 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (1436) */
/* 1494 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1496 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1498 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1500 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1502 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1504 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1506 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1508 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1510 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1512 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1514) */
/* 1514 */	
			0x12, 0x0,	/* FC_UP */
/* 1516 */	NdrFcShort( 0xffffffbc ),	/* Offset= -68 (1448) */

			0x0
        }
    };

static void __RPC_USER dhcpsrv__DHCP_SUBNET_ELEMENT_DATAExprEval_0000( PMIDL_STUB_MESSAGE pStubMsg )
{
    struct _DHCP_SUBNET_ELEMENT_DATA __RPC_FAR *pS	=	( struct _DHCP_SUBNET_ELEMENT_DATA __RPC_FAR * )(pStubMsg->StackTop - 4);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = ( unsigned long ) ( pS->ElementType <= DhcpIpRangesBootpOnly && DhcpIpRangesDhcpOnly <= pS->ElementType ? 0 : pS->ElementType );
}

static void __RPC_USER dhcpsrv__DHCP_SUBNET_ELEMENT_DATA_V4ExprEval_0001( PMIDL_STUB_MESSAGE pStubMsg )
{
    struct _DHCP_SUBNET_ELEMENT_DATA_V4 __RPC_FAR *pS	=	( struct _DHCP_SUBNET_ELEMENT_DATA_V4 __RPC_FAR * )(pStubMsg->StackTop - 4);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = ( unsigned long ) ( pS->ElementType <= DhcpIpRangesBootpOnly && DhcpIpRangesDhcpOnly <= pS->ElementType ? 0 : pS->ElementType );
}

static const EXPR_EVAL ExprEvalRoutines[] = 
    {
    dhcpsrv__DHCP_SUBNET_ELEMENT_DATAExprEval_0000
    ,dhcpsrv__DHCP_SUBNET_ELEMENT_DATA_V4ExprEval_0001
    };


static const unsigned short dhcpsrv_FormatStringOffsetTable[] =
    {
    0,
    54,
    108,
    162,
    234,
    288,
    372,
    432,
    486,
    540,
    594,
    648,
    696,
    756,
    816,
    894,
    948,
    996,
    1044,
    1098,
    1146,
    1224,
    1284,
    1332,
    1404,
    1458,
    1512,
    1560,
    1620,
    1674,
    1728,
    1812,
    1872,
    1920,
    1968,
    2022,
    2100,
    2160,
    2208,
    2256,
    2310
    };


static const MIDL_STUB_DESC dhcpsrv_StubDesc = 
    {
    (void __RPC_FAR *)& dhcpsrv___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    ExprEvalRoutines,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000143, /* MIDL Version 6.0.323 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION dhcpsrv_table[] =
    {
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE dhcpsrv_DispatchTable = 
    {
    41,
    dhcpsrv_table
    };

static const SERVER_ROUTINE dhcpsrv_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)R_DhcpCreateSubnet,
    (SERVER_ROUTINE)R_DhcpSetSubnetInfo,
    (SERVER_ROUTINE)R_DhcpGetSubnetInfo,
    (SERVER_ROUTINE)R_DhcpEnumSubnets,
    (SERVER_ROUTINE)R_DhcpAddSubnetElement,
    (SERVER_ROUTINE)R_DhcpEnumSubnetElements,
    (SERVER_ROUTINE)R_DhcpRemoveSubnetElement,
    (SERVER_ROUTINE)R_DhcpDeleteSubnet,
    (SERVER_ROUTINE)R_DhcpCreateOption,
    (SERVER_ROUTINE)R_DhcpSetOptionInfo,
    (SERVER_ROUTINE)R_DhcpGetOptionInfo,
    (SERVER_ROUTINE)R_DhcpRemoveOption,
    (SERVER_ROUTINE)R_DhcpSetOptionValue,
    (SERVER_ROUTINE)R_DhcpGetOptionValue,
    (SERVER_ROUTINE)R_DhcpEnumOptionValues,
    (SERVER_ROUTINE)R_DhcpRemoveOptionValue,
    (SERVER_ROUTINE)R_DhcpCreateClientInfo,
    (SERVER_ROUTINE)R_DhcpSetClientInfo,
    (SERVER_ROUTINE)R_DhcpGetClientInfo,
    (SERVER_ROUTINE)R_DhcpDeleteClientInfo,
    (SERVER_ROUTINE)R_DhcpEnumSubnetClients,
    (SERVER_ROUTINE)R_DhcpGetClientOptions,
    (SERVER_ROUTINE)R_DhcpGetMibInfo,
    (SERVER_ROUTINE)R_DhcpEnumOptions,
    (SERVER_ROUTINE)R_DhcpSetOptionValues,
    (SERVER_ROUTINE)R_DhcpServerSetConfig,
    (SERVER_ROUTINE)R_DhcpServerGetConfig,
    (SERVER_ROUTINE)R_DhcpScanDatabase,
    (SERVER_ROUTINE)R_DhcpGetVersion,
    (SERVER_ROUTINE)R_DhcpAddSubnetElementV4,
    (SERVER_ROUTINE)R_DhcpEnumSubnetElementsV4,
    (SERVER_ROUTINE)R_DhcpRemoveSubnetElementV4,
    (SERVER_ROUTINE)R_DhcpCreateClientInfoV4,
    (SERVER_ROUTINE)R_DhcpSetClientInfoV4,
    (SERVER_ROUTINE)R_DhcpGetClientInfoV4,
    (SERVER_ROUTINE)R_DhcpEnumSubnetClientsV4,
    (SERVER_ROUTINE)R_DhcpSetSuperScopeV4,
    (SERVER_ROUTINE)R_DhcpGetSuperScopeInfoV4,
    (SERVER_ROUTINE)R_DhcpDeleteSuperScopeV4,
    (SERVER_ROUTINE)R_DhcpServerSetConfigV4,
    (SERVER_ROUTINE)R_DhcpServerGetConfigV4
    };

static const MIDL_SERVER_INFO dhcpsrv_ServerInfo = 
    {
    &dhcpsrv_StubDesc,
    dhcpsrv_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    dhcpsrv_FormatStringOffsetTable,
    0,
    0,
    0,
    0};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the RPC server stubs */


 /* File created by MIDL compiler version 6.00.0323 */
/* Compiler settings for dhcp_srv.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, oldnames, robust dhcp_bug_compatibility
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#include <string.h>
#include "dhcp_srv.h"

#define TYPE_FORMAT_STRING_SIZE   1331                              
#define PROC_FORMAT_STRING_SIZE   2441                              
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;

/* Standard interface: dhcpsrv, ver. 1.0,
   GUID={0x6BFFD098,0xA112,0x3610,{0x98,0x33,0x46,0xC3,0xF8,0x74,0x53,0x2D}} */


extern const MIDL_SERVER_INFO dhcpsrv_ServerInfo;

extern RPC_DISPATCH_TABLE dhcpsrv_DispatchTable;

static const RPC_SERVER_INTERFACE dhcpsrv___RpcServerInterface =
    {
    sizeof(RPC_SERVER_INTERFACE),
    {{0x6BFFD098,0xA112,0x3610,{0x98,0x33,0x46,0xC3,0xF8,0x74,0x53,0x2D}},{1,0}},
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    &dhcpsrv_DispatchTable,
    0,
    0,
    0,
    &dhcpsrv_ServerInfo,
    0x04000000
    };
RPC_IF_HANDLE dhcpsrv_ServerIfHandle = (RPC_IF_HANDLE)& dhcpsrv___RpcServerInterface;

extern const MIDL_STUB_DESC dhcpsrv_StubDesc;

extern const EXPR_EVAL ExprEvalRoutines[];

#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure R_DhcpCreateSubnet */

			0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x0 ),	/* 0 */
/*  8 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 10 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 12 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 14 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 16 */	NdrFcShort( 0x8 ),	/* 8 */
/* 18 */	NdrFcShort( 0x8 ),	/* 8 */
/* 20 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 22 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */
/* 26 */	NdrFcShort( 0x0 ),	/* 0 */
/* 28 */	NdrFcShort( 0x0 ),	/* 0 */
/* 30 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 32 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 34 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 36 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 38 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 40 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 42 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 44 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 46 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 48 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Return value */

/* 50 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 52 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 54 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetSubnetInfo */

/* 56 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 58 */	NdrFcLong( 0x0 ),	/* 0 */
/* 62 */	NdrFcShort( 0x1 ),	/* 1 */
/* 64 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 66 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 68 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 70 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 72 */	NdrFcShort( 0x8 ),	/* 8 */
/* 74 */	NdrFcShort( 0x8 ),	/* 8 */
/* 76 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 78 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 80 */	NdrFcShort( 0x0 ),	/* 0 */
/* 82 */	NdrFcShort( 0x0 ),	/* 0 */
/* 84 */	NdrFcShort( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 88 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 90 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 92 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 94 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 96 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 98 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 100 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 102 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 104 */	NdrFcShort( 0x20 ),	/* Type Offset=32 */

	/* Return value */

/* 106 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 108 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 110 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetSubnetInfo */

/* 112 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 114 */	NdrFcLong( 0x0 ),	/* 0 */
/* 118 */	NdrFcShort( 0x2 ),	/* 2 */
/* 120 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 122 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 124 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 126 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 128 */	NdrFcShort( 0x8 ),	/* 8 */
/* 130 */	NdrFcShort( 0x8 ),	/* 8 */
/* 132 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 134 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 136 */	NdrFcShort( 0x0 ),	/* 0 */
/* 138 */	NdrFcShort( 0x0 ),	/* 0 */
/* 140 */	NdrFcShort( 0x0 ),	/* 0 */
/* 142 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 144 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 146 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 148 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 150 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 152 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SubnetInfo */

/* 156 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 158 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 160 */	NdrFcShort( 0x3c ),	/* Type Offset=60 */

	/* Return value */

/* 162 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 164 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 166 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnets */

/* 168 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 170 */	NdrFcLong( 0x0 ),	/* 0 */
/* 174 */	NdrFcShort( 0x3 ),	/* 3 */
/* 176 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 178 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 180 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 182 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 184 */	NdrFcShort( 0x24 ),	/* 36 */
/* 186 */	NdrFcShort( 0x5c ),	/* 92 */
/* 188 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 190 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 192 */	NdrFcShort( 0x1 ),	/* 1 */
/* 194 */	NdrFcShort( 0x0 ),	/* 0 */
/* 196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 200 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 202 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 204 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ResumeHandle */

/* 206 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 208 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 210 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 212 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 214 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 216 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumInfo */

/* 218 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 220 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 222 */	NdrFcShort( 0x48 ),	/* Type Offset=72 */

	/* Parameter ElementsRead */

/* 224 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 226 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 228 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 230 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 232 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 234 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 236 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 238 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 240 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpAddSubnetElement */

/* 242 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 244 */	NdrFcLong( 0x0 ),	/* 0 */
/* 248 */	NdrFcShort( 0x4 ),	/* 4 */
/* 250 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 252 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 254 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 256 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 258 */	NdrFcShort( 0x8 ),	/* 8 */
/* 260 */	NdrFcShort( 0x8 ),	/* 8 */
/* 262 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 264 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 268 */	NdrFcShort( 0x2 ),	/* 2 */
/* 270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 272 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 274 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 276 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 278 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 280 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 282 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 284 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter AddElementInfo */

/* 286 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 288 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 290 */	NdrFcShort( 0xe2 ),	/* Type Offset=226 */

	/* Return value */

/* 292 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 294 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 296 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetElements */

/* 298 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 300 */	NdrFcLong( 0x0 ),	/* 0 */
/* 304 */	NdrFcShort( 0x5 ),	/* 5 */
/* 306 */	NdrFcShort( 0x48 ),	/* ia64, axp64 Stack size/offset = 72 */
/* 308 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 310 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 312 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 314 */	NdrFcShort( 0x32 ),	/* 50 */
/* 316 */	NdrFcShort( 0x5c ),	/* 92 */
/* 318 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x9,		/* 9 */
/* 320 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 322 */	NdrFcShort( 0x3 ),	/* 3 */
/* 324 */	NdrFcShort( 0x0 ),	/* 0 */
/* 326 */	NdrFcShort( 0x0 ),	/* 0 */
/* 328 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 330 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 332 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 334 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 336 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 338 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 340 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementType */

/* 342 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 344 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 346 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 348 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 350 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 352 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 354 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 356 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 358 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementInfo */

/* 360 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 362 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 364 */	NdrFcShort( 0xf2 ),	/* Type Offset=242 */

	/* Parameter ElementsRead */

/* 366 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 368 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 370 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 372 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 374 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 376 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 378 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 380 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 382 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveSubnetElement */

/* 384 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 386 */	NdrFcLong( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x6 ),	/* 6 */
/* 392 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 394 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 396 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 398 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 400 */	NdrFcShort( 0xe ),	/* 14 */
/* 402 */	NdrFcShort( 0x8 ),	/* 8 */
/* 404 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 406 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 408 */	NdrFcShort( 0x0 ),	/* 0 */
/* 410 */	NdrFcShort( 0x2 ),	/* 2 */
/* 412 */	NdrFcShort( 0x0 ),	/* 0 */
/* 414 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 416 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 418 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 420 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 422 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 424 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 426 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter RemoveElementInfo */

/* 428 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 430 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 432 */	NdrFcShort( 0xe2 ),	/* Type Offset=226 */

	/* Parameter ForceFlag */

/* 434 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 436 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 438 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 440 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 442 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 444 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteSubnet */

/* 446 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 448 */	NdrFcLong( 0x0 ),	/* 0 */
/* 452 */	NdrFcShort( 0x7 ),	/* 7 */
/* 454 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 456 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 458 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 460 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 462 */	NdrFcShort( 0xe ),	/* 14 */
/* 464 */	NdrFcShort( 0x8 ),	/* 8 */
/* 466 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 468 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 470 */	NdrFcShort( 0x0 ),	/* 0 */
/* 472 */	NdrFcShort( 0x0 ),	/* 0 */
/* 474 */	NdrFcShort( 0x0 ),	/* 0 */
/* 476 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 478 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 480 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 482 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 484 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 486 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 488 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ForceFlag */

/* 490 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 492 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 494 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 496 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 498 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 500 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateOption */

/* 502 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 504 */	NdrFcLong( 0x0 ),	/* 0 */
/* 508 */	NdrFcShort( 0x8 ),	/* 8 */
/* 510 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 512 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 514 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 516 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 518 */	NdrFcShort( 0x8 ),	/* 8 */
/* 520 */	NdrFcShort( 0x8 ),	/* 8 */
/* 522 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 524 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 526 */	NdrFcShort( 0x0 ),	/* 0 */
/* 528 */	NdrFcShort( 0x4 ),	/* 4 */
/* 530 */	NdrFcShort( 0x0 ),	/* 0 */
/* 532 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 534 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 536 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 538 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 540 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 542 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 544 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 546 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 548 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 550 */	NdrFcShort( 0x19a ),	/* Type Offset=410 */

	/* Return value */

/* 552 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 554 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 556 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionInfo */

/* 558 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 560 */	NdrFcLong( 0x0 ),	/* 0 */
/* 564 */	NdrFcShort( 0x9 ),	/* 9 */
/* 566 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 568 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 570 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 572 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 574 */	NdrFcShort( 0x8 ),	/* 8 */
/* 576 */	NdrFcShort( 0x8 ),	/* 8 */
/* 578 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 580 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 582 */	NdrFcShort( 0x0 ),	/* 0 */
/* 584 */	NdrFcShort( 0x4 ),	/* 4 */
/* 586 */	NdrFcShort( 0x0 ),	/* 0 */
/* 588 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 590 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 592 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 594 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 596 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 598 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 600 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 602 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 604 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 606 */	NdrFcShort( 0x19a ),	/* Type Offset=410 */

	/* Return value */

/* 608 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 610 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 612 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetOptionInfo */

/* 614 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 616 */	NdrFcLong( 0x0 ),	/* 0 */
/* 620 */	NdrFcShort( 0xa ),	/* 10 */
/* 622 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 624 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 626 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 628 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 630 */	NdrFcShort( 0x8 ),	/* 8 */
/* 632 */	NdrFcShort( 0x8 ),	/* 8 */
/* 634 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 636 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 638 */	NdrFcShort( 0x4 ),	/* 4 */
/* 640 */	NdrFcShort( 0x0 ),	/* 0 */
/* 642 */	NdrFcShort( 0x0 ),	/* 0 */
/* 644 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 646 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 648 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 650 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 652 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 654 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 656 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionInfo */

/* 658 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 660 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 662 */	NdrFcShort( 0x1b6 ),	/* Type Offset=438 */

	/* Return value */

/* 664 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 666 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 668 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveOption */

/* 670 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 672 */	NdrFcLong( 0x0 ),	/* 0 */
/* 676 */	NdrFcShort( 0xb ),	/* 11 */
/* 678 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 680 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 682 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 684 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 686 */	NdrFcShort( 0x8 ),	/* 8 */
/* 688 */	NdrFcShort( 0x8 ),	/* 8 */
/* 690 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 692 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 694 */	NdrFcShort( 0x0 ),	/* 0 */
/* 696 */	NdrFcShort( 0x0 ),	/* 0 */
/* 698 */	NdrFcShort( 0x0 ),	/* 0 */
/* 700 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 702 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 704 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 706 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 708 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 710 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 712 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 714 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 716 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 718 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionValue */

/* 720 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 722 */	NdrFcLong( 0x0 ),	/* 0 */
/* 726 */	NdrFcShort( 0xc ),	/* 12 */
/* 728 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 730 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 732 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 734 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 736 */	NdrFcShort( 0x8 ),	/* 8 */
/* 738 */	NdrFcShort( 0x8 ),	/* 8 */
/* 740 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 742 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 744 */	NdrFcShort( 0x0 ),	/* 0 */
/* 746 */	NdrFcShort( 0x5 ),	/* 5 */
/* 748 */	NdrFcShort( 0x0 ),	/* 0 */
/* 750 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 752 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 754 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 756 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 758 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 760 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 762 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 764 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 766 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 768 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Parameter OptionValue */

/* 770 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 772 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 774 */	NdrFcShort( 0x18a ),	/* Type Offset=394 */

	/* Return value */

/* 776 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 778 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 780 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetOptionValue */

/* 782 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 784 */	NdrFcLong( 0x0 ),	/* 0 */
/* 788 */	NdrFcShort( 0xd ),	/* 13 */
/* 790 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 792 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 794 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 796 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 798 */	NdrFcShort( 0x8 ),	/* 8 */
/* 800 */	NdrFcShort( 0x8 ),	/* 8 */
/* 802 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 804 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 806 */	NdrFcShort( 0x4 ),	/* 4 */
/* 808 */	NdrFcShort( 0x1 ),	/* 1 */
/* 810 */	NdrFcShort( 0x0 ),	/* 0 */
/* 812 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 814 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 816 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 818 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 820 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 822 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 824 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 826 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 828 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 830 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Parameter OptionValue */

/* 832 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 834 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 836 */	NdrFcShort( 0x204 ),	/* Type Offset=516 */

	/* Return value */

/* 838 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 840 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 842 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumOptionValues */

/* 844 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 846 */	NdrFcLong( 0x0 ),	/* 0 */
/* 850 */	NdrFcShort( 0xe ),	/* 14 */
/* 852 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 854 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 856 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 858 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 860 */	NdrFcShort( 0x24 ),	/* 36 */
/* 862 */	NdrFcShort( 0x5c ),	/* 92 */
/* 864 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 866 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 868 */	NdrFcShort( 0x5 ),	/* 5 */
/* 870 */	NdrFcShort( 0x1 ),	/* 1 */
/* 872 */	NdrFcShort( 0x0 ),	/* 0 */
/* 874 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 876 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 878 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 880 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ScopeInfo */

/* 882 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 884 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 886 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Parameter ResumeHandle */

/* 888 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 890 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 892 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 894 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 896 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 898 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionValues */

/* 900 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 902 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 904 */	NdrFcShort( 0x21c ),	/* Type Offset=540 */

	/* Parameter OptionsRead */

/* 906 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 908 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 910 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionsTotal */

/* 912 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 914 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 916 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 918 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 920 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 922 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveOptionValue */

/* 924 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 926 */	NdrFcLong( 0x0 ),	/* 0 */
/* 930 */	NdrFcShort( 0xf ),	/* 15 */
/* 932 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 934 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 936 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 938 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 940 */	NdrFcShort( 0x8 ),	/* 8 */
/* 942 */	NdrFcShort( 0x8 ),	/* 8 */
/* 944 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 946 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 948 */	NdrFcShort( 0x0 ),	/* 0 */
/* 950 */	NdrFcShort( 0x1 ),	/* 1 */
/* 952 */	NdrFcShort( 0x0 ),	/* 0 */
/* 954 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 956 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 958 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 960 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter OptionID */

/* 962 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 964 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 966 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScopeInfo */

/* 968 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 970 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 972 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Return value */

/* 974 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 976 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 978 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateClientInfo */

/* 980 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 982 */	NdrFcLong( 0x0 ),	/* 0 */
/* 986 */	NdrFcShort( 0x10 ),	/* 16 */
/* 988 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 990 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 992 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 994 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 996 */	NdrFcShort( 0x0 ),	/* 0 */
/* 998 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1000 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1002 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1004 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1006 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1008 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1010 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1012 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1014 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1016 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1018 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1020 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1022 */	NdrFcShort( 0x24e ),	/* Type Offset=590 */

	/* Return value */

/* 1024 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1026 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1028 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetClientInfo */

/* 1030 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1032 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1036 */	NdrFcShort( 0x11 ),	/* 17 */
/* 1038 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1040 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1042 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1044 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1046 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1048 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1050 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1052 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1054 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1056 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1058 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1060 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1062 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1064 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1066 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1068 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1070 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1072 */	NdrFcShort( 0x24e ),	/* Type Offset=590 */

	/* Return value */

/* 1074 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1076 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1078 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientInfo */

/* 1080 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1082 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1086 */	NdrFcShort( 0x12 ),	/* 18 */
/* 1088 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1090 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1092 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1094 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1096 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1098 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1100 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1102 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1104 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1106 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1108 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1110 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1112 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1114 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1116 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SearchInfo */

/* 1118 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1120 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1122 */	NdrFcShort( 0x296 ),	/* Type Offset=662 */

	/* Parameter ClientInfo */

/* 1124 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1126 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1128 */	NdrFcShort( 0x2a6 ),	/* Type Offset=678 */

	/* Return value */

/* 1130 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1132 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1134 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteClientInfo */

/* 1136 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1138 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1142 */	NdrFcShort( 0x13 ),	/* 19 */
/* 1144 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1146 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1148 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1150 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1152 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1154 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1156 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1158 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1162 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1164 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1166 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1168 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1170 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1172 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1174 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1176 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1178 */	NdrFcShort( 0x296 ),	/* Type Offset=662 */

	/* Return value */

/* 1180 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1182 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetClients */

/* 1186 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1188 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1192 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1194 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 1196 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1198 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1200 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1202 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1204 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1206 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1208 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1210 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1212 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1216 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1218 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1220 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1222 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1224 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1226 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1228 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 1230 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 1232 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1234 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1236 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1238 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1240 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientInfo */

/* 1242 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1244 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1246 */	NdrFcShort( 0x2ae ),	/* Type Offset=686 */

	/* Parameter ClientsRead */

/* 1248 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1250 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1252 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientsTotal */

/* 1254 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1256 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 1258 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1260 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1262 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 1264 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientOptions */

/* 1266 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1268 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1272 */	NdrFcShort( 0x15 ),	/* 21 */
/* 1274 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1276 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1278 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1280 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1282 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1284 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1286 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1288 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1290 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1292 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1294 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1296 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1298 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1300 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1302 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientIpAddress */

/* 1304 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1306 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1308 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientSubnetMask */

/* 1310 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1312 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1314 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientOptions */

/* 1316 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1318 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1320 */	NdrFcShort( 0x2dc ),	/* Type Offset=732 */

	/* Return value */

/* 1322 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1324 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1326 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetMibInfo */

/* 1328 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1330 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1334 */	NdrFcShort( 0x16 ),	/* 22 */
/* 1336 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1338 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1340 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1342 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1344 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1346 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1348 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1350 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1352 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1354 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1356 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1358 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1360 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1362 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1364 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter MibInfo */

/* 1366 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1368 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1370 */	NdrFcShort( 0x2f4 ),	/* Type Offset=756 */

	/* Return value */

/* 1372 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1374 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1376 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumOptions */

/* 1378 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1380 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1384 */	NdrFcShort( 0x17 ),	/* 23 */
/* 1386 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 1388 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1390 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1392 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1394 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1396 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1398 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 1400 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1402 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1404 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1408 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1410 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1412 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1414 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ResumeHandle */

/* 1416 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 1418 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1420 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1422 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1424 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1426 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter Options */

/* 1428 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1430 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1432 */	NdrFcShort( 0x330 ),	/* Type Offset=816 */

	/* Parameter OptionsRead */

/* 1434 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1436 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1438 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter OptionsTotal */

/* 1440 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1442 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1444 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1446 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1448 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 1450 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetOptionValues */

/* 1452 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1454 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1458 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1460 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1462 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1464 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1466 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1468 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1470 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1472 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1474 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1476 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1478 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1480 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1482 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1484 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1486 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1488 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ScopeInfo */

/* 1490 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1492 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1494 */	NdrFcShort( 0x1f0 ),	/* Type Offset=496 */

	/* Parameter OptionValues */

/* 1496 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1498 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1500 */	NdrFcShort( 0x23a ),	/* Type Offset=570 */

	/* Return value */

/* 1502 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1504 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1506 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerSetConfig */

/* 1508 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1510 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1514 */	NdrFcShort( 0x19 ),	/* 25 */
/* 1516 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1518 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1520 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1522 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1524 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1526 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1528 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1530 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1532 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1534 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1536 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1538 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1540 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1542 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1544 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter FieldsToSet */

/* 1546 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1548 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1550 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ConfigInfo */

/* 1552 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1554 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1556 */	NdrFcShort( 0x366 ),	/* Type Offset=870 */

	/* Return value */

/* 1558 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1560 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1562 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerGetConfig */

/* 1564 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1566 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1570 */	NdrFcShort( 0x1a ),	/* 26 */
/* 1572 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1574 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1576 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1578 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1580 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1582 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1584 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1586 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1588 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1590 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1592 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1594 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1596 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1598 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1600 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ConfigInfo */

/* 1602 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1604 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1606 */	NdrFcShort( 0x386 ),	/* Type Offset=902 */

	/* Return value */

/* 1608 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1610 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1612 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpScanDatabase */

/* 1614 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1616 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1620 */	NdrFcShort( 0x1b ),	/* 27 */
/* 1622 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1624 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1626 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1628 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1630 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1632 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1634 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1636 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1638 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1640 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1642 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1644 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1646 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1648 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1650 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1652 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1654 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1656 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter FixFlag */

/* 1658 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1660 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1662 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ScanList */

/* 1664 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1666 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1668 */	NdrFcShort( 0x38e ),	/* Type Offset=910 */

	/* Return value */

/* 1670 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1672 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1674 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetVersion */

/* 1676 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1678 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1682 */	NdrFcShort( 0x1c ),	/* 28 */
/* 1684 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1686 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1688 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1690 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1692 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1694 */	NdrFcShort( 0x40 ),	/* 64 */
/* 1696 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1698 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1700 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1702 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1704 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1706 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1708 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1710 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1712 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter MajorVersion */

/* 1714 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1716 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1718 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter MinorVersion */

/* 1720 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1722 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1724 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1726 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1728 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1730 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpAddSubnetElementV4 */

/* 1732 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1734 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1738 */	NdrFcShort( 0x1d ),	/* 29 */
/* 1740 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1742 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1744 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1746 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1748 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1750 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1752 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 1754 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1756 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1758 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1760 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1762 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1764 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1766 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1768 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1770 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1772 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1774 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter AddElementInfo */

/* 1776 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1778 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1780 */	NdrFcShort( 0x410 ),	/* Type Offset=1040 */

	/* Return value */

/* 1782 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1784 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1786 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetElementsV4 */

/* 1788 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1790 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1794 */	NdrFcShort( 0x1e ),	/* 30 */
/* 1796 */	NdrFcShort( 0x48 ),	/* ia64, axp64 Stack size/offset = 72 */
/* 1798 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1800 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1802 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1804 */	NdrFcShort( 0x32 ),	/* 50 */
/* 1806 */	NdrFcShort( 0x5c ),	/* 92 */
/* 1808 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x9,		/* 9 */
/* 1810 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1812 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1814 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1816 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1818 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1820 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1822 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1824 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1826 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1828 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1830 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementType */

/* 1832 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1834 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1836 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 1838 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 1840 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1842 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 1844 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1846 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1848 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter EnumElementInfo */

/* 1850 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1852 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1854 */	NdrFcShort( 0x420 ),	/* Type Offset=1056 */

	/* Parameter ElementsRead */

/* 1856 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1858 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 1860 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ElementsTotal */

/* 1862 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1864 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 1866 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1868 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1870 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 1872 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpRemoveSubnetElementV4 */

/* 1874 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1876 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1880 */	NdrFcShort( 0x1f ),	/* 31 */
/* 1882 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 1884 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1886 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1888 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1890 */	NdrFcShort( 0xe ),	/* 14 */
/* 1892 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1894 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1896 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1898 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1900 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1902 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1904 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1906 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1908 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1910 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 1912 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1914 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1916 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter RemoveElementInfo */

/* 1918 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1920 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1922 */	NdrFcShort( 0x410 ),	/* Type Offset=1040 */

	/* Parameter ForceFlag */

/* 1924 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1926 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1928 */	0xd,		/* FC_ENUM16 */
			0x0,		/* 0 */

	/* Return value */

/* 1930 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1932 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 1934 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpCreateClientInfoV4 */

/* 1936 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1938 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1942 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1944 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1946 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1948 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1950 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 1952 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1954 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1956 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 1958 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1960 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1962 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1964 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1966 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 1968 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1970 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 1972 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 1974 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1976 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 1978 */	NdrFcShort( 0x452 ),	/* Type Offset=1106 */

	/* Return value */

/* 1980 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1982 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 1984 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetClientInfoV4 */

/* 1986 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 1988 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1992 */	NdrFcShort( 0x21 ),	/* 33 */
/* 1994 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 1996 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 1998 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2000 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2002 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2004 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2006 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2008 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 2010 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2012 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2014 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2016 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2018 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2020 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2022 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ClientInfo */

/* 2024 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2026 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2028 */	NdrFcShort( 0x452 ),	/* Type Offset=1106 */

	/* Return value */

/* 2030 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2032 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2034 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetClientInfoV4 */

/* 2036 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2038 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2042 */	NdrFcShort( 0x22 ),	/* 34 */
/* 2044 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2046 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2048 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2050 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2052 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2054 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2056 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 2058 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 2060 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2062 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2064 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2066 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2068 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2070 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2072 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SearchInfo */

/* 2074 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2076 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2078 */	NdrFcShort( 0x296 ),	/* Type Offset=662 */

	/* Parameter ClientInfo */

/* 2080 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2082 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2084 */	NdrFcShort( 0x476 ),	/* Type Offset=1142 */

	/* Return value */

/* 2086 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2088 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2090 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpEnumSubnetClientsV4 */

/* 2092 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2094 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2098 */	NdrFcShort( 0x23 ),	/* 35 */
/* 2100 */	NdrFcShort( 0x40 ),	/* ia64, axp64 Stack size/offset = 64 */
/* 2102 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2104 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2106 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2108 */	NdrFcShort( 0x2c ),	/* 44 */
/* 2110 */	NdrFcShort( 0x5c ),	/* 92 */
/* 2112 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 2114 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2116 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2118 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2122 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2124 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2126 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2128 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 2130 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2132 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2134 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ResumeHandle */

/* 2136 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 2138 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2140 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter PreferredMaximum */

/* 2142 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2144 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2146 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientInfo */

/* 2148 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2150 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2152 */	NdrFcShort( 0x47e ),	/* Type Offset=1150 */

	/* Parameter ClientsRead */

/* 2154 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2156 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2158 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ClientsTotal */

/* 2160 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 2162 */	NdrFcShort( 0x30 ),	/* ia64, axp64 Stack size/offset = 48 */
/* 2164 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2166 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2168 */	NdrFcShort( 0x38 ),	/* ia64, axp64 Stack size/offset = 56 */
/* 2170 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpSetSuperScopeV4 */

/* 2172 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2174 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2178 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2180 */	NdrFcShort( 0x28 ),	/* ia64, axp64 Stack size/offset = 40 */
/* 2182 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2184 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2186 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2188 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2190 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2192 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2194 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2202 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2204 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2206 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2208 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SubnetAddress */

/* 2210 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2212 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2214 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter SuperScopeName */

/* 2216 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2218 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2220 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ChangeExisting */

/* 2222 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2224 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2226 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 2228 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2230 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2232 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpGetSuperScopeInfoV4 */

/* 2234 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2236 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2240 */	NdrFcShort( 0x25 ),	/* 37 */
/* 2242 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2244 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2246 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2248 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2252 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2254 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2256 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2258 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2262 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2264 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2266 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2268 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2270 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SuperScopeTable */

/* 2272 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2274 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2276 */	NdrFcShort( 0x4ac ),	/* Type Offset=1196 */

	/* Return value */

/* 2278 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2280 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpDeleteSuperScopeV4 */

/* 2284 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2290 */	NdrFcShort( 0x26 ),	/* 38 */
/* 2292 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2294 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2296 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2298 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2300 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2302 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2304 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2306 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2308 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2312 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2314 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2316 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2318 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2320 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter SuperScopeName */

/* 2322 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2324 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2326 */	NdrFcShort( 0x4ee ),	/* Type Offset=1262 */

	/* Return value */

/* 2328 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2330 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2332 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerSetConfigV4 */

/* 2334 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2336 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2340 */	NdrFcShort( 0x27 ),	/* 39 */
/* 2342 */	NdrFcShort( 0x20 ),	/* ia64, axp64 Stack size/offset = 32 */
/* 2344 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2346 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2348 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2350 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2352 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2354 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 2356 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 2358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2360 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2362 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2364 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2366 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2368 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2370 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter FieldsToSet */

/* 2372 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2374 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2376 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ConfigInfo */

/* 2378 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2380 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2382 */	NdrFcShort( 0x500 ),	/* Type Offset=1280 */

	/* Return value */

/* 2384 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2386 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2388 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure R_DhcpServerGetConfigV4 */

/* 2390 */	0x0,		/* 0 */
			0x48,		/* Old Flags:  */
/* 2392 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2396 */	NdrFcShort( 0x28 ),	/* 40 */
/* 2398 */	NdrFcShort( 0x18 ),	/* ia64, axp64 Stack size/offset = 24 */
/* 2400 */	0x31,		/* FC_BIND_GENERIC */
			0x8,		/* 8 */
/* 2402 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2404 */	0x0,		/* 0 */
			0x5c,		/* FC_PAD */
/* 2406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2408 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2410 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2412 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2414 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2416 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2418 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2420 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ServerIpAddress */

/* 2422 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2424 */	NdrFcShort( 0x0 ),	/* ia64, axp64 Stack size/offset = 0 */
/* 2426 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ConfigInfo */

/* 2428 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2430 */	NdrFcShort( 0x8 ),	/* ia64, axp64 Stack size/offset = 8 */
/* 2432 */	NdrFcShort( 0x52a ),	/* Type Offset=1322 */

	/* Return value */

/* 2434 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2436 */	NdrFcShort( 0x10 ),	/* ia64, axp64 Stack size/offset = 16 */
/* 2438 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  4 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x11, 0x0,	/* FC_RP */
/*  8 */	NdrFcShort( 0x18 ),	/* Offset= 24 (32) */
/* 10 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 12 */	NdrFcShort( 0x18 ),	/* 24 */
/* 14 */	NdrFcShort( 0x0 ),	/* 0 */
/* 16 */	NdrFcShort( 0x8 ),	/* Offset= 8 (24) */
/* 18 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 20 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 22 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 24 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 26 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 28 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 30 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 32 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 34 */	NdrFcShort( 0x38 ),	/* 56 */
/* 36 */	NdrFcShort( 0x0 ),	/* 0 */
/* 38 */	NdrFcShort( 0xe ),	/* Offset= 14 (52) */
/* 40 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 42 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 44 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 46 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (10) */
/* 48 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 50 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 52 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 54 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 56 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 58 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 60 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 62 */	NdrFcShort( 0x2 ),	/* Offset= 2 (64) */
/* 64 */	
			0x12, 0x0,	/* FC_UP */
/* 66 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (32) */
/* 68 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 70 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 72 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 74 */	NdrFcShort( 0x2 ),	/* Offset= 2 (76) */
/* 76 */	
			0x12, 0x0,	/* FC_UP */
/* 78 */	NdrFcShort( 0xe ),	/* Offset= 14 (92) */
/* 80 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 82 */	NdrFcShort( 0x4 ),	/* 4 */
/* 84 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 86 */	NdrFcShort( 0x0 ),	/* 0 */
/* 88 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 90 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 92 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 94 */	NdrFcShort( 0x10 ),	/* 16 */
/* 96 */	NdrFcShort( 0x0 ),	/* 0 */
/* 98 */	NdrFcShort( 0x6 ),	/* Offset= 6 (104) */
/* 100 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 102 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 104 */	
			0x12, 0x0,	/* FC_UP */
/* 106 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (80) */
/* 108 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 110 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 112 */	
			0x11, 0x0,	/* FC_RP */
/* 114 */	NdrFcShort( 0x70 ),	/* Offset= 112 (226) */
/* 116 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 118 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 122 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 124 */	NdrFcShort( 0x2 ),	/* Offset= 2 (126) */
/* 126 */	NdrFcShort( 0x8 ),	/* 8 */
/* 128 */	NdrFcShort( 0x5 ),	/* 5 */
/* 130 */	NdrFcLong( 0x0 ),	/* 0 */
/* 134 */	NdrFcShort( 0x1c ),	/* Offset= 28 (162) */
/* 136 */	NdrFcLong( 0x1 ),	/* 1 */
/* 140 */	NdrFcShort( 0x22 ),	/* Offset= 34 (174) */
/* 142 */	NdrFcLong( 0x2 ),	/* 2 */
/* 146 */	NdrFcShort( 0x20 ),	/* Offset= 32 (178) */
/* 148 */	NdrFcLong( 0x3 ),	/* 3 */
/* 152 */	NdrFcShort( 0xa ),	/* Offset= 10 (162) */
/* 154 */	NdrFcLong( 0x4 ),	/* 4 */
/* 158 */	NdrFcShort( 0x4 ),	/* Offset= 4 (162) */
/* 160 */	NdrFcShort( 0x0 ),	/* Offset= 0 (160) */
/* 162 */	
			0x12, 0x0,	/* FC_UP */
/* 164 */	NdrFcShort( 0x2 ),	/* Offset= 2 (166) */
/* 166 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 168 */	NdrFcShort( 0x8 ),	/* 8 */
/* 170 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 172 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 174 */	
			0x12, 0x0,	/* FC_UP */
/* 176 */	NdrFcShort( 0xffffff5a ),	/* Offset= -166 (10) */
/* 178 */	
			0x12, 0x0,	/* FC_UP */
/* 180 */	NdrFcShort( 0x1e ),	/* Offset= 30 (210) */
/* 182 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 184 */	NdrFcShort( 0x1 ),	/* 1 */
/* 186 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 190 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 192 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 194 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 196 */	NdrFcShort( 0x10 ),	/* 16 */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 200 */	NdrFcShort( 0x6 ),	/* Offset= 6 (206) */
/* 202 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 204 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 206 */	
			0x12, 0x0,	/* FC_UP */
/* 208 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (182) */
/* 210 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 212 */	NdrFcShort( 0x10 ),	/* 16 */
/* 214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 216 */	NdrFcShort( 0x6 ),	/* Offset= 6 (222) */
/* 218 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 220 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 222 */	
			0x12, 0x0,	/* FC_UP */
/* 224 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (194) */
/* 226 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 228 */	NdrFcShort( 0x10 ),	/* 16 */
/* 230 */	NdrFcShort( 0x0 ),	/* 0 */
/* 232 */	NdrFcShort( 0x0 ),	/* Offset= 0 (232) */
/* 234 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 236 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 238 */	NdrFcShort( 0xffffff86 ),	/* Offset= -122 (116) */
/* 240 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 242 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 244 */	NdrFcShort( 0x2 ),	/* Offset= 2 (246) */
/* 246 */	
			0x12, 0x0,	/* FC_UP */
/* 248 */	NdrFcShort( 0x18 ),	/* Offset= 24 (272) */
/* 250 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 252 */	NdrFcShort( 0x0 ),	/* 0 */
/* 254 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 256 */	NdrFcShort( 0x0 ),	/* 0 */
/* 258 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 260 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 264 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 266 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 268 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (226) */
/* 270 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 272 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 274 */	NdrFcShort( 0x10 ),	/* 16 */
/* 276 */	NdrFcShort( 0x0 ),	/* 0 */
/* 278 */	NdrFcShort( 0x6 ),	/* Offset= 6 (284) */
/* 280 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 282 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 284 */	
			0x12, 0x0,	/* FC_UP */
/* 286 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (250) */
/* 288 */	
			0x11, 0x0,	/* FC_RP */
/* 290 */	NdrFcShort( 0x78 ),	/* Offset= 120 (410) */
/* 292 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 294 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 296 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 298 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 300 */	NdrFcShort( 0x2 ),	/* Offset= 2 (302) */
/* 302 */	NdrFcShort( 0x10 ),	/* 16 */
/* 304 */	NdrFcShort( 0x8 ),	/* 8 */
/* 306 */	NdrFcLong( 0x0 ),	/* 0 */
/* 310 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 312 */	NdrFcLong( 0x1 ),	/* 1 */
/* 316 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 318 */	NdrFcLong( 0x2 ),	/* 2 */
/* 322 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 324 */	NdrFcLong( 0x3 ),	/* 3 */
/* 328 */	NdrFcShort( 0xffffff5e ),	/* Offset= -162 (166) */
/* 330 */	NdrFcLong( 0x4 ),	/* 4 */
/* 334 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 336 */	NdrFcLong( 0x5 ),	/* 5 */
/* 340 */	NdrFcShort( 0xfffffeae ),	/* Offset= -338 (2) */
/* 342 */	NdrFcLong( 0x6 ),	/* 6 */
/* 346 */	NdrFcShort( 0xffffff68 ),	/* Offset= -152 (194) */
/* 348 */	NdrFcLong( 0x7 ),	/* 7 */
/* 352 */	NdrFcShort( 0xffffff62 ),	/* Offset= -158 (194) */
/* 354 */	NdrFcShort( 0x0 ),	/* Offset= 0 (354) */
/* 356 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 358 */	NdrFcShort( 0x18 ),	/* 24 */
/* 360 */	NdrFcShort( 0x0 ),	/* 0 */
/* 362 */	NdrFcShort( 0x0 ),	/* Offset= 0 (362) */
/* 364 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 366 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 368 */	NdrFcShort( 0xffffffb4 ),	/* Offset= -76 (292) */
/* 370 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 372 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 380 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 382 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 386 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 388 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 390 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (356) */
/* 392 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 394 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 396 */	NdrFcShort( 0x10 ),	/* 16 */
/* 398 */	NdrFcShort( 0x0 ),	/* 0 */
/* 400 */	NdrFcShort( 0x6 ),	/* Offset= 6 (406) */
/* 402 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 404 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 406 */	
			0x12, 0x0,	/* FC_UP */
/* 408 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (372) */
/* 410 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 412 */	NdrFcShort( 0x30 ),	/* 48 */
/* 414 */	NdrFcShort( 0x0 ),	/* 0 */
/* 416 */	NdrFcShort( 0xe ),	/* Offset= 14 (430) */
/* 418 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 420 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 422 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 424 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (394) */
/* 426 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 428 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 430 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 432 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 434 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 436 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 438 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 440 */	NdrFcShort( 0x2 ),	/* Offset= 2 (442) */
/* 442 */	
			0x12, 0x0,	/* FC_UP */
/* 444 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (410) */
/* 446 */	
			0x11, 0x0,	/* FC_RP */
/* 448 */	NdrFcShort( 0x30 ),	/* Offset= 48 (496) */
/* 450 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 452 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 454 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 456 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 458 */	NdrFcShort( 0x2 ),	/* Offset= 2 (460) */
/* 460 */	NdrFcShort( 0x8 ),	/* 8 */
/* 462 */	NdrFcShort( 0x5 ),	/* 5 */
/* 464 */	NdrFcLong( 0x0 ),	/* 0 */
/* 468 */	NdrFcShort( 0x0 ),	/* Offset= 0 (468) */
/* 470 */	NdrFcLong( 0x1 ),	/* 1 */
/* 474 */	NdrFcShort( 0x0 ),	/* Offset= 0 (474) */
/* 476 */	NdrFcLong( 0x2 ),	/* 2 */
/* 480 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 482 */	NdrFcLong( 0x3 ),	/* 3 */
/* 486 */	NdrFcShort( 0xfffffec0 ),	/* Offset= -320 (166) */
/* 488 */	NdrFcLong( 0x4 ),	/* 4 */
/* 492 */	NdrFcShort( 0xfffffe16 ),	/* Offset= -490 (2) */
/* 494 */	NdrFcShort( 0x0 ),	/* Offset= 0 (494) */
/* 496 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 498 */	NdrFcShort( 0x10 ),	/* 16 */
/* 500 */	NdrFcShort( 0x0 ),	/* 0 */
/* 502 */	NdrFcShort( 0x0 ),	/* Offset= 0 (502) */
/* 504 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 506 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 508 */	NdrFcShort( 0xffffffc6 ),	/* Offset= -58 (450) */
/* 510 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 512 */	
			0x11, 0x0,	/* FC_RP */
/* 514 */	NdrFcShort( 0xffffff88 ),	/* Offset= -120 (394) */
/* 516 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 518 */	NdrFcShort( 0x2 ),	/* Offset= 2 (520) */
/* 520 */	
			0x12, 0x0,	/* FC_UP */
/* 522 */	NdrFcShort( 0x2 ),	/* Offset= 2 (524) */
/* 524 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 526 */	NdrFcShort( 0x18 ),	/* 24 */
/* 528 */	NdrFcShort( 0x0 ),	/* 0 */
/* 530 */	NdrFcShort( 0x0 ),	/* Offset= 0 (530) */
/* 532 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 534 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 536 */	NdrFcShort( 0xffffff72 ),	/* Offset= -142 (394) */
/* 538 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 540 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 542 */	NdrFcShort( 0x2 ),	/* Offset= 2 (544) */
/* 544 */	
			0x12, 0x0,	/* FC_UP */
/* 546 */	NdrFcShort( 0x18 ),	/* Offset= 24 (570) */
/* 548 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 550 */	NdrFcShort( 0x0 ),	/* 0 */
/* 552 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 554 */	NdrFcShort( 0x0 ),	/* 0 */
/* 556 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 558 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 562 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 564 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 566 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (524) */
/* 568 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 570 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 572 */	NdrFcShort( 0x10 ),	/* 16 */
/* 574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 576 */	NdrFcShort( 0x6 ),	/* Offset= 6 (582) */
/* 578 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 580 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 582 */	
			0x12, 0x0,	/* FC_UP */
/* 584 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (548) */
/* 586 */	
			0x11, 0x0,	/* FC_RP */
/* 588 */	NdrFcShort( 0x2 ),	/* Offset= 2 (590) */
/* 590 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 592 */	NdrFcShort( 0x48 ),	/* 72 */
/* 594 */	NdrFcShort( 0x0 ),	/* 0 */
/* 596 */	NdrFcShort( 0x14 ),	/* Offset= 20 (616) */
/* 598 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 600 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 602 */	NdrFcShort( 0xfffffe68 ),	/* Offset= -408 (194) */
/* 604 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 606 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 608 */	NdrFcShort( 0xfffffe46 ),	/* Offset= -442 (166) */
/* 610 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 612 */	NdrFcShort( 0xfffffda6 ),	/* Offset= -602 (10) */
/* 614 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 616 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 618 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 620 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 622 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 624 */	
			0x11, 0x0,	/* FC_RP */
/* 626 */	NdrFcShort( 0x24 ),	/* Offset= 36 (662) */
/* 628 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 630 */	0x6,		/* Corr desc: FC_SHORT */
			0x0,		/*  */
/* 632 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 634 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 636 */	NdrFcShort( 0x2 ),	/* Offset= 2 (638) */
/* 638 */	NdrFcShort( 0x10 ),	/* 16 */
/* 640 */	NdrFcShort( 0x3 ),	/* 3 */
/* 642 */	NdrFcLong( 0x0 ),	/* 0 */
/* 646 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 648 */	NdrFcLong( 0x1 ),	/* 1 */
/* 652 */	NdrFcShort( 0xfffffe36 ),	/* Offset= -458 (194) */
/* 654 */	NdrFcLong( 0x2 ),	/* 2 */
/* 658 */	NdrFcShort( 0xfffffd70 ),	/* Offset= -656 (2) */
/* 660 */	NdrFcShort( 0x0 ),	/* Offset= 0 (660) */
/* 662 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 664 */	NdrFcShort( 0x18 ),	/* 24 */
/* 666 */	NdrFcShort( 0x0 ),	/* 0 */
/* 668 */	NdrFcShort( 0x0 ),	/* Offset= 0 (668) */
/* 670 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 672 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 674 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (628) */
/* 676 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 678 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 680 */	NdrFcShort( 0x2 ),	/* Offset= 2 (682) */
/* 682 */	
			0x12, 0x0,	/* FC_UP */
/* 684 */	NdrFcShort( 0xffffffa2 ),	/* Offset= -94 (590) */
/* 686 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 688 */	NdrFcShort( 0x2 ),	/* Offset= 2 (690) */
/* 690 */	
			0x12, 0x0,	/* FC_UP */
/* 692 */	NdrFcShort( 0x18 ),	/* Offset= 24 (716) */
/* 694 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 696 */	NdrFcShort( 0x0 ),	/* 0 */
/* 698 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 700 */	NdrFcShort( 0x0 ),	/* 0 */
/* 702 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 704 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 708 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 710 */	
			0x12, 0x0,	/* FC_UP */
/* 712 */	NdrFcShort( 0xffffff86 ),	/* Offset= -122 (590) */
/* 714 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 716 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 718 */	NdrFcShort( 0x10 ),	/* 16 */
/* 720 */	NdrFcShort( 0x0 ),	/* 0 */
/* 722 */	NdrFcShort( 0x6 ),	/* Offset= 6 (728) */
/* 724 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 726 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 728 */	
			0x12, 0x0,	/* FC_UP */
/* 730 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (694) */
/* 732 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 734 */	NdrFcShort( 0x2 ),	/* Offset= 2 (736) */
/* 736 */	
			0x12, 0x0,	/* FC_UP */
/* 738 */	NdrFcShort( 0x2 ),	/* Offset= 2 (740) */
/* 740 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 742 */	NdrFcShort( 0x10 ),	/* 16 */
/* 744 */	NdrFcShort( 0x0 ),	/* 0 */
/* 746 */	NdrFcShort( 0x6 ),	/* Offset= 6 (752) */
/* 748 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 750 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 752 */	
			0x12, 0x0,	/* FC_UP */
/* 754 */	NdrFcShort( 0xffffff32 ),	/* Offset= -206 (548) */
/* 756 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 758 */	NdrFcShort( 0x2 ),	/* Offset= 2 (760) */
/* 760 */	
			0x12, 0x0,	/* FC_UP */
/* 762 */	NdrFcShort( 0x1c ),	/* Offset= 28 (790) */
/* 764 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 766 */	NdrFcShort( 0x10 ),	/* 16 */
/* 768 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 770 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 772 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 774 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 776 */	NdrFcShort( 0x10 ),	/* 16 */
/* 778 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 780 */	NdrFcShort( 0x24 ),	/* 36 */
/* 782 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 784 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 786 */	NdrFcShort( 0xffffffea ),	/* Offset= -22 (764) */
/* 788 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 790 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 792 */	NdrFcShort( 0x30 ),	/* 48 */
/* 794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 796 */	NdrFcShort( 0x10 ),	/* Offset= 16 (812) */
/* 798 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 800 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 802 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 804 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 806 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffd7f ),	/* Offset= -641 (166) */
			0x8,		/* FC_LONG */
/* 810 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 812 */	
			0x12, 0x0,	/* FC_UP */
/* 814 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (774) */
/* 816 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 818 */	NdrFcShort( 0x2 ),	/* Offset= 2 (820) */
/* 820 */	
			0x12, 0x0,	/* FC_UP */
/* 822 */	NdrFcShort( 0x18 ),	/* Offset= 24 (846) */
/* 824 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 828 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 830 */	NdrFcShort( 0x0 ),	/* 0 */
/* 832 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 834 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 838 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 840 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 842 */	NdrFcShort( 0xfffffe50 ),	/* Offset= -432 (410) */
/* 844 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 846 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 848 */	NdrFcShort( 0x10 ),	/* 16 */
/* 850 */	NdrFcShort( 0x0 ),	/* 0 */
/* 852 */	NdrFcShort( 0x6 ),	/* Offset= 6 (858) */
/* 854 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 856 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 858 */	
			0x12, 0x0,	/* FC_UP */
/* 860 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (824) */
/* 862 */	
			0x11, 0x0,	/* FC_RP */
/* 864 */	NdrFcShort( 0xfffffeda ),	/* Offset= -294 (570) */
/* 866 */	
			0x11, 0x0,	/* FC_RP */
/* 868 */	NdrFcShort( 0x2 ),	/* Offset= 2 (870) */
/* 870 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 872 */	NdrFcShort( 0x38 ),	/* 56 */
/* 874 */	NdrFcShort( 0x0 ),	/* 0 */
/* 876 */	NdrFcShort( 0xe ),	/* Offset= 14 (890) */
/* 878 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 880 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 882 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 884 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 886 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 888 */	0x40,		/* FC_STRUCTPAD4 */
			0x5b,		/* FC_END */
/* 890 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 892 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 894 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 896 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 898 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 900 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 902 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 904 */	NdrFcShort( 0x2 ),	/* Offset= 2 (906) */
/* 906 */	
			0x12, 0x0,	/* FC_UP */
/* 908 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (870) */
/* 910 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 912 */	NdrFcShort( 0x2 ),	/* Offset= 2 (914) */
/* 914 */	
			0x12, 0x0,	/* FC_UP */
/* 916 */	NdrFcShort( 0x24 ),	/* Offset= 36 (952) */
/* 918 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 920 */	NdrFcShort( 0x8 ),	/* 8 */
/* 922 */	NdrFcShort( 0x0 ),	/* 0 */
/* 924 */	NdrFcShort( 0x0 ),	/* Offset= 0 (924) */
/* 926 */	0x8,		/* FC_LONG */
			0xd,		/* FC_ENUM16 */
/* 928 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 930 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 932 */	NdrFcShort( 0x0 ),	/* 0 */
/* 934 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 936 */	NdrFcShort( 0x0 ),	/* 0 */
/* 938 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 940 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 944 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 946 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 948 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (918) */
/* 950 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 952 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 954 */	NdrFcShort( 0x10 ),	/* 16 */
/* 956 */	NdrFcShort( 0x0 ),	/* 0 */
/* 958 */	NdrFcShort( 0x6 ),	/* Offset= 6 (964) */
/* 960 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 962 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 964 */	
			0x12, 0x0,	/* FC_UP */
/* 966 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (930) */
/* 968 */	
			0x11, 0x0,	/* FC_RP */
/* 970 */	NdrFcShort( 0x46 ),	/* Offset= 70 (1040) */
/* 972 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0xd,		/* FC_ENUM16 */
/* 974 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 976 */	NdrFcShort( 0x1 ),	/* 1 */
/* 978 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 980 */	NdrFcShort( 0x2 ),	/* Offset= 2 (982) */
/* 982 */	NdrFcShort( 0x8 ),	/* 8 */
/* 984 */	NdrFcShort( 0x5 ),	/* 5 */
/* 986 */	NdrFcLong( 0x0 ),	/* 0 */
/* 990 */	NdrFcShort( 0xfffffcc4 ),	/* Offset= -828 (162) */
/* 992 */	NdrFcLong( 0x1 ),	/* 1 */
/* 996 */	NdrFcShort( 0xfffffcca ),	/* Offset= -822 (174) */
/* 998 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1002 */	NdrFcShort( 0x10 ),	/* Offset= 16 (1018) */
/* 1004 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1008 */	NdrFcShort( 0xfffffcb2 ),	/* Offset= -846 (162) */
/* 1010 */	NdrFcLong( 0x4 ),	/* 4 */
/* 1014 */	NdrFcShort( 0xfffffcac ),	/* Offset= -852 (162) */
/* 1016 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1016) */
/* 1018 */	
			0x12, 0x0,	/* FC_UP */
/* 1020 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1022) */
/* 1022 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1024 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1026 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1028 */	NdrFcShort( 0x8 ),	/* Offset= 8 (1036) */
/* 1030 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1032 */	0x36,		/* FC_POINTER */
			0x2,		/* FC_CHAR */
/* 1034 */	0x43,		/* FC_STRUCTPAD7 */
			0x5b,		/* FC_END */
/* 1036 */	
			0x12, 0x0,	/* FC_UP */
/* 1038 */	NdrFcShort( 0xfffffcb4 ),	/* Offset= -844 (194) */
/* 1040 */	
			0x1a,		/* FC_BOGUS_STRUCT */
/* 3 */ /* DHCP Bug Compatibility */			0x1,		/* 1 */
/* 1042 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1044 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1046 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1046) */
/* 1048 */	0xd,		/* FC_ENUM16 */
			0x40,		/* FC_STRUCTPAD4 */
/* 1050 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1052 */	NdrFcShort( 0xffffffb0 ),	/* Offset= -80 (972) */
/* 1054 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1056 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1058 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1060) */
/* 1060 */	
			0x12, 0x0,	/* FC_UP */
/* 1062 */	NdrFcShort( 0x18 ),	/* Offset= 24 (1086) */
/* 1064 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1066 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1068 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1070 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1072 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1074 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1078 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1080 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1082 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1040) */
/* 1084 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1086 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1088 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1090 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1092 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1098) */
/* 1094 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1096 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1098 */	
			0x12, 0x0,	/* FC_UP */
/* 1100 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1064) */
/* 1102 */	
			0x11, 0x0,	/* FC_RP */
/* 1104 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1106) */
/* 1106 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1108 */	NdrFcShort( 0x50 ),	/* 80 */
/* 1110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1112 */	NdrFcShort( 0x16 ),	/* Offset= 22 (1134) */
/* 1114 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1116 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1118 */	NdrFcShort( 0xfffffc64 ),	/* Offset= -924 (194) */
/* 1120 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 1122 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1124 */	NdrFcShort( 0xfffffc42 ),	/* Offset= -958 (166) */
/* 1126 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1128 */	NdrFcShort( 0xfffffba2 ),	/* Offset= -1118 (10) */
/* 1130 */	0x2,		/* FC_CHAR */
			0x43,		/* FC_STRUCTPAD7 */
/* 1132 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1134 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1136 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1138 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1140 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1142 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1144 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1146) */
/* 1146 */	
			0x12, 0x0,	/* FC_UP */
/* 1148 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1106) */
/* 1150 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1152 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1154) */
/* 1154 */	
			0x12, 0x0,	/* FC_UP */
/* 1156 */	NdrFcShort( 0x18 ),	/* Offset= 24 (1180) */
/* 1158 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1162 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1164 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1166 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1168 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1172 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1174 */	
			0x12, 0x0,	/* FC_UP */
/* 1176 */	NdrFcShort( 0xffffffba ),	/* Offset= -70 (1106) */
/* 1178 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1180 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1182 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1184 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1186 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1192) */
/* 1188 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1190 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1192 */	
			0x12, 0x0,	/* FC_UP */
/* 1194 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1158) */
/* 1196 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1198 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1200) */
/* 1200 */	
			0x12, 0x0,	/* FC_UP */
/* 1202 */	NdrFcShort( 0x2a ),	/* Offset= 42 (1244) */
/* 1204 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1206 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1208 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1210 */	NdrFcShort( 0x8 ),	/* Offset= 8 (1218) */
/* 1212 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1214 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1216 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1218 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1220 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1222 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1224 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1226 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1230 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1232 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1236 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1238 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1240 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1204) */
/* 1242 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1244 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1246 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1248 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1250 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1256) */
/* 1252 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1254 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1256 */	
			0x12, 0x0,	/* FC_UP */
/* 1258 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1222) */
/* 1260 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 1262 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1264 */	
			0x11, 0x0,	/* FC_RP */
/* 1266 */	NdrFcShort( 0xe ),	/* Offset= 14 (1280) */
/* 1268 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1270 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1272 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1274 */	NdrFcShort( 0x38 ),	/* 56 */
/* 1276 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1278 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 1280 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1282 */	NdrFcShort( 0x50 ),	/* 80 */
/* 1284 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1286 */	NdrFcShort( 0x14 ),	/* Offset= 20 (1306) */
/* 1288 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1290 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 1292 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 1294 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1296 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1298 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1300 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 1302 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1304 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1306 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1308 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1310 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1312 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1314 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 1316 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 1318 */	
			0x12, 0x0,	/* FC_UP */
/* 1320 */	NdrFcShort( 0xffffffcc ),	/* Offset= -52 (1268) */
/* 1322 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1324 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1326) */
/* 1326 */	
			0x12, 0x0,	/* FC_UP */
/* 1328 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (1280) */

			0x0
        }
    };

static void __RPC_USER dhcpsrv__DHCP_SUBNET_ELEMENT_DATAExprEval_0000( PMIDL_STUB_MESSAGE pStubMsg )
{
    struct _DHCP_SUBNET_ELEMENT_DATA __RPC_FAR *pS	=	( struct _DHCP_SUBNET_ELEMENT_DATA __RPC_FAR * )(pStubMsg->StackTop - 8);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( pS->ElementType <= DhcpIpRangesBootpOnly && DhcpIpRangesDhcpOnly <= pS->ElementType ? 0 : pS->ElementType );
}

static void __RPC_USER dhcpsrv__DHCP_SUBNET_ELEMENT_DATA_V4ExprEval_0001( PMIDL_STUB_MESSAGE pStubMsg )
{
    struct _DHCP_SUBNET_ELEMENT_DATA_V4 __RPC_FAR *pS	=	( struct _DHCP_SUBNET_ELEMENT_DATA_V4 __RPC_FAR * )(pStubMsg->StackTop - 8);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( pS->ElementType <= DhcpIpRangesBootpOnly && DhcpIpRangesDhcpOnly <= pS->ElementType ? 0 : pS->ElementType );
}

static const EXPR_EVAL ExprEvalRoutines[] = 
    {
    dhcpsrv__DHCP_SUBNET_ELEMENT_DATAExprEval_0000
    ,dhcpsrv__DHCP_SUBNET_ELEMENT_DATA_V4ExprEval_0001
    };


static const unsigned short dhcpsrv_FormatStringOffsetTable[] =
    {
    0,
    56,
    112,
    168,
    242,
    298,
    384,
    446,
    502,
    558,
    614,
    670,
    720,
    782,
    844,
    924,
    980,
    1030,
    1080,
    1136,
    1186,
    1266,
    1328,
    1378,
    1452,
    1508,
    1564,
    1614,
    1676,
    1732,
    1788,
    1874,
    1936,
    1986,
    2036,
    2092,
    2172,
    2234,
    2284,
    2334,
    2390
    };


static const MIDL_STUB_DESC dhcpsrv_StubDesc = 
    {
    (void __RPC_FAR *)& dhcpsrv___RpcServerInterface,
    MIDL_user_allocate,
    MIDL_user_free,
    0,
    0,
    0,
    ExprEvalRoutines,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000143, /* MIDL Version 6.0.323 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

static RPC_DISPATCH_FUNCTION dhcpsrv_table[] =
    {
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    NdrServerCall2,
    0
    };
RPC_DISPATCH_TABLE dhcpsrv_DispatchTable = 
    {
    41,
    dhcpsrv_table
    };

static const SERVER_ROUTINE dhcpsrv_ServerRoutineTable[] = 
    {
    (SERVER_ROUTINE)R_DhcpCreateSubnet,
    (SERVER_ROUTINE)R_DhcpSetSubnetInfo,
    (SERVER_ROUTINE)R_DhcpGetSubnetInfo,
    (SERVER_ROUTINE)R_DhcpEnumSubnets,
    (SERVER_ROUTINE)R_DhcpAddSubnetElement,
    (SERVER_ROUTINE)R_DhcpEnumSubnetElements,
    (SERVER_ROUTINE)R_DhcpRemoveSubnetElement,
    (SERVER_ROUTINE)R_DhcpDeleteSubnet,
    (SERVER_ROUTINE)R_DhcpCreateOption,
    (SERVER_ROUTINE)R_DhcpSetOptionInfo,
    (SERVER_ROUTINE)R_DhcpGetOptionInfo,
    (SERVER_ROUTINE)R_DhcpRemoveOption,
    (SERVER_ROUTINE)R_DhcpSetOptionValue,
    (SERVER_ROUTINE)R_DhcpGetOptionValue,
    (SERVER_ROUTINE)R_DhcpEnumOptionValues,
    (SERVER_ROUTINE)R_DhcpRemoveOptionValue,
    (SERVER_ROUTINE)R_DhcpCreateClientInfo,
    (SERVER_ROUTINE)R_DhcpSetClientInfo,
    (SERVER_ROUTINE)R_DhcpGetClientInfo,
    (SERVER_ROUTINE)R_DhcpDeleteClientInfo,
    (SERVER_ROUTINE)R_DhcpEnumSubnetClients,
    (SERVER_ROUTINE)R_DhcpGetClientOptions,
    (SERVER_ROUTINE)R_DhcpGetMibInfo,
    (SERVER_ROUTINE)R_DhcpEnumOptions,
    (SERVER_ROUTINE)R_DhcpSetOptionValues,
    (SERVER_ROUTINE)R_DhcpServerSetConfig,
    (SERVER_ROUTINE)R_DhcpServerGetConfig,
    (SERVER_ROUTINE)R_DhcpScanDatabase,
    (SERVER_ROUTINE)R_DhcpGetVersion,
    (SERVER_ROUTINE)R_DhcpAddSubnetElementV4,
    (SERVER_ROUTINE)R_DhcpEnumSubnetElementsV4,
    (SERVER_ROUTINE)R_DhcpRemoveSubnetElementV4,
    (SERVER_ROUTINE)R_DhcpCreateClientInfoV4,
    (SERVER_ROUTINE)R_DhcpSetClientInfoV4,
    (SERVER_ROUTINE)R_DhcpGetClientInfoV4,
    (SERVER_ROUTINE)R_DhcpEnumSubnetClientsV4,
    (SERVER_ROUTINE)R_DhcpSetSuperScopeV4,
    (SERVER_ROUTINE)R_DhcpGetSuperScopeInfoV4,
    (SERVER_ROUTINE)R_DhcpDeleteSuperScopeV4,
    (SERVER_ROUTINE)R_DhcpServerSetConfigV4,
    (SERVER_ROUTINE)R_DhcpServerGetConfigV4
    };

static const MIDL_SERVER_INFO dhcpsrv_ServerInfo = 
    {
    &dhcpsrv_StubDesc,
    dhcpsrv_ServerRoutineTable,
    __MIDL_ProcFormatString.Format,
    dhcpsrv_FormatStringOffsetTable,
    0,
    0,
    0,
    0};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\endpoint.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

Module Name:
    endpoint.h

Abstract:
    endpoint structure.

Environment:
    NT5 DHCP Server.

--*/

#ifndef ENDPOINT_H_INCLUDED
#define ENDPOINT_H_INCLUDED

typedef struct _ENDPOINT {
    ENDPOINT_ENTRY IpTblEndPoint;
    SOCKET Socket;
    SOCKET RogueDetectSocket;
    SOCKET MadcapSocket;
    ULONG Flags;
} ENDPOINT, *PENDPOINT;

#define ENDPOINT_FLAG_BOUND 0x1
#define ENDPOINT_FLAG_MADCAP 0x2

#define SET_ENDPOINT_BOUND( _endpoint ) ( (_endpoint)->Flags |= ENDPOINT_FLAG_BOUND )
#define SET_ENDPOINT_UNBOUND( _endpoint ) ( (_endpoint)->Flags &= ~ENDPOINT_FLAG_BOUND )
#define IS_ENDPOINT_BOUND( _endpoint )  ( (_endpoint)->Flags & ENDPOINT_FLAG_BOUND )

#define SET_ENDPOINT_MADCAP( _endpoint ) ( (_endpoint)->Flags |= ENDPOINT_FLAG_MADCAP )
#define SET_ENDPOINT_DHCP( _endpoint ) ( (_endpoint)->Flags &= ~ENDPOINT_FLAG_MADCAP )
#define IS_ENDPOINT_MADCAP( _endpoint )  ( (_endpoint)->Flags & ENDPOINT_FLAG_MADCAP )

DWORD
InitializeEndPoints(
    VOID
    );

VOID
CleanupEndPoints(
    VOID
    );

VOID
DhcpUpdateEndpointBindings(
    VOID
    );

ULONG
DhcpSetBindingInfo(
    IN LPDHCP_BIND_ELEMENT_ARRAY BindInfo
    );

ULONG
DhcpGetBindingInfo(
    OUT LPDHCP_BIND_ELEMENT_ARRAY *BindInfo
    );

#endif  ENDPOINT_H_INCLUDED

//
// end of file.
//

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\endpoint.c ===
/*++

Copyright (C) 1998 Microsoft Corporation

Module Name:
    endpoint.c

Abstract:
    handles endpoints for dhcp server.

Environment:
    dhcpserver NT5+

--*/

#include <dhcppch.h>
#include <guiddef.h>
#include <convguid.h>
#include <iptbl.h>
#include <endpoint.h>
#include <ws2tcpip.h>
#include <mstcpip.h>
#include <nhapi.h>
#include <netconp.h>

#define SOCKET_RECEIVE_BUFFER_SIZE      (1024 * 64) // 64K max.

ULONG InitCount = 0;

BOOL
IsIpAddressBound(
    IN GUID *IfGuid,
    IN ULONG IpAddress
    );

DWORD
InitializeSocket(
    OUT SOCKET *Sockp,
    IN DWORD IpAddress,
    IN DWORD Port,
    IN DWORD McastAddress OPTIONAL
    )
/*++

Routine Description:
    Create and initialize a socket for DHCP.

    N.B. This routine also sets the winsock buffers, marks socket to
    allow broadcast and all those good things.

Arguments:
    Sockp -- socket to create and intiialize
    IpAddress -- ip address to bind the socket to
    Port -- the port to bind the socket to
    McastAddress -- if present, join this mcast address group

Return Values:
    winsock errors

--*/
{
    DWORD Error;
    DWORD OptValue, BufLen = 0;
    SOCKET Sock;
    struct sockaddr_in SocketName;
    struct ip_mreq mreq;

    Sock = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );

    if ( Sock == INVALID_SOCKET ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    OptValue = TRUE;
    Error = setsockopt(
        Sock,
        SOL_SOCKET,
        SO_REUSEADDR,
        (LPBYTE)&OptValue,
        sizeof(OptValue)
    );

    if ( Error != ERROR_SUCCESS ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    OptValue = TRUE;
    Error = setsockopt(
        Sock,
        SOL_SOCKET,
        SO_BROADCAST,
        (LPBYTE)&OptValue,
        sizeof(OptValue)
    );

    if ( Error != ERROR_SUCCESS ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    OptValue = SOCKET_RECEIVE_BUFFER_SIZE;
    Error = setsockopt(
        Sock,
        SOL_SOCKET,
        SO_RCVBUF,
        (LPBYTE)&OptValue,
        sizeof(OptValue)
    );

    if ( Error != ERROR_SUCCESS ) {
        Error = WSAGetLastError();
        goto Cleanup;
    }

    if( INADDR_ANY != IpAddress ) {
        OptValue = 1;
        Error = WSAIoctl(
            Sock, SIO_LIMIT_BROADCASTS, &OptValue, sizeof(OptValue),
            NULL, 0, &BufLen, NULL, NULL
            );

        if ( Error != ERROR_SUCCESS ) {
            Error = WSAGetLastError();
            goto Cleanup;
        }
    }
    
    SocketName.sin_family = PF_INET;
    SocketName.sin_port = htons( (unsigned short)Port );
    SocketName.sin_addr.s_addr = IpAddress;
    RtlZeroMemory( SocketName.sin_zero, 8);

    Error = bind(
        Sock,
        (struct sockaddr FAR *)&SocketName,
        sizeof( SocketName )
    );

    if ( Error != ERROR_SUCCESS ) {
        Error = WSAGetLastError();
        DhcpPrint((DEBUG_ERRORS,"bind failed with, %ld\n",Error));
        goto Cleanup;
    }

    //
    // If asked, then join mcast group
    //
    if( McastAddress ) {
        mreq.imr_multiaddr.s_addr = McastAddress;
        mreq.imr_interface.s_addr  = IpAddress;

        if ( SOCKET_ERROR == setsockopt(
            Sock,IPPROTO_IP,IP_ADD_MEMBERSHIP,(char *)&mreq,sizeof(mreq))
        ) {
            Error = WSAGetLastError();
            DhcpPrint((DEBUG_ERRORS,"could not join multicast group %ld\n",Error ));
            goto Cleanup;
        }
    }

    *Sockp = Sock;
    return ERROR_SUCCESS;

  Cleanup:

    //
    // if we aren't successful, close the socket if it is opened.
    //

    if( Sock != INVALID_SOCKET ) {
        closesocket( Sock );
    }

    return Error;
}


DWORD
DhcpInitializeEndpoint(
    PENDPOINT endpoint
    )
/*++

Routine Description:

    This function initializes an endpoint by creating and binding a
    socket to the local address.

Arguments:

    Socket - Receives a pointer to the newly created socket

    IpAddress - The IP address to initialize to.

    Port - The port to bind to.

Return Value:

    The status of the operation.

--*/
{
    DWORD Error;

    DhcpPrint((
        DEBUG_INIT, "Dhcpserver initializing endpoint %s\n",
        inet_ntoa(*(struct in_addr *)&endpoint->IpTblEndPoint.IpAddress)
        ));

    DhcpAssert( !IS_ENDPOINT_BOUND( endpoint ));

    //
    // first open socket for dhcp traffic
    //

    Error = InitializeSocket(
        &endpoint->Socket, endpoint->IpTblEndPoint.IpAddress,
        DhcpGlobalServerPort, 0
    );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((
            DEBUG_ERRORS,
            "DhcpInitializeEndpoint: %ld (0x%lx)\n", Error, Error
            ));
        return Error;
    }

    //
    // now open socket for mdhcp traffic
    //

    Error = InitializeSocket(
        &endpoint->MadcapSocket, endpoint->IpTblEndPoint.IpAddress,
        MADCAP_SERVER_PORT, MADCAP_SERVER_IP_ADDRESS
    );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((
            DEBUG_ERRORS, "DhcpInitializeEndpoint:"
            " %ld (0x%lx)\n", Error, Error
            ));
        return Error;
    }

    //
    // Finally open socket for rogue detection receives
    //
    Error = InitializeSocket(
        &endpoint->RogueDetectSocket,
        endpoint->IpTblEndPoint.IpAddress,
        DhcpGlobalClientPort, 0
    );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((
            DEBUG_ERRORS,
            "InitializeSocket: could not open rogue socket:%ld (0x%lx)\n",
            Error,Error));
        closesocket(endpoint->Socket);
        return Error;
    }

    SET_ENDPOINT_BOUND( endpoint );

    if ( DhcpGlobalNumberOfNetsActive++ == 0 ) {
        //
        // Signal MessageLoop waiting for endpoint to be ready..
        //
        DhcpPrint((
            DEBUG_MISC, "Activated an enpoint.."
            "pulsing the DhcpWaitForMessage thread\n"
            ));
        SetEvent( DhcpGlobalEndpointReadyEvent );
    }


    DhcpGlobalRogueRedoScheduledTime = 0;
    DhcpGlobalRedoRogueStuff = TRUE;
    SetEvent(DhcpGlobalRogueWaitEvent);
    
    return ERROR_SUCCESS;
}

DWORD
DhcpDeinitializeEndpoint(
    PENDPOINT    endpoint
    )
/*++

Routine Description:

    This function deinitializes the endpoint. It just closes the
    sockets and marks this interface unusable.

Arguments:

    endpoint -- clear the endpoint

Return Value:

    The status of the operation.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    DWORD LastError;

    DhcpPrint((
        DEBUG_INIT, "Deinitializing endpoint %s\n",
        inet_ntoa(*(struct in_addr
                    *)&endpoint->IpTblEndPoint.IpAddress)
        ));

    if ( endpoint->Socket != INVALID_SOCKET
         && endpoint->Socket != 0) {

        Error = LastError = closesocket(endpoint->Socket);
        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint((
                DEBUG_ERRORS, "Deinitialize endpoint could "
                "not close socket %lx\n", endpoint->Socket
                ));
        }
    }
    if ( endpoint->RogueDetectSocket != INVALID_SOCKET
         && endpoint->RogueDetectSocket != 0) {

        LastError = closesocket(endpoint->RogueDetectSocket);
        if ( LastError != ERROR_SUCCESS ) {
            Error = LastError;
            DhcpPrint((
                DEBUG_ERRORS, "Deinitialize endpoint could "
                "not close socket %lx\n", endpoint->RogueDetectSocket
                ));
        }
    }

    if ( endpoint->MadcapSocket != INVALID_SOCKET
         && endpoint->MadcapSocket != 0) {

        LastError = closesocket(endpoint->MadcapSocket);
        if ( LastError != ERROR_SUCCESS ) {
            Error = LastError;
            DhcpPrint((
                DEBUG_ERRORS, "Deinitialize endpoint could "
                "not close socket %lx\n", endpoint->MadcapSocket
                ));
        }
    }

    endpoint->Socket = INVALID_SOCKET;
    endpoint->MadcapSocket = INVALID_SOCKET;
    endpoint->RogueDetectSocket = INVALID_SOCKET;
    if ( IS_ENDPOINT_BOUND( endpoint ) ) {
        DhcpGlobalNumberOfNetsActive--;
        SET_ENDPOINT_UNBOUND( endpoint );
        if( 0 == DhcpGlobalNumberOfNetsActive ) {
            DhcpPrint((
                DEBUG_MISC, "Closing last active endpoint.. "
                "so resetting event for DhcpWaitForMessage\n"));
            ResetEvent(DhcpGlobalEndpointReadyEvent);
        }
    }

    DhcpGlobalRogueRedoScheduledTime = 0;
    DhcpGlobalRedoRogueStuff = TRUE;
    SetEvent(DhcpGlobalRogueWaitEvent);
    
    return Error;

}

VOID _stdcall
EndPointChangeHandler(
    IN ULONG Reason,
    IN OUT PENDPOINT_ENTRY Entry
    )
{
    PENDPOINT Ep = (PENDPOINT) Entry;

    if( REASON_ENDPOINT_CREATED == Reason ) {
        //
        // If endpoint just created, just mark it unbound.
        // We can check bindings later when the endpoint gets
        // refreshed.
        //
        DhcpPrint((
            DEBUG_PNP, "New EndPoint: %s\n",
            inet_ntoa(*(struct in_addr*)&Entry->IpAddress)
            ));

        SET_ENDPOINT_UNBOUND(Ep);
        return;
    }

    if( REASON_ENDPOINT_DELETED == Reason ) {
        //
        // If the endpoint is getting deleted, we only have
        // to do work if the endpoint is bound.
        //
        DhcpPrint((
            DEBUG_PNP, "EndPoint Deleted: %s\n",
            inet_ntoa(*(struct in_addr*)&Entry->IpAddress)
            ));
        if( !IS_ENDPOINT_BOUND(Ep) ) return;
        DhcpDeinitializeEndpoint(Ep);
        return;
    }

    if( REASON_ENDPOINT_REFRESHED == Reason ) {
        //
        // If the endpoint is getting refreshed, we need to check
        // if it is bound or unbound and if there is a state
        // change, we need to do accordingly.
        //
        BOOL fBound = IsIpAddressBound(
            &Entry->IfGuid, Entry->IpAddress
            );

        DhcpPrint((
            DEBUG_PNP, "EndPoint Refreshed: %s\n",
            inet_ntoa(*(struct in_addr*)&Entry->IpAddress)
            ));
        DhcpPrint((DEBUG_PNP, "Endpoint bound: %d\n", fBound));

        if( fBound ) {
            if( IS_ENDPOINT_BOUND(Ep) ) return;
            DhcpInitializeEndpoint(Ep);
        } else {
            if( !IS_ENDPOINT_BOUND(Ep) ) return;
            DhcpDeinitializeEndpoint(Ep);
        }
        return;
    }
}

DWORD
InitializeEndPoints(
    VOID
    )
{
    ULONG Status;

    InitCount ++;
    if( 1 != InitCount ) return ERROR_SUCCESS;

    Status = IpTblInitialize(
        &DhcpGlobalEndPointCS,
        sizeof(ENDPOINT),
        EndPointChangeHandler,
        GetProcessHeap()
        );
    if( NO_ERROR != Status ) {
        InitCount --;
    }

    return Status;
}

VOID
CleanupEndPoints(
    VOID
    )
{
    if( 0 == InitCount ) return;
    InitCount --;
    if( 0 != InitCount ) return;

    IpTblCleanup();
}

//
// Bindings.
//

#define MAX_GUID_NAME_SIZE 60

BOOL
IsIpAddressBound(
    IN GUID *IfGuid,
    IN ULONG IpAddress
    )
{
    ULONG Status, SubnetMask, SubnetAddr;
    WCHAR KeyName[MAX_GUID_NAME_SIZE];
    HKEY IfKey;
    BOOL fRetVal;

    //
    // Fast check to see if this IP Address is part of
    // DHCPServer\Parameters\Bind key
    //

    fRetVal = FALSE;
    if( QuickBound( IpAddress, &SubnetMask, &SubnetAddr, &fRetVal ) ) {

        DhcpPrint((DEBUG_PNP, "Interface is quick bound: %ld\n", fRetVal));
        return fRetVal;
    }

    if(!ConvertGuidToIfNameString(
        IfGuid, KeyName, sizeof(KeyName)/sizeof(WCHAR))) {
        //
        // Couldn't convert the guid to interface!!!!
        //
        DhcpPrint((DEBUG_PNP, "Couldn't converg guid to string\n"));
        DhcpAssert(FALSE);
        return FALSE;
    }

    //
    // Now open the key required.
    //

    Status = DhcpOpenInterfaceByName(
        KeyName,
        &IfKey
        );
    if( NO_ERROR != Status ) {
        //
        // Hmm... we have an interface which doesn't have a key?
        //
        DhcpPrint((DEBUG_PNP, "Couldnt open reg key: %ws\n", KeyName));
        DhcpAssert(FALSE);
        return FALSE;
    }

    fRetVal = FALSE;
    do {
        //
        // Now check to see if IP address is static or not.
        // If it is dhcp enabled, then we cannot process it.
        //
        if( !IsAdapterStaticIP(IfKey) ) {
            DhcpPrint((DEBUG_PNP, "Adapter %ws has no static IP\n", KeyName));
            break;
        }

        //
        // Now check to see if this is part of the bound or
        // unbound list for this interface.
        //
        fRetVal = CheckKeyForBinding(
            IfKey, IpAddress
            );
    } while ( 0 );

    RegCloseKey(IfKey);
    return fRetVal;
}

BOOL _stdcall
RefreshBinding(
    IN OUT PENDPOINT_ENTRY Entry,
    IN PVOID Ctxt_unused
    )
/*++

Routine Description:
    This routine refreshes the bindings information from
    the registry for the endpoint in question.

    N.B. This is done by faking a EndPointChangeHandler event
    handler with the endpoint.

Arguments:
    Entry -- endpoint entry.
    Ctxt_unused -- unused parameter.

Return Value:
    TRUE always so that the WalkthroughEndpoints routine tries
    to do this on the next endpoint.

--*/
{
    UNREFERENCED_PARAMETER(Ctxt_unused);

    EndPointChangeHandler(
        REASON_ENDPOINT_REFRESHED,
        Entry
        );
    return TRUE;
}

VOID
DhcpUpdateEndpointBindings(
    VOID
    )
/*++

Routine Description:
    This routine udpates all the endpoints to see if they are bound or
    not, by reading the registry.

--*/
{
    WalkthroughEndpoints(
        NULL,
        RefreshBinding
        );
}

LPWSTR
GetFriendlyNameFromGuidStruct(
    IN GUID *pGuid
    )
/*++

Routine Description:
    This routine calls the NHAPI routine to find out if there is a
    friendly name for the given interface guid...
    If this succeeds the routine returns the friendly name string
    allocated via DhcpAllocateMemory (and hence this must be freed
    via the same mechanism).

Arguments:
    pGuid -- the guid for which friendly connection name is needed.

Return Values:
    NULL -- error, or no such connection guid.
    connection name string.

--*/
{
    ULONG Error = 0, Size;
    LPWSTR String;

    String = NULL; Size = 0;

    while ( TRUE ) {
        Error = NhGetInterfaceNameFromGuid(
            pGuid, String, &Size, FALSE, TRUE
            );
        if( ERROR_INSUFFICIENT_BUFFER != Error &&
            ERROR_MORE_DATA != Error ) {
            break;
        }

        DhcpAssert( 0 != Size );
        if( String ) DhcpFreeMemory( String );
        String  = DhcpAllocateMemory( (Size+1)*sizeof(WCHAR));
        if( NULL == String ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
    }

    SetLastError( Error );
    if( ERROR_SUCCESS != Error ) {
        if( String ) DhcpFreeMemory( String );
        String = NULL;
    }

    return String;
}

LPWSTR
GetFriendlyNameFromGuidString(
    IN LPCWSTR GuidString
    )
/*++

Routine Description:
    This routine tries to get the connection name via the LAN
    connections API.  The returned string is allocated via
    DhcpAllocateMemory  and should be freed using counterpart..

Arguments:
    GuidString -- this string should include the "{}" ...

Return Values:
    valid lan connection name... or NULL

--*/
{
    HRESULT Result;
    LPWSTR RetVal;
    ULONG Size;

    RetVal = NULL; Size = 0;

    Result = HrLanConnectionNameFromGuidOrPath(
        NULL, GuidString, RetVal, &Size
        );
    if( !SUCCEEDED(Result) ) {
        return NULL;
    }

    DhcpAssert( 0 != Size );
    RetVal = DhcpAllocateMemory( (Size+1)*sizeof(WCHAR) );
    if( NULL == RetVal ) return NULL;

    Result = HrLanConnectionNameFromGuidOrPath(
        NULL, GuidString, RetVal, &Size
        );
    if( !SUCCEEDED(Result) ) {
        DhcpFreeMemory(RetVal);
        return NULL;
    }

    return RetVal;
}

LPWSTR
GetFriendlyNameFromGuid(
    IN GUID *pGuid,
    IN LPCWSTR GuidString
    )
{
    LPWSTR RetVal;

    RetVal = GetFriendlyNameFromGuidStruct(pGuid);
    if( NULL != RetVal ) return RetVal;

    return GetFriendlyNameFromGuidString(GuidString);
}

BOOL
IsEndpointQuickBound(
    IN PENDPOINT_ENTRY Entry
    )
/*++

Routine Description:
    This routine checks to see if the endpoint is bound because
    it is a "quick bind".

Return Value:
    TRUE -- yes quick bound
    FALSE -- no, not quickbound

--*/
{
    BOOL fStatus, fRetVal;
    ULONG DummyMask, DummyAddress;

    //
    // First check if it is bound in the first place.
    //
    if( !IS_ENDPOINT_BOUND((PENDPOINT)Entry) ) {
        return FALSE;
    }

    //
    // Now check if the endpoint IP address is present in the
    // quickbind array.
    //

    fStatus = QuickBound(
        Entry->IpAddress, &DummyMask, &DummyAddress,
        &fRetVal
        );

    //
    // If quickbound then return TRUE.
    //
    return  fStatus && fRetVal;
}

typedef struct {
    LPDHCP_BIND_ELEMENT_ARRAY Info;
    ULONG Error;
} BIND_INFO_CTXT;

BOOL
ProcessQuickBoundInterface(
    IN PENDPOINT_ENTRY Entry,
    IN PVOID Context,
    OUT BOOL *fStatus
    )
/*++

Routine Description:
    Check if the entpoint under consideration is bound to
    an interface because it is "QuickBound" -- if so,
    update the Context structure to include info about this
    interface.

Return Value:
    TRUE -- yes interface is quickbound.
    FALSE -- no interface is not quick bound.

    If this routine returns TRUE, then fStatus is also set.
    In this case fStatus would be set to TRUE, unless some
    fatal error occurred.

--*/
{
    BOOL fRetVal;
    BIND_INFO_CTXT *Ctxt = (BIND_INFO_CTXT *)Context;
    LPDHCP_BIND_ELEMENT Elts;
    ULONG Size, i;

    fRetVal = IsEndpointQuickBound(Entry);
    if( FALSE == fRetVal ) return fRetVal;

    (*fStatus) = TRUE;

    do {

        Size = Ctxt->Info->NumElements + 1;
        Elts = MIDL_user_allocate(sizeof(*Elts)*Size);
        if( NULL == Elts ) {
            Ctxt->Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        Elts->IfIdSize = sizeof(Entry->IfGuid);
        Elts->IfId = MIDL_user_allocate(sizeof(Entry->IfGuid));
        if( NULL == Elts->IfId ) {
            MIDL_user_free(Elts);
            Ctxt->Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        RtlCopyMemory(Elts->IfId, &Entry->IfGuid, sizeof(GUID));

        Elts->IfDescription = MIDL_user_allocate(
            sizeof(WCHAR)*( 1 +
            wcslen(GETSTRING(DHCP_CLUSTER_CONNECTION_NAME)))
            );
        if( NULL == Elts->IfDescription ) {
            MIDL_user_free(Elts->IfId);
            MIDL_user_free(Elts);
            Ctxt->Error = ERROR_NOT_ENOUGH_MEMORY;
        }

        wcscpy(
            Elts->IfDescription,
            GETSTRING(DHCP_CLUSTER_CONNECTION_NAME)
            );

        Elts->Flags = DHCP_ENDPOINT_FLAG_CANT_MODIFY;
        Elts->fBoundToDHCPServer = TRUE;
        Elts->AdapterPrimaryAddress = Entry->IpAddress;
        Elts->AdapterSubnetAddress = Entry->SubnetMask;

        if( Ctxt->Info->NumElements ) {
            MoveMemory(
                &Elts[1],
                Ctxt->Info->Elements,
                sizeof(*Elts)*Ctxt->Info->NumElements
                );
            MIDL_user_free(Ctxt->Info->Elements);
        }
        Ctxt->Info->Elements = Elts;
        Ctxt->Info->NumElements ++;

        //
        // Cool. return.
        //
        return TRUE;

    } while ( 0 );

    //
    // cleanup and error return.
    //

    (*fStatus) = FALSE;
    //
    // The only reason to come here is if there was an error
    // so, we will free everything up.
    //
    for( i = 0; i < Ctxt->Info->NumElements ; i ++ ) {
        MIDL_user_free(Ctxt->Info->Elements[i].IfId);
        MIDL_user_free(Ctxt->Info->Elements[i].IfDescription);
    }
    MIDL_user_free(Ctxt->Info->Elements);
    Ctxt->Info->Elements = NULL;
    Ctxt->Info->NumElements = 0;

    return TRUE;

}

BOOL _stdcall
AddBindingInfo(
    IN OUT PENDPOINT_ENTRY Entry,
    IN PVOID Context
    )
/*++

Routine Description:
    Add the endpoint to the binding information
    collected so far, reallocating memory if needed.

Return Value:
    FALSE on error (In this case Ctxt.Error is set and
        the array in Info is cleared).
    TRUE if an element was successfully added.

--*/
{
    ULONG i, Size, Error;
    BOOL fStatus;
    BIND_INFO_CTXT *Ctxt = (BIND_INFO_CTXT *)Context;
    LPDHCP_BIND_ELEMENT Elts;
    WCHAR IfString[MAX_GUID_NAME_SIZE];
    LPWSTR FriendlyNameString = NULL, Descr;
    HKEY IfKey;

    //
    // Process QuickBound Interfaces..
    //
    if( ProcessQuickBoundInterface(Entry, Context, &fStatus ) ) {
        return fStatus;
    }

    //
    // First check to see if the adapter is dhcp enabled.
    // then we won't even show it here.
    //
    fStatus = ConvertGuidToIfNameString(
        &Entry->IfGuid,
        IfString,
        MAX_GUID_NAME_SIZE
        );
    DhcpAssert(fStatus);

    //
    // Now open the key required.
    //
    Error = DhcpOpenInterfaceByName(
        IfString,
        &IfKey
        );
    if( NO_ERROR != Error ) {
        DhcpAssert(FALSE);
        //
        // ignore interface.
        //
        return TRUE;
    }

    fStatus = IsAdapterStaticIP(IfKey);

    if( TRUE == fStatus ) {
        //
        // For static, check if this is the first IP address,
        // and hence bindable..
        //
        fStatus = CheckKeyForBindability(
            IfKey,
            Entry->IpAddress
            );
    }

    RegCloseKey( IfKey );

    //
    // Ignore DHCP enabled interfaces or non-bindable interfaces.
    //
    if( FALSE == fStatus ) return TRUE;

    //
    // Get interface friendly name..
    //

    FriendlyNameString = GetFriendlyNameFromGuid(
        &Entry->IfGuid, IfString
        );

    if( NULL == FriendlyNameString ) FriendlyNameString = IfString;

    //
    // Aargh. New interface. Need to allocate more space.
    //

    do {
        BOOL fStatus;

        Size = Ctxt->Info->NumElements + 1 ;
        Elts = MIDL_user_allocate(sizeof(*Elts)*Size);
        if( NULL == Elts ) {
            Ctxt->Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        Elts->IfIdSize = sizeof(Entry->IfGuid);
        Elts->IfId = MIDL_user_allocate(sizeof(Entry->IfGuid));
        if( NULL == Elts->IfId ) {
            MIDL_user_free(Elts);
            Ctxt->Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        RtlCopyMemory(Elts->IfId,&Entry->IfGuid,sizeof(GUID));

        Elts->IfDescription = MIDL_user_allocate(
            sizeof(WCHAR)*(1+wcslen(FriendlyNameString))
            );
        if( NULL == Elts->IfDescription ) {
            MIDL_user_free(Elts->IfId);
            MIDL_user_free(Elts);
            Ctxt->Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        wcscpy( Elts->IfDescription, FriendlyNameString );

        Elts->Flags = 0;
        if( IS_ENDPOINT_BOUND(((PENDPOINT)Entry)) ) {
            Elts->fBoundToDHCPServer = TRUE;
        } else {
            Elts->fBoundToDHCPServer = FALSE;
        }

        Elts->AdapterPrimaryAddress = Entry->IpAddress;
        Elts->AdapterSubnetAddress = Entry->SubnetMask;

        if( Ctxt->Info->NumElements ) {
            MoveMemory(
                &Elts[1],
                Ctxt->Info->Elements,
                sizeof(*Elts)*Ctxt->Info->NumElements
                );
            MIDL_user_free(Ctxt->Info->Elements);
        }
        Ctxt->Info->Elements = Elts;
        Ctxt->Info->NumElements ++;

        if( NULL != FriendlyNameString &&
            IfString != FriendlyNameString ) {
            LocalFree( FriendlyNameString );
            FriendlyNameString = NULL;
        }
        //
        // process the next endpoint entry.
        //

        return TRUE;
    } while ( 0 );

    if( NULL != FriendlyNameString &&
        IfString != FriendlyNameString ) {
        LocalFree( FriendlyNameString );
        FriendlyNameString = NULL;
    }

    //
    // The only reason to come here is if there was an error
    // so, we will free everything up.
    //
    for( i = 0; i < Ctxt->Info->NumElements ; i ++ ) {
        MIDL_user_free(Ctxt->Info->Elements[i].IfId);
        MIDL_user_free(Ctxt->Info->Elements[i].IfDescription);
    }
    MIDL_user_free(Ctxt->Info->Elements);
    Ctxt->Info->Elements = NULL;
    Ctxt->Info->NumElements = 0;

    return FALSE;
}


ULONG
DhcpGetBindingInfo(
    OUT LPDHCP_BIND_ELEMENT_ARRAY *BindInfo
    )
/*++

Routine Description:
    This routine walks the binding information table and converts
    the information into the bindinfo structure.

    N.B. Since this routine is used for RPC, all allocations are
    done using MIDL_user_allocate and free's are done using
    MIDL_user_free.

Return Value:
    Win32 status?

--*/
{
    LPDHCP_BIND_ELEMENT_ARRAY LocalBindInfo;
    BIND_INFO_CTXT Ctxt;

    *BindInfo = NULL;
    LocalBindInfo = MIDL_user_allocate( sizeof(*LocalBindInfo));
    if( NULL == LocalBindInfo ) return ERROR_NOT_ENOUGH_MEMORY;

    LocalBindInfo->NumElements = 0;
    LocalBindInfo->Elements = NULL;
    Ctxt.Info = LocalBindInfo;
    Ctxt.Error = NO_ERROR;

    WalkthroughEndpoints(
        &Ctxt,
        AddBindingInfo
        );

    if( NO_ERROR == Ctxt.Error ) {
        *BindInfo = LocalBindInfo;
        return NO_ERROR;
    }

    MIDL_user_free( LocalBindInfo );
    *BindInfo = NULL;
    return Ctxt.Error;
}


ULONG
DhcpSetBindingInfo(
    IN LPDHCP_BIND_ELEMENT_ARRAY BindInfo
    )
/*++

Routine Description:
    This routine is the counterpart for the previous routine and it
    takes the array of binding information and sets it in the registry
    as well as updating the bindings.

Arguments:
    BindInfo -- the array of bindings information.

Return Value:
    Status.

--*/
{
    ULONG Error = 0, i;
    WCHAR IfString[MAX_GUID_NAME_SIZE];
    HKEY Key;

    //
    // First check if any element which has can't modify
    // is set to something other than bind..
    //
    for( i = 0; i < BindInfo->NumElements ; i ++ ) {
        if( BindInfo->Elements[i].Flags &
            DHCP_ENDPOINT_FLAG_CANT_MODIFY ) {
            if( ! BindInfo->Elements[i].fBoundToDHCPServer ) {
                return ERROR_DHCP_CANNOT_MODIFY_BINDINGS;
            }
        }
    }

    //
    // Now proceed with the rest.
    //
    for( i = 0; i < BindInfo->NumElements ; i ++ ) {
        GUID IfGuid;
        DHCP_IP_ADDRESS IpAddress;

        //
        // Skip entries marked un-modifiable.
        //
        if( BindInfo->Elements[i].Flags &
            DHCP_ENDPOINT_FLAG_CANT_MODIFY ) {
            continue;
        }

        IpAddress = BindInfo->Elements[i].AdapterPrimaryAddress;

        if( BindInfo->Elements[i].IfIdSize != sizeof(GUID)) {
            Error = ERROR_DHCP_NETWORK_CHANGED;
            break;
        }

        RtlCopyMemory(
            &IfGuid,
            BindInfo->Elements[i].IfId,
            BindInfo->Elements[i].IfIdSize
            );

        ConvertGuidToIfNameString(
            &IfGuid,
            IfString,
            MAX_GUID_NAME_SIZE
            );

        Error = DhcpOpenInterfaceByName(
            IfString,
            &Key
            );
        if( NO_ERROR != Error ) {
            RegCloseKey(Key);
            Error = ERROR_DHCP_NETWORK_CHANGED;
            break;
        }

        //
        // Check if this interface is static and bindable.
        //

        if( !IsAdapterStaticIP(Key)
            || FALSE == CheckKeyForBindability(Key, IpAddress) ) {
            //
            // Nope!
            //
            RegCloseKey(Key);
            Error = ERROR_DHCP_NETWORK_CHANGED;
            break;
        }

        //
        // Everything else looks fine. Just turn on the
        // bindings as requested.
        //

        Error = SetKeyForBinding(
            Key,
            IpAddress,
            BindInfo->Elements[i].fBoundToDHCPServer
            );
        RegCloseKey(Key);

        if( ERROR_SUCCESS != Error ) break;
    }

    //
    // Now refresh the bindings.
    //
    DhcpUpdateEndpointBindings();

    return Error;
}


//
// End of file
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\dsreg.h ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: This module does the DS downloads in a safe way.
// To do this, first a time check is made between registry and DS to see which
// is the latest... If the DS is latest, it is downloaded onto a DIFFERENT
// key from the standard location.  After a successful download, the key is just
// saved and restored onto the normal configuration key.
// Support for global options is lacking.
//================================================================================

VOID
DhcpDownloadDsToRegistry(
    VOID
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\global.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    global.c

Abstract:

    This module contains definitions for global server data.

Author:

    Madan Appiah  (madana)  10-Sep-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include "dhcpmsg.h"

#ifndef GLOBAL_DATA
#define GLOBAL_DATA

//
// main.c will #include this file with GLOBAL_DATA_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#undef EXTERN
#ifdef  GLOBAL_DATA_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

//
// process global data passed to this service from tcpsvcs.exe
//

EXTERN PTCPSVCS_GLOBAL_DATA TcpsvcsGlobalData;

//
// Lease extension.
//

EXTERN DWORD DhcpLeaseExtension;

//
// Dhcp Request in progress list.
//

EXTERN LIST_ENTRY DhcpGlobalInProgressWorkList;
EXTERN CRITICAL_SECTION DhcpGlobalInProgressCritSect;
EXTERN CRITICAL_SECTION DhcpGlobalBinlSyncCritSect;
//
// Registry pointers.
//

EXTERN HKEY DhcpGlobalRegSoftwareRoot;
EXTERN HKEY DhcpGlobalRegRoot;
EXTERN HKEY DhcpGlobalRegConfig;
EXTERN HKEY DhcpGlobalRegSubnets;
EXTERN HKEY DhcpGlobalRegMScopes;
EXTERN HKEY DhcpGlobalRegOptionInfo;
EXTERN HKEY DhcpGlobalRegGlobalOptions;
EXTERN HKEY DhcpGlobalRegSuperScope;

EXTERN HKEY DhcpGlobalRegParam;

EXTERN LPDHCP_SUPER_SCOPE_TABLE_ENTRY DhcpGlobalSuperScopeTable;
EXTERN DWORD DhcpGlobalTotalNumSubnets;

EXTERN CRITICAL_SECTION DhcpGlobalRegCritSect;

EXTERN DWORD DhcpGlobalNumberOfNetsActive;

EXTERN BOOL DhcpGlobalSubnetsListModified;
EXTERN BOOL DhcpGlobalSubnetsListEmpty;

//
// rogue dhcp detection data
//

EXTERN PCHAR    DhcpGlobalDSDomainAnsi;
EXTERN BOOL     DhcpGlobalOkToService;
EXTERN BOOL     DhcpGlobalRogueLogEventsLevel;

//
// stoc
//

EXTERN HANDLE               g_hevtProcessMessageComplete;
EXTERN DWORD                g_cMaxProcessingThreads;
EXTERN DWORD                g_cMaxActiveThreads;
EXTERN CRITICAL_SECTION     g_ProcessMessageCritSect;




//
// Database data
//

EXTERN JET_SESID DhcpGlobalJetServerSession;
EXTERN JET_DBID DhcpGlobalDatabaseHandle;
EXTERN JET_TABLEID DhcpGlobalClientTableHandle;

EXTERN TABLE_INFO *DhcpGlobalClientTable;   // point to static memory.
EXTERN CRITICAL_SECTION DhcpGlobalJetDatabaseCritSect;
EXTERN CRITICAL_SECTION DhcpGlobalMemoryCritSect;

EXTERN LPSTR DhcpGlobalOemDatabasePath;
EXTERN LPSTR DhcpGlobalOemBackupPath;
EXTERN LPSTR DhcpGlobalOemRestorePath;
EXTERN LPSTR DhcpGlobalOemJetRestorePath;
EXTERN LPSTR DhcpGlobalOemJetBackupPath;
EXTERN LPSTR DhcpGlobalOemDatabaseName;
EXTERN LPWSTR DhcpGlobalBackupConfigFileName;

EXTERN DWORD DhcpGlobalBackupInterval;
EXTERN BOOL DhcpGlobalDatabaseLoggingFlag;

EXTERN DWORD DhcpGlobalCleanupInterval;

EXTERN BOOL DhcpGlobalRestoreFlag;

EXTERN DWORD DhcpGlobalAuditLogFlag;
EXTERN DWORD DhcpGlobalDetectConflictRetries;
EXTERN DWORD DhcpGlobalPingType;

EXTERN DWORD DhcpGlobalScavengeIpAddressInterval;
EXTERN BOOL DhcpGlobalScavengeIpAddress;

//
// Service variables
//
EXTERN SERVICE_STATUS DhcpGlobalServiceStatus;
EXTERN SERVICE_STATUS_HANDLE DhcpGlobalServiceStatusHandle;

//
// Process data.
//

EXTERN HANDLE DhcpGlobalProcessTerminationEvent;
EXTERN HANDLE DhcpGlobalRogueWaitEvent;
EXTERN BOOL DhcpGlobalRedoRogueStuff;
EXTERN ULONG DhcpGlobalRogueRedoScheduledTime;
EXTERN DWORD DhcpGlobalScavengerTimeout;
EXTERN HANDLE DhcpGlobalProcessorHandle;
EXTERN HANDLE DhcpGlobalMessageHandle;

EXTERN DWORD DhcpGlobalMessageQueueLength;
EXTERN LIST_ENTRY DhcpGlobalFreeRecvList;
EXTERN LIST_ENTRY DhcpGlobalActiveRecvList;
EXTERN CRITICAL_SECTION DhcpGlobalRecvListCritSect;
EXTERN HANDLE DhcpGlobalRecvEvent;
EXTERN HANDLE DhcpGlobalMessageRecvHandle;

EXTERN DWORD DhcpGlobalRpcProtocols;
EXTERN BOOL DhcpGlobalRpcStarted;

EXTERN WCHAR DhcpGlobalServerName[MAX_COMPUTERNAME_LENGTH + 1];
EXTERN DWORD DhcpGlobalServerNameLen; // computer name len in bytes.
EXTERN HANDLE DhcpGlobalRecomputeTimerEvent;

EXTERN BOOL DhcpGlobalSystemShuttingDown;
EXTERN BOOL DhcpGlobalServiceStopping;

#if DBG
#define DEFAULT_MAXIMUM_DEBUGFILE_SIZE 20000000

EXTERN DWORD DhcpGlobalDebugFlag;
EXTERN CRITICAL_SECTION DhcpGlobalDebugFileCritSect;
EXTERN HANDLE DhcpGlobalDebugFileHandle;
EXTERN DWORD DhcpGlobalDebugFileMaxSize;
EXTERN LPWSTR DhcpGlobalDebugSharePath;

#endif // DBG

//
// MIB Counters;
//

DHCP_PERF_STATS *PerfStats;
DATE_TIME DhcpGlobalServerStartTime;

//
// misc
//
EXTERN DWORD DhcpGlobalIgnoreBroadcastFlag;     // whether to ignore the broadcast
                                                // bit in the client requests or not
EXTERN HANDLE g_hAuditLog;                      // audit log file handle
EXTERN DWORD DhcpGlobalAuditLogMaxSizeInBytes;  // max size of audit logging flie..

//
// string table stuff
//

#define  DHCP_FIRST_STRING DHCP_IP_LOG_ASSIGN_NAME
#define  DHCP_LAST_STRING  DHCP_LAST_STRING_DUMMY_MESSAGE
#define  DHCP_CSTRINGS (DHCP_LAST_STRING - DHCP_FIRST_STRING + 1)

#ifdef DBG
#define GETSTRING( dwID ) GetString( dwID )
#else
#define GETSTRING( dwID )  (g_ppszStrings[ dwID - DHCP_FIRST_STRING ])
#endif


EXTERN WCHAR  *g_ppszStrings[ DHCP_CSTRINGS ];

#endif // GLOBAL_DATA

//
// Dynamic jet loading
//

EXTERN AddressToInstanceMap *DhcpGlobalAddrToInstTable;
EXTERN HANDLE                DhcpGlobalTCPHandle;

EXTERN CRITICAL_SECTION    DhcpGlobalCacheCritSect;
EXTERN BOOL  DhcpGlobalUseNoDns;

EXTERN SOCKET   DhcpGlobalPnPNotificationSocket;
EXTERN HANDLE   DhcpGlobalEndpointReadyEvent;

EXTERN ULONG    DhcpGlobalAlertPercentage;
EXTERN ULONG    DhcpGlobalAlertCount;

//
// Debug only flag... dont use it when not in DBG build..
//
EXTERN BOOL fDhcpGlobalProcessInformsOnlyFlag;

//
// Is Dynamic BOOTP Enabled for this server?
//
EXTERN BOOL DhcpGlobalDynamicBOOTPEnabled;

//
// Are we bindings aware? By default we are.
//
EXTERN BOOL DhcpGlobalBindingsAware;

// how much clock skew allowed between madcap client and server
EXTERN DWORD DhcpGlobalClockSkewAllowance;
//how much extra allocation due to clock skew
EXTERN DWORD DhcpGlobalExtraAllocationTime;
//
// SIDs for dhcp users group and dhcp administrators group
//
EXTERN PSID DhcpSid;
EXTERN PSID DhcpAdminSid;

EXTERN ULONG DhcpGlobalMsft2000Class;
EXTERN ULONG DhcpGlobalMsft98Class;
EXTERN ULONG DhcpGlobalMsftClass;

EXTERN CRITICAL_SECTION DhcpGlobalEndPointCS;

//
// Security descriptors of Netlogon Service objects to control user accesses.
//


EXTERN PSECURITY_DESCRIPTOR DhcpGlobalSecurityDescriptor;
//
// Generic mapping for each Netlogon Service object object
//

EXTERN GENERIC_MAPPING DhcpGlobalSecurityInfoMapping
#ifdef GLOBAL_DATA_ALLOCATE
    = {
    STANDARD_RIGHTS_READ,                  // Generic read
    STANDARD_RIGHTS_WRITE,                 // Generic write
    STANDARD_RIGHTS_EXECUTE,               // Generic execute
    DHCP_ALL_ACCESS                        // Generic all
    }
#endif // GLOBAL_DATA_ALLOCATE
    ;

//
// Flag to indicate that the WELL known SID are made.
//

EXTERN BOOL DhcpGlobalWellKnownSIDsMade;

EXTERN ULONG DhcpGlobalServerPort, DhcpGlobalClientPort;

EXTERN DWORD DhcpGlobalRestoreStatus;
EXTERN BOOL DhcpGlobalImpersonated;

EXTERN PM_SERVER DhcpGlobalThisServer;

//================================================================================
// end of file
//================================================================================

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\dnsdb.c ===
/*++
   
Copyright (c) 1994 Microsoft Corporation

Module Name: 
    dnsdb.c

Abstract: 
    This module contains functions that work between Database and the 
    DhcpServer proper (more like database.c and other files).

    It helps implement Dynamic Dns Updates for the server side part.

Environment:
    User mode Win32 NT

--*/

#include "dhcppch.h"
#include <align.h>

LIST_ENTRY DhcpGlobalDnsCallbackList;
CRITICAL_SECTION DhcpGlobalDnsMemoryCriticalSection;
#define LOCK_MEM() EnterCriticalSection(&DhcpGlobalDnsMemoryCriticalSection)
#define UNLOCK_MEM() LeaveCriticalSection(&DhcpGlobalDnsMemoryCriticalSection)

//
//  To get better response, and to prevent memory leaks in this module,
//  the memory is managed with the following functions.
//  Only one structure is allocated with this function... This is the DNS context
//  structure (that will be defined later) -- that is used so that when DNS
//  calls back with a success code, we can clean up the database.
//
//  The three functions are implemented near the end.
//
LPVOID
DhcpDnsAllocateMemory(
    IN ULONG Size
    );

VOID
DhcpDnsFreeMemory(
    IN OUT LPVOID AllocatedPtr
    );

VOID
DhcpDnsAsyncDelete(
    IN DHCP_IP_ADDRESS IpAddress,
    IN LPWSTR ClientName,
    IN BYTE AddressState
    );

VOID
DhcpDnsAsyncAdd(
    IN DHCP_IP_ADDRESS IpAddress,
    IN LPWSTR ClientName,
    IN BYTE AddressState
);

VOID
DhcpDoDynDnsRefresh(
    IN DHCP_IP_ADDRESS IpAddress
    )
/*++

Routine Description:
    This routine reads the database for the current address specified and
    if the database indicates the record has not yet been registered (or
    de-registered ) with the DNS server yet, it refreshes the information
    without writing to the database.

    N.B -- It is assumed that the database lock is already taken.

Argument:
    IpAddress of record to refresh.

--*/
{
    DWORD Error, Size;
    CHAR AddressState;
    LPWSTR ClientName = NULL;

    if( USE_NO_DNS ) return;

    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        (PVOID) &IpAddress,
        sizeof(IpAddress)
        );

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "JetOpenKey(%s):%ld\n",
                   inet_ntoa(*(struct in_addr *)&IpAddress), Error)); 
        return;
    }

    Size = sizeof(AddressState);
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &AddressState,
        &Size
    );

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "JetGetValue(State, %s):%ld\n",
                   inet_ntoa(*(struct in_addr *)&IpAddress), Error));
        return;
    }

    //
    // If the record has the "yet-to-register" bit cleared, then no DNS
    // activity is pending so far as this record is concerned.
    //

    if( !IsAddressUnRegistered(AddressState) ) {
        DhcpPrint((DEBUG_ERRORS, "IsAddressUnRegistred(%2X,%s)=FALSE\n",
                   AddressState, inet_ntoa(*(struct in_addr *)&IpAddress)));
        return;
    }

    Size = 0;
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
        &ClientName,
        &Size
    );

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "JetGetValue(Name, %s):%ld\n",
                   inet_ntoa(*(struct in_addr *)&IpAddress), Error));
        return;
    }

    if( NULL == ClientName ) {
        //
        // Cannot have no name and the UNREGISTERED bit set..
        //
        DhcpAssert(FALSE);
        return;
    }

    //
    // Delete it in DNS if it is yet to be de-registered, otherwise just 
    // register with DNS again.
    //

    if( IsAddressDeleted(AddressState) ) {
        DhcpDnsAsyncDelete(IpAddress, ClientName, AddressState);
    } else if( IsAddressUnRegistered(AddressState) ) {
        DhcpDnsAsyncAdd(IpAddress, ClientName, AddressState);
    }

    if( ClientName ) DhcpFreeMemory(ClientName);
}

BOOL
DhcpDoDynDnsCheckDelete(
    IN DHCP_IP_ADDRESS IpAddress
)
/*++

Routine Description:
    This routine is called in several places, and it checks to see if DNS
    activity needs to be done before deleting the record for the given ip
    address.  If the given IP address has been successfully registered with
    DNS and requires to be removed (cleanup bit set), then it schedules a
    DNS de-registration and over-writes the time information in the record
    to indicate the time this scheduling has happened.....
    Also, the hw-address is munged so that that particular hw-addrses may
    appear in some other record without violating the hw-address
    uniqueness consistency of the database.  (No munging happens for
    reservations ofcourse).

    N.B  The database lock must be taken and the record pointer must point
    to the record given the by the IP address above..

Return Value:
    TRUE -- the record can be deleted either because no pending DNS
    activity for the record or because the record was deleted long back
    before and the DNS de-registration hasn't succeeded -- no point
    retrying again..

    FALSE -- DNS activity has been scheduled... record should not be
    deleted yet.

--*/
{
    DWORD Error, Size;
    BYTE OldAddressState, AddressState;
    LPWSTR ClientName;
    BYTE DummyHwAddress[sizeof(DWORD)+1+4];

    if( USE_NO_DNS ) return TRUE;

    DhcpPrint((DEBUG_DNS, "DhcpDoDynDnsCheckDelete %s\n",
               inet_ntoa( * (struct in_addr *) &IpAddress)));

    //
    // Get Address state information.  
    //

    Size = sizeof(AddressState);
    if( ERROR_SUCCESS != (Error = DhcpJetGetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &AddressState,
        &Size))) {
        DhcpPrint((DEBUG_ERRORS, "Failed to get state: %ld\n", Error));
        return TRUE;
    }
    OldAddressState = AddressState;

    if( !IsAddressCleanupRequired(OldAddressState)) {
        DhcpPrint((DEBUG_DNS, "Deleting record %s because "
                   "cleanup not required\n",
                   inet_ntoa(*(struct in_addr *)&IpAddress)));

        //
        // OK to delete if no cleanup required for this record..
        //
        return TRUE;
    }

    Size = 0;
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
        &ClientName,
        &Size
        );

    if(ERROR_SUCCESS != Error) {
        DhcpAssert(FALSE);
        DhcpPrint((DEBUG_ERRORS, "Could not get Client Name!\n"));
        return TRUE;
    }

    //
    // Set AddressState to DOOMED so that this record is not
    // mistaken for a valid IP address..
    //
    SetAddressStateDoomed(AddressState);

    //
    // Schedule a DNS delete for the record..
    //
    DhcpDnsAsyncDelete(IpAddress, ClientName, AddressState);

    //
    // Free ClientName as it was allocated by the DhcpJetGetValue
    // function. 
    if(ClientName) DhcpFreeMemory(ClientName); ClientName = NULL;

    //
    // Now set the address state OR'ed with DELETE bit on.
    //
    AddressState = AddressDeleted(AddressState);
    AddressState = AddressUnRegistered(AddressState);

    //
    // Now write this back onto the record.
    //
    Error = DhcpJetPrepareUpdate(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        &IpAddress,
        sizeof(IpAddress),
        FALSE
        );

    if(ERROR_SUCCESS != Error) {
        DhcpAssert(FALSE);
        DhcpPrint((DEBUG_ERRORS, "Could not write to "
                   "the database..:%ld\n", Error));
        //
        // Write failure?  just delete the darned record.
        //
        return TRUE;
    }

    //
    // Now munge hw-address if this is not a reservation..
    //

    Size = sizeof(AddressState);
    Error = DhcpJetSetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &AddressState,
        Size);
    DhcpAssert( ERROR_SUCCESS == Error );

    if( !DhcpServerIsAddressReserved( 
        DhcpGetCurrentServer(), IpAddress )) { 
        DhcpPrint((DEBUG_DNS, "Munging hw address "
                   "of non reservation client (deletion)\n"));

        Size = sizeof(DummyHwAddress);
        memset(DummyHwAddress, 0, sizeof(DummyHwAddress));
        memcpy(DummyHwAddress, (LPBYTE)&IpAddress, sizeof(IpAddress));
        Error = DhcpJetSetValue(
            DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
            DummyHwAddress,
            Size
        );
        DhcpAssert(ERROR_SUCCESS == Error );
    } else {
        DhcpPrint((DEBUG_DNS, "Not munging hw addr of reservation..\n"));
    }

    //
    // If old address deleted, check time stamp to figure out if we need 
    // to delete the record or just wait a while to try DNS de-registration
    // again.. 
    //

    if( IsAddressDeleted(OldAddressState) ) do {
        DATE_TIME TimeDiff, TimeNow = DhcpGetDateTime();
        FILETIME  LeaseExpires;

        //
        // Check if the time is lesser than now; If not, set lease expiry
        // time to now. 
        //

        Size = sizeof(LeaseExpires);
        Error = DhcpJetGetValue(
            DhcpGlobalClientTable[LEASE_TERMINATE_INDEX].ColHandle,
            &LeaseExpires,
            &Size
            );

        DhcpAssert(ERROR_SUCCESS == Error);
        if( ERROR_SUCCESS != Error ) break;

        if( CompareFileTime( (FILETIME *) &TimeNow, &LeaseExpires) <0) {
            //
            // have to reset the expiry time to NOW! (as lease not yet
            // expired, but need to fake expiration)
            //
            DhcpPrint((DEBUG_TRACE, "Setting expiry time to now..\n"));
            Error = DhcpJetSetValue(
                DhcpGlobalClientTable[LEASE_TERMINATE_INDEX].ColHandle,
                &TimeNow,
                sizeof(LeaseExpires)
            );
            break;
        }
        
        //
        // if it has been in this DELETED state for way too long, just
        // delete it. 
        //
        *(ULONGLONG UNALIGNED *)&TimeDiff =
            ((*(ULONGLONG UNALIGNED *)&TimeNow) - 
             (*(ULONGLONG UNALIGNED *)&LeaseExpires))/ 1000; 
        DhcpPrint((DEBUG_DNS, "Already deleted for [%u] micro-seconds!\n",
                   TimeDiff)); 
        DhcpPrint((DEBUG_DNS, "Max retry dns reg. time = %u"
                   " micro-seconds!\n", MAX_RETRY_DNS_REGISTRATION_TIME));

        if( *(ULONGLONG UNALIGNED *)&TimeDiff >=
            MAX_RETRY_DNS_REGISTRATION_TIME ) {
            //
            // the above comparison is in NANO seconds!
            //
            DhcpPrint((DEBUG_DNS, "Deleting really old ip address\n"));
            return TRUE;
        }

        //
        // This isn't a loop... Just don't like GOTOs much.
        //
    } while(0);
    
    //
    // Now commit changes. If we do NOT commit, nothing ever happens to the
    // changes!! 
    //
    if(ERROR_SUCCESS == Error) {
        Error = DhcpJetCommitUpdate();
    }

    if(ERROR_SUCCESS != Error) {
        DhcpAssert(FALSE);
        DhcpPrint((DEBUG_ERRORS, "Could not setval  to the"
                     " database..:%ld\n", Error)); 
        //
        // if we could not write this, might as well kill the record.
        //
        return TRUE;
    }

    //
    // OK. Did it.
    //
    DhcpPrint((DEBUG_TRACE, "Set Address state of %ws (%s) to %08x\n",
               L"", // had intended, machine name, but have freed it already..;-)
               inet_ntoa(* (struct in_addr *) &IpAddress),
               AddressState
        ));
    //
    // Should not delete.
    //

    return FALSE;
}

VOID
DhcpDoDynDnsCreateEntryWork(
    IN LPDHCP_IP_ADDRESS ClientIpAddress,
    IN BYTE bClientType,
    IN LPWSTR MachineName,
    IN OUT LPBYTE pAddressState,
    IN OUT LPBOOL pOpenExisting,
    IN BOOL BadAddress
)
/*++

Routine Description:
    This routine does the DynDns work associated with creating a new client
    entry...

    It checks to see if this is a new client, and if so does as required.
    If it is an update to an old client, then it undoes the previous DNS
    registration (if any) and redoes the new DNS registration.

    Because of this the value for the pOpenExisting variable may change.
    It also modifies the AddressState variable to indicate if DNS is
    pending etc..

    Also, if AddressState has the DOWNLEVEL bit turned on, then both A 
    and PTR registrations are done.   If the AddressState has the CLEANUP
    bit set, then the address will be removed on deletion..

    N.B. It is assumed that the database locks have been taken.
    
    N.B  Also, JetUpdate must be called by the caller to update info.  If
    not, something serious might happen. (?)

--*/
{
    DWORD Error, Size;
    BYTE PrevState;
    BOOL RecordExists = FALSE;
    LPWSTR OldClientName = NULL;

    if( USE_NO_DNS ) return;

    if( IS_ADDRESS_STATE_DECLINED(*pAddressState) ) {
        BadAddress = TRUE;
    }

    DhcpPrint((DEBUG_DNS, "DhcpDoDynDnsCreateEntryWork %s "
               "Open%sExisting %sAddress\n",
               inet_ntoa( * (struct in_addr *) ClientIpAddress),
               (*pOpenExisting)? "" : "Non",
               BadAddress?"Bad" :"Good"));
    DhcpPrint((DEBUG_DNS, "Machine is <%ws>\n",
               MachineName?MachineName:L"NULL")); 

    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        (PVOID) ClientIpAddress,
        sizeof(*ClientIpAddress)
        );

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_TRACE, "Could not do JetOpenKey(IPADDRESS %s):"
                   "%ld\n", 
                   inet_ntoa( * (struct in_addr *) ClientIpAddress), 
                   Error));
    }

    RecordExists = (ERROR_SUCCESS == Error); 

    if( RecordExists ) {
        DhcpPrint((DEBUG_TRACE, "Record Exists for Client %ws, %s\n",
                   MachineName, 
                   inet_ntoa(*(struct in_addr *) ClientIpAddress)));

        Size = sizeof(*pAddressState);
        if( ERROR_SUCCESS != DhcpJetGetValue(
            DhcpGlobalClientTable[STATE_INDEX].ColHandle,
            &PrevState,
            &Size)) {
            DhcpPrint((DEBUG_TRACE, "Failed to get state: %ld\n", Error));
            DhcpAssert(FALSE);
            return;
        }

        DhcpPrint((DEBUG_TRACE, "PrevState: 0x%2x\n", (int) PrevState));

        Size = 0;
        Error = DhcpJetGetValue(
            DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
            &OldClientName,
            &Size);

        if(ERROR_SUCCESS != Error)
            DhcpPrint((DEBUG_TRACE, "Could not get machine "
                       "name: %ld\n", Error));
        else DhcpPrint((DEBUG_TRACE, "OldClientName = %ws\n",
                        OldClientName?OldClientName:L"NULL"));
    }

    if( !*pOpenExisting ) {
        //
        // We DO NOT expect a record in this case.
        // What this means is that either there really is NO record,
        // Or there is a record marked DELETED, but is still there waiting for
        // Async Delete to work.
        // In the first case, we  are fine; the second case is common with the
        // OpenExisting = TRUE case. So, all that is done here is to check if
        // an un-DELETED record, exists.. if so, we return immediately as then,
        // the calling function would also be aborting.. (soon).
        //

        if( RecordExists && !IsAddressDeleted(PrevState) ) {
            DhcpPrint((DEBUG_ERRORS, "Trying to open with OpenExisting flag"
                       " set to FALSE" 
                       " and there is a record for this ip address!\n"));
            if(OldClientName) DhcpFreeMemory(OldClientName);
            return ;
        }

        //
        // Note that if record exists, we have to let the caller know abt
        // this.
        //
        if( RecordExists ) (*pOpenExisting) = TRUE;
    }

    //
    // Ok, we either have no record, or if !OpenExisting a deleted record, else
    // any record.  In any case, we call Async Delete to delete this record in the
    // hope that this call atleast might succeed. But, we'd lose track of this async
    // call as the db could get updated right after that. (well, not much chance..)
    // We also, may make sure that we DO NOT call this function if the client names
    // match.  
    //

    if( RecordExists ) {
        if( !IS_ADDRESS_STATE_OFFERED(PrevState) && OldClientName && 
            IsAddressCleanupRequired(PrevState) ) {
            BOOL fDel = TRUE;
            
            //
            // Do DNS deletion iff address wasnt ACK'ed before.
            //

            if( !BadAddress ) {
                if( MachineName && OldClientName
                    && 0 == _wcsicmp(MachineName, OldClientName)
                    ) {
                    fDel = FALSE;
                }
            }

            if( fDel ) {
                DhcpDnsAsyncDelete(
                    *ClientIpAddress, OldClientName, PrevState
                    );
            }
        }
    }


    //
    // No more work to do for bad addresses.
    //
    if( BadAddress ) {
        if(OldClientName) DhcpFreeMemory(OldClientName);
        return;
    }

    //
    //  Now we need to call the Async Register routine to do the Dns Stuff.
    //  But before that, we need to avoid bug 65666
    //

    if(!IS_ADDRESS_STATE_OFFERED(*pAddressState)) {
        DhcpPrint((DEBUG_TRACE, "Not offering..So bug 65666 is not a problem\n"));
    } else if(!IS_ADDRESS_STATE_ACTIVE(PrevState)) {
        DhcpPrint((DEBUG_TRACE, "PrevState is Not active..\n"));
    } else {
        //
        // Now change the state so that it is active.
        //
        SetAddressStateActive((*pAddressState));
        DhcpPrint((DEBUG_TRACE,"OK, changed state to: 0x%lx\n", (int)(*pAddressState)));
    }

    //
    // OK. Set the UnRegistered bit on. (only for non-null names + ACTIVE
    // leases)
    //
    if( MachineName && wcslen(MachineName) 
        && IS_ADDRESS_STATE_ACTIVE((*pAddressState)) 
        && IsAddressUnRegistered(*pAddressState) ) {
        
        DhcpDnsAsyncAdd(
            *ClientIpAddress, MachineName, (*pAddressState)
            );
    } else {
        //
        // Clear off the DNS bits off this record
        //
        (*pAddressState) = GetAddressState((*pAddressState));
    }

    DhcpPrint((DEBUG_DNS, "Returning, but OpenExisting=%d,"
               " AddressState=0x%02x\n", 
               (*pOpenExisting), (*pAddressState)));
    if(OldClientName) DhcpFreeMemory(OldClientName);
}


VOID
DhcpDoDynDnsReservationWork(
    IN DHCP_IP_ADDRESS ClientIpAddress,
    IN LPWSTR OldClientName,
    IN BYTE AddressState
)
/*++

Routine Description;
   This routine takes care of anything that needs to be done when a
   reservation is removed.  Currently it just calls the AsyncDelete
   routine. 

   N.B Databse locsk must be taken by caller as well as leaving the databse
   current record pointing at the record for ClientIpAddress.

--*/
{

    if( USE_NO_DNS ) return;
    DhcpPrint((DEBUG_TRACE,
               " DhcpDoDynDnsReservationWork for %s <%ws> (state: %d)\n", 
               inet_ntoa( * (struct in_addr *) &ClientIpAddress),
               OldClientName?OldClientName:L"NULL",
               AddressState
        ));

    DhcpDnsAsyncDelete(
        ClientIpAddress, OldClientName, AddressState
        );
    return ;
}


VOID
DhcpRealDeleteClient(
    IN DHCP_IP_ADDRESS IpAddress,
    IN LPWSTR ClientName,
    IN BYTE AddressState
)
/*++

Routine Description:
    This routine deletes the record for the given IpAddress from off the
    database provided that the ClientName and AddressState match in the
    database.  (If they don't match, something happened to the earlier
    record and the routine returns silently).

--*/
{
    DWORD Error, Size;
    LPWSTR OldClientName = NULL;
    BYTE PrevState;
    BOOL TransactBegin = FALSE;


    if( USE_NO_DNS ) DhcpAssert(FALSE);
    DhcpPrint((DEBUG_DNS, "DhcpRealDeleteClient(%s,%ws, %08x) entered\n",
               inet_ntoa(*(struct in_addr *) &IpAddress),
               ClientName?ClientName:L"NULL",
               AddressState));

    AddressState = GetAddressState(AddressState);
    LOCK_DATABASE();

    Error = DhcpJetBeginTransaction();

    if(ERROR_SUCCESS != Error) {
        UNLOCK_DATABASE();
        DhcpPrint((DEBUG_ERRORS, "Could not start transaction: %ld\n", Error));
        return;
    }

    Size = sizeof(IpAddress);
    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        (PVOID )&IpAddress,
        Size
        );

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "Deleting deleted key? %ws, %s\n",
                   ClientName?ClientName:L"NULL",
                   inet_ntoa(*(struct in_addr *)&IpAddress)));
        goto Cleanup;
    }

    //
    // OK. Got this record. Now get the ClientName and AddressState.
    //
    Size = sizeof(PrevState);
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &PrevState,
        &Size
        );
    
    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "could not get State info for %ws, %s\n", 
                   ClientName?ClientName:L"NULL", 
                   inet_ntoa(*(struct in_addr *)&IpAddress))); 

        goto Cleanup;
    } else DhcpPrint((DEBUG_TRACE, "Read AddressState=%08x\n", PrevState));

    if( !IsAddressDeleted(PrevState) || 
        !IsAddressUnRegistered(PrevState) ||
        AddressState != GetAddressState(PrevState)) {
        
        DhcpPrint((DEBUG_ERRORS, "Client tried to delete unregistered or undeleted record\n"));
        goto Cleanup;
    }

    //
    // Let DhcpJetGetValue allocate space for us.
    //
    Size = 0;
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
        &OldClientName,
        &Size);

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "Could not get machine name for %ws, %s\n",
                   ClientName?ClientName:L"NULL",
                   inet_ntoa(*(struct in_addr *)&IpAddress)));
        goto Cleanup;
    } else DhcpPrint((DEBUG_TRACE, "Read MachineName=%ws\n",
                      OldClientName?OldClientName:L"NULL")); 

    //
    // Now compare the stuff. (check if they are null?)
    //
    if( ClientName == NULL ) {
        if( OldClientName != NULL ) goto Cleanup;
    } else if( wcscmp(ClientName, OldClientName?OldClientName:L"")) {  
        DhcpPrint((DEBUG_ERRORS, "Name changed before deleting?"
                   "ignored deleting\n"));
        goto Cleanup;
    }

    //
    // Now  do the actual deletion.
    //
    Error = JetDelete(
        DhcpGlobalJetServerSession,
        DhcpGlobalClientTableHandle
        );

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "JetDelete failed!\n"));
    }

  Cleanup:
    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "Jet failed %ld\n", Error));
        Error = DhcpJetRollBack();
        DhcpAssert(ERROR_SUCCESS == Error);
    } else {
        Error = DhcpJetCommitTransaction();
        DhcpAssert(ERROR_SUCCESS == Error);
    }
    UNLOCK_DATABASE();

    if(OldClientName) DhcpFreeMemory(OldClientName);
    return;
}

VOID
DhcpFlipRegisteredBit(
    IN DHCP_IP_ADDRESS IpAddress,
    IN LPWSTR ClientName,
    IN BYTE AddressState
)
/*++

Routine Description:
    This routine flips the UNREGISTERED bit to mark the record as having
    completed registration.

    Same checks are done as for DhcpRealDeleteClient.
--*/
{
    DWORD Error, Size;
    LPWSTR OldClientName = NULL;
    BYTE PrevState;
    BOOL TransactBegin = FALSE;

    if( USE_NO_DNS ) DhcpAssert(FALSE);
    DhcpAssert(NULL != ClientName);

    DhcpPrint((DEBUG_DNS, "DhcpFlipRegisteredBit(%s, %ws, %08x\n",
               inet_ntoa(*(struct in_addr *)&IpAddress),
               ClientName?ClientName:L"NULL",
               AddressState));

    AddressState = GetAddressState(AddressState);
    LOCK_DATABASE();

    Error = DhcpJetBeginTransaction();

    if(ERROR_SUCCESS != Error) {
        UNLOCK_DATABASE();
        DhcpPrint((DEBUG_ERRORS, "Could not start transaction: %ld\n", Error));
        return;
    }

    Size = sizeof(IpAddress);
    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        (PVOID) &IpAddress,
        Size);

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "Deleting deleted key? %ws, %s\n",
                   ClientName?ClientName:L"NULL",
                   inet_ntoa(*(struct in_addr *)&IpAddress)));
        goto Cleanup;
    }

    //
    // OK. Got this record. Now get the ClientName and AddressState.
    //
    Size = sizeof(PrevState);
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &PrevState,
        &Size);

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "could not get State info for %ws, %s\n",
                   ClientName?ClientName:L"NULL",
                   inet_ntoa(*(struct in_addr *)&IpAddress)));

        goto Cleanup;
    }

    //
    // cannot flip bits for deleted clients or unregistered clients.
    //
    if( IsAddressDeleted(PrevState) || !IsAddressUnRegistered(PrevState) ||
        AddressState != GetAddressState(PrevState)) {
        DhcpPrint((DEBUG_ERRORS, "Client tried to delete unregistered"
                   " or deleted record\n"));
        goto Cleanup;
    }

    //
    // Let DhcpJetGetValue allocate space for us.
    //
    Size = 0;
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
        &OldClientName,
        &Size);

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "Could not get machine name for %ws, %s\n",
                   ClientName?ClientName:L"NULL",
                   inet_ntoa(*(struct in_addr *)&IpAddress)));
        goto Cleanup;
    }

    //
    // Now compare the stuff. (or if both are null) (ClientName cannot be
    // null)
    //
    if(ClientName == OldClientName 
       || wcscmp(ClientName, OldClientName?OldClientName:L"")) { 
        DhcpPrint((DEBUG_ERRORS, "Name changed before deleting?"
                   " ignored deleting\n")); 
        goto Cleanup;
    }

    //
    // Now do set the variable to the value needed.
    //
    Error = DhcpJetPrepareUpdate(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        &IpAddress,
        sizeof(IpAddress),
        FALSE); // This record has to exist to write to.

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "Could not jetPrepareUpdate record\n"));
        goto Cleanup;
    }

    //
    // remember to keep downlevel clients downlevel.
    //
    if(IsUpdateAPTRRequired(PrevState))
        AddressState = AddressUpdateAPTR(AddressState);

    if(IsAddressCleanupRequired(PrevState))
        AddressState = AddressCleanupRequired(AddressState);

    DhcpPrint((DEBUG_TRACE, "State is to be reset for client to: %08x\n",
               AddressState));
    Size = sizeof(AddressState);
    Error = DhcpJetSetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &AddressState,
        Size
        );

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "JetUpdate state failed!\n"));
    }

    Error = DhcpJetCommitUpdate();

    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, " Jetupdate failed\n"));
    }

  Cleanup:
    if(ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_ERRORS, "Jet failed %ld\n", Error));
        Error = DhcpJetRollBack();
        DhcpAssert(ERROR_SUCCESS == Error);
    } else {
        Error = DhcpJetCommitTransaction();
        DhcpAssert(ERROR_SUCCESS == Error);
    }
    UNLOCK_DATABASE();

    if(OldClientName)
        DhcpFreeMemory(OldClientName);
    return;
}

//
//  This structure holds the Dns context so that when the async routine calls
//  back with success or failure, we would be able to proceed and find out what
//  record should be updated.
//
typedef struct {
    LIST_ENTRY Entry;
    PVOID Ctxt;
    DHCP_IP_ADDRESS IpAddress;
    LPWSTR ClientName;
    BYTE AddressState;
    enum DhcpDnsOp {
        DhcpDnsDeleteRecord,
        DhcpDnsAddRecord
    } DnsOp;
} DHCP_DNS_CONTEXT, *PDHCP_DNS_CONTEXT;

VOID
DhcpDnsCallBack(
    IN DWORD Status,
    IN LPVOID Ctxt
)
/*++

Routine Description:
    This routine is called back by DNS whenever it is done with the
    registrations.  If DNS was updated successfully, the database is
    updated accordingly.

    Currently Status can take multiple values of which only
    DNSDHCP_FWD_FAILED and DNSDHCP_SUCCESS are assumed to be success
    codes..

--*/
{
    DWORD Error;
    PDHCP_DNS_CONTEXT pDnsCtxt = *(PDHCP_DNS_CONTEXT *)Ctxt;

    if( DhcpGlobalServiceStopping ) return ;
    if( USE_NO_DNS ) { DhcpAssert(FALSE); return ; }

    DhcpAssert(pDnsCtxt);
    DhcpPrint((DEBUG_DNS, "DhcpDnsCallBack %ld entered\n", Status));

    //
    // if a forward failed, we dont care much.
    //
    if(DNSDHCP_FWD_FAILED == Status) Status = DNSDHCP_SUCCESS;

    //
    // if anything else happened, dont change data base.
    // but still have to free the data.
    //
    if(DNSDHCP_SUCCESS != Status) {
        DhcpDnsFreeMemory(Ctxt);
        DhcpPrint((DEBUG_DNS, "DhcpDnsCallBAck failed\n"));
        return;
    }

    if(!pDnsCtxt) {
        DhcpPrint((DEBUG_ERRORS, "DhcpDnsCallBack called with"
                   " null ptr\n")); 
        DhcpAssert(FALSE);
        return;
    }

    if( DhcpGlobalImpersonated ) {
        DhcpPrint((DEBUG_TRACE, "Impersonated, so scheduling to  another thread"));

        pDnsCtxt->Ctxt = Ctxt;
        LOCK_MEM();
        InsertTailList(&DhcpGlobalDnsCallbackList, &pDnsCtxt->Entry);
        UNLOCK_MEM();

        SetEvent( DhcpGlobalRecomputeTimerEvent );
        DhcpPrint((DEBUG_TRACE, "DhcpDnsCallBAck done\n"));
        return;
    } 

    //
    // Now find if we have to flip or delete..
    //
    if(DhcpDnsDeleteRecord == pDnsCtxt->DnsOp) {
        DhcpPrint((DEBUG_TRACE, "DhcpDnsCallBack Delete was called\n")); 
        DhcpRealDeleteClient(
            pDnsCtxt->IpAddress, 
            pDnsCtxt->ClientName, 
            pDnsCtxt->AddressState
            );
    } else {
        DhcpAssert(DhcpDnsAddRecord == pDnsCtxt->DnsOp);
        DhcpPrint((DEBUG_TRACE, "DhcpDnsCallBack Add  was called\n"));
        DhcpFlipRegisteredBit(
            pDnsCtxt->IpAddress,
            pDnsCtxt->ClientName, 
            pDnsCtxt->AddressState
            );
    }

    //
    // Now free this memory.
    //
    DhcpDnsFreeMemory(Ctxt);
    DhcpPrint((DEBUG_TRACE, "DhcpDnsCallBAck done\n"));
}

VOID
DhcpDnsHandleCallbacks(
    VOID
    )
{
    PLIST_ENTRY ThisEntry;
    PDHCP_DNS_CONTEXT pDnsCtxt;
    BOOL fListEmpty = IsListEmpty(&DhcpGlobalDnsCallbackList);
    
    if(!fListEmpty) DhcpPrint((DEBUG_TRACE, "+DhcpDnsHandleCallbacks"));
    LOCK_MEM();
    while(!IsListEmpty(&DhcpGlobalDnsCallbackList) ) {
        ThisEntry = RemoveHeadList(&DhcpGlobalDnsCallbackList);
        UNLOCK_MEM();
        
        pDnsCtxt = CONTAINING_RECORD(ThisEntry, DHCP_DNS_CONTEXT, Entry);

        if( DhcpDnsDeleteRecord == pDnsCtxt->DnsOp ) {
            DhcpPrint((DEBUG_TRACE, "DhcpDnsCallBAck Delete\n"));
            DhcpRealDeleteClient(
                pDnsCtxt->IpAddress, pDnsCtxt->ClientName,
                pDnsCtxt->AddressState );
        } else {
            DhcpAssert(DhcpDnsAddRecord == pDnsCtxt->DnsOp);
            DhcpPrint((DEBUG_TRACE, "DhcpDnsCallBack Add\n"));
            DhcpFlipRegisteredBit(
                pDnsCtxt->IpAddress,
                pDnsCtxt->ClientName, 
                pDnsCtxt->AddressState
                );
        }            
        DhcpDnsFreeMemory(pDnsCtxt->Ctxt);

        LOCK_MEM();
    }
    UNLOCK_MEM();
    if(!fListEmpty) DhcpPrint((DEBUG_TRACE, "-DhcpDnsHandleCallbacks"));
}
    
PIP_ADDRESS
GetDnsServerList(
    IN DHCP_IP_ADDRESS IpAddress,
    OUT PULONG DnsServerCount
)
/*++

Routine Description:
    This routine retrieves the DNS information for the given Ip address.
    Currently it does not take the USER Class information for the Ip
    address and hence would end up picking up the "default" DNS servers.. 
    
    The classid thing needs to be fixed.. ?

--*/
{
    DWORD Error;
    PIP_ADDRESS DnsServers;
    ULONG Size, Unused;

    DnsServers = NULL;
    Size = 0;
    Error = DhcpGetParameterForAddress(
        IpAddress,
        0 /* no class id ..???? */,
        OPTION_DOMAIN_NAME_SERVERS,
        (LPBYTE *)&DnsServers,
        &Size,
        &Unused
        );
    if( ERROR_SUCCESS != Error ) {
        *DnsServerCount = 0;
        return NULL;
    }

    *DnsServerCount = Size / sizeof(PIP_ADDRESS);
    if( *DnsServerCount ) return DnsServers;
    *DnsServerCount = 0;
    if( DnsServers ) DhcpFreeMemory( DnsServers );
    return NULL;
}

VOID
DhcpDnsAsyncDelete(
    IN DHCP_IP_ADDRESS IpAddress,
    IN LPWSTR ClientName,
    IN BYTE AddressState
) 
/*++

Routine Description:
    This routine schedules a DNS delete for the IP address given by
    IpAddress and based on values for AddressState, it schedules the
    deregistration for A / PTR .

    (N.B The DNSAPI routine takes a callback which provides the status of
    the operation..)
--*/
{
    PDHCP_DNS_CONTEXT *pCtxt = NULL;
    REGISTER_HOST_ENTRY HostEntry;
    DWORD Size = 0, dwFlags;
    DNS_STATUS Status;
    PIP_ADDRESS DnsServers;
    ULONG DnsServerCount;

    if(!ClientName) ClientName = L"";

    DhcpPrint((DEBUG_DNS, "DhcpDnsAsyncDelete: %s [%ws] %08x\n",
               inet_ntoa(*(struct in_addr *) &IpAddress),
               ClientName?ClientName:L"NULL",
               AddressState));
    
    DhcpAssert(ClientName);

    Size += ROUND_UP_COUNT(sizeof(DHCP_DNS_CONTEXT), ALIGN_WORST);
    Size += ROUND_UP_COUNT(sizeof(WCHAR)*(1+wcslen(ClientName)), ALIGN_WORST);

    if(NULL == (pCtxt = (PDHCP_DNS_CONTEXT *)DhcpDnsAllocateMemory(Size))) {
        DhcpPrint((DEBUG_ERRORS, "Could not get enough memory\n"));
        return;
    }

    //
    // Now fill in the allocated structure with details.
    //
    InitializeListHead(&(*pCtxt)->Entry);
    (*pCtxt)->Ctxt = NULL;
    (*pCtxt)->IpAddress = IpAddress;
    (*pCtxt)->AddressState = AddressState;
    (*pCtxt)->ClientName = ROUND_UP_POINTER(
        ((LPBYTE)(*pCtxt)) + sizeof(**pCtxt), ALIGN_WORST
        );
    wcscpy((*pCtxt)->ClientName, ClientName);
    ClientName = ((*pCtxt))->ClientName;
    DhcpPrint((DEBUG_TRACE, "FQDN================%ws\n", ClientName));

    ((*pCtxt))->DnsOp = DhcpDnsDeleteRecord;

    //
    // Now should call the async routine to do our stuff.
    //
    HostEntry.Addr.ipAddr = htonl(IpAddress);

    //
    // Now call the deleting routine.
    //
    dwFlags = DYNDNS_DELETE_ENTRY;
    HostEntry.dwOptions = REGISTER_HOST_PTR;
    if ( IS_DOWN_LEVEL( AddressState )) {
	HostEntry.dwOptions |= REGISTER_HOST_A;
	dwFlags |= DYNDNS_REG_FORWARD;
    }

    DnsServers = GetDnsServerList( IpAddress, &DnsServerCount);

    Status = DnsDhcpSrvRegisterHostName_W(
        HostEntry, ClientName, DHCP_DNS_DEFAULT_TTL, dwFlags,
        DhcpDnsCallBack, pCtxt, DnsServers, DnsServerCount);

    if( DnsServers ) DhcpFreeMemory( DnsServers );

    DhcpPrint((DEBUG_DNS, "FQDN <%ws> {%s,%s%s} dwFlags=[%s%s] Status = %ld\n",
               ClientName,
               inet_ntoa(*(struct in_addr *)&HostEntry.Addr.ipAddr),
               (HostEntry.dwOptions & REGISTER_HOST_A) ? "A" : " ",
               (HostEntry.dwOptions & REGISTER_HOST_PTR) ? "PTR" : "   ",
               (dwFlags & DYNDNS_REG_FORWARD ) ? "FWD+" : "    ",
               (dwFlags & DYNDNS_ADD_ENTRY ) ? "ADD" : "DEL",
               Status
    ));
    if(ERROR_SUCCESS != Status) {
        DhcpPrint((DEBUG_ERRORS, "Dns delete failure %ld\n", Status));
        DhcpDnsFreeMemory(pCtxt);
    }
}

VOID
DhcpDnsAsyncAdd(
    IN DHCP_IP_ADDRESS IpAddress,
    IN LPWSTR ClientName,
    IN BYTE AddressState
) 
/*++

Routine Description:
    The counterpart for the deletion function is the Add function that tries to
    add a name to Dns. And when the call back executes, if all the names,etc
    match, it flips the required bit.


--*/
{
    PDHCP_DNS_CONTEXT (*pCtxt) = NULL;
    REGISTER_HOST_ENTRY HostEntry;
    DWORD Size = 0, dwFlags;
    DNS_STATUS Status;
    PIP_ADDRESS DnsServers;
    ULONG DnsServerCount;

    if( USE_NO_DNS ) return;

    if(!ClientName) ClientName = L"";
    DhcpPrint((DEBUG_DNS, "DhcpDnsAsyncAdd: %s %ws %08x\n",
               inet_ntoa(*(struct in_addr *) &IpAddress),
               ClientName?ClientName:L"NULL",
               AddressState));

    if(!wcslen(ClientName)) {
        //
        // cannot have empty client names for registration!
        //
        DhcpPrint((DEBUG_ERRORS, "Cant register null names!\n"));
        // DhcpAssert(FALSE);
        return;
    }
    DhcpAssert(ClientName);

    Size += ROUND_UP_COUNT(sizeof(DHCP_DNS_CONTEXT), ALIGN_WORST);
    Size += ROUND_UP_COUNT(
        sizeof(WCHAR)*(1+wcslen(ClientName)), ALIGN_WORST
        );

    if(NULL == (pCtxt = (PDHCP_DNS_CONTEXT *)DhcpDnsAllocateMemory(Size))) {
        DhcpPrint((DEBUG_ERRORS, "Could not get enough memory\n"));
        return;
    }

    //
    // Now fill in the allocated structure with details.
    //
    InitializeListHead(&((*pCtxt)->Entry));
    (*pCtxt)->IpAddress = IpAddress;
    (*pCtxt)->AddressState = AddressState;
    (*pCtxt)->ClientName = ROUND_UP_POINTER(
        ((LPBYTE)((*pCtxt))) + sizeof(*(*pCtxt)), ALIGN_WORST
        );
    wcscpy((*pCtxt)->ClientName, ClientName);
    ClientName = ((*pCtxt))->ClientName;

    ((*pCtxt))->DnsOp = DhcpDnsAddRecord;

    HostEntry . Addr . ipAddr = htonl(IpAddress);
    HostEntry . dwOptions = REGISTER_HOST_PTR;
    if(IS_DOWN_LEVEL(AddressState))
        HostEntry . dwOptions |= REGISTER_HOST_A;

    //
    // Now call the registration routine.
    //
    dwFlags = DYNDNS_ADD_ENTRY;
    if(IS_DOWN_LEVEL(AddressState)) dwFlags |= DYNDNS_REG_FORWARD;

    DnsServers = GetDnsServerList( IpAddress, &DnsServerCount );
    
    Status = DnsDhcpSrvRegisterHostName_W(
        HostEntry, ClientName, DHCP_DNS_DEFAULT_TTL, dwFlags,
        DhcpDnsCallBack, pCtxt, DnsServers, DnsServerCount);

    if( DnsServers ) DhcpFreeMemory( DnsServers );

    DhcpPrint((DEBUG_DNS, "FQDN <%ws> {%s,%s%s} dwFlags=[%s%s] Status = %ld\n",
               ClientName,
               inet_ntoa(*(struct in_addr *)&HostEntry.Addr.ipAddr),
               (HostEntry.dwOptions & REGISTER_HOST_A) ? "A" : " ",
               (HostEntry.dwOptions & REGISTER_HOST_PTR) ? "PTR" : "   ",
               (dwFlags & DYNDNS_REG_FORWARD ) ? "FWD+" : "    ",
               (dwFlags & DYNDNS_ADD_ENTRY ) ? "ADD" : "DEL",
               Status
    ));

    if(ERROR_SUCCESS != Status) {
        DhcpPrint((DEBUG_ERRORS, "Dns add failure %ld\n", Status));
        DhcpDnsFreeMemory(pCtxt);
    }
}

//
//  The memory functions are here.  Memory is handled through two lists.. the
//  Free and available list.  This way memory can be re-used without having to
//  worry about anything.  Also, if less than X memory is used, half the
//  unused memory is released....  that way, too much memory is not taken up.
//  Also memory is not indefinitely allocated:
//  The way this works is: each time the start allocation routine is called, it
//  would check for the last time a successful free was done; if a free was not
//  done for a very long time (check below for times: 15 min DBG, 1.5hr o/w),
//  then it refuses to allocate memory.
//  Also, memory is picked off the free list, as long as it is available. If it
//  is not available, then a bunch of addresses are allocated and added to the
//  free list, so that future allocations are fast.
//

//
//  Here is the memory block data-structure.  It is a simple linked list of
//  nodes with each node containing an actual pointer to size.
//
typedef struct {
    LIST_ENTRY   Ptr;          // Flink,Blink pointers
    DWORD        mSize;        // Size of allocated memory below.
    LPVOID       Memory;       // The actual memory allocated.
#if DBG
    BYTE         TestByte;     // this is always set to TEST_BYTE_VAL...
#endif
} MEM_NODE, *MEM_LIST;

LIST_ENTRY  FreeList, UsedList;
DWORD     FreeListSize = 0, UsedListSize = 0;
time_t    LastFreedTime = 0;
DWORD     nPendingAllocations = 0;

#if DBG
#define ALLOWED_ALLOCATION_TIME           (15*60) // seconds; 15 minutes
#define MAX_ALLOWED_ALLOCATIONS           1000    // atmost 1000 pending dns requests
#else
#define ALLOWED_ALLOCATION_TIME           (90*60) // seconds; 1.5 hrs
#define MAX_ALLOWED_ALLOCATIONS           5000    // be a little more flexible in real life
#endif

#define MIN_ALLOCATION_UNIT               15      // allocate in units of 15
#define MEM_NODE_SIZE              ROUND_UP_COUNT(sizeof(MEM_NODE),ALIGN_WORST)

//
// This gives just 60 bytes for a client name... but most often this is
// accurate enough.
//

#define MINIMUM_UNIT_SIZE          (sizeof(DHCP_DNS_CONTEXT) + 60*sizeof(WCHAR))

#define TEST_BYTE_VAL              0x55

//
// Two helper functions.. DhcpAddMemorytoFreeList would add a pointer to the
// Freelist and increment the free list counter..  DhcpAddMemoryToUsedList is just
// the same thing done to the Used list.
//
VOID
DhcpAddMemoryToUsedList(
    IN OUT MEM_LIST Ptr
    ) 
{
    //
    // Zero in the stuff as far as
    //
    memset((LPBYTE)Ptr + MEM_NODE_SIZE, 0x00, MINIMUM_UNIT_SIZE);

    //
    // Now add it to the right list.
    //
    InsertHeadList(&UsedList, &Ptr->Ptr);
    UsedListSize ++;

    //
    // Now check the pointers, and if debug, the TestByte also.
    //
    DhcpAssert( !DBG || Ptr->TestByte == TEST_BYTE_VAL);
    DhcpAssert(Ptr->mSize);
    DhcpAssert(Ptr->Memory == (LPBYTE)Ptr + MEM_NODE_SIZE);
}

VOID
DhcpAddMemoryToFreeList(
    IN OUT MEM_LIST Ptr
    ) 
{
    //
    // Zero in the stuff as far as
    //
    memset((LPBYTE)Ptr, 0x00, MEM_NODE_SIZE + MINIMUM_UNIT_SIZE);

    //
    // Now add it to the right list.
    //
    InsertHeadList(&FreeList, &Ptr->Ptr);
    FreeListSize ++;

    //
    // Now fill in the pointers, and if debug, the TestByte also.
    //
#if DBG
    Ptr->TestByte = TEST_BYTE_VAL;
#endif
    Ptr->Memory = (LPBYTE)Ptr + MEM_NODE_SIZE;
}

//
// Now comes the un-pooled function.  This function allocates memory, but does
// not try to allocate a set, instead.. allocates just exactly one node.
//
LPVOID
DhcpAllocateLotsOfDnsMemory(
    IN DWORD Size
    )
{
    MEM_LIST mList;

    if(NULL == (mList = DhcpAllocateMemory(MEM_NODE_SIZE + Size)))
        return NULL;

    memset(mList, 0x00, MEM_NODE_SIZE);
#if DBG
    mList->TestByte = TEST_BYTE_VAL;
#endif
    mList ->Memory = (LPBYTE)mList + MEM_NODE_SIZE;
    mList->mSize = Size;

    DhcpAddMemoryToUsedList(mList);

    return &(mList->Memory);
}

//
// This function returns the address of the LPVOID variable which holds the
// first address of the memory allocated...
//
LPVOID
DhcpDnsAllocateMemory(
    IN DWORD Size
    ) 
{
    time_t timeNow = time(NULL);
    LPVOID RetVal = NULL;
    PLIST_ENTRY listEntry;

    LOCK_MEM();
    if( 0 == Size ) {
        DhcpAssert(FALSE);
        goto EndF;
    }

    //
    // First check if we are really allowed to proceed.
    //
    if( nPendingAllocations < MAX_ALLOWED_ALLOCATIONS ) {
        nPendingAllocations ++;
    } else goto EndF;

    if( 2 * MINIMUM_UNIT_SIZE < Size ) {
        RetVal = DhcpAllocateLotsOfDnsMemory(Size);
        goto EndF;
    }

    if( MINIMUM_UNIT_SIZE > Size ) Size = MINIMUM_UNIT_SIZE;


    //
    // Now check if we have memory already, if not really allocate memory.
    //
    if( 0 == FreeListSize ) {
        DWORD i, SizeToAllocate;

        SizeToAllocate = MEM_NODE_SIZE + Size;
        for( i = 0; i < MIN_ALLOCATION_UNIT; i ++ ) {
            LPVOID Ptr = NULL;

            if( NULL == (Ptr = DhcpAllocateMemory(SizeToAllocate) ))
                goto EndF;
            DhcpAddMemoryToFreeList(Ptr);
            ((MEM_LIST)Ptr)->mSize = Size;
        }
    }

    DhcpAssert( 0 != FreeListSize );

    //
    // Now we can pick off the free list one item which is of the right
    // size. 
    //
    listEntry = FreeList.Flink;
    while( &FreeList != listEntry ) {
        MEM_LIST MemList = CONTAINING_RECORD(listEntry, MEM_NODE, Ptr);
        DWORD    mSize;

        DhcpAssert(MemList);
        mSize = MemList->mSize;

        if( Size <= mSize ) { // memory is sufficient.
            RetVal = &MemList->Memory;
            RemoveEntryList(&(MemList->Ptr));
            FreeListSize --;
            DhcpAddMemoryToUsedList(MemList);
            goto EndF;
        }

        listEntry = listEntry -> Flink;
    }

    //
    // Did not find anything anywhere... so do a special allocate.
    //
    RetVal = DhcpAllocateLotsOfDnsMemory(Size);

  EndF:
    UNLOCK_MEM();
    return RetVal;
}

//
// The allocated pointer is whatever is returned by the DnsAllocateMemory function.
// So, this is the address of the field Memory in the MEM_NODE structure. With this
// info, get the structure, and free the structure and other stuff.. If this address
// is invalid, then assert.
//
VOID
DhcpDnsFreeMemory(
    LPVOID AllocatedPtr
    ) 
{
    time_t timeNow = time(NULL);
    MEM_LIST MemList;
    DWORD Size;

    if( 0 == UsedListSize ) {
        DhcpAssert(FALSE);
        return;
    }

    LOCK_MEM();
    DhcpAssert(nPendingAllocations);
    nPendingAllocations --;

    //
    // Try to find out this address in the UsedList..
    //
    MemList = CONTAINING_RECORD(AllocatedPtr, MEM_NODE, Memory);


#if DBG
    DhcpAssert( TEST_BYTE_VAL == MemList->TestByte );
#endif

    RemoveEntryList(&(MemList->Ptr));
    UsedListSize --;
    if( 0 == UsedListSize ) {
        //
        // if no pending entry, mark LastFreedTime to zero so we dont stop
        // sending dns requests.
        //
        LastFreedTime = 0;
    }

    //
    // Now add this to the free list, unless the free list is already
    // bloated.
    //
    if( MIN_ALLOCATION_UNIT < FreeListSize && UsedListSize < FreeListSize ) {
        DhcpFreeMemory(MemList);
        goto EndF;
    }

    Size = MemList->mSize;

    if( 2 * MINIMUM_UNIT_SIZE < Size ) {
        //
        // this was allocated via DhcpAllocateLotsOfDnsMemory -- just free these..
        //
        DhcpFreeMemory(MemList);
        goto EndF;
    }

    DhcpAddMemoryToFreeList(MemList);
    MemList->mSize = Size;

  EndF:
    UNLOCK_MEM();
    return;
}

//
//  Initialize the critical section so that LOCK_MEM and UNLOCK_MEM work.
//
static ULONG Initialized = 0;

VOID
DhcpInitDnsMemory( 
    VOID 
    ) 
{
    DWORD Error;

    if( 0 != Initialized ) return;
    Initialized ++;

    try {
        InitializeCriticalSection( &DhcpGlobalDnsMemoryCriticalSection );
        InitializeListHead(&UsedList);
        InitializeListHead(&FreeList);
        InitializeListHead(&DhcpGlobalDnsCallbackList); 
    } except( EXCEPTION_EXECUTE_HANDLER ) {

        Error = GetLastError( );
    }
}

//
//  Cleanup the list of unused and free memory nodes..
//
VOID
DhcpCleanupDnsMemory( 
    VOID 
    ) 
{
    PLIST_ENTRY listEntry;

    if( USE_NO_DNS ) return;
    if( 0 == Initialized ) return;
    Initialized -- ;
    if( 0 != Initialized ) return;
    LOCK_MEM();

    DhcpDnsHandleCallbacks();
    DhcpPrint((DEBUG_TRACE, "Used: %ld, Free: %ld DNS Memory nodes\n",
               UsedListSize, FreeListSize));

    if( 0 == FreeListSize ) DhcpAssert(IsListEmpty(&FreeList));
    if( 0 == UsedListSize ) DhcpAssert(IsListEmpty(&UsedList));

    listEntry = UsedList.Flink;
    while(listEntry != &UsedList) {
        MEM_LIST mNode = CONTAINING_RECORD(listEntry, MEM_NODE, Ptr);

        listEntry = listEntry->Flink;
        RemoveEntryList(&(mNode->Ptr));
        DhcpFreeMemory(mNode);
    }

    listEntry = FreeList.Flink;
    while(listEntry != &FreeList) {
        MEM_LIST mNode = CONTAINING_RECORD(listEntry, MEM_NODE, Ptr);

        listEntry = listEntry->Flink;
        RemoveEntryList(&(mNode->Ptr));
        DhcpFreeMemory(mNode);
    }

    UNLOCK_MEM();
    FreeListSize = 0;
    UsedListSize = 0;
    nPendingAllocations = 0;

    DeleteCriticalSection(&DhcpGlobalDnsMemoryCriticalSection);
}

//
//  End of file.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\iptbl.c ===
/*++

Copyright (C) 1998 Microsoft Corporation.

Module Name:
    iptbl.c

Abstract:
    this module implements retreiving the IPAddress/Interface table
    from tcpip driver and maintains the winsock notification needed
    to update the table as well.

Environment:
    User mode Win32.

--*/

#if 0

How it all works:

This module initialization takes care of posting a winsock address
change notification so that any address change is notified.  On each
address change, the IP address table is completely retrieved and for
any new items the specified constructor is called and for any items
that have to be deleted too, the specified destructor is called before
the item is deleted.

Nothing is done if the subnet-mask is changed and nothing is done if
zero IP addresses are added or deleted.

Internally, this module keeps an array of
IP-Address,InterfaceName,SubnetMask
entries with the first two being the "key".

N.B.  It is up to the caller to create sockets etc. And note that if
an address goes and comes right back, no notifications will be given.
That is up to the user to handle too.

#endif 0

#include <dhcppch.h>
#include <guiddef.h>
#include <iphlpapi.h>
#include "convguid.h"
#include "iptbl.h"

#define TCPPREFIX_LEN sizeof("\\DEVICE\\TCPIP")

//
// The global endpoint table looks like this
//

typedef struct _ENDPOINT_TBL {
    //
    // How many times has this been initialized;
    //
    LONG InitCount;

    //
    // The critical section (allocated elsewhere) that
    // protects this global data.
    //
    PCRITICAL_SECTION CS;

    //
    // The Hook to be called into.
    //
    ENDPOINT_CALLBACK_RTN Callback;
    
    //
    // Socket to post notifications on.
    //
    SOCKET NotifySock;
    WSAOVERLAPPED Overlap;
    
    //
    // The following table is allocated by increasing
    // each time by about 10%.
    //
    HANDLE hHeap;
    ULONG nEndPointsAllocated;
    ULONG nEndPoints;
    PVOID EndPoints;
    ULONG EndPointEntrySize;
} ENDPOINT_TBL, *PENDPOINT_TBL;

//
// global variables and defines.
//

#define TEMP_SLEEP_TIME (4*1000)

ENDPOINT_TBL DhcpGlobalEndPointTable;

//
// Endpoint accessing routines.
//
#define GET_ENDPOINT(Tbl, i) GetEndPointEntry((Tbl),(i))

PENDPOINT_ENTRY
GetEndPointEntry(
    IN PENDPOINT_TBL Tbl,
    IN ULONG Index
    )
/*++

Routine Description:
    Access the "Index"th element of the Tbl.
    N.B. It is assumed that Index is valid.
    N.B. It is assumed that locks have been taken on Tbl.
Return value:
    table endpoitn entry.

--*/
{
    PBYTE EpStart = Tbl->EndPoints;
    return (PENDPOINT_ENTRY)(EpStart + Index * Tbl->EndPointEntrySize);
}

#define DELETE_ENDPOINT(Tbl,i)  DeleteEndPointEntry((Tbl),(i))

VOID
DeleteEndPointEntry(
    IN OUT PENDPOINT_TBL Tbl,
    IN ULONG Index
    )
/*++

Routine Description:
    This routine deletes the entry identified by the Index and moves
    the other elements up so that the gap is filled.

    N.B. It is assumed that Index is valid.
    N.B. It is assumed that locks have been taken on Tbl.
    N.B. No memory is freed.

--*/
{
    PENDPOINT_ENTRY Ep = GET_ENDPOINT(Tbl,Index);
    PENDPOINT_ENTRY Ep2 = GET_ENDPOINT(Tbl,(Index+1));

    //
    // first notify higher layer.
    //
    
    Tbl->Callback(
        REASON_ENDPOINT_DELETED,
        Ep
        );
    
    Tbl->nEndPoints --;
    
    //
    // Deleting the last element in the table is cool.
    //
    if( Index != Tbl->nEndPoints  ) {
        RtlCopyMemory(
            Ep, Ep2, (Tbl->nEndPoints - Index)*Tbl->EndPointEntrySize
            );
    }
}

#define ADD_ENDPOINT  AddEndPointEntry

ULONG
AddEndPointEntry(
    IN OUT PENDPOINT_TBL Tbl,
    IN GUID *IfGuid,
    IN ULONG IpAddress,
    IN ULONG IpIndex,
    IN ULONG IpContext,
    IN ULONG SubnetMask
    )
{
    PENDPOINT_ENTRY Entry;
    
    if( Tbl->nEndPoints == Tbl->nEndPointsAllocated ) {
        //
        // Not enough space. Need to allocate more space.
        //
        PVOID NewMem ;
        ULONG NewSize, NewSizeAllocated;

        NewSize = (Tbl->nEndPointsAllocated + 100);
        NewSize += (NewSize >> 3);
        NewSizeAllocated = NewSize*Tbl->EndPointEntrySize;

        if( NULL == Tbl->EndPoints ) {
            //
            // Never allocated before. Try now.
            //
            NewMem = HeapAlloc(Tbl->hHeap, 0, NewSizeAllocated );
            if( NULL == NewMem ) {
                NewSize = 10;
                NewSizeAllocated = NewSize * Tbl->EndPointEntrySize;
                
                NewMem = HeapAlloc(Tbl->hHeap, 0, NewSizeAllocated );
            }
        } else {
            //
            // Memory already exists? Then just reallocate it.
            //
            NewMem = HeapReAlloc(
                Tbl->hHeap, 0, Tbl->EndPoints, NewSizeAllocated
                );
        }

        if( NULL == NewMem ) {
            //
            // Couldn't allocate memory? Thats too bad. We will give
            // up now
            //
            return GetLastError();
        }

        //
        // We have allocated new memory. update pointers.
        //
        Tbl->nEndPointsAllocated = NewSize;
        Tbl->EndPoints = NewMem;        
    }

    //
    // Now just add this at the end of the table.
    //
    Entry = GET_ENDPOINT(Tbl, Tbl->nEndPoints );
    Tbl->nEndPoints ++;

    RtlZeroMemory(Entry, Tbl->EndPointEntrySize );
    Entry->IfGuid = *IfGuid;
    Entry->IpAddress = IpAddress;
    Entry->IpIndex = IpIndex;
    Entry->IpContext = IpContext;
    Entry->SubnetMask = SubnetMask;

    //
    // Now notify caller.
    //
    Tbl->Callback(
        REASON_ENDPOINT_CREATED,
        Entry
        );

    return ERROR_SUCCESS;
}

VOID
WalkthroughEndpoints(
    IN PVOID Context,
    IN BOOL (_stdcall *WalkthroughRoutine)(
        IN OUT PENDPOINT_ENTRY Entry,
        IN PVOID Context
        )
    )
/*++

Routine Description:
    This routine walks through the table of endpoints and calls the
    WalkthroughRoutine provided, for each of the endpoint entries.

    If the WalkthroughRoutine returns FALSE, then the enumeration is
    aborted and the routine returns.

    N.B The global endpoint lock is taken while enumerating.  So, this
    operation should happen fast or else several things may get
    blocked.

Arguments:
    Context -- the context to pass to the enumeration routine.
    WalkthroughRoutine -- enumeration rtn to be called on each
        endpoint.

--*/
{
    ULONG i;
    PENDPOINT_TBL Tbl = &DhcpGlobalEndPointTable;
    
    if( 0 == Tbl->InitCount ) return ;
    
    EnterCriticalSection(Tbl->CS);
    do {
        if( 0 == Tbl->InitCount ) break;
        
        for( i = 0; i < Tbl->nEndPoints ; i ++ ) {
            BOOL fStatus;

            fStatus = WalkthroughRoutine(
                GET_ENDPOINT(Tbl,i),
                Context
                );
            if( FALSE == fStatus ) break;
        }
    } while ( 0 );
    LeaveCriticalSection(Tbl->CS);
}
                 

//
// Address change notification handler is defined at a later
// point.
//
void CALLBACK AddrChangeHandler(
    IN DWORD dwError,
    IN DWORD cbTransferred,
    IN LPWSAOVERLAPPED Overlap,
    IN DWORD dwFlags
    );


ULONG
PostAddrChangeNotification(
    IN SOCKET Sock,
    IN OUT LPWSAOVERLAPPED Overlap,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE AddrChangeHandler,
    OUT BOOL *fImmediatelyCompleted
    )
/*++

Routine Description:
    This routine posts an address change notification with winsock.
    N.B.  It is possible that the address has already changed -- in
    this case the routine returns NO_ERROR and
    (*fImmediatelyCompleted) is set to TRUE to indicate this happend.

Arguments:
    Sock -- socket to use for posting the event.
    Overlap -- the overlapped structure to use.
    AddrChangeHandler -- the handler that shoudl be called on changes.
    fImmediatelyCompleted -- this is set to TRUE if the event happens
        immediately. In this case the handler wont automatically get
        called.


Return Values:
    NO_ERROR -- either the change already happened
       (fImmediatelyCompleted would be set to TRUE then) or the change
       notification handler was successfully registered.
    Winsock errors
    
--*/    
{
    ULONG Status, unused;

    *fImmediatelyCompleted = FALSE;
    RtlZeroMemory(Overlap, sizeof(*Overlap));
    Status = WSAIoctl(
        Sock,
        SIO_ADDRESS_LIST_CHANGE,
        NULL, 0, NULL, 0, &unused,
        Overlap, AddrChangeHandler
        );
    if( NO_ERROR == Status ) {
        //
        // Completed right away.  tell that to caller.
        //
        *fImmediatelyCompleted = TRUE;
        return NO_ERROR;
    }
    
    //
    // it _must_ be SOCKET_ERROR.
    //

    if( SOCKET_ERROR == Status ) Status = WSAGetLastError();
    if( WSA_IO_PENDING == Status ) {
        //
        // The notification was successfully posted.
        //
        Status = NO_ERROR;
    }
    return Status;
}

ULONG
CreateAddrListChangeSocket(
    OUT SOCKET *Sock,
    OUT LPWSAOVERLAPPED Overlap,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE AddrChangeHandler
    )
/*++

Routine Description:
    This routine creates a socket to receive address change
    notifications on, and also register the provided handler for the
    same.

    N.B. If there are some addresses already present, then the
    notification wont happen, but it will be faked and the
    notifyhandler routine would be artificially called from within
    this routine.

Arguments:
    Sock -- variable that will contain the socket on successful
        return from this routine.
    Overlap -- the overlap structure to use for performing this
        operation.
    AddrChangeHandler -- handler that has to be called whenever any
        address change happens.

Return Values:
    NO_ERROR -- everything went fine.
    Winsock errors
    
--*/
{
    ULONG Status;
    BOOL fChanged;
    
    (*Sock) = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );
    if( INVALID_SOCKET == (*Sock) ) {
        //
        // Couldn't as much as create a socket?
        //
        return WSAGetLastError();
    }

    Status = PostAddrChangeNotification(
        *Sock, Overlap, AddrChangeHandler, &fChanged
        );
    //
    // Apparently the above routine gives notifications only if things
    // change -- so for first time around we just fake a notification.
    //
    fChanged = TRUE; 
    if( NO_ERROR == Status ) {
        if( fChanged ) {
            //
            // Ugh.  Somethings have happened already.  Fake a AddrChangeHandler
            //
            AddrChangeHandler(
                0,
                0,
                Overlap,
                0
                );
        }
    } else {
        closesocket(*Sock);
        *Sock = INVALID_SOCKET;
    }
    
    return Status;
}

ULONG
DestroyAddrListChangeSocket(
    IN OUT SOCKET *Sock
    )
/*++

Routine Description:
    This routine destroys the socket on which a notification had been
    posted. This automatically cancels any pending notifications (but
    not one that is in progress).

Arguments:
    Sock -- socket to destroy.


Return Values:
    Winsock errors;

--*/
{
    SOCKET CapturedSockValue = (*Sock);
    (*Sock) = INVALID_SOCKET;

    if( SOCKET_ERROR == closesocket(CapturedSockValue)) {
        return WSAGetLastError();
    }

    return NO_ERROR;
}

//
// This the routine that is called to initialize this module.
//
ULONG
IpTblInitialize(
    IN OUT PCRITICAL_SECTION CS,
    IN ULONG EndPointEntrySize,
    IN ENDPOINT_CALLBACK_RTN Callback,
    IN HANDLE hHeap
    )
/*++

Routine Description:
    This routine attempts to initialize the IP address table.
    N.B. It can be called multiple times if the same set of parameters
    are used. (Else, it returns an error).

Arguments:
    CS -- the critical section used by all entries in this routine.
    EndPointEntrySize -- this is the size of the total endpoint
        inclusive of user allocated data region as well as the core 
        ENDPOINT_ENTRY structure.
    Callback -- the routine to call to add or delete endpoints
    hHeap -- heap to allocate off of.
    
Return Value:
    NO_ERROR if everything went fine.
    ERROR_CAN_NOT_COMPLETE if unable to complete operation.
    winsock errors 
    
--*/
{
    ULONG Status = NO_ERROR;
    
    EnterCriticalSection(CS);
    do {
        if( DhcpGlobalEndPointTable.InitCount ) {
            if( DhcpGlobalEndPointTable.CS != CS ) {
                //
                // Oops. Serious trouble.
                //
                Status = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }
        DhcpGlobalEndPointTable.InitCount ++;
        DhcpGlobalEndPointTable.CS = CS;
        DhcpGlobalEndPointTable.Callback = Callback;
        DhcpGlobalEndPointTable.EndPointEntrySize = EndPointEntrySize;
        DhcpGlobalEndPointTable.hHeap = hHeap;
        
        Status = CreateAddrListChangeSocket(
            &DhcpGlobalEndPointTable.NotifySock,
            &DhcpGlobalEndPointTable.Overlap,
            AddrChangeHandler
            );
        if( NO_ERROR != Status ) {
            DhcpGlobalEndPointTable.InitCount --;
            break;
        }
    } while ( 0 );
    LeaveCriticalSection(CS);
    return Status;

}

VOID
IpTblCleanup(
    VOID
    )
/*++

Routine Description:
    Thsi routine undoes the effect of hte previous routine and it
    makes sure that no callbacks are executed after the routine
    returns.

--*/
{
    PCRITICAL_SECTION CS;
    
    if( 0 == DhcpGlobalEndPointTable.InitCount ) return;
    CS = DhcpGlobalEndPointTable.CS;
    EnterCriticalSection(CS);
    do {
        ULONG i;

        if( 0 == DhcpGlobalEndPointTable.InitCount ) break;
        
        DhcpGlobalEndPointTable.InitCount --;
        if( 0 != DhcpGlobalEndPointTable.InitCount ) {
            //
            // Someone else has the table open! 
            //
            break;
        }

        for( i = 0; i < DhcpGlobalEndPointTable.nEndPoints; i ++ ) {
            DhcpGlobalEndPointTable.Callback(
                REASON_ENDPOINT_DELETED,
                GET_ENDPOINT(&DhcpGlobalEndPointTable,i)
                );
        }

        HeapFree(
            DhcpGlobalEndPointTable.hHeap, 0,
            DhcpGlobalEndPointTable.EndPoints
            );
        DestroyAddrListChangeSocket(&DhcpGlobalEndPointTable.NotifySock);
        RtlZeroMemory(
            &DhcpGlobalEndPointTable, sizeof(DhcpGlobalEndPointTable)
            );
    } while ( 0 );
    LeaveCriticalSection(CS);
}

//
// Real address change notification handler
//
void HandleAddressChange(
    IN OUT PENDPOINT_TBL Tbl
    );

void CALLBACK AddrChangeHandler(
    IN DWORD dwError,
    IN DWORD cbTransferred,
    IN LPWSAOVERLAPPED Overlap,
    IN DWORD dwFlags
    )
/*++

Routine Description:
    This routine is called whenever any address change happens.
    This routine does not do anything if there was an error (only
    possibility is that the socket was closed underneath).

    It starts off by delaying handling the notifications by sleeping
    for 10 seconds.  Then the real notifications are handled under the
    global Critical section.

Arguments:
    dwError -- was the operation successful?
    cbTransferred -- unused
    Overlap -- the overlap buffer.
    dwFlags -- unused

--*/
{
    ULONG Status;
    PENDPOINT_TBL EpTbl;

    UNREFERENCED_PARAMETER(cbTransferred);
    UNREFERENCED_PARAMETER(dwFlags);

    if( NO_ERROR != dwError ) {
        return;
    }

    EpTbl = (PENDPOINT_TBL)(
        ((PBYTE)Overlap) - FIELD_OFFSET(ENDPOINT_TBL, Overlap)
        );

    HandleAddressChange(EpTbl);
}

VOID
UpdateTable(
    IN OUT PENDPOINT_TBL Tbl
    );

void HandleAddressChange(
    IN OUT PENDPOINT_TBL Tbl
    )
/*++

Routine Description:
    See AddrChangeHandler.

--*/
{
    ULONG Status;
    BOOL fFired;

    if( 0 == Tbl->InitCount ) {
        //
        // De-initialzed?
        //
        return;
    }

    EnterCriticalSection(Tbl->CS);
    do {
        if( 0 == Tbl->InitCount ) break;
        
        //
        // Wait for 10 seconds before posting any real notifications.
        //
        Sleep(TEMP_SLEEP_TIME);

        //
        // reregister the notifications. ignore anything that has
        // changed until now.
        //
        do {
            Status = PostAddrChangeNotification(
                Tbl->NotifySock, &Tbl->Overlap, AddrChangeHandler, &fFired
                );
            if( NO_ERROR != Status ) break;
        } while ( fFired );

        //
        // Now do the real meat of the work.
        //
        UpdateTable(Tbl);
    } while ( 0 );
    LeaveCriticalSection(Tbl->CS);
}

typedef
BOOL
(*PWALTHROUGH_RTN)(
    IN PVOID Context,
    IN PMIB_IPADDRROW AddrInfo,
    IN PIP_ADAPTER_INDEX_MAP IfInfo
    )
/*++

Routine Description:
    This is the prototype of the routine to be used to walkthrough
    the IPAddrTable and IfInfo.  For each entry in the addr table,
    the ifrow and ipaddrrow for that is passed to the routine.
    Both of the above should not be modified in any way.
    
Return Values:
    return FALSE to indicate that walkthrough should stop.
    return TRUE to indicate that walkthrough should continue.

--*/
;

VOID
WalkthroughEntries(
    IN PIP_INTERFACE_INFO IfInfo,
    IN PMIB_IPADDRTABLE AddrTable,
    IN PWALTHROUGH_RTN Routine,
    IN PVOID Context
    )
{
    LONG i;
    ULONG j;
    
    if( NULL == IfInfo || NULL == AddrTable ) {
        //
        // What do we do about the addresss?
        // For now, we just ignore.
        //
        return;
    }

    for(i = 0; i < IfInfo->NumAdapters ; i ++ ) {
        //
        // Now walk through the addr table for
        // entries for this interface.
        //
        ULONG Index = IfInfo->Adapter[i].Index;
        
        for( j = 0; j < AddrTable->dwNumEntries ; j ++ ) {
            if( Index == AddrTable->table[j].dwIndex ) {
                //
                // found another address on this interface.
                //
                BOOL fStatus = Routine(
                    Context,
                    &AddrTable->table[j],
                    &IfInfo->Adapter[i]
                    );
                if( FALSE == fStatus ) {
                    //
                    // end this routine right away.
                    //
                    return ;
                }
            }
        }
    }
}

typedef struct _search_context {
    ULONG IpAddress;
    ULONG IpIndex;
    LPCWSTR AdapterName;
    PULONG SubnetMask;
    BOOL fFound;
} SRCH_CTXT;

BOOL
SearchForEntryRoutine(
    IN PVOID Context,
    IN PMIB_IPADDRROW AddrInfo,
    IN PIP_ADAPTER_INDEX_MAP IfInfo
    )
/*++
    See PWALTHROUGH_RTN declaration.
    This routine returns FALSE if the current element is the
    required element.

--*/
{
    SRCH_CTXT *Ctxt = Context;
    //
    // first check IP address and index
    //

    if( AddrInfo->dwAddr != Ctxt->IpAddress ) return TRUE;
    if( AddrInfo->dwIndex != Ctxt->IpIndex ) return TRUE;

    //
    // Now case insensitive search for adapter name.
    //
    if( 0 != _wcsicmp(Ctxt->AdapterName, TCPPREFIX_LEN + IfInfo->Name ) )
        return TRUE;

    //
    // Ok everything matches.  Now set the subnet mask if it
    // had changed meanwhile.
    //
    if( *(Ctxt->SubnetMask) != AddrInfo->dwMask ) {
        *(Ctxt->SubnetMask) = AddrInfo->dwMask;
    }

    //
    // Since the match happened -- don't need to do anything more.
    // just return FALSE to indicate search has to stop.
    //
    Ctxt->fFound = TRUE;
    return FALSE;
}

BOOL
SearchForEntry(
    IN PIP_INTERFACE_INFO IfInfo,
    IN PMIB_IPADDRTABLE AddrTable,
    IN LPCWSTR AdapterName,
    IN ULONG IpAddress,
    IN ULONG IpIndex,
    OUT ULONG *SubnetMask
    )
/*++

Routine Description:
    This routine walks the AddrTable,IfInfo and for each entry in
    that, it checks to see if it is the same as the AdapterName,
    IpAddress and IpIndex triple.  If so, it sets the SubnetMask to
    any new value (if it had changed) and returns TRUE.

    If no matches were found, this routine returns FALSE.

    AdapterName comparisons are case insensitive.

    N.B.  Walking the IpAddrTable is done by calling
    WalkthroughEntries with a routine that will handle comparing each
    item.

Arguments:
    IfInfo -- list of interfaces (used for adatper name)
    AddrTable -- list of addresses
    AdapterName -- the adapter name to compare.
    IpAddress -- ip address to compare
    IpIndex -- index to compare.
    SubnetMask -- if an entry is found with diff mask, update mask
        here.

Return Values:
    TRUE -- match found.
    FALSE -- no match found.

--*/
{
    SRCH_CTXT Ctxt = {
        IpAddress,
        IpIndex,
        AdapterName,
        SubnetMask,
        FALSE
    };

    WalkthroughEntries(
        IfInfo,
        AddrTable,
        SearchForEntryRoutine,
        &Ctxt
        );

    return Ctxt.fFound;
}

BOOL
AddEntriesRoutine(
    IN PVOID Context,
    IN PMIB_IPADDRROW AddrInfo,
    IN PIP_ADAPTER_INDEX_MAP IfInfo
    )
/*++

Routine Description:
    This routine attempts to add the specified address as an entry in
    the endpoint table, if one didnt exist.  It also calls the
    callback at this time to indicate this to higher layer.

    N.B. This routine ignores any zero addresses.

Arguments:
    Context -- this is actually the Tbl structure.
    AddrInfo -- info on the address
    IfInfo -- info on interface this address bleongs to.

Return Value:
    always TRUE.
--*/
{
    GUID IfGuid;
    ULONG i;
    PENDPOINT_TBL Tbl = Context;
    
    //
    // Ignore zero addresses.
    //
    if( 0 == AddrInfo->dwAddr ) return TRUE;

    //
    // If interface name isn't a guid, then drop interface.
    //
    if( !ConvertGuidFromIfNameString(&IfGuid, TCPPREFIX_LEN + IfInfo->Name) ) {
        return TRUE;
    }

    //
    // Now comes the meat of the work of walking through the
    // end point table looking for this same entry.
    //

    for( i = 0; i < Tbl->nEndPoints; i ++ ) {
        PENDPOINT_ENTRY Entry = GET_ENDPOINT(Tbl, i);

        if( Entry->IpAddress != AddrInfo->dwAddr ) continue;
        if( Entry->IpIndex != AddrInfo->dwIndex ) continue;
        if( !RtlEqualMemory(
            &Entry->IfGuid,&IfGuid,sizeof(IfGuid)) ) {
            continue;
        }

        //
        // ooo. found a match! so, we can't add this entry.
        //
        return TRUE;
    }

    //
    // Ok, entry isn't found.  Now try to allocate space for
    // it and add it if possible.
    //

    ADD_ENDPOINT(
        Tbl, &IfGuid, AddrInfo->dwAddr,
        AddrInfo->dwIndex, AddrInfo->dwReasmSize, AddrInfo->dwMask
        );

    return TRUE;
}

BOOL _stdcall RefreshEndPointsRoutine(
    IN PENDPOINT_ENTRY Entry,
    IN PENDPOINT_TBL Tbl
    )
{
    Tbl->Callback(
        REASON_ENDPOINT_REFRESHED,
        Entry 
       );
    return TRUE;
}
    
VOID
UpdateTable(
    IN OUT PENDPOINT_TBL Tbl
    )
/*++

Routine Description:
    This routine updates the table by retrieving all info from IP.
    It also calls the notificiation handler in Tbl->Callback.

Arguments:
    Tbl to update.

Return Value:
    none

--*/
{
    PIP_INTERFACE_INFO IfInfo;
    PMIB_IPADDRTABLE AddrTable;
    ULONG Status, Size, i;

    //
    // First get the IF table.
    //
    
    IfInfo = NULL; Size = 0;
    do {
        Status = GetInterfaceInfo(
            IfInfo,
            &Size
            );
        if( ERROR_INSUFFICIENT_BUFFER != Status ) break;
        if( IfInfo ) HeapFree(Tbl->hHeap, 0, IfInfo);
        if( 0 == Size ) {
            IfInfo = NULL;
            Status = NO_ERROR;
            break;
        }
        IfInfo = HeapAlloc(Tbl->hHeap, 0, Size);
        if( NULL == IfInfo ) {
            Status = GetLastError();
            break;
        }
    } while ( TRUE );

    if( NO_ERROR != Status ) return;
    
    //
    // Next get the addr table
    //

    AddrTable = NULL; Size = 0;
    do {
        Status = GetIpAddrTable(
            AddrTable,
            &Size,
            FALSE
            );
        if( ERROR_INSUFFICIENT_BUFFER != Status ) break;
        if( AddrTable ) HeapFree(Tbl->hHeap, 0, AddrTable);
        if( 0 == Size ) {
            AddrTable = NULL;
            Status = NO_ERROR;
            break;
        }
        AddrTable = HeapAlloc(Tbl->hHeap, 0, Size);
        if( NULL == AddrTable ) {
            Status = GetLastError();
            break;
        }
    } while (TRUE );

    if( NO_ERROR != Status ) {
        if(IfInfo ) HeapFree(Tbl->hHeap, 0, IfInfo );
        return;
    }

    //
    // Now first walk through the endpoint table and see if
    // any of old entries are not valid anymore.
    //
    for( i = 0 ; i < Tbl->nEndPoints ; i ++ ) {
        PENDPOINT_ENTRY Entry = GET_ENDPOINT(Tbl, i);
        WCHAR GuidString[50];
        BOOL fStatus;
        
        fStatus = ConvertGuidToIfNameString(
            &Entry->IfGuid, GuidString,
            sizeof(GuidString)/sizeof(WCHAR)
            );
        if( FALSE == fStatus ) {
            //
            // Couldn't convert? Can't really happen.
            //
            //RtlAssert( "FALSE", __FILE__, __LINE__, NULL);
            continue;
        }

        //
        // Now see if there is any adapter with the
        // same set of GuidString, Entry->IpAddress, Entry->IpIndex
        //
        fStatus = SearchForEntry(
            IfInfo, AddrTable,
            GuidString, Entry->IpAddress, Entry->IpIndex,
            &Entry->SubnetMask
            );
        if( FALSE != fStatus ) {
            //
            // Cool. The entry was also present in the newer IP table.
            // nothing to do for this entry.
            //
            continue;
        }
        
        //
        // if this isn't found, then this entry doesn't exist
        // anymore -- so delete this.
        //
        // Now we can ignore this entry and move the rest of
        // the stuff out of the way.
        //
        DELETE_ENDPOINT(Tbl, i);
        i -- ;
    }

    //
    // We have deleted all endpoints that need to be deleted.
    // Now walk through the IP table and add all entries that
    // have to be added.
    //

    WalkthroughEntries(
        IfInfo, AddrTable,
        AddEntriesRoutine,
        Tbl
        );

    //
    // Now free the tables concerned.
    //
    if( IfInfo ) HeapFree( Tbl->hHeap, 0, IfInfo );
    if( AddrTable ) HeapFree( Tbl->hHeap, 0, AddrTable );

    //
    // Now give a chance to update everything.
    //
    WalkthroughEndpoints(
        Tbl,
        RefreshEndPointsRoutine
        );
    
}

//
// end of file.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\dsreg.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: This module does the DS downloads in a safe way.
// To do this, first a time check is made between registry and DS to see which
// is the latest... If the DS is latest, it is downloaded onto a DIFFERENT
// key from the standard location.  After a successful download, the key is just
// saved and restored onto the normal configuration key.
// Support for global options is lacking.
//================================================================================

#include    <dhcppch.h>
#include    <dhcpapi.h>
#include    <dhcpds.h>

VOID
GetDNSHostName(                                   // get the DNS FQDN of this machine
    IN OUT  LPWSTR                 Name           // fill in this buffer with the name
)
{
    DWORD                          Err;
    CHAR                           sName[300];    // DNS name shouldn't be longer than this.
    HOSTENT                        *h;

    Err = gethostname(sName, sizeof(sName));
    if( ERROR_SUCCESS != Err ) {                  // oops.. could not get host name?
        wcscpy(Name,L"gethostname error");        // uhm.. should handle this better.. 
        return;
    }

    h = gethostbyname(sName);                      // try to resolve the name to get FQDN
    if( NULL == h ) {                             // gethostname failed? it shouldnt..?
        wcscpy(Name,L"gethostbyname error");      // should handle this better
        return;
    }

    Err = mbstowcs(Name, h->h_name, strlen(h->h_name)+1);
    if( -1 == Err ) {                             // this is weird, mbstowcs cant fail..
        wcscpy(Name,L"mbstowcs error");           // should fail better than this 
        return;
    }
}

VOID
GetLocalFileTime(                                 // fill in filetime struct w/ current local time
    IN OUT  LPFILETIME             Time           // struct to fill in
)
{
    BOOL                           Status;
    SYSTEMTIME                     SysTime;

    GetSystemTime(&SysTime);                      // get sys time as UTC time.
    Status = SystemTimeToFileTime(&SysTime,Time); // conver system time to file time
    if( FALSE == Status ) {                       // convert failed?
        Time->dwLowDateTime = 0xFFFFFFFF;         // set time to weird value in case of failiure
        Time->dwHighDateTime = 0xFFFFFFFF;
    }
}

VOID
GetRegistryTime(                                  // get the last update time on the registry?
    IN OUT  LPFILETIME             Time           // this is the time of last change..
) {
    DWORD                          Err, Size;
    HKEY                           hKey;

    Time->dwLowDateTime =Time->dwHighDateTime =0; // set time to "long back" initially
    Err = RegOpenKeyEx                            // try to open the config key.
    (
        /* hKey                 */ HKEY_LOCAL_MACHINE,
        /* lpSubKey             */ DHCP_SWROOT_KEY DHCP_CONFIG_KEY,
        /* ulOptions            */ 0 /* Reserved */ ,
        /* samDesired           */ KEY_ALL_ACCESS,
        /* phkResult            */ &hKey
    );
    if( ERROR_SUCCESS != Err ) return;            // time is still set to ages back

    Size = sizeof(*Time);
    Err = RegQueryValueEx                         // now fetch the lastdownload time value..
    (
        /* hKey                 */ hKey,
        /* lpValueName          */ DHCP_LAST_DOWNLOAD_TIME_VALUE,
        /* lpReserved           */ NULL,
        /* lpType               */ NULL,          // must verify type is REG_BINARY?
        /* lpData               */ (LPBYTE)Time,
        /* lpcData              */ &Size          // space reqd
    );
    RegCloseKey(hKey);                            // close key before we forget

    if( ERROR_SUCCESS != Err || Size != sizeof(*Time) ) {
        GetLocalFileTime(Time);                   // error, set registry time as NOW
    }
}

VOID
GetDsTime(                                        // get last update time server in DS.
    IN      LPWSTR                 ServerName,    // server to get last update time for
    IN OUT  LPFILETIME             Time           // fill this struct w/ the time
) {
    DWORD                          Err;

    Err = DhcpDsGetLastUpdateTime(ServerName,Time);
    if( ERROR_SUCCESS != Err ) {                  // ouch, cant get the time? set it to 0/0 ?
        Time->dwHighDateTime = 0;
        Time->dwLowDateTime = 0;
    }
}

BOOL
RegistryIsMoreCurrentThanDS(                      // if registry has later time stmp than DS?
    IN      LPWSTR                 ServerName
)
{
    DWORD                          Error;
    FILETIME                       RegTime, DsTime;

    GetRegistryTime(&RegTime);                    // get the time from regsitry
    GetDsTime(ServerName, &DsTime);               // and time from DS

    if( -1 == CompareFileTime(&RegTime, &DsTime) ) {
        return FALSE;                             // registry has earlier timestamp
    }
    return TRUE;                                  // doesnt matter if both have same..
}

VOID
DhcpRegDownloadDs(                                // function defined in mmreg\regds.c
    IN    LPWSTR                   ServerName
);

VOID
DhcpDownloadDsToRegistry(
    VOID
)
{
    DWORD                          Err;
    WCHAR                          Name[300];     // DNS name cannot be longer than this..

    GetDNSHostName(Name);                         // get DNS name of this machine
    if( RegistryIsMoreCurrentThanDS(Name) ) {     // if the reg. is more current, ignore DS
        return;
    }

    DhcpRegDownloadDs(Name);                      // download the DS stuff onto the registry..
}

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\makefile.inc ===
$(O)\dhcptest.res: dhcptest.rc
$(O)\roguet.res: roguet.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\lock.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:
    lock.c

Abstract:
    Implement recursive read write locks

Environment:
    User mode win32 NT

--*/
#include <dhcppch.h>

typedef struct _RW_LOCK {
    DWORD TlsIndex;
    LONG LockCount;
    CRITICAL_SECTION Lock;
    HANDLE ReadersDoneEvent;
} RW_LOCK, *PRW_LOCK, *LPRW_LOCK;

DWORD
RwLockInit(
    IN OUT PRW_LOCK Lock
) 
{
    Lock->TlsIndex = TlsAlloc();
    if( 0xFFFFFFFF == Lock->TlsIndex ) {
        //
        // Could not allocate thread local space?
        //
        return GetLastError();
    }

    Lock->LockCount = 0;
    try {
        InitializeCriticalSection(&Lock->Lock);
    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // shouldnt happen.
        //

        return( GetLastError( ) );
    }

    Lock->ReadersDoneEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if( NULL == Lock->ReadersDoneEvent ) {
        ULONG Error = GetLastError();

        TlsFree(Lock->TlsIndex);
        DeleteCriticalSection( &Lock->Lock );
        return Error;
    }

    return ERROR_SUCCESS;
}

DWORD
RwLockCleanup(
    IN OUT PRW_LOCK Lock
) 
{
    BOOL Status;

    DhcpAssert( 0 == Lock->LockCount);

    Status = TlsFree(Lock->TlsIndex);
    if( FALSE == Status ) { 
        DhcpAssert(FALSE); 
        return GetLastError(); 
    }
    DeleteCriticalSection(&Lock->Lock);

    return ERROR_SUCCESS;
}

DWORD
RwLockAcquireForRead(
    IN OUT PRW_LOCK Lock
) 
{
    DWORD TlsIndex, Status;
    LONG LockState;

    TlsIndex = Lock->TlsIndex;
    DhcpAssert( 0xFFFFFFFF != TlsIndex);

    LockState = (LONG)((ULONG_PTR)TlsGetValue(TlsIndex));
    if( LockState > 0 ) {
        //
        // already taken this read lock
        //
        LockState ++;
        Status = TlsSetValue(TlsIndex, ULongToPtr(LockState));
        DhcpAssert( 0 != Status);
        return ERROR_SUCCESS;
    }

    if( LockState < 0 ) {
        //
        // already taken  a # of write locks, pretend this is one too
        //
        LockState --;
        Status = TlsSetValue(TlsIndex, ULongToPtr(LockState));
        DhcpAssert( 0 != Status);
        return ERROR_SUCCESS;
    }

    EnterCriticalSection(&Lock->Lock);
    InterlockedIncrement( &Lock->LockCount );
    LeaveCriticalSection(&Lock->Lock);
    
    LockState = 1;
    Status = TlsSetValue(TlsIndex, ULongToPtr(LockState));
    DhcpAssert(0 != Status);

    return ERROR_SUCCESS;
}

DWORD
RwLockAcquireForWrite(
    IN OUT PRW_LOCK Lock
) 
{
    DWORD TlsIndex, Status;
    LONG LockState;

    TlsIndex = Lock->TlsIndex;
    DhcpAssert( 0xFFFFFFFF != TlsIndex);

    LockState = (LONG)((ULONG_PTR)TlsGetValue(TlsIndex));
    if( LockState > 0 ) {
        //
        // already taken # of read locks? Can't take write locks then!
        //
        DhcpAssert(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    if( LockState < 0 ) {
        //
        // already taken  a # of write locks, ok, take once more
        //
        LockState --;
        Status = TlsSetValue(TlsIndex, ULongToPtr(LockState));
        DhcpAssert( 0 != Status);
        return ERROR_SUCCESS;
    }

    EnterCriticalSection(&Lock->Lock);
    LockState = -1;
    Status = TlsSetValue(TlsIndex, ULongToPtr(LockState));
    DhcpAssert(0 != Status);

    if( InterlockedDecrement( &Lock->LockCount ) >= 0 ) {
        //
        // Wait for all the readers to get done..
        //
        WaitForSingleObject(Lock->ReadersDoneEvent, INFINITE );
    }
    return ERROR_SUCCESS;

}

DWORD
RwLockRelease(
    IN OUT PRW_LOCK Lock
) 
{
    DWORD TlsIndex, Status;
    LONG LockState;
    BOOL fReadLock;

    TlsIndex = Lock->TlsIndex;
    DhcpAssert( 0xFFFFFFFF != TlsIndex);

    LockState = (LONG)((ULONG_PTR)TlsGetValue(TlsIndex));
    DhcpAssert(0 != LockState);

    fReadLock = (LockState > 0);    
    if( fReadLock ) {
        LockState -- ;
    } else {
        LockState ++ ;
    }
     
    Status = TlsSetValue( TlsIndex, ULongToPtr( LockState) );
    DhcpAssert( 0 != Status );
    
    if( LockState != 0 ) {
        //
        // Recursively taken? Just unwind recursion..
        // nothing more to do.
        //
        return ERROR_SUCCESS;
    }

    //
    // If this is a write lock, we have to check to see 
    //
    if( FALSE == fReadLock ) {
        //
        // Reduce count to zero
        //
        DhcpAssert( Lock->LockCount == -1 );
        Lock->LockCount = 0;
        LeaveCriticalSection( &Lock->Lock );
        return ERROR_SUCCESS;
    }

    //
    // Releasing a read lock -- check if we are the last to release
    // if so, and if any writer pending, allow writer..
    //

    if( InterlockedDecrement( &Lock->LockCount ) < 0 ) {
        SetEvent( Lock->ReadersDoneEvent );
    }

    return ERROR_SUCCESS;
}

//
// specific requirements for dhcp server -- code for that follows
//
PRW_LOCK DhcpGlobalReadWriteLock = NULL;


//BeginExport(function)
DWORD
DhcpReadWriteInit(
    VOID
) //EndExport(function)
{
    DWORD Error;

    DhcpAssert(NULL == DhcpGlobalReadWriteLock);

    DhcpGlobalReadWriteLock = DhcpAllocateMemory(
        sizeof(*DhcpGlobalReadWriteLock)
        );
    if( NULL == DhcpGlobalReadWriteLock ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = RwLockInit(DhcpGlobalReadWriteLock);
    if( ERROR_SUCCESS != Error ) {
        DhcpFreeMemory(DhcpGlobalReadWriteLock);
        DhcpGlobalReadWriteLock = NULL;
    }
    return Error;
}

//BeginExport(function)
VOID
DhcpReadWriteCleanup(
    VOID
) //EndExport(function)
{
    DWORD Error;
    
    if( NULL == DhcpGlobalReadWriteLock ) return;

    Error = RwLockCleanup(DhcpGlobalReadWriteLock);
    DhcpGlobalReadWriteLock = NULL;
    DhcpAssert(ERROR_SUCCESS == Error);
}

//BeginExport(function)
VOID
DhcpAcquireReadLock(
    VOID
) //EndExport(function)
{
    DWORD Error;

    Error = RwLockAcquireForRead(
        DhcpGlobalReadWriteLock
        );
    DhcpAssert(ERROR_SUCCESS == Error);
}

//BeginExport(function)
VOID
DhcpAcquireWriteLock(
    VOID
) //EndExport(function)
{
    DWORD Error;

    Error = RwLockAcquireForWrite(
        DhcpGlobalReadWriteLock
        );
    DhcpAssert(ERROR_SUCCESS == Error);
}

//BeginExport(function)
VOID
DhcpReleaseWriteLock(
    VOID
) //EndExport(function)
{
    DWORD Error;

    Error = RwLockRelease(
        DhcpGlobalReadWriteLock
        );
    DhcpAssert(ERROR_SUCCESS == Error);
}

//BeginExport(function)
VOID
DhcpReleaseReadLock(
    VOID
) //EndExport(function)
{
    DWORD Error;

    Error = RwLockRelease(
        DhcpGlobalReadWriteLock
        );
    DhcpAssert(ERROR_SUCCESS == Error);
}

#if DBG
static  struct {
    LPCRITICAL_SECTION             CS;
    DWORD                          Thread;
} Table[] = {
    &DhcpGlobalRegCritSect,         -1,
    //    &DhcpGlobalMemoryCritSect,      -1,
    &DhcpGlobalJetDatabaseCritSect, -1,
    &DhcpGlobalInProgressCritSect,  -1,
};

#undef      EnterCriticalSection
#undef      LeaveCriticalSection
#undef      EnterCriticalSectionX
#undef      LeaveCriticalSectionX


VOID
EnterCriticalSectionX(
    IN OUT LPCRITICAL_SECTION CS,
    IN DWORD Line,
    IN LPSTR File
)
{
    DWORD i, j;
    DWORD Thread;

    EnterCriticalSection(CS);
    DhcpPrint((DEBUG_TRACK, "Entered CS %s:%ld\n", File, Line));

    for( i = 0; i < sizeof(Table)/sizeof(Table[0]); i ++ )
        if( Table[i].CS == CS ) break;

    if( i >= sizeof(Table)/sizeof(Table[0]) ) return;

    Thread = (DWORD)GetCurrentThreadId();
    for( j = 0; j < sizeof(Table)/sizeof(Table[0]); j ++ )
        if( j != i && Table[j].Thread == Thread ) {
            DhcpPrint((DEBUG_ERRORS, "Already have lock %d "
                       "while trying lock %d\n", j, i));
            //
            //  known problem == does nto cause deadlocks
            //
            if( j == 2 && i == 1 ) continue;
            DbgBreakPoint();
        }

    Table[i].Thread = Thread;
}

VOID
LeaveCriticalSectionX(
    IN LPCRITICAL_SECTION CS,
    IN DWORD Line,
    IN LPSTR File
)
{
    DWORD i, j;

    for( i = 0; i < sizeof(Table)/sizeof(Table[0]); i ++ )
        if( Table[i].CS == CS ) {
            Table[i].Thread = -1;
            break;
        }

    DhcpPrint((DEBUG_TRACK, "Leaving CS %s:%ld\n", File, Line));
    LeaveCriticalSection(CS);
}

#endif DBG


//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\iptbl.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

Module Name:
    iptbl.h

Abstract:
    implements the IP addr table notification mechanism.

Environment:
    Usermode Win32, NT5+

--*/

#ifndef IPTBL_H_INCLUDED
#define IPTBL_H_INCLUDED

#ifdef _cplusplus
extern "C" {
#endif


//
// Each endpoint has the following struct.
//

#define MAX_GUID_STRING_SIZE 60

typedef struct _ENDPOINT_ENTRY {
    GUID IfGuid;
    ULONG IpAddress;
    ULONG IpIndex;
    ULONG SubnetMask;
    ULONG IpContext;
    //
    // This area is followed by any user-allocated data.
    //
} ENDPOINT_ENTRY, *PENDPOINT_ENTRY;


//
// this is the routine that is called back when changes occur.
//
#define REASON_ENDPOINT_CREATED   0x01
#define REASON_ENDPOINT_DELETED   0x02
#define REASON_ENDPOINT_REFRESHED 0x03

typedef VOID (_stdcall *ENDPOINT_CALLBACK_RTN)(
    IN ULONG Reason,
    IN OUT PENDPOINT_ENTRY EndPoint
    );

VOID
WalkthroughEndpoints(
    IN PVOID Context,
    IN BOOL (_stdcall *WalkthroughRoutine)(
        IN OUT PENDPOINT_ENTRY Entry,
        IN PVOID Context
        )
    );

//
// This the routine that is called to initialize this module.
//
ULONG
IpTblInitialize(
    IN OUT PCRITICAL_SECTION CS,
    IN ULONG EndPointEntrySize,
    IN ENDPOINT_CALLBACK_RTN Callback,
    IN HANDLE hHeap
    );

VOID
IpTblCleanup(
    VOID
    );


#ifdef _cplusplus
}
#endif

#endif  IPTBL_H_INCLUDED
//
// end of file.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\mdhcpmsc.c ===
/*++

  Copyright (c) 1994  Microsoft Corporation

  Module Name:

  mdhcpdb.c

  Abstract:

  This module contains the functions for interfacing with the JET
  database API pertaining to MDHCP.

  Author:

  Munil Shah

  Environment:

  User Mode - Win32

  Revision History:

  --*/

#include "dhcppch.h"
#include "mdhcpsrv.h"

DWORD
DhcpDeleteMScope(
    IN LPWSTR MScopeName,
    IN DWORD ForceFlag
    );

BOOL
MadcapGetIpAddressFromClientId(
    PBYTE   ClientId,
    DWORD   ClientIdLength,
    PVOID   IpAddress,
    PDWORD  IpAddressLength
)
    /*++

      Routine Description:

      This function looks up the IP address corresponding to the given
      hardware address.

      Arguments:

      ClientId - pointer to a buffer where the hw address is returned.
      ClientIdLength - length of the above buffer.
      IpAddress - Pointer to buffer where ip address is to be copied(
                    when *ipaddresslength is nonzero)
                  Otherwise it is a pointer to a buffer pointer value
                     of which is assigned when the buffer is created
                     by this routine.

      IpAddressLength - Pointer to size of above buffer, if 0 then this
                        routine will allocate.

      Return Value:

      TRUE - The IP address was found.
      FALSE - The IP address could not be found.


      --*/
{
    DWORD Error;
    DWORD Size;
    DB_CTX  DbCtx;

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    Error = MadcapJetOpenKey(
        &DbCtx,
        MCAST_COL_NAME(MCAST_TBL_CLIENT_ID),
        ClientId,
        ClientIdLength );

    if ( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }

    //
    // Get the ip address information for this client.
    //
    Error = MadcapJetGetValue(
        &DbCtx,
        MCAST_COL_HANDLE(MCAST_TBL_IPADDRESS),
        IpAddress,
        IpAddressLength );

    if ( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }


    return( TRUE );
}

BOOL
MadcapGetClientIdFromIpAddress(
    PBYTE IpAddress,
    DWORD IpAddressLength,
    PVOID ClientId,
    PDWORD ClientIdLength
)
    /*++

      Routine Description:

      This function looks up the IP address corresponding to the given
      hardware address.

      Arguments:

      IpAddress - Pointer to Ipaddress of a record whose hw address is requested.
      IpAddressLength - Length of the above buffer.
      ClientId - pointer to a buffer where the client id is returned (when
                    *clientidlength is nonzero)
                 Otherwise it is a pointer to buffer pointer which will be
                    allocated by this routine.
      ClientIdLength - Pointer to the length of the above buffer.

      Return Value:

      TRUE - The IP address was found.
      FALSE - The IP address could not be found.  *IpAddress = -1.


      --*/
{
    DWORD Error;
    DWORD Size;
    DB_CTX  DbCtx;

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    Error = MadcapJetOpenKey(
        &DbCtx,
        MCAST_COL_NAME(MCAST_TBL_IPADDRESS),
        IpAddress,
        IpAddressLength );

    if ( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }

    //
    // Get the ip address information for this client.
    //

    Error = MadcapJetGetValue(
        &DbCtx,
        MCAST_COL_HANDLE(MCAST_TBL_CLIENT_ID),
        ClientId,
        ClientIdLength );

    if ( Error != ERROR_SUCCESS ) {
        return( FALSE );
    }


    return( TRUE );
}

DWORD
MadcapGetRemainingLeaseTime(
    PBYTE ClientId,
    DWORD ClientIdLength,
    DWORD *LeaseTime
)
    /*++

      Routine Description:

      This function looks up remaining leasetime for the client whose
      id is given.

      Arguments:

      ClientId - pointer to a buffer where the hw address is returned.
      ClientIdLength - length of the above buffer.
      LeaseTime - Returns the remaining lease time.

      Return Value:

        Returns jet error.

      --*/
{
    DWORD Error;
    DWORD Size;
    DWORD EndTimeLen;
    DB_CTX  DbCtx;
    DATE_TIME       CurrentTime;
    LARGE_INTEGER   Difference;
    DATE_TIME       EndTime;


    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    Error = MadcapJetOpenKey(
        &DbCtx,
        MCAST_COL_NAME(MCAST_TBL_CLIENT_ID),
        ClientId,
        ClientIdLength );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    // Get the Lease duration information for this client.
    //
    CurrentTime = DhcpCalculateTime(0);
    EndTimeLen = sizeof(EndTime);
    Error = MadcapJetGetValue(
        &DbCtx,
        MCAST_COL_HANDLE(MCAST_TBL_LEASE_END),
        &EndTime,
        &EndTimeLen );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    if (((LARGE_INTEGER *)&EndTime)->QuadPart <= ((LARGE_INTEGER *)&CurrentTime)->QuadPart) {
        *LeaseTime = 0;
        return ERROR_SUCCESS;
    }
    Difference.QuadPart = ((LARGE_INTEGER *)&EndTime)->QuadPart - ((LARGE_INTEGER *)&CurrentTime)->QuadPart;
    Difference.QuadPart /= 10000000;
    *LeaseTime = Difference.LowPart;

    return( ERROR_SUCCESS );
}

DWORD
MadcapCreateClientEntry(
    LPBYTE                ClientIpAddress,
    DWORD                 ClientIpAddressLength,
    DWORD                 ScopeId,
    LPBYTE                ClientId,
    DWORD                 ClientIdLength,
    LPWSTR                ClientInfo OPTIONAL,
    DATE_TIME             LeaseStarts,
    DATE_TIME             LeaseTerminates,
    DWORD                 ServerIpAddress,
    BYTE                  AddressState,
    DWORD                 AddressFlags,
    BOOL                  OpenExisting
    )
/*++

Routine Description:

    This function creates a client entry in the client database.

Arguments:

    ClientIpAddress - A pointer to the IP address of the client.

    ClientIpAddressLength - The length of the above buffer.

    ClientId - The unique id of this client.

    ClientIdLength - The length, in bytes, of the hardware address.

    ClientInfo - The textual info of the client.

    LeaseDuration - The duration of the lease, in seconds.

    ServerIpAddress - IpAddress of the server on the net where the
        client gets response.

    AddressState - The new state of the address.

    OpenExisting - If the client already exists in the database.
        TRUE - Overwrite the information for this client.
        FALSE - Do not over overwrite existing information.  Return an error.

        Ignored if this client does not exist in the database.

    Packet -  the original wrapper to put information if we have to schedule a
        ping for conflict detection; NULL ==> dont schedule, just do synchronously

    Status -  the DWORD here is ERROR_SUCCESS whenever a ping is NOT scheduled.

Return Value:

    The status of the operation.

--*/
{
    DHCP_IP_ADDRESS SubnetMask;
    DWORD Error,LocalError;
    BOOL AddressAlloted = FALSE;
    BOOL TransactBegin = FALSE;
    JET_ERR JetError = JET_errSuccess;
    WCHAR   CurClientInformation[ MACHINE_INFO_SIZE / sizeof(WCHAR) ];
    DWORD   CurClientInformationSize = MACHINE_INFO_SIZE;
    LPBYTE HWAddr;
    DWORD HWAddrLength;
    BYTE  bAllowedClientTypes;
    BYTE PreviousAddressState;
    DWORD Size;
    DB_CTX  DbCtx;


    DhcpAssert(0 != ClientIpAddress);

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    //
    // lock both registry and database locks here to avoid dead lock.
    //

    LOCK_DATABASE();

    //
    // start transaction before a create/update database record.
    //

    Error = MadcapJetBeginTransaction(&DbCtx);

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    TransactBegin = TRUE;

    Error = MadcapJetPrepareUpdate(
        &DbCtx,
        MCAST_COL_NAME(MCAST_TBL_IPADDRESS),
        ClientIpAddress,
        ClientIpAddressLength,
        !OpenExisting );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // if new record update constant info.
    //

    if( !OpenExisting ) {

        Error = MadcapJetSetValue(
            &DbCtx,
            MCAST_COL_HANDLE(MCAST_TBL_IPADDRESS),
            ClientIpAddress,
            ClientIpAddressLength);

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

    }

    Error = MadcapJetSetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_SCOPE_ID),
                &ScopeId,
                sizeof(ScopeId));

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = MadcapJetSetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_STATE),
                &AddressState,
                sizeof(AddressState));

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = MadcapJetSetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_FLAGS),
                &AddressFlags,
                sizeof(AddressFlags));

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    // ClientHarwardAddress can't be NULL.
    DhcpAssert( (ClientId != NULL) &&
                (ClientIdLength > 0) );


    Error = MadcapJetSetValue(
        &DbCtx,
        MCAST_COL_HANDLE(MCAST_TBL_CLIENT_ID),
        ClientId,
        ClientIdLength
    );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if ( !OpenExisting || ClientInfo ) {
        Error = MadcapJetSetValue(
                  &DbCtx,
                  MCAST_COL_HANDLE(MCAST_TBL_CLIENT_INFO),
                  ClientInfo,
                  (ClientInfo == NULL) ? 0 :
                    (wcslen(ClientInfo) + 1) * sizeof(WCHAR) );
    }

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }



    Error = MadcapJetSetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_LEASE_START),
                &LeaseStarts,
                sizeof(LeaseStarts));

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = MadcapJetSetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_LEASE_END),
                &LeaseTerminates,
                sizeof(LeaseTerminates));

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = MadcapJetSetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_SERVER_NAME),
                DhcpGlobalServerName,
                DhcpGlobalServerNameLen );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = MadcapJetSetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_SERVER_IP_ADDRESS),
                &ServerIpAddress,
                sizeof(ServerIpAddress) );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }


    //
    // commit changes.
    //

    JetError = JetUpdate(
                    DhcpGlobalJetServerSession,
                    MadcapGlobalClientTableHandle,
                    NULL,
                    0,
                    NULL );
    if( JET_errKeyDuplicate == JetError ) {
        DhcpAssert( FALSE );
        Error = ERROR_DHCP_JET_ERROR;
    } else {
        Error = DhcpMapJetError(JetError, "MCreateClientEntry:Update");
    }
Cleanup:

    if ( Error != ERROR_SUCCESS ) {
        LocalError = MadcapJetRollBack(&DbCtx);
        DhcpAssert( LocalError == ERROR_SUCCESS );
        DhcpPrint(( DEBUG_ERRORS, "Can't create client entry in the "
                    "database, %ld.\n", Error));
    }
    else {
        //
        // commit the transaction before we return.
        LocalError = MadcapJetCommitTransaction(&DbCtx);
        DhcpAssert( LocalError == ERROR_SUCCESS );
    }

    UNLOCK_DATABASE();
    return( Error );
}

DWORD
MadcapValidateClientByIpAddr(
    DHCP_IP_ADDRESS ClientIpAddress,
    PVOID ClientId,
    DWORD ClientIdLength
    )
/*++

Routine Description:

    This function verifies that an IP address and hardware address match.

Arguments:

    ClientIpAddress - The IP address of the client.

    ClientId - The hardware address of the client

    ClientIdLenght - The length, in bytes, of the hardware address.

Return Value:

    The status of the operation.

--*/
{
    LPBYTE LocalClientId = NULL;
    LPSTR                          IpAddressString;
    DWORD Length;
    DWORD Error;
    DB_CTX  DbCtx;


    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    Error = MadcapJetOpenKey(
                &DbCtx,
                MCAST_COL_NAME(MCAST_TBL_IPADDRESS),
                &ClientIpAddress,
                sizeof(ClientIpAddress));

    if ( Error != ERROR_SUCCESS ) {
        Error = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }


    Length = 0;
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_CLIENT_ID),
                &LocalClientId,
                &Length);

    DhcpAssert( Length != 0 );

    if (Length == ClientIdLength &&
        (RtlCompareMemory(
                (LPBYTE) LocalClientId ,
                (LPBYTE) ClientId ,
                Length) == Length ))
    {
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }


    IpAddressString = DhcpIpAddressToDottedString(ClientIpAddress);
    if ( RtlCompareMemory(
            LocalClientId,
            IpAddressString,
            strlen(IpAddressString)) == strlen(IpAddressString)) {
        // reconciled address.
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    Error  = ERROR_GEN_FAILURE;

Cleanup:

    if( LocalClientId != NULL ) {
        MIDL_user_free( LocalClientId );
    }

    return( Error );
}

DWORD
MadcapValidateClientByClientId(
    LPBYTE ClientIpAddress,
    DWORD  ClientIpAddressLength,
    PVOID  ClientId,
    DWORD  ClientIdLength
    )
/*++

Routine Description:

    This function verifies that an IP address and hardware address match.

Arguments:

    ClientIpAddress - Pointer to the IP address of the client.

    ClientIpAddressLength - Length of the above buffer.

    ClientId - The client id of the client

    ClientIdLenght - The length, in bytes, of the client id.

Return Value:

    The status of the operation.

--*/
{
    DWORD   Error;
    DB_CTX  DbCtx;
    LPBYTE  LocalIpAddress = NULL;
    DWORD   LocalLength;


    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    Error = MadcapJetOpenKey(
                &DbCtx,
                MCAST_COL_NAME(MCAST_TBL_CLIENT_ID),
                ClientId,
                ClientIdLength);

    if ( Error != ERROR_SUCCESS ) {
        return ERROR_FILE_NOT_FOUND;
    }


    LocalLength = 0;
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_IPADDRESS),
                &LocalIpAddress,
                &LocalLength);

    DhcpAssert( 0 == LocalLength % sizeof(DHCP_IP_ADDRESS) );

    if (LocalLength == ClientIpAddressLength &&
        (RtlCompareMemory(
                (LPBYTE) LocalIpAddress ,
                (LPBYTE) ClientIpAddress ,
                LocalLength) == LocalLength ))
    {
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    Error = ERROR_GEN_FAILURE ;
Cleanup:

    if( LocalIpAddress != NULL ) {
        MIDL_user_free( LocalIpAddress );
    }

    return( Error );

}

DWORD
MadcapRemoveClientEntryByIpAddress(
    DHCP_IP_ADDRESS ClientIpAddress,
    BOOL ReleaseAddress
    )
/*++

Routine Description:

    This routine removes a client entry in the madcap database
    and releases the IP address..

Arguments:

    ClientIpAddress -- Ip address of client to remove database entry..

Return Values:

    Jet errors

--*/
{
    JET_ERR JetError;
    DWORD Error;
    BOOL TransactBegin = FALSE;
    BYTE State;
    DWORD Size;
    BOOL  Reserved = FALSE;
    DB_CTX  DbCtx;
    DWORD MScopeId;

    // lock both registry and database locks here to avoid dead lock.
    LOCK_DATABASE();

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    // start transaction before a create/update database record.
    Error = MadcapJetBeginTransaction(&DbCtx);
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    TransactBegin = TRUE;

    Error = MadcapJetOpenKey(
        &DbCtx,
        MCAST_COL_NAME(MCAST_TBL_IPADDRESS),
        &ClientIpAddress,
        sizeof( DHCP_IP_ADDRESS )
        );

    if( Error != ERROR_SUCCESS ) goto Cleanup;

    Size = sizeof(MScopeId);
    Error = MadcapJetGetValue(
        &DbCtx,
        MCAST_COL_HANDLE(MCAST_TBL_SCOPE_ID),
        &MScopeId,
        &Size);
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    JetError = JetDelete(
        DhcpGlobalJetServerSession,
        MadcapGlobalClientTableHandle );
    Error = DhcpMapJetError( JetError, "M:Remove:Delete" );

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_ERRORS, "Could not delete client entry: %ld\n", JetError));
        goto Cleanup;
    }

    // Finally, mark the IP address available in bitmap.
    if( ReleaseAddress == TRUE ) {
        PM_SUBNET   pMScope;
        DWORD       Error2;
        Error2 = DhcpMScopeReleaseAddress( MScopeId, ClientIpAddress);
        if (ERROR_SUCCESS != Error2) {
            // MBUG: log an event.
            DhcpPrint((DEBUG_ERRORS, "Could not delete mclient %lx from bitmap in scope id %lx, error %ld\n",
                       ClientIpAddress, MScopeId, Error2));
            goto Cleanup;
        }
    }

Cleanup:

    if ( (Error != ERROR_SUCCESS) &&
            (Error != ERROR_DHCP_RESERVED_CLIENT) ) {
        // if the transaction has been started, than roll back to the
        // start point, so that we will not leave the database
        // inconsistence.
        if( TransactBegin == TRUE ) {
            DWORD LocalError;
            LocalError = MadcapJetRollBack(&DbCtx);
            DhcpAssert( LocalError == ERROR_SUCCESS );
        }
        DhcpPrint(( DEBUG_ERRORS, "Can't remove client entry from the "
                    "database, %ld.\n", Error));
    }
    else {
        // commit the transaction before we return.
        DWORD LocalError;
        DhcpAssert( TransactBegin == TRUE );
        LocalError = MadcapJetCommitTransaction(&DbCtx);
        DhcpAssert( LocalError == ERROR_SUCCESS );
    }
    UNLOCK_DATABASE();
    return( Error );

}


DWORD
MadcapRemoveClientEntryByClientId(
    LPBYTE ClientId,
    DWORD ClientIdLength,
    BOOL ReleaseAddress
    )
/*++

Routine Description:

    This function removes a client entry from the client database.

Arguments:

    ClientIpAddress - The IP address of the client.

    HardwareAddress - client's hardware address.

    HardwareAddressLength - client's hardware address length.

    ReleaseAddress - if this flag is TRUE, release the address bit from
        registry, otherwise don't.

    DeletePendingRecord - if this flag is TRUE, the record is deleted
        only if the state of the record is ADDRESS_STATE_OFFERED.

Return Value:

    The status of the operation.

--*/
{
    JET_ERR JetError;
    DWORD Error;
    BOOL TransactBegin = FALSE;
    BYTE State;
    DWORD Size;
    BOOL  Reserved = FALSE;
    DB_CTX  DbCtx;
    DWORD MScopeId;
    DHCP_IP_ADDRESS ClientIpAddress;


    // lock both registry and database locks here to avoid dead lock.
    LOCK_DATABASE();

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    // start transaction before a create/update database record.
    Error = MadcapJetBeginTransaction(&DbCtx);
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    TransactBegin = TRUE;

    Error = MadcapJetOpenKey(
                    &DbCtx,
                    MCAST_COL_NAME(MCAST_TBL_CLIENT_ID),
                    ClientId,
                    ClientIdLength
                    );

    if( Error != ERROR_SUCCESS ) goto Cleanup;

    Size = sizeof(ClientIpAddress);
    Error = MadcapJetGetValue(
        &DbCtx,
        MCAST_COL_HANDLE(MCAST_TBL_IPADDRESS),
        &ClientIpAddress,
        &Size);
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    Size = sizeof(MScopeId);
    Error = MadcapJetGetValue(
        &DbCtx,
        MCAST_COL_HANDLE(MCAST_TBL_SCOPE_ID),
        &MScopeId,
        &Size);
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    JetError = JetDelete(
        DhcpGlobalJetServerSession,
        MadcapGlobalClientTableHandle );
    Error = DhcpMapJetError( JetError, "M:Remove:Delete" );

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_ERRORS, "Could not delete client entry: %ld\n", JetError));
        goto Cleanup;
    }

    // Finally, mark the IP address available in bitmap.
    if( ReleaseAddress == TRUE ) {
        PM_SUBNET   pMScope;
        DWORD       Error2;
        Error2 = DhcpMScopeReleaseAddress( MScopeId, ClientIpAddress);
        if (ERROR_SUCCESS != Error2) {
            // MBUG: log an event.
            DhcpPrint((DEBUG_ERRORS, "Could not delete mclient %lx from bitmap in scope id %lx, error %ld\n",
                       ClientIpAddress, MScopeId, Error2));
            goto Cleanup;
        }
    }

Cleanup:

    if ( (Error != ERROR_SUCCESS) &&
            (Error != ERROR_DHCP_RESERVED_CLIENT) ) {
        // if the transaction has been started, than roll back to the
        // start point, so that we will not leave the database
        // inconsistence.
        if( TransactBegin == TRUE ) {
            DWORD LocalError;
            LocalError = MadcapJetRollBack(&DbCtx);
            DhcpAssert( LocalError == ERROR_SUCCESS );
        }
        DhcpPrint(( DEBUG_ERRORS, "Can't remove client entry from the "
                    "database, %ld.\n", Error));
    }
    else {
        // commit the transaction before we return.
        DWORD LocalError;
        DhcpAssert( TransactBegin == TRUE );
        LocalError = MadcapJetCommitTransaction(&DbCtx);
        DhcpAssert( LocalError == ERROR_SUCCESS );
    }
    UNLOCK_DATABASE();
    return( Error );
}

MadcapGetCurrentClientInfo(
    LPDHCP_MCLIENT_INFO *ClientInfo,
    LPDWORD InfoSize, // optional parameter.
    LPBOOL ValidClient, // optional parameter.
    DWORD  MScopeId
    )
/*++

Routine Description:

    This function retrieves current client information information. It
    allocates MIDL memory for the client structure (and for variable
    length structure fields). The caller is responsible to lock the
    database when this function is called.

Arguments:

    ClientInfo - pointer to a location where the client info structure
                    pointer is returned.

    InfoSize - pointer to a DWORD location where the number of bytes
                    consumed in the ClientInfo is returned.

    ValidClient - when this parameter is specified this
        function packs the current record only if the client

            1. belongs to the specified subnet.
            2. address state is ADDRESS_STATE_ACTIVE.

    SubnetAddress - the subnet address to filter client.

Return Value:

    Jet Errors.

--*/
{
    DWORD Error;
    LPDHCP_MCLIENT_INFO LocalClientInfo = NULL;
    DWORD LocalInfoSize = 0;
    DWORD Size;
    DHCP_IP_ADDRESS IpAddress;
    DHCP_IP_ADDRESS ClientSubnetAddress;
    DHCP_IP_ADDRESS realSubnetMask;
    BYTE AddressState;
    DWORD LocalMScopeId, AddressFlags;
    DB_CTX  DbCtx;

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    DhcpAssert( *ClientInfo == NULL );

    //
    // allocate return Buffer.
    //

    LocalClientInfo = MIDL_user_allocate( sizeof(DHCP_MCLIENT_INFO) );
    if( LocalClientInfo == NULL ) return ERROR_NOT_ENOUGH_MEMORY;

    LocalInfoSize = sizeof(DHCP_MCLIENT_INFO);
    //
    // read IpAddress and SubnetMask to filter unwanted clients.
    //

    Size = sizeof(IpAddress);
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_IPADDRESS),
                &IpAddress,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(IpAddress) );
    LocalClientInfo->ClientIpAddress = IpAddress;

    Size = sizeof(LocalMScopeId);
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_SCOPE_ID),
                &LocalMScopeId,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(LocalMScopeId) );
    LocalClientInfo->MScopeId = LocalMScopeId;

    // filter client if we are asked to do so.
    if( ValidClient != NULL ) {

        // don't filter client if the scopeid is 0
        if( (MScopeId != 0) &&
                (MScopeId != LocalMScopeId )) {
            *ValidClient = FALSE;
            Error = ERROR_SUCCESS;
            goto Cleanup;
        }

        *ValidClient = TRUE;
    }

    Size = sizeof(AddressFlags);
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_FLAGS),
                &AddressFlags,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(AddressFlags) );
    LocalClientInfo->AddressFlags = AddressFlags;

    Size = sizeof(AddressState);
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_STATE),
                &AddressState,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(AddressState) );
    LocalClientInfo->AddressState = AddressState;

    //
    // read additional client info from database.
    //

    LocalClientInfo->ClientId.DataLength = 0;
        // let DhcpJetGetValue allocates name buffer.
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_CLIENT_ID),
                &LocalClientInfo->ClientId.Data,
                &LocalClientInfo->ClientId.DataLength );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    LocalInfoSize += LocalClientInfo->ClientId.DataLength;

    Size = 0; // let DhcpJetGetValue allocates name buffer.
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_CLIENT_INFO),
                &LocalClientInfo->ClientName,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if( LocalClientInfo->ClientName != NULL ) {
        DhcpAssert( (wcslen(LocalClientInfo->ClientName) + 1) *
                        sizeof(WCHAR) == Size );
    }
    else {
        DhcpAssert( Size == 0 );
    }

    LocalInfoSize += Size;

    Size = sizeof( LocalClientInfo->ClientLeaseStarts );
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_LEASE_START),
                &LocalClientInfo->ClientLeaseStarts,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(LocalClientInfo->ClientLeaseStarts ) );

    Size = sizeof( LocalClientInfo->ClientLeaseEnds );
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_LEASE_END),
                &LocalClientInfo->ClientLeaseEnds,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(LocalClientInfo->ClientLeaseEnds ) );

    RtlZeroMemory(
        &LocalClientInfo->OwnerHost, sizeof(LocalClientInfo->OwnerHost)
        );

    Size = sizeof( LocalClientInfo->OwnerHost.IpAddress );
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_SERVER_IP_ADDRESS),
                &LocalClientInfo->OwnerHost.IpAddress,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpAssert( Size == sizeof(LocalClientInfo->OwnerHost.IpAddress) );


    Size = 0;
    Error = MadcapJetGetValue(
                &DbCtx,
                MCAST_COL_HANDLE(MCAST_TBL_SERVER_NAME),
                &LocalClientInfo->OwnerHost.NetBiosName,
                &Size );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }


    if ( LocalClientInfo->OwnerHost.NetBiosName != NULL ) {
        DhcpAssert( Size ==
            (wcslen(LocalClientInfo->OwnerHost.NetBiosName) + 1) *
                sizeof(WCHAR) );

    }
    else {
        DhcpAssert( Size == 0 );
    }
    LocalInfoSize += Size;

    *ClientInfo = LocalClientInfo;

Cleanup:

    if( Error != ERROR_SUCCESS ) {
        // if we aren't successful, return alloted memory.
        if( LocalClientInfo != NULL ) {
            _fgs__DHCP_MCLIENT_INFO ( LocalClientInfo );
        }
        LocalInfoSize = 0;
    }

    if( InfoSize != NULL ) {
        *InfoSize =  LocalInfoSize;
    }

    return( Error );
}

DWORD
MadcapRetractOffer(                                      // remove pending list and database entries
    IN      PDHCP_REQUEST_CONTEXT    RequestContext,
    IN      LPMADCAP_SERVER_OPTIONS  MadcapOptions,
    IN      LPBYTE                   ClientId,
    IN      DWORD                    ClientIdLength
)
{
    DWORD                          Error;
    DHCP_IP_ADDRESS                desiredIpAddress = 0;
    LPDHCP_PENDING_CTXT            PendingCtxt;


    DhcpPrint((DEBUG_MSTOC, "Retracting offer (clnt accepted from %s)\n",
               DhcpIpAddressToDottedString(MadcapOptions->Server?*(MadcapOptions->Server):-1)));

    // Remove the pending entry and delete the record from the
    // database.

    LOCK_INPROGRESS_LIST();
    Error = DhcpFindPendingCtxt(
        ClientId,
        ClientIdLength,
        0,
        &PendingCtxt
    );
    if( ERROR_SUCCESS == Error ) {
        desiredIpAddress = PendingCtxt->Address;
        Error = DhcpRemovePendingCtxt(PendingCtxt);
        DhcpAssert(ERROR_SUCCESS == Error);
        Error = MadcapDeletePendingCtxt(PendingCtxt);
        DhcpAssert(ERROR_SUCCESS == Error);
    }
    UNLOCK_INPROGRESS_LIST();

    LOCK_DATABASE();
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_MISC, "Retract offer: client has no records\n" ));
        UNLOCK_DATABASE();
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    } else {
        DhcpPrint((DEBUG_MISC, "Deleting pending client entry, %s.\n",
                   DhcpIpAddressToDottedString(desiredIpAddress)
        ));
    }

    Error = MadcapRemoveClientEntryByClientId(
        ClientId,
        ClientIdLength,
        TRUE                                          // release address from bit map.
    );
    UNLOCK_DATABASE();

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS, "[RetractOffer] RemoveClientEntry(%s): %ld [0x%lx]\n",
                    DhcpIpAddressToDottedString(desiredIpAddress), Error, Error ));
    }

    return ERROR_DHCP_INVALID_DHCP_CLIENT;
}


DWORD
GetMCastDatabaseList(
    DWORD   ScopeId,
    LPDHCP_IP_ADDRESS *DatabaseList,
    DWORD *DatabaseListCount
    )
/*++

Routine Description:

    Read ipaddresses of the database entries that belong to the given
    subnet.

Arguments:

    SubnetAddress : Address of the subnet scope to verify.

    DatabaseList : pointer to list of ip address. caller should free up
        the memory after use.

    DatabaseListCount : count of ip addresses in the above list.

Return Value:

    WINDOWS errors.
--*/
{

    DWORD Error;
    JET_ERR JetError;
    JET_RECPOS JetRecordPosition;
    DWORD TotalExpRecCount = 1;
    DWORD RecordCount = 0;
    LPDHCP_IP_ADDRESS IpList = NULL;
    DWORD i;
    DB_CTX  DbCtx;
    DWORD   LocalScopeId;


    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    // move the database pointer to the begining.
    Error = MadcapJetPrepareSearch(
                &DbCtx,
                MCAST_COL_NAME( MCAST_TBL_IPADDRESS),
                TRUE,   // Search from start
                NULL,
                0
                );

    if( Error != ERROR_SUCCESS ) {
        if( Error == ERROR_NO_MORE_ITEMS ) {
            *DatabaseList = NULL;
            *DatabaseListCount = 0;

            Error = ERROR_SUCCESS;
        }
        goto Cleanup;
    }

    // determine total number of records in the database.
    // There is no way to determine the total number of records, other
    // than  walk through the db. do it.
    while ( (Error = MadcapJetNextRecord(&DbCtx) ) == ERROR_SUCCESS )  {
         TotalExpRecCount++;
    }

    if ( Error != ERROR_NO_MORE_ITEMS ) {
        goto Cleanup;
    }

    // move back the database pointer to the begining.
    Error = MadcapJetPrepareSearch(
                &DbCtx,
                MCAST_COL_NAME( MCAST_TBL_IPADDRESS),
                TRUE,   // Search from start
                NULL,
                0
                );


    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    // allocate memory for return list.
    IpList = DhcpAllocateMemory( sizeof(DHCP_IP_ADDRESS) * TotalExpRecCount );

    if( IpList == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    // read database entries.
    for( i = 0; i < TotalExpRecCount; i++ ) {

        DHCP_IP_ADDRESS IpAddress;
        DHCP_IP_ADDRESS realSubnetMask;
        DWORD Size;

        // read ip address of the current record.
        Size = sizeof(IpAddress);
        Error = MadcapJetGetValue(
                    &DbCtx,
                    MCAST_COL_HANDLE( MCAST_TBL_IPADDRESS ),
                    &IpAddress,
                    &Size );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
        DhcpAssert( Size == sizeof(IpAddress) );
        Size = sizeof(LocalScopeId);
        Error = MadcapJetGetValue(
                    &DbCtx,
                    MCAST_COL_HANDLE( MCAST_TBL_SCOPE_ID),
                    &LocalScopeId,
                    &Size );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
        DhcpAssert( Size == sizeof(LocalScopeId) );
        if( LocalScopeId == ScopeId ) {
            // append this address to list.
            IpList[RecordCount++] = IpAddress;
        }

        // move to next record.
        Error = MadcapJetNextRecord(&DbCtx);
        if( Error != ERROR_SUCCESS ) {
            if( Error == ERROR_NO_MORE_ITEMS ) {
                Error = ERROR_SUCCESS;
                break;
            }
            goto Cleanup;
        }
    }

#if DBG
    // we should be pointing to end of database.
    Error = MadcapJetNextRecord(&DbCtx);
    DhcpAssert( Error == ERROR_NO_MORE_ITEMS );
    Error = ERROR_SUCCESS;
#endif // DBG

    *DatabaseList = IpList;
    IpList = NULL;
    *DatabaseListCount = RecordCount;

Cleanup:

    if( IpList != NULL ) {
        DhcpFreeMemory( IpList );
    }

    return( Error );
}

DWORD
DhcpDeleteMScopeClients(
    DWORD MScopeId
    )
/*++

Routine Description:

    This functions cleans up all clients records of the specified MScope
    from the database.

Arguments:

    MScopeId : MScopeId whose clients should be cleaned off.

Return Value:

    Database error code or ERROR_SUCCESS.

--*/
{
    DWORD Error;
    DWORD ReturnError = ERROR_SUCCESS;
    DB_CTX  DbCtx;

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    LOCK_DATABASE();
    Error = MadcapJetPrepareSearch(
                &DbCtx,
                MCAST_COL_NAME( MCAST_TBL_IPADDRESS ),
                TRUE,   // Search from start
                NULL,
                0 );

    if( Error != ERROR_SUCCESS ) goto Cleanup;

    // Walk through the entire database looking looking for the
    // specified subnet clients.
    for ( ;; ) {

        DWORD Size;
        DHCP_IP_ADDRESS IpAddress;
        DWORD       LocalMScopeId;

        // read IpAddress and MScopeId
        Size = sizeof(IpAddress);
        Error = MadcapJetGetValue(
                    &DbCtx,
                    MCAST_COL_HANDLE( MCAST_TBL_IPADDRESS ),
                    &IpAddress,
                    &Size );

        if( Error != ERROR_SUCCESS ) goto Cleanup;
        DhcpAssert( Size == sizeof(IpAddress) );

        Size = sizeof(LocalMScopeId);
        Error = MadcapJetGetValue(
                    &DbCtx,
                    MCAST_COL_HANDLE( MCAST_TBL_SCOPE_ID ),
                    &LocalMScopeId,
                    &Size );

        if( Error != ERROR_SUCCESS ) goto Cleanup;
        DhcpAssert( Size == sizeof(LocalMScopeId) );

        if( MScopeId == LocalMScopeId ) {
            // found a specified subnet client record , delete it.
            Error = MadcapJetBeginTransaction(&DbCtx);
            if( Error != ERROR_SUCCESS ) goto Cleanup;

            Error = MadcapJetDeleteCurrentRecord(&DbCtx);

            if( Error != ERROR_SUCCESS ) {
                DhcpPrint(( DEBUG_ERRORS,"Cleanup current database record failed, %ld.\n",Error ));
                ReturnError = Error;
                Error = MadcapJetRollBack(&DbCtx);
                if( Error != ERROR_SUCCESS ) goto Cleanup;
            } else {
                Error = MadcapJetCommitTransaction(&DbCtx);
                if( Error != ERROR_SUCCESS ) goto Cleanup;
            }
        }

        // move to next record.
        Error = MadcapJetNextRecord(&DbCtx);
        if( Error != ERROR_SUCCESS ) {
            if( Error == ERROR_NO_MORE_ITEMS ) {
                Error = ERROR_SUCCESS;
                break;
            }
            goto Cleanup;
        }
    }

Cleanup:
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS, "DhcpDeleteSubnetClients failed, %ld.\n", Error ));
    }
    else  {
        DhcpPrint(( DEBUG_APIS, "DhcpDeleteSubnetClients finished successfully.\n" ));
    }
    UNLOCK_DATABASE();
    return(Error);
}

DWORD
ChangeMScopeIdInDb(
    DWORD   OldMScopeId,
    DWORD   NewMScopeId
    )
/*++

Routine Description:

    This functions changes up all clients records of the specified MScope
    to new scope id.

Arguments:

    OldMScopeId : MScopeId whose clients should be changed.

    NewMScopeId : The value of new scope id.

Return Value:

    Database error code or ERROR_SUCCESS.

--*/
{
    DWORD Error;
    DWORD ReturnError = ERROR_SUCCESS;
    DB_CTX  DbCtx;

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    LOCK_DATABASE();
    Error = MadcapJetPrepareSearch(
                &DbCtx,
                MCAST_COL_NAME( MCAST_TBL_IPADDRESS ),
                TRUE,   // Search from start
                NULL,
                0 );

    if( Error != ERROR_SUCCESS ) goto Cleanup;

    // Walk through the entire database looking looking for the
    // specified subnet clients.
    for ( ;; ) {

        DWORD Size;
        DHCP_IP_ADDRESS IpAddress;
        DWORD       LocalMScopeId;

        Size = sizeof(LocalMScopeId);
        Error = MadcapJetGetValue(
                    &DbCtx,
                    MCAST_COL_HANDLE( MCAST_TBL_SCOPE_ID ),
                    &LocalMScopeId,
                    &Size );

        if( Error != ERROR_SUCCESS ) goto Cleanup;
        DhcpAssert( Size == sizeof(LocalMScopeId) );

        if( OldMScopeId == LocalMScopeId ) {
            // found a specified subnet client record , delete it.
            Error = MadcapJetBeginTransaction(&DbCtx);
            if( Error != ERROR_SUCCESS ) goto Cleanup;

            Error = MadcapJetSetValue(
                        &DbCtx,
                        MCAST_COL_HANDLE(MCAST_TBL_SCOPE_ID),
                        &NewMScopeId,
                        sizeof(NewMScopeId));

            if( Error != ERROR_SUCCESS ) {
                DhcpPrint(( DEBUG_ERRORS,"Change of MScopeId on current database record failed, %ld.\n",Error ));
                ReturnError = Error;
                Error = MadcapJetRollBack(&DbCtx);
                if( Error != ERROR_SUCCESS ) goto Cleanup;
            } else {
                Error = MadcapJetCommitTransaction(&DbCtx);
                if( Error != ERROR_SUCCESS ) goto Cleanup;
            }
        }

        // move to next record.
        Error = MadcapJetNextRecord(&DbCtx);
        if( Error != ERROR_SUCCESS ) {
            if( Error == ERROR_NO_MORE_ITEMS ) {
                Error = ERROR_SUCCESS;
                break;
            }
            goto Cleanup;
        }
    }

Cleanup:
    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS, "ChangeMScopeIdInDb failed, %ld.\n", Error ));
    }
    else  {
        DhcpPrint(( DEBUG_APIS, "ChangeMScopeIdInDb finished successfully.\n" ));
    }
    UNLOCK_DATABASE();
    return(Error);
}

VOID
DeleteExpiredMcastScopes(
    IN      DATE_TIME*             TimeNow
    )
{
    PM_SERVER                       pServer;
    PM_SUBNET                       pScope;
    ARRAY_LOCATION                  Loc;
    DWORD                           Error;

    DhcpAcquireWriteLock();
    pServer = DhcpGetCurrentServer();

    Error = MemArrayInitLoc(&(pServer->MScopes), &Loc);
    if ( ERROR_FILE_NOT_FOUND == Error ) {
        DhcpReleaseWriteLock();
        return;
    }

    while ( ERROR_FILE_NOT_FOUND != Error ) {
        Error = MemArrayGetElement(
            &(pServer->MScopes), &Loc, (LPVOID *)&pScope
            );
        DhcpAssert(ERROR_SUCCESS == Error);
        if (CompareFileTime(
            (FILETIME *)&pScope->ExpiryTime, (FILETIME *)TimeNow
            ) < 0 ) {
            //
            // DELETE SCOPE HERE.
            //
            DhcpPrint(
                ( DEBUG_SCAVENGER,
                  "DeleteExpiredMcastScopes :deleting expired mscope %ws\n",
                  pScope->Name));

            DhcpDeleteMScope(pScope->Name, DhcpFullForce);
        }
        
        Error = MemArrayNextLoc(&(pServer->MScopes), &Loc);
    }
    
    DhcpReleaseWriteLock();
    return;
}

DWORD
CleanupMCastDatabase(
    IN      DATE_TIME*             TimeNow,            // current time standard
    IN      DATE_TIME*             DoomTime,           // Time when the records become 'doom'
    IN      BOOL                   DeleteExpiredLeases,// expired leases be deleted right away? or just set state="doomed"
    OUT     ULONG*                 nExpired,
    OUT     ULONG*                 nDeleted
)
{
    JET_ERR                        JetError;
    DWORD                          Error;
    FILETIME                       leaseExpires;
    DWORD                          dataSize;
    DHCP_IP_ADDRESS                ipAddress;
    DHCP_IP_ADDRESS                NextIpAddress;
    BYTE                           AddressState;
    BOOL                           DatabaseLocked = FALSE;
    BOOL                           RegistryLocked = FALSE;
    DWORD                          i;
    BYTE                            bAllowedClientTypes;
    DB_CTX                          DbCtx;
    DWORD                           MScopeId;
    DWORD                          ReturnError = ERROR_SUCCESS;


    DhcpPrint(( DEBUG_MISC, "Cleaning up Multicast database table.\n"));

    (*nExpired) = (*nDeleted) = 0;

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);
    // Get the first user record's IpAddress.
    LOCK_DATABASE();
    DatabaseLocked = TRUE;
    Error = MadcapJetPrepareSearch(
        &DbCtx,
        MCAST_COL_NAME( MCAST_TBL_IPADDRESS ),
        TRUE,   // Search from start
        NULL,
        0
    );
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    dataSize = sizeof( NextIpAddress );
    Error = MadcapJetGetValue(
        &DbCtx,
        MCAST_COL_HANDLE( MCAST_TBL_IPADDRESS ),
        &NextIpAddress,
        &dataSize
    );
    if( Error != ERROR_SUCCESS ) goto Cleanup;
    DhcpAssert( dataSize == sizeof( NextIpAddress )) ;

    UNLOCK_DATABASE();
    DatabaseLocked = FALSE;

    // Walk through the entire database looking for expired leases to
    // free up.
    for ( ;; ) {

        // return to caller when the service is shutting down.
        if( (WaitForSingleObject( DhcpGlobalProcessTerminationEvent, 0 ) == 0) ) {
            Error = ERROR_SUCCESS;
            goto Cleanup;
        }

        // lock both registry and database locks here to avoid dead lock.

        if( FALSE == DatabaseLocked ) {
            LOCK_DATABASE();
            DatabaseLocked = TRUE;
        }

        // Seek to the next record.
        JetError = JetSetCurrentIndex(
            DhcpGlobalJetServerSession,
            MadcapGlobalClientTableHandle,
            MCAST_COL_NAME(MCAST_TBL_IPADDRESS)
        );

        Error = DhcpMapJetError( JetError, "M:Cleanup:SetcurrentIndex" );
        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        JetError = JetMakeKey(
            DhcpGlobalJetServerSession,
            MadcapGlobalClientTableHandle,
            &NextIpAddress,
            sizeof( NextIpAddress ),
            JET_bitNewKey
        );

        Error = DhcpMapJetError( JetError, "M:Cleanup:MakeKey" );
        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        // Seek to the next record or greater to process. When we
        // processed last record we noted down the next record to
        // process, however the next record may have been deleted when
        // we unlocked the database lock. So moving to the next or
        // greater record will make us to move forward.

        JetError = JetSeek(
            DhcpGlobalJetServerSession,
            MadcapGlobalClientTableHandle,
            JET_bitSeekGE
        );

        // #if0 when JET_errNoCurrentRecord removed (see scavengr.c@v25);
        // that code tried to go back to start of file when scanned everything.

        Error = DhcpMapJetError( JetError, "M:Cleanup:Seek" );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        // read the IP address of current record.
        dataSize = sizeof( ipAddress );
        Error = MadcapJetGetValue(
            &DbCtx,
            MCAST_COL_HANDLE(MCAST_TBL_IPADDRESS),
            &ipAddress,
            &dataSize
        );
        if( Error != ERROR_SUCCESS ) {
            goto ContinueError;
        }
        DhcpAssert( dataSize == sizeof( ipAddress )) ;

        // read the MScopeId of current record.
        dataSize = sizeof( MScopeId );
        Error = MadcapJetGetValue(
            &DbCtx,
            MCAST_COL_HANDLE(MCAST_TBL_SCOPE_ID),
            &MScopeId,
            &dataSize
        );
        if( Error != ERROR_SUCCESS ) {
            goto ContinueError;
        }
        DhcpAssert( dataSize == sizeof( MScopeId )) ;

        //
        // if this is reserved entry don't delete.
        //

        if( DhcpMScopeIsAddressReserved(MScopeId, ipAddress) ) {
            Error = ERROR_SUCCESS;
            goto ContinueError;
        }

        dataSize = sizeof( leaseExpires );
        Error = MadcapJetGetValue(
            &DbCtx,
            MCAST_COL_HANDLE( MCAST_TBL_LEASE_END),
            &leaseExpires,
            &dataSize
        );

        if( Error != ERROR_SUCCESS ) {
            goto ContinueError;
        }

        DhcpAssert(dataSize == sizeof( leaseExpires ) );


        // if the LeaseExpired value is not zero and the lease has
        // expired then delete the entry.

        if( CompareFileTime( &leaseExpires, (FILETIME *)TimeNow ) < 0 ) {
            // This lease has expired.  Clear the record.
            // Delete this lease if
            //  1. we are asked to delete all expired leases. or
            //  2. the record passed doom time.
            //

            if( DeleteExpiredLeases ||
                    CompareFileTime(
                        &leaseExpires, (FILETIME *)DoomTime ) < 0 ) {

                DhcpPrint(( DEBUG_SCAVENGER, "Deleting Client Record %s.\n",
                    DhcpIpAddressToDottedString(ipAddress) ));

                Error = DhcpMScopeReleaseAddress( MScopeId, ipAddress );

                if( Error != ERROR_SUCCESS ) {
                    //
                    // This is not a big error and should not stop scavenge.
                    //
                    Error = ERROR_SUCCESS;
                    goto ContinueError;
                }

                Error = MadcapJetBeginTransaction(&DbCtx);

                if( Error != ERROR_SUCCESS ) {
                    goto Cleanup;
                }

                Error = MadcapJetDeleteCurrentRecord(&DbCtx);

                if( Error != ERROR_SUCCESS ) {
                    Error = MadcapJetRollBack(&DbCtx);
                    if( Error != ERROR_SUCCESS ) {
                        goto Cleanup;
                    }
                    goto ContinueError;
                }

                Error = MadcapJetCommitTransaction(&DbCtx);

                if( Error != ERROR_SUCCESS ) {
                    goto Cleanup;
                }
                (*nDeleted) ++;
            }
            else {

                //
                // read address State.
                //

                dataSize = sizeof( AddressState );
                Error = MadcapJetGetValue(
                            &DbCtx,
                            MCAST_COL_HANDLE( MCAST_TBL_STATE ),
                            &AddressState,
                            &dataSize );

                if( Error != ERROR_SUCCESS ) {
                    goto ContinueError;
                }

                DhcpAssert( dataSize == sizeof( AddressState )) ;

                if( ! IS_ADDRESS_STATE_DOOMED(AddressState) ) {
                    JET_ERR JetError;

                    //
                    // set state to DOOM.
                    //

                    Error = MadcapJetBeginTransaction(&DbCtx);

                    if( Error != ERROR_SUCCESS ) {
                        goto Cleanup;
                    }

                    JetError = JetPrepareUpdate(
                                    DhcpGlobalJetServerSession,
                                    MadcapGlobalClientTableHandle,
                                    JET_prepReplace );

                    Error = DhcpMapJetError( JetError, "M:Cleanup:PrepUpdate" );

                    if( Error == ERROR_SUCCESS ) {

                        SetAddressStateDoomed(AddressState);
                        Error = MadcapJetSetValue(
                                    &DbCtx,
                                    MCAST_COL_HANDLE(MCAST_TBL_STATE),
                                    &AddressState,
                                    sizeof(AddressState) );

                        if( Error == ERROR_SUCCESS ) {
                            Error = MadcapJetCommitUpdate(&DbCtx);
                        }
                    }

                    if( Error != ERROR_SUCCESS ) {

                        Error = MadcapJetRollBack(&DbCtx);
                        if( Error != ERROR_SUCCESS ) {
                            goto Cleanup;
                        }

                        goto ContinueError;
                    }

                    Error = MadcapJetCommitTransaction(&DbCtx);

                    if( Error != ERROR_SUCCESS ) {
                        goto Cleanup;
                    }

                    (*nExpired) ++;
                }
            }
        }

ContinueError:

        if( Error != ERROR_SUCCESS ) {

            DhcpPrint(( DEBUG_ERRORS,
                "Cleanup current database record failed, %ld.\n",
                    Error ));

            ReturnError = Error;
        }

        Error = MadcapJetNextRecord(&DbCtx);

        if( Error == ERROR_NO_MORE_ITEMS ) {
            Error = ERROR_SUCCESS;
            break;
        }

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // get next record Ip Address.
        //

        dataSize = sizeof( NextIpAddress );
        Error = MadcapJetGetValue(
                    &DbCtx,
                    MCAST_COL_HANDLE(MCAST_TBL_IPADDRESS),
                    &NextIpAddress,
                    &dataSize );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        DhcpAssert( dataSize == sizeof( NextIpAddress )) ;

        //
        // unlock the registry and database locks after each user record
        // processed, so that other threads will get chance to look into
        // the registry and/or database.
        //
        // Since we have noted down the next user record to process,
        // when we resume to process again we know where to start.
        //

        if( TRUE == DatabaseLocked ) {
            UNLOCK_DATABASE();
            DatabaseLocked = FALSE;
        }
    }

    DhcpAssert( Error == ERROR_SUCCESS );

Cleanup:

    if( DatabaseLocked ) {
        UNLOCK_DATABASE();
    }

    return ReturnError;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\mdhcpdb.c ===
/*++

  Copyright (c) 1994  Microsoft Corporation

  Module Name:

  mdhcpdb.c

  Abstract:

  This module contains the functions for interfacing with the JET
  database API pertaining to MDHCP.

  Author:

  Munil Shah

  Environment:

  User Mode - Win32

  Revision History:

  --*/

#include "dhcppch.h"
#include "mdhcpsrv.h"





//
//  Structure of the MDHCP table is as follows.
//
//
//      Columns :
//
//          Name                Type
//
//      1. IpAddress            JET_coltypLongBinary - List of ipaddresses.
//      2. ClientId             JET_coltypBinary - Binary data, < 255 bytes.
//      3. ClientInfo           JET_coltypBinary - Textual info of the client.
//      4. State                JET_coltypUnsignedByte - 1-byte integer, unsigned.
//      5. Flags                JET_coltypLong - 4 byte integer, signed.
//      6. ScopeId              JET_coltypBinary - Binary data, < 255 bytes.
//      7. LeaseStart           JET_coltypCurrency - 8-byte integer, signed
//      8. LeaseEnd             JET_coltypCurrency - 8-byte integer, signed
//      9. ServerIpAddress      JET_coltypBinary - Max 16-byte
//      10. ServerName           JET_coltypBinary - Binary data, < 255 bytes
//

//
// global data structure.
// ColName and ColType are constant, so they are initialized here.
// ColType is initialized when the database is created or reopened.
//


STATIC TABLE_INFO MCastClientTable[] = {
    { MCAST_TBL_IPADDRESS_STR        , 0, JET_coltypLongBinary },
    { MCAST_TBL_CLIENT_ID_STR        , 0, JET_coltypBinary },
    { MCAST_TBL_CLIENT_INFO_STR      , 0, JET_coltypLongBinary },
    { MCAST_TBL_STATE_STR            , 0, JET_coltypUnsignedByte },
    { MCAST_TBL_FLAGS_STR            , 0, JET_coltypLong },
    { MCAST_TBL_SCOPE_ID_STR         , 0, JET_coltypBinary },
    { MCAST_TBL_LEASE_START_STR      , 0, JET_coltypCurrency },
    { MCAST_TBL_LEASE_END_STR  ,       0, JET_coltypCurrency },
    { MCAST_TBL_SERVER_IP_ADDRESS_STR, 0, JET_coltypLongBinary },
    { MCAST_TBL_SERVER_NAME_STR,    0, JET_coltypBinary },
};


DWORD
DhcpOpenMCastDbTable(
    JET_SESID   SessId,
    JET_DBID    DbId
)
    /*++

      Routine Description:

      This routine creates/opens MCast client table and initializes it.

      Arguments:

      JetSessID - Session handle

      JetDbID - database handle

      Return Value:

      JET errors.

      --*/
{

    JET_ERR JetError;
    DWORD Error = NO_ERROR;
    JET_COLUMNDEF   ColumnDef;
    CHAR *IndexKey;
    DWORD i;

    //
    // hook the client table pointer.
    //

    MadcapGlobalClientTable = MCastClientTable;

    //
    // Create Table.
    //

    JetError = JetOpenTable(
        SessId,
        DbId,
        MCAST_CLIENT_TABLE_NAME,
        NULL,
        0,
        0,
        &MadcapGlobalClientTableHandle );
    DhcpPrint((DEBUG_MISC, "JetOpenTable - MCast Table\n")); // JET TRACE

    // if table exist, read the table columns.
    if ( JET_errSuccess == JetError) {
        // read columns.
        for ( i = 0; i < MCAST_MAX_COLUMN; i++ ) {
            JetError = JetGetTableColumnInfo(
                SessId,
                MadcapGlobalClientTableHandle,
                MadcapGlobalClientTable[i].ColName,
                &ColumnDef,
                sizeof(ColumnDef),
                0);
            Error = DhcpMapJetError( JetError, "M:GetTableColumnInfo" );
            if( Error != ERROR_SUCCESS ) {
                goto Cleanup;
            }

            MadcapGlobalClientTable[i].ColHandle  = ColumnDef.columnid;
            DhcpPrint((DEBUG_MISC, "JetGetTableColumnInfo, name %s, handle %ld\n",
                       MadcapGlobalClientTable[i].ColName, MadcapGlobalClientTable[i].ColHandle)); // JET TRACE
        }

    // if the table does not exist, create it. O/w bail
    } else if ( JET_errObjectNotFound != JetError ) {
        Error = DhcpMapJetError( JetError, "M:OpenTable" );
        if( Error != ERROR_SUCCESS ) goto Cleanup;
    } else {

        JetError = JetCreateTable(
            SessId,
            DbId,
            MCAST_CLIENT_TABLE_NAME,
            DB_TABLE_SIZE,
            DB_TABLE_DENSITY,
            &MadcapGlobalClientTableHandle );
        DhcpPrint((DEBUG_MISC, "JetCreateTable - MCast Table, %ld\n", JetError)); // JET TRACE

        Error = DhcpMapJetError( JetError, "M:CreateTAble" );
        if( Error != ERROR_SUCCESS ) goto Cleanup;

        // create columns.
        // Init fields of columndef that do not change between addition of
        // columns

        ColumnDef.cbStruct  = sizeof(ColumnDef);
        ColumnDef.columnid  = 0;
        ColumnDef.wCountry  = 1;
        ColumnDef.langid    = DB_LANGID;
        ColumnDef.cp        = DB_CP;
        ColumnDef.wCollate  = 0;
        ColumnDef.cbMax     = 0;
        ColumnDef.grbit     = 0; // variable length binary and text data.

        for ( i = 0; i < MCAST_MAX_COLUMN; i++ ) {

            ColumnDef.coltyp   = MadcapGlobalClientTable[i].ColType;
            JetError = JetAddColumn(
                SessId,
                MadcapGlobalClientTableHandle,
                MadcapGlobalClientTable[i].ColName,
                &ColumnDef,
                NULL, // no optinal value.
                0,
                &MadcapGlobalClientTable[i].ColHandle );

            Error = DhcpMapJetError( JetError, "M:AddColumn" );
            if( Error != ERROR_SUCCESS ) goto Cleanup;

            DhcpPrint((DEBUG_MISC,"JetAddColumn - name %s, handle %ld\n",
                       MadcapGlobalClientTable[i].ColName, MadcapGlobalClientTable[i].ColHandle));

        }
        // finally create index.
        IndexKey =  "+" MCAST_TBL_IPADDRESS_STR "\0";
        JetError = JetCreateIndex(
            SessId,
            MadcapGlobalClientTableHandle,
            MadcapGlobalClientTable[MCAST_TBL_IPADDRESS].ColName,
            JET_bitIndexPrimary,
            // ?? JET_bitIndexClustered will degrade frequent
            // update response time.
            IndexKey,
            strlen(IndexKey) + 2, // for two termination chars
            50
        );

        Error = DhcpMapJetError( JetError, "M:CreateIndex" );
        if( Error != ERROR_SUCCESS ) goto Cleanup;

        IndexKey =  "+" MCAST_TBL_CLIENT_ID_STR "\0";
        JetError = JetCreateIndex(
            SessId,
            MadcapGlobalClientTableHandle,
            MadcapGlobalClientTable[MCAST_TBL_CLIENT_ID].ColName,
            JET_bitIndexUnique,
            IndexKey,
            strlen(IndexKey) + 2, // for two termination chars
            50
        );

        Error = DhcpMapJetError( JetError, "M:CreateIndex" );
        if( Error != ERROR_SUCCESS ) goto Cleanup;

    }



  Cleanup:

    if( Error != ERROR_SUCCESS ) {

        DhcpPrint(( DEBUG_JET, "could not open mcast client table, %ld.\n", Error ));
    }
    else {

        DhcpPrint(( DEBUG_JET, "Succssfully opened mcast client ..\n" ));
    }

    return(Error);
}

DWORD
MadcapJetOpenKey(
    PDB_CTX pDbCtx,
    char *ColumnName,
    PVOID Key,
    DWORD KeySize
)
    /*++

      Routine Description:

      This function opens a key for the named index.

      Arguments:

      ColumnName - The column name of an index column.

      Key - The key to look up.

      KeySize - The size of the specified key, in bytes.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetSetCurrentIndex(
        pDbCtx->SessId,
        pDbCtx->TblId,
        ColumnName );

    Error = DhcpMapJetError( JetError,"M:OpenKey" );
    if( Error != ERROR_SUCCESS ) {
        DhcpMapJetError( JetError, ColumnName);
        return(Error);
    }

    JetError = JetMakeKey(
        pDbCtx->SessId,
        pDbCtx->TblId,
        Key,
        KeySize,
        JET_bitNewKey );

    Error = DhcpMapJetError( JetError, "M:MakeKey" );
    if( Error != ERROR_SUCCESS ) {
        DhcpMapJetError(JetError, ColumnName);
        return(Error);
    }

    JetError = JetSeek( pDbCtx->SessId, pDbCtx->TblId, JET_bitSeekEQ );
    return( DhcpMapJetError( JetError, "M:OpenKey:Seek" ));
}



DWORD
MadcapJetBeginTransaction(
    PDB_CTX pDbCtx
)
    /*++

      Routine Description:

      This functions starts a dhcp database transaction.

      Arguments:

      none.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetBeginTransaction( pDbCtx->SessId );

    Error = DhcpMapJetError( JetError, "M:BeginTransaction" );
    return(Error);
}



DWORD
MadcapJetRollBack(
    PDB_CTX pDbCtx
)
    /*++

      Routine Description:

      This functions rolls back a dhcp database transaction.

      Arguments:

      none.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetRollback(
        pDbCtx->SessId,
        0 ); // Rollback the last transaction.

    Error = DhcpMapJetError( JetError, "M:Rollback" );
    return(Error);
}




DWORD
MadcapJetCommitTransaction(
    PDB_CTX pDbCtx
)
    /*++

      Routine Description:

      This functions commits a dhcp database transaction.

      Arguments:

      none.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    // Change JET_bitCommitFlush to JET_bitCommitLazyFlush as
    // Jet97 does not seem to have JET_bitCommitFlush

    JetError = JetCommitTransaction(
        pDbCtx->SessId,
        JET_bitCommitLazyFlush);

    Error = DhcpMapJetError( JetError, "M:CommitTransaction" );
    return(Error);
}




DWORD
MadcapJetPrepareUpdate(
    PDB_CTX pDbCtx,
    char *ColumnName,
    PVOID Key,
    DWORD KeySize,
    BOOL NewRecord
)
    /*++

      Routine Description:

      This function prepares the database for the creation of a new record,
      or updating an existing record.

      Arguments:

      ColumnName - The column name of an index column.

      Key - The key to update/create.

      KeySize - The size of the specified key, in bytes.

      NewRecord - TRUE to create the key, FALSE to update an existing key.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    if ( !NewRecord ) {
        JetError = JetSetCurrentIndex(
            pDbCtx->SessId,
            pDbCtx->TblId,
            ColumnName );

        Error = DhcpMapJetError( JetError, "M:PrepareUpdate" );
        if( Error != ERROR_SUCCESS ) {
            DhcpMapJetError(JetError, ColumnName);
            return( Error );
        }

        JetError = JetMakeKey(
            pDbCtx->SessId,
            pDbCtx->TblId,
            Key,
            KeySize,
            JET_bitNewKey );

        Error = DhcpMapJetError( JetError, "M:prepareupdate:MakeKey" );
        if( Error != ERROR_SUCCESS ) {
            DhcpMapJetError(JetError, ColumnName);
            return( Error );
        }

        JetError = JetSeek(
            pDbCtx->SessId,
            pDbCtx->TblId,
            JET_bitSeekEQ );

        Error = DhcpMapJetError( JetError, "M:PrepareUpdate:Seek" );
        if( Error != ERROR_SUCCESS ) {
            DhcpMapJetError(JetError, ColumnName);
            return( Error );
        }

    }

    JetError = JetPrepareUpdate(
        pDbCtx->SessId,
        pDbCtx->TblId,
        NewRecord ? JET_prepInsert : JET_prepReplace );

    return( DhcpMapJetError( JetError, "M:PrepareUpdate:PrepareUpdate" ));
}



DWORD
MadcapJetCommitUpdate(
    PDB_CTX pDbCtx
)
    /*++

      Routine Description:

      This function commits an update to the database.  The record specified
      by the last call to DhcpJetPrepareUpdate() is committed.

      Arguments:

      None.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;

    JetError = JetUpdate(
        pDbCtx->SessId,
        pDbCtx->TblId,
        NULL,
        0,
        NULL );

    return( DhcpMapJetError( JetError, "M:CommitUpdate" ));
}



DWORD
MadcapJetSetValue(
    PDB_CTX pDbCtx,
    JET_COLUMNID KeyColumnId,
    PVOID Data,
    DWORD DataSize
)
    /*++

      Routine Description:

      This function updates the value of an entry in the current record.

      Arguments:

      KeyColumnId - The Id of the column (value) to update.

      Data - A pointer to the new value for the column.

      DataSize - The size of the data, in bytes.

      Return Value:

      None.

      --*/
{
    JET_ERR JetError;

    JetError = JetSetColumn(
        pDbCtx->SessId,
        pDbCtx->TblId,
        KeyColumnId,
        Data,
        DataSize,
        0,
        NULL );

    return( DhcpMapJetError( JetError, "M:SetValue" ) );
}



DWORD
MadcapJetGetValue(
    PDB_CTX pDbCtx,
    JET_COLUMNID ColumnId,
    PVOID Data,
    PDWORD DataSize
)
    /*++

      Routine Description:

      This function read the value of an entry in the current record.

      Arguments:

      ColumnId - The Id of the column (value) to read.

      Data - Pointer to a location where the data that is read from the
      database returned,  or pointer to a location where data is.

      DataSize - if the pointed value is non-zero then the Data points to
      a buffer otherwise this function allocates buffer for return data
      and returns buffer pointer in Data.

      Return Value:

      None.

      --*/
{
    JET_ERR JetError;
    DWORD Error;
    DWORD ActualDataSize;
    DWORD NewActualDataSize;
    LPBYTE DataBuffer = NULL;

    if( *DataSize  != 0 ) {

        JetError = JetRetrieveColumn(
            pDbCtx->SessId,
            pDbCtx->TblId,
            ColumnId,
            Data,
            *DataSize,
            DataSize,
            0,
            NULL );

        Error = DhcpMapJetError( JetError, "M:RetrieveColumn1" );
        goto Cleanup;
    }

    //
    // determine the size of data.
    //

    JetError = JetRetrieveColumn(
        pDbCtx->SessId,
        pDbCtx->TblId,
        ColumnId,
        NULL,
        0,
        &ActualDataSize,
        0,
        NULL );

    //
    // JET_wrnBufferTruncated is expected warning.
    //

    if( JetError != JET_wrnBufferTruncated ) {
        Error = DhcpMapJetError( JetError, "M:RetrieveColukmn2" );
        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
    }
    else {
        Error = ERROR_SUCCESS;
    }

    if( ActualDataSize == 0 ) {
        //
        // field is NULL.
        //
        *(LPBYTE *)Data = NULL;
        goto Cleanup;
    }

    DataBuffer = MIDL_user_allocate( ActualDataSize );

    if( DataBuffer == NULL ) {
        *(LPBYTE *)Data = NULL;
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    JetError = JetRetrieveColumn(
        pDbCtx->SessId,
        pDbCtx->TblId,
        ColumnId,
        DataBuffer,
        ActualDataSize,
        &NewActualDataSize,
        0,
        NULL );

    Error = DhcpMapJetError( JetError, "M:RetrieveColumn3" );
    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    DhcpAssert( ActualDataSize == NewActualDataSize );
    *(LPBYTE *)Data = DataBuffer;
    *DataSize = ActualDataSize;

    Error = ERROR_SUCCESS;

  Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // freeup local buffer.
        //

        if( DataBuffer != NULL ) {
            MIDL_user_free( DataBuffer );
        }
    }

    return( Error );
}



DWORD
MadcapJetPrepareSearch(
    PDB_CTX pDbCtx,
    char *ColumnName,
    BOOL SearchFromStart,
    PVOID Key,
    DWORD KeySize
)
    /*++

      Routine Description:

      This function prepares for a search of the client database.

      Arguments:

      ColumnName - The column name to use as the index column.

      SearchFromStart - If TRUE, search from the first record in the
      database.  If FALSE, search from the specified key.

      Key - The key to start the search.

      KeySize - The size, in bytes, of key.

      Return Value:

      None.

      --*/
{
    JET_ERR JetError;
    DWORD Error;

    JetError = JetSetCurrentIndex(
        pDbCtx->SessId,
        pDbCtx->TblId,
        ColumnName );

    Error = DhcpMapJetError( JetError, "M:PrepareSearch:SetcurrentIndex" );
    if( Error != ERROR_SUCCESS ) {
        DhcpMapJetError( JetError, ColumnName );
        return( Error );
    }

    if ( SearchFromStart ) {
        JetError = JetMove(
            pDbCtx->SessId,
            pDbCtx->TblId,
            JET_MoveFirst,
            0 );
    } else {
        JetError =  JetMakeKey(
            pDbCtx->SessId,
            pDbCtx->TblId,
            Key,
            KeySize,
            JET_bitNewKey );

        Error = DhcpMapJetError( JetError, "M:PrepareSearch:MakeKey" );
        if( Error != ERROR_SUCCESS ) {
            DhcpMapJetError( JetError, ColumnName );
            return( Error );
        }

        JetError = JetSeek(
            pDbCtx->SessId,
            pDbCtx->TblId,
            JET_bitSeekGT );
    }

    return( DhcpMapJetError( JetError, "M:PrepareSearch:Move/Seek" ) );
}



DWORD
MadcapJetNextRecord(
    PDB_CTX pDbCtx
)
    /*++

      Routine Description:

      This function advances to the next record in a search.

      Arguments:

      None.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;

    JetError = JetMove(
        pDbCtx->SessId,
        pDbCtx->TblId,
        JET_MoveNext,
        0 );

    return( DhcpMapJetError( JetError, "M:NextRecord" ) );
}



DWORD
MadcapJetDeleteCurrentRecord(
    PDB_CTX pDbCtx
)
    /*++

      Routine Description:

      This function deletes the current record.

      Arguments:

      None.

      Return Value:

      The status of the operation.

      --*/
{
    JET_ERR JetError;

    JetError = JetDelete( pDbCtx->SessId, pDbCtx->TblId );
    return( DhcpMapJetError( JetError, "M:DeleteCurrentRecord" ) );
}

DWORD
MadcapJetGetRecordPosition(
    IN PDB_CTX pDbCtx,
    IN JET_RECPOS *pRecPos,
    IN DWORD    Size
)
{
    JET_ERR JetError;

    JetError = JetGetRecordPosition(
                    pDbCtx->SessId,
                    pDbCtx->TblId,
                    pRecPos,
                    Size );

    return( DhcpMapJetError( JetError, "M:GetCurrRecord" ) );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\lock.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

DWORD
DhcpReadWriteInit(
    VOID
) ;


VOID
DhcpReadWriteCleanup(
    VOID
) ;


VOID
DhcpAcquireReadLock(
    VOID
) ;


VOID
DhcpAcquireWriteLock(
    VOID
) ;


VOID
DhcpReleaseWriteLock(
    VOID
) ;


VOID
DhcpReleaseReadLock(
    VOID
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\mdhcpdb.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/

#define MCAST_CLIENT_TABLE_NAME       "MCastClientTableVer3"

#define MCAST_TBL_IPADDRESS_STR "MCastIpAddr"
#define MCAST_TBL_CLIENT_ID_STR "MCastClientID"
#define MCAST_TBL_CLIENT_INFO_STR "MCastClientInfo"
#define MCAST_TBL_STATE_STR     "MCastState"
#define MCAST_TBL_FLAGS_STR     "MCastFlags"
#define MCAST_TBL_SCOPE_ID_STR     "ScopeId"
#define MCAST_TBL_LEASE_START_STR   "MCastLeaseStart"
#define MCAST_TBL_LEASE_END_STR     "MCastLeaseEnd"
#define MCAST_TBL_SERVER_IP_ADDRESS_STR "MCastServerIp"
#define MCAST_TBL_SERVER_NAME_STR "MCastServerName"


enum {
    MCAST_TBL_IPADDRESS,
    MCAST_TBL_CLIENT_ID,
    MCAST_TBL_CLIENT_INFO,
    MCAST_TBL_STATE,
    MCAST_TBL_FLAGS,
    MCAST_TBL_SCOPE_ID,
    MCAST_TBL_LEASE_START,
    MCAST_TBL_LEASE_END,
    MCAST_TBL_SERVER_IP_ADDRESS,
    MCAST_TBL_SERVER_NAME,
    MCAST_MAX_COLUMN
};

typedef struct _DB_CTX {
    JET_DBID  DbId;
    JET_SESID SessId;
    JET_TABLEID TblId;
} DB_CTX, *PDB_CTX;

typedef struct _DB_COLUMN_CTX {
    char *  Name;
    JET_COLUMNID ColHandle;
    PVOID   Data;
    union {
        DWORD   DataLen;
        PDWORD  pDataLen;
    };
} DB_COLUMN_CTX, *PDB_COLUMN_CTX;

#define INIT_DB_CTX( _ctx, _sessid, _tblid ) {    \
    (_ctx)->SessId = _sessid;                       \
    (_ctx)->TblId = _tblid;                       \
}

#define MCAST_COL_HANDLE( _colid ) MadcapGlobalClientTable[_colid].ColHandle
#define MCAST_COL_NAME( _colid ) MadcapGlobalClientTable[_colid].ColName

#define INIT_DB_COLUMN_CTX( _ctx, _name, _id, _data, _datalen ) {    \
    (_ctx)->Name = _name;                       \
    (_ctx)->ColHandle = _id;                       \
   (_ctx)->Data = _data;                       \
   (_ctx)->DataLen = (DWORD)_datalen                       \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\main.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This is the main routine for the DHCP server service.

Author:

    Madan Appiah (madana)  10-Sep-1993
    Manny Weiser (mannyw)  11-Aug-1992

Environment:

    User Mode - Win32

Revision History:

    Cheng Yang (t-cheny) 30-May-1996  superscope
    Cheng Yang (t-cheny) 24-Jun-1996  IP address detection, audit log

--*/

#include    <dhcppch.h>
#define GLOBAL_DATA_ALLOCATE                       // alloc globl data in global.h
#undef  GLOBAL_DATA
#include    <global.h>
#include    <dhcp_srv.h>
#include    <dhcp2_srv.h>
#include    <dsreg.h>
#include    <iptbl.h>
#include    <endpoint.h>

LONG DhcpGlobalDataRefCount = 0;

extern
DWORD       DhcpDsInitDS(                         // initialize DS structs.. <dhcpds.h>
    IN      DWORD                  Flags,         // initialization optiosn.. must be zero
    IN      LPVOID                 IdInfo         // future use param
);

extern
VOID        DhcpDsCleanupDS(                      // undo DhcpDsInitDS
    VOID
);
#include <mdhcpsrv.h>

DWORD
Initialize(                                       // global data struct init..
    BOOLEAN ServiceStartup,
    BOOLEAN RestartInit
    );

VOID
Shutdown(
    IN DWORD ErrorCode,
    BOOLEAN ServiceEnd,
    BOOLEAN RestartClose
    );

BOOL                               DnsStarted = FALSE;

//DOC  UpdateStatus updates the dhcp service status with the Service Controller.
//DOC  RETURN VALUE is Win32 error code as returned from SetServiceStatus()
DWORD
UpdateStatus(                                     // send service status to controller
    VOID
)
{
    DWORD                          Error = ERROR_SUCCESS;
    BOOL                           SetServiceStatusRetVal;

    DhcpAssert( DhcpGlobalServiceStatusHandle !=  0 );

    SetServiceStatusRetVal = SetServiceStatus(
        DhcpGlobalServiceStatusHandle,
        &DhcpGlobalServiceStatus
    );

    if( !SetServiceStatusRetVal ) {               // shouldn't really happen
        Error = GetLastError();
        DhcpPrint((DEBUG_ERRORS, "SetServiceStatus failed, %ld.\n", Error ));
    }

    return Error;
}

//DOC LoadStrings loads a bunch of strings defined via the .mc file into an
//DOC array for sake of efficiency.
//DOC RETURN VALUE is TRUE if everything went ok, else returns FALSE.
BOOL
LoadStrings(                                      // load required strings
    VOID
) {
   DWORD                           dwSuccess;
   HMODULE                         hModule;
   DWORD                           dwID;
   VOID                            FreeStrings(); // defined right below..

   hModule = LoadLibrary( DHCP_SERVER_MODULE_NAME );
   memset( g_ppszStrings, 0, DHCP_CSTRINGS * sizeof( WCHAR * ) );

   for ( dwID = DHCP_FIRST_STRING; dwID <= DHCP_LAST_STRING; dwID++ ) {
       dwSuccess = FormatMessage(                 // format the required string
          FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
          hModule,                                // search local process
          dwID,                                   // string ID
          MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT),
          (WCHAR*) ( g_ppszStrings + dwID - DHCP_FIRST_STRING ),
          1,
          NULL
      );

      if (!dwSuccess) break;
   }

   FreeLibrary(hModule);                          // error or success, got to free.

   if( dwID <= DHCP_LAST_STRING ) {               // error!
       FreeStrings();
       return FALSE;
   }

   return TRUE;                                   // everything went fine.
}

//DOC FreeStrings free's the strings in the array loaded by LoadStrings.
VOID
FreeStrings(                                      // free's string loaded by LoadStrings
    VOID
)
{
   int                             i;

   for( i = 0; i < DHCP_CSTRINGS; i++ ) {
       if (g_ppszStrings[i] != NULL) {
           (LocalFree)( g_ppszStrings[i] );           // avoid all #defines and use (LocalFree)
           g_ppszStrings[i] = NULL;
       }
   }
}


WCHAR *
GetString(                                        // used only in chk'ed builds..
    DWORD dwID
)
{
    // if you hit this assert, change DHCP_LAST_STRING in global.h
    DhcpAssert( dwID <= DHCP_LAST_STRING );

    return g_ppszStrings[ dwID - DHCP_FIRST_STRING ];
}

ULONG
DhcpInitGlobalData (
    BOOLEAN ServiceStartup
)
{
    ULONG Error = ERROR_SUCCESS;
    BOOLEAN restartInit = FALSE;

    // This call was previously buried inside DhcpInitGlobalData.  
    // It caused a deadlock because BINL grabs first DhcpGlobalBinlSyncCritSect, then
    // gcsDHCPBINL (in TellBinlState, called from InformBinl); while DHCP calls grabs them
    // in the opposite order.
    // Now, this call to InformBinl is made whenever StartupService is true and depends on
    // nothing else.  Moreover, what it makes BINL do is initialize socket endpoints, which
    // can be safely done here since I think the variables initalised by DHCP before the
    // call, previously, are not affected adversely by BINL.
    if( ServiceStartup ) {
        InformBinl( DHCP_STARTING );
    }

    EnterCriticalSection( &DhcpGlobalBinlSyncCritSect );

    DhcpGlobalDataRefCount++;

    if (DhcpGlobalDataRefCount > 1) {

        if (ServiceStartup) {

            restartInit = TRUE;

        } else {

            LeaveCriticalSection( &DhcpGlobalBinlSyncCritSect );
            return Error;
        }
    }

    Error = Initialize( ServiceStartup, restartInit );

    LeaveCriticalSection( &DhcpGlobalBinlSyncCritSect );
    return Error;
}

VOID
DhcpCleanUpGlobalData (
    ULONG Error,
    BOOLEAN ServiceEnd
)
{
    BOOLEAN restartEnd = FALSE;

    EnterCriticalSection( &DhcpGlobalBinlSyncCritSect );

    DhcpGlobalDataRefCount--;

    if (DhcpGlobalDataRefCount > 0) {

        if (ServiceEnd) {

            restartEnd = TRUE;

        } else {

            LeaveCriticalSection( &DhcpGlobalBinlSyncCritSect );
            return;
        }
    }

    Shutdown( Error, ServiceEnd, restartEnd );
    LeaveCriticalSection( &DhcpGlobalBinlSyncCritSect );
    return;
}


DWORD
InitializeData(                                   // init bunch of memory ...
    VOID
)
{
    DWORD                          Length;
    DWORD                          Error;

    DhcpLeaseExtension = DHCP_LEASE_EXTENSION;
    DhcpGlobalScavengerTimeout = DHCP_SCAVENGER_INTERVAL;

    Error = DhcpPendingListInit();                // init pending list structures
    if( ERROR_SUCCESS != Error ) return Error;

    Length = MAX_COMPUTERNAME_LENGTH + 1;         // get the server name
    if( !GetComputerName( DhcpGlobalServerName, &Length ) ) {
        Error = GetLastError();                   // need to use gethostname..
        DhcpPrint(( DEBUG_ERRORS, "Can't get computer name, %ld.\n", Error ));

        return Error ;
    }

    DhcpAssert( Length <= MAX_COMPUTERNAME_LENGTH );
    DhcpGlobalServerName[Length] = L'\0';
    DhcpGlobalServerNameLen = (Length + 1) * sizeof(WCHAR);

    return ERROR_SUCCESS;
}


VOID
CleanupData(                                      // sundry cleanup..
    VOID
) {
    DhcpPendingListCleanup();

    //
    // delete security objects.
    //

    if( DhcpGlobalSecurityDescriptor != NULL ) {
        NetpDeleteSecurityObject( &DhcpGlobalSecurityDescriptor );
        DhcpGlobalSecurityDescriptor = NULL;
    }

    if( DhcpSid ) {
        DhcpFreeMemory( DhcpSid );
        DhcpSid = NULL;
    }

    //
    // delete well known SIDs if they are allocated already.
    //

    if( DhcpGlobalWellKnownSIDsMade ) {
        NetpFreeWellKnownSids();
        DhcpGlobalWellKnownSIDsMade = FALSE;
    }

    if( DhcpGlobalOemDatabasePath != NULL ) {
        DhcpFreeMemory( DhcpGlobalOemDatabasePath );
        DhcpGlobalOemDatabasePath = NULL;
    }

    if( DhcpGlobalOemBackupPath != NULL ) {
        DhcpFreeMemory( DhcpGlobalOemBackupPath );
        DhcpGlobalOemBackupPath = NULL;
    }

    if( DhcpGlobalOemRestorePath != NULL ) {
        DhcpFreeMemory( DhcpGlobalOemRestorePath );
        DhcpGlobalOemRestorePath = NULL;
    }

    if( DhcpGlobalOemJetBackupPath != NULL ) {
        DhcpFreeMemory( DhcpGlobalOemJetBackupPath );
        DhcpGlobalOemJetBackupPath = NULL;
    }

    if( DhcpGlobalOemJetRestorePath != NULL ) {
        DhcpFreeMemory( DhcpGlobalOemJetRestorePath );
        DhcpGlobalOemJetRestorePath = NULL;
    }
    
    if( DhcpGlobalBackupConfigFileName != NULL ) {
        DhcpFreeMemory( DhcpGlobalBackupConfigFileName );
        DhcpGlobalBackupConfigFileName = NULL;
    }

    if( DhcpGlobalRecomputeTimerEvent != NULL ) {
        CloseHandle( DhcpGlobalRecomputeTimerEvent );
        DhcpGlobalRecomputeTimerEvent = NULL;
    }

    if( DhcpGlobalProcessTerminationEvent != NULL ) {
        CloseHandle( DhcpGlobalProcessTerminationEvent );
        DhcpGlobalProcessTerminationEvent = NULL;
    }

    if( DhcpGlobalRogueWaitEvent != NULL ) {
        CloseHandle( DhcpGlobalRogueWaitEvent );
        DhcpGlobalRogueWaitEvent = NULL;
    }

    if( DhcpGlobalAddrToInstTable ) {
        DhcpFreeMemory(DhcpGlobalAddrToInstTable);
        DhcpGlobalAddrToInstTable = NULL;
    }

    if( DhcpGlobalTCPHandle != NULL ) {
        CloseHandle( DhcpGlobalTCPHandle );
        DhcpGlobalTCPHandle = NULL;
    }

    //
    // close the interface notification socket.
    //

    if ( DhcpGlobalPnPNotificationSocket != INVALID_SOCKET) {
        closesocket( DhcpGlobalPnPNotificationSocket );
        DhcpGlobalPnPNotificationSocket = INVALID_SOCKET;
    }

    if ( DhcpGlobalEndpointReadyEvent ) {
        CloseHandle( DhcpGlobalEndpointReadyEvent );
        DhcpGlobalEndpointReadyEvent = NULL;
    }

    DhcpConfigCleanup();

}

DWORD
InitializeRpc(                                    // initialize rpc like we want
    VOID
)
{
    RPC_STATUS                     rpcStatus;     // RPC_STATUS is Windows error.
    RPC_STATUS                     rpcStatus2;
    RPC_BINDING_VECTOR            *bindingVector;
    BOOL                           RpcOverTcpIP = FALSE;
    BOOL                           Bool;


    //
    // Read "RpcAPIProtocolBinding" parameter (DWORD) from registry,
    // if it is 1 - use "ncacn_ip_tcp" protocol.
    // if it is 2 - use "ncacn_np" protocol.
    // if it is 3 - use both.
    //

    //
    // if none is specified, use "ncacn_ip_tcp".
    //

    if( !(DhcpGlobalRpcProtocols & DHCP_SERVER_USE_RPC_OVER_ALL) ) {
        DhcpGlobalRpcProtocols = DHCP_SERVER_USE_RPC_OVER_TCPIP;
    }

    //
    // if we are asked to use RPC over TCPIP, do so.
    //

    if( DhcpGlobalRpcProtocols & DHCP_SERVER_USE_RPC_OVER_TCPIP ) {

        rpcStatus = RpcServerUseProtseq(
            L"ncacn_ip_tcp",                      // protocol string.
            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,       // max concurrent calls
            NULL //DhcpGlobalSecurityDescriptor
        );

        if (rpcStatus != RPC_S_OK) {
            return rpcStatus;
        }

        RpcOverTcpIP = TRUE;
    }

    //
    // if we are asked to use RPC over Named Pipe, do so.
    //

    if( DhcpGlobalRpcProtocols & DHCP_SERVER_USE_RPC_OVER_NP ) {

        rpcStatus = RpcServerUseProtseqEp(
            L"ncacn_np",                          // protocol string.
            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,       // maximum concurrent calls
            DHCP_NAMED_PIPE,                      // endpoint
            NULL// RPC bug DhcpGlobalSecurityDescriptor
        );

        if( (rpcStatus != RPC_S_DUPLICATE_ENDPOINT) &&
                (rpcStatus != RPC_S_OK) ) {

            if( DHCP_SERVER_USE_RPC_OVER_NP ==
                DhcpGlobalRpcProtocols ) {
                return rpcStatus;
            }

            //
            // just log an event
            //
            
            DhcpServerEventLog(
                EVENT_SERVER_INIT_RPC_FAILED,
                EVENTLOG_WARNING_TYPE, rpcStatus );
            
        }
        rpcStatus = RPC_S_OK;
    }

    //
    // if we are asked to use RPC over LPC, do so.
    //
    // We need this protocol for the following two reasons.
    //
    // 1. performance.
    // 2. due to a bug in the security checking when rpc is made from
    // one local system process to another local system process using
    // other protocols.
    //

    if( DhcpGlobalRpcProtocols & DHCP_SERVER_USE_RPC_OVER_LPC ) {

        rpcStatus = RpcServerUseProtseqEp(
            L"ncalrpc",                           // protocol string.
            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,       // maximum concurrent calls
            DHCP_LPC_EP,                          // endpoint
            NULL// RPC bug DhcpGlobalSecurityDescriptor
        );

        if ( (rpcStatus != RPC_S_DUPLICATE_ENDPOINT) &&
                (rpcStatus != RPC_S_OK) ) {
            return rpcStatus;
        }
        rpcStatus = RPC_S_OK;
    }

    rpcStatus = RpcServerInqBindings(&bindingVector);

    if (rpcStatus != RPC_S_OK) {
        return(rpcStatus);
    }

    rpcStatus = RpcEpRegisterNoReplaceW(
        dhcpsrv_ServerIfHandle,
        bindingVector,
        NULL,                                     // Uuid vector.
        L""                                       // annotation.
    );
    if ( rpcStatus != RPC_S_OK ) {
        return rpcStatus;
    }

    rpcStatus2 = RpcEpRegisterNoReplaceW(
        dhcpsrv2_ServerIfHandle,
        bindingVector,
        NULL,
        L""
    );

    if ( rpcStatus != RPC_S_OK ) {
        return rpcStatus;
    }

    //
    // free binding vector.
    //

    rpcStatus = RpcBindingVectorFree( &bindingVector );

    DhcpAssert( rpcStatus == RPC_S_OK );
    rpcStatus = RPC_S_OK;

    rpcStatus = RpcServerRegisterIf(dhcpsrv_ServerIfHandle, 0, 0);
    if ( rpcStatus != RPC_S_OK ) {
        return rpcStatus;
    }

    rpcStatus = RpcServerRegisterIf(dhcpsrv2_ServerIfHandle, 0, 0);
    if ( rpcStatus != RPC_S_OK ) {
        return rpcStatus;
    }

    if( RpcOverTcpIP == TRUE ) {
        LPWSTR PrincName;
        
        rpcStatus = RpcServerRegisterAuthInfo(
            DHCP_SERVER_SECURITY,                 // app name to security provider.
            DHCP_SERVER_SECURITY_AUTH_ID,         // Auth package ID.
            NULL,                                 // Encryption function handle.
            NULL                                  // argment pointer to Encrypt function.
        );

        if ( rpcStatus ) {
            return rpcStatus;
        }

        rpcStatus = RpcServerInqDefaultPrincName(
            RPC_C_AUTHN_GSS_NEGOTIATE, &PrincName );

        if( RPC_S_OK != rpcStatus ) return rpcStatus;
        
        rpcStatus = RpcServerRegisterAuthInfo(
            PrincName, RPC_C_AUTHN_GSS_NEGOTIATE, NULL, 0 );

        RpcStringFree( &PrincName );

        if( RPC_S_OK != rpcStatus ) return rpcStatus;
    }

    rpcStatus = TcpsvcsGlobalData->StartRpcServerListen();

    DhcpGlobalRpcStarted = TRUE;
    return(rpcStatus);

}

//DOC ServiceControlHandler is the entrypoint into the dhcp server
//DOC from the service controller.
VOID
ServiceControlHandler(                            // hdl SC operations
    IN      DWORD                  Opcode         // operation type..
) {
    switch (Opcode) {
    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:

        if (DhcpGlobalServiceStatus.dwCurrentState != SERVICE_STOP_PENDING) {
            if( Opcode == SERVICE_CONTROL_SHUTDOWN ) {

                //
                // set this flag, so that service shut down will be
                // faster.
                //

                DhcpGlobalSystemShuttingDown = TRUE;
            }

            DhcpGlobalServiceStopping = TRUE;
            DhcpPrint(( DEBUG_MISC, "Service is stop pending.\n"));
            DhcpGlobalServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
            DhcpGlobalServiceStatus.dwCheckPoint = 1;

            UpdateStatus();                       // send response to controller

            if (! SetEvent(DhcpGlobalProcessTerminationEvent)) {

                //
                // Problem with setting event to terminate dhcp
                // service.
                //

                DhcpPrint(( DEBUG_ERRORS, "DHCP Server: Error "
                            "setting DoneEvent %lu\n",
                            GetLastError()));

                DhcpAssert(FALSE);
            }

            DhcpPrint((DEBUG_TRACE, "Set termination event!\n"));

            if( TRUE ) {                          //  Ask the worker threads to quit
                DWORD              Error;         //  Shouldnt really have errs here

                Error = DhcpNotifyWorkerThreadsQuit();
                if( ERROR_SUCCESS != Error ) {
                    DhcpPrint((DEBUG_ERRORS, "NotifyWorkerThreadsQuit:%ld\n",Error));
                }
            }

            return;
        }
        break;

    case SERVICE_CONTROL_PAUSE:

        DhcpGlobalServiceStatus.dwCurrentState = SERVICE_PAUSED;
        CALLOUT_CONTROL(DHCP_CONTROL_PAUSE);
        DhcpPrint(( DEBUG_MISC, "Service is paused.\n"));
        break;

    case SERVICE_CONTROL_CONTINUE:

        DhcpGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;
        CALLOUT_CONTROL(DHCP_CONTROL_CONTINUE);
        DhcpPrint(( DEBUG_MISC, "Service is Continued.\n"));
        InformBinl(DHCP_STARTING);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        DhcpPrint(( DEBUG_MISC, "Service is interrogated.\n"));
        break;

    case SERVICE_CONTROL_NETBINDADD:
    case SERVICE_CONTROL_NETBINDREMOVE:
    case SERVICE_CONTROL_NETBINDENABLE:
    case SERVICE_CONTROL_NETBINDDISABLE:
        DhcpUpdateEndpointBindings();
        break;
    default:
        DhcpPrint(( DEBUG_MISC, "Service received unknown control.\n"));
        break;
    }

    UpdateStatus();                               // send status response
}

//
// Defined in rpcapi1.c
//
DWORD
SetDefaultConfigInfo(
    VOID
    );

//DOC Initialize does the global data-structure initialization and it also
//DOC starts up the service itself.
//DOC RETURN VALUE: 0 is success, +ve  is Win32 err, -ve is service specific err.
DWORD
Initialize(                                       // global data struct init..
    BOOLEAN ServiceStartup,
    BOOLEAN RestartInit
) {
    DWORD                          threadId;
    DWORD                          Error = ERROR_SUCCESS;
    WSADATA                        wsaData;
    DWORD                          i;
    DWORD                          DsThreadId;
    HANDLE                         DsThreadHandle;

    if (! RestartInit) {

        //
        // prepare to use the debug heap
        //

        INIT_DEBUG_HEAP( HEAPX_NORMAL );

        //
        // Initialize globals
        //

        // set to TRUE after rogue detection part decides it's ok to service
        DhcpGlobalOkToService = FALSE;

        g_hAuditLog = NULL;

        DhcpGlobalSystemShuttingDown = FALSE;
        DhcpGlobalServerPort = DHCP_SERVR_PORT;
        DhcpGlobalClientPort = DHCP_CLIENT_PORT;
    }
    if (ServiceStartup) {

        DhcpGlobalServiceStopping = FALSE;
        DhcpLeaseExtension = 0;
        DhcpGlobalCleanupInterval = DHCP_DATABASE_CLEANUP_INTERVAL;

        DhcpGlobalRpcProtocols = 0;

        DhcpGlobalScavengeIpAddressInterval = DHCP_SCAVENGE_IP_ADDRESS;
        DhcpGlobalScavengeIpAddress = FALSE;

        DhcpGlobalDetectConflictRetries = DEFAULT_DETECT_CONFLICT_RETRIES;
        DhcpGlobalBackupInterval = DEFAULT_BACKUP_INTERVAL;
        DhcpGlobalDatabaseLoggingFlag = DEFAULT_LOGGING_FLAG;
        DhcpGlobalRestoreFlag = DEFAULT_RESTORE_FLAG;

        DhcpGlobalAuditLogFlag = DEFAULT_AUDIT_LOG_FLAG;
        DhcpGlobalRecomputeTimerEvent = NULL;
        DhcpGlobalRpcStarted = FALSE;
        DhcpGlobalOemDatabasePath = NULL;
        DhcpGlobalOemBackupPath = NULL;
        DhcpGlobalOemRestorePath = NULL;
        DhcpGlobalOemJetBackupPath = NULL;
        DhcpGlobalOemJetRestorePath = NULL;
        DhcpGlobalOemDatabaseName = NULL;
        DhcpGlobalBackupConfigFileName = NULL;
        DhcpGlobalRegSoftwareRoot = NULL;
        DhcpGlobalRegRoot = NULL;
        DhcpGlobalRegConfig = NULL;
        DhcpGlobalRegSubnets = NULL;
        DhcpGlobalRegMScopes = NULL;
        DhcpGlobalRegOptionInfo = NULL;
        DhcpGlobalRegGlobalOptions = NULL;
        DhcpGlobalRegSuperScope = NULL;    // added by t-cheny: superscope
        DhcpGlobalRegParam = NULL;

        DhcpGlobalDSDomainAnsi = NULL;
        DhcpGlobalJetServerSession = 0;
        DhcpGlobalDatabaseHandle = 0;
        DhcpGlobalClientTableHandle = 0;
        DhcpGlobalClientTable = NULL;

        DhcpGlobalScavengerTimeout = 0;
        DhcpGlobalProcessorHandle = NULL;
        DhcpGlobalMessageHandle = NULL;
        DhcpGlobalProcessTerminationEvent = NULL;
        DhcpGlobalRogueWaitEvent = NULL;
        DhcpGlobalTotalNumSubnets = 0;     // added by t-cheny: superscope
        DhcpGlobalNumberOfNetsActive = 0;
        DhcpGlobalSubnetsListModified = TRUE;
        DhcpGlobalSubnetsListEmpty = FALSE;

        DhcpGlobalBindingsAware = TRUE;
        DhcpGlobalImpersonated = FALSE;
        
        DhcpGlobalSecurityDescriptor = NULL;
        DhcpSid = NULL;
        DhcpGlobalWellKnownSIDsMade = FALSE;
        DhcpGlobalRestoreStatus = NO_ERROR;
        
        try {
            InitializeCriticalSection(&DhcpGlobalJetDatabaseCritSect);
            InitializeCriticalSection(&DhcpGlobalRegCritSect);
        } except( EXCEPTION_EXECUTE_HANDLER ) {

            Error = GetLastError( );
            DhcpPrint( (DEBUG_INIT, "Critical Section Init Failed, " "%ld.\n", Error ) );
            return( Error );
        }

        DhcpGlobalServerStartTime.dwLowDateTime = 0;
        DhcpGlobalServerStartTime.dwHighDateTime = 0;

        DhcpGlobalUseNoDns = FALSE;
        DhcpGlobalThisServer = NULL;
    }
    if (! RestartInit) {

        try {
            InitializeCriticalSection(&DhcpGlobalInProgressCritSect);
            InitializeCriticalSection(&DhcpGlobalMemoryCritSect);
            InitializeCriticalSection( &g_ProcessMessageCritSect );

            InitializeListHead(&DhcpGlobalFreeRecvList);
            InitializeListHead(&DhcpGlobalActiveRecvList);
            InitializeCriticalSection(&DhcpGlobalRecvListCritSect);
        } except( EXCEPTION_EXECUTE_HANDLER ) {

 
            Error = GetLastError( );
            DhcpPrint((DEBUG_INIT, "Critical Section Init failed, " "%ld.\n", Error ) );
            return( Error );

        }

        DhcpGlobalMessageQueueLength = DHCP_RECV_QUEUE_LENGTH;
        DhcpGlobalRecvEvent = NULL;


#if DBG
        DhcpGlobalDebugFlag = 0xFFFF | DEBUG_LOG_IN_FILE | DEBUG_ALLOC;

        Error = DhcpMemInit();
        if( ERROR_SUCCESS != Error ) return Error;


        DhcpGlobalDebugFileHandle = NULL;

        DhcpGlobalDebugFileMaxSize = DEFAULT_MAXIMUM_DEBUGFILE_SIZE;
        DhcpGlobalDebugSharePath = NULL;

        //
        // Open debug log file.
        //

        DhcpOpenDebugFile( FALSE );  // not a reopen.
#endif
    }
    if (ServiceStartup) {
        DhcpInitDnsMemory();
        DhcpInitializeMadcap();

        //
        // Initialize all the status fields so that subsequent calls to
        // SetServiceStatus need to only update fields that changed.
        //

        DhcpGlobalServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
        DhcpGlobalServiceStatus.dwCurrentState = SERVICE_START_PENDING;
        DhcpGlobalServiceStatus.dwControlsAccepted = 0;
        DhcpGlobalServiceStatus.dwCheckPoint = 1;
        DhcpGlobalServiceStatus.dwWaitHint = 60000; // 60 secs.
        DhcpGlobalServiceStatus.dwWin32ExitCode = ERROR_SUCCESS;
        DhcpGlobalServiceStatus.dwServiceSpecificExitCode = 0;

        Error = PerfInit();
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint(( DEBUG_INIT, "PerfInit failed %ld\n", Error));
            return Error;
        }

        //
        // Initialize dhcp to receive service requests by registering the
        // control handler.
        //

        DhcpGlobalServiceStatusHandle = RegisterServiceCtrlHandler(
            DHCP_SERVER,
            ServiceControlHandler );

        if ( DhcpGlobalServiceStatusHandle == 0 ) {
            Error = GetLastError();
            DhcpPrint((DEBUG_INIT, "RegisterServiceCtrlHandlerW failed, "
                       "%ld.\n", Error));

            DhcpServerEventLog(
                EVENT_SERVER_FAILED_REGISTER_SC,
                EVENTLOG_ERROR_TYPE,
                Error );

            return(Error);
        }
        //
        // Tell Service Controller that we are start pending.
        //

        UpdateStatus();

        //
        // Create the process termination event.
        //

        DhcpGlobalProcessTerminationEvent =
            CreateEvent(
                NULL,      // no security descriptor
                TRUE,      // MANUAL reset
                FALSE,     // initial state: not signalled
                NULL);     // no name

        if ( DhcpGlobalProcessTerminationEvent == NULL ) {
            Error = GetLastError();
            DhcpPrint((DEBUG_INIT, "Can't create ProcessTerminationEvent, "
                        "%ld.\n", Error));
            return(Error);
        }


        DhcpGlobalRogueWaitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if( NULL == DhcpGlobalRogueWaitEvent ) {
            Error = GetLastError();
            DhcpPrint((DEBUG_INIT, "Can't create RogueWaitEvent: %ld\n", Error));
            return Error;
        }


        //
        // create the ProcessMessage termination event
        //

        g_hevtProcessMessageComplete = CreateEvent(
            NULL,
            FALSE,
            FALSE,
            NULL
        );

        if ( !g_hevtProcessMessageComplete ) {
            Error = GetLastError();

            DhcpPrint( (DEBUG_INIT,
                        "Initialize(...) CreateEvent returned error %x\n",
                        Error )
                    );

            return Error;
        }

    }

    if (! RestartInit) {

        DhcpPrint(( DEBUG_INIT, "Initializing .. \n", 0 ));

        //
        // load localized messages from the string table
        //

        if ( !LoadStrings() )
        {
            DhcpPrint(( DEBUG_INIT, "Unable to load string table.\n" ));

            DhcpServerEventLog(
                    EVENT_SERVER_INIT_DATA_FAILED,
                    EVENTLOG_ERROR_TYPE,
                    ERROR_NOT_ENOUGH_MEMORY );

            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    if (ServiceStartup) {

        //
        // start up winsock
        //
        //

        Error = WSAStartup( WS_VERSION_REQUIRED, &wsaData);
        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_INIT, "WSAStartup failed, %ld.\n", Error ));

            DhcpServerEventLog(
                EVENT_SERVER_INIT_WINSOCK_FAILED,
                EVENTLOG_ERROR_TYPE,
                Error );

            return(Error);
        }

        Error = InitializeData();
        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_INIT, "Data initialization failed, %ld.\n",
                            Error ));

            DhcpServerEventLog(
                EVENT_SERVER_INIT_DATA_FAILED,
                EVENTLOG_ERROR_TYPE,
                Error );

            return(Error);
        }

        DhcpPrint(( DEBUG_INIT, "Data initialization succeeded.\n", 0 ));

        //
        // send heart beat to the service controller.
        //
        //

        DhcpGlobalServiceStatus.dwCheckPoint++;
        UpdateStatus();
    }

    if (! RestartInit) {

        Error = DhcpDsInitDS(0,NULL);                 // Ignore DS errors for now.
        Error = ERROR_SUCCESS;                        // ignore errors..
    }

    if( !CFLAG_DONT_DO_DSWORK ) {                 // DS Stuff is enabled..

        DsThreadHandle = CreateThread             // create a new thread as call is SLOW
        (
            NULL,                                 // no security attributes
            0,                                    // default stack size
            (LPTHREAD_START_ROUTINE)DhcpDownloadDsToRegistry,
            NULL,                                 // no parameters
            0,                                    // no creation flags
            &DsThreadId                           // not really used..
        );
        if( NULL == DsThreadHandle ) {            // could not create the thread
            Error = GetLastError();
        } else {
            do {                                  // keep up checkpoints for SC sanity.
                Error = WaitForSingleObject(DsThreadHandle, 2000);
                DhcpGlobalServiceStatus.dwCheckPoint++;
                UpdateStatus();                       // keep satisfying the service controller
            } while ( WAIT_TIMEOUT == Error );
            if( WAIT_OBJECT_0 == Error ) {        // the other thread did quit
                Error = ERROR_SUCCESS;                // in which case, it not really an error
            } else {
                Error = GetLastError();           // hmm.. this should nto really happen
            }
            CloseHandle(DsThreadHandle);          // close this thread and free resources
        }

        if( ERROR_SUCCESS != Error ) {
            DhcpPrint(( DEBUG_ERRORS, "Error downloading DS: %ld\n", Error));
            DhcpServerEventLog(
                EVENT_SERVER_INIT_REGISTRY_FAILED,// need some other event
                EVENTLOG_ERROR_TYPE,
                Error
            );
        }
    } // if

    if (! RestartInit) {

        Error = DhcpInitSecrets();

        if( ERROR_SUCCESS != Error ) {

            DhcpPrint((DEBUG_INIT, "Can't initialize LSA secrets stuff: %ld\n", Error));
            return Error;

        }
    }

    if (ServiceStartup) {
        //
        // Create well know SID for netlogon.dll
        //

        Error = RtlNtStatusToDosError( NetpCreateWellKnownSids( NULL ) );

        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS, "Can't create Well Known SIDs.\n", Error));
            return(Error);
        }

        DhcpGlobalWellKnownSIDsMade = TRUE;

        //
        // Create the security descriptors we'll use for the APIs
        //

        Error = DhcpCreateSecurityObjects();

        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS, "Can't create security object.\n", Error));
            return(Error);
        }

        //
        // send heart beat to the service controller.
        //
        //

        DhcpGlobalServiceStatus.dwCheckPoint++;
        UpdateStatus();


	// DhcpInitializeRegistry() not only initializes the registry,
	// but also tries to create the directories specified in the registry.
	// So the directories specified must be accessible upon startup time
	// otherwise the service will not startup.

        Error = DhcpInitializeRegistry();             // older init proc. appendage, will go sometime.
        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS, "New Registry initialization failed, %ld.\n", Error ));
            DhcpServerEventLog(
                EVENT_SERVER_INIT_REGISTRY_FAILED,
                EVENTLOG_ERROR_TYPE,
                Error
            );
            return Error;
        }
        DhcpPrint(( DEBUG_INIT, "Registry initialization succeeded.\n", 0));

#if DBG
        //
        // break in the debugger if we are asked to do so.
        //

        if(DhcpGlobalDebugFlag & DEBUG_STARTUP_BRK) {
            // Here comes the kludge... NTSD will not be able to
            // get this because we wont know the pid of tcpsvcs.exe
            // to catch this.... So, we print messages and sleep
            // for about a minute to enable others to catch it.
            // To avoid problems, we sleep 10 seconds at a time,
            // and print messages, and do this 6 times. (Updating
            // SC with hearbeats....)
            DWORD i;

            for( i = 0 ; i < 6 && (DhcpGlobalDebugFlag & DEBUG_STARTUP_BRK) ; i ++ ) {
                DhcpPrint((DEBUG_MISC, "Going to break into debugger soon\n"));
                Sleep(5000);
                UpdateStatus();
            }

            DebugBreak();
        } // if break on start

#endif

        //
        // send heart beat to the service controller.
        //
        //

        DhcpGlobalServiceStatus.dwCheckPoint++;
        UpdateStatus();

        //
        // restore the database and registry configurations if we are asked
        // to do so.
        //

        if( NULL != DhcpGlobalOemJetRestorePath ) {
	    LPWSTR RestoreConfigFileName;
	    //test
	    
	    DhcpPrint(( DEBUG_MISC,
			"Restoring Configuration from %s\n", 
			DhcpGlobalOemJetRestorePath ));
	    
	    
	    RestoreConfigFileName =
		DhcpAllocateMemory( sizeof( WCHAR ) * strlen( DhcpGlobalOemJetRestorePath ) +
				    sizeof( WCHAR ) * wcslen( DHCP_KEY_CONNECT ) +
				    sizeof( WCHAR ) * wcslen( DHCP_BACKUP_CONFIG_FILE_NAME ) +
				    sizeof( WCHAR ) * 1);

	    if ( DhcpGlobalOemJetRestorePath == NULL ) {
		return( ERROR_NOT_ENOUGH_MEMORY );
	    }

	    RestoreConfigFileName = 
		DhcpOemToUnicode( DhcpGlobalOemJetRestorePath, 
				  RestoreConfigFileName );
	    wcscat( RestoreConfigFileName, DHCP_KEY_CONNECT );
	    wcscat( RestoreConfigFileName, DHCP_BACKUP_CONFIG_FILE_NAME );

	    // Restore from the specified backup path
  	    Error = DhcpRestoreConfiguration( RestoreConfigFileName );
	    DhcpFreeMemory( RestoreConfigFileName );

            if ( Error != ERROR_SUCCESS ) {
                DhcpPrint(( DEBUG_ERRORS,
                    "DhcpRestoreConfiguration failed, %ld.\n", Error ));

                DhcpServerEventLog(
                    EVENT_SERVER_CONFIG_RESTORE_FAILED,
                    EVENTLOG_ERROR_TYPE,
                    Error );

                return(Error);
            } // if 

	    DhcpPrint(( DEBUG_MISC,
			"Restoring database from %s\n",
			DhcpGlobalOemJetRestorePath ));

            Error = DhcpRestoreDatabase(
                DhcpGlobalOemJetRestorePath );

            if( ERROR_SUCCESS != Error ) {
                DhcpPrint((
                    DEBUG_ERRORS, "DhcpRestoreDatabase failed, %ld\n", Error ));

                DhcpServerEventLog(
                    EVENT_SERVER_DATABASE_RESTORE_FAILED,
                    EVENTLOG_ERROR_TYPE,
                    Error
                    );
                DhcpGlobalRestoreStatus = Error;
                Error = NO_ERROR;
            } else {

                DhcpServerEventLog(
                    EVENT_SERVER_DATABASE_RESTORE_SUCCEEDED,
                    EVENTLOG_INFORMATION_TYPE,
                    0 );

		DhcpPrint(( DEBUG_REGISTRY,
			    "Deleting RestoreBackupPath ...\n" ));
                RegDeleteValue( DhcpGlobalRegParam,
                                DHCP_RESTORE_PATH_VALUE );
            } // else 

//  	    // The registry is changed, so reinitialize the registry
//  	    DhcpPrint(( DEBUG_INIT,
//  			"Cleaning up the registry ... \n " ));

//  	    DhcpCleanupRegistry();

//  	    DhcpPrint(( DEBUG_INIT,
//  			"Reinitializing the registry ... \n" ));
//  	    Error = DhcpInitializeRegistry();
//  	    if ( Error != ERROR_SUCCESS ) {
//  		DhcpPrint(( DEBUG_ERRORS,
//  			    "Registry reinitialization failed, %ld.\n", Error ));
//  		DhcpServerEventLog( EVENT_SERVER_INIT_REGISTRY_FAILED,
//  				    EVENTLOG_ERROR_TYPE,
//  				    Error );
//  		return Error;
//  	    } //if 
//  	    DhcpPrint(( DEBUG_INIT,
//  			"Registry reinitialization succeeded.\n"));

        } // if we need to restore 

        if( DhcpGlobalRestoreFlag ) {

            Error = DhcpRestoreConfiguration( DhcpGlobalBackupConfigFileName );

            if ( Error != ERROR_SUCCESS ) {
                DhcpPrint(( DEBUG_ERRORS,
                    "DhcpRestoreConfiguration failed, %ld.\n", Error ));

                DhcpServerEventLog(
                    EVENT_SERVER_CONFIG_RESTORE_FAILED,
                    EVENTLOG_ERROR_TYPE,
                    Error );

                return(Error);
            }

            Error = DhcpRestoreDatabase( DhcpGlobalOemJetBackupPath );

            if ( Error != ERROR_SUCCESS ) {
                DhcpPrint(( DEBUG_ERRORS,
                    "DhcpRestoreDatabase failed, %ld.\n", Error ));

                DhcpServerEventLog(
                    EVENT_SERVER_DATABASE_RESTORE_FAILED,
                    EVENTLOG_ERROR_TYPE,
                    Error );

                return(Error);
            }

            DhcpServerEventLog(
                EVENT_SERVER_DATABASE_RESTORE_SUCCEEDED,
                EVENTLOG_INFORMATION_TYPE,
                0
                );

            //
            // reset restore flag in registry, so that we don't do the
            // restore again in the next reboot.
            //

            DhcpGlobalRestoreFlag = FALSE;
            Error = RegSetValueEx(
                DhcpGlobalRegParam,
                DHCP_RESTORE_FLAG_VALUE,
                0,
                DHCP_RESTORE_FLAG_VALUE_TYPE,
                (LPBYTE)&DhcpGlobalRestoreFlag,
                sizeof(DhcpGlobalRestoreFlag)
                );

            DhcpAssert( Error == ERROR_SUCCESS );
        } // if DhcpGlobalRestoreFlag

	DhcpPrint(( DEBUG_MISC,
		    "Initializing Auditlog .. \n" ));

        Error = DhcpAuditLogInit();
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_INIT, "AuditLog failed 0x%lx\n", Error));
            return Error;
        }

	DhcpPrint(( DEBUG_MISC,
		    "Initializing database ... \n" ));

        Error = DhcpInitializeDatabase();
        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS, "Database init failed, %ld.\n", Error ));

            DhcpServerEventLog(
                EVENT_SERVER_INIT_DATABASE_FAILED,
                EVENTLOG_ERROR_TYPE,
                Error );

            //
            // the database/logfile may be corrupt, try to restore the
            // database from backup and retry database initialization once
            // again
            //

            Error = DhcpRestoreDatabase( DhcpGlobalOemJetBackupPath );

            if ( Error != ERROR_SUCCESS ) {
                DhcpPrint(( DEBUG_ERRORS,
                    "DhcpRestoreDatabase failed, %ld.\n", Error ));

                DhcpServerEventLog(
                    EVENT_SERVER_DATABASE_RESTORE_FAILED,
                    EVENTLOG_ERROR_TYPE,
                    Error );

                return(Error);
            }

            DhcpServerEventLog(
                EVENT_SERVER_DATABASE_RESTORE_SUCCEEDED,
                EVENTLOG_INFORMATION_TYPE,
                0
                );

            Error = DhcpInitializeDatabase();

            if ( Error != ERROR_SUCCESS ) {
                DhcpPrint(( DEBUG_ERRORS,
                    "Database init failed again, %ld.\n", Error ));

                DhcpServerEventLog(
                    EVENT_SERVER_INIT_DATABASE_FAILED,
                    EVENTLOG_ERROR_TYPE,
                    Error );

                return(Error);
            }
        } // if InitializeDatabase() failed

        DhcpPrint(( DEBUG_INIT, "Database initialization succeeded.\n", 0));


        Error = DhcpConfigInit();                   // do the main reg. init. here.
        if( ERROR_SUCCESS != Error ) {                // could not get critical info
            DhcpPrint(( DEBUG_ERRORS, "Error reading config : %ld\n", Error));
            DhcpServerEventLog(
                EVENT_SERVER_INIT_CONFIG_FAILED,
                EVENTLOG_ERROR_TYPE,
                Error
            );

            return Error;
        }

        DhcpPrint((DEBUG_INIT, "Configuration Initialized\n"));


        //
        // Now set default configuration
        //

        Error = SetDefaultConfigInfo();
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_INIT, "Default configuration set failed 0x%lx\n", Error));
            Error = ERROR_SUCCESS;
        }
        
        //
        // send heart beat to the service controller.
        //
        //

        DhcpGlobalServiceStatus.dwCheckPoint++;
        UpdateStatus();

        //
        // Get TCP/IP ARP entity table for seeding arp cache entries
        //
        Error = GetAddressToInstanceTable();
        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint((DEBUG_ERRORS, "could not get address to instance table, %ld\n",Error));
        }

        DhcpGlobalRecomputeTimerEvent =
            CreateEvent( NULL, FALSE, FALSE, NULL );

        if (DhcpGlobalRecomputeTimerEvent  == NULL ) {
            Error = GetLastError();
            DhcpPrint((DEBUG_INIT, "Can't create RecomputeTimerEvent, %ld.\n", Error));
            return(Error);
        }


        //
        // Start the DynamicDns engine.
        //

        if(! USE_NO_DNS) {

	    Error = DynamicDnsInit();
	    if ( ERROR_SUCCESS != Error ) {
		return Error;
	    }
	    else {
		DnsStarted = !DhcpGlobalUseNoDns;
	    }
        }

        //
        // send heart beat to the service controller.
        //
        //

        DhcpGlobalServiceStatus.dwCheckPoint++;
        UpdateStatus();

        CalloutInit();

        Error = DhcpInitializeClientToServer();
        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS, "Client-to-server initialization "
                            "failed, %ld.\n", Error));

            DhcpServerEventLog(
                EVENT_SERVER_INIT_SOCK_FAILED,
                EVENTLOG_ERROR_TYPE,
                Error );

            return(Error);
        }

        DhcpPrint(( DEBUG_INIT, "Client-to-server initialization succeeded.\n", 0 ));


        DhcpGlobalServiceStatus.dwCurrentState = SERVICE_RUNNING;
        DhcpGlobalServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                                     SERVICE_ACCEPT_SHUTDOWN |
                                                     SERVICE_ACCEPT_PAUSE_CONTINUE
                                                     | SERVICE_ACCEPT_NETBINDCHANGE
                                                        ;

        UpdateStatus();
    }

    if (ServiceStartup) {

        Error = DhcpRogueInit(NULL, DhcpGlobalRogueWaitEvent, DhcpGlobalProcessTerminationEvent);
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_INIT, "DhcpRogueInit: %ld\n", Error));
            return Error;
        }

        //
        // finally set the server startup time.
        //

        DhcpGlobalServerStartTime = DhcpGetDateTime();

        Error = InitializeRpc();
        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS, "Rpc initialization failed, %ld.\n", Error ));

            DhcpServerEventLog(
                EVENT_SERVER_INIT_RPC_FAILED,
                EVENTLOG_ERROR_TYPE,
                Error );

            return(Error);
        }

        DhcpPrint(( DEBUG_INIT, "Rpc initialization succeeded.\n", 0));

        //
        // send heart beat to the service controller.
        //
        //

        DhcpGlobalServiceStatus.dwCheckPoint++;
        UpdateStatus();

    }

    return ERROR_SUCCESS;
}



VOID
Shutdown(
    IN DWORD ErrorCode,
    BOOLEAN ServiceEnd,
    BOOLEAN RestartClose
    )
/*++

Routine Description:

    This function shuts down the dhcp service.

Arguments:

    ErrorCode - Supplies the error code of the failure

Return Value:

    None.

--*/
{
    DWORD   Error;
    BOOL    fThreadPoolIsEmpty;
    DWORD   i;

    if (ServiceEnd) {

        DhcpPrint((DEBUG_MISC, "Shutdown started ..\n" ));


        // don't service any more requests (no need for crit sect, it's ok to
        // service one or two more requests if we hit that timing window)

        DhcpGlobalOkToService = FALSE;

        //
        // note that the service is stopping..
        //

        DhcpGlobalServiceStopping = TRUE;

        //
        // record the shutdown in audit log
        //

        DhcpUpdateAuditLog(
            DHCP_IP_LOG_STOP,
            GETSTRING( DHCP_IP_LOG_STOP_NAME ),
            0,
            NULL,
            0,
            NULL
        );

        //
        // LOG an event if this is not a normal shutdown.
        //

        if( ErrorCode != ERROR_SUCCESS ) {

            DhcpServerEventLog(
                EVENT_SERVER_SHUTDOWN,
                EVENTLOG_ERROR_TYPE,
                ErrorCode );

        }

        //
        // Service is shuting down, may be due to some service problem or
        // the administrator is stopping the service. Inform the service
        // controller.
        //

        DhcpGlobalServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        DhcpGlobalServiceStatus.dwCheckPoint = 1;

        //
        // Send the status response.
        //

        UpdateStatus();

        //
        // stop RPC interface.
        //

        if( DhcpGlobalRpcStarted ) {

            RPC_BINDING_VECTOR *bindingVector;

            Error = RpcServerInqBindings(&bindingVector);
            DhcpAssert( Error == RPC_S_OK );

            if (Error == RPC_S_OK) {

                Error = RpcEpUnregister(
                                dhcpsrv_ServerIfHandle,
                                bindingVector,
                                NULL );               // Uuid vector.

                DhcpAssert( Error == RPC_S_OK );

                Error = RpcEpUnregister(
                                dhcpsrv2_ServerIfHandle,
                                bindingVector,
                                NULL );               // Uuid vector.

                DhcpAssert( Error == RPC_S_OK );

                //
                // free binding vector.
                //

                Error = RpcBindingVectorFree( &bindingVector );

                DhcpAssert( Error == RPC_S_OK );
            }


            //
            // wait for all calls to complete.
            //

            Error = RpcServerUnregisterIf( dhcpsrv_ServerIfHandle, 0, TRUE );

            DhcpAssert( Error == ERROR_SUCCESS );
            Error = RpcServerUnregisterIf( dhcpsrv2_ServerIfHandle, 0, TRUE );

            DhcpAssert( Error == ERROR_SUCCESS );

            //
            // stop server listen.
            //

            Error = TcpsvcsGlobalData->StopRpcServerListen();

            DhcpAssert( Error == ERROR_SUCCESS );

            DhcpGlobalRpcStarted = FALSE;
        }

        DhcpPrint((DEBUG_MISC, "RPC shut down.\n" ));

        //
        // send heart beat to the service controller.
        //
        //

        DhcpGlobalServiceStatus.dwCheckPoint++;
        UpdateStatus();

        if( DhcpGlobalProcessTerminationEvent != NULL ) {

            DATE_TIME TimeNow;

            //
            // set Termination Event so that other threads know about the
            // shut down.
            //

            SetEvent( DhcpGlobalProcessTerminationEvent );

            //
            // ENDPOINT: Cleanup rogue detection sockets..
            //

            //
            // shut down client to server : This kills all processing threads, msg thread
            // and the ping threads
            //

            DhcpCleanupClientToServer();

            //
            // wait for the rogue detect thread to complete.
            // (this thread will be alive only if we still haven't determined if
            // this dhcp server is authorized to service, or if we are running on
            // SAM server).
            //

            DhcpRogueCleanup(NULL);

            if (DhcpGlobalDSDomainAnsi) {
                LocalFree(DhcpGlobalDSDomainAnsi);
                DhcpGlobalDSDomainAnsi = NULL;
            }

            //
            // Cleanup all pending client requests.
            //

            // TimeNow = DhcpGetDateTime();
            // Error = CleanupClientRequests( &TimeNow, TRUE );
        }

        DhcpPrint((DEBUG_MISC, "Client requests cleaned up.\n" ));

        //
        // send heart beat to the service controller.
        //
        //

        DhcpGlobalServiceStatus.dwCheckPoint++;
        UpdateStatus();


        //
        // cleanup perf related stuff
        //
        PerfCleanup();

        //
        // cleanup Dhcp DNS
        //

        if( !USE_NO_DNS && DnsStarted) {    //  Get DNS to quit, as it quits fast
            if(ERROR_SUCCESS != DnsDhcpSrvRegisterTerm()) {
                DhcpAssert(FALSE);
            }
            DnsStarted = FALSE;
        }

        DhcpCleanupDnsMemory();             //   Cleanup all memory that was allocated to do DNS stuff

        DhcpPrint((DEBUG_MISC, "DhcpDns cleaned up.\n"));

        //
        // Cleanup Regsitry.
        //

        DhcpCleanupRegistry();

        DhcpPrint((DEBUG_MISC, "Registry cleaned up.\n" ));

        //
        // Cleanup database.
        //

        //
        // send heart beat to the service controller. Also set the
        // service controller wait time to a large value because the
        // database cleanup may potentially takes long time.
        //

        DhcpGlobalServiceStatus.dwWaitHint = 5 * 60 * 1000; // 5 mins.
        DhcpGlobalServiceStatus.dwCheckPoint++;
        UpdateStatus();

        DhcpCleanupDatabase( ErrorCode );

        DhcpPrint((DEBUG_MISC, "Database cleaned up.\n" ));

        //
        // send heart beat to the service controller and
        // reset wait time.
        //

        DhcpGlobalServiceStatus.dwWaitHint = 60 * 1000; // 1 mins.
        DhcpGlobalServiceStatus.dwCheckPoint++;
        UpdateStatus();


        CalloutCleanup();

        //
        // cleanup misc stuff
        //

        DhcpAuditLogCleanup();
    }
    if (!RestartClose) {

        DhcpCleanupSecrets();
    }

    if (ServiceEnd) {

        CleanupData();

        DhcpPrint((DEBUG_MISC, "Shutdown Completed.\n" ));
    }

    if (!RestartClose) {

        DeleteCriticalSection(&DhcpGlobalInProgressCritSect);
        DeleteCriticalSection( &g_ProcessMessageCritSect );
        DeleteCriticalSection(&DhcpGlobalMemoryCritSect);

        DhcpDsCleanupDS();

        FreeStrings();
#if DBG

        EnterCriticalSection( &DhcpGlobalDebugFileCritSect );
        if ( DhcpGlobalDebugFileHandle != NULL ) {
            CloseHandle( DhcpGlobalDebugFileHandle );
            DhcpGlobalDebugFileHandle = NULL;
        }

        if( DhcpGlobalDebugSharePath != NULL ) {
            DhcpFreeMemory( DhcpGlobalDebugSharePath );
            DhcpGlobalDebugSharePath = NULL;
        }
        LeaveCriticalSection( &DhcpGlobalDebugFileCritSect );

#endif DBG

        //
        // don't use DhcpPrint past this point
        //

        //
        // unitialize the debug heap
        //

        UNINIT_DEBUG_HEAP();
    }

    if (ServiceEnd) {
        DhcpGlobalServiceStatus.dwCurrentState = SERVICE_STOPPED;
        DhcpGlobalServiceStatus.dwControlsAccepted = 0;
        DhcpGlobalServiceStatus.dwWin32ExitCode = ErrorCode;
        DhcpGlobalServiceStatus.dwServiceSpecificExitCode = 0;

        DhcpGlobalServiceStatus.dwCheckPoint = 0;
        DhcpGlobalServiceStatus.dwWaitHint = 0;

        UpdateStatus();

        //
        // Free up the jet dll handle.
        //
    }
    if (!RestartClose) {

        DhcpMemCleanup();
    }
}


VOID
ServiceEntry(
    DWORD NumArgs,
    LPWSTR *ArgsArray,
    IN PTCPSVCS_GLOBAL_DATA pGlobalData
    )
/*++

Routine Description:

    This is the main routine of the DHCP server service.  After
    the service has been initialized, this thread will wait on
    DhcpGlobalProcessTerminationEvent for a signal to terminate the service.

Arguments:

    NumArgs - Supplies the number of strings specified in ArgsArray.

    ArgsArray -  Supplies string arguments that are specified in the
        StartService API call.  This parameter is ignored.

Return Value:

    None.

--*/
{
    DWORD Error;

    UNREFERENCED_PARAMETER(NumArgs);
    UNREFERENCED_PARAMETER(ArgsArray);

    //
    // copy the process global data pointer to service global variable.
    //

    TcpsvcsGlobalData = pGlobalData;
#if DBG
    DhcpGlobalDebugFlag = DEBUG_LOG_IN_FILE | DEBUG_ALLOC;
#endif

    Error = DhcpInitGlobalData( TRUE );

    if ( Error == ERROR_SUCCESS) {

        //
        // record the startup in audit log
        //

        DhcpUpdateAuditLog(
                    DHCP_IP_LOG_START,
                    GETSTRING( DHCP_IP_LOG_START_NAME ),
                    0,
                    NULL,
                    0,
                    NULL
                    );

        //
        // perform Scavenge task until we are told to stop.
        //

        Error = Scavenger();
    }

    InformBinl(DHCP_STOPPED);
    DhcpCleanUpGlobalData( Error, TRUE );
    InformBinl(DHCP_READY_TO_UNLOAD);
    return;
}

BOOLEAN
DhcpDllInitialize(
    IN HINSTANCE DllHandle,
    IN ULONG Reason,
    IN LPVOID lpReserved OPTIONAL
    )
{
    NTSTATUS Error;
    extern HMODULE Self ;

    Self = DllHandle;

    //
    // Handle attaching dhcpssvc.dll to a new process.
    //

    if (Reason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls( DllHandle );

        //
        //  we need to initialize everything that other components may need
        //  even if our service isn't running.
        //

        InitializeCriticalSection(&DhcpGlobalBinlSyncCritSect);
        InitializeCriticalSection(&DhcpGlobalEndPointCS);
#if DBG
        InitializeCriticalSection( &DhcpGlobalDebugFileCritSect );
#endif DBG

        //
        // When DLL_PROCESS_DETACH and lpReserved is NULL, then a FreeLibrary
        // call is being made.  If lpReserved is Non-NULL, and ExitProcess is
        // in progress.  These cleanup routines will only be called when
        // a FreeLibrary is being called.  ExitProcess will automatically
        // clean up all process resources, handles, and pending io.
        //
    } else if ((Reason == DLL_PROCESS_DETACH) &&
               (lpReserved == NULL)) {

        DeleteCriticalSection( &DhcpGlobalBinlSyncCritSect );
        DeleteCriticalSection( &DhcpGlobalEndPointCS );
#if DBG
        DeleteCriticalSection( &DhcpGlobalDebugFileCritSect );
#endif DBG

    }

    return TRUE;
}


//--------------------------------------------------------------------------------
//  End of file
//--------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\mdhcpsrv.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/

#include "mdhcpdb.h"
#include "mdhcppro.h"
#include <ws2tcpip.h>


#ifdef MADCAP_DATA_ALLOCATE
#define MADCAP_EXTERN
#else
#define MADCAP_EXTERN extern
#endif

// mib counters
typedef
struct _MADCAP_MIB_COUNTERS {
    DWORD   Discovers;
    DWORD Offers;
    DWORD Requests;
    DWORD Renews;
    DWORD Acks;
    DWORD Naks;
    DWORD Releases;
    DWORD Informs;
} MADCAP_MIB_COUNTERS, *LPMADCAP_MIB_COUNTERS;

// externs
MADCAP_EXTERN TABLE_INFO *MadcapGlobalClientTable;   // point to static memory.
MADCAP_EXTERN JET_TABLEID MadcapGlobalClientTableHandle;
MADCAP_EXTERN int  MadcapGlobalTTL;
MADCAP_EXTERN MADCAP_MIB_COUNTERS MadcapGlobalMibCounters;

// misc stuff which eventually go in the right place.

#define     INVALID_MSCOPE_ID      0x0
#define     INVALID_MSCOPE_NAME    NULL


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\mdhcppro.h ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/

DWORD
MadcapJetOpenKey(
    PDB_CTX pDbCtx,
    char *ColumnName,
    PVOID Key,
    DWORD KeySize
);


DWORD
MadcapJetBeginTransaction(
    PDB_CTX pDbCtx
);

DWORD
MadcapJetRollBack(
    PDB_CTX pDbCtx
);

DWORD
MadcapJetCommitTransaction(
    PDB_CTX pDbCtx
);

DWORD
MadcapJetPrepareUpdate(
    PDB_CTX pDbCtx,
    char *ColumnName,
    PVOID Key,
    DWORD KeySize,
    BOOL NewRecord
);

DWORD
MadcapJetCommitUpdate(
    PDB_CTX pDbCtx
);

DWORD
MadcapJetSetValue(
    PDB_CTX pDbCtx,
    JET_COLUMNID KeyColumnId,
    PVOID Data,
    DWORD DataSize
);

DWORD
MadcapJetGetValue(
    PDB_CTX pDbCtx,
    JET_COLUMNID ColumnId,
    PVOID Data,
    PDWORD DataSize
);

DWORD
MadcapJetPrepareSearch(
    PDB_CTX pDbCtx,
    char *ColumnName,
    BOOL SearchFromStart,
    PVOID Key,
    DWORD KeySize
);

DWORD
MadcapJetNextRecord(
    PDB_CTX pDbCtx
);

DWORD
MadcapJetDeleteCurrentRecord(
    PDB_CTX pDbCtx
);

DWORD
MadcapJetGetRecordPosition(
    IN PDB_CTX pDbCtx,
    IN JET_RECPOS *pRecPos,
    IN DWORD    Size
);


// mdhcpsrc.c
DWORD
DhcpInitializeMadcap();

DWORD
ProcessMadcapInform(
    LPDHCP_REQUEST_CONTEXT      RequestContext,
    LPMADCAP_SERVER_OPTIONS     DhcpOptions,
    PBOOL                       SendResponse
    );

DWORD
ProcessMadcapDiscover(
    LPDHCP_REQUEST_CONTEXT      pCtxt,
    LPMADCAP_SERVER_OPTIONS     pOptions,
    PBOOL                       SendResponse
    );


DWORD
ProcessMadcapDiscoverAndRequest(
    LPDHCP_REQUEST_CONTEXT      pCtxt,
    LPMADCAP_SERVER_OPTIONS     pOptions,
    WORD                        MsgType,
    PBOOL                       SendResponse
    );

DWORD
ProcessMadcapRenew(
    LPDHCP_REQUEST_CONTEXT      pCtxt,
    LPMADCAP_SERVER_OPTIONS     pOptions,
    PBOOL                       SendResponse
    );

DWORD
ProcessMadcapRelease(
    LPDHCP_REQUEST_CONTEXT      pCtxt,
    LPMADCAP_SERVER_OPTIONS     pOptions,
    PBOOL                       SendResponse
    );

DWORD
MadcapReleaseAddress(
    IN      PM_SUBNET           pSubnet,
    IN      DHCP_IP_ADDRESS        Address
);

// mdhcpmsc.c

BOOL
MadcapGetIpAddressFromClientId(
    PBYTE ClientId,
    DWORD ClientIdLength,
    PVOID IpAddress,
    PDWORD IpAddressLength
);

BOOL
MadcapGetClientIdFromIpAddress(
    PBYTE IpAddress,
    DWORD IpAddressLength,
    PVOID ClientId,
    PDWORD ClientIdLength
);

DWORD
MadcapGetRemainingLeaseTime(
    PBYTE ClientId,
    DWORD ClientIdLength,
    DWORD *LeaseTime
);

DWORD
MadcapCreateClientEntry(
    LPBYTE                ClientIpAddress,
    DWORD                 ClientIpAddressLength,
    DWORD                 ScopeId,
    LPBYTE                ClientId,
    DWORD                 ClientIdLength,
    LPWSTR                ClientInfo OPTIONAL,
    DATE_TIME             LeaseStarts,
    DATE_TIME             LeaseTerminates,
    DWORD                 ServerIpAddress,
    BYTE                  AddressState,
    DWORD                 AddressFlags,
    BOOL                  OpenExisting
    );

DWORD
MadcapValidateClientByClientId(
    LPBYTE ClientIpAddress,
    DWORD   ClientIpAddressLength,
    PVOID   ClientId,
    DWORD   ClientIdLength
    );

DWORD
MadcapRemoveClientEntryByClientId(
    LPBYTE  ClientId,
    DWORD   ClientIdLength,
    BOOL ReleaseAddress
    );

DWORD
MadcapRemoveClientEntryByIpAddress(
    DHCP_IP_ADDRESS ClientIpAddress,
    BOOL ReleaseAddress
    );


DWORD
MadcapRetractOffer(                                      // remove pending list and database entries
    IN      PDHCP_REQUEST_CONTEXT  RequestContext,
    IN      LPMADCAP_SERVER_OPTIONS  DhcpOptions,
    IN      LPBYTE                 ClientId,
    IN      DWORD                  ClientIdLength
);

MadcapGetCurrentClientInfo(
    LPDHCP_MCLIENT_INFO *ClientInfo,
    LPDWORD InfoSize, // optional parameter.
    LPBOOL ValidClient, // optional parameter.
    DWORD  MScopeId
    );

DWORD
GetMCastDatabaseList(
    DWORD   ScopeId,
    LPDHCP_IP_ADDRESS *DatabaseList,
    DWORD *DatabaseListCount
    );

DWORD
DhcpDeleteMScopeClients(
    DWORD MScopeId
    );

DWORD
ChangeMScopeIdInDb(
    DWORD   OldMScopeId,
    DWORD   NewMScopeId
    );

DWORD
CleanupMCastDatabase(
    IN      DATE_TIME*             TimeNow,            // current time standard
    IN      DATE_TIME*             DoomTime,           // Time when the records become 'doom'
    IN      BOOL                   DeleteExpiredLeases,// expired leases be deleted right away? or just set state="doomed"
    OUT     ULONG*                 nExpiredLeases,
    OUT     ULONG*                 nDeletedLeases
);

VOID
DeleteExpiredMcastScopes(
    IN      DATE_TIME*             TimeNow
    );

// Other missing prototypes.
// MBUG: these guys should eventually go into the right place.


VOID
PrintHWAddress(
    IN      LPBYTE                 HWAddress,
    IN      LONG                   HWAddressLength
);

























=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\mdhcpsrv.c ===
/*++

  Copyright (c) 1994  Microsoft Corporation

  Module Name:

  mdhcpdb.c

  Abstract:

  This module contains the functions for interfacing with the JET
  database API pertaining to MADCAP.

  Author:

  Munil Shah

  Environment:

  User Mode - Win32

  Revision History:

  --*/

#include "dhcppch.h"
#define MADCAP_DATA_ALLOCATE    // allocate global data defined in mdhcpsrv.h
#include "mdhcpsrv.h"


#define     DEF_ERROR_OPT_SIZE      16
#define     DEFAULT_LEASE_DURATION  (30*24*60*60)

DWORD
DhcpInitializeMadcap()
{
    RtlZeroMemory(&MadcapGlobalMibCounters,sizeof(MadcapGlobalMibCounters));
    return ERROR_SUCCESS;
}


WIDE_OPTION UNALIGNED *                                           // ptr to add additional options
FormatMadcapCommonMessage(                                 // format the packet for an INFORM
    IN      LPDHCP_REQUEST_CONTEXT pCtxt,    // format for this context
    IN      LPMADCAP_SERVER_OPTIONS  pOptions,
    IN      BYTE                   MessageType,
    IN      DHCP_IP_ADDRESS        ServerAddress
) {

    DWORD                          size;
    DWORD                          Error;
    WIDE_OPTION  UNALIGNED *       option;
    LPBYTE                         OptionEnd;
    PMADCAP_MESSAGE                dhcpReceiveMessage, dhcpSendMessage;
    BYTE                           ServerId[6];
    WORD                           AddrFamily = htons(MADCAP_ADDR_FAMILY_V4);


    dhcpReceiveMessage  = (PMADCAP_MESSAGE)pCtxt->ReceiveBuffer;
    dhcpSendMessage     = (PMADCAP_MESSAGE)pCtxt->SendBuffer;

    RtlZeroMemory( dhcpSendMessage, DHCP_SEND_MESSAGE_SIZE );

    dhcpSendMessage->Version = MADCAP_VERSION;
    dhcpSendMessage->MessageType = MessageType;
    dhcpSendMessage->AddressFamily = htons(MADCAP_ADDR_FAMILY_V4);
    dhcpSendMessage->TransactionID = dhcpReceiveMessage->TransactionID;

    option = &dhcpSendMessage->Option;
    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;



    option = AppendWideOption(        // ==> use this client id as option
        option,
        MADCAP_OPTION_LEASE_ID,
        pOptions->Guid,
        (WORD)pOptions->GuidLength,
        OptionEnd
    );

    memcpy(ServerId, &AddrFamily, 2);
    memcpy(ServerId + 2, &ServerAddress, 4);

    option = AppendWideOption(
        option,
        MADCAP_OPTION_SERVER_ID,
        &ServerId,
        sizeof(ServerId),
        OptionEnd );

    return( option );
}

BOOL
ValidateMadcapMessage(
    IN      LPMADCAP_SERVER_OPTIONS     pOptions,
    IN      WORD                        MessageType,
    IN  OUT PBYTE                       NakData,
    IN  OUT WORD                        *NakDataLen,
    OUT     BOOL                        *DropIt
    )

/*++

Routine Description:

   This routine validates madcap message for any semantic errors.If
   there is any error, this routine provides information for the
   ERROR option to be sent via NAK.

Arguments:

   pOptions - Pointer to incoming options.

   MessageType - The type of message

   NakData - The data pertaining to error option. This buffer is allocated
             by the caller.

   NakDataLen - (IN) Length of the above buffer. (OUT) length of error option

   DropIt - whether or not this message should be dropped instead of nak.

Return Value:

   TRUE - if no NAK is to be generated. FALSE otherwise.

--*/
{
    WORD    Ecode;
    PBYTE   ExtraData;
    WORD    i;

    // assume minumum size, currently all types of errors are really small
    DhcpAssert(*NakDataLen >= 6);
    *DropIt = FALSE;       // return value
    *NakDataLen = 0;       // return value
    Ecode = -1;            // assume no error
    ExtraData = NakData+2;   // start past ecode

    do {
        // first check for common errors
        // in general we do not want to NAK packets with missing options
        // even though the draft says we should. Those packets are seriously
        // broken and there is not much value in naking it.

        // is current time ok?
        if (pOptions->Time) {
            DWORD   Skew;
            DWORD   TimeNow = (DWORD)time(NULL);
            Skew =  abs(ntohl(*pOptions->Time) - TimeNow);
            if ( Skew > DhcpGlobalClockSkewAllowance) {
                Ecode = MADCAP_NAK_CLOCK_SKEW;
                *(DWORD UNALIGNED *)(ExtraData) = htonl(Skew);
                *NakDataLen += 4;
                DhcpPrint(( DEBUG_ERRORS, "ValidateMadcapMessage - clock skew %ld\n",Skew ));
                break;
            }
        } else {
            // we better not have start time option, because that
            // must be accompanied by current time option.
            if (pOptions->LeaseStartTime || pOptions->MaxStartTime) {
                Ecode = MADCAP_NAK_INVALID_REQ;
                *(WORD UNALIGNED *)(ExtraData) = htons(MADCAP_OPTION_TIME);
                *NakDataLen += 4;
                DhcpPrint(( DEBUG_ERRORS, "ValidateMadcapMessage - missing time option\n"));
                break;
            }
        }

        // is client asking for some required features which we don't support?
        // currently we don't support any optional features
        if (pOptions->Features[REQUIRED_FEATURES]) {
            Ecode = MADCAP_NAK_UNSUPPORTED_FEATURE;
            RtlCopyMemory(
                ExtraData,
                &pOptions->Features[REQUIRED_FEATURES],
                pOptions->FeatureCount[REQUIRED_FEATURES]*2
                );
            *NakDataLen += pOptions->FeatureCount[REQUIRED_FEATURES]*2;
            DhcpPrint(( DEBUG_ERRORS,
                        "ValidateMadcapMessage - Required feature %d not supported\n",
                        *(pOptions->Features[REQUIRED_FEATURES]) ));
            break;
        }

	// Check for client id. We NAK the message with zero length client id
	if (0 == pOptions->GuidLength) {
	  *(WORD UNALIGNED *)(NakData) = htons(MADCAP_OPTION_LEASE_ID);
	  *NakDataLen += 2;
	  return FALSE;
	} // if

        // now check for errors specific to message
        switch (MessageType) {
        case MADCAP_INFORM_MESSAGE: {
            WORD    MustOpt[] = {MADCAP_OPTION_LEASE_ID, MADCAP_OPTION_REQUEST_LIST};
            for (i=0; i<sizeof(MustOpt)/sizeof(MustOpt[0]); i++) {
                if (!pOptions->OptPresent[MustOpt[i]]) {
                    *DropIt = TRUE;
                    DhcpPrint(( DEBUG_ERRORS, "ValidateMadcapMessage - INFORM with no %d option\n",MustOpt[i] ));
                    break;
                }
            }
            break;
        }
        case MADCAP_DISCOVER_MESSAGE: {
            WORD    MustOpt[] = {MADCAP_OPTION_LEASE_ID, MADCAP_OPTION_MCAST_SCOPE};
            for (i=0; i<sizeof(MustOpt)/sizeof(MustOpt[0]); i++) {
                if (!pOptions->OptPresent[MustOpt[i]]) {
                    *DropIt = TRUE;
                    DhcpPrint(( DEBUG_ERRORS, "ValidateMadcapMessage - DISCOVER with no %d option\n",MustOpt[i] ));
                    break;
                }
            }
            break;
        }
        case MADCAP_REQUEST_MESSAGE: {
            WORD    MustOpt[] = {MADCAP_OPTION_LEASE_ID, MADCAP_OPTION_MCAST_SCOPE};
            for (i=0; i<sizeof(MustOpt)/sizeof(MustOpt[0]); i++) {
                if (!pOptions->OptPresent[MustOpt[i]]) {
                    *DropIt = TRUE;
                    DhcpPrint(( DEBUG_ERRORS, "ValidateMadcapMessage - REQUEST with no %d option\n",MustOpt[i] ));
                    break;
                }
            }
            break;
        }
        case MADCAP_RENEW_MESSAGE: {
            WORD    MustOpt[] = {MADCAP_OPTION_LEASE_ID};
            for (i=0; i<sizeof(MustOpt)/sizeof(MustOpt[0]); i++) {
                if (!pOptions->OptPresent[MustOpt[i]]) {
                    *DropIt = TRUE;
                    DhcpPrint(( DEBUG_ERRORS, "ValidateMadcapMessage - RENEW with no %d option\n",MustOpt[i] ));
                    break;
                }
            }
            break;
        }
        case MADCAP_RELEASE_MESSAGE: {
            WORD    MustOpt[] = {MADCAP_OPTION_LEASE_ID};
            for (i=0; i<sizeof(MustOpt)/sizeof(MustOpt[0]); i++) {
                if (!pOptions->OptPresent[MustOpt[i]]) {
                    *DropIt = TRUE;
                    DhcpPrint(( DEBUG_ERRORS, "ValidateMadcapMessage - RENEW with no %d option\n",MustOpt[i] ));
                    break;
                }
            }
            break;
        }
        default:
            DhcpAssert(FALSE);
        }
    } while ( FALSE );

    if (*DropIt) {
        return FALSE;
    } else if ((WORD)-1 != Ecode) {
        *(WORD UNALIGNED *)(NakData) = htons(Ecode);
        *NakDataLen += 2;
        return FALSE;
    } else {
        return TRUE;
    }
}

WIDE_OPTION UNALIGNED *
ConsiderAppendingMadcapOption(                               // conditionally append option to message (if the option is valid)
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,         // ctxt of the client
    IN      WIDE_OPTION  UNALIGNED *Option,
    IN      WORD                 OptionType,         // what option is this?
    IN      LPBYTE                 OptionEnd          // cutoff upto which we can fill options
    )

/*++

Routine Description:

   This routine tries to verify if it is OK to append the option requested and
   if it is not one of the options manually added by the DHCP server, then it is
   appended at the point given by "Option" (assuming it would fit in without outrunning
   "OptionEnd" ).   The format in which it is appended is as per the wire protocol.

Arguments:

   ClientCtxt - This is the bunch of parameters like client class, vendor class etc.

   Option - The location where to start appending the option

   OptionType - The actual OPTION ID to retrieve the value of and append.

   OptionEnd - The end marker for this buffer (the option is not appended if we
       would have to overrun this marker while trying to append)

Return Value:

   The location in memory AFTER the option has been appended (in case the option was
   not appended, this would be the same as "Option" ).

--*/

{
    LPBYTE                         optionValue;
    WORD                           optionSize;
    DWORD                          status;
    DWORD                          option4BVal;


    switch ( OptionType ) {
    case MADCAP_OPTION_MCAST_SCOPE_LIST:
        status = MadcapGetMScopeListOption(
            ClientCtxt->EndPointIpAddress,
            &optionValue,
            &optionSize
        );

        if ( status == ERROR_SUCCESS ) {
            Option = AppendWideOption(
                Option,
                OptionType,
                (PVOID)optionValue,
                optionSize,
                OptionEnd
            );

            //
            // Release the buffer returned by DhcpGetParameter()
            //

            DhcpFreeMemory( optionValue );

        }
        break;

    case MADCAP_OPTION_TIME:
        option4BVal = (DWORD) time(NULL);
        optionSize = 4;
        optionValue = (LPBYTE)&option4BVal;
        Option = AppendWideOption(
            Option,
            OptionType,
            (PVOID)optionValue,
            optionSize,
            OptionEnd
        );
        break;
    case MADCAP_OPTION_FEATURE_LIST: {
        // we dont support any features.
        BYTE    Features[6] = {0,0,0,0,0,0};
        optionSize = 6;
        optionValue = Features;
        Option = AppendWideOption(
            Option,
            OptionType,
            (PVOID)optionValue,
            optionSize,
            OptionEnd
        );
    }
    break;
    default:

        break;

    }

    return Option;
}

WIDE_OPTION UNALIGNED *
AppendMadcapRequestedParameters(                       // if the client requested parameters, add those to the message
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,         // clients context
    IN      LPBYTE                 RequestedList,      // list of options requested by client
    IN      DWORD                  ListLength,         // how long is the list
    OUT     WIDE_OPTION UNALIGNED *Option,             // this is where to start adding the options
    IN      LPBYTE                 OptionEnd          // cutoff pt in the buffer up to which options can be filled
)
{
    WORD           OptionType;
    WIDE_OPTION UNALIGNED *NextOption;
    WIDE_OPTION UNALIGNED *PrevOption;

    NextOption = PrevOption = Option;

    while ( ListLength >= 2) {
        OptionType = ntohs(*(WORD UNALIGNED *)RequestedList);
        NextOption = ConsiderAppendingMadcapOption(
            ClientCtxt,
            PrevOption,
            OptionType,
            OptionEnd
        );
        if (NextOption == PrevOption) {
            // this means that we could not add this requested option
            // fail the whole request by sending the original option
            // pointer.

            // Maybe not!
            // return Option;
            DhcpPrint((DEBUG_ERRORS,"AppendMadcapRequestedParameters: did not add requested opt %ld\n",OptionType));
        }
        ListLength -= 2;
        RequestedList += 2;
        PrevOption = NextOption;
    }

    return NextOption;
}

DWORD
ProcessMadcapInform(
    LPDHCP_REQUEST_CONTEXT      pCtxt,
    LPMADCAP_SERVER_OPTIONS     pOptions,
    PBOOL                       SendResponse
    )
    /*++
      ...
      --*/
{
    DWORD                       Error;
    BYTE                       *ClientId,
                               *OptionEnd ;
    DWORD                       ClientIdLength;
    WIDE_OPTION UNALIGNED      *Option;
    LPMADCAP_MESSAGE            dhcpReceiveMessage,dhcpSendMessage;
    WIDE_OPTION UNALIGNED      *CurrOption;
    WCHAR                       ClientInfoBuff[DHCP_IP_KEY_LEN];
    WCHAR                      *ClientInfo;
    DHCP_IP_ADDRESS             ClientIpAddress;
    BYTE                        NakData[DEF_ERROR_OPT_SIZE];
    WORD                        NakDataLen;
    BOOL                        DropIt;

    DhcpPrint((DEBUG_MSTOC, "Processing Madcap Inform\n"));

    dhcpReceiveMessage  = (LPMADCAP_MESSAGE)pCtxt->ReceiveBuffer;
    dhcpSendMessage     = (LPMADCAP_MESSAGE)pCtxt->SendBuffer;
    *SendResponse       = DropIt = FALSE;
    Option              = NULL;
    OptionEnd           = NULL;
    ClientId            = pOptions->Guid;
    ClientIdLength      = pOptions->GuidLength;
    ClientIpAddress     = ((struct sockaddr_in *)&pCtxt->SourceName)->sin_addr.s_addr;
    ClientInfo          = DhcpRegIpAddressToKey(ntohl(ClientIpAddress),ClientInfoBuff);
    Error               = ERROR_SUCCESS;

    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Informs);

    // validation
    NakDataLen = DEF_ERROR_OPT_SIZE;
    if (!ValidateMadcapMessage(
            pOptions,
            MADCAP_INFORM_MESSAGE,
            NakData,
            &NakDataLen,
            &DropIt
            )){
        if (DropIt) {
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }
        goto Nak;
    }
    // Initialize nak data
    *(WORD UNALIGNED *)NakData = htons(MADCAP_NAK_REQ_NOT_COMPLETED);
    *(WORD UNALIGNED *)(NakData+2) = htons(MADCAP_OPTION_NONE);
    NakDataLen = 4;


    // Here come the actual formatting of the ack!
    Option = FormatMadcapCommonMessage(
        pCtxt,
        pOptions,
        MADCAP_ACK_MESSAGE,
        pCtxt->EndPointIpAddress
        );

    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    // Finally, add client requested parameters.
    CurrOption = Option;
    Option = AppendMadcapRequestedParameters(
                pCtxt,
                pOptions->RequestList,
                pOptions->RequestListLength,
                Option,
                OptionEnd
                );
    //check if we could add any options.if we didn't then
    // we don't want to send ack.
    if (CurrOption == Option) {
        Error = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }

    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    pCtxt->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);
    *SendResponse = TRUE;
    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Acks);
    DhcpPrint(( DEBUG_MSTOC,"MadcapInform Acked\n" ));
    goto Cleanup;

Nak:
    // Here come the actual formatting of the Nak!
    Option = FormatMadcapCommonMessage(
        pCtxt,
        pOptions,
        MADCAP_NACK_MESSAGE,
        pCtxt->EndPointIpAddress
        );


    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_ERROR,
                 NakData,
                 NakDataLen,
                 OptionEnd );

    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    pCtxt->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);

    // dont log all kinds of NACK. Only ones which are useful for diagnosis
    if (ClientIdLength) {
        DhcpUpdateAuditLog(
            DHCP_IP_LOG_NACK,
            GETSTRING( DHCP_IP_LOG_NACK_NAME ),
            0,
            ClientId,
            ClientIdLength,
            ClientInfo
        );
    }

    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Naks);
    *SendResponse = TRUE;
    Error = ERROR_SUCCESS;
    DhcpPrint(( DEBUG_MSTOC,"MadcapInform Nacked\n" ));


Cleanup:
    if (ERROR_SUCCESS != Error) {
        DhcpPrint(( DEBUG_MSTOC,"MadcapInform Dropped\n" ));
    }

    return( Error );
}

DWORD
MadcapIsRequestedAddressValid(
    LPDHCP_REQUEST_CONTEXT  pCtxt,
    DHCP_IP_ADDRESS         RequestedIpAddress
    )
{
    DWORD   Error;
    //
    // check requested IP address belongs to the appropriate net and
    // it is free.
    //
    if( DhcpSubnetIsAddressExcluded(pCtxt->Subnet, RequestedIpAddress ) ||
        DhcpSubnetIsAddressOutOfRange( pCtxt->Subnet, RequestedIpAddress, FALSE )) {
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    if( DhcpRequestSpecificAddress(pCtxt, RequestedIpAddress) ) {
        // sure, we can offer the requested address.
        return ERROR_SUCCESS;
    } else {
        PBYTE StoredClientId;
        DWORD StoredClientIdLength;
        DHCP_IP_ADDRESS RequestedNetIpAddress;
        BOOL Found;

        // check to see the requested address is a reconciled address, if so
        // we can give it to this requesting client.
        LOCK_DATABASE();
        StoredClientIdLength = 0;
        Found = MadcapGetClientIdFromIpAddress(
                    (PBYTE)&RequestedIpAddress,
                    sizeof ( RequestedIpAddress),
                    &StoredClientId,
                    &StoredClientIdLength
                    );

        UNLOCK_DATABASE();
        Error = ERROR_DHCP_INVALID_DHCP_CLIENT;
        if ( Found ) {
            LPSTR IpAddressString;


            // match the client id and client ipaddress string.
            RequestedNetIpAddress = ntohl(RequestedIpAddress);
            IpAddressString = inet_ntoa( *(struct in_addr *)&RequestedNetIpAddress);

            if( (strlen(StoredClientId) == strlen(IpAddressString)) &&
                    (strcmp(StoredClientId, IpAddressString) == 0) ) {
                Error = ERROR_SUCCESS;
            }
            MIDL_user_free( StoredClientId);
        }
        return Error;
    }
}

DWORD
GetMCastLeaseInfo(
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    OUT     LPDWORD                LeaseDurationPtr,
    IN      DWORD UNALIGNED       *RequestLeaseTime,
    IN      DWORD UNALIGNED       *MinLeaseTime,
    IN      DWORD UNALIGNED       *LeaseStartTime,
    IN      DWORD UNALIGNED       *MaxStartTime,
    OUT     WORD  UNALIGNED       *ErrorOption
)
/*++

Routine Description:


Arguments:

    ClientCtxt - The client ctxt structure for the client to be used to figure out
        the client class and other information.

    LeaseDurationPtr - This DWORD will be filled with the # of seconds the lease is
        to be given out to the client.

    RequestedLeaseTime -- If specified, and if this lease duration is lesser than
        the duration as specified in the configuration, then, this is the duration
        that the client would be returned in LeaseDurationPtr.

    MinLeaseTime - If specified, Minimum lease duration requested by client.

    LeaseStartTime - If specified, desired start time

    MaxStartTime - If specified, max start time

    ErrorOption - If anything fails, the option which caused this

Return Value:

    Win32 Error code.

--*/
{
    LPBYTE                         OptionData;
    DWORD                          Error;
    DWORD                          LocalLeaseDuration;
    DWORD                          LocalLeaseStartTime;
    DWORD                          LocalStartTime;
    DWORD                          OptionDataLength;
    DWORD                          dwUnused;
    DWORD                          LocalRequestedLeaseTime;

    LocalLeaseDuration = 0;
    LocalStartTime = 0;
    LocalRequestedLeaseTime = 0;
    LocalLeaseStartTime = 0;
    OptionDataLength = 0;
    OptionData = NULL;

    Error = DhcpGetParameter(
        0,
        ClientCtxt,
        MADCAP_OPTION_LEASE_TIME,
        &OptionData,
        &OptionDataLength,
        NULL /* dont care if this is reservation option, subnet option etc */
    );

    if ( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_ERRORS, "Unable to read lease value from mscope, %ld.\n", Error));
        LocalLeaseDuration = DEFAULT_LEASE_DURATION;
        OptionData = NULL;
        OptionDataLength = 0;
    } else {
        DhcpAssert( OptionDataLength == sizeof(LocalLeaseDuration) );
        LocalLeaseDuration = *(DWORD *)OptionData;
        LocalLeaseDuration = ntohl( LocalLeaseDuration );

        DhcpFreeMemory( OptionData );
        OptionData = NULL;
        OptionDataLength = 0;
    }

    // did client specify requested lease time?
    if ( ARGUMENT_PRESENT(RequestLeaseTime) ) {
        LocalRequestedLeaseTime =  ntohl( *RequestLeaseTime );
        // Add allowance for clock skew
        LocalRequestedLeaseTime += DhcpGlobalExtraAllocationTime;
    }

    // did client specify start time?
    if (ARGUMENT_PRESENT(LeaseStartTime)) {
        DWORD   CurrentTime = (DWORD)time(NULL);
        LocalLeaseStartTime = ntohl(*LeaseStartTime);
        // does his start time begin in future?
        if (LocalLeaseStartTime >= CurrentTime) {
            // since we always allocate at current time, we need to add
            // the slack for future start time.
            LocalRequestedLeaseTime += (LocalLeaseStartTime - CurrentTime);
        } else {
            // Wow! his start time begins in past!
            DWORD TimeInPast = CurrentTime - LocalLeaseStartTime;
            // cut his lease time by amount requeted in past
            if (LocalRequestedLeaseTime > TimeInPast) {
                LocalRequestedLeaseTime -= TimeInPast;
            } else {
                // this guy starts in past and ends in past! weird!
                *ErrorOption = htons(MADCAP_OPTION_START_TIME);
                return ERROR_DHCP_INVALID_DHCP_CLIENT;;
            }
        }
    }

    // If client requests a shorter lease than what we usually give, shorten it!
    if ( LocalLeaseDuration > LocalRequestedLeaseTime ) {
        if (LocalRequestedLeaseTime) {
            LocalLeaseDuration = LocalRequestedLeaseTime;
        }
    } else {
        // actually he is requesting more than what we can give.
        // if he requested min lease, we need to make sure we can honor it.
        if (ARGUMENT_PRESENT(MinLeaseTime)) {
            DWORD   LocalMinLeaseTime = ntohl(*MinLeaseTime);
            if (LocalMinLeaseTime > LocalLeaseDuration) {
                // we cannot honor his min lease time
                *ErrorOption = htons(MADCAP_OPTION_LEASE_TIME);
                return ERROR_DHCP_INVALID_DHCP_CLIENT;;
            }
        }
    }

    if (LocalLeaseDuration) {
        *LeaseDurationPtr = LocalLeaseDuration;
        return ERROR_SUCCESS;
    } else {
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

}

DWORD
ProcessMadcapDiscoverAndRequest(
    LPDHCP_REQUEST_CONTEXT      pCtxt,
    LPMADCAP_SERVER_OPTIONS     pOptions,
    WORD                        MsgType,
    PBOOL                       SendResponse
    )
/*++

Routine Description:

    This routine processes madcap discover, multicast request and
    unicast request messages.

Arguments:

    pCtxt - A pointer to the current request context.

    pOptions - A pointer to a preallocated pOptions structure.

    MsgType - Discover or request

    SendResponse - Pointer to boolean which gets set to true if
                    a response is to be sent to a client.

Return Value:

    Windows Error.

--*/
{
    DWORD                   Error,Error2;
    DWORD                   LeaseDuration;
    BYTE                   *ClientId,
                           *OptionEnd ;
    DWORD                   ClientIdLength;
    WIDE_OPTION UNALIGNED  *Option;
    LPMADCAP_MESSAGE        dhcpReceiveMessage,
                            dhcpSendMessage;
    LPDHCP_PENDING_CTXT     pPending;
    DHCP_IP_ADDRESS         IpAddress;
    DWORD                   ScopeId;
    DWORD                  *RequestedAddrList;
    WORD                    RequestedAddrCount;
    DWORD                  *AllocatedAddrList;
    WORD                    AllocatedAddrCount;
    BOOL                    DbLockHeld;
    BOOL                    PendingClientFound, DbClientFound;
    WCHAR                   ClientInfoBuff[DHCP_IP_KEY_LEN];
    WCHAR                  *ClientInfo;
    DHCP_IP_ADDRESS         ClientIpAddress;
    BYTE                    NakData[DEF_ERROR_OPT_SIZE];
    WORD                    NakDataLen;
    BOOL                    DropIt;
    BOOL                    DiscoverMsg, McastRequest;


    DhcpPrint(( DEBUG_MSTOC, "Processing MadcapDiscoverAndRequest.\n" ));

    dhcpReceiveMessage  = (LPMADCAP_MESSAGE)pCtxt->ReceiveBuffer;
    dhcpSendMessage     = (LPMADCAP_MESSAGE)pCtxt->SendBuffer;
    RequestedAddrList   = AllocatedAddrList = NULL;
    RequestedAddrCount  = AllocatedAddrCount = 0;
    PendingClientFound  = DbClientFound = FALSE;
    DbLockHeld          = FALSE;
    *SendResponse       = DropIt = FALSE;
    DiscoverMsg         = McastRequest = FALSE;
    LeaseDuration       = 0;
    IpAddress           = 0;
    ScopeId             = 0;
    Option              = NULL;
    OptionEnd           = NULL;
    ClientId            = pOptions->Guid;
    ClientIdLength      = pOptions->GuidLength;
    ClientIpAddress     = ((struct sockaddr_in *)&pCtxt->SourceName)->sin_addr.s_addr;
    ClientInfo          = DhcpRegIpAddressToKey(ntohl(ClientIpAddress),ClientInfoBuff);
    Error               = ERROR_SUCCESS;


    if( MADCAP_DISCOVER_MESSAGE == MsgType ) {
        InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Discovers);
    } else {
        InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Requests);
    }

    // validation
    NakDataLen = DEF_ERROR_OPT_SIZE;
    if (!ValidateMadcapMessage(
            pOptions,
            MsgType,
            NakData,
            &NakDataLen,
            &DropIt
            )){
        if (DropIt) {
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }
        goto Nak;
    }
#if DBG
    PrintHWAddress( ClientId, ClientIdLength );
#endif

    // Initialize nak data
    *(WORD UNALIGNED *)NakData = htons(MADCAP_NAK_REQ_NOT_COMPLETED);
    *(WORD UNALIGNED *)(NakData+2) = htons(MADCAP_OPTION_NONE);
    NakDataLen = 4;

    // is this request part of four packet exchange protocol or is it
    // part of two packet exchange protocol
    if (MADCAP_DISCOVER_MESSAGE == MsgType) {
        DhcpPrint(( DEBUG_MSTOC, "MadcapDiscoverAndRequest: it's DISCOVER.\n" ));
        DiscoverMsg = TRUE;
    } else if (pOptions->Server) {
        DhcpPrint(( DEBUG_MSTOC, "MadcapDiscoverAndRequest: it's MULTICAST REQUEST.\n" ));
        McastRequest = TRUE;
    }

    if (pOptions->MinAddrCount) {
        WORD    MinAddrCount = ntohs(*pOptions->MinAddrCount);
        // MBUG: Can't do more than one ip
        if (MinAddrCount > 1) {
            *(WORD UNALIGNED *)(NakData+2) = htons(MADCAP_OPTION_ADDR_COUNT);
            goto Nak;
        }
    }
    // first validate the scopeid option
    ScopeId = ntohl(*pOptions->ScopeId);
    Error = DhcpServerFindMScope(
                pCtxt->Server,
                ScopeId,
                NULL,
                &pCtxt->Subnet
                );
    if (ERROR_SUCCESS != Error) {
        DhcpPrint(( DEBUG_ERRORS, "ProcessMadcapDiscoverAndRequest could not find MScope id %ld\n", ScopeId ));
        *(WORD UNALIGNED *)(NakData+2) = htons(MADCAP_OPTION_MCAST_SCOPE);
        goto Nak;
    }
    // is this scope disabled?
    if( DhcpSubnetIsDisabled(pCtxt->Subnet, TRUE) ) {
        *(WORD UNALIGNED *)(NakData+2) = htons(MADCAP_OPTION_MCAST_SCOPE);
        goto Nak;
    }

    // did client specify specific address list?
    if (pOptions->AddrRangeList) {
        Error = ExpandMadcapAddressList(
                    pOptions->AddrRangeList,
                    pOptions->AddrRangeListSize,
                    NULL,
                    &RequestedAddrCount
                    );
        if (ERROR_BUFFER_OVERFLOW != Error) {
            goto Cleanup;
        }
        RequestedAddrList = DhcpAllocateMemory(RequestedAddrCount*sizeof(DWORD));
        if (!RequestedAddrList ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        Error = ExpandMadcapAddressList(
                    pOptions->AddrRangeList,
                    pOptions->AddrRangeListSize,
                    RequestedAddrList,
                    &RequestedAddrCount
                    );
        if (ERROR_SUCCESS != Error) {
            goto Cleanup;
        }
        // retrieve the first ip requested by the client
        IpAddress  = ntohl( RequestedAddrList[0]);
    }
    // MBUG: Currently we don't support more than one ip
    RequestedAddrCount = 1;

    AllocatedAddrList = DhcpAllocateMemory(RequestedAddrCount*sizeof(DWORD));
    if (!AllocatedAddrList) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    // make sure that the requested ip is good
    if ( IpAddress ) {
        IpAddress = ntohl(RequestedAddrList[0]);
        Error = DhcpGetMScopeForAddress( IpAddress, pCtxt );
        if (ERROR_SUCCESS != Error ) {
            DhcpPrint(( DEBUG_ERRORS, "ProcessMadcapDiscoverAndRequest could not find MScope for reqested ip %s\n",
                        DhcpIpAddressToDottedString(IpAddress) ));
            *(WORD UNALIGNED *)(NakData+2) = htons(MADCAP_OPTION_MCAST_SCOPE);
            goto Nak;
        }
        // make sure the requested scopeid matches with the scopeid of the requested address.
        if (ScopeId != pCtxt->Subnet->MScopeId) {
            DhcpPrint(( DEBUG_ERRORS, "ProcessMadcapDiscoverAndRequest reqested ip %s not in the requested scope id %ld\n",
                        DhcpIpAddressToDottedString(IpAddress), ScopeId ));
            *(WORD UNALIGNED *)(NakData+2) = htons(MADCAP_OPTION_MCAST_SCOPE);
            goto Nak;
        }
    }

    //
    // If the client specified a server identifier option, we should
    // drop this packet unless the identified server is this one.
    if ( McastRequest && *pOptions->Server != pCtxt->EndPointIpAddress ) {
         DhcpPrint((DEBUG_MSTOC,"ProcessMadcapDiscoverAndRequest: Ignoring request, retracting offer\n"));
         Error = MadcapRetractOffer(
                    pCtxt,
                    pOptions,
				    ClientId,
				    ClientIdLength
				  );
         goto Cleanup;
    }

    // find out if we can honor the lease duration
    Error = GetMCastLeaseInfo(
                pCtxt,
                &LeaseDuration,
                pOptions->RequestLeaseTime,
                pOptions->MinLeaseTime,
                pOptions->LeaseStartTime,
                pOptions->MaxStartTime ,
                (WORD UNALIGNED *)(NakData+2)
                );

    if (ERROR_SUCCESS != Error) {
        goto Nak;
    }
#if DBG
    {
        time_t scratchTime;

        scratchTime = LeaseDuration;

        DhcpPrint(( DEBUG_MSTOC, "MadcapDiscoverAndRequest: providing lease upto %.19s\n",
                    asctime(localtime(&scratchTime)) ));
    }
#endif

    // Now lookup the client both in pending list and database.
    LOCK_INPROGRESS_LIST();
    Error = DhcpFindPendingCtxt(
        ClientId,
        ClientIdLength,
        0,
        &pPending
    );
    if( ERROR_SUCCESS == Error ) {                     // there is some pending ctxt with this address
        if( IpAddress && IpAddress != pPending->Address ) {
            DhcpPrint((DEBUG_ERRORS,
                       "ProcessMadcapDiscoverAndRequest: Nacking %lx - pending ctx has different Addr %lx\n",
                       IpAddress, pPending->Address));
            UNLOCK_INPROGRESS_LIST();
            goto Nak;
        }
        DhcpPrint((DEBUG_MSTOC,"ProcessMadcapDiscoverAndRequest: pending record found %s\n",
                   DhcpIpAddressToDottedString(IpAddress)));
        IpAddress = pPending->Address;
        DhcpAssert( !pPending->Processing );
        PendingClientFound = TRUE;
        // everything looks ok, remove and free the context and proceed
        Error = DhcpRemovePendingCtxt(pPending);
        DhcpAssert(ERROR_SUCCESS == Error);
        DhcpFreeMemory(pPending);
    }
    UNLOCK_INPROGRESS_LIST();

    // Now look him up in the DB.
    //
    LOCK_DATABASE();
    DbLockHeld = TRUE;
    // if we know the ipaddress then look him up in the DB.
    // if he exists then make sure there is no inconsistency,
    // if inconsistent then send NAK
    // else do nothing and send ACK. Atleast, don't renew it as the client
    // is supposed to send the renewal packet.
    if (IpAddress) {
        Error = MadcapValidateClientByClientId(
                    (LPBYTE)&IpAddress,
                    sizeof (IpAddress),
                    ClientId,
                    ClientIdLength);
        if ( ERROR_SUCCESS == Error ) {
            DhcpPrint((DEBUG_MSTOC,"ProcessMadcapDiscoverAndRequest: database record found %s\n",
                       DhcpIpAddressToDottedString(IpAddress)));
            DbClientFound = TRUE;
        } else if ( Error != ERROR_FILE_NOT_FOUND ){
            DhcpPrint((DEBUG_MSTOC,
                       "ProcessMadcapDiscoverAndRequest: conflict with the database clientid entry\n"));
            goto Nak;
        }
    } else {
        DWORD   IpAddressLen = sizeof (IpAddress);
        if (MadcapGetIpAddressFromClientId(
                  ClientId,
                  ClientIdLength,
                  &IpAddress,
                  &IpAddressLen
                  ) ) {
            DbClientFound = TRUE;
            DhcpPrint((DEBUG_MSTOC,"ProcessMadcapDiscoverAndRequest: database record found %s\n",
                       DhcpIpAddressToDottedString(IpAddress)));
        } else {
            DhcpPrint((DEBUG_ERRORS,"ProcessMadcapDiscoverAndRequest - could not find ipaddress from client id\n"));
        }
    }

    if ( !PendingClientFound && !DbClientFound ) {
        if (DiscoverMsg || !McastRequest) {
            if (IpAddress) {
                DhcpPrint((DEBUG_MSTOC,"ProcessMadcapDiscoverAndRequest: requesting specific address %s\n",
                           DhcpIpAddressToDottedString(IpAddress)));
                if (!DhcpRequestSpecificMAddress(pCtxt, IpAddress)) {
                    DhcpPrint(( DEBUG_ERRORS, "ProcessMadcapDiscoverAndRequest could not allocate specific address, %ld\n", Error));
                    Error = ERROR_DHCP_ADDRESS_NOT_AVAILABLE;
                }
            } else {
                // we need to determine a brand new address for this client.
                Error = DhcpRequestSomeAddress(                    // try to get some address..
                    pCtxt,
                    &IpAddress,
                    FALSE
                );
                if ( ERROR_SUCCESS != Error ) {
                    DhcpPrint((DEBUG_MSTOC,"ProcessMadcapDiscoverAndRequest: allocating address %s\n",
                               DhcpIpAddressToDottedString(IpAddress)));
                }

            }
            if ( ERROR_SUCCESS != Error ) {
                if( Error == ERROR_DHCP_RANGE_FULL ) {             // failed because of lack of addresses
                    DhcpGlobalScavengeIpAddress = TRUE;            // flag scanvenger to scavenge ip addresses
                }

                DhcpPrint(( DEBUG_ERRORS, "ProcessMadcapDiscoverAndRequest could not allocate new address, %ld\n", Error));
                goto Nak;
            }
        } else {
            DhcpPrint((DEBUG_MSTOC,"ProcessMadcapDiscoverAndRequest: could not find client entry in db or pending list\n"));
            goto Nak;
        }
    }

    DhcpAssert(IpAddress);

    // If IpAddress is out of range, then ignore this request.
    if( DhcpSubnetIsAddressOutOfRange(pCtxt->Subnet,IpAddress, FALSE) ||
        DhcpSubnetIsAddressExcluded(pCtxt->Subnet,IpAddress) ) {

        DhcpPrint((DEBUG_MSTOC,
                   "ProcessMadcapDiscoverAndRequest: OutOfRange/Excluded ipaddress\n"));
        goto Nak;
    }


    AllocatedAddrList[AllocatedAddrCount++] = htonl(IpAddress);

    if (!DiscoverMsg) {
        Error = MadcapCreateClientEntry(
            (LPBYTE)&IpAddress,  // desired ip address
            sizeof (IpAddress),
            ScopeId,
            ClientId,
            ClientIdLength,
            ClientInfo,
            DhcpCalculateTime( 0 ),
            DhcpCalculateTime( LeaseDuration ),
            ntohl(pCtxt->EndPointIpAddress),
            ADDRESS_STATE_ACTIVE,
            0,   // no flags currently.
            DbClientFound
        );
        if ( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_MSTOC, "ProcessMadcapDiscoverAndRequest:Releasing attempted address: 0x%lx\n", IpAddress));
            Error2 = DhcpSubnetReleaseAddress(pCtxt->Subnet, IpAddress);
            DhcpAssert(ERROR_SUCCESS == Error2);
            goto Cleanup;
        }

        UNLOCK_DATABASE();
        DbLockHeld = FALSE;

        DhcpUpdateAuditLog(
            DHCP_IP_LOG_ASSIGN,
            GETSTRING( DHCP_IP_LOG_ASSIGN_NAME ),
            IpAddress,
            ClientId,
            ClientIdLength,
            ClientInfo
        );

    } else {
        UNLOCK_DATABASE();
        DbLockHeld = FALSE;

        LOCK_INPROGRESS_LIST();                        // locks unnecessary as must have already been taken? 
        Error = DhcpAddPendingCtxt(
            ClientId,
            ClientIdLength,
            IpAddress,
            LeaseDuration,
            0,
            0,
            ScopeId,
            DhcpCalculateTime( MADCAP_OFFER_HOLD ),
            FALSE                                      // this record has been processed, nothing more to do
        );
        UNLOCK_INPROGRESS_LIST();
        DhcpAssert(ERROR_SUCCESS == Error);            // expect everything to go well here

    }

Ack:
    if (DbLockHeld) {
        UNLOCK_DATABASE();
        DbLockHeld = FALSE;
    }
    Option = FormatMadcapCommonMessage(
                pCtxt,
                pOptions,
                (BYTE)(DiscoverMsg?MADCAP_OFFER_MESSAGE:MADCAP_ACK_MESSAGE),
                pCtxt->EndPointIpAddress
                );

    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    Option = AppendMadcapAddressList(
                Option,
                AllocatedAddrList,
                AllocatedAddrCount,
                OptionEnd
                );

    ScopeId = htonl(ScopeId);
    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_MCAST_SCOPE,
                 &ScopeId,
                 sizeof(ScopeId),
                 OptionEnd );

    LeaseDuration = htonl(LeaseDuration);
    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_LEASE_TIME,
                 &LeaseDuration,
                 sizeof(LeaseDuration),
                 OptionEnd );


    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    pCtxt->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);

    DhcpPrint(( DEBUG_MSTOC,
        "ProcessMadcapDiscoverAndRequest committed, address %s (%ws).\n",
            DhcpIpAddressToDottedString(IpAddress),
            ClientInfo ));

    Error = ERROR_SUCCESS;
    *SendResponse = TRUE;
    if (DiscoverMsg) {
        InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Offers);
        DhcpPrint(( DEBUG_MSTOC, "ProcessMadcapDiscoverAndRequest Offered.\n" ));
    } else {
        InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Acks);
        DhcpPrint(( DEBUG_MSTOC, "ProcessMadcapDiscoverAndRequest Acked.\n" ));
    }
    goto Cleanup;

Nak:
    if (DbLockHeld) {
        UNLOCK_DATABASE();
        DbLockHeld = FALSE;
    }
    DhcpPrint(( DEBUG_MSTOC,"ProcessMadcapDiscoverAndRequest: %s Nack'd.\n",
            DhcpIpAddressToDottedString ( IpAddress ) ));

    Option = FormatMadcapCommonMessage(
                pCtxt,
                pOptions,
                MADCAP_NACK_MESSAGE,
                pCtxt->EndPointIpAddress
                );

    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    DhcpAssert(NakDataLen);
    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_ERROR,
                 NakData,
                 NakDataLen,
                 OptionEnd );

    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    pCtxt->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);

    // dont log all kinds of NACK. Only those useful for diagnosis
    if (ClientIdLength) {
        DhcpUpdateAuditLog(
            DHCP_IP_LOG_NACK,
            GETSTRING( DHCP_IP_LOG_NACK_NAME ),
            IpAddress,
            ClientId,
            ClientIdLength,
            ClientInfo
        );
    }

    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Naks);
    *SendResponse = TRUE;
    Error = ERROR_SUCCESS;
    DhcpPrint(( DEBUG_MSTOC, "ProcessMadcapDiscoverAndRequest Nacked.\n" ));

Cleanup:
    if (DbLockHeld) {
        UNLOCK_DATABASE();
    }

    if (RequestedAddrList) {
        DhcpFreeMemory(RequestedAddrList);
    }
    if (AllocatedAddrList) {
        DhcpFreeMemory(AllocatedAddrList);
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_MSTOC, "ProcessMadcapDiscoverAndRequest failed, %ld.\n", Error ));
    }

    return( Error );
}

DWORD
ProcessMadcapRenew(
    LPDHCP_REQUEST_CONTEXT      pCtxt,
    LPMADCAP_SERVER_OPTIONS     pOptions,
    PBOOL                       SendResponse
    )
/*++

Routine Description:

    This function processes a DHCP Request request packet.

Arguments:

    pCtxt - A pointer to the current request context.

    pOptions - A pointer to a preallocated pOptions structure.

Return Value:

    Windows Error.

--*/
{
    DWORD                   Error,Error2,
                            LeaseDuration;
    BYTE                   *ClientId,
                           *OptionEnd ;
    DWORD                   ClientIdLength;
    WIDE_OPTION  UNALIGNED *Option;
    LPMADCAP_MESSAGE        dhcpReceiveMessage,
                            dhcpSendMessage;
    LPDHCP_PENDING_CTXT     pPending;
    DHCP_IP_ADDRESS         IpAddress;
    DWORD                   IpAddressLen;
    DWORD                   ScopeId;
    DWORD                  *AllocatedAddrList;
    WORD                    AllocatedAddrCount;
    BOOL                    DbLockHeld;
    WCHAR                   ClientInfoBuff[DHCP_IP_KEY_LEN];
    WCHAR                  *ClientInfo;
    DHCP_IP_ADDRESS         ClientIpAddress;
    BYTE                    NakData[DEF_ERROR_OPT_SIZE];
    WORD                    NakDataLen;
    BOOL                    DropIt;

    DhcpPrint(( DEBUG_MSTOC, "Processing MADCAPRENEW.\n" ));

    dhcpReceiveMessage  = (LPMADCAP_MESSAGE)pCtxt->ReceiveBuffer;
    dhcpSendMessage     = (LPMADCAP_MESSAGE)pCtxt->SendBuffer;
    AllocatedAddrList   = NULL;
    AllocatedAddrCount  = 0;
    DbLockHeld          = FALSE;
    *SendResponse       = DropIt = FALSE;
    LeaseDuration       = 0;
    IpAddress           = 0;
    ScopeId             = 0;
    Option              = NULL;
    OptionEnd           = NULL;
    ClientId            = pOptions->Guid;
    ClientIdLength      = pOptions->GuidLength;
    ClientIpAddress     = ((struct sockaddr_in *)&pCtxt->SourceName)->sin_addr.s_addr;
    ClientInfo          = DhcpRegIpAddressToKey(ntohl(ClientIpAddress),ClientInfoBuff);
    Error               = ERROR_SUCCESS;


    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Renews);

    // validation
    NakDataLen = DEF_ERROR_OPT_SIZE;
    if (!ValidateMadcapMessage(
            pOptions,
            MADCAP_RENEW_MESSAGE,
            NakData,
            &NakDataLen,
            &DropIt
            )){
        if (DropIt) {
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }
        goto Nak;
    }

    // Initialize nak data
    *(WORD UNALIGNED *)NakData = htons(MADCAP_NAK_REQ_NOT_COMPLETED);
    *(WORD UNALIGNED *)(NakData+2) = htons(MADCAP_OPTION_NONE);
    NakDataLen = 4;

#if DBG
    PrintHWAddress( ClientId, ClientIdLength );
#endif

    LOCK_DATABASE();
    DbLockHeld = TRUE;
    // first lookup this client using its id.If we cannot find him in the db
    // then nak him
    IpAddressLen = sizeof (IpAddress);
    if (!MadcapGetIpAddressFromClientId(
              ClientId,
              ClientIdLength,
              &IpAddress,
              &IpAddressLen
              ) ) {
        *(WORD UNALIGNED *)NakData = htons(MADCAP_NAK_INVALID_LEASE_ID);
        NakDataLen = 2;

        DhcpPrint((DEBUG_ERRORS,"ProcessMadcapRenew - could not find ipaddress from client id\n"));
        goto Nak;
    }

    AllocatedAddrList = DhcpAllocateMemory(1*sizeof(DWORD));
    if (!AllocatedAddrList) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Error = DhcpGetMScopeForAddress(IpAddress,pCtxt);
    if (ERROR_SUCCESS != Error) {
        DhcpPrint(( DEBUG_ERRORS, "MadcapRenew could not find MScope for %s\n",
                    DhcpIpAddressToDottedString( IpAddress ) ));
        // this shouldn't really happen.
        DhcpAssert(FALSE);
        goto Cleanup;
    }
    ScopeId = pCtxt->Subnet->MScopeId;

    if( DhcpSubnetIsDisabled(pCtxt->Subnet, TRUE) ) {
        goto Nak;
    }

    AllocatedAddrList[AllocatedAddrCount++] = htonl(IpAddress);
    GetMCastLeaseInfo(
        pCtxt,
        &LeaseDuration,
        pOptions->RequestLeaseTime,
        pOptions->MinLeaseTime,
        pOptions->LeaseStartTime,
        pOptions->MaxStartTime,
        (WORD UNALIGNED *)(NakData+2)
        );

    Error = MadcapCreateClientEntry(
        (LPBYTE)&IpAddress,  // desired ip address
        sizeof(IpAddress),
        ScopeId,
        ClientId,
        ClientIdLength,
        ClientInfo,
        DhcpCalculateTime( 0 ),
        DhcpCalculateTime( LeaseDuration ),
        ntohl(pCtxt->EndPointIpAddress),
        ADDRESS_STATE_ACTIVE,
        0,   // no flags currently.
        TRUE
    );


    UNLOCK_DATABASE();
    DbLockHeld = FALSE;

    if ( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_MSTOC, "Could not update DB for : 0x%lx\n", IpAddress));
        DhcpAssert(FALSE);
        goto Cleanup;
    }

    DhcpUpdateAuditLog(
        DHCP_IP_LOG_ASSIGN,
        GETSTRING( DHCP_IP_LOG_RENEW_NAME ),
        IpAddress,
        ClientId,
        ClientIdLength,
        NULL
    );

    Option = FormatMadcapCommonMessage(
                pCtxt,
                pOptions,
                MADCAP_ACK_MESSAGE,
                pCtxt->EndPointIpAddress
                );

    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    Option = AppendMadcapAddressList(
                Option,
                AllocatedAddrList,
                AllocatedAddrCount,
                OptionEnd
                );
    LeaseDuration = htonl(LeaseDuration);
    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_LEASE_TIME,
                 &LeaseDuration,
                 sizeof(LeaseDuration),
                 OptionEnd );

    ScopeId = htonl(ScopeId);
    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_MCAST_SCOPE,
                 &ScopeId,
                 sizeof(ScopeId),
                 OptionEnd );

    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    pCtxt->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);

    DhcpPrint(( DEBUG_MSTOC,"MadcapRenew committed, address %s \n",
            DhcpIpAddressToDottedString(IpAddress)));

    Error = ERROR_SUCCESS;
    *SendResponse = TRUE;
    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Acks);
    DhcpPrint(( DEBUG_MSTOC, "MadcapRenew acked.\n"));
    goto Cleanup;

Nak:
    if (DbLockHeld) {
        UNLOCK_DATABASE();
        DbLockHeld = FALSE;
    }
    DhcpPrint(( DEBUG_MSTOC,"Invalid MADCAPRENEW for %s Nack'd.\n",
            DhcpIpAddressToDottedString ( IpAddress ) ));

    Option = FormatMadcapCommonMessage(
                pCtxt,
                pOptions,
                MADCAP_NACK_MESSAGE,
                pCtxt->EndPointIpAddress
                );

    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    DhcpAssert(NakDataLen);
    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_ERROR,
                 NakData,
                 NakDataLen,
                 OptionEnd );

    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    pCtxt->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);

    // dont log all kinds of NACK. Only those useful for diagnosis
    if (ClientIdLength) {
        DhcpUpdateAuditLog(
            DHCP_IP_LOG_NACK,
            GETSTRING( DHCP_IP_LOG_NACK_NAME ),
            IpAddress,
            ClientId,
            ClientIdLength,
            ClientInfo
        );
    }

    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Naks);
    *SendResponse = TRUE;
    Error = ERROR_SUCCESS;
    DhcpPrint(( DEBUG_MSTOC, "MadcapRenew Nacked.\n"));

Cleanup:
    if (DbLockHeld) {
        UNLOCK_DATABASE();
    }

    if (AllocatedAddrList) {
        DhcpFreeMemory(AllocatedAddrList);
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_MSTOC, "MadcapRenew failed, %ld.\n", Error ));
    }

    return( Error );
}

DWORD
ProcessMadcapRelease(
    LPDHCP_REQUEST_CONTEXT      pCtxt,
    LPMADCAP_SERVER_OPTIONS     pOptions,
    PBOOL                       SendResponse
    )
/*++

Routine Description:

    This function processes a DHCP Release request packet.

Arguments:

    pCtxt - A pointer to the current request context.

    pOptions - A pointer to a preallocated pOptions structure.

Return Value:

    FALSE - Do not send a response.

--*/
{
    DWORD                   Error,Error2;
    DHCP_IP_ADDRESS         ClientIpAddress;
    DHCP_IP_ADDRESS         IpAddress = 0;
    DWORD                   IpAddressLen;
    LPMADCAP_MESSAGE        dhcpReceiveMessage;
    LPMADCAP_MESSAGE        dhcpSendMessage;
    LPDHCP_PENDING_CTXT     pPending = NULL;
    BYTE                    *ClientId;
    DWORD                   ClientIdLength;
    WCHAR                   *pwszName;
    WIDE_OPTION  UNALIGNED *Option;
    LPBYTE                  OptionEnd;
    DB_CTX                  DbCtx;
    WCHAR                   ClientInfoBuff[DHCP_IP_KEY_LEN];
    WCHAR                  *ClientInfo;
    BYTE                    NakData[DEF_ERROR_OPT_SIZE];
    WORD                    NakDataLen;
    BOOL                    DropIt;

    DhcpPrint(( DEBUG_MSTOC, "MadcapRelease arrived.\n" ));

    dhcpReceiveMessage  = (LPMADCAP_MESSAGE)pCtxt->ReceiveBuffer;
    dhcpSendMessage     = (LPMADCAP_MESSAGE)pCtxt->SendBuffer;
    *SendResponse       = DropIt = FALSE;
    IpAddress           = 0;
    IpAddressLen        = 0;
    Option              = NULL;
    OptionEnd           = NULL;
    ClientId            = pOptions->Guid;
    ClientIdLength      = pOptions->GuidLength;
    ClientIpAddress     = ((struct sockaddr_in *)&pCtxt->SourceName)->sin_addr.s_addr;
    ClientInfo          = DhcpRegIpAddressToKey(ntohl(ClientIpAddress),ClientInfoBuff);
    Error               = ERROR_SUCCESS;

    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Releases);

    // validation
    NakDataLen = DEF_ERROR_OPT_SIZE;
    if (!ValidateMadcapMessage(
            pOptions,
            MADCAP_RELEASE_MESSAGE,
            NakData,
            &NakDataLen,
            &DropIt
            )){
        if (DropIt) {
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }
        goto Nak;
    }
    // Initialize nak data
    *(WORD UNALIGNED *)NakData = htons(MADCAP_NAK_REQ_NOT_COMPLETED);
    *(WORD UNALIGNED *)(NakData+2) = htons(MADCAP_OPTION_NONE);
    NakDataLen = 4;

#if DBG
    PrintHWAddress( ClientId, ClientIdLength );
#endif

    LOCK_DATABASE();

    // find the client in the database.
    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);
    IpAddressLen = sizeof (IpAddress);
    if (!MadcapGetIpAddressFromClientId(
            ClientId,
            ClientIdLength,
            &IpAddress,
            &IpAddressLen
            )) {
        UNLOCK_DATABASE();
        *(WORD UNALIGNED *)NakData = htons(MADCAP_NAK_INVALID_LEASE_ID);
        NakDataLen = 2;
        goto Nak;
    }

    DhcpPrint(( DEBUG_MSTOC, "MadcapRelease address, %s.\n",
                DhcpIpAddressToDottedString(IpAddress) ));

    Error = MadcapRemoveClientEntryByClientId(
                ClientId,
                ClientIdLength,
                TRUE);       // release address from bit map.

    if (Error == ERROR_SUCCESS) {
        DhcpUpdateAuditLog(
            DHCP_IP_LOG_RELEASE,
            GETSTRING( DHCP_IP_LOG_RELEASE_NAME ),
            IpAddress,
            ClientId,
            ClientIdLength,
            NULL
        );
    }

    UNLOCK_DATABASE();


    // finally if there is any pending request for this client,
    // remove it now.
    LOCK_INPROGRESS_LIST();
    Error2 = DhcpFindPendingCtxt(
        ClientId,
        ClientIdLength,
        0,
        &pPending
    );
    if( ERROR_SUCCESS == Error2 ) {
        Error2 = DhcpRemovePendingCtxt(
            pPending
        );
        DhcpAssert( ERROR_SUCCESS == Error2);
        Error2 = MadcapDeletePendingCtxt(
            pPending
        );
        DhcpAssert( ERROR_SUCCESS == Error2 );
    }
    UNLOCK_INPROGRESS_LIST();

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_MSTOC, "DhcpRelease failed, %ld.\n", Error ));
        goto Cleanup;
    }

    //
    // send a response.
    //
    Option = FormatMadcapCommonMessage(
                pCtxt,
                pOptions,
                MADCAP_ACK_MESSAGE,
                pCtxt->EndPointIpAddress
                );

    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;
    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    pCtxt->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);
    DhcpAssert( pCtxt->SendMessageSize <= DHCP_SEND_MESSAGE_SIZE );

    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Acks);
    *SendResponse = TRUE;
    DhcpPrint(( DEBUG_MSTOC,"MadcapRelease for %s Acked.\n",
            DhcpIpAddressToDottedString ( IpAddress ) ));
    goto Cleanup;

Nak:
    DhcpPrint(( DEBUG_MSTOC,"MadcapRelease for %s Nack'd.\n",
            DhcpIpAddressToDottedString ( IpAddress ) ));

    Option = FormatMadcapCommonMessage(
                pCtxt,
                pOptions,
                MADCAP_NACK_MESSAGE,
                pCtxt->EndPointIpAddress
                );

    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    DhcpAssert(NakDataLen);
    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_ERROR,
                 NakData,
                 NakDataLen,
                 OptionEnd );

    Option = AppendWideOption(
                 Option,
                 MADCAP_OPTION_END,
                 NULL,
                 0,
                 OptionEnd
                 );

    pCtxt->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);

    // dont log all kinds of NACK. Only those useful for diagnosis
    if (ClientIdLength) {
        DhcpUpdateAuditLog(
            DHCP_IP_LOG_NACK,
            GETSTRING( DHCP_IP_LOG_NACK_NAME ),
            IpAddress,
            ClientId,
            ClientIdLength,
            ClientInfo
        );
    }

    InterlockedIncrement((PVOID)&MadcapGlobalMibCounters.Naks);
    *SendResponse = TRUE;
    Error = ERROR_SUCCESS;

Cleanup:
    if (ERROR_SUCCESS != Error) {

        DhcpPrint(( DEBUG_MSTOC, "MadcapRelease failed %ld\n", Error));
    }
    return( Error );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\mdhcsapi.c ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/
//
// Subnet APIs
//
#include "dhcppch.h"
#include "dhcp2_srv.h"
#include "mdhcpsrv.h"
#include "rpcapi.h"

DWORD
DhcpCreateMScope(
    LPWSTR   pMScopeName,
    LPDHCP_MSCOPE_INFO pMScopeInfo
)
{
    DWORD                          Error, Error2;
    PM_SUBNET                      pMScope;
    PM_SUBNET                      pOldMScope = NULL;

    DhcpAssert( pMScopeName && pMScopeInfo );

    if (wcscmp(pMScopeName, pMScopeInfo->MScopeName ))
        return ERROR_INVALID_PARAMETER;

    if( !DhcpServerValidateNewMScopeId(DhcpGetCurrentServer(),pMScopeInfo->MScopeId) )
        return ERROR_DHCP_MSCOPE_EXISTS;
    if( !DhcpServerValidateNewMScopeName(DhcpGetCurrentServer(),pMScopeInfo->MScopeName) )
        return ERROR_DHCP_MSCOPE_EXISTS;

    Error = MemMScopeInit(
        &pMScope,
        pMScopeInfo->MScopeId,
        pMScopeInfo->MScopeState,
        pMScopeInfo->MScopeAddressPolicy,
        pMScopeInfo->TTL,
        pMScopeName,
        pMScopeInfo->MScopeComment,
        pMScopeInfo->LangTag,
        pMScopeInfo->ExpiryTime
        );

    if( ERROR_SUCCESS != Error ) return Error;
    DhcpAssert(pMScope);

    Error = MemServerAddMScope(DhcpGetCurrentServer(), pMScope);

    if( ERROR_SUCCESS != Error ) {
        Error2 = MemSubnetCleanup(pMScope);
        DhcpAssert(ERROR_SUCCESS == Error2);
        return Error;
    }

    return Error;
}

DWORD
DhcpModifyMScope(
    LPWSTR   pMScopeName,
    LPDHCP_MSCOPE_INFO pMScopeInfo
)
{
    DWORD                          Error, Error2;
    PM_SUBNET                      pMScope;
    PM_SUBNET                      pOldMScope = NULL;
    BOOL                           NewName = FALSE;

    DhcpAssert( pMScopeName && pMScopeInfo );

    Error = DhcpServerFindMScope(
        DhcpGetCurrentServer(),
        INVALID_MSCOPE_ID,
        pMScopeName,
        &pOldMScope
        );

    if ( ERROR_SUCCESS != Error ) return ERROR_DHCP_SUBNET_NOT_PRESENT;

    // never change the scopeid.
    if (pMScopeInfo->MScopeId != pOldMScope->MScopeId ) {
        if( !DhcpServerValidateNewMScopeId(DhcpGetCurrentServer(),pMScopeInfo->MScopeId) )
            return ERROR_DHCP_SUBNET_EXITS;
        Error = ChangeMScopeIdInDb(pOldMScope->MScopeId, pMScopeInfo->MScopeId);
        if (ERROR_SUCCESS != Error) {
            return Error;
        }
    }

    // if we want to change the name, make sure the new name is valid.
    if (wcscmp(pMScopeInfo->MScopeName, pMScopeName) ){
        if( !DhcpServerValidateNewMScopeName(DhcpGetCurrentServer(),pMScopeInfo->MScopeName) )
            return ERROR_DHCP_SUBNET_EXITS;
        
        Error = DhcpMigrateMScopes(
            pOldMScope->Name, pMScopeInfo->MScopeName,
            DhcpSaveOrRestoreConfigToFile
            );
        DhcpAssert( ERROR_SUCCESS == Error );
        if (ERROR_SUCCESS != Error) return Error;

    }

    // modify the values.
    Error = MemMScopeModify(
                pOldMScope,
                pMScopeInfo->MScopeId, // never change the scope id.
                pMScopeInfo->MScopeState,
                pMScopeInfo->MScopeAddressPolicy,
                pMScopeInfo->TTL,
                pMScopeInfo->MScopeName,
                pMScopeInfo->MScopeComment,
                pMScopeInfo->LangTag,
                pMScopeInfo->ExpiryTime
                );

    if( ERROR_SUCCESS != Error ) return Error;

    // MBUG: need to save the MScope subkeys also.
    if( ERROR_SUCCESS == Error ) {
        Error = DhcpRegFlushServer( FLUSH_ANYWAY );
    }

    return Error;
}

DWORD
R_DhcpSetMScopeInfo(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPWSTR   pMScopeName,
    LPDHCP_MSCOPE_INFO pMScopeInfo,
    BOOL    NewScope
    )
/*++

Routine Description:

    This function creates a new subnet structure in the server
    registry database. The server will start managing the new subnet
    and distribute IP address to clients from that subnet. However
    the administrator should call DhcpAddSubnetElement() to add an
    address range for distribution. The PrimaryHost field specified in
    the SubnetInfo should be same as the server pointed by
    ServerIpAddress.

Arguments:

    ServerIpAddress : IP address string of the DHCP server (Primary).

    SubnetAddress : IP Address of the new subnet.

    SubnetInfo : Pointer to the new subnet information structure.

Return Value:

    ERROR_DHCP_MSCOPE_EXISTS - if the subnet is already managed.

    ERROR_INVALID_PARAMETER - if the information structure contains an
        inconsistent fields.

    other WINDOWS errors.

--*/
{
    DWORD Error;
    WCHAR KeyBuffer[DHCP_IP_KEY_LEN];
    LPWSTR KeyName;
    HKEY KeyHandle = NULL;
    HKEY SubkeyHandle = NULL;
    DWORD KeyDisposition;
    EXCLUDED_IP_RANGES ExcludedIpRanges;
    DWORD MScopeId;
    
    DhcpPrint(( DEBUG_APIS, "R_DhcpCreateMScope is called, NewScope %d\n",NewScope));

    if (!pMScopeName || !pMScopeInfo ) {
        return ERROR_INVALID_PARAMETER;
    }
    if (wcslen(pMScopeName) >= MAX_PATH) {
        return (ERROR_DHCP_SCOPE_NAME_TOO_LONG);
    }
    if ( INVALID_MSCOPE_ID == pMScopeInfo->MScopeId ) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpSetMScopeInfo" );
    if( NO_ERROR != Error ) return Error;
    
    if (NewScope) {

        Error = DhcpCreateMScope(
                    pMScopeName,
                    pMScopeInfo
                    );
    } else {
        Error = DhcpModifyMScope(
                    pMScopeName,
                    pMScopeInfo
                    );
    }

    MScopeId = pMScopeInfo->MScopeId;
    if( 0 == MScopeId ) MScopeId = INVALID_MSCOPE_ID;
    
    return DhcpEndWriteApiEx(
        "DhcpSetMScopeInfo", Error, FALSE, FALSE, 0,
        MScopeId, 0 );
}

DWORD
DhcpGetMScopeInfo(
    IN      LPWSTR                 pMScopeName,
    IN      LPDHCP_MSCOPE_INFO     pMScopeInfo
)
{
    DWORD                          Error;
    PM_SUBNET                      pMScope;

    Error = MemServerFindMScope(
        DhcpGetCurrentServer(),
        INVALID_MSCOPE_ID,
        pMScopeName,
        &pMScope
        );

    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_SUBNET_NOT_PRESENT;
    if( ERROR_SUCCESS != Error) return Error;

    DhcpAssert(NULL != pMScope);

    pMScopeInfo->MScopeName     = CloneLPWSTR(pMScope->Name);
    pMScopeInfo->MScopeId       = pMScope->MScopeId;
    pMScopeInfo->MScopeComment  = CloneLPWSTR(pMScope->Description);
    pMScopeInfo->MScopeState    = pMScope->State;
    pMScopeInfo->MScopeAddressPolicy = pMScope->Policy;
    pMScopeInfo->TTL            = pMScope->TTL;
    pMScopeInfo->ExpiryTime     = pMScope->ExpiryTime;
    pMScopeInfo->LangTag         = CloneLPWSTR(pMScope->LangTag);
    pMScopeInfo->MScopeFlags    = 0;
    pMScopeInfo->PrimaryHost.IpAddress = inet_addr("127.0.0.1");
    pMScopeInfo->PrimaryHost.NetBiosName = CloneLPWSTR(L"");
    pMScopeInfo->PrimaryHost.HostName = CloneLPWSTR(L"");

    return ERROR_SUCCESS;
}

DWORD
R_DhcpGetMScopeInfo(
    LPWSTR ServerIpAddress,
    LPWSTR   pMScopeName,
    LPDHCP_MSCOPE_INFO *pMScopeInfo
    )
/*++

Routine Description:

    This function retrieves the information of the subnet managed by
    the server.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    SubnetInfo : Pointer to a location where the subnet information
        structure pointer is returned. Caller should free up
        this buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    Other WINDOWS errors.

--*/
{
    DWORD                          Error;
    LPDHCP_MSCOPE_INFO             LocalMScopeInfo;

    *pMScopeInfo = NULL;

    if (!pMScopeName) return ERROR_INVALID_PARAMETER;

    Error = DhcpBeginReadApi( "DhcpGetMScopeInfo" );
    if( ERROR_SUCCESS != Error ) return Error;

    LocalMScopeInfo = MIDL_user_allocate(sizeof(DHCP_MSCOPE_INFO));
    if( NULL == LocalMScopeInfo ) {
        DhcpEndReadApi( "DhcpGetMScopeInfo", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpGetMScopeInfo(pMScopeName, LocalMScopeInfo);

    if( ERROR_SUCCESS != Error ) {
        MIDL_user_free(LocalMScopeInfo);
    } else {
        *pMScopeInfo = LocalMScopeInfo;
    }

    DhcpEndReadApi( "DhcpGetMScopeInfo", Error );
    return Error;
}

DWORD
DhcpEnumMScopes(
    IN OUT  DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN OUT  LPDHCP_MSCOPE_TABLE    EnumInfo,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Error, Error2;
    DWORD                          Index;
    DWORD                          Count;
    DWORD                          FilledSize;
    DWORD                          nMScopes;
    DWORD                          nToRead;
    PARRAY                         pMScopes;
    PM_SUBNET                      pMScope;
    ARRAY_LOCATION                 Loc;
    LPWSTR                        *pMScopeNames;

    EnumInfo->NumElements = 0;
    EnumInfo->pMScopeNames = NULL;

    pMScopes = & (DhcpGetCurrentServer()->MScopes);
    nMScopes = MemArraySize(pMScopes);
    if( 0 == nMScopes || nMScopes <= *ResumeHandle)
        return ERROR_NO_MORE_ITEMS;

    if( nMScopes - *ResumeHandle > PreferredMaximum )
        nToRead = PreferredMaximum;
    else nToRead = nMScopes - *ResumeHandle;

    pMScopeNames = MIDL_user_allocate(sizeof(LPWSTR)*nToRead);
    if( NULL == pMScopeNames ) return ERROR_NOT_ENOUGH_MEMORY;

    // zero out the memory.
    RtlZeroMemory( pMScopeNames,sizeof(LPWSTR)*nToRead);

    Error = MemArrayInitLoc(pMScopes, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error);

    for(Index = 0; Index < *ResumeHandle; Index ++ ) {
        Error = MemArrayNextLoc(pMScopes, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    Count = Index;
    for( Index = 0; Index < nToRead; Index ++ ) {
        LPWSTR  pLocalScopeName;
        Error = MemArrayGetElement(pMScopes, &Loc, &pMScope);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != pMScope );

        pMScopeNames[Index] = MIDL_user_allocate( WSTRSIZE( pMScope->Name ) );
        if ( !pMScopeNames[Index] ) { Error = ERROR_NOT_ENOUGH_MEMORY;goto Cleanup;}
        wcscpy(pMScopeNames[Index], pMScope->Name );

        Error = MemArrayNextLoc(pMScopes, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error || Count + Index + 1 == nMScopes ); // the Index was not yet incremented => +1
    }

    *nRead = Index;
    *nTotal = nMScopes - Count;
    *ResumeHandle = Count + Index;

    EnumInfo->NumElements = Index;
    EnumInfo->pMScopeNames = pMScopeNames;

    return ERROR_SUCCESS;

Cleanup:
    for ( Index = 0; Index < nToRead; Index++ ) {
        if ( pMScopeNames[Index] ) MIDL_user_free( pMScopeNames[Index] );
    }
    MIDL_user_free( pMScopeNames );
    return Error;
}

DWORD
R_DhcpEnumMScopes(
    DHCP_SRV_HANDLE ServerIpAddress,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_MSCOPE_TABLE *MScopeTable,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    )
/*++

Routine Description:

    This function enumerates the available subnets.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to
        zero on first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    EnumInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up the buffer after use
        by calling DhcpRPCFreeMemory().

    ElementsRead : Pointer to a DWORD where the number of subnet
        elements in the above buffer is returned.

    ElementsTotal : Pointer to a DWORD where the total number of
        elements remaining from the current position is returned.

Return Value:

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD                          Error;
    LPDHCP_MSCOPE_TABLE            LocalMScopeTable;

    *MScopeTable = NULL;

    Error = DhcpBeginReadApi( "DhcpEnumMScopes" );    
    if( ERROR_SUCCESS != Error ) return Error;

    LocalMScopeTable = MIDL_user_allocate(sizeof(DHCP_MSCOPE_TABLE));
    if( NULL == LocalMScopeTable ) {
        DhcpEndReadApi( "DhcpEnumMScopes", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    Error = DhcpEnumMScopes(ResumeHandle, PreferredMaximum, LocalMScopeTable, ElementsRead, ElementsTotal);

    if( ERROR_SUCCESS != Error && ERROR_MORE_DATA != Error ) {
        MIDL_user_free(LocalMScopeTable);
    } else {
        *MScopeTable = LocalMScopeTable;
    }

    DhcpEndReadApi( "DhcpEnumMScopes", Error );
    return Error;
}

DWORD
R_DhcpAddMScopeElement(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPWSTR  pMScopeName,
    LPDHCP_SUBNET_ELEMENT_DATA_V4 AddElementInfo
    )
/*++

Routine Description:

    This function adds an enumerable type of subnet elements to the
    specified subnet. The new elements that are added to the subnet will
    come into effect immediately.

    This function emulates the RPC interface used by NT 4.0 DHCP Server.
    It is provided for backward compatibilty with older version of the
    DHCP Administrator application.

    NOTE: It is not clear now how do we handle the new secondary hosts.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    AddElementInfo : Pointer to an element information structure
        containing new element that is added to the subnet.
        DhcpIPClusters element type is invalid to specify.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    Other WINDOWS errors.
--*/


{
    DWORD                          Error;
    PM_SUBNET                      pMScope;
    DWORD                          MscopeId;
    
    if (!pMScopeName || !AddElementInfo ) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( DhcpReservedIps == AddElementInfo->ElementType ) {
        return ERROR_INVALID_PARAMETER;
    }

    MscopeId = 0;
    Error = DhcpBeginWriteApi( "DhcpAddMScopeElement" );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerFindMScope(
                DhcpGetCurrentServer(),
                INVALID_MSCOPE_ID,
                pMScopeName,
                &pMScope);

    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_SUBNET_NOT_PRESENT;
    else if( ERROR_SUCCESS == Error ) {
        Error = DhcpAddSubnetElement(pMScope, AddElementInfo, FALSE);
        MscopeId = pMScope->MScopeId;
        if( 0 == MscopeId ) MscopeId = INVALID_MSCOPE_ID;
    }

    return DhcpEndWriteApiEx(
        "DhcpAddMScopeElement", Error, FALSE, FALSE, 0, MscopeId,
        0 );
}




DWORD
R_DhcpEnumMScopeElements
(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPWSTR          pMScopeName,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    )
/*++

Routine Description:

    This function enumerates the eumerable fields of a subnet.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    EnumElementType : Type of the subnet element that are enumerated.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to
        zero on first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    EnumElementInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up the buffer after use
        by calling DhcpRPCFreeMemory().

    ElementsRead : Pointer to a DWORD where the number of subnet
        elements in the above buffer is returned.

    ElementsTotal : Pointer to a DWORD where the total number of
        elements remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD                          Error;
    PM_SUBNET                      pMScope;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 LocalElementEnumInfo;

    if (!pMScopeName) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( DhcpReservedIps == EnumElementType ) {
        return ERROR_INVALID_PARAMETER;
    }

    *EnumElementInfo = NULL;
    *ElementsRead = 0;
    *ElementsTotal = 0;

    Error = DhcpBeginReadApi( "DhcpEnumMScopeElements" );
    if( ERROR_SUCCESS != Error ) return Error;
    
    LocalElementEnumInfo = MIDL_user_allocate(sizeof(DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4));
    if( NULL == LocalElementEnumInfo ) {
        DhcpEndReadApi( "DhcpEnumMScopeElements", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    Error = MemServerFindMScope(
                DhcpGetCurrentServer(),
                INVALID_MSCOPE_ID,
                pMScopeName,
                &pMScope);

    if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
    else if( ERROR_SUCCESS == Error ) {
        Error = DhcpEnumSubnetElements(
            pMScope,
            EnumElementType,
            ResumeHandle,
            PreferredMaximum,
            FALSE,
            LocalElementEnumInfo,
            ElementsRead,
            ElementsTotal
        );
    }

    if( ERROR_SUCCESS != Error ) {
        MIDL_user_free(LocalElementEnumInfo);
    } else {
        *EnumElementInfo = LocalElementEnumInfo;
    }

    DhcpEndReadApi( "DhcpEnumMScopeElements", Error );
    return Error;

}


DWORD
R_DhcpRemoveMScopeElement(
    LPWSTR ServerIpAddress,
    LPWSTR          pMScopeName,
    LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    )
/*++

Routine Description:

    This function removes a subnet element from managing. If the subnet
    element is in use (for example, if the IpRange is in use) then it
    returns error according to the ForceFlag specified.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    RemoveElementInfo : Pointer to an element information structure
        containing element that should be removed from the subnet.
        DhcpIPClusters element type is invalid to specify.

    ForceFlag - Indicates how forcefully this element is removed.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    ERROR_DHCP_ELEMENT_CANT_REMOVE - if the element can't be removed for the
        reason it is has been used.

    Other WINDOWS errors.
--*/
{
    DWORD                          Error;
    PM_SUBNET                      pMScope;
    DWORD                          MscopeId = 0;

    if (!pMScopeName) {
        return ERROR_INVALID_PARAMETER;
    }

    if ( DhcpReservedIps == RemoveElementInfo->ElementType ) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpRemoveMScopeElement" );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerFindMScope(
                DhcpGetCurrentServer(),
                INVALID_MSCOPE_ID,
                pMScopeName,
                &pMScope);

    if( ERROR_SUCCESS != Error ) return Error;

    if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
    else if( ERROR_SUCCESS == Error ) {
        Error = DhcpRemoveSubnetElement(pMScope, RemoveElementInfo, FALSE, ForceFlag);
        MscopeId = pMScope->MScopeId;
        if( 0 == MscopeId ) MscopeId = INVALID_MSCOPE_ID;
    }

    return DhcpEndWriteApiEx(
        "DhcpRemoveMScopeElement", Error, FALSE, FALSE, 0, MscopeId,
        0 );
}

DWORD
MScopeInUse(
    LPWSTR  pMScopeName
    )
/*++

Routine Description:

    This routine determines if a givem mscope is in use or not.

Arguments:

    pMScopeName - the name of the mscope.

Return Value:

    DHCP_SUBNET_CANT_REMOVE - if the subnet is in use.

    Other registry errors.

--*/
{
    DWORD Error;
    DWORD Resumehandle = 0;
    LPDHCP_MCLIENT_INFO_ARRAY ClientInfo = NULL;
    DWORD ClientsRead;
    DWORD ClientsTotal;

    // enumurate clients that belong to the given subnet.
    //
    // We can specify big enough buffer to hold one or two clients
    // info, all we want to know is, is there atleast a client belong
    // to this subnet.
    Error = R_DhcpEnumMScopeClients(
                NULL,
                pMScopeName,
                &Resumehandle,
                1024,  // 1K buffer.
                &ClientInfo,
                &ClientsRead,
                &ClientsTotal );

    if( Error == ERROR_NO_MORE_ITEMS ) {
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }
    if( (Error == ERROR_SUCCESS) || (Error == ERROR_MORE_DATA) ) {
        if( ClientsRead != 0 ) {
            Error = ERROR_DHCP_ELEMENT_CANT_REMOVE;
        }
        else {
            Error = ERROR_SUCCESS;
        }
    }
Cleanup:
    if( ClientInfo != NULL ) {
        _fgs__DHCP_MCLIENT_INFO_ARRAY( ClientInfo );
        MIDL_user_free( ClientInfo );
    }
    return( Error );
}

DWORD
DhcpDeleteMScope(
    IN      LPWSTR                 pMScopeName,
    IN      DWORD                  ForceFlag
)
{
    DWORD                          Error;
    PM_SUBNET                      MScope;

    // If force on, it should remove every record in the database for this subnet..
    if( ForceFlag != DhcpFullForce ) {
        Error = MScopeInUse(pMScopeName);
        if( ERROR_SUCCESS != Error ) return Error;
    }


    Error = MemServerDelMScope(
        DhcpGetCurrentServer(),
        INVALID_MSCOPE_ID,
        pMScopeName,
        &MScope
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_SUBNET_NOT_PRESENT;
    if( ERROR_SUCCESS != Error ) return Error;

    // delete the records from the database.
    Error = DhcpDeleteMScopeClients(MScope->MScopeId);
    // ignore the above error? 

    MemSubnetFree(MScope);                        // evaporate this subnet all all related stuff
    return NO_ERROR;
}

DWORD
R_DhcpDeleteMScope(
    LPWSTR ServerIpAddress,
    LPWSTR pMScopeName,
    DHCP_FORCE_FLAG ForceFlag
    )
/*++

Routine Description:

    This function removes a subnet from DHCP server management. If the
    subnet is in use (for example, if the IpRange is in use)
    then it returns error according to the ForceFlag specified.


Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    ForceFlag : Indicates how forcefully this element is removed.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    ERROR_DHCP_ELEMENT_CANT_REMOVE - if the element can't be removed for the
        reason it is has been used.

    Other WINDOWS errors.

--*/
{
    DWORD                          Error;
    DWORD                          MscopeId = 0;
    PM_MSCOPE                      pMScope;
    
    Error = DhcpBeginWriteApi( "DhcpDeleteMScope" );
    if( ERROR_SUCCESS != Error ) return Error;


    Error = MemServerFindMScope(
                DhcpGetCurrentServer(),
                INVALID_MSCOPE_ID,
                pMScopeName,
                &pMScope);

    if( NO_ERROR == Error ) {
        MscopeId = pMScope->MScopeId;
        if( 0 == MscopeId ) MscopeId = INVALID_MSCOPE_ID;
    }
    
    Error = DhcpDeleteMScope(pMScopeName, ForceFlag);


    return DhcpEndWriteApiEx(
        "DhcpDeleteMScope", Error, FALSE, FALSE, 0, MscopeId,
        0 );
}

//
// Client APIs
//

//
// Client APIs
//


DWORD
R_DhcpCreateMClientInfo(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPWSTR          pMScopeName,
    LPDHCP_MCLIENT_INFO ClientInfo
    )
/*++

Routine Description:

    This function creates a client record in server's database. Also
    this marks the specified client IP address as unavailable (or
    distributed). This function returns error under the following cases :

    1. If the specified client IP address is not within the server
        management.

    2. If the specified client IP address is already unavailable.

    3. If the specified client record is already in the server's
        database.

    This function may be used to distribute IP addresses manually.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_IP_ADDRESS_NOT_MANAGED - if the specified client
        IP address is not managed by the server.

    ERROR_DHCP_IP_ADDRESS_NOT_AVAILABLE - if the specified client IP
        address is not available. May be in use by some other client.

    ERROR_DHCP_CLIENT_EXISTS - if the client record exists already in
        server's database.

    Other WINDOWS errors.
--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}



DWORD
R_DhcpSetMClientInfo(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPDHCP_MCLIENT_INFO ClientInfo
    )
/*++

Routine Description:

    This function sets client information record on the server's
    database.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to the client information structure.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the client information structure
        contains inconsistent data.

    Other WINDOWS errors.
--*/
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD
R_DhcpGetMClientInfo(
    DHCP_SRV_HANDLE     ServerIpAddress,
    LPDHCP_SEARCH_INFO  SearchInfo,
    LPDHCP_MCLIENT_INFO  *ClientInfo
    )
/*++

Routine Description:

    This function retrieves client information record from the server's
    database.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SearchInfo : Pointer to a search information record which is the key
        for the client's record search.

    ClientInfo : Pointer to a location where the pointer to the client
        information structure is returned. This caller should free up
        this buffer after use by calling DhcpRPCFreeMemory().

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    ERROR_INVALID_PARAMETER - if the search information invalid.

    Other WINDOWS errors.
--*/
{
    DWORD Error;
    LPDHCP_MCLIENT_INFO LocalClientInfo = NULL;
    DB_CTX  DbCtx;

    DhcpAssert( SearchInfo != NULL );

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    LOCK_DATABASE();

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    //
    // open appropriate record and set current position.
    //

    switch( SearchInfo->SearchType ) {
    case DhcpClientIpAddress:
        DhcpPrint(( DEBUG_APIS, "DhcpGetMClientInfo is called, (%s).\n",
                        DhcpIpAddressToDottedString(
                            SearchInfo->SearchInfo.ClientIpAddress) ));
        Error = MadcapJetOpenKey(
                    &DbCtx,
                    MCAST_COL_NAME(MCAST_TBL_IPADDRESS),
                    &SearchInfo->SearchInfo.ClientIpAddress,
                    sizeof( DHCP_IP_ADDRESS ) );

        break;
    case DhcpClientHardwareAddress:
        DhcpPrint(( DEBUG_APIS, "DhcpGetMClientInfo is called "
                        "with HW address.\n"));
        Error = MadcapJetOpenKey(
                    &DbCtx,
                    MCAST_COL_NAME(MCAST_TBL_CLIENT_ID),
                    SearchInfo->SearchInfo.ClientHardwareAddress.Data,
                    SearchInfo->SearchInfo.ClientHardwareAddress.DataLength );

        break;
    default:
        DhcpPrint(( DEBUG_APIS, "DhcpGetMClientInfo is called "
                        "with invalid parameter.\n"));
        Error = ERROR_INVALID_PARAMETER;
        break;
    }


    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = MadcapGetCurrentClientInfo( ClientInfo, NULL, NULL, 0 );

Cleanup:

    UNLOCK_DATABASE();

    if( Error != ERROR_SUCCESS ) {

        DhcpPrint(( DEBUG_APIS, "DhcpGetMClientInfo failed, %ld.\n",
                        Error ));
    }

    return( Error );
}


DWORD
R_DhcpDeleteMClientInfo(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPDHCP_SEARCH_INFO ClientInfo
    )
/*++

Routine Description:

    This function deletes the specified client record. Also it frees up
    the client IP address for redistribution.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ClientInfo : Pointer to a client information which is the key for
        the client's record search.

Return Value:

    ERROR_DHCP_CLIENT_NOT_PRESENT - if the specified client record does
        not exist on the server's database.

    Other WINDOWS errors.
--*/
{
    DWORD Error;
    DHCP_IP_ADDRESS FreeIpAddress;
    DWORD Size;
    LPBYTE ClientId = NULL;
    DWORD ClientIdLength = 0;
    BOOL TransactBegin = FALSE;
    BYTE bAllowedClientTypes;
    BYTE AddressState;
    BOOL AlreadyDeleted = FALSE;

    DhcpAssert( ClientInfo != NULL );

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }


    switch( ClientInfo->SearchType ) {
    case DhcpClientHardwareAddress:
        DhcpPrint(( DEBUG_APIS, "DhcpDeleteMClientInfo is called "
                        "with client id.\n"));
        Error = MadcapRemoveClientEntryByClientId(
                    ClientInfo->SearchInfo.ClientHardwareAddress.Data,
                    ClientInfo->SearchInfo.ClientHardwareAddress.DataLength,
                    TRUE
                    );
        break;

    case DhcpClientIpAddress:
        DhcpPrint(( DEBUG_APIS, "DhcpDeleteMClientInfo is called "
                    "with Ip Address (%s)\n",
                    DhcpIpAddressToDottedString(
                        ClientInfo->SearchInfo.ClientIpAddress
                        )
                    ));
        Error = MadcapRemoveClientEntryByIpAddress(
            ClientInfo->SearchInfo.ClientIpAddress,
            TRUE
            );
        break;
        
    default:
        DhcpPrint(( DEBUG_APIS, "DhcpDeleteMClientInfo is called "
                        "with invalid parameter.\n"));
        Error = ERROR_INVALID_PARAMETER;
        break;
    }

    return(Error);
}

DWORD
R_DhcpEnumMScopeClients(
    DHCP_SRV_HANDLE ServerIpAddress,
    LPWSTR          pMScopeName,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_MCLIENT_INFO_ARRAY *ClientInfo,
    DWORD *ClientsRead,
    DWORD *ClientsTotal
    )
/*++

Routine Description:

    This function returns all registered clients of the specified
    subnet. However it returns clients from all subnets if the subnet
    address specified is zero.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet. Client filter is disabled
        and clients from all subnet are returned if this subnet address
        is zero.

    ResumeHandle : Pointer to a resume handle where the resume
        information is returned. The resume handle should be set to zero on
        first call and left unchanged for subsequent calls.

    PreferredMaximum : Preferred maximum length of the return buffer.

    ClientInfo : Pointer to a location where the return buffer
        pointer is stored. Caller should free up this buffer
        after use by calling DhcpRPCFreeMemory().

    ClientsRead : Pointer to a DWORD where the number of clients
        that in the above buffer is returned.

    ClientsTotal : Pointer to a DWORD where the total number of
        clients remaining from the current position is returned.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_MORE_DATA - if more elements available to enumerate.

    ERROR_NO_MORE_ITEMS - if no more element to enumerate.

    Other WINDOWS errors.
--*/
{
    DWORD Error;
    JET_ERR JetError;
    DWORD i;
    JET_RECPOS JetRecordPosition;
    LPDHCP_MCLIENT_INFO_ARRAY LocalEnumInfo = NULL;
    DWORD ElementsCount;
    DB_CTX  DbCtx;
    PM_SUBNET   pMScope;

    DWORD RemainingRecords;
    DWORD ConsumedSize;
    DHCP_RESUME_HANDLE LocalResumeHandle = 0;

    if (!pMScopeName) {
        return ERROR_INVALID_PARAMETER;
    }

    DhcpAssert( *ClientInfo == NULL );

    Error = DhcpBeginReadApi( "DhcpEnumMScopeClients" );
    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    Error = DhcpServerFindMScope(
        DhcpGetCurrentServer(),
        INVALID_MSCOPE_ID,
        pMScopeName,
        &pMScope
        );

    if ( ERROR_SUCCESS != Error ) {
        DhcpEndReadApi( "DhcpEnumMScopeClients", Error );
        return ERROR_DHCP_SUBNET_NOT_PRESENT;
    }
    LOCK_DATABASE();


    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    // position the current record pointer to appropriate position.
    if( *ResumeHandle == 0 ) {
        // fresh enumeration, start from begining.
        Error = MadcapJetPrepareSearch(
                    &DbCtx,
                    MCAST_COL_NAME(MCAST_TBL_IPADDRESS),
                    TRUE,   // Search from start
                    NULL,
                    0
                    );
    } else {
        // start from the record where we stopped last time.
        // we place the IpAddress of last record in the resume handle.

        DhcpAssert( sizeof(*ResumeHandle) == sizeof(DHCP_IP_ADDRESS) );
        Error = MadcapJetPrepareSearch(
                    &DbCtx,
                    MCAST_COL_NAME(MCAST_TBL_IPADDRESS),
                    FALSE,
                    ResumeHandle,
                    sizeof(*ResumeHandle) );
     }

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    // now query remaining records in the database.
    Error = MadcapJetGetRecordPosition(
                    &DbCtx,
                    &JetRecordPosition,
                    sizeof(JET_RECPOS) );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }
    DhcpPrint(( DEBUG_APIS, "JetGetRecordPosition returned, "
                    "entriesLT = %ld, "
                    "entriesInRange = %ld, "
                    "entriesTotal = %ld.\n",
                        JetRecordPosition.centriesLT,
                        JetRecordPosition.centriesInRange,
                        JetRecordPosition.centriesTotal ));

#if 0
    //
    // IpAddress is unique, we find exactly one record for this key.
    //

    DhcpAssert( JetRecordPosition.centriesInRange == 1 );

    RemainingRecords = JetRecordPosition.centriesTotal -
                            JetRecordPosition.centriesLT;

    DhcpAssert( (INT)RemainingRecords > 0 );

    if( RemainingRecords == 0 ) {
        Error = ERROR_NO_MORE_ITEMS;
        goto Cleanup;
    }

#else
    // ?? always return big value, until we know a reliable way to
    // determine the remaining records.
    RemainingRecords = 0x7FFFFFFF;
#endif

    // limit resource.
    if( PreferredMaximum > DHCP_ENUM_BUFFER_SIZE_LIMIT ) {
        PreferredMaximum = DHCP_ENUM_BUFFER_SIZE_LIMIT;
    }

    // if the PreferredMaximum buffer size is too small ..
    if( PreferredMaximum < DHCP_ENUM_BUFFER_SIZE_LIMIT_MIN ) {
        PreferredMaximum = DHCP_ENUM_BUFFER_SIZE_LIMIT_MIN;
    }

    // allocate enum array.
    // determine possible number of records that can be returned in
    // PreferredMaximum buffer;
    ElementsCount =
        ( PreferredMaximum - sizeof(DHCP_MCLIENT_INFO_ARRAY) ) /
            (sizeof(LPDHCP_MCLIENT_INFO) + sizeof(DHCP_MCLIENT_INFO));

    LocalEnumInfo = MIDL_user_allocate( sizeof(DHCP_MCLIENT_INFO_ARRAY) );

    if( LocalEnumInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalEnumInfo->NumElements = 0;
    LocalEnumInfo->Clients =
        MIDL_user_allocate(sizeof(LPDHCP_MCLIENT_INFO) * ElementsCount);
    if( LocalEnumInfo->Clients == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    ConsumedSize = sizeof(DHCP_MCLIENT_INFO_ARRAY);
    for( i = 0;
                // if we have filled up the return buffer.
            (LocalEnumInfo->NumElements < ElementsCount) &&
                // no more record in the database.
            (i < RemainingRecords);
                        i++ ) {

        LPDHCP_MCLIENT_INFO CurrentClientInfo;
        DWORD CurrentInfoSize;
        DWORD NewSize;
        BOOL ValidClient;

        //
        // read current record.
        //


        CurrentClientInfo = NULL;
        CurrentInfoSize = 0;
        ValidClient = FALSE;

        Error = MadcapGetCurrentClientInfo(
                    &CurrentClientInfo,
                    &CurrentInfoSize,
                    &ValidClient,
                    pMScope->MScopeId );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        if( ValidClient ) {

            //
            // client belongs to the requested subnet, so pack it.
            //

            NewSize =
                ConsumedSize +
                    CurrentInfoSize +
                        sizeof(LPDHCP_MCLIENT_INFO); // for pointer.

            if( NewSize < PreferredMaximum ) {

                //
                // we have space for the current record.
                //

                LocalEnumInfo->Clients[LocalEnumInfo->NumElements] =
                    CurrentClientInfo;
                LocalEnumInfo->NumElements++;

                ConsumedSize = NewSize;
            }
            else {

                //
                // we have filled the buffer.
                //

                Error = ERROR_MORE_DATA;

                if( 0 ) {
                    //
                    //  resume handle has to be the LAST ip address RETURNED.
                    //  this is the next one.. so don't do this..
                    //
                    LocalResumeHandle =
                        (DHCP_RESUME_HANDLE)CurrentClientInfo->ClientIpAddress;
                }
                
                //
                // free last record.
                //

                _fgs__DHCP_MCLIENT_INFO ( CurrentClientInfo );

                break;
            }

        }

        //
        // move to next record.
        //

        Error = MadcapJetNextRecord(&DbCtx);

        if( Error != ERROR_SUCCESS ) {

            if( Error == ERROR_NO_MORE_ITEMS ) {
                break;
            }

            goto Cleanup;
        }
    }

    *ClientInfo = LocalEnumInfo;
    *ClientsRead = LocalEnumInfo->NumElements;

    if( Error == ERROR_NO_MORE_ITEMS ) {

        *ClientsTotal = LocalEnumInfo->NumElements;
        *ResumeHandle = 0;
        Error = ERROR_SUCCESS;

#if 0
        //
        // when we have right RemainingRecords count.
        //

        DhcpAssert( RemainingRecords == LocalEnumInfo->NumElements );
#endif

    }
    else {

        *ClientsTotal = RemainingRecords;
        if( LocalResumeHandle != 0 ) {

            *ResumeHandle = LocalResumeHandle;
        }
        else {

            *ResumeHandle =
                LocalEnumInfo->Clients
                    [LocalEnumInfo->NumElements - 1]->ClientIpAddress;
        }

        Error = ERROR_MORE_DATA;
    }

Cleanup:

    UNLOCK_DATABASE();

    if( (Error != ERROR_SUCCESS) &&
        (Error != ERROR_MORE_DATA) ) {

        //
        // if we aren't succssful return locally allocated buffer.
        //

        if( LocalEnumInfo != NULL ) {
            _fgs__DHCP_MCLIENT_INFO_ARRAY( LocalEnumInfo );
            MIDL_user_free( LocalEnumInfo );
        }

    }

    DhcpEndReadApi( "DhcpEnumMScopeClients", Error );
    return(Error);
}


DWORD
R_DhcpScanMDatabase(
    LPWSTR ServerIpAddress,
    LPWSTR          pMScopeName,
    DWORD FixFlag,
    LPDHCP_SCAN_LIST *ScanList
    )
/*++

Routine Description:

    This function scans the database entries and registry bit-map for
    specified subnet scope and veryfies to see they match. If they
    don't match, this api will return the list of inconsistent entries.
    Optionally FixFlag can be used to fix the bad entries.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : Address of the subnet scope to verify.

    FixFlag : If this flag is TRUE, this api will fix the bad entries.

    ScanList : List of bad entries returned. The caller should free up
        this memory after it has been used.


Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error;
    PM_SUBNET   pMScope;

    DhcpPrint(( DEBUG_APIS, "DhcpScanMDatabase is called. (%ws)\n",pMScopeName));

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }


    DhcpAcquireWriteLock();

    Error = DhcpFlushBitmaps();
    DhcpAssert(ERROR_SUCCESS == Error);

    Error = MemServerFindMScope(
                DhcpGetCurrentServer(),
                INVALID_MSCOPE_ID,
                pMScopeName,
                &pMScope);

    if( ERROR_FILE_NOT_FOUND == Error ) {
        Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
        goto Cleanup;
    }

    if( ERROR_SUCCESS != Error) goto Cleanup;

    DhcpAssert(NULL != pMScope);

    Error = ScanDatabase(
        pMScope,
        FixFlag,
        ScanList
    );

Cleanup:

    DhcpReleaseWriteLock();
    DhcpScheduleRogueAuthCheck();


    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_APIS, "DhcpScanMDatabase  failed, %ld.\n",
                        Error ));
    }

    return(Error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\mib.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mib.c

Abstract:

    This module contains the implementation of DHCP MIB API.

Author:

    Madan Appiah (madana)  14-Jan-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#include    <dhcppch.h>
#include    <rpcapi.h>
#include    <mdhcpsrv.h>

DWORD
DhcpUpdateInUseCount(
    IN      PM_RANGE  InitialRange,	// the initial range
    IN      PM_RANGE  ThisSubRange,	// interval included in the initial range
    IN OUT  PDWORD    pAddrInUse)   // cumulative value for the InUse number of bits
{
    DWORD   Error;

    // parameters should be valid
    DhcpAssert( InitialRange != NULL &&
                ThisSubRange != NULL &&
                pAddrInUse != NULL);

    // ThisSubRange has to be a sub range of InitialRange
    DhcpAssert( InitialRange->Start <= ThisSubRange->Start && ThisSubRange->End <= InitialRange->End);
    // The InitialRange should have a valid BitMask
    DhcpAssert( InitialRange->BitMask != NULL);

    // update the pAddrInUse: this is all what we are working for!
    *pAddrInUse += MemBitGetSetBitsInRange(InitialRange->BitMask,
                                          ThisSubRange->Start - InitialRange->Start,
                                          ThisSubRange->End - InitialRange->Start);
    return ERROR_SUCCESS;
}

DWORD
DhcpGetFreeInRange(
    IN      PM_RANGE    InitialRange,
    IN      PARRAY      Exclusions,
    OUT     PDWORD      AddrFree,
    OUT     PDWORD      AddrInUse
)
{
    DWORD Error;
    DWORD BackupError;

    // variables for the Exclusion list
    ARRAY_LOCATION      LocExcl;
    PM_RANGE            ThisExclusion = NULL;
    DWORD               IpExcluded;
    DWORD               i;

    // variables for the Ranges list
    PM_RANGE            firstRange = NULL;
    ARRAY               Ranges;
    ARRAY_LOCATION      LocRanges;
    PM_RANGE            ThisRange = NULL;
    DWORD               IpRanges;
    DWORD               j;

	// Parameters should be valid
	DhcpAssert(InitialRange != NULL && Exclusions != NULL);

    // init the list of Ranges to scan
    firstRange = MemAlloc(sizeof(M_RANGE));
    if (firstRange == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;
    // use here MemRangeInit instead
    firstRange->Start = InitialRange->Start;
    firstRange->End = InitialRange->End;
    // insert firstRange element in the list
    Error = MemArrayInit(&Ranges);
    Error = MemArrayInitLoc(&Ranges, &LocRanges);

    Error = MemArrayInsElement(&Ranges, &LocRanges, firstRange);
    if (Error != ERROR_SUCCESS)
    {
        MemFree(firstRange);
        return Error;           // free firstRange here?
    }

    // scan the list of excluded IP addresses
    IpExcluded = MemArraySize(Exclusions);
    Error = MemArrayInitLoc(Exclusions, &LocExcl);
    for (i = 0; i < IpExcluded; i++)
    {
        // {ThisExclusion} = interval of IP addresses to exclude
        Error = MemArrayGetElement(Exclusions, &LocExcl, &ThisExclusion);
        DhcpAssert(ERROR_SUCCESS == Error && ThisExclusion);

        // walk through the list of Ranges to scan and remove exclusion from Ranges.
        IpRanges = MemArraySize(&Ranges);
        Error = MemArrayInitLoc(&Ranges, &LocRanges);
        for (j = 0; j < IpRanges; j++)
        {
            // [ThisRange] = interval of IP addresses to intersect with the exclusion
            Error = MemArrayGetElement(&Ranges, &LocRanges, &ThisRange);
            DhcpAssert(ERROR_SUCCESS == Error && ThisRange);

            // {}[] -> This Exclusion is done, go to the next one. (Ranges list is ordered!)
            if (ThisExclusion->End < ThisRange->Start)
                break;
            // {[}] or {[]}
            if (ThisExclusion->Start <= ThisRange->Start)
            {
                // {[}] -> adjust range and go to the next exclusion
                if (ThisExclusion->End < ThisRange->End)
                {
                    ThisRange->Start = ThisExclusion->End + 1;
                    break;
                }
                // {[]} -> remove this range and go to the next range
                else
                {
                    Error = MemArrayDelElement(&Ranges, &LocRanges, &ThisRange);
                    MemFree(ThisRange);
                    IpRanges--; j--; // reflect new size and rollback index one position
                    continue;        // next iteration on same element
                }
            }
            // [{}] or [{]}
            else if (ThisExclusion->Start <= ThisRange->End)
            {
                // [{]} -> adjust the range and go to the next range
                if (ThisExclusion->End >= ThisRange->End)
                {
                    ThisRange->End = ThisExclusion->Start - 1;
                }
                // [{}] -> break the range in two and go to the next exclusion
                else
                {
                    PM_RANGE newRange;

                    newRange = MemAlloc(sizeof(M_RANGE));
                    if (newRange == NULL)
                    {
                        Error = ERROR_NOT_ENOUGH_MEMORY;     // should the Ranges list be released?
                        goto cleanup;
                    }
                    // use here MemRangeInit instead
                    newRange->Start = ThisRange->Start;
                    newRange->End = ThisExclusion->Start - 1;
                    ThisRange->Start = ThisExclusion->End + 1;
                    // insert newRange element before ThisRange
                    Error = MemArrayInsElement(&Ranges, &LocRanges, newRange);
                    if (Error != ERROR_SUCCESS)
                        goto cleanup;                       // should the Ranges list be released?
                    break;
                }
            }
            // []{} -> nothing special to do, go to the next Range

            Error = MemArrayNextLoc(&Ranges, &LocRanges);
            DhcpAssert(ERROR_SUCCESS == Error || j == IpRanges-1);
        }

        Error = MemArrayNextLoc(Exclusions, &LocExcl);
        DhcpAssert(ERROR_SUCCESS == Error || i == IpExcluded-1);
    }

    // if this point is hit, everything went fine
    Error = ERROR_SUCCESS;

cleanup:
    // sum here all the free addresses from the Ranges list
    IpRanges = MemArraySize(&Ranges);
    MemArrayInitLoc(&Ranges, &LocRanges);

	// I have here the list of all "active" ranges (Ranges)
	// and also the Bitmask of the InitialRange so I have everything
	// to find out which addresses are really in use (outside an exclusion range)
	// I can do this in the same loop below as far as the Ranges list is ordered!

    *AddrFree = 0;
    *AddrInUse = 0;

	// InitialRange should have a valid BitMask at this point
    DhcpAssert(InitialRange->BitMask != NULL);

    for (j = 0; j < IpRanges; j++)
    {
        BackupError = MemArrayGetElement(&Ranges, &LocRanges, &ThisRange);
        DhcpAssert(ERROR_SUCCESS == BackupError && ThisRange);

        *AddrFree += ThisRange->End - ThisRange->Start + 1;
        DhcpUpdateInUseCount(InitialRange, ThisRange, AddrInUse);

        MemFree(ThisRange);

        BackupError = MemArrayNextLoc(&Ranges, &LocRanges);
        DhcpAssert(ERROR_SUCCESS == BackupError|| j == IpRanges-1);
    }
    // cleanup all the memory allocated in this function
    MemArrayCleanup(&Ranges);

    return Error;
}

DWORD
DhcpSubnetGetMibCount(
    IN      PM_SUBNET               Subnet,
    OUT     PDWORD                  AddrInUse,
    OUT     PDWORD                  AddrFree,
    OUT     PDWORD                  AddrPending
)
{
    PARRAY                         Ranges;
    ARRAY_LOCATION                 Loc2;
    PM_RANGE                       ThisRange = NULL;
    PARRAY                         Exclusions;
    PM_EXCL                        ThisExcl = NULL;
    DWORD                          IpRanges;
    DWORD                          Error = ERROR_SUCCESS;
    PLIST_ENTRY                    listEntry;
    LPPENDING_CONTEXT              PendingContext;
    DWORD                          j;

    *AddrInUse = 0;
    *AddrFree = 0;
    *AddrPending = 0;

    if (IS_DISABLED(Subnet->State)) return ERROR_SUCCESS;

    Ranges = &Subnet->Ranges;
    IpRanges = MemArraySize(Ranges);
    Exclusions = &Subnet->Exclusions;

    //
    // add all subnet ranges.
    //

    Error = MemArrayInitLoc(Ranges, &Loc2);

    for( j = 0; j < IpRanges; j++ ) {
        DWORD	FreeInRange;
		DWORD	InUseInRange;

        Error = MemArrayGetElement(Ranges, &Loc2, &ThisRange);
        DhcpAssert(ERROR_SUCCESS == Error && ThisRange);
        Error = MemArrayNextLoc(Ranges, &Loc2);
        DhcpAssert(ERROR_SUCCESS == Error || j == IpRanges-1);

        Error = DhcpGetFreeInRange(ThisRange, Exclusions, &FreeInRange, &InUseInRange);
        if (ERROR_SUCCESS != Error)
            return Error;

        *AddrFree  += FreeInRange;
        *AddrInUse += InUseInRange;
    }

    //
    // finally subtract InUse count.
    //

    *AddrFree -=  *AddrInUse;

    LOCK_INPROGRESS_LIST();
    *AddrPending = Subnet->fSubnet ? DhcpCountIPPendingCtxt(Subnet->Address, Subnet->Mask)
                                   : DhcpCountMCastPendingCtxt( Subnet->MScopeId );
    UNLOCK_INPROGRESS_LIST();

    return Error;
}

DWORD
QueryMibInfo(
    OUT     LPDHCP_MIB_INFO       *MibInfo
)
{
    DWORD                          Error;
    LPDHCP_MIB_INFO                LocalMibInfo = NULL;
    LPSCOPE_MIB_INFO               LocalScopeMibInfo = NULL;
    DHCP_KEY_QUERY_INFO            QueryInfo;
    DWORD                          SubnetCount;

    DWORD                          i;
    DWORD                          NumAddressesInUse;

    PARRAY                         Subnets;
    ARRAY_LOCATION                 Loc;
    PM_SUBNET                      ThisSubnet = NULL;

    DhcpAssert( *MibInfo == NULL );

    //
    // allocate counter buffer.
    //

    LocalMibInfo = MIDL_user_allocate( sizeof(DHCP_MIB_INFO) );

    if( LocalMibInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalMibInfo->Discovers = DhcpGlobalNumDiscovers;
    LocalMibInfo->Offers = DhcpGlobalNumOffers;
    LocalMibInfo->Requests = DhcpGlobalNumRequests;
    LocalMibInfo->Acks = DhcpGlobalNumAcks;
    LocalMibInfo->Naks = DhcpGlobalNumNaks;
    LocalMibInfo->Declines = DhcpGlobalNumDeclines;
    LocalMibInfo->Releases = DhcpGlobalNumReleases;
    LocalMibInfo->ServerStartTime = DhcpGlobalServerStartTime;
    LocalMibInfo->Scopes = 0;
    LocalMibInfo->ScopeInfo = NULL;


    //
    // query number of available subnets on this server.
    //

    SubnetCount = DhcpServerGetSubnetCount(DhcpGetCurrentServer());
    if( 0 == SubnetCount ) {
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // allocate memory for the scope information.
    //

    LocalScopeMibInfo = MIDL_user_allocate(sizeof( SCOPE_MIB_INFO )*SubnetCount );

    if( LocalScopeMibInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Subnets = &(DhcpGetCurrentServer()->Subnets);
    Error = MemArrayInitLoc(Subnets, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error);

    for ( i = 0; i < SubnetCount; i++) {          // process each subnet

        Error = MemArrayGetElement(Subnets, &Loc, (LPVOID *)&ThisSubnet);
        DhcpAssert(ERROR_SUCCESS == Error);
        Error = MemArrayNextLoc(Subnets, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error || i == SubnetCount-1);

        LocalScopeMibInfo[i].Subnet = ThisSubnet->Address;
        Error = DhcpSubnetGetMibCount(
                    ThisSubnet,
                    &LocalScopeMibInfo[i].NumAddressesInuse,
                    &LocalScopeMibInfo[i].NumAddressesFree,
                    &LocalScopeMibInfo[i].NumPendingOffers
                    );

    }

    //
    // Finally set return buffer.
    //

    LocalMibInfo->Scopes = SubnetCount;
    LocalMibInfo->ScopeInfo = LocalScopeMibInfo;

    Error = ERROR_SUCCESS;

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // Free up Locally alloted memory.
        //

        if( LocalMibInfo != NULL ) {
            MIDL_user_free( LocalMibInfo );
        }

        if( LocalScopeMibInfo != NULL ) {
            MIDL_user_free( LocalScopeMibInfo );
        }
    } else {
        *MibInfo = LocalMibInfo;
    }

    return( Error );
}

DWORD
R_DhcpGetMibInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_MIB_INFO *MibInfo
    )
/*++

Routine Description:

    This function retrives all counter values of the DHCP server
    service.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    MibInfo : pointer a counter/table buffer. Caller should free up this
        buffer after usage.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error;

    UNREFERENCED_PARAMETER( ServerIpAddress );

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );

    if ( Error != ERROR_SUCCESS ) return( Error );

    DhcpAcquireReadLock();
    Error = QueryMibInfo( MibInfo );
    DhcpReleaseReadLock();

    return Error;
}

DWORD
QueryMCastMibInfo(
    OUT     LPDHCP_MCAST_MIB_INFO       *MCastMibInfo
)
{
    DWORD                          Error;
    LPDHCP_MCAST_MIB_INFO          LocalMCastMibInfo = NULL;
    LPMSCOPE_MIB_INFO              LocalMScopeMibInfo = NULL;
    DHCP_KEY_QUERY_INFO            QueryInfo;
    DWORD                          IpRanges;
    DWORD                          MScopeCount;

    DWORD                          i, j;
    DWORD                          NumAddressesInUse;

    PARRAY                         MScopes;
    ARRAY_LOCATION                 Loc;
    PM_SUBNET                      ThisMScope = NULL;

    DhcpAssert( *MCastMibInfo == NULL );

    //
    // allocate counter buffer.
    //

    LocalMCastMibInfo = MIDL_user_allocate( sizeof(DHCP_MCAST_MIB_INFO) );

    if( LocalMCastMibInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalMCastMibInfo->Discovers = MadcapGlobalMibCounters.Discovers;
    LocalMCastMibInfo->Offers = MadcapGlobalMibCounters.Offers;
    LocalMCastMibInfo->Requests = MadcapGlobalMibCounters.Requests;
    LocalMCastMibInfo->Renews = MadcapGlobalMibCounters.Renews;
    LocalMCastMibInfo->Acks = MadcapGlobalMibCounters.Acks;
    LocalMCastMibInfo->Naks = MadcapGlobalMibCounters.Naks;
    LocalMCastMibInfo->Releases = MadcapGlobalMibCounters.Releases;
    LocalMCastMibInfo->Informs = MadcapGlobalMibCounters.Informs;
    LocalMCastMibInfo->ServerStartTime = DhcpGlobalServerStartTime;
    LocalMCastMibInfo->Scopes = 0;
    LocalMCastMibInfo->ScopeInfo = NULL;


    //
    // query number of available subnets on this server.
    //

    MScopeCount = DhcpServerGetMScopeCount(DhcpGetCurrentServer());
    if( 0 == MScopeCount ) {
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // allocate memory for the scope information.
    //

    LocalMScopeMibInfo = MIDL_user_allocate(sizeof( MSCOPE_MIB_INFO )*MScopeCount );

    if( LocalMScopeMibInfo == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    MScopes = &(DhcpGetCurrentServer()->MScopes);
    Error = MemArrayInitLoc(MScopes, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error);

    for ( i = 0; i < MScopeCount; i++) {          // process each subnet

        Error = MemArrayGetElement(MScopes, &Loc, (LPVOID *)&ThisMScope);
        DhcpAssert(ERROR_SUCCESS == Error);
        Error = MemArrayNextLoc(MScopes, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error || i == MScopeCount-1);

        LocalMScopeMibInfo[i].MScopeId = ThisMScope->MScopeId;
        LocalMScopeMibInfo[i].MScopeName =  MIDL_user_allocate( WSTRSIZE( ThisMScope->Name ) );
        if (LocalMScopeMibInfo[i].MScopeName) {
            wcscpy(LocalMScopeMibInfo[i].MScopeName,ThisMScope->Name);
        }
        Error = DhcpSubnetGetMibCount(
                    ThisMScope,
                    &LocalMScopeMibInfo[i].NumAddressesInuse,
                    &LocalMScopeMibInfo[i].NumAddressesFree,
                    &LocalMScopeMibInfo[i].NumPendingOffers
                    );

    }

    //
    // Finally set return buffer.
    //

    LocalMCastMibInfo->Scopes = MScopeCount;
    LocalMCastMibInfo->ScopeInfo = LocalMScopeMibInfo;

    Error = ERROR_SUCCESS;
Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // Free up Locally alloted memory.
        //

        if( LocalMCastMibInfo != NULL ) {
            MIDL_user_free( LocalMCastMibInfo );
        }

        if( LocalMScopeMibInfo != NULL ) {
            MIDL_user_free( LocalMScopeMibInfo );
        }
    } else {
        *MCastMibInfo = LocalMCastMibInfo;
    }

    return( Error );
}

DWORD
R_DhcpGetMCastMibInfo(
    LPWSTR ServerIpAddress,
    LPDHCP_MCAST_MIB_INFO *MCastMibInfo
    )
/*++

Routine Description:

    This function retrives all counter values of the DHCP server
    service.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    MCastMibInfo : pointer a counter/table buffer. Caller should free up this
        buffer after usage.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error;

    UNREFERENCED_PARAMETER( ServerIpAddress );

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );

    if ( Error != ERROR_SUCCESS ) return( Error );

    DhcpAcquireReadLock();
    Error = QueryMCastMibInfo( MCastMibInfo );
    DhcpReleaseReadLock();

    return Error;
}

BOOL
IsStringTroublesome(
    IN LPCWSTR Str
    )
{
    LPBYTE Buf;
    BOOL fResult;
    DWORD Size;
    
    //
    // A string is troublesome if it can't be converted to
    // OEM or ANSI code pages without any errors
    //

    Size = 1 + wcslen(Str)*3;
    Buf = DhcpAllocateMemory(Size);
    if( NULL == Buf ) return TRUE;

    fResult = FALSE;
    do {
        if( 0 == WideCharToMultiByte(
            CP_ACP, WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK |
            WC_DEFAULTCHAR, Str, -1, Buf, Size, NULL, &fResult
            ) ) {
            fResult = TRUE;
            break;
        }

        if( fResult ) break;

        if( 0 == WideCharToMultiByte(
            CP_OEMCP, WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK |
            WC_DEFAULTCHAR, Str, -1, Buf, Size, NULL, &fResult
            ) ) {
            fResult = TRUE;
            break;
        }
        
    } while ( 0 );

    DhcpFreeMemory( Buf );
    return fResult;
}

DWORD
R_DhcpServerSetConfig(
    LPWSTR  ServerIpAddress,
    DWORD   FieldsToSet,
    LPDHCP_SERVER_CONFIG_INFO ConfigInfo
    )
/*++

Routine Description:

    This function sets the DHCP server configuration information.
    Serveral of the configuration information will become effective
    immediately.  This function is provided to emulate the pre-NT4SP2
    RPC interface to allow interoperability with older versions of the
    DHCP Administrator application.

    The following parameters require restart of the service after this
    API is called successfully.

        Set_APIProtocolSupport
        Set_DatabaseName
        Set_DatabasePath
        Set_DatabaseLoggingFlag
        Set_RestoreFlag

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    FieldsToSet : Bit mask of the fields in the ConfigInfo structure to
        be set.

    ConfigInfo: Pointer to the info structure to be set.


Return Value:

    WINDOWS errors.
--*/

{
    DWORD                      dwResult;

    dwResult = R_DhcpServerSetConfigV4(
                        ServerIpAddress,
                        FieldsToSet,
                        (DHCP_SERVER_CONFIG_INFO_V4 *) ConfigInfo );

    return dwResult;
}


DWORD
R_DhcpServerSetConfigV4(
    LPWSTR ServerIpAddress,
    DWORD FieldsToSet,
    LPDHCP_SERVER_CONFIG_INFO_V4 ConfigInfo
    )
/*++

Routine Description:

    This function sets the DHCP server configuration information.
    Serveral of the configuration information will become effective
    immediately.

    The following parameters require restart of the service after this
    API is called successfully.

        Set_APIProtocolSupport
        Set_DatabaseName
        Set_DatabasePath
        Set_DatabaseLoggingFlag
        Set_RestoreFlag

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    FieldsToSet : Bit mask of the fields in the ConfigInfo structure to
        be set.

    ConfigInfo: Pointer to the info structure to be set.


Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error, Tmp;
    BOOL BoolError;

    LPSTR OemDatabaseName = NULL;
    LPSTR OemDatabasePath = NULL;
    LPSTR OemBackupPath = NULL;
    LPSTR OemJetBackupPath = NULL;
    LPWSTR BackupConfigFileName = NULL;

    BOOL RecomputeTimer = FALSE;

    DhcpPrint(( DEBUG_APIS, "DhcpServerSetConfig is called.\n" ));
    DhcpAssert( ConfigInfo != NULL );

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    if( FieldsToSet == 0 ) {
        goto Cleanup;
    }

    //
    // Set API Protocol parameter. Requires service restart.
    //

    if( FieldsToSet & Set_APIProtocolSupport ) {

        //
        // atleast a protocol should be enabled.
        //

        if( ConfigInfo->APIProtocolSupport == 0 ) {
            Error = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_API_PROTOCOL_VALUE,
                    0,
                    DHCP_API_PROTOCOL_VALUE_TYPE,
                    (LPBYTE)&ConfigInfo->APIProtocolSupport,
                    sizeof(ConfigInfo->APIProtocolSupport)
                    );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        DhcpGlobalRpcProtocols = ConfigInfo->APIProtocolSupport;
    }

    if( FieldsToSet & Set_PingRetries ) {
        if ( ConfigInfo->dwPingRetries + 1 >= MIN_DETECT_CONFLICT_RETRIES + 1&&
             ConfigInfo->dwPingRetries <= MAX_DETECT_CONFLICT_RETRIES )
        {
            Error = RegSetValueEx(
                        DhcpGlobalRegParam,
                        DHCP_DETECT_CONFLICT_RETRIES_VALUE,
                        0,
                        DHCP_DETECT_CONFLICT_RETRIES_VALUE_TYPE,
                        (LPBYTE) &ConfigInfo->dwPingRetries,
                        sizeof( ConfigInfo->dwPingRetries ));

            if ( ERROR_SUCCESS != Error )
                goto Cleanup;

            DhcpGlobalDetectConflictRetries = ConfigInfo->dwPingRetries;
        }
        else
        {
            // invalid parameter
            Error = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    if ( FieldsToSet & Set_AuditLogState )
    {
        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_AUDIT_LOG_FLAG_VALUE,
                    0,
                    DHCP_AUDIT_LOG_FLAG_VALUE_TYPE,
                    (LPBYTE) &ConfigInfo->fAuditLog,
                    sizeof( ConfigInfo->fAuditLog )
                    );

        if ( ERROR_SUCCESS != Error )
            goto Cleanup;

        DhcpGlobalAuditLogFlag = ConfigInfo->fAuditLog;

    }



    if ( FieldsToSet & Set_BootFileTable )
    {

        if ( ConfigInfo->wszBootTableString )
        {

              Error = RegSetValueEx(
                            DhcpGlobalRegGlobalOptions,
                            DHCP_BOOT_FILE_TABLE,
                            0,
                            DHCP_BOOT_FILE_TABLE_TYPE,
                            (LPBYTE) ConfigInfo->wszBootTableString,
                            ConfigInfo->cbBootTableString
                            );

              if ( ERROR_SUCCESS != Error )
                  goto Cleanup;
        }
        else
            RegDeleteValue( DhcpGlobalRegGlobalOptions,
                            DHCP_BOOT_FILE_TABLE );
    }

    //
    // Set Database name parameter. Requires service restart.
    //

    if( FieldsToSet & Set_DatabaseName ) {

        //
        // can't be a NULL string.
        //

        if( (ConfigInfo->DatabaseName == NULL) ||
            (wcslen(ConfigInfo->DatabaseName ) == 0) ) {

            Error = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        if( IsStringTroublesome( ConfigInfo->DatabaseName ) ) {
            Error = ERROR_INVALID_NAME;
            goto Cleanup;
        }
        
        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_DB_NAME_VALUE,
                    0,
                    DHCP_DB_NAME_VALUE_TYPE,
                    (LPBYTE)ConfigInfo->DatabaseName,
                    (wcslen(ConfigInfo->DatabaseName) + 1) *
                        sizeof(WCHAR) );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // update the global parameter.
        //

        OemDatabaseName = DhcpUnicodeToOem(
                            ConfigInfo->DatabaseName,
                            NULL ); // allocate memory.

        if( OemDatabaseName == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }


    }

    //
    // Set Database path parameter. Requires service restart.
    //

    if( FieldsToSet & Set_DatabasePath ) {

        //
        // can't be a NULL string.
        //

        if( (ConfigInfo->DatabasePath == NULL) ||
            (wcslen(ConfigInfo->DatabasePath ) == 0) ) {

            Error = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        if( IsStringTroublesome( ConfigInfo->DatabasePath ) ) {
            Error = ERROR_INVALID_NAME;
            goto Cleanup;
        }
        
        //
        // create the backup directory if it is not there.
        //

        BoolError = CreateDirectoryPathW(
            ConfigInfo->DatabasePath,
            DhcpGlobalSecurityDescriptor
            );

        if( !BoolError ) {

            Error = GetLastError();
            if( Error != ERROR_ALREADY_EXISTS ) {
                goto Cleanup;
            }
            Error = ERROR_SUCCESS;
        }

        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_DB_PATH_VALUE,
                    0,
                    DHCP_DB_PATH_VALUE_TYPE,
                    (LPBYTE)ConfigInfo->DatabasePath,
                    (wcslen(ConfigInfo->DatabasePath) + 1) *
                        sizeof(WCHAR) );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // update the global parameter.
        //

        OemDatabasePath = DhcpUnicodeToOem(
                            ConfigInfo->DatabasePath,
                            NULL ); // allocate memory.

        if( OemDatabasePath == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

    }

    //
    // Set Backup path parameter.
    //

    if( FieldsToSet & Set_BackupPath ) {

        //
        // can't be a NULL string.
        //

        if( (ConfigInfo->BackupPath == NULL) ||
            (wcslen(ConfigInfo->BackupPath ) == 0) ) {

            Error = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }


        if( IsStringTroublesome( ConfigInfo->BackupPath ) ) {
            Error = ERROR_INVALID_NAME;
            goto Cleanup;
        }
        //
        // create the backup directory if it is not there.
        //

        BoolError = CreateDirectoryPathW(
            ConfigInfo->BackupPath,
            DhcpGlobalSecurityDescriptor
            );

        if( !BoolError ) {

            Error = GetLastError();
            if( Error != ERROR_ALREADY_EXISTS ) {
                goto Cleanup;
            }
            Error = ERROR_SUCCESS;
        }

        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_BACKUP_PATH_VALUE,
                    0,
                    DHCP_BACKUP_PATH_VALUE_TYPE,
                    (LPBYTE)ConfigInfo->BackupPath,
                    (wcslen(ConfigInfo->BackupPath) + 1) *
                        sizeof(WCHAR) );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // update the global parameter, so that next backup will be done
        // using the new path.
        //

        OemBackupPath = DhcpUnicodeToOem(
                            ConfigInfo->BackupPath,
                            NULL ); // allocate memory.

        if( OemBackupPath == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }


        OemJetBackupPath =
            DhcpAllocateMemory(
                (strlen(OemBackupPath) +
                 strlen(DHCP_KEY_CONNECT_ANSI) +
                 strlen(DHCP_JET_BACKUP_PATH) + 1) );

        if( OemJetBackupPath == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        strcpy( OemJetBackupPath, OemBackupPath );
        strcat( OemJetBackupPath, DHCP_KEY_CONNECT_ANSI );
        strcat( OemJetBackupPath, DHCP_JET_BACKUP_PATH );

        //
        // create the JET backup directory if it is not there.
        //

        BoolError = CreateDirectoryPathOem(
            OemJetBackupPath,
            DhcpGlobalSecurityDescriptor
            );

        if( !BoolError ) {

            Error = GetLastError();
            if( Error != ERROR_ALREADY_EXISTS ) {
                goto Cleanup;
            }
            Error = ERROR_SUCCESS;
        }

        //
        // make backup configuration (full) file name.
        //

        BackupConfigFileName =
            DhcpAllocateMemory(
                (strlen(OemBackupPath) +
                    wcslen(DHCP_KEY_CONNECT) +
                    wcslen(DHCP_BACKUP_CONFIG_FILE_NAME) + 1) *
                        sizeof(WCHAR) );

        if( BackupConfigFileName == NULL ) {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // convert oem path to unicode path.
        //

        BackupConfigFileName =
            DhcpOemToUnicode(
                OemBackupPath,
                BackupConfigFileName );

        DhcpAssert( BackupConfigFileName != NULL );

        //
        // add file name.
        //

        wcscat( BackupConfigFileName, DHCP_KEY_CONNECT );
        wcscat( BackupConfigFileName, DHCP_BACKUP_CONFIG_FILE_NAME );


        //
        // now replace Global values.
        //

        LOCK_DATABASE();

        if( DhcpGlobalOemBackupPath != NULL ) {
            DhcpFreeMemory( DhcpGlobalOemBackupPath );
        }
        DhcpGlobalOemBackupPath = OemBackupPath;

        if( DhcpGlobalOemJetBackupPath != NULL ) {
            DhcpFreeMemory( DhcpGlobalOemJetBackupPath );
        }
        DhcpGlobalOemJetBackupPath = OemJetBackupPath;

        UNLOCK_DATABASE();

        LOCK_REGISTRY();

        if( DhcpGlobalBackupConfigFileName != NULL ) {
            DhcpFreeMemory( DhcpGlobalBackupConfigFileName );
        }
        DhcpGlobalBackupConfigFileName = BackupConfigFileName;

        UNLOCK_REGISTRY();

        OemBackupPath = NULL;
        OemJetBackupPath = NULL;
        BackupConfigFileName = NULL;
    }

    //
    // Set Backup Interval parameter.
    //

    if( FieldsToSet & Set_BackupInterval ) {

        if( ConfigInfo->BackupInterval == 0 ) {
            Error = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        Tmp = ConfigInfo->BackupInterval * 60000;
        if( (Tmp/ 60000) != ConfigInfo->BackupInterval ) {
            Error = ERROR_ARITHMETIC_OVERFLOW;
            goto Cleanup;
        }
            
        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_BACKUP_INTERVAL_VALUE,
                    0,
                    DHCP_BACKUP_INTERVAL_VALUE_TYPE,
                    (LPBYTE)&ConfigInfo->BackupInterval,
                    sizeof(ConfigInfo->BackupInterval)
                    );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        DhcpGlobalBackupInterval = ConfigInfo->BackupInterval * 60000;
        RecomputeTimer = TRUE;
    }

    //
    // Set Backup Interval parameter. Requires service restart.
    //

    if( FieldsToSet & Set_DatabaseLoggingFlag ) {

        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_DB_LOGGING_FLAG_VALUE,
                    0,
                    DHCP_DB_LOGGING_FLAG_VALUE_TYPE,
                    (LPBYTE)&ConfigInfo->DatabaseLoggingFlag,
                    sizeof(ConfigInfo->DatabaseLoggingFlag)
                    );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
        DhcpGlobalDatabaseLoggingFlag = ConfigInfo->DatabaseLoggingFlag;
    }

    //
    // Set Restore parameter. Requires service restart.
    //

    if( FieldsToSet & Set_RestoreFlag ) {

        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_RESTORE_FLAG_VALUE,
                    0,
                    DHCP_RESTORE_FLAG_VALUE_TYPE,
                    (LPBYTE)&ConfigInfo->RestoreFlag,
                    sizeof(ConfigInfo->RestoreFlag)
                    );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
        DhcpGlobalRestoreFlag = ConfigInfo->RestoreFlag;
    }

    //
    // Set Database Cleanup Interval parameter.
    //

    if( FieldsToSet & Set_DatabaseCleanupInterval ) {

        if( ConfigInfo->DatabaseCleanupInterval == 0 ) {
            Error = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        Tmp = ConfigInfo->DatabaseCleanupInterval * 60000;
        if( (Tmp/ 60000) != ConfigInfo->DatabaseCleanupInterval ) {
            Error = ERROR_ARITHMETIC_OVERFLOW;
            goto Cleanup;
        }
            
        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_DB_CLEANUP_INTERVAL_VALUE,
                    0,
                    DHCP_DB_CLEANUP_INTERVAL_VALUE_TYPE,
                    (LPBYTE)&ConfigInfo->DatabaseCleanupInterval,
                    sizeof(ConfigInfo->DatabaseCleanupInterval)
                    );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        DhcpGlobalCleanupInterval =
            ConfigInfo->DatabaseCleanupInterval * 60000;

        RecomputeTimer = TRUE;
    }

    //
    // Set debug flags.
    //

    if( FieldsToSet & Set_DebugFlag ) {

#if DBG
        DhcpGlobalDebugFlag = ConfigInfo->DebugFlag;

        if( DhcpGlobalDebugFlag & 0x40000000 ) {
            DbgBreakPoint();
        }

        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_DEBUG_FLAG_VALUE,
                    0,
                    DHCP_DEBUG_FLAG_VALUE_TYPE,
                    (LPBYTE)&ConfigInfo->DebugFlag,
                    sizeof(ConfigInfo->DebugFlag)
                    );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
#endif
    }

Cleanup:

    if( OemDatabaseName != NULL ) {
        DhcpFreeMemory( OemDatabaseName );
    }

    if( OemDatabasePath != NULL ) {
        DhcpFreeMemory( OemDatabasePath );
    }

    if( OemBackupPath != NULL ) {
        DhcpFreeMemory( OemBackupPath );
    }

    if( OemJetBackupPath != NULL ) {
        DhcpFreeMemory( OemJetBackupPath );
    }

    if( BackupConfigFileName != NULL ) {
        DhcpFreeMemory( BackupConfigFileName );
    }

    if( RecomputeTimer ) {
        BoolError = SetEvent( DhcpGlobalRecomputeTimerEvent );

        if( !BoolError ) {

            DWORD LocalError;

            LocalError = GetLastError();
            DhcpAssert( LocalError == ERROR_SUCCESS );

            if( Error == ERROR_SUCCESS ) {
                Error = LocalError;
            }
        }
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_APIS,
                "DhcpServerSetConfig failed, %ld.\n",
                    Error ));
    }

    return( Error );
}

DWORD
R_DhcpServerGetConfig(
    LPWSTR ServerIpAddress,
    LPDHCP_SERVER_CONFIG_INFO *ConfigInfo
    )
/*++

Routine Description:

    This function retrieves the current configuration information of the
    server.  This function is provided to emulate the pre-NT4SP2
    RPC interface to allow interoperability with older versions of the
    DHCP Administrator application.


Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ConfigInfo: Pointer to a location where the pointer to the dhcp
        server config info structure is returned. Caller should free up
        this structure after use.

Return Value:

    WINDOWS errors.
--*/

{
    LPDHCP_SERVER_CONFIG_INFO_V4  pConfigInfoV4 = NULL;
    DWORD                         dwResult;

    DhcpAssert( !ConfigInfo );

    dwResult = R_DhcpServerGetConfigV4(
                    ServerIpAddress,
                    &pConfigInfoV4
                    );

    if ( ERROR_SUCCESS == dwResult )
    {

        //
        // free unused fields
        //

        if ( pConfigInfoV4->wszBootTableString )
        {
            MIDL_user_free( pConfigInfoV4->wszBootTableString );
        }

        //
        // since the new fields are at the end of the struct, it
        // is safe to simply return the new struct.
        //

        *ConfigInfo = ( DHCP_SERVER_CONFIG_INFO *) pConfigInfoV4;
    }


    return dwResult;
}


DWORD
R_DhcpServerGetConfigV4(
    LPWSTR ServerIpAddress,
    LPDHCP_SERVER_CONFIG_INFO_V4 *ConfigInfo
    )
/*++

Routine Description:

    This function retrieves the current configuration information of the
    server.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    ConfigInfo: Pointer to a location where the pointer to the dhcp
        server config info structure is returned. Caller should free up
        this structure after use.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error;
    LPDHCP_SERVER_CONFIG_INFO_V4 LocalConfigInfo;
    LPWSTR UnicodeString;
    WCHAR  *pwszBootFileTable;

    DhcpPrint(( DEBUG_APIS, "DhcpServerGetConfig is called.\n" ));
    DhcpAssert( *ConfigInfo == NULL );

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    LocalConfigInfo = MIDL_user_allocate( sizeof(DHCP_SERVER_CONFIG_INFO_V4) );

    if( LocalConfigInfo == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    LocalConfigInfo->APIProtocolSupport = DhcpGlobalRpcProtocols;

    UnicodeString = MIDL_user_allocate(
                        (strlen(DhcpGlobalOemDatabaseName) + 1)
                            * sizeof(WCHAR) );

    if( UnicodeString == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalConfigInfo->DatabaseName =
        DhcpOemToUnicode(
            DhcpGlobalOemDatabaseName,
            UnicodeString );

    UnicodeString = MIDL_user_allocate(
                        (strlen(DhcpGlobalOemDatabasePath) + 1)
                            * sizeof(WCHAR) );

    if( UnicodeString == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalConfigInfo->DatabasePath =
        DhcpOemToUnicode(
            DhcpGlobalOemDatabasePath,
            UnicodeString );

    UnicodeString = MIDL_user_allocate(
                        (strlen(DhcpGlobalOemBackupPath) + 1)
                            * sizeof(WCHAR) );

    if( UnicodeString == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    LocalConfigInfo->BackupPath =
        DhcpOemToUnicode(
            DhcpGlobalOemBackupPath,
            UnicodeString );




    LocalConfigInfo->BackupInterval = DhcpGlobalBackupInterval / 60000;
    LocalConfigInfo->DatabaseLoggingFlag = DhcpGlobalDatabaseLoggingFlag;
    LocalConfigInfo->RestoreFlag = DhcpGlobalRestoreFlag;
    LocalConfigInfo->DatabaseCleanupInterval =
        DhcpGlobalCleanupInterval / 60000;

#if DBG
    LocalConfigInfo->DebugFlag = DhcpGlobalDebugFlag;
#endif

    LocalConfigInfo->fAuditLog = DhcpGlobalAuditLogFlag;
    LocalConfigInfo->dwPingRetries = DhcpGlobalDetectConflictRetries;

    Error = LoadBootFileTable( &LocalConfigInfo->wszBootTableString,
                               &LocalConfigInfo->cbBootTableString);

    if ( ERROR_SUCCESS != Error )
    {
        if ( ERROR_SERVER_INVALID_BOOT_FILE_TABLE == Error )
        {
            LocalConfigInfo->cbBootTableString  = 0;
            LocalConfigInfo->wszBootTableString = NULL;
        }
        else
            goto Cleanup;
    }

    *ConfigInfo = LocalConfigInfo;
    Error = ERROR_SUCCESS;
Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // freeup the locally allocated memories if we aren't
        // successful.
        //

        if( LocalConfigInfo != NULL ) {

            if( LocalConfigInfo->DatabaseName != NULL ) {
                MIDL_user_free( LocalConfigInfo->DatabaseName);
            }

            if( LocalConfigInfo->DatabasePath != NULL ) {
                MIDL_user_free( LocalConfigInfo->DatabasePath);
            }

            if( LocalConfigInfo->BackupPath != NULL ) {
                MIDL_user_free( LocalConfigInfo->BackupPath);
            }

            if ( LocalConfigInfo->wszBootTableString )
            {
                MIDL_user_free( LocalConfigInfo->wszBootTableString );
            }

            MIDL_user_free( LocalConfigInfo );
        }

        DhcpPrint(( DEBUG_APIS,
                "DhcpServerGetConfig failed, %ld.\n",
                    Error ));
    }

    return( Error );
}

DWORD
R_DhcpAuditLogSetParams(                          // set some auditlogging params
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,         // currently must be zero
    IN      LPWSTR                 AuditLogDir,   // directory to log files in..
    IN      DWORD                  DiskCheckInterval, // how often to check disk space?
    IN      DWORD                  MaxLogFilesSize,   // how big can all logs files be..
    IN      DWORD                  MinSpaceOnDisk     // mininum amt of free disk space
)
{
    DWORD                          Error;

    DhcpPrint(( DEBUG_APIS, "AuditLogSetParams is called.\n" ));

    if( 0 != Flags ) return ERROR_INVALID_PARAMETER;
    if( NULL == AuditLogDir ) return ERROR_INVALID_PARAMETER;

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );
    if ( Error != ERROR_SUCCESS ) {
        return Error ;
    }

    return AuditLogSetParams(
        Flags,
        AuditLogDir,
        DiskCheckInterval,
        MaxLogFilesSize,
        MinSpaceOnDisk
    );
}

DWORD
R_DhcpAuditLogGetParams(                          // get the auditlogging params
    IN      LPWSTR                 ServerAddress,
    IN      DWORD                  Flags,         // must be zero
    OUT     LPWSTR                *AuditLogDir,   // same meaning as in AuditLogSetParams
    OUT     DWORD                 *DiskCheckInterval, // ditto
    OUT     DWORD                 *MaxLogFilesSize,   // ditto
    OUT     DWORD                 *MinSpaceOnDisk     // ditto
)
{
    DWORD                          Error;

    DhcpPrint(( DEBUG_APIS, "AuditLogSetParams is called.\n" ));

    if( 0 != Flags ) return ERROR_INVALID_PARAMETER;

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );
    if ( Error != ERROR_SUCCESS ) {
        return Error ;
    }

    return AuditLogGetParams(
        Flags,
        AuditLogDir,
        DiskCheckInterval,
        MaxLogFilesSize,
        MinSpaceOnDisk
    );
}


DWORD
R_DhcpGetVersion(
    LPWSTR ServerIpAddress,
    LPDWORD MajorVersion,
    LPDWORD MinorVersion
    )
/*++

Routine Description:

    This function returns the major and minor version numbers of the
    server.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    MajorVersion : pointer to a location where the major version of the
        server is returned.

    MinorVersion : pointer to a location where the minor version of the
        server is returned.

Return Value:

    WINDOWS errors.

--*/
{

    *MajorVersion = DHCP_SERVER_MAJOR_VERSION_NUMBER;
    *MinorVersion = DHCP_SERVER_MINOR_VERSION_NUMBER;
    return( ERROR_SUCCESS );
}


//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\mmapi.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This file has been generated. Pl look at the .c file
//========================================================================

DWORD
DhcpRegistryInitOld(
    VOID
) ;

DWORD
DhcpReadConfigInfo(
    IN OUT PM_SERVER *Server
    );

DWORD
DhcpOpenConfigTable(
    IN JET_SESID SesId,
    IN JET_DBID DbId
    );

DWORD
DhcpSaveConfigInfo(
    IN OUT PM_SERVER Server,
    IN BOOL fClassChanged,
    IN BOOL fOptionsChanged,
    IN DHCP_IP_ADDRESS Subnet OPTIONAL,
    IN DWORD Mscope OPTIONAL,
    IN DHCP_IP_ADDRESS Reservation OPTIONAL
    );

DWORD
DhcpConfigInit(
    VOID
) ;

VOID
DhcpConfigCleanup(
    VOID
) ;


DWORD
DhcpConfigSave(
    IN BOOL fClassChanged,
    IN BOOL fOptionsChanged,
    IN DHCP_IP_ADDRESS Subnet OPTIONAL,
    IN DWORD Mscope OPTIONAL,
    IN DHCP_IP_ADDRESS Reservation OPTIONAL
    );

PM_SERVER
DhcpGetCurrentServer(
    VOID
) ;


VOID
DhcpSetCurrentServer(
    IN      PM_SERVER              NewCurrentServer
) ;


DWORD
DhcpFindReservationByAddress(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        Address,
    OUT     LPBYTE                *ClientUID,
    OUT     ULONG                 *ClientUIDSize
) ;


DWORD
DhcpLoopThruSubnetRanges(
    IN      PM_SUBNET              Subnet,
    IN      LPVOID                 Context1,
    IN      LPVOID                 Context2,
    IN      LPVOID                 Context3,
    IN      DWORD                  (*FillRangesFunc)(
            IN          PM_RANGE        Range,
            IN          LPVOID          Context1,
            IN          LPVOID          Context2,
            IN          LPVOID          Context3,
            IN          LPDHCP_BINARY_DATA InUseData,
            IN          LPDHCP_BINARY_DATA UsedData
    )
) ;


DWORD
DhcpGetParameter(
    IN      DHCP_IP_ADDRESS        Address,
    IN      PDHCP_REQUEST_CONTEXT  Ctxt,
    IN      DWORD                  Option,
    OUT     LPBYTE                *OptData, // allocated by funciton
    OUT     DWORD                 *OptDataSize,
    OUT     DWORD                 *Level    // OPTIONAL
) ;


DWORD
DhcpGetParameterForAddress(
    IN      DHCP_IP_ADDRESS        Address,
    IN      DWORD                  ClassId,
    IN      DWORD                  Option,
    OUT     LPBYTE                *OptData, // allocated by function
    OUT     DWORD                 *OptDataSize,
    OUT     DWORD                 *Level    // OPTIONAL
) ;


DWORD
DhcpGetAndCopyOption(
    IN      DHCP_IP_ADDRESS        Address,
    IN      PDHCP_REQUEST_CONTEXT  Ctxt,
    IN      DWORD                  Option,
    IN  OUT LPBYTE                 OptData, // fill input buffer --max size is given as OptDataSize parameter
    IN  OUT DWORD                 *OptDataSize,
    OUT     DWORD                 *Level,   // OPTIONAL
    IN      BOOL                   fUtf8
) ;


DHCP_IP_ADDRESS
DhcpGetSubnetMaskForAddress(
    IN      DHCP_IP_ADDRESS        AnyIpAddress
) ;


DWORD
DhcpLookupReservationByHardwareAddress(
    IN      DHCP_IP_ADDRESS        ClientSubnetAddress,
    IN      LPBYTE                 RawHwAddr,
    IN      DWORD                  RawHwAddrSize,
    IN OUT  PDHCP_REQUEST_CONTEXT  ClientCtxt          // fill in the Subnet and Reservation of the client
) ;


VOID
DhcpReservationGetAddressAndType(
    IN      PM_RESERVATION         Reservation,
    OUT     DHCP_IP_ADDRESS       *Address,
    OUT     BYTE                  *Type
) ;


VOID
DhcpSubnetGetSubnetAddressAndMask(
    IN      PM_SUBNET              Subnet,
    OUT     DHCP_IP_ADDRESS       *Address,
    OUT     DHCP_IP_ADDRESS       *Mask
) ;


BOOL
DhcpSubnetIsDisabled(
    IN      PM_SUBNET              Subnet,
    IN      BOOL                   fBootp
) ;


BOOL
DhcpSubnetIsSwitched(
    IN      PM_SUBNET              Subnet
) ;


DWORD
DhcpGetSubnetForAddress(                               // fill in with the right subnet for given address
    IN      DHCP_IP_ADDRESS        Address,
    IN OUT  PDHCP_REQUEST_CONTEXT  ClientCtxt
) ;


DWORD
DhcpGetMScopeForAddress(                               // fill in with the right subnet for given address
    IN      DHCP_IP_ADDRESS        Address,
    IN OUT  PDHCP_REQUEST_CONTEXT  ClientCtxt
) ;


DWORD
DhcpLookupDatabaseByHardwareAddress(                   // see if the client has any previous address in the database
    IN OUT  PDHCP_REQUEST_CONTEXT  ClientCtxt,         // set this with details if found
    IN      LPBYTE                 RawHwAddr,
    IN      DWORD                  RawHwAddrSize,
    OUT     DHCP_IP_ADDRESS       *desiredIpAddress    // if found, fill this with the ip address found
) ;


DWORD
DhcpRequestSomeAddress(                                // get some address in this context
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    OUT     DHCP_IP_ADDRESS       *desiredIpAddress,
    IN      BOOL                   fBootp
) ;


BOOL
DhcpSubnetInSameSuperScope(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        IpAddress2
) ;


BOOL
DhcpInSameSuperScope(
    IN      DHCP_IP_ADDRESS        Address1,
    IN      DHCP_IP_ADDRESS        Address2
) ;


BOOL
DhcpAddressIsOutOfRange(
    IN      DHCP_IP_ADDRESS        Address,
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    IN      BOOL                   fBootp
) ;


BOOL
DhcpAddressIsExcluded(
    IN      DHCP_IP_ADDRESS        Address,
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt
) ;


BOOL
DhcpRequestSpecificAddress(
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    IN      DHCP_IP_ADDRESS        Address
) ;


DWORD
DhcpReleaseBootpAddress(
    IN      DHCP_IP_ADDRESS        Address
) ;


DWORD
DhcpReleaseAddress(
    IN      DHCP_IP_ADDRESS        Address
) ;


DWORD
DhcpServerGetSubnetCount(
    IN      PM_SERVER              Server
) ;


DWORD
DhcpServerGetMScopeCount(
    IN      PM_SERVER              Server
) ;


DWORD
DhcpServerGetClassId(
    IN      PM_SERVER              Server,
    IN      LPBYTE                 ClassIdBytes,
    IN      DWORD                  nClassIdBytes
) ;


DWORD
DhcpServerGetVendorId(
    IN      PM_SERVER              Server,
    IN      LPBYTE                 VendorIdBytes,
    IN      DWORD                  nVendorIdBytes
) ;


BOOL
DhcpServerIsAddressReserved(
    IN      PM_SERVER              Server,
    IN      DHCP_IP_ADDRESS        Address
) ;


BOOL
DhcpServerIsAddressOutOfRange(
    IN      PM_SERVER              Server,
    IN      DHCP_IP_ADDRESS        Address,
    IN      BOOL                   fBootp
) ;


BOOL
DhcpSubnetIsAddressExcluded(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        Address
) ;


BOOL
DhcpSubnetIsAddressOutOfRange(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        Address,
    IN      BOOL                   fBootp
) ;


BOOL
DhcpSubnetIsAddressReserved(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        Address
) ;


DWORD
DhcpUpdateReservationInfo(
    IN      DHCP_IP_ADDRESS        IpAddress,
    IN      LPBYTE                 SetClientUID,
    IN      DWORD                  SetClientUIDLength
) ;


DWORD
DhcpRegFlushServerIfNeeded(
    VOID
) ;


DWORD
DhcpFlushBitmaps(                                 // do a flush of all bitmaps that have changed
    VOID
) ;


DWORD
DhcpServerFindMScope(
    IN      PM_SERVER              Server,
    IN      DWORD                  ScopeId,
    IN      LPWSTR                 Name,          // Multicast scope name or NULL if this is not the key to search on
    OUT     PM_MSCOPE             *MScope
) ;


BOOL
DhcpServerValidateNewMScopeId(
    IN      PM_SERVER               Server,
    IN      DWORD                   MScopeId
) ;


BOOL
DhcpServerValidateNewMScopeName(
    IN      PM_SERVER               Server,
    IN      LPWSTR                  Name
) ;


DWORD
DhcpMScopeReleaseAddress(
    IN      DWORD                  MScopeId,
    IN      DHCP_IP_ADDRESS        Address
) ;


DWORD
DhcpSubnetRequestSpecificAddress(
	PM_SUBNET            Subnet,
	DHCP_IP_ADDRESS      IpAddress
) ;


DWORD
DhcpSubnetReleaseAddress(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        Address
) ;


DWORD
MadcapGetMScopeListOption(
    IN      DHCP_IP_ADDRESS         ServerIpAddress,
    OUT     LPBYTE                 *OptVal,
    IN OUT  WORD                   *OptSize
) ;


BOOL
DhcpRequestSpecificMAddress(
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    IN      DHCP_IP_ADDRESS        Address
) ;


BOOL
DhcpMScopeIsAddressReserved(
    IN      DWORD                   MScopeId,
    IN      DHCP_IP_ADDRESS         Address
) ;

BOOL
DhcpIsSubnetStateDisabled(
    IN ULONG SubnetState
) ;


BOOL
DhcpServerIsNotServicingSubnet(
    IN      DWORD                   IpAddressInSubnet
) ;


// This function tries to create a list of all classes (wire-class-id, class name, descr)
// and send this as an option. but since the list can be > 255 it has to be make a continuation...
// and also, we dont want the list truncated somewhere in the middle.. so we try to append
// information for each class separately to see if it succeeds..
LPBYTE
DhcpAppendClassList(
    IN OUT  LPBYTE                  BufStart,
    IN OUT  LPBYTE                  BufEnd
) ;


DWORD
DhcpMemInit(
    VOID
) ;


VOID
DhcpMemCleanup(
    VOID
) ;

//========================================================================
//  end of file
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\mmapi.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:

    mmapi.c

Abstract:

    Server interface to the MM module

Environment:

    User mode, Win32

--*/

#include    <dhcppch.h>
#include    <rpcapi.h>
#include    <dsreg.h>

//
// file static variable.
//

//
// Exported routines begin here.
//

//BeginExport(function)
DWORD
DhcpRegistryInitOld(
    VOID
) //EndExport(function)
/*++

    Initializes registry so far as MM is concerned -- just read the objects
    and fill in the internal structures.

--*/
{
    DhcpAssert( NULL == DhcpGlobalThisServer );
    return DhcpRegReadThisServer(&DhcpGlobalThisServer);
}

//BeginExport(function)
DWORD
DhcpConfigInit(
    VOID
) //EndExport(function)
{
    DWORD Error;

    Error = DhcpReadConfigInfo(&DhcpGlobalThisServer);
    if( NO_ERROR != Error ) return Error;

    return DhcpRegReadServerBitmasks(DhcpGlobalThisServer);
}

//BeginExport(function)
VOID
DhcpConfigCleanup(
    VOID
) //EndExport(function)
/*++

    This undoes the effect of DhcpConfigInit, closing all handles and
    freeing all resources.

--*/
{
    if(DhcpGlobalThisServer) {

        DhcpRegFlushServer(FLUSH_ANYWAY);
        MemServerFree(DhcpGlobalThisServer);
        DhcpGlobalThisServer = NULL;
    }
}

//BeginExport(function)
DWORD
DhcpConfigSave(
    IN BOOL fClassChanged,
    IN BOOL fOptionsChanged,
    IN DHCP_IP_ADDRESS Subnet OPTIONAL,
    IN DWORD Mscope OPTIONAL,
    IN DHCP_IP_ADDRESS Reservation OPTIONAL
) //EndExport(function)
{
    return DhcpSaveConfigInfo(
        DhcpGlobalThisServer, fClassChanged, fOptionsChanged,
        Subnet, Mscope, Reservation );
}

//BeginExport(function)
PM_SERVER
DhcpGetCurrentServer(
    VOID
) //EndExport(function)
{
    return DhcpGlobalThisServer;
}

//BeginExport(function)
VOID
DhcpSetCurrentServer(
    IN PM_SERVER NewCurrentServer
) //EndExport(function)
{
    DhcpAssert(NewCurrentServer);
    DhcpGlobalThisServer = NewCurrentServer;
}

//BeginExport(function)
DWORD
DhcpFindReservationByAddress(
    IN PM_SUBNET Subnet,
    IN DHCP_IP_ADDRESS Address,
    OUT LPBYTE *ClientUID,
    OUT ULONG *ClientUIDSize
)   //EndExport(function)
/*++

Routine Description:

    This function searches a subnet for a reservation with a given IP
    address, and if found returns the ClientUID and size.  The ClientUID is
    an internally allocated pointer that is valid only so long as the
    "ReadLock" (see lock.c) is taken....  It could get modified after
    that..

Arguments:

    Subnet -- valid subnet object pointer
    Address -- non-zero IP address of the reservation to check for
    ClientUID -- return pointer to memory that is valid only so long as
        readlock is held. (Do not free this memory).
    ClientUIDSize -- size of above pointer in bytes.

Return Value:

    Win32 errors

--*/
{
    ULONG Error;
    PM_RESERVATION Reservation;

    Error = MemReserveFindByAddress(
        &Subnet->Reservations, Address, &Reservation
        );
    if( ERROR_SUCCESS != Error ) return Error;

    *ClientUID = Reservation->ClientUID;
    *ClientUIDSize = Reservation->nBytes;

    return ERROR_SUCCESS;
}


//BeginExport(function)
DWORD
DhcpLoopThruSubnetRanges(
    IN PM_SUBNET Subnet,
    IN LPVOID Context1 OPTIONAL,
    IN LPVOID Context2 OPTIONAL,
    IN LPVOID Context3 OPTIONAL,
    IN DWORD (*FillRangesFunc)(
        IN PM_RANGE Range,
        IN LPVOID Context1,
        IN LPVOID Context2,
        IN LPVOID Context3,
        IN LPDHCP_BINARY_DATA InUseData,
        IN LPDHCP_BINARY_DATA UsedData
    )
)   //EndExport(function)
/*++

Routine Description:
    This routine can be used to loop though the ranges of a subnet to
    process each range.   Three contexts can be supplied which will be
    passed directly to the FillRangesFunc routine as parameter.

Arguments:
    Subnet -- this is the subnet to loop through.
    Context1 -- caller specified context, passed to FillRangesFunc.
    Context2 -- caller specified context, passed to FillRangesFunc.
    Context3 -- caller specified context, passed to FillRangesFunc.
    FillRangesFunc -- caller specified routine that is called on each
        range found for the subnet.   This routine is called with the
        InUseData and UsedData clusters as appropriate for this range.
        (These last two parameters should not be modified in anyway)

Return Value:
   If any invocation of FillRangesFunc returns an error, then that error is
   immediately returned.  If there is any error in retreiving the InUseData
   and the UsedData binary structures for any range, then an error is
   returned.

   Win32 errors.

--*/
{
    ULONG Error;
    ARRAY_LOCATION Loc;
    PM_RANGE ThisRange = NULL;
    DHCP_BINARY_DATA InUseData, UsedData;

    for( Error = MemArrayInitLoc(&Subnet->Ranges, &Loc) ;
         ERROR_SUCCESS == Error ;
         Error = MemArrayNextLoc(&Subnet->Ranges, &Loc)
    ) {
        Error = MemArrayGetElement(&Subnet->Ranges, &Loc, &ThisRange);

        Error = MemRangeConvertToClusters(
            ThisRange, &InUseData.Data, &InUseData.DataLength,
            &UsedData.Data, &UsedData.DataLength
            );
        if( ERROR_SUCCESS != Error ) return Error;

        Error = FillRangesFunc(
            ThisRange, Context1, Context2, Context3, &InUseData, &UsedData
            );
        if( UsedData.Data ) MemFree(UsedData.Data);
        if( InUseData.Data ) MemFree(InUseData.Data);

        if( ERROR_SUCCESS != Error ) return Error;
    }

    return ERROR_SUCCESS;
}

DWORD
DhcpOptClassGetMemOptionExact(
    IN LPDHCP_REQUEST_CONTEXT Ctxt,
    IN PM_OPTCLASS Options,
    IN DWORD Option,
    IN DWORD ClassId,
    IN DWORD VendorId,
    OUT PM_OPTION *Opt
)
/*++

Routine Description:
    This routine tries to find an option matching the option ID specified
    in "Option" parameter and belonging to the class specified by ClassId
    and VendorId.  (Note that ClassId and VendorId are used for exact
    matches).

    If an option is found, then the option structure is returned in the
    "Opt" parameter -- this can be used only so long as the global readlock
    on all memory structures are in place. (see lock.c).  It is an internal
    pointer and should not be modified.

    N.B.  If VendorId actually belongs to a microsoft vendor class ID, then
    the MSFT class is also applied..

Arguments:
    Ctxt -- client request context
    Options -- the option-class list to search for the particular option
    Option -- the option ID of the option to search for
    ClassId -- the exact class id of the option needed
    VendorId -- the exact vendor id of the option needed
    Opt -- a variable that will be filled with pointer to the in memory
        option structure.

Return Value:
    Win32 errors.
--*/
{
    DWORD Error;
    PM_OPTLIST OptList;

    //
    // get list of options for classid, vendorid pair.
    //

    do {
        OptList = NULL;
        Error = MemOptClassFindClassOptions(
            Options,
            ClassId,
            VendorId,
            &OptList
            );
        if( ERROR_SUCCESS != Error ) {
            if( VendorId != DhcpGlobalMsftClass
                && Ctxt->fMSFTClient ) {
                //
                // If it belongs to a microsoft client,
                // try the MSFT class also.
                //
                VendorId = DhcpGlobalMsftClass;
                continue;
            }
        }

        if( ERROR_SUCCESS != Error ) break;

        //
        // search for reqd option id
        //

        DhcpAssert(NULL != OptList);
        Error = MemOptListFindOption(
            OptList,
            Option,
            Opt
            );
        if( ERROR_SUCCESS != Error ) {
            if( VendorId != DhcpGlobalMsftClass
                && Ctxt->fMSFTClient ) {
                //
                // If it belongs to a microsoft client,
                // try the MSFT class also.
                //
                VendorId = DhcpGlobalMsftClass;
                continue;
            }
        }

        break;
    } while ( 1 );
    return Error;
}

DWORD
DhcpOptClassGetMemOption(
    IN LPDHCP_REQUEST_CONTEXT Ctxt,
    IN PM_OPTCLASS Options,
    IN DWORD Option,
    IN DWORD ClassId OPTIONAL,
    IN DWORD VendorId OPTIONAL,
    OUT PM_OPTION *Opt
)
/*++

Routine Description:
    This routine is almost exactly the same as
    DhcpOptClassGetMemOptionExact except that the ClassId and VendorId are
    optional, and the following search logic is used to identify the
    options.

    1. An exact search is made for <Option, ClassId, VendorId>.

    Note that the returned option is valid only so long as the global
    memory read lock is taken... (see lock.c)

Arguments:
    Ctxt -- client request context
    Options -- list of opt-class to search for desired option
    Option -- option id to search for
    ClassId -- reqd class id
    VendorId -- reqd vendor id
    Opt -- variable to store the found option.

Return Value:
    Win32 errors

--*/
{
    DWORD Error;

    //
    // exact match.
    //

    Error = DhcpOptClassGetMemOptionExact(
        Ctxt,
        Options,
        Option,
        ClassId,
        VendorId,
        Opt
    );

    return Error;
} // DhcpOptClassGetMemOption()

DWORD
DhcpOptClassGetOptionSimple(
    IN PDHCP_REQUEST_CONTEXT Ctxt,
    IN PM_OPTCLASS Options,
    IN DWORD Option,
    IN DWORD ClassId,
    IN DWORD VendorId,
    OUT LPBYTE OptData OPTIONAL,
    IN OUT DWORD *OptDataSize,
    IN BOOL fUtf8
)
/*++

Routine Description:
    This routine copies the option data value for the option id specified
    by the "Option" parameter onto the buffer "OptData" and fills the size
    of the buffer filled onto the parameter "OptDataSize".   If the buffer
    is of insufficient size (input size is also specified by the
    "OptDataSize" parameter), then the required size is filled in, and
    ERROR_MORE_DATA is returned.

    No special processing is done for option OPTION_VENDOR_SPEC_INFO --
    i.e. if there are multiple vendor specific option ID's defined, the
    information is not collated. Use DhcpOptClassGetOption for that.

    The buffer "OptData" is filled in with the option as it would need to
    be sent on the wire.

Arguments:
    Ctxt -- client request context
    Options -- the option-class list to search in for reqd option
    Option -- option id to search for
    ClassId -- the user class to seach for
    VendorId -- the vendor class to seach for
    OptData -- the input buffer to fill in with option data information
        This can be NULL if OptDataSize is set to zero on input.
    OptDataSize -- on input this should be the size of the above buffer,
        and on output it would be set to the actual size required or used
        for this option.

Return Value:
    ERROR_MORE_DATA if the input buffer size is insufficient.
    Other Win32 errors

--*/
{
    DWORD Error;
    PM_OPTION Opt;

    //
    // get the option first.
    //

    Opt = NULL;
    Error = DhcpOptClassGetMemOption(
        Ctxt,
        Options,
        Option,
        ClassId,
        VendorId,
        &Opt
    );
    if( ERROR_SUCCESS != Error ) return ERROR_FILE_NOT_FOUND;

    DhcpAssert(NULL != Opt);

    //
    // Convert formats.
    //

    return DhcpParseRegistryOption(
        Opt->Val,
        Opt->Len,
        OptData,
        OptDataSize,
        fUtf8
    );

}

DWORD
DhcpOptClassGetOption(
    IN PDHCP_REQUEST_CONTEXT Ctxt,
    IN PM_OPTCLASS Options,
    IN DWORD Option,
    IN DWORD ClassId,
    IN DWORD VendorId,
    OUT LPBYTE OptData OPTIONAL,
    IN OUT DWORD *OptDataSize,
    IN BOOL fUtf8
)
/*++

Routine Description:
    This routine copies the option data value for the option id specified
    by the "Option" parameter onto the buffer "OptData" and fills the size
    of the buffer filled onto the parameter "OptDataSize".   If the buffer
    is of insufficient size (input size is also specified by the
    "OptDataSize" parameter), then the required size is filled in, and
    ERROR_MORE_DATA is returned.

    If the "Option" parameter is OPTION_VENDOR_SPEC_INFO, then, this
    routine collates the information for ALL vendor id's  (vendor id 1 to
    vendor id 254) that are present for the particular class id and vendor
    id, and pulls them together (constructing the resulting option as
    required by the DHCP draft) and returns that in the OptData buffer.
    Note that if the size of the resultant buffer would end up bigger than
    255 (which is the erstwhile maximum size allowed on wire), only so many
    vendor optiosn are included as is possible to keep the count within
    this size.  Also, if there is already an OPTION_VENDOR_SPEC_INFO option
    defined, then that is used instead of the specific options.

    The buffer "OptData" is filled in with the option as it would need to
    be sent on the wire.

Arguments:
    Ctxt -- client request context
    Options -- the option-class list to search in for reqd option
    Option -- option id to search for
    ClassId -- the user class to seach for
    VendorId -- the vendor class to seach for
    OptData -- the input buffer to fill in with option data information
        This can be NULL if OptDataSize is set to zero on input.
    OptDataSize -- on input this should be the size of the above buffer,
        and on output it would be set to the actual size required or used
        for this option.

Return Value:
    ERROR_MORE_DATA if the input buffer size is insufficient.
    Other Win32 errors

--*/
{
    DWORD Error, Index, InBufferSize;
    DWORD ThisSize, InBufferSizeTmp, OutBufferSize;

    //
    // Jus' try to get 'un option.
    //

    Error = DhcpOptClassGetOptionSimple(
        Ctxt,
        Options,
        Option,
        ClassId,
        VendorId,
        OptData,
        OptDataSize,
        fUtf8
    );
    if( OPTION_VENDOR_SPEC_INFO != Option
        || ERROR_FILE_NOT_FOUND != Error ) {
        //
        // Vendor spec option not requested, or succeeded or unknown error
        //
        return Error;
    }

    //
    // process each vendor spec option and collate 'em
    //

    InBufferSize = InBufferSizeTmp = *OptDataSize;
    OutBufferSize = 0;
    for( Index = 1; Index < OPTION_END ; Index ++ ) {
        if(InBufferSizeTmp > 0) {
            *OptData = (BYTE)Index;
        }
        ThisSize = (InBufferSizeTmp>1)?(InBufferSizeTmp-2):0;
        Error = DhcpOptClassGetOptionSimple(
            Ctxt,
            Options,
            ConvertOptIdToMemValue(Index, TRUE),
            ClassId,
            VendorId,
            OptData+2,
            &ThisSize,
            fUtf8
        );
        if( ERROR_SUCCESS != Error && ERROR_MORE_DATA != Error ) {
            continue;
        }

        //
        // found a vendor spec option, check buffer size.. if too big
        // but we have found some before, then quit loop..
        //

        if( InBufferSizeTmp + ThisSize + 2 > OPTION_END ) {
            if( OutBufferSize ) break;
            continue;
        }

        if( InBufferSizeTmp < ThisSize + 2) {
            InBufferSizeTmp = 0;
        } else {
            InBufferSizeTmp -= ThisSize + 2;
            OptData[1] =(BYTE)ThisSize;
            OptData += ThisSize + 2;
        }
        OutBufferSize += ThisSize + 2;
    }

    if( OutBufferSize == 0 ) return ERROR_FILE_NOT_FOUND;
    *OptDataSize = OutBufferSize;
    if( OutBufferSize > InBufferSize ) return ERROR_MORE_DATA;
    return ERROR_SUCCESS;
} // DhcpOptClassGetOption()


//
//
// abstract: options priority (1) Reservation, (2) Scope Level and (3) Global
// get the options for the client based on its context.( resv, userid or vendorid )
// this function grovels through the internal ( residing in memory ) options 
// based on the client context. The options at the reservation level has the highest priority, at the scope level
// the next highest priority and the global level the lowest priority.
//
//

DWORD
DhcpGetOptionByContext(
   IN      DHCP_IP_ADDRESS        Address,
   IN      PDHCP_REQUEST_CONTEXT  Ctxt,
   IN      DWORD                  Option,
   IN OUT  LPBYTE                 OptData,
   IN OUT  DWORD                 *OptDataSize,
   OUT     DWORD                 *Level,
   IN      BOOL                   fUtf8 
)
{

  DWORD Error = ERROR_FILE_NOT_FOUND;
  PM_OPTLIST OptList = NULL;

if( !DhcpGlobalThisServer ) return ERROR_FILE_NOT_FOUND;
    if( !Ctxt ) return ERROR_FILE_NOT_FOUND;

    if( Level ) *Level = DHCP_OPTION_LEVEL_RESERVATION;
    if( Ctxt->Reservation )
        Error = DhcpOptClassGetOption(
            Ctxt,
            &(Ctxt->Reservation->Options),
            Option,
            Ctxt->ClassId,
            Ctxt->VendorId,
            OptData,
            OptDataSize,
            fUtf8
        );

    if( ERROR_SUCCESS == Error) return ERROR_SUCCESS;
    if( ERROR_MORE_DATA == Error) return Error;

    if( Level ) *Level = DHCP_OPTION_LEVEL_SCOPE;

    if( Ctxt->Subnet )
        Error = DhcpOptClassGetOption(
            Ctxt,
            &(Ctxt->Subnet->Options),
            Option,
            Ctxt->ClassId,
            Ctxt->VendorId,
            OptData,
            OptDataSize,
            fUtf8
        );

    if( ERROR_SUCCESS == Error) return ERROR_SUCCESS;
    if( ERROR_MORE_DATA == Error) return Error;
    if( Level ) *Level = DHCP_OPTION_LEVEL_GLOBAL;

    if( Ctxt->Server )
        Error = DhcpOptClassGetOption(
            Ctxt,
            &(Ctxt->Server->Options),
            Option,
            Ctxt->ClassId,
            Ctxt->VendorId,
            OptData,
            OptDataSize,
            fUtf8
        );

    return Error;
  
} // DhcpGetOptionByContext()

//
//
// checks the options based on userid/classid. This function follows the following algorithm.
// (a) Check for options with the passed classid/vendorid if both are non NULL. If success return.
// (b) If vendorid is non NULL and userid is NULL, get value for this option. If success return.
// (c) If userid is non NULL and vendor id is NULL, get value for this option. If success return.
// (d) If all else fails, go for the default options with zero value for vendorid and userid.
//
// To figure out the size of the option this function may be called
// with OptData set to NULL. In that case the error code is ERROR_MORE_DATA
// and the function will return.
//
//

DWORD
DhcpGetOption(
    IN      DHCP_IP_ADDRESS        Address,
    IN      PDHCP_REQUEST_CONTEXT  Ctxt,
    IN      DWORD                  Option,
    IN  OUT LPBYTE                 OptData, // copied into buffer
    IN  OUT DWORD                 *OptDataSize, // input buffer size and filled with output buffer size
    OUT     DWORD                 *Level,   // OPTIONAL
    IN      BOOL                   fUtf8
)
{
    DWORD                          Error = ERROR_FILE_NOT_FOUND;
    DWORD                          lClsId;
    DWORD                          lVendId;


    if( !DhcpGlobalThisServer ) return ERROR_FILE_NOT_FOUND;
    if( !Ctxt ) return ERROR_FILE_NOT_FOUND;

    //
    // local variables that will hold the classid/vendorid 
    //

    lClsId  = Ctxt -> ClassId;
    lVendId = Ctxt -> VendorId; 

    //
    // both classid and vendorid are present.
    //

    if (( Ctxt -> ClassId ) && 
	( Ctxt -> VendorId )) {
        Error = DhcpGetOptionByContext( Address, Ctxt, Option, OptData, OptDataSize, Level, fUtf8 );
    }

    if (( Error == ERROR_SUCCESS ) ||
	( Error == ERROR_MORE_DATA )) {
	return( Error );
    }

    //
    // only vendor id is present or the above call failed.
    //

    if ( Ctxt -> VendorId ) {
        Ctxt -> ClassId = 0;
        Error = DhcpGetOptionByContext( Address, Ctxt, Option, OptData, OptDataSize, Level, fUtf8 );
    }

    Ctxt -> ClassId = lClsId;

    if (( Error == ERROR_SUCCESS ) ||
	( Error == ERROR_MORE_DATA )) {
        return( Error );
    }

    //
    // only classid is present or the above call failed
    //

    if ( Ctxt -> ClassId ) {
        Ctxt -> VendorId = 0;
        Error = DhcpGetOptionByContext( Address, Ctxt, Option, OptData, OptDataSize, Level, fUtf8 );
    }

    Ctxt -> VendorId = lVendId;
    if (( Error == ERROR_SUCCESS ) ||
	( Error == ERROR_MORE_DATA )) {
        return ( Error );
    }
    
    //
    // niether classid nor vendorid is present or all the calls above failed, get default options.
    //
    
    Ctxt -> VendorId = Ctxt -> ClassId = 0;
    Error = DhcpGetOptionByContext( Address, Ctxt, Option, OptData, OptDataSize, Level, fUtf8 );
    Ctxt -> VendorId = lVendId; 
    Ctxt -> ClassId  = lClsId;
    return Error;
} // DhcpGetOption()

//BeginExport(function)
DWORD
DhcpGetParameter(
    IN      DHCP_IP_ADDRESS        Address,
    IN      PDHCP_REQUEST_CONTEXT  Ctxt,
    IN      DWORD                  Option,
    OUT     LPBYTE                *OptData, // allocated by funciton
    OUT     DWORD                 *OptDataSize,
    OUT     DWORD                 *Level    // OPTIONAL
) //EndExport(function)
{
    LPBYTE                         Ptr;
    LPBYTE                         RetVal;
    DWORD                          Size;
    DWORD                          Error;

    *OptData = NULL;
    *OptDataSize = 0;

    Size = 0;
    Error = DhcpGetOption(Address, Ctxt, Option, NULL, &Size,
                          Level,FALSE);
    if( ERROR_MORE_DATA != Error ) return Error;

    if( 0 == Size ) return ERROR_SUCCESS;

    RetVal = DhcpAllocateMemory(Size);
    if( NULL == RetVal ) return ERROR_NOT_ENOUGH_MEMORY;

    Error = DhcpGetOption(Address, Ctxt, Option, RetVal, &Size,
                          Level, FALSE);
    if( ERROR_SUCCESS != Error ) {
        DhcpAssert(ERROR_MORE_DATA != Error);
        DhcpFreeMemory(RetVal);
    } else {
        *OptData = RetVal;
        *OptDataSize = Size;
    }

    return Error;
}

//BeginExport(function)
DWORD
DhcpGetParameterForAddress(
    IN      DHCP_IP_ADDRESS        Address,
    IN      DWORD                  ClassId,
    IN      DWORD                  Option,
    OUT     LPBYTE                *OptData, // allocated by function
    OUT     DWORD                 *OptDataSize,
    OUT     DWORD                 *Level    // OPTIONAL
) //EndExport(function)
{
    DWORD                          Error;
    DHCP_REQUEST_CONTEXT           Ctxt;

    // this routine does not work for multicast address.
    DhcpAssert( !CLASSD_HOST_ADDR(Address) );

    Ctxt.Server = DhcpGetCurrentServer();
    Ctxt.Subnet = NULL;
    Ctxt.Range = NULL;
    Ctxt.Reservation = NULL;
    Ctxt.ClassId = ClassId;
    Ctxt.VendorId = 0;
    Ctxt.fMSFTClient = FALSE;

    Error = DhcpGetSubnetForAddress(Address, &Ctxt);
    if( ERROR_SUCCESS != Error ) return Error;

    return DhcpGetParameter(Address, &Ctxt, Option, OptData, OptDataSize, Level);
}

//BeginExport(function)
DWORD
DhcpGetAndCopyOption(
    IN      DHCP_IP_ADDRESS        Address,
    IN      PDHCP_REQUEST_CONTEXT  Ctxt,
    IN      DWORD                  Option,
    IN  OUT LPBYTE                 OptData, // fill input buffer --max size is given as OptDataSize parameter
    IN  OUT DWORD                 *OptDataSize,
    OUT     DWORD                 *Level,   // OPTIONAL
    IN      BOOL                   fUtf8
    ) //EndExport(function)
{
    return DhcpGetOption(
        Address, Ctxt, Option, OptData, OptDataSize, Level, fUtf8);
}

//BeginExport(function)
DHCP_IP_ADDRESS
DhcpGetSubnetMaskForAddress(
    IN      DHCP_IP_ADDRESS        AnyIpAddress
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    if( !DhcpGlobalThisServer ) return 0;
    Error = MemServerGetAddressInfo(
        DhcpGlobalThisServer,
        AnyIpAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return 0;
    DhcpAssert(Subnet);
    return Subnet->Mask;
}

//BeginExport(function)
DWORD
DhcpLookupReservationByHardwareAddress(
    IN      DHCP_IP_ADDRESS        ClientSubnetAddress,
    IN      LPBYTE                 RawHwAddr,
    IN      DWORD                  RawHwAddrSize,
    IN OUT  PDHCP_REQUEST_CONTEXT  ClientCtxt          // fill in the Subnet and Reservation of the client
) //EndExport(function)
{
    PM_SUBNET                      Subnet = NULL;
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    DWORD                          SScopeId;
    DWORD                          UIDSize;
    LPBYTE                         UID;

    Error = MemServerGetAddressInfo(
        ClientCtxt->Server,
        ClientSubnetAddress,
        &(ClientCtxt->Subnet),
        &(ClientCtxt->Range),
        &(ClientCtxt->Excl),
        &(ClientCtxt->Reservation)
    );
    if( ERROR_SUCCESS != Error ) return Error;
    if( NULL == ClientCtxt->Subnet ) return ERROR_FILE_NOT_FOUND;
    SScopeId = ClientCtxt->Subnet->SuperScopeId;

    Error = MemArrayInitLoc(&(ClientCtxt->Server->Subnets), &Loc);
    DhcpAssert(ERROR_SUCCESS == Error );

    while( ERROR_FILE_NOT_FOUND != Error ) {
        DhcpAssert(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(&(ClientCtxt->Server->Subnets), &Loc, (LPVOID *)&Subnet);
        DhcpAssert(ERROR_SUCCESS == Error);

        if( 0 == SScopeId && ClientCtxt->Subnet != Subnet ) {
            Error = MemArrayNextLoc(&(ClientCtxt->Server->Subnets), &Loc);
            continue;
        }
        if( Subnet->SuperScopeId == SScopeId ) {
            UID = NULL;
            Error = DhcpMakeClientUID(
                RawHwAddr,
                RawHwAddrSize,
                0 /* hardware type is hardcoded anyways.. */,
                Subnet->Address,
                &UID,
                &UIDSize
            );
            if( ERROR_SUCCESS != Error ) return Error;

            Error = MemReserveFindByClientUID(
                &(Subnet->Reservations),
                UID,
                UIDSize,
                &(ClientCtxt->Reservation)
            );
            DhcpFreeMemory(UID);
            if( ERROR_SUCCESS == Error && NULL != &(ClientCtxt->Reservation) ) {
                ClientCtxt->Subnet = Subnet;
                return ERROR_SUCCESS;
            }
        }

        Error = MemArrayNextLoc(&(ClientCtxt->Server->Subnets), &Loc);
    }

    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
VOID
DhcpReservationGetAddressAndType(
    IN      PM_RESERVATION         Reservation,
    OUT     DHCP_IP_ADDRESS       *Address,
    OUT     BYTE                  *Type
) //EndExport(function)
{
    if( NULL == Reservation ) {
        DhcpAssert(FALSE);
        *Address = 0; *Type = 0;
        return;
    }
    *Address = Reservation->Address;
    *Type = (BYTE)Reservation->Flags;
}


//BeginExport(function)
VOID
DhcpSubnetGetSubnetAddressAndMask(
    IN      PM_SUBNET              Subnet,
    OUT     DHCP_IP_ADDRESS       *Address,
    OUT     DHCP_IP_ADDRESS       *Mask
) //EndExport(function)
{
    if( NULL == Subnet ) {
        DhcpAssert(FALSE);
        *Address = *Mask = 0;
        return;
    }

    *Address = Subnet->Address;
    *Mask = Subnet->Mask;
}

//BeginExport(function)
BOOL
DhcpSubnetIsDisabled(
    IN      PM_SUBNET              Subnet,
    IN      BOOL                   fBootp
) //EndExport(function)
{

    if( Subnet?(IS_DISABLED(Subnet->State)):TRUE )
        return TRUE;

    if( FALSE == Subnet->fSubnet ) {
        //
        // no more checks for MADCAP Scopes
        //
        return FALSE;
    }

    return !MemSubnetCheckBootpDhcp(Subnet, fBootp, TRUE);
}

//BeginExport(function)
BOOL
DhcpSubnetIsSwitched(
    IN      PM_SUBNET              Subnet
) //EndExport(function)
{
    return Subnet?(IS_SWITCHED(Subnet->State)):FALSE;
}

//BeginExport(function)
DWORD
DhcpGetSubnetForAddress(                               // fill in with the right subnet for given address
    IN      DHCP_IP_ADDRESS        Address,
    IN OUT  PDHCP_REQUEST_CONTEXT  ClientCtxt
) //EndExport(function)
{
    if( NULL == ClientCtxt->Server ) return ERROR_FILE_NOT_FOUND;
    return MemServerGetAddressInfo(
        ClientCtxt->Server,
        Address,
        &(ClientCtxt->Subnet),
        &(ClientCtxt->Range),
        &(ClientCtxt->Excl),
        &(ClientCtxt->Reservation)
    );
}

//BeginExport(function)
DWORD
DhcpGetMScopeForAddress(                               // fill in with the right subnet for given address
    IN      DHCP_IP_ADDRESS        Address,
    IN OUT  PDHCP_REQUEST_CONTEXT  ClientCtxt
) //EndExport(function)
{
    if( NULL == ClientCtxt->Server ) return ERROR_FILE_NOT_FOUND;
    return MemServerGetMAddressInfo(
        ClientCtxt->Server,
        Address,
        &(ClientCtxt->Subnet),
        &(ClientCtxt->Range),
        &(ClientCtxt->Excl),
        NULL
    );
}

//BeginExport(function)
DWORD
DhcpLookupDatabaseByHardwareAddress(                   // see if the client has any previous address in the database
    IN OUT  PDHCP_REQUEST_CONTEXT  ClientCtxt,         // set this with details if found
    IN      LPBYTE                 RawHwAddr,
    IN      DWORD                  RawHwAddrSize,
    OUT     DHCP_IP_ADDRESS       *desiredIpAddress    // if found, fill this with the ip address found
) //EndExport(function)
{
    PM_SUBNET                      Subnet = NULL;
    ARRAY_LOCATION                 Loc;
    DWORD                          Error;
    DWORD                          SScopeId;
    DWORD                          UIDSize;
    DWORD                          Size;
    LPBYTE                         UID;

    DhcpAssert(NULL != ClientCtxt->Subnet);
    if( NULL == ClientCtxt->Subnet ) return ERROR_INVALID_PARAMETER;
    SScopeId = ClientCtxt->Subnet->SuperScopeId;

    Error = MemArrayInitLoc(&(ClientCtxt->Server->Subnets), &Loc);
    DhcpAssert(ERROR_SUCCESS == Error );

    while( ERROR_FILE_NOT_FOUND != Error ) {
        DhcpAssert(ERROR_SUCCESS == Error );

        Error = MemArrayGetElement(&(ClientCtxt->Server->Subnets), &Loc, (LPVOID *)&Subnet);
        DhcpAssert(ERROR_SUCCESS == Error);

        if( 0 == SScopeId && ClientCtxt->Subnet != Subnet ) {
            Error = MemArrayNextLoc(&(ClientCtxt->Server->Subnets), &Loc);
            continue;
        }

        if( Subnet->SuperScopeId == SScopeId ) {
            UID = NULL;
            Error = DhcpMakeClientUID(
                RawHwAddr,
                RawHwAddrSize,
                0 /* hardware type is hardcoded anyways.. */,
                Subnet->Address,
                &UID,
                &UIDSize
            );
            if( ERROR_SUCCESS != Error ) return Error;

            LOCK_DATABASE();
            Error = DhcpJetOpenKey(
                DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColName,
                UID,
                UIDSize
            );
            DhcpFreeMemory(UID);
            if( ERROR_SUCCESS == Error ) {
                Size = sizeof(DHCP_IP_ADDRESS);
                Error = DhcpJetGetValue(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
                    desiredIpAddress,
                    &Size
                );
                if( ERROR_SUCCESS == Error ) {
                    DhcpAssert(((*desiredIpAddress) & Subnet->Mask) == Subnet->Address);
                    UNLOCK_DATABASE();
                    return DhcpGetSubnetForAddress(
                        *desiredIpAddress,
                        ClientCtxt
                    );
                }
            }
            UNLOCK_DATABASE();
        }

        Error = MemArrayNextLoc(&(ClientCtxt->Server->Subnets), &Loc);
    }

    return ERROR_FILE_NOT_FOUND;
}

//BeginExport(function)
DWORD
DhcpRequestSomeAddress(                                // get some address in this context
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    OUT     DHCP_IP_ADDRESS       *desiredIpAddress,
    IN      BOOL                   fBootp
) //EndExport(function)
{
    static BOOL                    DhcpRangeFull = FALSE;
    static BOOL                    BootpRangeFull = FALSE;
    BOOL                           Result;
    PM_SUBNET                      Subnet;
    DWORD                          Error;

    *desiredIpAddress = 0;

    if( ClientCtxt->Subnet->fSubnet == TRUE &&
        FALSE == MemSubnetCheckBootpDhcp(ClientCtxt->Subnet, fBootp, TRUE ) ) {
        //
        // For DHCP Scopes, check to see if any required type of addreses
        // are present.. If not, return error saying none available.
        // No such checks for MADCAP Scopes.
        //
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }


    LOCK_MEMORY();
    Result = MemSubnetRequestAddress(
        ClientCtxt->Subnet,
        0,
        TRUE, /* also acquire the address */
        fBootp, /* asking for dynamic bootp address? */
        desiredIpAddress,
        &Subnet
    );
    UNLOCK_MEMORY();
    if( Result ) {
        DhcpAssert(*desiredIpAddress && Subnet);
        ClientCtxt->Subnet = Subnet;
        Error = MemSubnetGetAddressInfo(
            Subnet,
            *desiredIpAddress,
            &(ClientCtxt->Range),
            &(ClientCtxt->Excl),
            &(ClientCtxt->Reservation)
        );
        DhcpAssert(ERROR_SUCCESS == Error);
        if( fBootp ) {
            BootpRangeFull = FALSE;
        } else {
            DhcpRangeFull = FALSE;
        }
        return Error;
    }

    if( FALSE == (fBootp? BootpRangeFull : DhcpRangeFull) ) {
        //
        // avoid repeated logging..
        //
        if( fBootp ) BootpRangeFull = TRUE; else DhcpRangeFull = TRUE;
        DhcpUpdateAuditLog(
            fBootp?DHCP_IP_BOOTP_LOG_RANGE_FULL:DHCP_IP_LOG_RANGE_FULL,
            fBootp? GETSTRING( DHCP_IP_BOOTP_LOG_RANGE_FULL_NAME)
            : GETSTRING( DHCP_IP_LOG_RANGE_FULL_NAME ),
            ClientCtxt->Subnet->Address,
            NULL,
            0,
            NULL
        );
    }

    return ERROR_DHCP_RANGE_FULL;
}

//BeginExport(function)
BOOL
DhcpSubnetInSameSuperScope(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        IpAddress2
)   //EndExport(function)
{
    ULONG                          SubnetMask, SubnetAddress, Error;
    PM_SUBNET                      Subnet2;

    DhcpSubnetGetSubnetAddressAndMask(
        Subnet,
        &SubnetAddress,
        &SubnetMask
    );

    if( (IpAddress2 & SubnetMask ) == SubnetAddress ) return TRUE;

    Error = MemServerGetAddressInfo(
        DhcpGlobalThisServer,
        IpAddress2,
        &Subnet2,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return FALSE;

    // --ft: Addresses are in the same superscope if in the same subnet or if there is a
    // superscope and both subnets belong to it. (Subnets out of a superscope have SuperScopeId == 0)

    if (Subnet == Subnet2 ) return TRUE;

    return (Subnet->SuperScopeId == Subnet2->SuperScopeId) && ( 0 != Subnet->SuperScopeId );
}

//BeginExport(function)
BOOL
DhcpInSameSuperScope(
    IN      DHCP_IP_ADDRESS        Address1,
    IN      DHCP_IP_ADDRESS        Address2
) //EndExport(function)
{
    PM_SUBNET                      Subnet;
    DWORD                          Error;

    if( !DhcpGlobalThisServer ) return FALSE;

    Error = MemServerGetAddressInfo(
        DhcpGlobalThisServer,
        Address1,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return FALSE;

    return DhcpSubnetInSameSuperScope(Subnet, Address2);
}

//BeginExport(function)
BOOL
DhcpAddressIsOutOfRange(
    IN      DHCP_IP_ADDRESS        Address,
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    IN      BOOL                   fBootp
) //EndExport(function)
{
    return MemServerIsOutOfRangeAddress(ClientCtxt->Server, Address, fBootp);
}

//BeginExport(function)
BOOL
DhcpAddressIsExcluded(
    IN      DHCP_IP_ADDRESS        Address,
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt
) //EndExport(function)
{
    return MemServerIsExcludedAddress(ClientCtxt->Server, Address);
}

//BeginExport(function)
BOOL
DhcpRequestSpecificAddress(
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    IN      DHCP_IP_ADDRESS        Address
) //EndExport(function)
{
    DWORD                          Error;

    Error = MemServerGetAddressInfo(
        ClientCtxt->Server,
        Address,
        &(ClientCtxt->Subnet),
        &(ClientCtxt->Range),
        &(ClientCtxt->Excl),
        &(ClientCtxt->Reservation)
    );

    if( ERROR_SUCCESS != Error || !ClientCtxt->Range || ClientCtxt->Excl )
        return FALSE;

    LOCK_MEMORY();
    Error = MemSubnetRequestAddress(
        ClientCtxt->Subnet,
        Address,
        TRUE,
        FALSE,
        NULL,
        NULL
    );
    UNLOCK_MEMORY();

    if( TRUE != Error )
        return FALSE;
    return TRUE;
}

VOID
LogReleaseAddress(
    IN DHCP_IP_ADDRESS Address
    )
{
    //
    // For DBG builds alone, just print the fact that an
    // IP address got released..
    //
#if DBG
    DhcpUpdateAuditLog(
        DHCP_IP_LOG_DELETED,
        GETSTRING( DHCP_IP_LOG_DELETED_NAME ),
        Address,
        NULL,
        0,
        L"IPAddr Released"
        );
#endif
}

//BeginExport(function)
DWORD
DhcpReleaseBootpAddress(
    IN      DHCP_IP_ADDRESS        Address
) //EndExport(function)
{
    DWORD                          Error;

    LOCK_MEMORY();
    Error = MemServerReleaseAddress(
        DhcpGlobalThisServer,
        Address,
        TRUE
        );
    UNLOCK_MEMORY();

    if( ERROR_SUCCESS == Error ) LogReleaseAddress(Address);
    return Error;
}

//BeginExport(function)
DWORD
DhcpReleaseAddress(
    IN      DHCP_IP_ADDRESS        Address
) //EndExport(function)
{
    DWORD                          Error;

    LOCK_MEMORY();
    Error = MemServerReleaseAddress(
        DhcpGlobalThisServer,
        Address,
        FALSE
    );
    UNLOCK_MEMORY();

    if( ERROR_SUCCESS == Error ) LogReleaseAddress(Address);
    return Error;
}

//BeginExport(function)
DWORD
DhcpServerGetSubnetCount(
    IN      PM_SERVER              Server
) //EndExport(function)
{
    return Server?MemArraySize(&(Server->Subnets)):0;
}

//BeginExport(function)
DWORD
DhcpServerGetMScopeCount(
    IN      PM_SERVER              Server
) //EndExport(function)
{
    return Server?MemArraySize(&(Server->MScopes)):0;
}

//BeginExport(function)
DWORD
DhcpServerGetClassId(
    IN      PM_SERVER              Server,
    IN      LPBYTE                 ClassIdBytes,
    IN      DWORD                  nClassIdBytes
) //EndExport(function)
{
    PM_CLASSDEF                    ClassDef;
    DWORD                          Error;

    if( NULL == ClassIdBytes || 0 == nClassIdBytes )
        return 0;

    Error = MemServerGetClassDef(
        Server,
        0,
        NULL,
        nClassIdBytes,
        ClassIdBytes,
        &ClassDef
    );
    if( ERROR_SUCCESS != Error ) return 0;
    if( TRUE == ClassDef->IsVendor ) return 0;
    return ClassDef->ClassId;
}

//BeginExport(function)
DWORD
DhcpServerGetVendorId(
    IN      PM_SERVER              Server,
    IN      LPBYTE                 VendorIdBytes,
    IN      DWORD                  nVendorIdBytes
) //EndExport(function)
{
    PM_CLASSDEF                    ClassDef;
    DWORD                          Error;

    if( NULL == VendorIdBytes || 0 == nVendorIdBytes )
        return 0;

    Error = MemServerGetClassDef(
        Server,
        0,
        NULL,
        nVendorIdBytes,
        VendorIdBytes,
        &ClassDef
    );
    if( ERROR_SUCCESS != Error ) return 0;
    if( FALSE == ClassDef->IsVendor ) return 0;
    return ClassDef->ClassId;
}

//BeginExport(function)
BOOL
DhcpServerIsAddressReserved(
    IN      PM_SERVER              Server,
    IN      DHCP_IP_ADDRESS        Address
) //EndExport(function)
{
    return MemServerIsReservedAddress(Server,Address);
}

//BeginExport(function)
BOOL
DhcpServerIsAddressOutOfRange(
    IN      PM_SERVER              Server,
    IN      DHCP_IP_ADDRESS        Address,
    IN      BOOL                   fBootp
) //EndExport(function)
{
    DWORD                          Error;
    PM_RANGE                       Range;
    PM_EXCL                        Excl;

    Error = MemServerGetAddressInfo(
        Server,
        Address,
        NULL,
        &Range,
        &Excl,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return TRUE;

    if( Excl || NULL == Range ) return TRUE;
    if( 0 == (Range->State & (fBootp? MM_FLAG_ALLOW_BOOTP : MM_FLAG_ALLOW_DHCP) ) ) {
        return TRUE;
    }
    return FALSE;
}

//BeginExport(function)
BOOL
DhcpSubnetIsAddressExcluded(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        Address
) //EndExport(function)
{
    DWORD                          Error;
    PM_EXCL                        Excl;

    Error = MemSubnetGetAddressInfo(
        Subnet,
        Address,
        NULL,
        &Excl,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return FALSE;
    return NULL != Excl;
}

//BeginExport(function)
BOOL
DhcpSubnetIsAddressOutOfRange(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        Address,
    IN      BOOL                   fBootp
) //EndExport(function)
{
    DWORD                          Error;
    PM_RANGE                       Range;
    PM_EXCL                        Excl;
    PM_RESERVATION                 Resv;

    //
    // passing exclusion and resvation info to check if the address is ok.
    //

    Error = MemSubnetGetAddressInfo(
        Subnet,
        Address,
        &Range,
        &Excl,
        &Resv 
    );

    if( ERROR_SUCCESS != Error ) return TRUE;
    if( NULL == Range ) return TRUE;
    if( 0 == (Range->State & (fBootp? MM_FLAG_ALLOW_BOOTP : MM_FLAG_ALLOW_DHCP) ) ) {
        return TRUE;
    }
    return FALSE;
}

//BeginExport(function)
BOOL
DhcpSubnetIsAddressReserved(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        Address
) //EndExport(function)
{
    DWORD                          Error;
    PM_RESERVATION                 Reservation;

    Error = MemSubnetGetAddressInfo(
        Subnet,
        Address,
        NULL,
        NULL,
        &Reservation
    );

    if( ERROR_SUCCESS == Error && NULL != Reservation )
        return TRUE;

    return FALSE;
}

#if  0 // defined in rpcapi2.c with better implementation
//BeginExport(function)
DWORD
DhcpUpdateReservationInfo(
    IN      DHCP_IP_ADDRESS        IpAddress,
    IN      LPBYTE                 SetClientUID,
    IN      DWORD                  SetClientUIDLength
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Flags;
    PM_SUBNET                      Subnet;
    PM_RESERVATION                 Reservation;

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        IpAddress,
        &Subnet,
        NULL,
        NULL,
        &Reservation
    );
    if( ERROR_SUCCESS != Error || NULL == Subnet || NULL == Reservation ) {
        DhcpAssert(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    Flags = Reservation->Flags;

    return MemReserveReplace(
        &Subnet->Reservations,
        IpAddress,
        Flags,
        SetClientUID,
        SetClientUIDLength
    );
}
#endif 0

static const
DWORD                              TryThreshold = 5;
//BeginExport(function)
DWORD
DhcpRegFlushServerIfNeeded(
    VOID
) //EndExport(function)
{
    static ULONG                    DummyLong = 0;

    if( TryThreshold <= (ULONG)InterlockedIncrement(&DummyLong) ) {
        DummyLong = 0;
        return DhcpRegFlushServer(FALSE);
    }

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpFlushBitmaps(                                 // do a flush of all bitmaps that have changed
    VOID
) //EndExport(function)
{

    return DhcpRegFlushServer(TRUE);
}

//BeginExport(function)
DWORD
DhcpServerFindMScope(
    IN      PM_SERVER              Server,
    IN      DWORD                  ScopeId,
    IN      LPWSTR                 Name,          // Multicast scope name or NULL if this is not the key to search on
    OUT     PM_MSCOPE             *MScope
) //EndExport(function)
{
    return MemServerFindMScope(
        Server,
        ScopeId,
        Name,
        MScope
    );
}


//BeginExport(function)
BOOL
DhcpServerValidateNewMScopeId(
    IN      PM_SERVER               Server,
    IN      DWORD                   MScopeId
) //EndExport(function)
{
    PM_SUBNET   pMScope;
    DWORD       Error;

    Error = MemServerFindMScope(
                Server,
                MScopeId,
                INVALID_MSCOPE_NAME,
                &pMScope
                );

    if ( ERROR_SUCCESS == Error ) {
        return FALSE;
    } else {
        DhcpAssert( ERROR_FILE_NOT_FOUND == Error );
        return TRUE;
    }
}

//BeginExport(function)
BOOL
DhcpServerValidateNewMScopeName(
    IN      PM_SERVER               Server,
    IN      LPWSTR                  Name
) //EndExport(function)
{
    PM_SUBNET   pMScope;
    DWORD       Error;

    Error = MemServerFindMScope(
                Server,
                INVALID_MSCOPE_ID,
                Name,
                &pMScope
                );

    if ( ERROR_SUCCESS == Error ) {
        return FALSE;
    } else {
        DhcpAssert( ERROR_FILE_NOT_FOUND == Error );
        return TRUE;
    }
}


//BeginExport(function)
DWORD
DhcpMScopeReleaseAddress(
    IN      DWORD                  MScopeId,
    IN      DHCP_IP_ADDRESS        Address
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      pMScope;

    Error = DhcpServerFindMScope(
        DhcpGetCurrentServer(),
        MScopeId,
        NULL, /* scope name */
        &pMScope
        );
    if ( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "Could not find MScope object - id %lx, %ld\n", MScopeId, Error));
        return Error;
    }

    LOCK_MEMORY();
    Error = MemSubnetReleaseAddress(
        pMScope,
        Address,
        FALSE
    );
    UNLOCK_MEMORY();

    if( ERROR_SUCCESS == Error ) LogReleaseAddress(Address);
    return Error;
}

//BeginExport(function)
DWORD
DhcpSubnetRequestSpecificAddress(
    PM_SUBNET            Subnet,
    DHCP_IP_ADDRESS      IpAddress
) //EndExport(function)
{
    DWORD   Error;

	LOCK_MEMORY();
	Error = MemSubnetRequestAddress(
           Subnet,
           IpAddress,
           TRUE,
           FALSE,
           NULL,
           NULL
	);
	UNLOCK_MEMORY();
	return Error;
}

//BeginExport(function)
DWORD
DhcpSubnetReleaseAddress(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        Address
) //EndExport(function)
{
    DWORD                          Error;

    LOCK_MEMORY();
    Error = MemSubnetReleaseAddress(
        Subnet,
        Address,
        FALSE
    );
    UNLOCK_MEMORY();

    if( ERROR_SUCCESS == Error ) LogReleaseAddress(Address);
    return Error;
}

//BeginExport(function)
DWORD
MadcapGetMScopeListOption(
    IN      DHCP_IP_ADDRESS         ServerIpAddress,
    OUT     LPBYTE                 *OptVal,
    IN OUT  WORD                   *OptSize
) //EndExport(function)
{
    PM_SERVER                       pServer;
    PM_SUBNET                       pScope = NULL;
    ARRAY_LOCATION                  Loc;
    WORD                            TotalScopeDescLen;
    WORD                            ScopeCount;
    DWORD                           Error;
    WORD                            TotalSize;
    PBYTE                           pBuf,pScopeBuf;
    WORD                            DbgScopeCount = 0;

    pServer = DhcpGetCurrentServer();

    Error = MemArrayInitLoc(&(pServer->MScopes), &Loc);
    if ( ERROR_FILE_NOT_FOUND == Error ) {
        return Error;
    }

    // First find out how much memory do we need.
    ScopeCount = TotalScopeDescLen = 0;
    while ( ERROR_FILE_NOT_FOUND != Error ) {

        Error = MemArrayGetElement(&(pServer->MScopes), &Loc, (LPVOID *)&pScope);
        DhcpAssert(ERROR_SUCCESS == Error);

        if (!IS_DISABLED(pScope->State)) {
            if (pScope->Name) {
                TotalScopeDescLen += (WORD) ConvertUnicodeToUTF8(pScope->Name, -1, NULL, 0 );
                // add for the lang tag, flags, name length etc.
                TotalScopeDescLen += (3 + wcslen(pScope->LangTag));

            }
            ScopeCount++;
        }

        Error = MemArrayNextLoc(&(pServer->MScopes), &Loc);
    }

    if (!ScopeCount) {
        return ERROR_FILE_NOT_FOUND;
    }
    // MBUG - assumes IPv4
    TotalSize = 1 // scope count
                + ScopeCount * ( 10 ) // scope id, last addr, TTL, name count
                + TotalScopeDescLen; // all the descriptor.

    pScopeBuf = DhcpAllocateMemory( TotalSize );

    if ( !pScopeBuf ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    RtlZeroMemory( pScopeBuf, TotalSize );

    pBuf = pScopeBuf;
    // store the scope count
    *pBuf++ = (BYTE)ScopeCount;

    // now for each scope store the id and the descriptor.
    Error = MemArrayInitLoc(&(pServer->MScopes), &Loc);
    DhcpAssert(ERROR_SUCCESS == Error);

    while ( ERROR_FILE_NOT_FOUND != Error ) {
        LPSTR   pDesc;
        BYTE    DescLen;
        DWORD   LastAddr;

        Error = MemArrayGetElement(&(pServer->MScopes), &Loc, (LPVOID *)&pScope);
        DhcpAssert(ERROR_SUCCESS == Error);


        if (!IS_DISABLED(pScope->State)) {
            PM_RANGE    Range = NULL;
            ARRAY_LOCATION  LastLoc = 0;

            *(DWORD UNALIGNED *)pBuf = htonl(pScope->MScopeId);
            pBuf += 4;
            // store last address
            Error = MemArrayLastLoc(&(pScope->Ranges), &LastLoc);
            if (ERROR_SUCCESS == Error) {
                Error = MemArrayGetElement(&(pScope->Ranges), &LastLoc, &Range);
                DhcpAssert(ERROR_SUCCESS == Error);
                LastAddr = htonl(Range->End);
            } else {
                LastAddr = htonl(pScope->MScopeId);
            }
            *(DWORD UNALIGNED *)pBuf = LastAddr;
            pBuf += 4;
            // store the ttl
            *pBuf++ = pScope->TTL;
            // name count
            *pBuf++ = 1;


            if ( pScope->Name ) {
                char    LangTag[80];
                // Name flags
                *pBuf++ = 128;
                // Language tag
                DhcpAssert(pScope->LangTag);
                if (NULL == DhcpUnicodeToOem(pScope->LangTag, LangTag) ) {
                    DhcpFreeMemory( pScopeBuf );
                    return ERROR_INVALID_DATA;
                }
                *pBuf++ = (BYTE)strlen(LangTag);
                memcpy(pBuf, LangTag, strlen(LangTag));
                pBuf += strlen(LangTag);
                TotalScopeDescLen -= (3 + strlen(LangTag));
                pDesc = pBuf + 1;
                if ( 0 == (DescLen = (BYTE) ConvertUnicodeToUTF8(pScope->Name, -1, pDesc, TotalScopeDescLen) ) ) {
                    DhcpFreeMemory( pScopeBuf );
                    return ERROR_BAD_FORMAT;
                }
                TotalScopeDescLen -= DescLen;
            } else {
                DescLen = 0;
            }
            *pBuf++ = DescLen;
            pBuf += DescLen;
#ifdef DBG
            DbgScopeCount++;
#endif
        }

        Error = MemArrayNextLoc(&(pServer->MScopes), &Loc);
    }

    DhcpAssert( ScopeCount == DbgScopeCount );

    *OptVal = pScopeBuf;
    *OptSize = TotalSize;

    return ERROR_SUCCESS;
}

//BeginExport(function)
BOOL
DhcpRequestSpecificMAddress(
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    IN      DHCP_IP_ADDRESS        Address
) //EndExport(function)
{
    DWORD                          Error;

    Error = MemSubnetGetAddressInfo(
        ClientCtxt->Subnet,
        Address,
        &(ClientCtxt->Range),
        &(ClientCtxt->Excl),
        &(ClientCtxt->Reservation)
    );

    if( ERROR_SUCCESS != Error || !ClientCtxt->Range || ClientCtxt->Excl )
        return FALSE;

    LOCK_MEMORY();
    Error = MemSubnetRequestAddress(
        ClientCtxt->Subnet,
        Address,
        TRUE,
        FALSE,
        NULL,
        NULL
    );
    UNLOCK_MEMORY();

    if( ERROR_SUCCESS != Error )
        return FALSE;
    return TRUE;
}

//BeginExport(function)
BOOL
DhcpMScopeIsAddressReserved(
    IN      DWORD                   MScopeId,
    IN      DHCP_IP_ADDRESS         Address
) //EndExport(function)
{
    return FALSE;
}

//BeginExport(function)
BOOL
DhcpIsSubnetStateDisabled(
    IN ULONG SubnetState
)   //EndExport(function)
{
    return IS_DISABLED(SubnetState);
}


// This function returns TRUE if the subnet address in question does not exist in
// the list of subnets for the current server.  This SHOULD NOT BE CALLED with the
// Read/Write lock taken as the lock is taken right here.
//BeginExport(function)
BOOL
DhcpServerIsNotServicingSubnet(
    IN      DWORD                   IpAddressInSubnet
)   //EndExport(function)
{

    DWORD                           Mask;

    DhcpAcquireReadLock();

    Mask = DhcpGetSubnetMaskForAddress(IpAddressInSubnet);

    DhcpReleaseReadLock();

    return Mask == 0;
}

VOID        _inline
ConvertHostToNetworkString(
    IN      LPWSTR                  String,
    IN      ULONG                   NChars
)
{
    while(NChars--) {
        *String = htons(*String);
        String ++;
    }
}

// this function takes a class def and converts it into packs into a buffer as follows
// [size-hi] [size-lo] class-id-bytes [size-hi] [size-lo] name [size-hi] [lo] descr
// where name and descr are LPWSTR (nul terminated) that are just copied over..
VOID
ConvertClassDefToWireFormat(
    IN      PM_CLASSDEF             ClassDef,
    OUT     LPBYTE                 *Buf,          // allocated by this function
    OUT     DWORD                  *BufSize       // size allocated by this function
)
{
    DWORD                           Size;
    LPBYTE                          Mem;

    *Buf = NULL; *BufSize = 0;
    Size = 6+ ((3+ClassDef->nBytes)&~3)           // round off nbytes by "4"
        + sizeof(WCHAR)*(1+wcslen(ClassDef->Name));
    if( NULL == ClassDef->Comment ) Size += sizeof(WCHAR);
    else Size += sizeof(WCHAR)*(1+wcslen(ClassDef->Comment));

    Mem = DhcpAllocateMemory(Size);
    if( NULL == Mem ) return ;

    *Buf = Mem; *BufSize = Size;
    Mem[0] = (BYTE)(ClassDef->nBytes >> 8) ;
    Mem[1] = (BYTE)(ClassDef->nBytes & 0xFF);
    Mem += 2;
    memcpy(Mem, ClassDef->ActualBytes, ClassDef->nBytes);
    Mem += (ClassDef->nBytes+3)&~3;               // round off to multiple of "4"
    Size = sizeof(WCHAR)*(1+wcslen(ClassDef->Name));
    Mem[0] = (BYTE)(Size>>8);
    Mem[1] = (BYTE)(Size&0xFF);
    Mem += 2;
    memcpy(Mem, (LPBYTE)(ClassDef->Name), Size);
    ConvertHostToNetworkString((LPWSTR)Mem, Size/2);
    Mem += Size;
    if( NULL == ClassDef->Comment ) {
        Mem[0] = 0; Mem[1] = sizeof(WCHAR);
        Mem += 2; memset(Mem, 0, sizeof(WCHAR));
        Mem += sizeof(WCHAR);
    } else {
        Size = sizeof(WCHAR)*(1+wcslen(ClassDef->Comment));
        Mem[0] = (BYTE)(Size>>8);
        Mem[1] = (BYTE)(Size&0xFF);
        Mem += 2;
        memcpy(Mem, (LPBYTE)(ClassDef->Comment), Size);
        ConvertHostToNetworkString((LPWSTR)Mem, Size/2);
        Mem += Size;
    }
}

//BeginExport(function)
// This function tries to create a list of all classes (wire-class-id, class name, descr)
// and send this as an option. but since the list can be > 255 it has to be make a continuation...
// and also, we dont want the list truncated somewhere in the middle.. so we try to append
// information for each class separately to see if it succeeds..
LPBYTE
DhcpAppendClassList(
    IN OUT  LPBYTE                  BufStart,
    IN OUT  LPBYTE                  BufEnd
) //EndExport(function)
{
    PARRAY                          ClassDefList;
    ARRAY_LOCATION                  Loc;
    PM_CLASSDEF                     ThisClassDef = NULL;
    DWORD                           Result, Size;
    LPBYTE                          Buf;

    ClassDefList = &(DhcpGetCurrentServer()->ClassDefs.ClassDefArray);
    for( Result = MemArrayInitLoc(ClassDefList, &Loc)
         ;  ERROR_FILE_NOT_FOUND != Result ;
         Result = MemArrayNextLoc(ClassDefList, &Loc)
    ) {                                           // walk thru the array and add classes..
        Result = MemArrayGetElement(ClassDefList, &Loc, (LPVOID)&ThisClassDef);
        DhcpAssert(ERROR_SUCCESS == Result && NULL != ThisClassDef);

        if( ThisClassDef->IsVendor ) continue;    // don't list vendor classes

        Buf = NULL; Size = 0;
        ConvertClassDefToWireFormat(ThisClassDef, &Buf, &Size);
        if( NULL == Buf || 0 == Size ) {          // some error.. could not convert this class.. ignore..
            DhcpAssert(FALSE);
            continue;
        }

        BufStart = (LPBYTE)DhcpAppendOption(
            (LPOPTION)BufStart,
            OPTION_USER_CLASS,
            (PVOID)Buf,
            Size,
            (LPVOID)BufEnd
        );
        DhcpFreeMemory(Buf);
    }

    return BufStart;
}


//BeginExport(function)
DWORD
DhcpMemInit(
    VOID
) //EndExport(function)
{
#if DBG_MEM
    return MemInit();
#else
    return ERROR_SUCCESS;
#endif
}

//BeginExport(function)
VOID
DhcpMemCleanup(
    VOID
) //EndExport(function)
{
#if DBG_MEM
    MemCleanup();
#endif
}

ULONG       DhcpGlobalMemoryAllocated = 0;

#if  DBG_MEM
#undef DhcpAllocateMemory
#undef DhcpFreeMemory
LPVOID
DhcpAllocateMemory(
    IN      DWORD                  nBytes
)
{
    DWORD                          SizeBytes = ROUND_UP_COUNT(sizeof(DWORD),ALIGN_WORST);
    LPDWORD                        RetVal;

    DhcpAssert(nBytes != 0);
    RetVal = MemAlloc(nBytes+SizeBytes);
    if( NULL == RetVal ) return NULL;

    *RetVal = nBytes+SizeBytes;
    InterlockedExchangeAdd(&DhcpGlobalMemoryAllocated, nBytes+SizeBytes);
    return SizeBytes + (LPBYTE)RetVal;
}

VOID
DhcpFreeMemory(
    IN      LPVOID                 Ptr
)
{
    DWORD                          Result;
    LONG                           Size;

    if( NULL == Ptr ) {
        Require(FALSE);
        return;
    }

    Ptr = ((LPBYTE)Ptr) - ROUND_UP_COUNT(sizeof(DWORD), ALIGN_WORST);
    Size = *((LPLONG)Ptr);

    Result = MemFree(Ptr);
    DhcpAssert(ERROR_SUCCESS == Result);
    InterlockedExchangeAdd(&DhcpGlobalMemoryAllocated, -Size);
}
#endif  DBG

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\network.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    network.c

Abstract:

    This module contains the network interface for the DHCP server.

Author:

    Madan Appiah (madana)  10-Sep-1993
    Manny Weiser (mannyw)  24-Aug-1992

Environment:

    User Mode - Win32

Revision History:

--*/

#include "dhcppch.h"
#include "ipinfo.h"
#include "llinfo.h"
#include "ntddtcp.h"
#include "tdiinfo.h"
#include <ws2tcpip.h>
#include <iptbl.h>
#include <endpoint.h>

DWORD UpdateArpCache(DWORD dwIfAddress, DWORD dwIPAddress,
                     LPBYTE lpbLLAddress, DWORD dwLLAddrlen, BOOL bAdd);
DWORD OpenTcp();
DWORD TCPSetInformationEx(LPVOID lpvInBuffer, LPDWORD lpdwInSize,
                          LPVOID lpvOutBuffer, LPDWORD lpdwOutSize);
DWORD TCPQueryInformationEx(LPVOID lpvInBuffer, LPDWORD lpdwInSize,
                            LPVOID lpvOutBuffer, LPDWORD lpdwOutSize);

DWORD MapAddressToInstance(DWORD dwAddress, LPDWORD lpdwInstance,
                           LPDWORD lpdwIndex);
//
// TCPIP values
//
DWORD                 DhcpGlobalAddrToInstCount;
AddressToInstanceMap *DhcpGlobalAddrToInstTable = NULL;
HANDLE                DhcpGlobalTCPHandle;


BOOL _stdcall
SetBoundSocketInFdSet(
    IN OUT PENDPOINT_ENTRY Entry,
    IN PVOID FdSetp
    )
/*++

Routine Description:
    This routine sets the socket in the FdSet if the current endpoint
    is bound.  It sets both teh dhcp socket as well as the madcap
    socket.

Arguments:
    Entry -- endpoint entry.
    FdSet -- FD Set.

Return Value:
    TRUE always.

--*/
{
    fd_set *FdSet = (fd_set *)FdSetp;
    PENDPOINT Ep = (PENDPOINT)Entry;

    if( IS_ENDPOINT_BOUND( Ep ) ) {
        FD_SET(Ep->Socket, FdSet);
        FD_SET(Ep->MadcapSocket, FdSet);
    }

    return TRUE;
}

typedef struct {
    IN OUT BOOL fFound;
    IN OUT BOOL fMadcap;
    IN fd_set *FdSet;
    OUT SOCKET Sock;
    OUT DHCP_IP_ADDRESS IpAddress;
    OUT DHCP_IP_ADDRESS Mask;
} SOCK_READY_CTXT;

BOOL _stdcall
FindReadyContext(
    IN OUT PENDPOINT_ENTRY Entry,
    IN PVOID ReadyCtxt
    )
{
    PENDPOINT Ep = (PENDPOINT)Entry;
    SOCK_READY_CTXT *Ctxt = (SOCK_READY_CTXT *)ReadyCtxt;

    if( !IS_ENDPOINT_BOUND(Ep) ) return TRUE;

    Ctxt->IpAddress = Entry->IpAddress;
    Ctxt->Mask = Entry->SubnetMask;
    if( FD_ISSET(Ep->Socket, Ctxt->FdSet) ) {
        Ctxt->Sock = Ep->Socket;
        Ctxt->fFound = TRUE;
        return FALSE;
    }

    if( FD_ISSET(Ep->MadcapSocket, Ctxt->FdSet ) ) {
        Ctxt->Sock = Ep->MadcapSocket;
        Ctxt->fFound = TRUE;
        Ctxt->fMadcap = TRUE;
        return FALSE;
    }

    return TRUE;
}

DWORD
DhcpWaitForMessage(
    DHCP_REQUEST_CONTEXT *pRequestContext
    )
/*++

Routine Description:

    This function waits for a request on the DHCP port on any of the
    configured interfaces.

Arguments:

    RequestContext - A pointer to a request context block for
        this request.

Return Value:

    The status of the operation.

--*/
{
    DWORD length;
    DWORD error;
    fd_set readSocketSet;
    DWORD i;
    int readySockets;
    struct timeval timeout = { 0x7FFFFFFF, 0 }; // forever.
    BOOLEAN MsgRcvd;
    SOCKET readySocket;
    SOCK_READY_CTXT ReadyCtxt;

#define ENDPOINT_EVENT       0
#define TERMINATE_EVENT             1

#define EVENT_COUNT                 2

    if ( DhcpGlobalNumberOfNetsActive == 0 ) {
        HANDLE  WaitHandle[ EVENT_COUNT ];
        DWORD   result;

        DhcpPrint((DEBUG_MISC,"No active nets(%lx)..waiting\n", DhcpGlobalNumberOfNetsActive ));
        // no endpoints ready. wait infinitely for one to become available.
        WaitHandle[ ENDPOINT_EVENT ] = DhcpGlobalEndpointReadyEvent;
        WaitHandle[ TERMINATE_EVENT ] = DhcpGlobalProcessTerminationEvent;

        result = WaitForMultipleObjects(
            /* num handles  */ EVENT_COUNT,
            /* handle array */ WaitHandle,
            /* wait for any */ FALSE,
            /* timeout msecs*/INFINITE
            );

        switch ( result ) {
        case TERMINATE_EVENT:
            return( ERROR_SEM_TIMEOUT );
        case ENDPOINT_EVENT:
            break;
        default:
            break;
        }

    }

    //
    // Setup the file descriptor set for select from all bound
    // endpoints.
    //

    FD_ZERO(&readSocketSet);
    WalkthroughEndpoints(
        &readSocketSet,
        SetBoundSocketInFdSet
        );

    readySockets = select( 0, &readSocketSet, NULL, NULL, &timeout );

    //
    // return to caller when the service is shutting down or select()
    // times out.
    //

    if( (readySockets == 0)  ||
        (WaitForSingleObject( DhcpGlobalProcessTerminationEvent, 0 ) == 0) ) {

        return( ERROR_SEM_TIMEOUT );
    }

    //
    // Time to play 20 question with winsock.  Which socket is ready?
    //
    ReadyCtxt.fFound = FALSE;
    ReadyCtxt.fMadcap = FALSE;
    ReadyCtxt.FdSet = &readSocketSet;

    WalkthroughEndpoints(
        &ReadyCtxt,
        FindReadyContext
        );

    if( FALSE == ReadyCtxt.fFound ) {
        //
        // this can happen when a socket becomes readable
        // coz of a close that just happened on it on
        // the pnp thread.
        //
        return ERROR_DEV_NOT_EXIST;
    }

    pRequestContext->EndPointIpAddress = ReadyCtxt.IpAddress;
    pRequestContext->EndPointMask = ReadyCtxt.Mask;
    pRequestContext->EndPointSocket = ReadyCtxt.Sock;
    pRequestContext->fMadcap = ReadyCtxt.fMadcap;
    readySocket = ReadyCtxt.Sock;

    //
    // Read data from the net.  If multiple sockets have data, just
    // process the first available socket.
    //

    pRequestContext->SourceNameLength = sizeof( struct sockaddr );

    //
    // clean the receive buffer before receiving data in it.
    //

    RtlZeroMemory( pRequestContext->ReceiveBuffer, pRequestContext->ReceiveBufferSize );
    pRequestContext->ReceiveMessageSize = pRequestContext->ReceiveBufferSize;

    length = recvfrom(
                 readySocket,
                 (char *)pRequestContext->ReceiveBuffer,
                 pRequestContext->ReceiveMessageSize,
                 0,
                 &pRequestContext->SourceName,
                 (int *)&pRequestContext->SourceNameLength
                 );

    if ( length == SOCKET_ERROR ) {
        error = WSAGetLastError();
        DhcpPrint(( DEBUG_ERRORS, "Recv failed, error = %ld\n", error ));
        if( WSAENOTSOCK == error ) {
            // something changed underneath.  The socket just died?  let's hope that
            // the PnP thread will catch this soon.  Until then, we will have to sleep
            // maybe for a few milliseconds. Just yield this thread and see if that helps.
            Sleep(0);
        }
    } else {
        DhcpPrint(( DEBUG_MESSAGE, "Received message\n", 0 ));
        error = ERROR_SUCCESS;
    }

    pRequestContext->ReceiveMessageSize = length;
    return( error );
}



DWORD
DhcpSendMessage(
    LPDHCP_REQUEST_CONTEXT DhcpRequestContext
    )
/*++

Routine Description:

    This function send a response to a DHCP client.

Arguments:

    RequestContext - A pointer to the DhcpRequestContext block for
        this request.

Return Value:

    The status of the operation.

--*/
{
    DWORD error;
    struct sockaddr_in *source;
    LPDHCP_MESSAGE dhcpMessage;
    LPDHCP_MESSAGE dhcpReceivedMessage;
    WORD SendPort;
    DWORD MessageLength;
    BOOL  ArpCacheUpdated = FALSE;

    dhcpMessage = (LPDHCP_MESSAGE) DhcpRequestContext->SendBuffer;
    dhcpReceivedMessage = (LPDHCP_MESSAGE) DhcpRequestContext->ReceiveBuffer;

    //
    // if the request arrived from a relay agent, then send the reply
    // on server port otherwise on client port.
    //

    source = (struct sockaddr_in *)&DhcpRequestContext->SourceName;
    DhcpAssert( !DhcpRequestContext->fMadcap );
    if ( dhcpReceivedMessage->RelayAgentIpAddress != 0 ) {
        SendPort = (USHORT)DhcpGlobalServerPort ;
    } else {
        SendPort = (USHORT)DhcpGlobalClientPort;
    }
    source->sin_port = htons( SendPort );

    //
    // if this request arrived from relay agent then send the
    // response to the address the relay agent says.
    //


    if ( DHCP_INFORM_MESSAGE == DhcpRequestContext->MessageType ) {
        //
        // UNICAST inform ACKs to DHCP client unless we don't know the client address
        // or the BROADCAST bit is set..  (and even in those 2 cases, if we are
        // across a relay agent, unicast to relay agent on the SERVER port)
        //

        if( (ntohs(dhcpReceivedMessage->Reserved) & DHCP_BROADCAST ) ||
            0 == dhcpReceivedMessage->ClientIpAddress ) {

            if( 0 != dhcpReceivedMessage->RelayAgentIpAddress ) {
                source->sin_addr.s_addr = dhcpReceivedMessage->RelayAgentIpAddress;
                dhcpMessage->Reserved = 0; // Why this strangeness?
            } else {
                source->sin_addr.s_addr = (DWORD) -1;
                //
                // Values in this case should be set before, don't need to bother.
                //
            }

        } else {

            source->sin_addr.s_addr = dhcpReceivedMessage->ClientIpAddress;
            source->sin_port = htons((USHORT)DhcpGlobalClientPort);
        }

    } else if ( dhcpReceivedMessage->RelayAgentIpAddress != 0 ) {
        source->sin_addr.s_addr = dhcpReceivedMessage->RelayAgentIpAddress;

    } else {

        //
        // if the client didnt specify broadcast bit and if
        // we know the ipaddress of the client then send unicast.
        //

        //
        // But if IgnoreBroadcastFlag is set in the registry and
        // if the client requested to broadcast or the server is
        // nacking or If the client doesn't have an address yet,
        // respond via broadcast.
        // Note that IgnoreBroadcastFlag is off by default. But it
        // can be set as a workaround for the clients that are not
        // capable of receiving unicast
        // and they also dont set the broadcast bit.
        //

        if ( DhcpGlobalIgnoreBroadcastFlag ) {
            if( (ntohs(dhcpReceivedMessage->Reserved) & DHCP_BROADCAST) ||
                    (dhcpReceivedMessage->ClientIpAddress == 0) ||
                    (source->sin_addr.s_addr == 0) ) {

                source->sin_addr.s_addr = (DWORD)-1;

                dhcpMessage->Reserved = 0;
                    // this flag should be zero in the local response.
            }

        } else {

            if( (ntohs(dhcpReceivedMessage->Reserved) & DHCP_BROADCAST) ||
                (!dhcpMessage->YourIpAddress ) ){

                source->sin_addr.s_addr = (DWORD)-1;

                dhcpMessage->Reserved = 0;
                    // this flag should be zero in the local response.
            } else {
                DWORD   LocalError;
                if ( ( LocalError = UpdateArpCache(
                                        DhcpRequestContext->EndPointIpAddress,
                                        dhcpMessage->YourIpAddress,
                                        dhcpReceivedMessage->HardwareAddress,
                                        dhcpReceivedMessage->HardwareAddressLength,
                                        TRUE)) == STATUS_SUCCESS ) {

                    source->sin_addr.s_addr = dhcpMessage->YourIpAddress;
                    ArpCacheUpdated = TRUE;
                    DhcpPrint((DEBUG_STOC, "Arp entry added on %s interface for %s client \n",
                        inet_ntoa( *(struct in_addr *)&DhcpRequestContext->EndPointIpAddress),
                        inet_ntoa( *(struct in_addr *)&dhcpMessage->YourIpAddress)) );

                } else {
                    DhcpPrint(( DEBUG_ERRORS, "Failed to add Arp entry on %s, for client %s, Error %lx\n",
                        inet_ntoa( *(struct in_addr *)&DhcpRequestContext->EndPointIpAddress),
                        inet_ntoa( *(struct in_addr *)&dhcpMessage->YourIpAddress), LocalError) );

                    source->sin_addr.s_addr = (DWORD)-1;
                }

            }

        }
    }

#if DBG
    // This allows the DHCP Server to be up on the net while we are doing the rest.  So,
    // Whenever this guy is up, we still do not broadcast.. but just send to the test
    // machines address....
    if( (DWORD)(-1) != DhcpRegGetBcastAddress() )
        source->sin_addr.s_addr = DhcpRegGetBcastAddress();
#endif


    DhcpPrint(( DEBUG_STOC, "Sending response to = %s, XID = %lx.\n",
        inet_ntoa(source->sin_addr), dhcpMessage->TransactionID));


    //
    // send minimum DHCP_MIN_SEND_RECV_PK_SIZE (300) bytes, otherwise
    // bootp relay agents don't like the packet.
    //

    MessageLength = ((
        DhcpRequestContext->SendMessageSize >
        DHCP_MIN_SEND_RECV_PK_SIZE)
        ? DhcpRequestContext->SendMessageSize
        : DHCP_MIN_SEND_RECV_PK_SIZE
        )
        ;
    error = sendto(
        DhcpRequestContext->EndPointSocket,
        (char *)DhcpRequestContext->SendBuffer,
        MessageLength,
        0,
        &DhcpRequestContext->SourceName,
        DhcpRequestContext->SourceNameLength
        );

    if ( error == SOCKET_ERROR ) {
        error = WSAGetLastError();
        DhcpPrint(( DEBUG_ERRORS, "Send failed, error = %ld\n", error ));
    } else {
        error = ERROR_SUCCESS;
    }

    if ( ArpCacheUpdated ) {
        DWORD   LocalError;
        LocalError = UpdateArpCache(
            DhcpRequestContext->EndPointIpAddress,
            dhcpMessage->YourIpAddress,
            dhcpReceivedMessage->HardwareAddress,
            dhcpReceivedMessage->HardwareAddressLength,
            FALSE
            );
        if( LocalError != STATUS_SUCCESS ) {

            DhcpPrint((
                DEBUG_ERRORS, "Failed to delete Arp entry on %s"
                ", for client %s, Error %lx\n",
                inet_ntoa( *(struct in_addr *)
                           &DhcpRequestContext->EndPointIpAddress),
                inet_ntoa( *(struct in_addr *)
                           &dhcpMessage->YourIpAddress),
                LocalError
                ) );

        }

    }

    return( error );
}

DWORD
MadcapSendMessage(
    LPDHCP_REQUEST_CONTEXT DhcpRequestContext
    )
/*++

Routine Description:

    This function send a response to a DHCP client.

Arguments:

    RequestContext - A pointer to the DhcpRequestContext block for
        this request.

Return Value:

    The status of the operation.

--*/
{
    DWORD error;
    struct sockaddr_in *source;
    LPMADCAP_MESSAGE dhcpMessage;
    LPMADCAP_MESSAGE dhcpReceivedMessage;

    dhcpMessage = (LPMADCAP_MESSAGE) DhcpRequestContext->SendBuffer;
    dhcpReceivedMessage = (LPMADCAP_MESSAGE) DhcpRequestContext->ReceiveBuffer;

    //
    // if the request arrived from a relay agent, then send the reply
    // on server port otherwise on client port.
    //

    source = (struct sockaddr_in *)&DhcpRequestContext->SourceName;



    DhcpPrint(( DEBUG_STOC, "Sending response to = %s, XID = %lx.\n",
        inet_ntoa(source->sin_addr), dhcpMessage->TransactionID));


    error = sendto(
        DhcpRequestContext->EndPointSocket,
        (char *)DhcpRequestContext->SendBuffer,
        DhcpRequestContext->SendMessageSize,
        0,
        &DhcpRequestContext->SourceName,
        DhcpRequestContext->SourceNameLength
        );

    if ( error == SOCKET_ERROR ) {
        error = WSAGetLastError();
        DhcpPrint(( DEBUG_ERRORS, "Send failed, error = %ld\n", error ));
    } else {
        error = ERROR_SUCCESS;
    }


    return( error );
}

//---------------------------------------------------------------------------
// Function:    UpdateArpCache
//
// Parameters:
//      DWORD   dwIfAddress     the interface to modify
//      DWORD   dwIPAddress     the IP address to add
//      LPBYTE  lpbLLAddress    the hardware address to add
//      DWORD   dwLLAddrlen     the length of the hardware address
//      BOOL    bAdd            if true, an entry is added. otherwise,
//                              an entry is deleted.
//
// This function adds or deletes an entry to the local ARP cache for
// the network interface whose IP address is dwIfAddress
//---------------------------------------------------------------------------
DWORD APIENTRY UpdateArpCache(DWORD dwIfAddress, DWORD dwIPAddress,
                     LPBYTE lpbLLAddress, DWORD dwLLAddrlen, BOOL bAdd) {
    UCHAR *lpContext;
    TDIObjectID *lpObject;
    IPNetToMediaEntry *lpinmeEntry;
    TCP_REQUEST_SET_INFORMATION_EX *lptrsiBuffer;

    DWORD dwErr, dwInstance, dwIndex, dwInSize, dwOutSize;


    dwErr = MapAddressToInstance(dwIfAddress, &dwInstance, &dwIndex);
    if (dwErr == (DWORD)-1) { return 1; }

    dwInSize = sizeof(TCP_REQUEST_SET_INFORMATION_EX) +
               sizeof(IPNetToMediaEntry) - 1;
    lptrsiBuffer = DhcpAllocateMemory(dwInSize);
    if (lptrsiBuffer == NULL) {
        return GetLastError();
    }

    lptrsiBuffer->BufferSize = sizeof(IPNetToMediaEntry);

    lpObject = &lptrsiBuffer->ID;
    lpObject->toi_id = AT_MIB_ADDRXLAT_ENTRY_ID;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_entity.tei_entity = AT_ENTITY;
    lpObject->toi_entity.tei_instance = dwInstance;

    lpinmeEntry = (IPNetToMediaEntry *)lptrsiBuffer->Buffer;
    lpinmeEntry->inme_index = dwIndex;
    lpinmeEntry->inme_addr = dwIPAddress;
    lpinmeEntry->inme_type = (bAdd ? INME_TYPE_DYNAMIC : INME_TYPE_INVALID);
    lpinmeEntry->inme_physaddrlen = dwLLAddrlen;
    CopyMemory(lpinmeEntry->inme_physaddr, lpbLLAddress, dwLLAddrlen);

    dwOutSize = 0;
    dwErr = TCPSetInformationEx((LPVOID)lptrsiBuffer, &dwInSize,
                                NULL, &dwOutSize);

    return dwErr;
}



//-----------------------------------------------------------------------
// Function:    GetAddressToInstanceTable
//
// Parameters:
//      none
//
// Builds the mappings from IP address to ARP Entity Instance; these
// mappings are needed for adding entries to ARP caches when messages
// are being relayed to clients.
// The algorithm is as follows:

//  get table of all TDI entities.
//  query each address translation entity in the table, and save
//      the instance numbers of all entities which support ARP.
//  query each ARP entity for its address translation info; this
//      info includes a field axi_index.
//  query the IP layer for the table of all IP address entries; these
//      entries include a field iae_index which corresponds to axi_index.
//  for each IP address, make an entry in our global AddressToInstanceMap
//      array, setting the index (by matching iae_index to axi_index),
//      the address (using iae_address), and the instance number
//      by using iae_index (==axi_index) to find the AddrXlatInfo for this
//      IP address, and then using the AddrXlatInfo to find the
//      ARP instance number.
//-----------------------------------------------------------------------
DWORD APIENTRY GetAddressToInstanceTable() {
    UCHAR *lpContext;
    IPSNMPInfo ipsiInfo;
    TDIObjectID *lpObject;

    DWORD dwErr, dwInSize, dwOutSize;
    TCP_REQUEST_QUERY_INFORMATION_EX trqiBuffer;

    DWORD dwAxiCount;
    AddrXlatInfo *lpAXITable, *lpaxi, *lpaxiend;

    DWORD dwAddrCount;
    IPAddrEntry *lpAddrTable, *lpaddr, *lpaddrend;

    DWORD dwEntityCount;
    TDIEntityID *lpEntityTable, *lpent, *lpentend;

    DWORD dwArpInstCount;
    DWORD adwArpInstTable[MAX_TDI_ENTITIES], *lpdwinst, *lpdwinstend;

    AddressToInstanceMap *lpAddrToInstTable, *lpatoi;


    //-----------------
    // get entity table
    //-----------------
    dwInSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutSize = MAX_TDI_ENTITIES * sizeof(TDIEntityID);

    lpEntityTable = (TDIEntityID *)DhcpAllocateMemory(dwOutSize);
    if (lpEntityTable == NULL) {
        return GetLastError();
    }

    lpContext = (UCHAR *)trqiBuffer.Context;
    ZeroMemory(lpContext, CONTEXT_SIZE);

    lpObject = &trqiBuffer.ID;
    lpObject->toi_id = ENTITY_LIST_ID;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_class = INFO_CLASS_GENERIC;
    lpObject->toi_entity.tei_instance = 0;
    lpObject->toi_entity.tei_entity = GENERIC_ENTITY;

    dwErr = TCPQueryInformationEx(&trqiBuffer, &dwInSize,
                                  lpEntityTable, &dwOutSize);
    if (dwErr != NO_ERROR || dwOutSize == 0) {
        DhcpFreeMemory(lpEntityTable);
        return dwErr;
    }

    dwEntityCount = dwOutSize / sizeof(TDIEntityID);


    //-------------------------------------------
    // copy instance numbers for all ARP entities
    //-------------------------------------------
    dwInSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    lpContext = (UCHAR *)trqiBuffer.Context;
    lpObject = &trqiBuffer.ID;
    lpObject->toi_id = ENTITY_TYPE_ID;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_class = INFO_CLASS_GENERIC;
    lpObject->toi_entity.tei_entity = AT_ENTITY;

    lpdwinst = adwArpInstTable;
    lpentend = lpEntityTable + dwEntityCount;
    for (lpent = lpEntityTable; lpent < lpentend; lpent++) {
        if (lpent->tei_entity == AT_ENTITY) {
            DWORD dwEntityType;

            lpObject->toi_type = INFO_TYPE_PROVIDER;
            lpObject->toi_class = INFO_CLASS_GENERIC;
            lpObject->toi_entity.tei_entity = AT_ENTITY;
            lpObject->toi_entity.tei_instance = lpent->tei_instance;

            dwInSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
            dwOutSize = sizeof(dwEntityType);
            ZeroMemory(lpContext, CONTEXT_SIZE);

            dwErr = TCPQueryInformationEx(&trqiBuffer, &dwInSize,
                                          &dwEntityType, &dwOutSize);
            if (dwErr != NO_ERROR) {
                continue;
            }

            if (dwEntityType == AT_ARP) {
                *lpdwinst++ = lpent->tei_instance;
            }

        }
    }

    // done with the entity table now
    DhcpFreeMemory(lpEntityTable);

    dwArpInstCount = (DWORD)(lpdwinst - adwArpInstTable);
    if (dwArpInstCount == 0) {
        return 0;
    }


    //------------------------------------------------
    // make memory for the AT entities and then
    // query ARP entities for address translation info
    //------------------------------------------------
    lpAXITable = DhcpAllocateMemory(dwArpInstCount * sizeof(AddrXlatInfo));
    if (lpAXITable == NULL) {
        return GetLastError();
    }

    lpContext = (UCHAR *)trqiBuffer.Context;

    lpObject->toi_id = AT_MIB_ADDRXLAT_INFO_ID;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_entity.tei_entity = AT_ENTITY;

    lpaxi = lpAXITable;
    lpaxiend = lpAXITable + dwArpInstCount;
    lpdwinstend = adwArpInstTable + dwArpInstCount;
    for (lpdwinst = adwArpInstTable; lpdwinst < lpdwinstend; lpdwinst++) {
        lpObject->toi_entity.tei_instance = *lpdwinst;

        dwInSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
        dwOutSize = sizeof(AddrXlatInfo);

        ZeroMemory(lpContext, CONTEXT_SIZE);

        dwErr = TCPQueryInformationEx(&trqiBuffer, &dwInSize,
                                      lpaxi, &dwOutSize);

        // ignore errors, since each AddrXlatInfo must be in
        // a position in the AXI table that is parallel with
        // the postion of its instance number in the instance table
        if (dwErr != 0) {
            lpaxi->axi_index = (DWORD)-1;
        }
        ++lpaxi;
    }

    dwAxiCount = (DWORD)(lpaxi - lpAXITable);
    if (dwAxiCount == 0) {
        DhcpFreeMemory(lpAXITable);
        return 0;
    }


    //------------------------------
    // query IP for IP address table
    //------------------------------

    // first get address count
    dwInSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutSize = sizeof(IPSNMPInfo);

    lpContext = (UCHAR *)trqiBuffer.Context;
    ZeroMemory(lpContext, CONTEXT_SIZE);

    lpObject->toi_id = IP_MIB_STATS_ID;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_entity.tei_entity = CL_NL_ENTITY;
    lpObject->toi_entity.tei_instance = 0;

    dwErr = TCPQueryInformationEx(&trqiBuffer, &dwInSize,
                                  &ipsiInfo, &dwOutSize);
    if (dwErr != NO_ERROR || ipsiInfo.ipsi_numaddr == 0) {
        DhcpFreeMemory(lpAXITable);
        return dwErr;
    }

    dwAddrCount = ipsiInfo.ipsi_numaddr;

    // got address count, now get address table

    dwInSize = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    dwOutSize = (dwAddrCount + 5) * sizeof(IPAddrEntry);

    lpAddrTable = DhcpAllocateMemory(dwOutSize);
    if (lpAddrTable == NULL) {
        DhcpFreeMemory(lpAXITable);
        return GetLastError();
    }

    lpContext = (UCHAR *)trqiBuffer.Context;
    ZeroMemory(lpContext, CONTEXT_SIZE);

    lpObject->toi_id = IP_MIB_ADDRTABLE_ENTRY_ID;
    lpObject->toi_type = INFO_TYPE_PROVIDER;
    lpObject->toi_class = INFO_CLASS_PROTOCOL;
    lpObject->toi_entity.tei_entity = CL_NL_ENTITY;
    lpObject->toi_entity.tei_instance = 0;

    dwErr = TCPQueryInformationEx(&trqiBuffer, &dwInSize,
                                  lpAddrTable, &dwOutSize);
    if (dwErr != NO_ERROR) {
        DhcpFreeMemory(lpAXITable);
        DhcpFreeMemory(lpAddrTable);
        return GetLastError();
    }


    // build table of AddressToInstanceMap structures
    // for each IP address, as follows:
    //      use IPAddrEntry.iae_index to find corresponding
    //          AddrXlatInfo.axi_index
    //      use the AddrXlatInfo found to find corresponding TDIEntityID
    //      use the TDIEntity found to set AddressToInstanceMap.dwInstance
    //--------------------------------------------------------------------
    lpAddrToInstTable = DhcpAllocateMemory(dwAddrCount * sizeof(AddressToInstanceMap));
    if (lpAddrToInstTable == NULL) {
        DhcpFreeMemory(lpAXITable);
        DhcpFreeMemory(lpAddrTable);
        return GetLastError();
    }

    lpatoi = lpAddrToInstTable;
    lpaxiend = lpAXITable + dwAxiCount;
    lpaddrend = lpAddrTable + dwAddrCount;
    for (lpaddr = lpAddrTable; lpaddr < lpaddrend; lpaddr++) {
        lpatoi->dwIndex = lpaddr->iae_index;
        lpatoi->dwIPAddress = lpaddr->iae_addr;

        // find the instance number
        lpdwinst = adwArpInstTable;
        for (lpaxi = lpAXITable; lpaxi < lpaxiend; lpaxi++) {
            if (lpaxi->axi_index != (DWORD)-1 &&
                lpaxi->axi_index == lpaddr->iae_index) {
                lpatoi->dwInstance = *lpdwinst;
                ++lpatoi;
                break;
            }
            ++lpdwinst;
        }
    }

    // done with AXI table and IP address table
    DhcpFreeMemory(lpAXITable);
    DhcpFreeMemory(lpAddrTable);

    if (DhcpGlobalAddrToInstTable != NULL) {
        DhcpFreeMemory(DhcpGlobalAddrToInstTable);
    }

    DhcpGlobalAddrToInstCount = (DWORD)(lpatoi - lpAddrToInstTable);
    DhcpGlobalAddrToInstTable = lpAddrToInstTable;

    return 0;
}



//------------------------------------------------------------------
// Function:    MapAddressToInstance
//
// Parameters:
//      DWORD   dwAddress       the address to map
//
//------------------------------------------------------------------
DWORD MapAddressToInstance(DWORD dwAddress, LPDWORD lpdwInstance,
                           LPDWORD lpdwIndex) {
    DWORD dwErr;
    AddressToInstanceMap *lpptr, *lpend;

    dwErr = (DWORD)-1;

    if ( DhcpGlobalAddrToInstTable == NULL ) {
        return dwErr;
    }
    lpend = DhcpGlobalAddrToInstTable + DhcpGlobalAddrToInstCount;
    for (lpptr = DhcpGlobalAddrToInstTable; lpptr < lpend; lpptr++) {
        if (dwAddress == lpptr->dwIPAddress) {
            *lpdwIndex = lpptr->dwIndex;
            *lpdwInstance = lpptr->dwInstance;
            dwErr = 0;
            break;
        }
    }

    return dwErr;
}



//------------------------------------------------------------------
// Function:    OpenTcp
//
// Parameters:
//      none.
//
// Opens the handle to the Tcpip driver.
//------------------------------------------------------------------
DWORD OpenTcp() {
    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;

    // Open the ip stack for setting routes and parps later.
    //
    // Open a Handle to the TCP driver.
    //
    RtlInitUnicodeString(&nameString, DD_TCP_DEVICE_NAME);

    InitializeObjectAttributes(&objectAttributes, &nameString,
			                   OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtCreateFile(
        &DhcpGlobalTCPHandle,
        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
        &objectAttributes, &ioStatusBlock, NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_OPEN_IF,
        FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0
        );

    return (status == STATUS_SUCCESS ? 0 : ERROR_OPEN_FAILED);

}



//---------------------------------------------------------------------
// Function:        TCPQueryInformationEx
//
// Parameters:
//      TDIObjectID *ID            The TDI Object ID to query
//      void        *Buffer        buffer to contain the query results
//      LPDWORD     *BufferSize    pointer to the size of the buffer
//                                 filled in with the amount of data.
//      UCHAR       *Context       context value for the query. should
//                                 be zeroed for a new query. It will be
//                                 filled with context information for
//                                 linked enumeration queries.
//
// Returns:
//      An NTSTATUS value.
//
//  This routine provides the interface to the TDI QueryInformationEx
//      facility of the TCP/IP stack on NT.
//---------------------------------------------------------------------
DWORD TCPQueryInformationEx(LPVOID lpvInBuffer, LPDWORD lpdwInSize,
                            LPVOID lpvOutBuffer, LPDWORD lpdwOutSize) {
    NTSTATUS status;
    IO_STATUS_BLOCK isbStatusBlock;

    if (DhcpGlobalTCPHandle == NULL) {
        OpenTcp();
    }

    status = NtDeviceIoControlFile(
        DhcpGlobalTCPHandle, // Driver handle
        NULL,                // Event
        NULL,                // APC Routine
        NULL,                // APC context
        &isbStatusBlock,     // Status block
        IOCTL_TCP_QUERY_INFORMATION_EX,  // Control
        lpvInBuffer,         // Input buffer
        *lpdwInSize,         // Input buffer size
        lpvOutBuffer,        // Output buffer
        *lpdwOutSize
        );       // Output buffer size

    if (status == STATUS_PENDING) {
	    status = NtWaitForSingleObject(DhcpGlobalTCPHandle, TRUE, NULL);
        status = isbStatusBlock.Status;
    }

    if (status != STATUS_SUCCESS) {
        *lpdwOutSize = 0;
    }
    else {
        *lpdwOutSize = (ULONG)isbStatusBlock.Information;
    }

    return status;
}




//---------------------------------------------------------------------------
// Function:        TCPSetInformationEx
//
// Parameters:
//
//      TDIObjectID *ID         the TDI Object ID to set
//      void      *lpvBuffer    data buffer containing the information
//                              to be set
//      DWORD     dwBufferSize  the size of the data buffer.
//
//  This routine provides the interface to the TDI SetInformationEx
//  facility of the TCP/IP stack on NT.
//---------------------------------------------------------------------------
DWORD TCPSetInformationEx(LPVOID lpvInBuffer, LPDWORD lpdwInSize,
                          LPVOID lpvOutBuffer, LPDWORD lpdwOutSize) {
    NTSTATUS status;
    IO_STATUS_BLOCK isbStatusBlock;

    if (DhcpGlobalTCPHandle == NULL) {
        OpenTcp();
    }

    status = NtDeviceIoControlFile(
        DhcpGlobalTCPHandle, // Driver handle
        NULL,                // Event
        NULL,                // APC Routine
        NULL,                // APC context
        &isbStatusBlock,     // Status block
        IOCTL_TCP_SET_INFORMATION_EX,    // Control
        lpvInBuffer,         // Input buffer
        *lpdwInSize,         // Input buffer size
        lpvOutBuffer,        // Output buffer
        *lpdwOutSize
        );       // Output buffer size
    
    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(DhcpGlobalTCPHandle, TRUE, NULL);
        status = isbStatusBlock.Status;
    }

    if (status != STATUS_SUCCESS) {
        *lpdwOutSize = 0;
    }
    else {
        *lpdwOutSize = (ULONG)isbStatusBlock.Information;
    }

    return status;
}


DHCP_IP_ADDRESS
DhcpResolveName(
    CHAR *szHostName
    )
/*++

Routine Description:
    Resolves the specified host name to an IP address
    .
Arguments:

    szHostName  - host name
    .

Return Value:

    Success - the IP address for szHostName.
    Failure - 0.

    .

--*/

{
    DHCP_IP_ADDRESS IpAddress = 0;

    IpAddress = inet_addr( szHostName );

    if ( INADDR_NONE == IpAddress )
    {
        HOSTENT *ph = gethostbyname( szHostName );
        if ( ph )
        {
            IpAddress = *((DHCP_IP_ADDRESS*) ph->h_addr_list[0]);
        }
    }

    return IpAddress;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\oldstub.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    oldstub.h

Abstract:

    This file is the old RPC stub code.

Author:

    Madan Appiah  (madana)  25-APR-1994

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

#include <string.h>
#include <limits.h>

#include "dhcp_srv.h"

/* routine that frees graph for struct _DHCP_BINARY_DATA */
void _fgs__DHCP_BINARY_DATA (DHCP_BINARY_DATA  * _source);

/* routine that frees graph for struct _DHCP_HOST_INFO */
void _fgs__DHCP_HOST_INFO (DHCP_HOST_INFO  * _source);

/* routine that frees graph for struct _DHCP_SUBNET_INFO */
void _fgs__DHCP_SUBNET_INFO (DHCP_SUBNET_INFO  * _source);

/* routine that frees graph for struct _DHCP_IP_ARRAY */
void _fgs__DHCP_IP_ARRAY (DHCP_IP_ARRAY  * _source);

/* routine that frees graph for struct _DHCP_IP_RESERVATION */
void _fgs__DHCP_IP_RESERVATION (DHCP_IP_RESERVATION_V4  * _source);

/* routine that frees graph for union _DHCP_SUBNET_ELEMENT_UNION */
void _fgu__DHCP_SUBNET_ELEMENT_UNION (union _DHCP_SUBNET_ELEMENT_UNION_V4 * _source, DHCP_SUBNET_ELEMENT_TYPE _branch);

/* routine that frees graph for struct _DHCP_SUBNET_ELEMENT_DATA */
void _fgs__DHCP_SUBNET_ELEMENT_DATA (DHCP_SUBNET_ELEMENT_DATA_V4  * _source);

/* routine that frees graph for struct _DHCP_SUBNET_ELEMENT_INFO_ARRAY */
void _fgs__DHCP_SUBNET_ELEMENT_INFO_ARRAY (DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4  * _source);


/* routine that frees graph for union _DHCP_OPTION_ELEMENT_UNION */
void _fgu__DHCP_OPTION_ELEMENT_UNION (union _DHCP_OPTION_ELEMENT_UNION * _source, DHCP_OPTION_DATA_TYPE _branch);

/* routine that frees graph for struct _DHCP_OPTION_DATA_ELEMENT */
void _fgs__DHCP_OPTION_DATA_ELEMENT (DHCP_OPTION_DATA_ELEMENT  * _source);

/* routine that frees graph for struct _DHCP_OPTION_DATA */
void _fgs__DHCP_OPTION_DATA (DHCP_OPTION_DATA  * _source);

/* routine that frees graph for struct _DHCP_OPTION */
void _fgs__DHCP_OPTION (DHCP_OPTION  * _source);

/* routine that frees graph for struct _DHCP_OPTION_VALUE */
void _fgs__DHCP_OPTION_VALUE (DHCP_OPTION_VALUE  * _source);

/* routine that frees graph for struct _DHCP_OPTION_VALUE_ARRAY */
void _fgs__DHCP_OPTION_VALUE_ARRAY (DHCP_OPTION_VALUE_ARRAY  * _source);

/* routine that frees graph for struct _DHCP_OPTION_LIST */
void _fgs__DHCP_OPTION_LIST (DHCP_OPTION_LIST  * _source);

/* routine that frees graph for struct _DHCP_CLIENT_INFO */
void _fgs__DHCP_CLIENT_INFO (DHCP_CLIENT_INFO_V4  * _source);

/* routine that frees graph for struct _DHCP_CLIENT_INFO_V5 */
void _fgs__DHCP_CLIENT_INFO_V5 (DHCP_CLIENT_INFO_V5 * _source);

/* routine that frees graph for struct _DHCP_CLIENT_INFO_ARRAY */
void _fgs__DHCP_CLIENT_INFO_ARRAY (DHCP_CLIENT_INFO_ARRAY_V4  * _source);

/* routine that frees graph for struct _DHCP_INFO_ARRAY_V5 */
void _fgs__DHCP_CLIENT_INFO_ARRAY_V5 (DHCP_CLIENT_INFO_ARRAY_V5    *_source);

/* routine that frees graph for union _DHCP_CLIENT_SEARCH_UNION */
void _fgu__DHCP_CLIENT_SEARCH_UNION (union _DHCP_CLIENT_SEARCH_UNION * _source, DHCP_SEARCH_INFO_TYPE _branch);

/* routine that frees graph for struct _DHCP_CLIENT_SEARCH_INFO */
void _fgs__DHCP_CLIENT_SEARCH_INFO (DHCP_SEARCH_INFO  * _source);

/* routine that frees graph for struct _DHCP_OPTION_ARRAY */
void _fgs__DHCP_OPTION_ARRAY(DHCP_OPTION_ARRAY * _source );

/* routine that frees graph for struct _DHCP_MCLIENT_INFO */
void _fgs__DHCP_MCLIENT_INFO (DHCP_MCLIENT_INFO  * _source);

/* routine that frees graph for struct _DHCP_MCLIENT_INFO_ARRAY */
void _fgs__DHCP_MCLIENT_INFO_ARRAY (DHCP_MCLIENT_INFO_ARRAY  * _source);

DHCP_SUBNET_ELEMENT_DATA_V4 *
CopySubnetElementDataToV4(
    DHCP_SUBNET_ELEMENT_DATA    *pInput
    );

BOOL
CopySubnetElementUnionToV4(
    DHCP_SUBNET_ELEMENT_UNION_V4 *pUnionV4,
    DHCP_SUBNET_ELEMENT_UNION    *pUnion,
    DHCP_SUBNET_ELEMENT_TYPE      Type
    );

DHCP_IP_RANGE *
CopyIpRange(
    DHCP_IP_RANGE *IpRange
    );

DHCP_HOST_INFO *
CopyHostInfo( DHCP_HOST_INFO *pHostInfo,
              OPTIONAL DHCP_HOST_INFO *pHostInfoDest
    );

DHCP_IP_RESERVATION_V4 *
CopyIpReservationToV4(
    DHCP_IP_RESERVATION *pInput
    );

DHCP_IP_CLUSTER *
CopyIpCluster(
    DHCP_IP_CLUSTER *pInput
    );

DHCP_BINARY_DATA *
CopyBinaryData(
    DHCP_BINARY_DATA *pInput,
    DHCP_BINARY_DATA *pOutputBuff
    );

DHCP_CLIENT_INFO_V4 *
CopyClientInfoToV4(
    DHCP_CLIENT_INFO *pInput
    );


WCHAR *
DupUnicodeString( WCHAR *pInput
    );







=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\pendingc.c ===
//================================================================================
// Copyright (c) 1997 Microsoft Corporation
// Author: RameshV
// Description: deals with the pending context list structures used to shortcircuit
// expensive lookups and searches..
//================================================================================
#include <dhcppch.h>
#include <mdhcpsrv.h>
#include <align.h>

//BeginExport(typedef)
#ifndef     PENDING_CTXT_DEFINED
#define     PENDING_CTXT_DEFINED
typedef struct _DHCP_PENDING_CTXT {               // this is what is stored for each pending client
    LIST_ENTRY                     BucketList;    // entry in the bucket (hash list)
    LIST_ENTRY                     GlobalList;    // list of ALL pending contexts in FIFO order
    LPBYTE                         RawHwAddr;     // raw hw address, not UID as created by us
    DWORD                          nBytes;        // size of above in bytes
    DWORD                          Address;       // offered address
    DWORD                          LeaseDuration; // how long did we offer before?
    DWORD                          T1, T2;        // old offered T1 and T2
    DWORD                          MScopeId;      // MScopeId this address was offered from.
    DATE_TIME                      ExpiryTime;    // when should this context be expired?
    BOOL                           Processing;    // is this being processed?
} DHCP_PENDING_CTXT, *PDHCP_PENDING_CTXT, *LPDHCP_PENDING_CTXT;
typedef     LIST_ENTRY             PENDING_CTXT_SEARCH_HANDLE;
typedef     PLIST_ENTRY            PPENDING_CTXT_SEARCH_HANDLE;
typedef     PLIST_ENTRY            LPPENDING_CTXT_SEARCH_HANDLE;
#endif      PENDING_CTXT_DEFINED
//EndExport(typedef)

#define     HASH_SIZE              512            // hash table of size 255 bytes
LIST_ENTRY                         PendingList;
LIST_ENTRY                         Buckets[HASH_SIZE];
DWORD                              nPendingReqs = 0;
const       DWORD                  MaxPendingRequests = 1000;
static      DWORD                  Initialized = 0;
#if DBG
DWORD                              nBytesAllocatedForPendingRequests = 0;
#endif

DWORD       _inline
CalculateHashValue(
    IN      LPBYTE                 RawHwAddr,
    IN      DWORD                  nBytes
) {
    ULONG                          RetVal = 0;
    while( nBytes >= sizeof(DWORD) ) {
        RetVal += *((DWORD UNALIGNED*)RawHwAddr) ++;
        nBytes -= sizeof(DWORD);
    }
    while( nBytes-- ) RetVal += *RawHwAddr++;
    return RetVal % HASH_SIZE;
}

//BeginExport(function)
DWORD
DhcpFindPendingCtxt(                              // find if a pending context exists (srch by ip address or hw addr)
    IN      LPBYTE                 RawHwAddr,     // OPTIONAL the hw addr to use for search
    IN      DWORD                  RawHwAddrSize, // OPTIONAL size of above in bytes
    IN      DWORD                  Address,       // OPTIONAL the address to search for
    OUT     PDHCP_PENDING_CTXT    *Ctxt
) //EndExport(function)
{
    DWORD                          Hash;
    PLIST_ENTRY                    List, ThisEntry;

    DhcpAssert( RawHwAddrSize != 0 && Address == 0 || RawHwAddrSize == 0 && Address != 0 );

    if( 0 == RawHwAddrSize ) {                    // this search is global
        List = &PendingList;
    } else {
        Hash = CalculateHashValue(RawHwAddr, RawHwAddrSize );
        DhcpAssert( Hash < HASH_SIZE);

        List = &Buckets[Hash];
    }

    ThisEntry = List->Flink;
    while( ThisEntry != List ) {
        if( RawHwAddrSize ) {                     // looking in bucket list
            *Ctxt = CONTAINING_RECORD( ThisEntry, DHCP_PENDING_CTXT, BucketList );
            if( (*Ctxt)->nBytes == RawHwAddrSize )
                if( 0 == memcmp(RawHwAddr, (*Ctxt)->RawHwAddr, RawHwAddrSize) )
                    return ERROR_SUCCESS;
        } else {                                  // looking in global list
            *Ctxt = CONTAINING_RECORD( ThisEntry, DHCP_PENDING_CTXT, GlobalList );
            if( Address == (*Ctxt)->Address )
                return ERROR_SUCCESS;
        }

        ThisEntry = ThisEntry->Flink;
    }

    *Ctxt = NULL;
    return ERROR_FILE_NOT_FOUND;
}

DWORD
DhcpRemoveMatchingCtxt(
    IN DWORD                       Mask,
    IN DWORD                       Address
)
{
    PDHCP_PENDING_CTXT             Ctxt;
    PLIST_ENTRY                    ThisEntry;

    ThisEntry = PendingList.Flink;
    while( ThisEntry != &PendingList )
    {
        Ctxt = CONTAINING_RECORD( ThisEntry, DHCP_PENDING_CTXT, GlobalList );
        ThisEntry = ThisEntry->Flink;
        if ((Ctxt->Address & Mask) == Address)
        {
            RemoveEntryList(&Ctxt->BucketList);           // remove from the bucket
            RemoveEntryList(&Ctxt->GlobalList);           // remove from the global list

            DhcpFreeMemory(Ctxt);
        }
    }
    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpRemovePendingCtxt(                            // remove a ctxt from the pending ctxt list
    IN OUT  PDHCP_PENDING_CTXT     Ctxt
) //EndExport(function)
{
    DhcpAssert(!IsListEmpty(&Ctxt->BucketList));
    DhcpAssert(!IsListEmpty(&Ctxt->GlobalList));

    RemoveEntryList(&Ctxt->BucketList);           // remove from the bucket
    RemoveEntryList(&Ctxt->GlobalList);           // remove from the global list

    InitializeListHead(&Ctxt->BucketList);
    InitializeListHead(&Ctxt->GlobalList);

    nPendingReqs--;

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpAddPendingCtxt(                               // add a new pending ctxt
    IN      LPBYTE                 RawHwAddr,     // raw bytes that form the hw address
    IN      DWORD                  nBytes,        // size of above in bytes
    IN      DWORD                  Address,       // offered address
    IN      DWORD                  LeaseDuration, // how long did we offer before?
    IN      DWORD                  T1,            // old offered T1
    IN      DWORD                  T2,            // old offered T2
    IN      DWORD                  MScopeId,      // the multicast scope id of offered address.
    IN      DATE_TIME              ExpiryTime,    // how long to keep the pending ctxt?
    IN      BOOL                   Processing     // is this context still being processed?
) //EndExport(function)
{
    PDHCP_PENDING_CTXT             Ctxt;
    DWORD                          Result;
    DWORD                          Size;
    DWORD                          Hash;
    PLIST_ENTRY                    Entry;


    DhcpAssert( !CLASSD_HOST_ADDR( Address ) || MScopeId != 0 );

    if( nPendingReqs < MaxPendingRequests ) {
    } else {                                      // not enough space for a pending context.. make space
        Entry = PendingList.Blink;
        Ctxt = CONTAINING_RECORD(Entry, DHCP_PENDING_CTXT, GlobalList);
        Result = DhcpRemovePendingCtxt(Ctxt);
        if( ERROR_SUCCESS != Result ) {
            DhcpAssert(FALSE);
            return Result;
        }
        Result = DhcpDeletePendingCtxt(Ctxt);
        // Require(ERROR_SUCCESS == Result);
    }

    Size = sizeof(*Ctxt) + nBytes ;
    Ctxt = DhcpAllocateMemory(Size);
    if( NULL == Ctxt ) return ERROR_NOT_ENOUGH_MEMORY;

    nPendingReqs ++;                          // we are adding one more pending context
    Ctxt->RawHwAddr = sizeof(*Ctxt) + (LPBYTE)Ctxt;
    memcpy(Ctxt->RawHwAddr, RawHwAddr, nBytes);
    Ctxt->nBytes = nBytes;
    Ctxt->LeaseDuration = LeaseDuration;
    Ctxt->T1 = T1;
    Ctxt->T2 = T2;
    Ctxt->Address = Address;
    Ctxt->MScopeId = MScopeId;
    Ctxt->Processing = Processing;
    Ctxt->ExpiryTime = ExpiryTime;

    Hash = CalculateHashValue(RawHwAddr, nBytes);
    DhcpAssert( Hash < HASH_SIZE);

    InsertHeadList(&Buckets[Hash], &Ctxt->BucketList);
    InsertHeadList(&PendingList, &Ctxt->GlobalList);
#if DBG
    nBytesAllocatedForPendingRequests += sizeof(*Ctxt) + Ctxt->nBytes;
#endif

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpDeletePendingCtxt(
    IN OUT  PDHCP_PENDING_CTXT     Ctxt
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Size;
    BYTE                           State;
    BOOL                           OkToRelease;

    DhcpAssert(IsListEmpty(&Ctxt->BucketList));   // must have been taken off the buckets
    DhcpAssert(IsListEmpty(&Ctxt->GlobalList));   // must have been taken off the buckets

    LOCK_DATABASE();
    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        &(Ctxt->Address),
        sizeof(Ctxt->Address)
    );
    if( ERROR_SUCCESS != Error ) {
        OkToRelease = TRUE;                       // ok to release address with no db entry
    } else {
        Size = sizeof(State);
        Error = DhcpJetGetValue(
            DhcpGlobalClientTable[STATE_INDEX].ColHandle,
            &State,
            &Size
        );
        if( ERROR_SUCCESS != Error || IsAddressDeleted(State) || !IS_ADDRESS_STATE_ACTIVE(State) )
            OkToRelease = TRUE;
        else OkToRelease = FALSE;
    }

    if( OkToRelease ) {
        DhcpReleaseAddress(Ctxt->Address);        // release the address -- it must be taken
    } else {
        DhcpPrint((DEBUG_ERRORS, "Address 0x%lx is not deleted from registry!\n", Ctxt->Address));
    }

    UNLOCK_DATABASE();
#if DBG
    nBytesAllocatedForPendingRequests -= sizeof(*Ctxt) + Ctxt->nBytes;
#endif
    DhcpFreeMemory(Ctxt);

    return ERROR_SUCCESS;
}

DWORD
MadcapDeletePendingCtxt(
    IN OUT  PDHCP_PENDING_CTXT     Ctxt
)
{
    DWORD                          Error;
    DWORD                          Size;
    BYTE                           State;
    BOOL                           OkToRelease;
    DB_CTX  DbCtx;


    DhcpAssert(IsListEmpty(&Ctxt->BucketList));   // must have been taken off the buckets
    DhcpAssert(IsListEmpty(&Ctxt->GlobalList));   // must have been taken off the buckets

    INIT_DB_CTX(&DbCtx,DhcpGlobalJetServerSession,MadcapGlobalClientTableHandle);

    LOCK_DATABASE();
    Error = MadcapJetOpenKey(
        &DbCtx,
        MCAST_COL_NAME(MCAST_TBL_IPADDRESS),
        &(Ctxt->RawHwAddr),
        Ctxt->nBytes
        );

    if( ERROR_SUCCESS != Error ) {
        OkToRelease = TRUE;                       // ok to release address with no db entry
    } else {
        Size = sizeof(State);
        Error = MadcapJetGetValue(
            &DbCtx,
            MCAST_COL_HANDLE(MCAST_TBL_STATE),
            &State,
            &Size
        );
        if( ERROR_SUCCESS != Error || !IS_ADDRESS_STATE_ACTIVE(State) )
            OkToRelease = TRUE;
        else OkToRelease = FALSE;
    }

    if( OkToRelease ) {
        Error = DhcpMScopeReleaseAddress(Ctxt->MScopeId, Ctxt->Address);        // release the address -- it must be taken
    } else {
        DhcpPrint((DEBUG_ERRORS, "Address 0x%lx is not deleted from registry!\n", Ctxt->Address));
    }

    UNLOCK_DATABASE();
#if DBG
    nBytesAllocatedForPendingRequests -= sizeof(*Ctxt) + Ctxt->nBytes;
#endif
    DhcpFreeMemory(Ctxt);

    return ERROR_SUCCESS;
}

#define     DATE_CONV(X)           (*(ULONGLONG UNALIGNED *)(&X))

//BeginExport(function)
DWORD
DhcpDeleteExpiredCtxt(                            // all ctxt with expiration time < this will be deleted
    IN      DATE_TIME              ExpiryTime     // if this is zero, delete EVERY element
) //EndExport(function)
{
    PDHCP_PENDING_CTXT             Ctxt;
    PLIST_ENTRY                    ThisEntry;
    DWORD                          Error;

    if( 0 == Initialized ) return ERROR_SUCCESS;

    ThisEntry = PendingList.Flink;
    while( ThisEntry != &PendingList ) {
        Ctxt = CONTAINING_RECORD(ThisEntry, DHCP_PENDING_CTXT, GlobalList);
        ThisEntry = ThisEntry->Flink;

        if( (ULONGLONG)0 == DATE_CONV(ExpiryTime) ||
            DATE_CONV(Ctxt->ExpiryTime) < DATE_CONV(ExpiryTime) ) {
            DHCP_IP_ADDRESS Addr = htonl(Ctxt->Address);

            DhcpPrint((DEBUG_SCAVENGER, "Deleting pending %s\n",
                       inet_ntoa(*(struct in_addr *)&Addr) ));
            Error = DhcpRemovePendingCtxt(Ctxt);
            DhcpAssert(ERROR_SUCCESS == Error);
            if (CLASSD_HOST_ADDR(Ctxt->Address)) {
                Error = MadcapDeletePendingCtxt(Ctxt);
            } else {
                Error = DhcpDeletePendingCtxt(Ctxt);
            }
            DhcpAssert(ERROR_SUCCESS == Error);
        } else {
            DHCP_IP_ADDRESS Addr = htonl(Ctxt->Address);

            DhcpPrint((DEBUG_SCAVENGER, "Not deleting pending %s\n",
                       inet_ntoa(*(struct in_addr *)&Addr) ));
        }
    }

    return ERROR_SUCCESS;
}

//BeginExport(function)
DWORD
DhcpCountIPPendingCtxt(                             // find the # of pending ctxt in given subnet
    IN      DWORD                  SubnetAddress,
    IN      DWORD                  SubnetMask
) //EndExport(function)
{
    DWORD                          Count;
    PDHCP_PENDING_CTXT             Ctxt;
    PLIST_ENTRY                    ThisEntry;

    Count = 0;
    ThisEntry = PendingList.Flink;
    while( ThisEntry != &PendingList ) {
        Ctxt = CONTAINING_RECORD(ThisEntry, DHCP_PENDING_CTXT, GlobalList);
        ThisEntry = ThisEntry->Flink;

        if( !CLASSD_HOST_ADDR(Ctxt->Address) && ((Ctxt->Address & SubnetMask) == SubnetAddress) )
            Count ++;
    }

    //
    // This assert is BOGUS as we can easily have multiple subnet's cache in this list.. so
    // it is not valid to assume total matches this..
    // DhcpAssert(nPendingReqs == Count);
    //
    return Count;
}

//BeginExport(function)
DWORD
DhcpCountMCastPendingCtxt(                             // find the # of pending ctxt in given subnet
    IN      DWORD                  MScopeId
) //EndExport(function)
{
    DWORD                          Count;
    PDHCP_PENDING_CTXT             Ctxt;
    PLIST_ENTRY                    ThisEntry;

    Count = 0;
    ThisEntry = PendingList.Flink;
    while( ThisEntry != &PendingList ) {
        Ctxt = CONTAINING_RECORD(ThisEntry, DHCP_PENDING_CTXT, GlobalList);
        ThisEntry = ThisEntry->Flink;

        if( CLASSD_HOST_ADDR(Ctxt->Address) && Ctxt->MScopeId == MScopeId )
            Count ++;
    }

    //
    // With MCAST stuff, this count isn't accurate so far as nPendingReqs
    // is concerned... So, we'll leave this alone and not ASSERT
    //
    //DhcpAssert(nPendingReqs == Count);
    //
    return Count;
}

//BeginExport(function)
DWORD
DhcpPendingListInit(                              // intialize this module
    VOID
) //EndExport(function)
{
    DWORD                          i;

    DhcpAssert(0 == Initialized);
    InitializeListHead(&PendingList);
    for( i = 0 ; i < HASH_SIZE ; i ++ )
        InitializeListHead(&Buckets[i]);

    Initialized ++;
    return ERROR_SUCCESS;
}

//BeginExport(function)
VOID
DhcpPendingListCleanup(                           // cleanup everything in this module
    VOID
) //EndExport(function)
{
    DWORD                          i;
    DWORD                          Error;
    DATE_TIME                      ZeroTime;

    if( 0 == Initialized ) return ;
    Initialized --;
    DhcpAssert(0 == Initialized);

    memset(&ZeroTime, 0, sizeof(ZeroTime));
    Error = DhcpDeleteExpiredCtxt(ZeroTime);      // delete every pending ctxt
    DhcpAssert(ERROR_SUCCESS == Error);

    nPendingReqs = 0;
#if DBG
    nBytesAllocatedForPendingRequests = 0;
#endif
    return ;
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\pendingc.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation
//  Author: RameshV
//  Description: This file has been generated. Pl look at the .c file
//========================================================================

#ifndef     PENDING_CTXT_DEFINED
#define     PENDING_CTXT_DEFINED
typedef struct _DHCP_PENDING_CTXT {               // this is what is stored for each pending client
    LIST_ENTRY                     BucketList;    // entry in the bucket (hash list)
    LIST_ENTRY                     GlobalList;    // list of ALL pending contexts in FIFO order
    LPBYTE                         RawHwAddr;     // raw hw address, not UID as created by us
    DWORD                          nBytes;        // size of above in bytes
    DWORD                          Address;       // offered address
    DWORD                          LeaseDuration; // how long did we offer before?
    DWORD                          T1, T2;        // old offered T1 and T2
    DWORD                          MScopeId;      // MScopeId this address was offered from.
    DATE_TIME                      ExpiryTime;    // when should this context be expired?
    BOOL                           Processing;    // is this being processed?
} DHCP_PENDING_CTXT, *PDHCP_PENDING_CTXT, *LPDHCP_PENDING_CTXT;
typedef     LIST_ENTRY             PENDING_CTXT_SEARCH_HANDLE;
typedef     PLIST_ENTRY            PPENDING_CTXT_SEARCH_HANDLE;
typedef     PLIST_ENTRY            LPPENDING_CTXT_SEARCH_HANDLE;
#endif      PENDING_CTXT_DEFINED


DWORD
DhcpFindPendingCtxt(                              // find if a pending context exists (srch by ip address or hw addr)
    IN      LPBYTE                 RawHwAddr,     // OPTIONAL the hw addr to use for search
    IN      DWORD                  RawHwAddrSize, // OPTIONAL size of above in bytes
    IN      DWORD                  Address,       // OPTIONAL the address to search for
    OUT     PDHCP_PENDING_CTXT    *Ctxt
) ;


DWORD
DhcpRemoveMatchingCtxt(
    IN DWORD                       Mask,
    IN DWORD                       Address
) ;

DWORD
DhcpRemovePendingCtxt(                            // remove a ctxt from the pending ctxt list
    IN OUT  PDHCP_PENDING_CTXT     Ctxt
) ;


DWORD
DhcpAddPendingCtxt(                               // add a new pending ctxt
    IN      LPBYTE                 RawHwAddr,     // raw bytes that form the hw address
    IN      DWORD                  nBytes,        // size of above in bytes
    IN      DWORD                  Address,       // offered address
    IN      DWORD                  LeaseDuration, // how long did we offer before?
    IN      DWORD                  T1,            // old offered T1
    IN      DWORD                  T2,            // old offered T2
    IN      DWORD                  MScopeId,      // multicast scope id
    IN      DATE_TIME              ExpiryTime,    // how long to keep the pending ctxt?
    IN      BOOL                   Processing     // is this context still being processed?
) ;


DWORD
DhcpDeletePendingCtxt(
    IN OUT  PDHCP_PENDING_CTXT     Ctxt
) ;

DWORD
MadcapDeletePendingCtxt(
    IN OUT  PDHCP_PENDING_CTXT     Ctxt
) ;


DWORD
DhcpDeleteExpiredCtxt(                            // all ctxt with expiration time < this will be deleted
    IN      DATE_TIME              ExpiryTime     // if this is zero, delete EVERY element
) ;


DWORD
DhcpCountIPPendingCtxt(                             // find the # of pending ctxt in given subnet
    IN      DWORD                  SubnetAddress,
    IN      DWORD                  SubnetMask
);

DWORD
DhcpCountMCastPendingCtxt(                             // find the # of pending ctxt in given subnet
    IN      DWORD                  MScopeId
);

DWORD
DhcpPendingListInit(                              // intialize this module
    VOID
) ;


VOID
DhcpPendingListCleanup(                           // cleanup everything in this module
    VOID
) ;

//========================================================================
//  end of file
//========================================================================

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\perf.c ===
/*++

    Copyright (C) 1998 Microsoft Corporation

Module:

    perf.c

Abstract:

    This module creates the shared memory segment needed for running
    perfmon

Author:

    Ramesh V K (RameshV) 08-Aug-1998

Environment:

    User mode (Win32)


--*/

#include <dhcppch.h>
#include <aclapi.h>

#define REF_REG_KEY L"MACHINE\\System\\CurrentControlSet\\Services\\DHCPServer\\Performance"

ULONG
CopyDaclsFromRegistryToSharedMem(
    VOID
)
{
    BOOL Status;
    ULONG Error;
    PACL pDacl = NULL;
    PSID pOwnerSid = NULL;
    WCHAR String[sizeof(REF_REG_KEY)/sizeof(WCHAR)] = REF_REG_KEY;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    
    Error = GetNamedSecurityInfo(
        String,
        SE_REGISTRY_KEY,
        DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION ,
        &pOwnerSid,
        NULL,
        &pDacl,
        NULL,
        &pSecurityDescriptor
    );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_INIT, "GetNamedSecurityInfo failed %ld\n", Error));
        return Error;
    }

    Error = SetNamedSecurityInfo(
        DHCPCTR_SHARED_MEM_NAME,
        SE_KERNEL_OBJECT,
        DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION ,
        pOwnerSid,
        NULL,
        pDacl,
        NULL
    );

    if( pSecurityDescriptor ) LocalFree (pSecurityDescriptor);

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_INIT, "SetNamedSecurityInfoEx failed %ld\n", Error));
    }

    return Error;
}

BOOL fPerfInitialized = FALSE;
HANDLE PerfHandle = NULL;

ULONG
PerfInit(
    VOID
)
{
    ULONG Error;

    DhcpAssert( FALSE == fPerfInitialized );

    if( TRUE == fPerfInitialized ) return ERROR_SUCCESS;

    do {
        PerfStats = NULL;
        PerfHandle = CreateFileMapping(
            INVALID_HANDLE_VALUE,
            NULL,
            PAGE_READWRITE,
            0,
            sizeof(DHCP_PERF_STATS),
            DHCPCTR_SHARED_MEM_NAME
        );
        if( NULL == PerfHandle ) break;

        PerfStats = (LPVOID) MapViewOfFile(
            PerfHandle,
            FILE_MAP_WRITE,
            0,
            0,
            sizeof(DHCP_PERF_STATS)
        );
        if( NULL == PerfStats ) break;

        fPerfInitialized = TRUE;

        RtlZeroMemory( PerfStats, sizeof(*PerfStats));
        CopyDaclsFromRegistryToSharedMem();
        return ERROR_SUCCESS;
    } while (FALSE);

    Error = GetLastError();

    if( NULL != PerfHandle ) {
        CloseHandle(PerfHandle);
        PerfHandle = NULL;
        PerfStats = NULL;
    }

    return Error;
}

VOID
PerfCleanup(
    VOID
)
{
    if( FALSE == fPerfInitialized ) return;

    if( NULL != PerfStats ) UnmapViewOfFile( PerfStats );
    if( NULL != PerfHandle ) CloseHandle( PerfHandle );

    PerfStats = NULL;
    PerfHandle  = NULL;
    fPerfInitialized = FALSE;
}

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\oldstub.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    oldstub.c

Abstract:

    This file is the old RPC stub code.

Author:

    Madan Appiah  (madana)  25-APR-1994

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/

#include "dhcppch.h"

#define WSTRSIZE( wsz ) (( wcslen( wsz ) + 1 ) * sizeof( WCHAR ))


/* routine that frees graph for struct _DHCP_BINARY_DATA */
void _fgs__DHCP_BINARY_DATA (DHCP_BINARY_DATA  * _source)
  {
  if (_source->Data !=0)
    {
    MIDL_user_free((void  *)(_source->Data));
    }
  }
/* routine that frees graph for struct _DHCP_HOST_INFO */
void _fgs__DHCP_HOST_INFO (DHCP_HOST_INFO  * _source)
  {
  if (_source->NetBiosName !=0)
    {
    MIDL_user_free((void  *)(_source->NetBiosName));
    }
  if (_source->HostName !=0)
    {
    MIDL_user_free((void  *)(_source->HostName));
    }
  }


/* routine that frees graph for struct _DHCP_SUBNET_INFO */
void _fgs__DHCP_SUBNET_INFO (DHCP_SUBNET_INFO  * _source)
  {
  if (_source->SubnetName !=0)
    {
    MIDL_user_free((void  *)(_source->SubnetName));
    }
  if (_source->SubnetComment !=0)
    {
    MIDL_user_free((void  *)(_source->SubnetComment));
    }
  _fgs__DHCP_HOST_INFO ((DHCP_HOST_INFO *)&_source->PrimaryHost);
  }

/* routine that frees graph for struct _DHCP_IP_ARRAY */
void _fgs__DHCP_IP_ARRAY (DHCP_IP_ARRAY  * _source)
  {
  if (_source->Elements !=0)
    {
    MIDL_user_free((void  *)(_source->Elements));
    }
  }

/* routine that frees graph for struct _DHCP_IP_RESERVATION */
void _fgs__DHCP_IP_RESERVATION (DHCP_IP_RESERVATION_V4  * _source)
  {
  if (_source->ReservedForClient !=0)
    {
    _fgs__DHCP_BINARY_DATA ((DHCP_BINARY_DATA *)_source->ReservedForClient);
    MIDL_user_free((void  *)(_source->ReservedForClient));
    }

  }
/* routine that frees graph for union _DHCP_SUBNET_ELEMENT_UNION */
void _fgu__DHCP_SUBNET_ELEMENT_UNION (union _DHCP_SUBNET_ELEMENT_UNION_V4 * _source, DHCP_SUBNET_ELEMENT_TYPE _branch)
  {
  switch (_branch)
    {
    case DhcpIpRanges :
    case DhcpIpRangesDhcpOnly:
    case DhcpIpRangesBootpOnly:
    case DhcpIpRangesDhcpBootp:
      {
      if (_source->IpRange !=0)
        {
        MIDL_user_free((void  *)(_source->IpRange));
        }
      break;
      }
    case DhcpSecondaryHosts :
      {
      if (_source->SecondaryHost !=0)
        {
        _fgs__DHCP_HOST_INFO ((DHCP_HOST_INFO *)_source->SecondaryHost);
        MIDL_user_free((void  *)(_source->SecondaryHost));
        }
      break;
      }
    case DhcpReservedIps :
      {
      if (_source->ReservedIp !=0)
        {
        _fgs__DHCP_IP_RESERVATION ((DHCP_IP_RESERVATION_V4 *)_source->ReservedIp);
        MIDL_user_free((void  *)(_source->ReservedIp));
        }
      break;
      }
    case DhcpExcludedIpRanges :
      {
      if (_source->ExcludeIpRange !=0)
        {
        MIDL_user_free((void  *)(_source->ExcludeIpRange));
        }
      break;
      }
    case DhcpIpUsedClusters :
      {
      if (_source->IpUsedCluster !=0)
        {
        MIDL_user_free((void  *)(_source->IpUsedCluster));
        }
      break;
      }
    default :
      {
      break;
      }
    }
  }

/* routine that frees graph for struct _DHCP_SUBNET_ELEMENT_DATA */
void _fgs__DHCP_SUBNET_ELEMENT_DATA (DHCP_SUBNET_ELEMENT_DATA_V4  * _source)
  {
  _fgu__DHCP_SUBNET_ELEMENT_UNION ( (union _DHCP_SUBNET_ELEMENT_UNION_V4 *)&_source->Element, _source->ElementType);
  }
/* routine that frees graph for struct _DHCP_SUBNET_ELEMENT_INFO_ARRAY */
void _fgs__DHCP_SUBNET_ELEMENT_INFO_ARRAY (DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4  * _source)
  {
  if (_source->Elements !=0)
    {
      {
      unsigned long _sym23;
      for (_sym23 = 0; _sym23 < (unsigned long )(0 + _source->NumElements); _sym23++)
        {
        _fgs__DHCP_SUBNET_ELEMENT_DATA ((DHCP_SUBNET_ELEMENT_DATA_V4 *)&_source->Elements[_sym23]);
        }
      }
    MIDL_user_free((void  *)(_source->Elements));
    }
  }
/* routine that frees graph for union _DHCP_OPTION_ELEMENT_UNION */
void _fgu__DHCP_OPTION_ELEMENT_UNION (union _DHCP_OPTION_ELEMENT_UNION * _source, DHCP_OPTION_DATA_TYPE _branch)
  {
  switch (_branch)
    {
    case DhcpByteOption :
      {
      break;
      }
    case DhcpWordOption :
      {
      break;
      }
    case DhcpDWordOption :
      {
      break;
      }
    case DhcpDWordDWordOption :
      {
      break;
      }
    case DhcpIpAddressOption :
      {
      break;
      }
    case DhcpStringDataOption :
      {
      if (_source->StringDataOption !=0)
        {
        MIDL_user_free((void  *)(_source->StringDataOption));
        }
      break;
      }
    case DhcpBinaryDataOption :
      {
      _fgs__DHCP_BINARY_DATA ((DHCP_BINARY_DATA *)&_source->BinaryDataOption);
      break;
      }
    case DhcpEncapsulatedDataOption :
      {
      _fgs__DHCP_BINARY_DATA ((DHCP_BINARY_DATA *)&_source->EncapsulatedDataOption);
      break;
      }
    default :
      {
      break;
      }
    }
  }
/* routine that frees graph for struct _DHCP_OPTION_DATA_ELEMENT */
void _fgs__DHCP_OPTION_DATA_ELEMENT (DHCP_OPTION_DATA_ELEMENT  * _source)
  {
  _fgu__DHCP_OPTION_ELEMENT_UNION ( (union _DHCP_OPTION_ELEMENT_UNION *)&_source->Element, _source->OptionType);
  }
/* routine that frees graph for struct _DHCP_OPTION_DATA */
void _fgs__DHCP_OPTION_DATA (DHCP_OPTION_DATA  * _source)
  {
  if (_source->Elements !=0)
    {
      {
      unsigned long _sym31;
      for (_sym31 = 0; _sym31 < (unsigned long )(0 + _source->NumElements); _sym31++)
        {
        _fgs__DHCP_OPTION_DATA_ELEMENT ((DHCP_OPTION_DATA_ELEMENT *)&_source->Elements[_sym31]);
        }
      }
    MIDL_user_free((void  *)(_source->Elements));
    }
  }
/* routine that frees graph for struct _DHCP_OPTION */
void _fgs__DHCP_OPTION (DHCP_OPTION  * _source)
  {
  if (_source->OptionName !=0)
    {
    MIDL_user_free((void  *)(_source->OptionName));
    }
  if (_source->OptionComment !=0)
    {
    MIDL_user_free((void  *)(_source->OptionComment));
    }
  _fgs__DHCP_OPTION_DATA ((DHCP_OPTION_DATA *)&_source->DefaultValue);
  }
/* routine that frees graph for struct _DHCP_OPTION_VALUE */
void _fgs__DHCP_OPTION_VALUE (DHCP_OPTION_VALUE  * _source)
  {
  _fgs__DHCP_OPTION_DATA ((DHCP_OPTION_DATA *)&_source->Value);
  }
/* routine that frees graph for struct _DHCP_OPTION_VALUE_ARRAY */
void _fgs__DHCP_OPTION_VALUE_ARRAY (DHCP_OPTION_VALUE_ARRAY  * _source)
  {
  if (_source->Values !=0)
    {
      {
      unsigned long _sym34;
      for (_sym34 = 0; _sym34 < (unsigned long )(0 + _source->NumElements); _sym34++)
        {
        _fgs__DHCP_OPTION_VALUE ((DHCP_OPTION_VALUE *)&_source->Values[_sym34]);
        }
      }
    MIDL_user_free((void  *)(_source->Values));
    }
  }
/* routine that frees graph for struct _DHCP_OPTION_LIST */
void _fgs__DHCP_OPTION_LIST (DHCP_OPTION_LIST  * _source)
  {
  if (_source->Options !=0)
    {
      {
      unsigned long _sym37;
      for (_sym37 = 0; _sym37 < (unsigned long )(0 + _source->NumOptions); _sym37++)
        {
        _fgs__DHCP_OPTION_VALUE ((DHCP_OPTION_VALUE *)&_source->Options[_sym37]);
        }
      }
    MIDL_user_free((void  *)(_source->Options));
    }
  }
/* routine that frees graph for struct _DHCP_CLIENT_INFO */
void _fgs__DHCP_CLIENT_INFO (DHCP_CLIENT_INFO_V4  * _source)
  {
  _fgs__DHCP_BINARY_DATA ((DHCP_BINARY_DATA *)&_source->ClientHardwareAddress);
  if (_source->ClientName !=0)
    {
    MIDL_user_free((void  *)(_source->ClientName));
    }
  if (_source->ClientComment !=0)
    {
    MIDL_user_free((void  *)(_source->ClientComment));
    }
  _fgs__DHCP_HOST_INFO ((DHCP_HOST_INFO *)&_source->OwnerHost);
  }
/* routine that frees graph for struct _DHCP_CLIENT_INFO_ARRAY */
void _fgs__DHCP_CLIENT_INFO_ARRAY (DHCP_CLIENT_INFO_ARRAY_V4  * _source)
  {
  if (_source->Clients !=0)
    {
      {
      unsigned long _sym40;
      for (_sym40 = 0; _sym40 < (unsigned long )(0 + _source->NumElements); _sym40++)
        {
        if (_source->Clients[_sym40] !=0)
          {
          _fgs__DHCP_CLIENT_INFO ((DHCP_CLIENT_INFO_V4 *)_source->Clients[_sym40]);
          MIDL_user_free((void  *)(_source->Clients[_sym40]));
          }
        }
      }
    MIDL_user_free((void  *)(_source->Clients));
    }
  }
/* routine that frees graph for struct _DHCP_CLIENT_INFO_ARRAY_V5 */
void _fgs__DHCP_CLIENT_INFO_ARRAY_V5 (DHCP_CLIENT_INFO_ARRAY_V5  * _source)
  {
  if (_source->Clients !=0)
    {
      {
      unsigned long _sym40;
      for (_sym40 = 0; _sym40 < (unsigned long )(0 + _source->NumElements); _sym40++)
        {
        if (_source->Clients[_sym40] !=0)
          {
          _fgs__DHCP_CLIENT_INFO_V5 ((DHCP_CLIENT_INFO_V5 *)_source->Clients[_sym40]);
          MIDL_user_free((void  *)(_source->Clients[_sym40]));
          }
        }
      }
    MIDL_user_free((void  *)(_source->Clients));
    }
  }
/* routine that frees graph for struct _DHCP_CLIENT_INFO_V5 */
void _fgs__DHCP_CLIENT_INFO_V5 (DHCP_CLIENT_INFO_V5  * _source)
  {
  _fgs__DHCP_BINARY_DATA ((DHCP_BINARY_DATA *)&_source->ClientHardwareAddress);
  if (_source->ClientName !=0)
    {
    MIDL_user_free((void  *)(_source->ClientName));
    }
  if (_source->ClientComment !=0)
    {
    MIDL_user_free((void  *)(_source->ClientComment));
    }
  _fgs__DHCP_HOST_INFO ((DHCP_HOST_INFO *)&_source->OwnerHost);
  }

/* routine that frees graph for union _DHCP_CLIENT_SEARCH_UNION */
void _fgu__DHCP_CLIENT_SEARCH_UNION (union _DHCP_CLIENT_SEARCH_UNION * _source, DHCP_SEARCH_INFO_TYPE _branch)
  {
  switch (_branch)
    {
    case DhcpClientIpAddress :
      {
      break;
      }
    case DhcpClientHardwareAddress :
      {
      _fgs__DHCP_BINARY_DATA ((DHCP_BINARY_DATA *)&_source->ClientHardwareAddress);
      break;
      }
    case DhcpClientName :
      {
      if (_source->ClientName !=0)
        {
        MIDL_user_free((void  *)(_source->ClientName));
        }
      break;
      }
    default :
      {
      break;
      }
    }
  }
/* routine that frees graph for struct _DHCP_CLIENT_SEARCH_INFO */
void _fgs__DHCP_CLIENT_SEARCH_INFO (DHCP_SEARCH_INFO  * _source)
  {
  _fgu__DHCP_CLIENT_SEARCH_UNION ( (union _DHCP_CLIENT_SEARCH_UNION *)&_source->SearchInfo, _source->SearchType);
  }

void _fgs__DHCP_OPTION_ARRAY(DHCP_OPTION_ARRAY * _source )
  {
  if (_source->Options !=0)
    {
      {
      unsigned long _sym23;
      for (_sym23 = 0; _sym23 < (unsigned long )(0 + _source->NumElements); _sym23++)
        {
        _fgs__DHCP_OPTION ((DHCP_OPTION *)&_source->Options[_sym23]);
        }
      }
    MIDL_user_free((void  *)(_source->Options));
    }
  }


DHCP_SUBNET_ELEMENT_DATA_V4 *
CopySubnetElementDataToV4(
    DHCP_SUBNET_ELEMENT_DATA    *pInput
    )
/*++

Routine Description:
    Deep copy a DHCP_SUBNET_ELEMENT_DATA_V4 structure to a
    DHCP_SUBNET_ELEMENT_DATA structure, allocating memory as
    necessary.  Fields that exist in DHCP_SUBNET_ELEMENT_DATA_V4
    that don't exist in DHCP_SUBNET_ELEMENT_DATA are ignored.

    .
Arguments:

    pInput - pointer to a DHCP_SUBNET_ELEMENT_DATA_V4 structure.

Return Value:
    Success - pointer to a DHCP_SUBNET_ELEMENT_DATA structure.
    Failure - NULL

    .

--*/

{
    DHCP_SUBNET_ELEMENT_DATA_V4 *pOutput;
    DWORD                        dwResult;

    pOutput = MIDL_user_allocate( sizeof( *pOutput ) );
    if ( pOutput )
    {
        if (CopySubnetElementUnionToV4(
                            &pOutput->Element,
                            &pInput->Element,
                            pInput->ElementType
                            ))
        {
            pOutput->ElementType = pInput->ElementType;
        }
        else
        {
            MIDL_user_free( pOutput );
            pOutput = NULL;
        }
    }

    return pOutput;
}


BOOL
CopySubnetElementUnionToV4(
    DHCP_SUBNET_ELEMENT_UNION_V4 *pUnionV4,
    DHCP_SUBNET_ELEMENT_UNION    *pUnion,
    DHCP_SUBNET_ELEMENT_TYPE      Type
    )
/*++

Routine Description:
    Deep copy a DHCP_SUBNET_ELEMENT_UNION_V4 structure to a
    DHCP_SUBNET_ELEMENT_UNION structure, allocating memory as
    necessary.  Fields that exist in DHCP_SUBNET_ELEMENT_UNION_V4
    that don't exist in DHCP_SUBNET_ELEMENT_UNION are ignored.

    .
Arguments:

    pInput - pointer to a DHCP_SUBNET_ELEMENT_UNION_V4 structure.

Return Value:
    Success - pointer to a DHCP_SUBNET_ELEMENT_UNION structure.
    Failure - NULL

    .

--*/

{
    BOOL fResult = FALSE;

    switch ( Type )
    {
    case DhcpIpRanges:
    case DhcpIpRangesDhcpOnly:
    case DhcpIpRangesBootpOnly:
    case DhcpIpRangesDhcpBootp:
        pUnionV4->IpRange = CopyIpRange( pUnion->IpRange );
        fResult = ( pUnionV4->IpRange != NULL );
        break;

    case DhcpSecondaryHosts:
        pUnionV4->SecondaryHost = CopyHostInfo( pUnion->SecondaryHost, NULL );
        fResult = ( pUnionV4->SecondaryHost != NULL );
        break;

    case DhcpReservedIps:
        pUnionV4->ReservedIp = CopyIpReservationToV4( pUnion->ReservedIp );
        fResult = ( pUnionV4->ReservedIp != NULL );
        break;

    case DhcpExcludedIpRanges:
        pUnionV4->ExcludeIpRange = CopyIpRange( pUnion->ExcludeIpRange );
        fResult = ( pUnionV4->ExcludeIpRange != NULL );
        break;

    case DhcpIpUsedClusters:
        pUnionV4->IpUsedCluster = CopyIpCluster( pUnion->IpUsedCluster );
        fResult = ( pUnionV4->IpUsedCluster != NULL );
        break;

    }

    return fResult;
}

DHCP_IP_RANGE *
CopyIpRange(
    DHCP_IP_RANGE *IpRange
    )
/*++

Routine Description:
    Duplicate a DHCP_IP_RANGE structure.  The function allocates
    memory for the new structure.

    .
Arguments:

    IpRange - pointer to an DHCP_IP_RANGE structure.

Return Value:
    Success - pointer to a DHCP_IP_RANGE structure.
    Failure - NULL

    .

--*/

{
    DHCP_IP_RANGE *pOutputRange;

    if( NULL == IpRange ) return NULL;
    
    pOutputRange = MIDL_user_allocate( sizeof( *pOutputRange ) );

    if ( pOutputRange )
    {
        pOutputRange->StartAddress  = IpRange->StartAddress;
        pOutputRange->EndAddress    = IpRange->EndAddress;
    }

    return pOutputRange;
}


DHCP_HOST_INFO *
CopyHostInfo(
    DHCP_HOST_INFO *pHostInfo,
    DHCP_HOST_INFO *pHostInfoDest OPTIONAL
    )
/*++

Routine Description:
    Duplicate a DHCP_HOST_INFO structure.  The function allocates
    memory for the new structure unless a buffer is provided by the
    caller.

    .
Arguments:

    pHostInfo - pointer to an DHCP_HOST_INFO structure.
    pHostInfoDest - optional pointer to a DHCP_HOST_INFO struct


Return Value:
    Success - pointer to a DHCP_HOST_INFO structure.
    Failure - NULL

    .

--*/

{
    DHCP_HOST_INFO *pOutput;

    if ( !pHostInfoDest )
        pOutput = MIDL_user_allocate( sizeof( *pOutput ) );
    else
        pOutput = pHostInfoDest;

    if ( pOutput )
    {
        pOutput->IpAddress = pHostInfo->IpAddress;

        if ( pHostInfo->NetBiosName )
        {
            pOutput->NetBiosName =
                MIDL_user_allocate( WSTRSIZE( pHostInfo->NetBiosName ) );

            if ( !pOutput->NetBiosName )
            {
                goto t_cleanup;
            }

            wcscpy ( pOutput->NetBiosName,
                     pHostInfo->NetBiosName );
        }

        if ( pHostInfo->HostName )
        {
            pOutput->HostName =
                MIDL_user_allocate( WSTRSIZE( pHostInfo->HostName ) );

            if ( !pOutput->HostName )
            {
                goto t_cleanup;
            }

            wcscpy( pOutput->HostName,
                    pHostInfo->HostName
                  );
        }

        return pOutput;
    }
t_cleanup:

    if ( pOutput->HostName )
    {
        MIDL_user_free( pOutput->HostName );
    }

    if ( pOutput->NetBiosName )
    {
        MIDL_user_free( pOutput->NetBiosName );
    }

    if ( !pHostInfoDest )
        MIDL_user_free( pOutput );

    return NULL;
}

DHCP_IP_RESERVATION_V4 *
CopyIpReservationToV4(
    DHCP_IP_RESERVATION *pInput
    )
/*++

Routine Description:
    Deep copy a DHCP_IP_RESERVATION_V4 structure to a
    DHCP_IP_RESERVATION structure, allocating memory as
    necessary.  Fields that exist in DHCP_IP_RESERVATION_V4
    that don't exist in DHCP_IP_RESERVATION are ignored.

    .
Arguments:

    pInput - pointer to a DHCP_IP_RESERVATION_V4 structure.

Return Value:
    Success - pointer to a DHCP_IP_RESERVATION structure.
    Failure - NULL

    .

--*/
{
    DHCP_IP_RESERVATION_V4 *pOutput =
        MIDL_user_allocate( sizeof( *pOutput ) );

    if ( pOutput )
    {
        pOutput->ReservedIpAddress   = pInput->ReservedIpAddress;
        pOutput->ReservedForClient =
            CopyBinaryData( pInput->ReservedForClient, NULL );

        if ( !pOutput->ReservedForClient )
        {
            goto t_cleanup;
        }

        pOutput->bAllowedClientTypes = CLIENT_TYPE_DHCP;
    }

    return pOutput;

t_cleanup:

    if ( pOutput->ReservedForClient )
    {
        _fgs__DHCP_BINARY_DATA( pOutput->ReservedForClient );
    }

    return NULL;
}

DHCP_IP_CLUSTER *
CopyIpCluster(
    DHCP_IP_CLUSTER *pInput
    )
/*++

Routine Description:
    Duplicate a DHCP_IP_CLUSTER structure.  The function allocates
    memory for the new structure.

    .
Arguments:

    IpRange - pointer to an DHCP_IP_CLUSTER structure.

Return Value:
    Success - pointer to a DHCP_IP_CLUSTER structure.
    Failure - NULL

    .

--*/
{
    DHCP_IP_CLUSTER *pOutput =
        MIDL_user_allocate( sizeof( *pOutput ) );

    if ( pOutput )
    {
        pOutput->ClusterAddress = pInput->ClusterAddress;
        pOutput->ClusterMask    = pInput->ClusterMask;
    }
    return pOutput;
}

DHCP_BINARY_DATA *
CopyBinaryData(
    DHCP_BINARY_DATA *pInput,
    DHCP_BINARY_DATA *pOutputArg
    )
/*++

Routine Description:
    Duplicate a DHCP_BINARY_DATA structure.  The function allocates
    memory for the new structure unless a buffer is provided by the
    caller.

    .
Arguments:

    pHostInfo - pointer to an DHCP_BINARY_DATA structure.
    pHostInfoDest - optional pointer to a DHCP_BINARY_DATA struct


Return Value:
    Success - pointer to a DHCP_BINARY_DATA structure.
    Failure - NULL

    .

--*/

{
    DHCP_BINARY_DATA *pOutput;

    DhcpAssert( NULL != pInput );
    DhcpAssert( NULL != pInput->Data );

    // Check for valid Input
    if (( NULL == pInput ) ||
	( NULL == pInput->Data )) {
	return NULL;
    }

    if ( pOutputArg )
        pOutput = pOutputArg;
    else
        pOutput = MIDL_user_allocate( sizeof( *pOutput ) );
    if ( pOutput )
    {
        pOutput->DataLength = pInput->DataLength;

        pOutput->Data = MIDL_user_allocate( pOutput->DataLength );
        if ( !pOutput->Data )
        {
            goto t_cleanup;
        }
	
	if ( IsBadReadPtr( pInput->Data, pInput->DataLength )) {
	    goto t_cleanup;
	}

        RtlCopyMemory( pOutput->Data,
                       pInput->Data,
                       pInput->DataLength );
    }

    return pOutput;

t_cleanup:
    if ( pOutput->Data )
    {
        MIDL_user_free( pOutput->Data );
    }

    if ( !pOutputArg )
    {
        MIDL_user_free( pOutput );
    }


    return NULL;
}

WCHAR *
DupUnicodeString(
    WCHAR *pInput
    )
/*++

Routine Description:
    Duplicate a unicode string.  The function allocates
    memory for the new string.

    .
Arguments:

    IpRange - pointer to unicode string.

Return Value:
    Success - pointer to a copy of pInput.
    Failure - NULL

    .

--*/
{
    WCHAR *pOutput = MIDL_user_allocate( WSTRSIZE( pInput ) );
    if ( pOutput )
    {
        wcscpy( pOutput, pInput );
    }

    return pOutput;
}

DHCP_CLIENT_INFO_V4 *
CopyClientInfoToV4(
    DHCP_CLIENT_INFO *pInput
    )
/*++

Routine Description:
    Deep copy a DHCP_CLIENT_INFO_V4 structure to a
    DHCP_CLIENT_INFO structure, allocating memory as
    necessary.  Fields that exist in DHCP_CLIENT_INFO_V4
    that don't exist in DHCP_CLIENT_INFO are ignored.

    .
Arguments:

    pInput - pointer to a DHCP_CLIENT_INFO_V4 structure.

Return Value:
    Success - pointer to a DHCP_CLIENT_INFO structure.
    Failure - NULL

    .

--*/
{
    DHCP_CLIENT_INFO_V4 *pOutput =
        MIDL_user_allocate( sizeof( *pOutput ) );

    if ( pOutput )
    {

        pOutput->ClientIpAddress = pInput->ClientIpAddress;
        pOutput->SubnetMask      = pInput->SubnetMask;

        if ( !CopyBinaryData( &pInput->ClientHardwareAddress,
                              &pOutput->ClientHardwareAddress ))
            goto t_cleanup;

        if ( pInput->ClientName )
        {
            pOutput->ClientName = DupUnicodeString( pInput->ClientName );

            if ( !pOutput->ClientName )
                goto t_cleanup;
        }


        if ( pInput->ClientComment )
        {
            pOutput->ClientComment = DupUnicodeString( pInput->ClientComment );

            if ( !pOutput->ClientComment )
                goto t_cleanup;
        }

        pOutput->ClientLeaseExpires = pInput->ClientLeaseExpires;
        if ( !CopyHostInfo( &pInput->OwnerHost, &pOutput->OwnerHost ) )
        {
            goto t_cleanup;
        }

        pOutput -> OwnerHost.NetBiosName = NULL;
        pOutput -> OwnerHost.HostName = NULL;
    }

    return pOutput;

t_cleanup:
    _fgs__DHCP_BINARY_DATA( &pOutput->ClientHardwareAddress );

    if ( pOutput->ClientName )
    {
        MIDL_user_free( pOutput->ClientName );
    }

    if ( pOutput->ClientComment )
    {
        MIDL_user_free( pOutput->ClientComment );
    }

    _fgs__DHCP_HOST_INFO( &pOutput->OwnerHost );

    MIDL_user_free( pOutput );

    return NULL;
}

/* routine that frees graph for struct _DHCP_MCLIENT_INFO */
void _fgs__DHCP_MCLIENT_INFO (DHCP_MCLIENT_INFO  * _source)
  {
  _fgs__DHCP_BINARY_DATA ((DHCP_BINARY_DATA *)&_source->ClientId);
  if (_source->ClientName !=0)
    {
    MIDL_user_free((void  *)(_source->ClientName));
    }
  _fgs__DHCP_HOST_INFO ((DHCP_HOST_INFO *)&_source->OwnerHost);
  }

/* routine that frees graph for struct _DHCP_MCLIENT_INFO_ARRAY */
void _fgs__DHCP_MCLIENT_INFO_ARRAY (DHCP_MCLIENT_INFO_ARRAY  * _source)
  {
  if (_source->Clients !=0)
    {
      {
      unsigned long _sym40;
      for (_sym40 = 0; _sym40 < (unsigned long )(0 + _source->NumElements); _sym40++)
        {
        if (_source->Clients[_sym40] !=0)
          {
          _fgs__DHCP_MCLIENT_INFO ((DHCP_MCLIENT_INFO *)_source->Clients[_sym40]);
          MIDL_user_free((void  *)(_source->Clients[_sym40]));
          }
        }
      }
    MIDL_user_free((void  *)(_source->Clients));
    }
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\ping.h ===
//================================================================================
//  Copyright (C) Microsoft Corporation 1997
//  Date: July 27 1997
//  Author: RameshV
//  Description:  Handles the asynchronous pinging part
//================================================================================

//================================================================================
//  Functions EXPORTED
//================================================================================
DWORD                                    // Win32 errors
DoIcmpRequest(                           // send icmp req. and process asynchro..
    DHCP_IP_ADDRESS    DestAddr,         // Address to send ping to
    LPVOID             Context           // the parameter to above function..
);

DWORD                                    // Win32 errors
DoIcmpRequestEx(                         // send icmp req. and process asynchro..
    DHCP_IP_ADDRESS    DestAddr,         // Address to send ping to
    LPVOID             Context,          // the parameter to above function..
    LONG               nAttempts         // # of attempts to ping
);

DWORD                                    // Win32 errors
PingInit(                                // Initialize all globals..
    VOID
);

VOID
PingCleanup(                             // Free memory and close handles..
    VOID
);

//================================================================================
//  Some defines
//================================================================================
#define WAIT_TIME              1000     //  Wait for 1 seconds
#define RCV_BUF_SIZE           0x500    //  This big a buffer
#define SEND_MESSAGE           "DhcpIcmpChk"
#define THREAD_KILL_TIME       INFINITE //  No need to kill anything, it will work

#define MAX_PENDING_REQUESTS   200      //  Any more requests are handled synchro.
#define NUM_RETRIES            ((LONG)DhcpGlobalDetectConflictRetries)


//================================================================================
//  End of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\proto.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    proto.h

Abstract:

    This file contain function prototypes for the DHCP server service.

Author:

    Manny Weiser  (mannyw)  11-Aug-1992

Environment:

    User Mode - Win32 - MIDL

Revision History:

--*/
#ifndef PROTO_H_INCLUDED
#define PROTO_H_INCLUDED

//
//  util.c
//

VOID
DhcpServerEventLog(
    DWORD EventID,
    DWORD EventType,
    DWORD ErrorCode
    );

VOID
DhcpServerJetEventLog(
    DWORD EventID,
    DWORD EventType,
    DWORD ErrorCode,
    LPSTR CallerInfo
    );

VOID
DhcpServerEventLogSTOC(
    DWORD EventID,
    DWORD EventType,
    DHCP_IP_ADDRESS IPAddress,
    LPBYTE HardwareAddress,
    DWORD HardwareAddressLength
    );

DWORD
DisplayUserMessage(
    DWORD MessageId,
    ...
    );

BOOL
CreateDirectoryPathOem(
    IN LPCSTR OemPath,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

BOOL
CreateDirectoryPathW(
    IN LPWSTR Path,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

ULONG
GetUserAndDomainName(
    IN WCHAR Buf[]
    );

    
DWORD
RevertFromSecretUser(
    IN VOID
    );

DWORD
ImpersonateSecretUser(
    VOID
    );

BOOL
IsRunningOnDc(
    VOID
    );

DWORD
DhcpBeginWriteApi(
    IN LPSTR ApiName
    );

DWORD
DhcpEndWriteApi(
    IN LPSTR ApiName,
    IN ULONG Error
    );

DWORD
DhcpEndWriteApiEx(
    IN LPSTR ApiName,
    IN ULONG Error,
    IN BOOL fClassChanged,
    IN BOOL fOptionsChanged,
    IN DHCP_IP_ADDRESS Subnet OPTIONAL,
    IN DWORD Mscope OPTIONAL,
    IN DHCP_IP_ADDRESS Reservation OPTIONAL
    );

DWORD
DhcpBeginReadApi(
    IN LPSTR ApiName
    );

VOID
DhcpEndReadApi(
    IN LPSTR ApiName,
    IN ULONG Error
    );


DWORD
DynamicDnsInit(
    VOID
);

//
// cltapi.c
//

DWORD
DhcpCreateClientEntry(
    DHCP_IP_ADDRESS ClientIpAddress,
    LPBYTE ClientHardwareAddress OPTIONAL,
    DWORD HardwareAddressLength,
    DATE_TIME LeaseDuration,
    LPWSTR MachineName OPTIONAL,
    LPWSTR ClientInformation OPTIONAL,
    BYTE   bClientType,
    DHCP_IP_ADDRESS ServerIpAddress,
    BYTE AddressState,
    BOOL OpenExisting
);

DWORD
DhcpGetBootpReservationInfo(
    BYTE            *pbAllowedClientType,
    CHAR            *szBootFileServer,
    CHAR            *szBootFileName
);

DWORD
DhcpRemoveClientEntry(
    DHCP_IP_ADDRESS ClientIpAddress,
    LPBYTE HardwareAddress,
    DWORD HardwareAddressLength,
    BOOL ReleaseAddress,
    BOOL DeletePendingRecord
    );

BOOL
DhcpIsClientValid(
    IN      DHCP_IP_ADDRESS        Address,
    IN      LPBYTE                 RawHwAddress,
    IN      DWORD                  RawHwAddressLength,
    OUT     BOOL                  *fReconciled
);

BOOL
DhcpValidateClient(
    DHCP_IP_ADDRESS ClientIpAddress,
    PVOID HardwareAddress,
    DWORD HardwareAddressLength
);

DWORD
DhcpDeleteSubnetClients(
    DHCP_IP_ADDRESS SubnetAddress
);

//
// stoc.c
//

DWORD
DhcpInitializeClientToServer(
    VOID
);

VOID
DhcpCleanupClientToServer(
    VOID
    );


DWORD
ProcessMessage(
    LPDHCP_REQUEST_CONTEXT RequestContext,
    LPPACKET               AdditionalContext,
    LPDWORD                AdditionalStatus
);

DWORD
ProcessMadcapMessage(
    LPDHCP_REQUEST_CONTEXT RequestContext,
    LPPACKET               AdditionalContext,
    LPDWORD                AdditionalStatus
);


DWORD
DhcpMakeClientUID(
    LPBYTE ClientHardwareAddress,
    DWORD  ClientHardwareAddressLength,
    BYTE ClientHardwareAddressType,
    DHCP_IP_ADDRESS ClientSubnetAddress,
    LPBYTE *ClientUID,
    DWORD  *ClientUIDLength
);

//
// network.c
//

DWORD
InitializeSocket(
    OUT     SOCKET                *Sockp,
    IN      DWORD                  IpAddress,
    IN      DWORD                  Port,
    IN      DWORD                  McastAddress  OPTIONAL
);

DWORD
DhcpWaitForMessage(
    DHCP_REQUEST_CONTEXT *pRequestContext
);

DWORD
DhcpSendMessage(
    LPDHCP_REQUEST_CONTEXT DhcpRequestContext
);

DWORD
MadcapSendMessage(
    LPDHCP_REQUEST_CONTEXT DhcpRequestContext
);

DWORD
GetAddressToInstanceTable(
    VOID
);

DHCP_IP_ADDRESS
DhcpResolveName(
    CHAR *szHostName
);


//
// subntapi.c
//

// only RPC calls?

//
// optapi.c
//

DWORD
DhcpLookupBootpInfo(
    LPBYTE ReceivedBootFileName,
    LPBYTE BootFileName,
    LPBYTE BootFileServer
);

VOID
DhcpGetBootpInfo(
    IN LPDHCP_REQUEST_CONTEXT Ctxt,
    IN DHCP_IP_ADDRESS IpAddress,
    IN DHCP_IP_ADDRESS Mask,
    IN CHAR *szRequest,
    OUT CHAR *szBootFileName,
    OUT DHCP_IP_ADDRESS *pBootpServerAddress
    );


DWORD
LoadBootFileTable(
    WCHAR **ppszTable,
    DWORD *pcb
);

DWORD
DhcpParseBootFileString(
    WCHAR *wszBootFileString,
    char  *szGenericName,
    char  *szBootFileName,
    char  *szServerName
);


//
// database.c
//

DWORD
DhcpLoadDatabaseDll(
    VOID
);

DWORD
DhcpMapJetError(
    JET_ERR JetError,
    LPSTR CallerInfo OPTIONAL
);

DWORD
DhcpJetOpenKey(
    char *ColumnName,
    PVOID Key,
    DWORD KeySize
);

DWORD
DhcpJetBeginTransaction(
    VOID
);

DWORD
DhcpJetRollBack(
    VOID
);

DWORD
DhcpJetCommitTransaction(
    VOID
);

DWORD
DhcpJetPrepareUpdate(
    char *ColumnName,
    PVOID Key,
    DWORD KeySize,
    BOOL NewRecord
);

DWORD
DhcpJetCommitUpdate(
    VOID
);

DWORD
DhcpJetSetValue(
    JET_COLUMNID KeyColumnId,
    PVOID Data,
    DWORD DataSize
);

DWORD
DhcpJetGetValue(
    JET_COLUMNID ColumnId,
    PVOID Data,
    PDWORD DataSize
);

DWORD
DhcpJetPrepareSearch(
    char *ColumnName,
    BOOL SearchFromStart,
    PVOID Key,
    DWORD KeySize
);

DWORD
DhcpJetNextRecord(
    VOID
);

DWORD
DhcpJetDeleteCurrentRecord(
    VOID
);

BOOL
DhcpGetIpAddressFromHwAddress(
    PBYTE HardwareAddress,
    BYTE HardwareAddressLength,
    LPDHCP_IP_ADDRESS IpAddress
);

DWORD
DhcpSearchSuperScopeForHWAddress(
    BYTE *pbHardwareAddress,
    BYTE  cbHardwareAddress,
    BYTE  bHardwareAddressType,
    DHCP_IP_ADDRESS *pSubnetIPAddress,
    DHCP_IP_ADDRESS *pClientIPAddress
);


BOOL
DhcpGetHwAddressFromIpAddress(
    DHCP_IP_ADDRESS IpAddress,
    PBYTE HardwareAddress,
    DWORD HardwareAddressLength
);

DWORD
DhcpCreateAndInitDatabase(
    CHAR *Connect,
    JET_DBID *DatabaseHandle,
    JET_GRBIT JetBits
);

DWORD
DhcpInitializeDatabase(
    VOID
);

VOID
DhcpCleanupDatabase(
    DWORD ErrorCode
);

DWORD
DhcpBackupDatabase(
    LPSTR BackupPath,
    BOOL FullBackup
);

DWORD
DhcpRestoreDatabase(
    LPSTR BackupPath
);

DWORD
DhcpStartJet500Conversion(
    VOID
);

DWORD
DhcpStartJet97Conversion(
    VOID
);

DWORD
DhcpAuditLogInit(                                 // intialize audit log
    VOID                                          // must be called after initializing registry..
);

VOID
DhcpAuditLogCleanup(                              // undo the effects of the init..
    VOID
);

DWORD
DhcpUpdateAuditLog(
    DWORD Task,
    WCHAR *TaskName,
    DHCP_IP_ADDRESS IpAddress,
    LPBYTE HardwareAddress,
    DWORD HardwareAddressLength,
    LPWSTR MachineName
);

DWORD
DhcpUpdateAuditLogEx(
    DWORD Task,
    WCHAR *TaskName,
    DHCP_IP_ADDRESS IpAddress,
    LPBYTE HardwareAddress,
    DWORD HardwareAddressLength,
    LPWSTR MachineName,
    ULONG ErrorCode OPTIONAL
);

DWORD
AuditLogSetParams(                                // set some auditlogging params
    IN      DWORD                  Flags,         // currently must be zero
    IN      LPWSTR                 AuditLogDir,   // directory to log files in..
    IN      DWORD                  DiskCheckInterval, // how often to check disk space?
    IN      DWORD                  MaxLogFilesSize,   // how big can all logs files be..
    IN      DWORD                  MinSpaceOnDisk     // mininum amt of free disk space
);

DWORD
AuditLogGetParams(                                // get the auditlogging params
    IN      DWORD                  Flags,         // must be zero
    OUT     LPWSTR                *AuditLogDir,   // same meaning as in AuditLogSetParams
    OUT     DWORD                 *DiskCheckInterval, // ditto
    OUT     DWORD                 *MaxLogFilesSize,   // ditto
    OUT     DWORD                 *MinSpaceOnDisk     // ditto
);

VOID
DhcpChangeAuditLogs(                              // shift for new log
    VOID
);

//
// scavenger.c
//

DWORD
Scavenger(
    VOID
);

DWORD
CleanupClientRequests(
    DATE_TIME *TimeNow,
    BOOL CleanupAll
);


//
// main.c
//

DWORD
UpdateStatus(
    VOID
);

//
// rogue.c
//

VOID
DhcpScheduleRogueAuthCheck(
    VOID
);

BOOLEAN
DhcpRogueAcceptEnterprise(
    PCHAR   pClientDomain,
    DWORD   dwClientDomLen
);


VOID
DhcpRogueDetect(
    VOID
);


DWORD
DhcpRogueSockInit(
    VOID
);


DWORD
DhcpRogueWithDS(
    VOID
);


DWORD
DhcpRogueGetNeighborInfo(
    OUT PCHAR    *pInfo,
    OUT DWORD    *pNumResponses,
    OUT BOOLEAN  *pfSomeDSExists
);


DWORD
DhcpRogueSendDhcpInform(
    DWORD   *pXid
);


DWORD
DhcpRogueRecvDhcpInformResp(
    OUT PCHAR    pszDomainName,
    OUT DWORD   *pIpAddress,
    OUT BOOLEAN *fGotResponse,
    IN  DWORD    Xid
);

DWORD
DhcpRogueReceiveResponse(
    struct sockaddr *pSockAddr,
    DWORD           TimeOut,
    CHAR            *rcvBuf,
    DWORD           *pdwMsgLen,
    BOOL            *pfSelectTimedOut
);


DWORD
DhcpRogueOnSAM(
    VOID
    );

DWORD
DhcpRogueSendDiscover(
    VOID
);


DWORD
DhcpRogueListenForOffers(
    IN DWORD  TimeOut
);


BOOL
AmIRunningOnSAMSrv(
    VOID
);
//
// binl.c
//

BOOL
BinlRunning(
    VOID
    );

VOID
InformBinl(
    int NewState
    );

VOID
BinlProcessDiscover(
    LPDHCP_REQUEST_CONTEXT  RequestContext,
    LPDHCP_SERVER_OPTIONS   DhcpOptions
    );

LPOPTION
BinlProcessRequest(
    LPDHCP_REQUEST_CONTEXT  RequestContext,
    LPDHCP_SERVER_OPTIONS   DhcpOptions,
    LPOPTION Option,
    PBYTE OptionEnd
    );

BOOL
CheckForBinlOnlyRequest(
    LPDHCP_REQUEST_CONTEXT  RequestContext,
    LPDHCP_SERVER_OPTIONS   DhcpOptions
    );

//
// stuff for .mc messages
// you may have to change hese definitions if you add messages
//

#ifdef DBG
WCHAR * GetString( DWORD dwID );
#endif

// Get the real broadcast address to use instead of 255.255.255.255.
DHCP_IP_ADDRESS
DhcpRegGetBcastAddress(
    VOID
);

//
// dnsdb.c
//

// here are some functions that do work for Dynamic Dns stuff.

// The following function is called after JetBeginTransaction() by DhcpMakeclientEntry()
VOID
DhcpDoDynDnsCreateEntryWork(
    LPDHCP_IP_ADDRESS   ClientIpAddress,  // Ip address of new client
    BYTE                ClientType,       // The type of the client
    LPWSTR              MachineName,      // Name of the machine.
    LPBYTE              AddressState,     // The required address state
    LPBOOL              OpenExisiting,    // expected existence of record
    BOOL                BadAddress        // Is this a bad address?
);

// This function is called by DhcpRemoveClientEntry for Reservation case alone
VOID
DhcpDoDynDnsReservationWork(
    DHCP_IP_ADDRESS     ClientIpAddress,  // The ip address of the dying client
    LPWSTR              ClientName,       // The name of the client
    BYTE                State             // The state of the client in DB.
);

// This function is called in the scavenger and the main file cltapi.c (delete x..)
BOOL
DhcpDoDynDnsCheckDelete(
    DHCP_IP_ADDRESS IpAddress
);


VOID
DhcpDoDynDnsRefresh(
    DHCP_IP_ADDRESS IpAddress
);

VOID
DhcpCleanupDnsMemory(
    VOID
);

VOID
DhcpInitDnsMemory(
    VOID
);

VOID
DhcpDnsHandleCallbacks(
    VOID
    );

//
// thread.c -- see thread.h
//

//
// ping.c -- see ping.h
//

//
// dhcpreg.c
//

BOOL
QuickBound(
    DHCP_IP_ADDRESS ipAddress,
    DHCP_IP_ADDRESS *subnetMask,
    DHCP_IP_ADDRESS *subnetAddress,
    BOOL *fBind
);

DWORD
DhcpGetBindingList(
    LPWSTR  *bindingList
);

DWORD
DhcpOpenAdapterConfigKey(
    LPWSTR  AdapterStr,
    HKEY *AdapterKeyHandle
);

BOOL
IsAdapterStaticIP(
    HKEY AdapterKeyHandle
);

#if 0
BOOL
IsAdapterBoundToDHCPServer(
    HKEY AdapterKeyHandle
);

DWORD
SetBindingToDHCPServer(
    HKEY Key,
    BOOL fBind
);
#endif

DWORD
DhcpGetAdapterIPAddr(
    HKEY AdapterKeyHandle,
    DHCP_IP_ADDRESS *IpAddress,
    DHCP_IP_ADDRESS *SubnetMask,
    DHCP_IP_ADDRESS *SubnetAddress
);

DWORD
DhcpGetAdapterIPAddrQuickBind(
    HKEY             AdapterKeyHandle,
    DHCP_IP_ADDRESS *IpAddress,
    DHCP_IP_ADDRESS *SubnetMask,
    DHCP_IP_ADDRESS *SubnetAddress
);

BOOL
DhcpCheckIfDatabaseUpgraded(
    BOOL fRegUpgrade
    );

DWORD
DhcpSetRegistryUpgradedToDatabaseStatus(
    VOID
    );


//
// mm interface (in memory strucutures)
//

#include    <mmapi.h>

#if DBG
VOID
EnterCriticalSectionX(
    IN      LPCRITICAL_SECTION     CS,
    IN      DWORD                  LineNo,
    IN      LPSTR                  FileName
);

VOID
LeaveCriticalSectionX(
    IN      LPCRITICAL_SECTION     CS,
    IN      DWORD                  LineNo,
    IN      LPSTR                  FileName
);
#endif

//
// secretk.h
//

DWORD
DhcpInitSecrets(
    VOID
);

VOID
DhcpCleanupSecrets(
    VOID
);


BOOL
DhcpGetAuthStatus(
    IN LPWSTR DomainName,
    OUT BOOL *fUpgraded,
    OUT BOOL *fAuthorized
);

DWORD
DhcpSetAuthStatus(
    IN LPWSTR DomainName OPTIONAL,
    IN BOOL fUpgraded,
    IN BOOL fAuthorized
);

VOID
DhcpSetAuthStatusUpgradedFlag(
    IN BOOL fUpgraded
);


DWORD
DhcpQuerySecretUname(
    IN OUT LPWSTR Uname,
    IN ULONG UnameSize,  // size in BYTES not WCHARS
    IN OUT LPWSTR Domain,
    IN ULONG DomainSize, // size in BYTES
    IN OUT LPWSTR Passwd,
    IN ULONG PasswdSize  // size in BYTES
    );

DWORD
DhcpSetSecretUnamePasswd(
    IN LPWSTR Uname,
    IN LPWSTR Domain,
    IN LPWSTR Passwd
    );

//
// Rogue.C
//

DWORD
APIENTRY
DhcpRogueInit(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info OPTIONAL,
    IN      HANDLE                 WaitEvent,
    IN      HANDLE                 TerminateEvent
);

VOID
APIENTRY
DhcpRogueCleanup(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info OPTIONAL
);

ULONG
APIENTRY
RogueDetectStateMachine(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info OPTIONAL
);

VOID
DhcpScheduleRogueAuthCheck(
    VOID
);

ULONG
DhcpInitGlobalData (
    BOOLEAN ServiceStartup
);

VOID
DhcpCleanUpGlobalData (
    ULONG   Error,
    BOOLEAN ServiceEnd
);

//
// Perf.c
//

ULONG
PerfInit(
    VOID
);

VOID
PerfCleanup(
    VOID
);

//
// mib.c
//

BOOL
IsStringTroublesome(
    IN LPCWSTR Str
    );

//
// scan.c
//
DWORD
CreateClientDBEntry(
    DHCP_IP_ADDRESS ClientIpAddress,
    DHCP_IP_ADDRESS SubnetMask,
    LPBYTE ClientHardwareAddress,
    DWORD HardwareAddressLength,
    DATE_TIME LeaseTerminates,
    LPWSTR MachineName,
    LPWSTR ClientInformation,
    DHCP_IP_ADDRESS ServerIpAddress,
    BYTE AddressState,
    BYTE ClientType
    );

//--------------------------------------------------------------------------------
// End of file
//--------------------------------------------------------------------------------
#endif PROTO_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\ping.c ===
//================================================================================
//  Microsoft Confidential
//  Copyright (C) Microsoft Corporation 1997
//
//  Author: RameshV
//================================================================================

//================================================================================
//  Required headers
//================================================================================
#include <dhcppch.h>
#include <ping.h>
#include <thread.h>

#include <ipexport.h>
#include <icmpif.h>
#include <icmpapi.h>

//================================================================================
//  Data structures  NOT EXPORTED
//================================================================================

//  The follwing is the structure that is passed back to the callback function
typedef struct st_apcContext {          // struct passed to APC routine
    LIST_ENTRY       IcmpRepliesList;   // the chain of replies got is stored here
    LIST_ENTRY       IcmpRequestsList;  // The list that holds the icmp response
    PICMP_ECHO_REPLY Reply;             // Icmp reply packet
    DWORD            ReplySize;         // The size of above buffer.
    IPAddr           DestinationAddress;// Who are we try to ping?
    LONG             Status;            // Did we succeed? Also retry count.
    LPVOID           Context;           // Dont know what this is goint to be
} APC_CONTEXT, *PAPC_CONTEXT;

// All file-scope globals are here.
LIST_ENTRY               IcmpRepliesList;      // Here is where the IcmpReplies are spooled
LIST_ENTRY               IcmpRequestsList;     // Here is where the
CRITICAL_SECTION         IcmpRepliesCritSect;  // To access the replies list
CRITICAL_SECTION         IcmpRequestsCritSect; // To access the requests list
HANDLE                   IcmpRepliesEvent;     // Signaled each time a reply is received
HANDLE                   IcmpRequestsEvent;    // Singaled whenever a request is received

HANDLE                   TerminateEvent;       // Quit everything being done.
CRITICAL_SECTION         OutputCritSect;       // To co-ordinate access to console output

HANDLE                   RequestsThreadHandle; // The handle of the thread that takes requests
HANDLE                   RepliesThreadHandle;  // The handle of the thread that takes replies

HANDLE                   IcmpHandle;           // Handle to do IcmpSendEcho2 etc.

BOOL                     Terminating = FALSE;  // Are we terminating?
DWORD                    nPendingRequests = 0; // # of pending ICMP requests..

#define LOCK_REPLIES_LIST()    EnterCriticalSection(&IcmpRepliesCritSect)
#define LOCK_REQUESTS_LIST()   EnterCriticalSection(&IcmpRequestsCritSect)
#define LOCK_OUTPUT()          EnterCriticalSection(&OutputCritSect)

#define UNLOCK_REPLIES_LIST()  LeaveCriticalSection(&IcmpRepliesCritSect)
#define UNLOCK_REQUESTS_LIST() LeaveCriticalSection(&IcmpRequestsCritSect)
#define UNLOCK_OUTPUT()        LeaveCriticalSection(&OutputCritSect)

//================================================================================
//  Routines
//================================================================================

//--------------------------------------------------------------------------------
//  The following functions are on the replies side.  They handle the icmp reply
//  packet and take the necessary action depending on the status, etc.
//--------------------------------------------------------------------------------

VOID NTAPI
ApcRoutine(                             //  This is called when ping completes
    IN PVOID            Context,        //  The above structure
    IN PIO_STATUS_BLOCK Ignored1,       //  Unused param
    IN ULONG            Ignored2        //  Unused param
) {
    BOOL   Status;
    PAPC_CONTEXT ApcContext = (PAPC_CONTEXT)Context;

    LOCK_REPLIES_LIST();                //  Add this to replies list
    InsertTailList(&IcmpRepliesList, &ApcContext->IcmpRepliesList);
    UNLOCK_REPLIES_LIST();
    nPendingRequests --;

    if( CFLAG_USE_PING_REPLY_THREAD ) { // if using a separate thread, notify!
        Status = SetEvent(IcmpRepliesEvent);
        DhcpAssert( FALSE != Status );
    }
}

BOOL
DestReachable(                          //  Is destination reachable?
    IN PAPC_CONTEXT      ApcContext     //  this has the info of sender etc..
) {
    DWORD nReplies, i;

    nReplies = IcmpParseReplies(
        ApcContext->Reply,
        ApcContext->ReplySize
    );

    if( 0 == nReplies ) {               //  No reply, so dest unreachable
        // If there was no reply, there is no way for us to reach this
        // So, we assume that the Dest is NOT reachable.
        // Reasons could be IP_REQ_TIMED_OUT or IP_BAD_DESTINATION etc..
        return FALSE;
    }

    // Now we check each reply to see if there is anything from the same dest
    // address we are looking for. And if the status is success. If the status
    // is not success, we actually do not check anything there. Potentially, it
    // could be IP_DEST_PORT_UNREACHABLE, in which case, the dest machine is up,
    // but for some reason we tried the wrong port..

    for( i = 0; i < nReplies; i ++ ) {
        if( ApcContext->DestinationAddress == ApcContext->Reply[i].Address ) {
            // hit the destination!

            DhcpAssert( IP_SUCCESS == ApcContext->Reply[i].Status );
            return TRUE;
        }

        DhcpAssert( IP_SUCCESS != ApcContext->Reply[i].Status);
    }

    return FALSE;
}

VOID
HandleRepliesEvent(                     //  Process all replies received
    VOID
) {
    PAPC_CONTEXT   ApcContext;
    PLIST_ENTRY    listEntry;
    BOOL           Status;

    LOCK_REPLIES_LIST();                //  Pickup replies and process them
    while( !IsListEmpty( &IcmpRepliesList ) ) {

        ApcContext = CONTAINING_RECORD(IcmpRepliesList.Flink, APC_CONTEXT, IcmpRepliesList);
        RemoveEntryList(&ApcContext->IcmpRepliesList);

        UNLOCK_REPLIES_LIST();

        Status = DestReachable(ApcContext);

        if( Status || NUM_RETRIES <= ApcContext->Status ) {
            HandleIcmpResult(
                ApcContext->DestinationAddress,
                Status,
                ApcContext->Context
            );

            DhcpFreeMemory(ApcContext);
        } else {                        //  Dest unreachable, but retry

            LOCK_REQUESTS_LIST();       //  Put it on the request list and notify
            InsertTailList(&IcmpRequestsList, &ApcContext->IcmpRequestsList);
            UNLOCK_REQUESTS_LIST();

            Status = SetEvent(IcmpRequestsEvent);
            DhcpAssert( TRUE == Status );
        }

        LOCK_REPLIES_LIST();
    }
    UNLOCK_REPLIES_LIST();
}


//  This routine sleeps on a loop, and is woken up by the call back function when an ICMP
//  reply comes through.  On waking up, this routine processes ALL ICMP replies.
DWORD                                   //  THREAD ENTRY
LoopOnIcmpReplies(                      //  Loop on all the ICMP replies.
    LPVOID      Unused
) {
    DWORD  Status;
    HANDLE WaitHandles[2];

    WaitHandles[0] = TerminateEvent;    //  Wait for global terminate event
    WaitHandles[1] = IcmpRepliesEvent;  //  Or for ICMP replies to be queued

    while( TRUE ) {
        Status = WaitForMultipleObjects(
            sizeof(WaitHandles)/sizeof(WaitHandles[0]),
            WaitHandles,
            FALSE,
            INFINITE
        );


        if( WAIT_OBJECT_0 == Status )   //  Termination
            break;

        if( 1+WAIT_OBJECT_0 == Status ) {
            HandleRepliesEvent();       //  Some ICMP reply got queued, process this q
            continue;
        }

        DhcpPrint((DEBUG_ERRORS, "WaitForMult: %ld\n", Status));
        DhcpAssert( FALSE );            //  Should not happen
    }

    return ERROR_SUCCESS;
}

#define AlignSizeof(X)     ROUND_UP_COUNT(sizeof(X),ALIGN_WORST)

//================================================================================
//  Note that this is async only when the # of pending reqs is < MAX_PENDING_REQUESTS
//  Beyond that it just blocks for some request to be satisfied before queueing this
//  one
//================================================================================
DWORD                                   //  Win32 errors
DoIcmpRequestEx(                        //  Try to send an ICMP request (ASYNC)
    IPAddr        DestAddr,             //  The address to try to ping
    LPVOID        Context,              //  The parameter to HandleIcmpResult
    LONG          InitCount             //  Initial count (negative ==> # of attempts)
)
{
    PAPC_CONTEXT  pCtxt;
    LPBYTE        startAddress;
    DWORD         Status;
    BOOL          BoolStatus;

    pCtxt = DhcpAllocateMemory(AlignSizeof(APC_CONTEXT) + RCV_BUF_SIZE);
    startAddress = (LPBYTE)pCtxt;
    if( NULL == pCtxt )                 //  If could not allocate context?
        return ERROR_NOT_ENOUGH_MEMORY;

    // Now fill the context with all that we know.
    pCtxt->Reply = (PICMP_ECHO_REPLY)(startAddress + AlignSizeof(APC_CONTEXT));
    pCtxt->ReplySize = RCV_BUF_SIZE;
    pCtxt->DestinationAddress = DestAddr;
    pCtxt->Status = (InitCount? ( NUM_RETRIES - InitCount ) : 0 );
    pCtxt->Context = Context;

    LOCK_REQUESTS_LIST();
    InsertTailList(&IcmpRequestsList, &pCtxt->IcmpRequestsList);
    UNLOCK_REQUESTS_LIST();

    // Signal the Requests loop.
    BoolStatus = SetEvent(IcmpRequestsEvent);
    DhcpAssert( TRUE == BoolStatus );

    return ERROR_SUCCESS;
}

DWORD                                   //  Win32 errors
DoIcmpRequest(                          //  Try to send an ICMP request (ASYNC)
    IPAddr        DestAddr,             //  The address to try to ping
    LPVOID        Context               //  The parameter to HandleIcmpResult
)
{
    return DoIcmpRequestEx(DestAddr, Context, 0);
}

//--------------------------------------------------------------------------------
//  The following functions handle the the end that sends ICMP echoes.
//--------------------------------------------------------------------------------
VOID
HandleRequestsEvent(                    //   Process every request for ICMP echo.
    VOID
) {
    PAPC_CONTEXT   ApcContext;
    PLIST_ENTRY    listEntry;
    DWORD          Status;


    LOCK_REQUESTS_LIST();

    while( !IsListEmpty( &IcmpRequestsList ) ) {
        // retrive the first element in the list
        ApcContext = CONTAINING_RECORD(IcmpRequestsList.Flink, APC_CONTEXT, IcmpRequestsList);
        RemoveEntryList(&ApcContext->IcmpRequestsList);
        UNLOCK_REQUESTS_LIST();

        if( nPendingRequests >= MAX_PENDING_REQUESTS ) {
            //
            // Need to sleep for more than WAIT_TIME as IcmpSendEcho2 is
            // not accurate so far as timing is concerned..
            //
            SleepEx( WAIT_TIME + (WAIT_TIME/2), TRUE );
            DhcpAssert(nPendingRequests < MAX_PENDING_REQUESTS );
        }

        nPendingRequests ++;
        // Send an Icmp echo and return immediately..
        ApcContext->Status ++;
        Status = IcmpSendEcho2(
            IcmpHandle,                 // The handle to register APC and send echo
            NULL,                       // No event
            ApcRoutine,                 // The call back routine
            (LPVOID)ApcContext,         // The first parameter to the callback routine
            ApcContext->DestinationAddress, // The address being PING'ed
            SEND_MESSAGE,
            (WORD)strlen(SEND_MESSAGE),
            NULL,
            (LPVOID)ApcContext->Reply,
            ApcContext->ReplySize,
            WAIT_TIME
        );

        if( FALSE == Status ) Status = GetLastError();
        else {
            DhcpAssert(FALSE);          //  We can not get anything else!
            Status = ERROR_SUCCESS;
        }

        // Since we queued an APC, we expect an STATUS_PENDING.
        if( ERROR_SUCCESS != Status && ERROR_IO_PENDING != Status ) {
            // Got something that is incorrect.  Free ApcContext?
            // Maybe call ApcRoutine on this?
            DhcpPrint((DEBUG_ERRORS, "IcmpSendEcho2:GetLastError: %ld\n", Status));
            DhcpAssert(FALSE);
            nPendingRequests --;        //  Lets do our best to continue..
            DhcpFreeMemory(ApcContext); //  No point wasting this memory..
        }
        LOCK_REQUESTS_LIST();
    }
    UNLOCK_REQUESTS_LIST();
}


// This function handles the Requests.. For each one, it just sends an IcmpEcho
// asynchronously and returns back immediately.  When the APC routine is called,
// it would queue it up on the Replies list and then it would get processed...
DWORD                                   //  THREAD ENTRY
LoopOnIcmpRequests(                     //  Process pending requests for echo
    LPVOID           Unused
) {
    DWORD  Status;
    HANDLE WaitHandles[2];

    WaitHandles[0] = TerminateEvent;    //  Quit only when terminate is signalled
    WaitHandles[1] = IcmpRequestsEvent; //  Otherwise just wait til some request

    while( TRUE ) {
        Status = WaitForMultipleObjectsEx(
            sizeof(WaitHandles)/sizeof(WaitHandles[0]),
            WaitHandles,                //  array of handles
            FALSE,                      //  any one of them set
            INFINITE,                   //  wait forever
            TRUE                        //  allow APC's
        );

        if( WAIT_OBJECT_0 == Status )   //  Asked to terminate
            break;
        if( WAIT_IO_COMPLETION == Status) {
            if( ! CFLAG_USE_PING_REPLY_THREAD ) {
                HandleRepliesEvent();   //  APC -- some ICMP reply got queued, process the Q
            }
            continue;
        }
        if( 1+WAIT_OBJECT_0 == Status ) {
            HandleRequestsEvent();      //  Satisfy all pending requests for echo
            if( ! CFLAG_USE_PING_REPLY_THREAD ) {
                HandleRepliesEvent();   //  APC could have occurred in above call.
            }
            continue;
        }

        DhcpPrint((DEBUG_ERRORS, "WaitForM (IcmpReq) : %ld\n", Status));
        DhcpAssert(FALSE);              //  Unexpected error
    }

    return ERROR_SUCCESS;
}

//--------------------------------------------------------------------------------
//  Initialization, Cleanup routines.
//--------------------------------------------------------------------------------
DWORD PingInitLevel = 0;
DWORD // exported
PingInit(
    VOID
)
{
    DWORD ThreadId, Status;

    // Initialize all data vars.
    IcmpRepliesEvent = IcmpRequestsEvent = TerminateEvent = NULL;
    RepliesThreadHandle = RequestsThreadHandle = NULL;
    IcmpHandle = NULL;


    // Initialize Lists.
    InitializeListHead(&IcmpRepliesList);
    InitializeListHead(&IcmpRequestsList);

    // Initialize Critical Sections.
    try {
        InitializeCriticalSection(&IcmpRepliesCritSect);
        InitializeCriticalSection(&IcmpRequestsCritSect);
        InitializeCriticalSection(&OutputCritSect);
    }except( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // hit an exception while initializing critical section
        // shouldnt happen
        //

        Status = GetLastError( );
        return( Status );
    }

    PingInitLevel ++;        // Indicate that PingInit was started
    // Open IcmpHandle..
    IcmpHandle = IcmpCreateFile();
    if( INVALID_HANDLE_VALUE == IcmpHandle ) return GetLastError();

    // Create Events,
    IcmpRepliesEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if( NULL == IcmpRepliesEvent ) return GetLastError();
    IcmpRequestsEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if( NULL == IcmpRequestsEvent ) return GetLastError();
    TerminateEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    if( NULL == TerminateEvent ) return GetLastError();

    // Create Threads

    if( CFLAG_USE_PING_REPLY_THREAD ) {
        RepliesThreadHandle = CreateThread(
            (LPSECURITY_ATTRIBUTES)
            NULL,            // No security information
            0,               // Stack size = same as default primary thread
            LoopOnIcmpReplies,// The function to call
            NULL,            // No paramter needs to be passed to this function
            0,               // Flags: just start this thread right away
            &ThreadId        // The return ThreadId value.
        );
        if( NULL == RepliesThreadHandle ) return GetLastError();
    }

    RequestsThreadHandle = CreateThread(
        NULL,                // No security information
        0,                   // Stack size = same as default primary thread
        LoopOnIcmpRequests,  // The function to call
        NULL,                // No paramter needs to be passed to this function
        0,                   // Flags: just start this thread right away
        &ThreadId            // The return ThreadId value.
    );
    if( NULL == RequestsThreadHandle ) return GetLastError();

    return ERROR_SUCCESS;
}

VOID // exported
PingCleanup(
    VOID
)
{
    DWORD               Status;
    BOOL                BoolStatus;
    PAPC_CONTEXT        ApcContext;
    PLIST_ENTRY         listEntry;

    if( 0 == PingInitLevel ) return;
    PingInitLevel -- ;

    // Kill the replies and reqeusts threads after waiting for a while.
    // Kill the Replies and Requests ThreadHandle 's.
    if( NULL != RepliesThreadHandle || NULL != RequestsThreadHandle ) {
        // DhcpAssert ( NULL != TerminateEvent )
        Terminating = TRUE;
        SetEvent(TerminateEvent);

        if( CFLAG_USE_PING_REPLY_THREAD && NULL != RepliesThreadHandle ) {
            Status = WaitForSingleObject(
                RepliesThreadHandle,
                THREAD_KILL_TIME
            );
            if( WAIT_OBJECT_0 != Status ) {
                //  did not succeed in stopping the thread..
                DhcpPrint( (DEBUG_ERRORS, "Error: PingCleanup ( threadwait to die): %ld \n", Status ) );
            }
            CloseHandle(RepliesThreadHandle);
        }

        if( NULL != RequestsThreadHandle ) {
            Status = WaitForSingleObject(
                RequestsThreadHandle,
                THREAD_KILL_TIME
            );
            if( WAIT_OBJECT_0 != Status ) {
                //  did not succeed in stopping the thread..
                DhcpPrint( (DEBUG_ERRORS, "Error: PingCleanup ( threadwait to die): %ld \n", Status ) );
            }
            CloseHandle(RequestsThreadHandle);
        }
    }

    while( nPendingRequests ) {
        SleepEx( WAIT_TIME, TRUE );
    }

    // Close Event handles.
    CloseHandle(IcmpRepliesEvent);
    CloseHandle(IcmpRequestsEvent);
    CloseHandle(TerminateEvent);

    // Freeup all elements of lists..
    while( !IsListEmpty( &IcmpRepliesList ) ) {
        // retrive the first element in the list
        ApcContext = CONTAINING_RECORD(IcmpRepliesList.Flink, APC_CONTEXT, IcmpRepliesList);
        RemoveEntryList(&ApcContext->IcmpRepliesList);

        DhcpFreeMemory(ApcContext);
    }
    while( !IsListEmpty( &IcmpRequestsList ) ) {
        // retrive the first element in the list
        ApcContext = CONTAINING_RECORD(IcmpRequestsList.Flink, APC_CONTEXT, IcmpRequestsList);
        RemoveEntryList(&ApcContext->IcmpRequestsList);

        DhcpFreeMemory(ApcContext);
    }

    // Close Icmp handle
    CloseHandle(IcmpHandle);

    // Destroy critical sections
    DeleteCriticalSection(&IcmpRepliesCritSect);
    DeleteCriticalSection(&IcmpRequestsCritSect);
    DeleteCriticalSection(&OutputCritSect);

    DhcpAssert( 0 == PingInitLevel );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\rogue.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    rogue.c

Abstract:

    This file contains all the routines used in Rogue DHCP Server detection

Author:

    Shirish Koti (koti)    16-May-1997

    Ramesh VK (RameshV)    07-Mar-1998
       *PnP changes

    Ramesh VK (RameshV)    01-Aug-1998
       * Code changes to include asynchronous design
       * better logging (event + auditlog)
       * Two sockets only (needed for async recv + sync send? )
       * NT5 server in NT4 domain
       * Better reliability in case of multiple DS DC's + one goes down etc

    Ramesh VK (RameshV)    28-Sep-1998
       * Updated with review suggestions as well as ->NT5 upgrade scenarios
       * Updated -- removed neg caching, changed timeouts, changed loops..

    Ramesh VK (RameshV)    16-Dec-1998
       * Updated bindings model change.
       
Environment:

    User Mode - Win32

Revision History:


--*/

#include <dhcppch.h>
#include <dhcpds.h>
#include <iptbl.h>
#include <endpoint.h>


typedef enum {

    ROGUE_STATE_INIT = 0,
    ROGUE_STATE_WAIT_FOR_NETWORK,
    ROGUE_STATE_START,
    ROGUE_STATE_PREPARE_SEND_PACKET,
    ROGUE_STATE_SEND_PACKET,
    ROGUE_STATE_WAIT_FOR_RESP,
    ROGUE_STATE_PROCESS_RESP,
    ROGUE_STATE_TERMINATED

} DHCP_ROGUE_STATE;

#define  DHCP_ROGUE_AUTHORIZED                      0
#define  DHCP_ROGUE_UNAUTHORIZED                    1
#define  DHCP_ROGUE_DSERROR                         2


enum {
    ROGUE_AUTHORIZED = 0,
    ROGUE_UNAUTHORIZED,
    ROGUE_AUTH_NOT_CHECKED
};

#define DHCP_GET_DS_ROOT_RETRIES                 3
#define DHCP_GET_DS_ROOT_TIME                    5
#define DHCP_ROGUE_RUNTIME_RESTART               (60)
#define DHCP_ROGUE_RUNTIME_RESTART_LONG          (5*60)
#define DHCP_ROGUE_WAIT_FOR_RESP_TIME            8

#undef  DHCP_ROGUE_RUNTIME_DELTA
#undef  DHCP_ROGUE_RUNTIME_DELTA_LONG

#define DHCP_ROGUE_RESTART_NET_ERROR             5
#define DHCP_ROGUE_RUNTIME_DIFF                  (5*60)
#define DHCP_ROGUE_RUNTIME_DIFF_LONG             (7*60)
#define DHCP_ROGUE_RUNTIME_DELTA                 (5*60)
#define DHCP_ROGUE_RUNTIME_DELTA_LONG            (15*60)
#define DHCP_MAX_ACKS_PER_INFORM                 (30)
#define DHCP_ROGUE_MAX_INFORMS_TO_SEND           (4)
#define DHCP_RECHECK_DSDC_RETRIES                100
#define ROUND_DELTA_TIME                         (60*60)

#define IPCACHE_TIME                             (5*60)

#define DHCP_ROGUE_FIRST_NONET_TIME              (1*60)

//
// The rogue authorization recheck time is now configurable.
// The minimum time is 5 minutes, default = 60 minutes
//
#define ROGUE_MIN_AUTH_RECHECK_TIME              (5 * 60)
#define ROGUE_DEFAULT_AUTH_RECHECK_TIME          (60 * 60)
DWORD RogueAuthRecheckTime = ROGUE_DEFAULT_AUTH_RECHECK_TIME;


typedef struct {
    LIST_ENTRY  List;

    ULONG IpAddress;
    BOOL fProcessed;
    ULONG Authorized;
    LPWSTR Domain;
    LPWSTR DnsForestName;
} CACHED_SERVER_ENTRY, *PCACHED_SERVER_ENTRY;



DHCP_ROGUE_STATE_INFO DhcpGlobalRogueInfo;
HMODULE Self;

#if DBG
LPWSTR FakeDomain = NULL, FakeDnsForestName = NULL;
PBOOL  FakeIsSamSrv = NULL;
BOOL  fDhcpGlobalNoRogue = FALSE;
#endif

//
//           A U D I T   L O G   C A L L S
//

VOID
RogueAuditLog(
    IN ULONG EventId,
    IN ULONG IpAddress,
    IN LPWSTR Domain,
    IN ULONG ErrorCode
)
{
    DhcpPrint((DEBUG_ROGUE, "%ws, %x, %ws (%ld)\n", 
               GETSTRING(EventId), IpAddress, Domain, ErrorCode));
    DhcpUpdateAuditLogEx(
        (EventId + DHCP_IP_LOG_ROGUE_BASE - DHCP_IP_LOG_ROGUE_FIRST ),
        GETSTRING(EventId),
        IpAddress,
        NULL,
        0,
        Domain,
        ErrorCode
    );
}

ULONG
MapEventIdToEventLogType(
    IN ULONG EventId
)
{
    switch(EventId) {
    case DHCP_ROGUE_EVENT_STARTED: 
    case DHCP_ROGUE_EVENT_STARTED_DOMAIN:
    case DHCP_ROGUE_EVENT_JUST_UPGRADED:
    case DHCP_ROGUE_EVENT_JUST_UPGRADED_DOMAIN:
        return EVENTLOG_INFORMATION_TYPE;
    }
    return EVENTLOG_ERROR_TYPE;
}

VOID
RogueEventLog(
    IN ULONG EventId,
    IN ULONG IpAddress,
    IN LPWSTR Domain,
    IN ULONG ErrorCode
)
{
    LPWSTR IpAddrString;
    LPWSTR Strings[3];
    WCHAR ErrorCodeString[sizeof(ErrorCode)*2 + 5];
    
    if( 0 == IpAddress ) IpAddrString = NULL;
    else {
        IpAddress = htonl(IpAddress);
        IpAddrString = DhcpOemToUnicode( 
            inet_ntoa(*(struct in_addr *)&IpAddress), 
            NULL
            );
    }

    Strings[0] = (NULL == IpAddrString)? L"" : IpAddrString;
    Strings[1] = (NULL == Domain)? L"" : Domain;
    if( 0 == ErrorCode ) {
        Strings[2] = L"0";
    } else {
        swprintf(ErrorCodeString, L"0x%8lx", ErrorCode);
        Strings[2] = ErrorCodeString;
    }

    DhcpReportEventW(
        DHCP_EVENT_SERVER,
        EventId,
        MapEventIdToEventLogType(EventId),
        3,
        sizeof(ULONG),
        Strings,
        (LPVOID)&ErrorCode
    );
}

#define ROGUEAUDITLOG(Evt,Ip,Dom,Err) if(Info->fLogEvents) RogueAuditLog(Evt,Ip,Dom,Err)
#define ROGUEEVENTLOG(Evt,Ip,Dom,Err) RogueEventLog(Evt,Ip,Dom,Err)

LPWSTR
FormatRogueServerInfo(
    IN ULONG IpAddress,
    IN LPWSTR Domain,
    IN ULONG Authorization
)
{
    LPWSTR String = NULL;
    LPWSTR IpString, Strings[2] ;
    ULONG Error;

    switch(Authorization) {
    case ROGUE_UNAUTHORIZED : 
        Authorization = DHCP_ROGUE_STRING_FMT_UNAUTHORIZED; break;
    case ROGUE_AUTHORIZED : 
        Authorization = DHCP_ROGUE_STRING_FMT_AUTHORIZED; break;
    case ROGUE_AUTH_NOT_CHECKED : 
        Authorization = DHCP_ROGUE_STRING_FMT_NOT_CHECKED; break;
    default: return NULL;
    }

    IpAddress = htonl(IpAddress);
    IpString = DhcpOemToUnicode(
        inet_ntoa( *(struct in_addr *)&IpAddress), NULL
        );
    if( NULL == IpString ) return NULL;

    Strings[0] = IpString;
    Strings[1] = Domain;
    Error = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER 
        | FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        Self,
        Authorization,
        MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
        (PVOID)&String,
        0,
        (PVOID)Strings
    );

    DhcpFreeMemory(IpString);
    return String;
}

LPWSTR
FormatRogueServerInfoEx(
    IN PDHCP_ROGUE_STATE_INFO Info
)
{
    LPWSTR String1, String2, String3;
    PLIST_ENTRY Entry;
    PCACHED_SERVER_ENTRY CachedServer;

    String1 = NULL;
    Entry = Info->CachedServersList.Flink;
    while( Entry != &Info->CachedServersList ) {
        CachedServer = CONTAINING_RECORD(
            Entry, CACHED_SERVER_ENTRY, List
            );
        Entry = Entry->Flink;

        if( CachedServer->Authorized == ROGUE_AUTHORIZED
            || NULL == CachedServer->Domain 
            || L'\0' == CachedServer->Domain[0] ) {
            continue;
        }

        String2 = FormatRogueServerInfo(
            CachedServer->IpAddress, 
            CachedServer->Domain,
            CachedServer->Authorized 
        );
        if( NULL == String2 )  continue;

        if( NULL == String1 ) {
            String1 = String2 ;
            continue;
        }

        String3 = LocalAlloc(
            LPTR, 
            sizeof(WCHAR) *(wcslen(String2) + wcslen(String1) + 1)
            );
        if( NULL == String3 ) continue;

        wcscpy(String3, String1);
        wcscat(String3, String2);
        if( String1 ) LocalFree( String1 );
        if( String2 ) LocalFree( String2 );
        String1 = String3;
    }

    return String1;
}

ULONG _inline
CountDomains(
    IN PDHCP_ROGUE_STATE_INFO Info
)
{
    ULONG Count = 0;
    PLIST_ENTRY Entry;
    PCACHED_SERVER_ENTRY CachedServer;

    Entry = Info->CachedServersList.Flink;
    while( Entry != &Info->CachedServersList ) {
        CachedServer = CONTAINING_RECORD(Entry, CACHED_SERVER_ENTRY, List);
        Entry = Entry->Flink;

        if( CachedServer->Authorized != ROGUE_AUTHORIZED &&
            NULL != CachedServer->Domain && CachedServer->Domain[0] )
            Count ++;
    }

    return Count;
}

//
//
//

BOOL _inline
IsThereDuplicateCachedEntry(
    IN PLIST_ENTRY CachedServersList,
    IN ULONG IpAddress,
    IN LPWSTR Domain,
    IN LPWSTR DnsForestName
)
{
    PLIST_ENTRY List = CachedServersList;
    PCACHED_SERVER_ENTRY Entry;

    List = List->Flink;
    while( List != CachedServersList ) {
        Entry = CONTAINING_RECORD( 
            List, CACHED_SERVER_ENTRY, List 
            );
        List = List->Flink;

        if( Entry->IpAddress == IpAddress ) return TRUE;
        if( Domain && Entry->Domain 
            && 0 == _wcsicmp(Domain,Entry->Domain) ) {
            return TRUE;
        }

        if( DnsForestName && Entry->DnsForestName &&
            0 == _wcsicmp(DnsForestName, Entry->DnsForestName ) ) {
            return TRUE;
        }
    }

    return FALSE;
}

VOID _inline
InsertCachedEntry(
    IN OUT PLIST_ENTRY CachedServersList,
    IN ULONG IpAddress,
    IN BOOL fProcessed,
    IN BOOL Authorized,
    IN LPWSTR Domain,
    IN LPWSTR DnsForestName
)
{
    PCACHED_SERVER_ENTRY Entry;
    ULONG Size;

    Size = ROUND_UP_COUNT(sizeof(*Entry), ALIGN_WCHAR);
    Size += (Domain? (wcslen(Domain)+1): 0) * sizeof(WCHAR); 
    Size += (DnsForestName? (wcslen(DnsForestName)+1): 0) * sizeof(WCHAR);

    Entry = LocalAlloc(LPTR, Size);
    if( NULL == Entry ) {
        //
        //  -- what to do?
        //
        return;
    }

    Entry->IpAddress = IpAddress;
    Entry->fProcessed = fProcessed;
    Entry->Authorized = Authorized;

    Size = ROUND_UP_COUNT(sizeof(*Entry), ALIGN_WCHAR);
    if( NULL == Domain ) {
        Entry->Domain = Entry->DnsForestName = NULL;
    } else {
        Entry->Domain = (LPWSTR)(Size + (LPBYTE)Entry);
        wcscpy(Entry->Domain, Domain);

        if( NULL == DnsForestName ) {
            Entry->DnsForestName = NULL;
        } else {
            Size += (wcslen(Domain) +1)* sizeof(WCHAR);
            Entry->DnsForestName = (LPWSTR)(Size + (LPBYTE)Entry);
            wcscpy(Entry->DnsForestName, DnsForestName);
        }
    }

    InsertHeadList( CachedServersList, &Entry->List );
}


BOOL
AmIRunningOnSBSSrv(
    VOID
)
/*++

Routine Description:

    This function determines if this is a SAM Server

Arguments:

    None.

Return Value:

    TRUE if this is an SBS server that still has the NT 
         Restriction Key  "Small Business(Restricted)" in ProductSuite
    FALSE - otherwise

--*/
{
    OSVERSIONINFOEX OsInfo;
    DWORDLONG dwlCondition = 0;
    
    OsInfo.dwOSVersionInfoSize = sizeof(OsInfo);
    OsInfo.wSuiteMask = VER_SUITE_SMALLBUSINESS_RESTRICTED;

    VER_SET_CONDITION(
        dwlCondition, VER_SUITENAME, VER_AND
        );
    
    return VerifyVersionInfo(
        &OsInfo,
        VER_SUITENAME,
        dwlCondition
        );
}

DWORD _inline
GetDomainName(
    IN OUT PDHCP_ROGUE_STATE_INFO Info
)
{
    DWORD Error;
    LPWSTR pNetbiosName = NULL, pDomainName = NULL;
    BOOLEAN fIsWorkGroup;

#if DBG
    if( FakeDomain ) {
        if( wcscmp(FakeDomain, L"NONE") == 0 ) {
            Info->fIsWorkGroup = TRUE;
            return ERROR_SUCCESS;
        }
        Info->fIsWorkGroup = FALSE;
        wcscpy(Info->DomainDnsName, FakeDomain);
        return ERROR_SUCCESS;
    }
#endif

    Error = NetpGetDomainNameExEx(
        &pNetbiosName,
        &pDomainName,
        &fIsWorkGroup
    );

    if( ERROR_SUCCESS != Error ) return Error;
    Info->fIsWorkGroup = fIsWorkGroup;

    if( pNetbiosName && NULL == pDomainName ) {
        //
        // Only NetbiosName available?  Then this is NOT a NT5 domain!
        //
        Info->fDcIsDsEnabled = FALSE;
        wcscpy(Info->DomainDnsName, pNetbiosName );
    }

    if( pNetbiosName ) NetApiBufferFree(pNetbiosName);

    if( NULL != pDomainName ) {
        wcscpy(Info->DomainDnsName, pDomainName);
    }

    if( pDomainName ) NetApiBufferFree(pDomainName);

    return ERROR_SUCCESS;
}

DWORD _inline
RogueNetworkInit(
    IN OUT PDHCP_ROGUE_STATE_INFO Info
)
{
    ULONG Error;

    if( FALSE == Info->fDhcp ) {
        if( INVALID_SOCKET != Info->SendSocket ) return ERROR_SUCCESS;
        
        //
        // Open socket and initialize it as needed, binding to 0.0.0.0
        //
        
        Error = InitializeSocket(
            &Info->RecvSocket, INADDR_ANY, DhcpGlobalClientPort, 0
            );
        if( ERROR_SUCCESS != Error ) return Error;
    }

    return InitializeSocket(
        &Info->SendSocket, INADDR_ANY, DhcpGlobalClientPort, 0
        );
}

DWORD
GetDcNameForDomain(
    IN LPWSTR DomainName,
    IN OUT BOOL *fDcIsDsEnabled,
    IN OUT LPWSTR DnsForestName
)
{
    //
    // DnsForetName should be a buffer 
    // that is atleast MAX_DNS_NAME_LEN wchars
    //

    DWORD Error;
    PDOMAIN_CONTROLLER_INFO DcInfo;
    ULONG IsEnabled;

#if DBG
    if( FakeDomain && FakeDnsForestName &&
        0 == _wcsicmp(DomainName, FakeDomain ) ) {

        if( 0 == wcscmp(FakeDnsForestName, L"NONE" ) ) {
            (*fDcIsDsEnabled) = FALSE;
            DnsForestName[0] = L'\0';
        } else {
            (*fDcIsDsEnabled) = TRUE;
            wcscpy(DnsForestName, FakeDnsForestName);
        }
        return ERROR_SUCCESS;
    }
#endif

    Error = ERROR_SUCCESS;
    do {
        DcInfo = NULL;
        IsEnabled = FALSE;

        Error = DsGetDcNameW(
            NULL,
            DomainName,
            NULL,
            NULL,
            DS_IS_DNS_NAME | DS_RETURN_DNS_NAME 
            | DS_DIRECTORY_SERVICE_PREFERRED, 
            &DcInfo
        );

        if( ERROR_SUCCESS != Error ) break;
        if( DcInfo->DnsForestName ) {
            wcscpy(DnsForestName, DcInfo->DnsForestName);
        }

        IsEnabled = ( DcInfo->DnsForestName && (DcInfo->Flags & DS_DS_FLAG) );
        NetApiBufferFree( DcInfo );

    } while ( FALSE );

    if( FALSE == IsEnabled ) {
        DnsForestName[0] = L'\0';
    }
    (*fDcIsDsEnabled) = IsEnabled;

    return Error;
}

DWORD _inline
GetDsDcName(
    IN OUT PDHCP_ROGUE_STATE_INFO Info
)
{
    return GetDcNameForDomain(
        NULL, &(Info->fDcIsDsEnabled), Info->DnsForestName 
    );
}


VOID
LogUnAuthorizedInfo(
    IN OUT PDHCP_ROGUE_STATE_INFO Info
)
/*++

Routine Description

    This routine walks through the Info->CachedServersList and
    creates a string out of them formatted as below (one per entry)

    Server <Entry->IpAddress> (domain Entry->Domain) : [Authorized, NotAuthorized, Not Cheecked]

    For workgroup or Sam server, it just looks at LastSeenDomain and LastSeenIpAddress

Arguments

    Info -- pointer to state info to gather information to print.

Return Value

    none
--*/
{
    LPWSTR String, Strings[1];
    static ULONG LastCount = 0;
    ULONG Count;

    if( Info->fIsWorkGroup || Info->fIsSamSrv ) {
        static ULONG Addresses[1000];
        static ULONG LastUpdateTime=0;
        ULONG i;

        //
        // Ignore if no other server present or while in wrkgrp and saw
        // no domain.
        //
        
        if( Info->LastSeenIpAddress == 0 ) {
            return ;
        }

        if( Info->fIsWorkGroup && Info->LastSeenDomain[0] == L'\0' ) {
            return ;
        }
        
        for( i = 0; i < sizeof(Addresses)/sizeof(Addresses[0]); i ++ ) {
            if( Addresses[i] == Info->LastSeenIpAddress ) {
                return;
            }
            if( 0 == Addresses[i] ) {
                Addresses[i] = Info->LastSeenIpAddress;
                break;
            }
        }
        if( LastUpdateTime + IPCACHE_TIME < (ULONG)time(NULL) ) {
            //
            // cache expired.
            //
            RtlZeroMemory(Addresses, sizeof(Addresses));
        }
        
        String = FormatRogueServerInfo(
            Info->LastSeenIpAddress, Info->LastSeenDomain, DHCP_ROGUE_UNAUTHORIZED
            );
    } else {
        Count = CountDomains( Info );
        if( Count == LastCount ) return ;

        LastCount = Count;
        if( 0 == Count ) return ;

        String = FormatRogueServerInfoEx(Info);
    }

    if( NULL == String ) return ;

    DhcpPrint((DEBUG_ROGUE,"LOG -- %ws\n", String));

    Strings[0] = String;
    DhcpReportEventW(
        DHCP_EVENT_SERVER,
        DHCP_ROGUE_EVENT_UNAUTHORIZED_INFO,
        EVENTLOG_WARNING_TYPE,
        1,
        0,
        Strings,
        NULL
    );

    if(String ) LocalFree( String );
}

ULONG _fastcall
ValidateServer(
    IN OUT PDHCP_ROGUE_STATE_INFO Info
)
{
    DWORD Error;
    BOOL fFound, fIsStandAlone;

    //
    // Validate ourselves against the local DS.
    //

    DhcpPrint(( DEBUG_ROGUE,
        "Validating : %ws %x\n",
        Info->DomainDnsName,
        Info->LastSeenIpAddress
        ));
    Error = DhcpDsValidateService(
        Info->DomainDnsName,
        NULL,
        0,
        NULL,
        0,
        ADS_SECURE_AUTHENTICATION,
        &fFound,
        &fIsStandAlone
    );
    if( ERROR_SUCCESS != Error ) {

        ROGUEAUDITLOG( DHCP_ROGUE_LOG_COULDNT_SEE_DS, 0, Info->DomainDnsName, Error );
    ROGUEEVENTLOG( EVENT_SERVER_COULDNT_SEE_DS, 0, Info->DomainDnsName, Error );

        return DHCP_ROGUE_DSERROR;
    }

    return fFound? DHCP_ROGUE_AUTHORIZED : DHCP_ROGUE_UNAUTHORIZED;
} // ValidateServer()

VOID
EnableOrDisableService(
    IN OUT PDHCP_ROGUE_STATE_INFO Info,
    IN BOOL fEnable,
    IN BOOL fLogOnly
)
/*++

Routine Description

    This routine enables or disables the service depending on what the
    value of fEnable is.  It doesnt do either but just logs some
    information if fLogOnly is TRUE.

Arguments

    Info  -- pointer to the global information and state
    fEnable -- ENABLE or DISABLE the service (TRUE or FALSE)
    fLogOnly -- log some information but do not enable or disable service

Return Values

    None

--*/
{
    LPWSTR DomainName;
    ULONG EventId;

    LogUnAuthorizedInfo(Info);

    if( FALSE == fLogOnly ) {
        //
        // If state is changed, then inform binl.
        //
        InformBinl( fEnable ? DHCP_AUTHORIZED : DHCP_NOT_AUTHORIZED );

#if DBG
        if( FALSE == fDhcpGlobalNoRogue ) DhcpGlobalOkToService = fEnable;
#else
        DhcpGlobalOkToService = fEnable;
#endif
        
        ROGUEAUDITLOG( 
            fEnable ? DHCP_ROGUE_LOG_STARTED: DHCP_ROGUE_LOG_STOPPED, 0, 
            Info->DomainDnsName, 0);

        if( Info->DomainDnsName[0] ) {
            DomainName = Info->DomainDnsName;
            if( fEnable && Info->fJustUpgraded ) {
                if( ROGUE_AUTHORIZED != Info->CachedAuthStatus ) {
                    EventId = DHCP_ROGUE_EVENT_JUST_UPGRADED_DOMAIN; 
                } else {
                    EventId = DHCP_ROGUE_EVENT_STARTED_DOMAIN ;
                }
            } else {
                EventId = ( 
                    fEnable ? 
                    DHCP_ROGUE_EVENT_STARTED_DOMAIN :
                    DHCP_ROGUE_EVENT_STOPPED_DOMAIN 
                    );
            }
        } else {
            DomainName = NULL;
            if( fEnable && Info->fJustUpgraded ) {
                EventId = DHCP_ROGUE_EVENT_JUST_UPGRADED ;
            } else {
                EventId = ( 
                    fEnable ?
                    DHCP_ROGUE_EVENT_STARTED :
                    DHCP_ROGUE_EVENT_STOPPED );
            }
        }
        
        ROGUEEVENTLOG(
            EventId, 0, 
            DomainName, 0
            );
    }
}

ULONG _inline
GetSomeHostAddress(
    VOID
)
{
    struct hostent *HostEnt;

    HostEnt = gethostbyname( NULL);

    if( NULL == HostEnt ) return INADDR_ANY;
    //
    //  -- need to discard zeroes and 127.* etc..
    //
    return *((ULONG *)(HostEnt->h_addr_list[0]));
}

BOOL _inline
IsThisOurAddress(
    IN ULONG Addr /* host order */
)
{
    struct hostent *HostEnt;
    int i;

    HostEnt = gethostbyname( NULL);

    if( NULL == HostEnt ) return TRUE;
    i = 0;
    while( HostEnt->h_addr_list[i] ) {
        if( *(ULONG*)(HostEnt->h_addr_list[i]) == ntohl(Addr) )
            return TRUE;
        i++;
    }

    return FALSE;
}

BOOL _stdcall
DoWSAEventSelectForRead(
    IN OUT PENDPOINT_ENTRY Entry,
    IN OUT PVOID RogueInfo
    )
/*++

Routine Description:
    This routine sets all the rogue sockets to signal the
    WaitHandle on availablity to read.

    N.B This is done only on the bound sockets.
Arguments:
    Entry -- endpoint binding.
    RogueInfo -- rogue state info.

Return Values:
    always TRUE as all the endpoints need to be scanned.

--*/
{
    PDHCP_ROGUE_STATE_INFO Info = (PDHCP_ROGUE_STATE_INFO) RogueInfo;
    PENDPOINT Ep = (PENDPOINT)Entry;
    ULONG Error;
    
    //
    // Ignore unbound interfaces right away.
    //
    if( !IS_ENDPOINT_BOUND( Ep ) ) return TRUE;

    //
    // Now do WSAEventSelect and print error code.
    //
    Error = WSAEventSelect(
        Ep->RogueDetectSocket,
        Info->WaitHandle,
        FD_READ
        );
    if( SOCKET_ERROR == Error ) {
        Error = WSAGetLastError();
        DhcpPrint((DEBUG_ROGUE, "LOG WSAEventSelect: %ld\n", Error));
    }

    return TRUE;
}

VOID
EnableForReceive(
    IN PDHCP_ROGUE_STATE_INFO Info
)
/*++

Routine Description:
    Sets the ASYNC SELECT events on the required sockets.

--*/
{
    ULONG Error, i;

    if( FALSE == Info->fDhcp ) {
        //
        // BINL -- only one socket: Info->RecvSocket
        //
        if( SOCKET_ERROR == WSAEventSelect(
            Info->RecvSocket, Info->WaitHandle, FD_READ) ) {
            Error = WSAGetLastError();
            
            DhcpPrint((DEBUG_ROGUE, "LOG WSAEventSelect failed %ld\n",
                       Error));
        }
        return;
    }

    //
    // For DHCP -- each endpoint that is bound has a rogue detect socket.
    // Enable receiving on each of those.
    //

    WalkthroughEndpoints(
        (PVOID)Info,
        DoWSAEventSelectForRead
        );
}

ULONG _inline
RogueSendDhcpInform(
    IN OUT PDHCP_ROGUE_STATE_INFO Info,
    IN BOOL fNewXid
)
{
    DWORD Error;
    PDHCP_MESSAGE SendMessage;
    POPTION Option;
    LPBYTE OptionEnd;
    BYTE Value;
    CHAR Buf[2];
    SOCKADDR_IN BcastAddr;
    ULONG Async;

    //
    // Format the inform packet if we haven't done it already.
    //

    SendMessage = (PDHCP_MESSAGE) Info->SendMessage;
    RtlZeroMemory( Info->SendMessage, sizeof(Info->SendMessage) );
    SendMessage ->Operation = BOOT_REQUEST;
    SendMessage ->HardwareAddressType = HARDWARE_TYPE_10MB_EITHERNET;
    SendMessage ->HardwareAddressLength = 6;
    SendMessage ->SecondsSinceBoot = 10;
    SendMessage ->Reserved = htons(DHCP_BROADCAST);
    
    Option = &SendMessage->Option;
    OptionEnd = DHCP_MESSAGE_SIZE + (LPBYTE)SendMessage;
    
    Option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) Option, OptionEnd );
    Value = Info->fIsSamSrv ? DHCP_DISCOVER_MESSAGE : DHCP_INFORM_MESSAGE;
    Option = DhcpAppendOption(
        Option,
        OPTION_MESSAGE_TYPE,
        &Value,
        sizeof(Value),
        OptionEnd
        );
    
    if( FALSE == Info->fIsSamSrv ) {
        Buf[0] = OPTION_MSFT_DSDOMAINNAME_REQ;
        Buf[1] = 0;
        Option = DhcpAppendOption(
            Option,
            OPTION_VENDOR_SPEC_INFO,
            Buf,
            sizeof(Buf),
            OptionEnd
            );
    }
    
    Option = DhcpAppendOption (Option, OPTION_END, NULL, 0, OptionEnd);
    
    Info->SendMessageSize = (DWORD) ((PBYTE)Option - (PBYTE)SendMessage);

    //
    // Chose the first IP address that is around for showing up
    //

    SendMessage ->ClientIpAddress = GetSomeHostAddress();
    if( fNewXid ) SendMessage ->TransactionID = GetTickCount() + (rand() << 16);

    //
    // Send the packet out broadcast
    //

    BcastAddr.sin_family = AF_INET;
    BcastAddr.sin_port = htons(DHCP_SERVR_PORT);
    BcastAddr.sin_addr.s_addr = INADDR_BROADCAST;

    if( SOCKET_ERROR == sendto(
        Info->SendSocket,
        (PCHAR) Info->SendMessage,
        Info->SendMessageSize,
        0,
        (LPSOCKADDR) &BcastAddr,
        sizeof(SOCKADDR_IN) ) ) {

        Error = WSAGetLastError();

        //
        // LOG error
        //
        ROGUEAUDITLOG( DHCP_ROGUE_LOG_NETWORK_FAILURE,0, NULL, Error);
        return Error;
    }

    //
    // Set the socket to be asynchronous binding to WaitHandle event
    //

    EnableForReceive(Info);

    return ERROR_SUCCESS;
}

typedef struct {
    PDHCP_ROGUE_STATE_INFO Info;
    SOCKET *Sock;
    ULONG LastError;
} GET_SOCK_CTXT;

BOOL _stdcall
GetReadableSocket(
    IN OUT PENDPOINT_ENTRY Entry,
    IN OUT PVOID SockCtxt
    )
/*++

Routine Description:
    This routine takes a network endpoint and tells if the endpoint
    has a rogue det. socket available for reading.
    If so, it returns FALSE.  Otherwise, it returns TRUE.

    If the routine returns TRUE, then the socket that is ready for
    read is returned in the SockCtxt->Sock variable.
    
Arguments:
    Entry -- endpoint entry
    SockCtxt -- pointer to a GET_SOCK_CTXT structure.

Return Values:
    TRUE -- the socket does not have a read event ready.
    FALSE -- the socket has a read event ready.
    
--*/
{
    GET_SOCK_CTXT *Ctxt = (GET_SOCK_CTXT*)SockCtxt;
    PENDPOINT Ep = (PENDPOINT)Entry;
    WSANETWORKEVENTS NetEvents;
    ULONG Error;
    
    if(!IS_ENDPOINT_BOUND(Ep) ) return TRUE;

    Error = WSAEnumNetworkEvents(
        Ep->RogueDetectSocket,
        Ctxt->Info->WaitHandle,
        &NetEvents
        );
    if( SOCKET_ERROR == Error ) {
        Ctxt->LastError = WSAGetLastError();
        DhcpPrint((DEBUG_ROGUE,"LOG WSAEnumNet: %ld\n", Error));
        return TRUE;
    }

    if( 0 == (NetEvents.lNetworkEvents & FD_READ) ) {
        //
        // Nothing to read for this socket.
        //
        return TRUE;
    }
    *(Ctxt->Sock) = Ep->RogueDetectSocket;
    Ctxt->LastError = NO_ERROR;

    //
    // return FALSE - don't proceed with enumeration anymore.
    // 
    return FALSE;
}

DWORD
GetReceivableSocket(
    IN PDHCP_ROGUE_STATE_INFO Info,
    OUT SOCKET *Socket
)
/*++

Routine Description:
   This routine returns a socket that has a packet receivable on it.

Argument:
   Info -- state info
   Socket -- socket that recvfrom won't block on

Return Value:
   ERROR_SEM_TIMEOUT if no socket is avaliable for receive
   Winsock errors

--*/
{
    ULONG Error;
    WSANETWORKEVENTS NetEvents;
    GET_SOCK_CTXT Ctxt;
    
    if( FALSE == Info->fDhcp ) {
        //
        // BINL -- need to check only the RecvSocket to see if readable.
        //
        Error = WSAEnumNetworkEvents( 
            Info->RecvSocket,
            Info->WaitHandle,
            &NetEvents
            );
        if( SOCKET_ERROR == Error ) {
            Error = WSAGetLastError();
#if DBG
            DbgPrint("WSAEnumNetworkEvents: %ld (0x%lx)\n", Error);
            DebugBreak();
#endif
            return Error;
        }
        
        if( 0 == (NetEvents.lNetworkEvents & FD_READ ) ) {
            //
            // OK - nothing to read? 
            //
            return ERROR_SEM_TIMEOUT;
        }

        *Socket = Info->RecvSocket;
        return ERROR_SUCCESS;
    }

    //
    // For DHCP -- we need to traverse the list of bound endpoints..
    // and check to see if any of them are available for read.
    //

    *Socket = INVALID_SOCKET;
    
    Ctxt.Info = Info;
    Ctxt.Sock = Socket;
    Ctxt.LastError = ERROR_SEM_TIMEOUT;
    
    WalkthroughEndpoints(
        (PVOID)&Ctxt,
        GetReadableSocket
        );
    
    return Ctxt.LastError;
}
        
DWORD _inline
RogueReceiveAck(
    IN OUT PDHCP_ROGUE_STATE_INFO Info
)
{
    ULONG SockAddrLen, MsgLen, Error, IpAddress, Flags;
    struct sockaddr SockAddr;
    struct sockaddr_in *Source;
    PDHCP_MESSAGE RecvMessage, SendMessage;
    DHCP_SERVER_OPTIONS DhcpOptions;
    LPSTR DomainName;
    WCHAR DomBuf[MAX_DNS_NAME_LEN];
    LPWSTR DomainNameW;
    WSABUF WsaBuf = { sizeof(Info->RecvMessage), Info->RecvMessage };
    BOOL fFirstTime = TRUE;
    SOCKET Socket;

    //
    // First try to do a recvfrom -- since socket is asynchronous it will
    // tell if there is a packet waiting or it will fail coz there is none
    // If it fails, just return success
    //

    while ( TRUE ) {

        Error = GetReceivableSocket( Info, &Socket );
        if( ERROR_SUCCESS != Error ) {
            if( ERROR_SEM_TIMEOUT == Error && !fFirstTime ) {
                return ERROR_RETRY;
            }
            return Error;
        }

        fFirstTime = FALSE;

        SockAddrLen = sizeof( struct sockaddr );
        Flags = 0;
        Error = WSARecvFrom(
            Socket,
            &WsaBuf,
            1,
            &MsgLen,
            &Flags,
            &SockAddr,
            &SockAddrLen,
            NULL,
            NULL
        );

        if( SOCKET_ERROR == Error ) {
            Error = WSAGetLastError();

            if( WSAEWOULDBLOCK == Error ) {
                //
                // UNEXPECTED!!!!!!!!!!
                //
                return ERROR_RETRY;
            }

            if( WSAECONNRESET == Error ) {
                //
                // Someone is sending ICMP port unreachable. Like we care.
                //
                DhcpPrint((DEBUG_ROGUE, "LOG WSARecvFrom returned WSAECONNRESET\n"));
                continue;
            }

            if( WSAENOTSOCK == Error ) {
                //
                // PnP Event blew away the socket? Ignore it
                //
                DhcpPrint((DEBUG_ROGUE, "PnP Event Blewaway the Socket\n"));
                continue;
            }
                
            //
            // Some weird error. LOG and return error..
            //
            DhcpPrint((DEBUG_ROGUE, "LOG: recvfrom failed %ld\n", Error));
            return Error;
        }

        RecvMessage = (PDHCP_MESSAGE) Info->RecvMessage;
        SendMessage = (PDHCP_MESSAGE) Info->SendMessage;
        if( SendMessage->TransactionID != RecvMessage->TransactionID ) {
            //
            // No fair.. some general response got picked up
            //
            continue;
        }

        Error = ExtractOptions(
            RecvMessage,&DhcpOptions, MsgLen
        );
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ROGUE, "LOG received message could't parse\n"));
            continue;
        }

        Source = (struct sockaddr_in *) &SockAddr;
        IpAddress = htonl(Source->sin_addr.s_addr);

        if( INADDR_ANY == IpAddress || (0xFFFFFFFF) == IpAddress ) {
            //
            // Illegal IP addresses..
            //
            continue;
        }
        
        if( IsThisOurAddress( IpAddress ) ) {
            DhcpPrint((DEBUG_ROGUE, "LOG ignoring packet from ourselves\n"));
            continue;
        }
        break;
    }

    Info->nResponses ++;
    Info->LastSeenIpAddress = IpAddress;
    Info->LastSeenDomain[0] = L'\0';

    if( DhcpOptions.DSDomainName ) {
        DomainName = DhcpOptions.DSDomainName;
        DomainNameW = NULL;
        DomainName[DhcpOptions.DSDomainNameLen] = '\0';
        MsgLen = mbstowcs(DomBuf, DomainName, sizeof(DomBuf)/sizeof(DomBuf[0]) );
        if( -1 != MsgLen ) {
            DomainNameW = DomBuf;
            DomBuf[MsgLen] = L'\0';
        }
        wcscpy(Info->LastSeenDomain, DomBuf);
    }

    if( NULL == DhcpOptions.DSDomainName || Info->fIsSamSrv ) {
        //
        // If this is a SAM serve, we got to quit.
        // Else if there is no domain, it ain't a problem.
        //
        return ERROR_SUCCESS;
    }


    if( Info->fIsWorkGroup ) {
        //
        // LOG this IP and domain name
        //
        DhcpPrint((DEBUG_ROGUE, "LOG Workgroup saw a domain\n"));
        return ERROR_SUCCESS;
    }


    if( 0 == _wcsicmp(DomainNameW, Info->DomainDnsName) ) {
        //
        // Same domain as ours.. LOG it
        //
        ROGUEAUDITLOG( DHCP_ROGUE_LOG_SAME_DOMAIN, IpAddress, Info->DomainDnsName, 0 );

        //
        // We do not drop same domain...
        //
        // return ERROR_SUCCESS;
    }

    //
    // Remove duplicates and queue these out there
    //

    if( IsThereDuplicateCachedEntry(
        &Info->CachedServersList, IpAddress, DomainNameW, NULL ) ) {
        DhcpPrint((DEBUG_ROGUE, "Entry exists already\n"));
        return ERROR_SUCCESS;
    }

    InsertCachedEntry(
        &Info->CachedServersList,
        IpAddress,
        FALSE,
        ROGUE_AUTH_NOT_CHECKED,
        DomainNameW,
        NULL
    );

    return ERROR_SUCCESS;
}

BOOL _stdcall
StopReceiveForEndpoint(
    IN OUT PENDPOINT_ENTRY Entry,
    IN PVOID Unused
    )
/*++

Routine Description:
    This routine turns of asnyc event notificaiton for the rogue
    detection socket on the given endpoint (assuming that the endpoint
    is bound).

Arguments:
    Entry -- endpoint entry.
    Unused -- unused variable.

Return Values:
    TRUE always.

--*/
{
    PENDPOINT Ep = (PENDPOINT) Entry;
    ULONG Error;

    //
    // Ignore unbound sockets.
    //
    if( !IS_ENDPOINT_BOUND(Ep) ) return TRUE;

    Error = WSAEventSelect( Ep->RogueDetectSocket, NULL, 0 );
    if( SOCKET_ERROR == Error ) {
        Error = WSAGetLastError();
        DhcpPrint((
            DEBUG_ROGUE, "LOG WSAEventSelect(NULL):%ld\n",Error
            ));
    }

    return TRUE;
}

VOID _inline
RogueStopReceives(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info
)
{
    ULONG Error,i;

    //
    // Set the socket to be synchronous removing the
    // binding to the wait hdl 
    //

    if( FALSE == Info->fDhcp ) {
        //
        // BINL has only one socket in use -- the RecvSocket.  
        //
        if( SOCKET_ERROR == WSAEventSelect(
            Info->RecvSocket, NULL, 0 ) ) {
            
            Error = WSAGetLastError();
            //
            // LOG error
            //
            DhcpPrint((
                DEBUG_ROGUE, " LOG WSAEventSelect(NULL,0)"
                " failed %ld\n", Error
                ));
        }
    } else {
        //
        // DHCP has the list of endpoints  to be taken care of
        //

        WalkthroughEndpoints(
            NULL,
            StopReceiveForEndpoint
            );
    }
    ResetEvent(Info->WaitHandle);
}

VOID _inline
RogueProcessAcks(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info
)
{
    ULONG Error;
    BOOL fDcIsDsEnabled;
    PLIST_ENTRY List;
    PCACHED_SERVER_ENTRY Entry;
    WCHAR DnsForestName[MAX_DNS_NAME_LEN];

    //
    // For each ACK that is from a domain (that is not ours) calculate if it
    // has a DS and if it does, find the root of the DS.
    // Process only entries that haven't been processed before.
    //

    while ( !IsListEmpty( (&Info->CachedServersList) ) ) {
        List = RemoveTailList( (&Info->CachedServersList) );
        Entry = CONTAINING_RECORD(List, CACHED_SERVER_ENTRY, List );

        if( Entry->fProcessed ) {
            InsertTailList( &Info->CachedServersList, &Entry->List );
            break;
        }

        Entry->fProcessed = TRUE;

        if( Entry->Domain ) {

            DhcpPrint((DEBUG_ROGUE, "LOG received server"
                       "[%lx] Domain: %ws\n", Entry->IpAddress,
                       Entry->Domain)); 
            Error = GetDcNameForDomain( 
                Entry->Domain, &fDcIsDsEnabled, DnsForestName
                );
            if( ERROR_SUCCESS != Error ) {
                //
                // Assume we're not authorized on this and set fSomeDsExists
                // Actually, since we can't see the domain, just assume that 
                // no DC exists.. and so same as fDcIsDsEnabled... 
                // So, do not set the fSomeDsExists..
                //
                Entry->Authorized = ROGUE_AUTH_NOT_CHECKED;
                
                // Info->fSomeDsExists = TRUE;

            } else if ( FALSE == fDcIsDsEnabled ) {

                DhcpPrint((DEBUG_ROGUE, "LOG server isn't part of a DS DC\n"));
                Entry->Authorized = ROGUE_AUTHORIZED;
            } else {

                Info->fSomeDsExists = TRUE;
                //
                // Need new context for DnsForestName
                //

                if( !IsThereDuplicateCachedEntry(
                    &Info->CachedServersList, Entry->IpAddress,
                    Entry->Domain, DnsForestName ) 
                ) {

                    DhcpPrint((DEBUG_ROGUE, "LOG Server is part of NEW DS %ws\n", DnsForestName));
                    Info->fSomeDsExists = TRUE;
                    InsertCachedEntry(
                        &Info->CachedServersList,
                        Entry->IpAddress,
                        TRUE,
                        ROGUE_AUTH_NOT_CHECKED,
                        Entry->Domain,
                        DnsForestName
                    );
                } else {
                    DhcpPrint((DEBUG_ROGUE, "LOG Server is part of OLD DS %ws\n", DnsForestName));
                }

                LocalFree( Entry );
                Entry = NULL;
            }
        }

        if( Entry ) InsertHeadList( &Info->CachedServersList, &Entry->List);
    }
}

ULONG _inline
ValidateServerInOtherDomains(
    IN OUT PDHCP_ROGUE_STATE_INFO Info
)
{
    ULONG Error;
    PLIST_ENTRY List;
    PCACHED_SERVER_ENTRY Entry;
    BOOL fDsError = FALSE, fFound, fIsStandAlone;

    //
    // For each entry in this validate to see if we are present in the
    // DS for any DS-ful entries.
    //

    for( List = Info->CachedServersList.Flink ;
         List != &Info->CachedServersList ;
         List = List->Flink
    ) {
        Entry = CONTAINING_RECORD(List, CACHED_SERVER_ENTRY, List );

        if( FALSE == Entry->fProcessed ) {
            continue;
        }

        if( NULL == Entry->Domain || Entry->Authorized != ROGUE_AUTH_NOT_CHECKED )
            continue;

        if( NULL == Entry->DnsForestName ) {
            //
            // Couldn't get the DS DC information for this -- ignore it???
            //
            // Entry->Authorized = ROGUE_UNAUTHORIZED;
            // return DHCP_ROGUE_UNAUTHORIZED;
            continue;
        }

        fFound = FALSE;
        Error = DhcpDsValidateService(
            Entry->Domain,
            NULL,
            0,
            NULL,
            0,
            ADS_SECURE_AUTHENTICATION,
            &fFound,
            &fIsStandAlone
        );
        if( ERROR_SUCCESS != Error ) {
            Entry->Authorized = ROGUE_UNAUTHORIZED;
            fDsError = TRUE;
        } else if( !fFound ) {
            Entry->Authorized = ROGUE_UNAUTHORIZED;
            return DHCP_ROGUE_UNAUTHORIZED;
        } else {
            Entry->Authorized = ROGUE_AUTHORIZED;
        }
    }

    return fDsError? DHCP_ROGUE_DSERROR: DHCP_ROGUE_AUTHORIZED;
}

VOID
CleanupCachedEntries(
    IN OUT PDHCP_ROGUE_STATE_INFO Info,
    IN BOOL fAllEntries
)
{
    PLIST_ENTRY List;
    PCACHED_SERVER_ENTRY Entry;

    List = Info->CachedServersList.Flink;

    while( List != &Info->CachedServersList ) {
        Entry = CONTAINING_RECORD( List, CACHED_SERVER_ENTRY, List );
        List = List->Flink;

        if( fAllEntries || FALSE == Entry->fProcessed ||
            ROGUE_AUTHORIZED != Entry->Authorized ) {
            //
            // Remove this entry!.
            //
            RemoveEntryList( &Entry->List );
            LocalFree(Entry);
        }
    }
}

VOID _inline
CleanupRogueStruct(
    IN OUT PDHCP_ROGUE_STATE_INFO Info
)
{
    CleanupCachedEntries( Info, TRUE);
    if( INVALID_SOCKET != Info->SendSocket ) closesocket(Info->SendSocket);
    if( INVALID_SOCKET != Info->RecvSocket ) closesocket(Info->RecvSocket);
    RtlZeroMemory( Info, sizeof(*Info) );
    Info->SendSocket = INVALID_SOCKET;
    Info->RecvSocket = INVALID_SOCKET;
    InitializeListHead (&Info->CachedServersList );
}

VOID
ValidateDsCacheInRegistry(
    IN PDHCP_ROGUE_STATE_INFO Info
)
/*++

Routine Description:
    This routine checks to see if the DS cache in registry is valid and if
    it is not valid, it clears the registry.

    When this routine is called, it is assumed that the domain name
    information is set in Info (as well as whether this domain is DS
    enabled or not).

    It does nothing, other than set the Info->fJustUpgraded flag if the
    machine just upgraded to NT5.

--*/
{
    ULONG Error;
    BOOL fResult, fUpgrade, fAuthorized;

    Info->fJustUpgraded = FALSE;
    Info->CachedAuthStatus = ROGUE_AUTH_NOT_CHECKED;

    if( Info->fIsSamSrv ) return;

    if( Info->fIsWorkGroup ) {
        fResult = DhcpGetAuthStatus( NULL, &fUpgrade, &fAuthorized );
        DhcpSetAuthStatus( NULL, fUpgrade, TRUE );
        return;
    }

    fResult = DhcpGetAuthStatus(
        Info->DomainDnsName, &fUpgrade, &fAuthorized 
        );

    Info->fJustUpgraded = fUpgrade;

    if( FALSE == fResult ) {
        Info->CachedAuthStatus = ROGUE_AUTH_NOT_CHECKED;
    } else {
        Info->CachedAuthStatus = (
            fAuthorized? DHCP_ROGUE_AUTHORIZED : DHCP_ROGUE_UNAUTHORIZED
            ); 
    }
    
    //
    // If there was any information pertaining to any other domain than
    // what is there currently, then we got to lose that information..
    // But we retain information on possible upgrade .. 
    //
    if( FALSE == fResult ) {
        DhcpSetAuthStatus( NULL, fUpgrade, FALSE );
    }
}

BOOL
ServiceCheckForDomain(
    IN PDHCP_ROGUE_STATE_INFO Info
)
/*++

Routine Description:
    Do the service validation check for server in Domain:

    1.  If just upgraded to NT5, then start service (and update DS cache
        just in case even thought it isn't consulted.)

    2.  


Return Value:
    TRUE --> Enable Service. FALSE --> Disable Service.

--*/
{
    ULONG Error;

    if( Info->fJustUpgraded ) {
        //
        // Special case -- just upgraded to NT5 ? No DS Checks really.
        // Just update the registry DS cache for DS-validation even though
        // this isn't used for enabling/disabling service in current state.
        //
        ROGUEAUDITLOG(
            DHCP_ROGUE_LOG_UPGRADED, 0, Info->DomainDnsName, 0
            );
        
        Error = ValidateServer(Info);
        if( DHCP_ROGUE_AUTHORIZED == Error ) {
            DhcpSetAuthStatus(
                Info->DomainDnsName, Info->fJustUpgraded, TRUE 
                );
        } else if( DHCP_ROGUE_UNAUTHORIZED == Error ) { 
            DhcpSetAuthStatus(
                CFLAG_ALLOW_NEGATIVE_CACHING?Info->DomainDnsName:NULL, 
                Info->fJustUpgraded, FALSE
                );
        }

        return TRUE;
    }

    //
    // Not an upgrade?  Two cases -- DS available, DS not
    // available. 
    //

    if( FALSE == Info->fDcIsDsEnabled ) {
        //
        // No DS-DC is available -- just use cached information.. 
        //
        ROGUEAUDITLOG( DHCP_ROGUE_LOG_NO_DSDC, 0,
               Info->DomainDnsName, 0 );
    ROGUEEVENTLOG( EVENT_SERVER_COULDNT_SEE_DS, 0,
               NULL, 0 );
        return ( DHCP_ROGUE_UNAUTHORIZED != Info->CachedAuthStatus);
    }

    //
    // DS is present -- try to reach it.
    //

    Error = ValidateServer(Info);
    if( DHCP_ROGUE_AUTHORIZED == Error ) {
        //
        // Authorized in DS
        //
        ROGUEAUDITLOG( 
            DHCP_ROGUE_LOG_AUTHORIZED, 0, 
            Info->DomainDnsName, 0 
            );
        DhcpSetAuthStatus(
            Info->DomainDnsName, FALSE, TRUE 
            );

        Info->CachedAuthStatus = DHCP_ROGUE_AUTHORIZED;
        return TRUE;
    } 
    
    if( DHCP_ROGUE_UNAUTHORIZED == Error ||
        DHCP_ROGUE_AUTHORIZED != Info->CachedAuthStatus ) {

        ULONG TimeNow = (ULONG) time(NULL);
        //
        // Server specifically unathorized or no cache
        // authorization either
        //
        
        ROGUEAUDITLOG( 
            DHCP_ROGUE_LOG_UNAUTHORIZED, 0,
            Info->DomainDnsName, 0
            );

    if( TimeNow >= Info->LastUnauthLogTime + RogueAuthRecheckTime ) {
            Info->LastUnauthLogTime = TimeNow;
            
            ROGUEEVENTLOG( 
                DHCP_ROGUE_EVENT_UNAUTHORIZED, 0,
                Info->DomainDnsName, 0
                );
        }

        if( DHCP_ROGUE_UNAUTHORIZED == Error ) {
            DhcpSetAuthStatus(
                CFLAG_ALLOW_NEGATIVE_CACHING?Info->DomainDnsName: NULL, 
                FALSE, FALSE 
                );
            Info->CachedAuthStatus = DHCP_ROGUE_UNAUTHORIZED;
        }

        //
        // Note that if DS is not reachable for various errors
        // including lack of access, then the service will start?
        // ugh. ugh. 
        //
        return (DHCP_ROGUE_UNAUTHORIZED != Info->CachedAuthStatus);
    } 

    //
    // Was authorized via the CachedAuthStatus
    //

    ROGUEAUDITLOG( 
        DHCP_ROGUE_LOG_PREAUTHORIZED, 0,
        Info->DomainDnsName, 0
        );
    return TRUE;
}

VOID
CheckAndWipeOutUpgradeInfo(
    IN PDHCP_ROGUE_STATE_INFO Info
)
/*++

Routine Description:
    This routine checks to see if a DS is currently available 
    and if so, it wipes out the "UPGRADED" information in the
    registry..

--*/
{
    BOOL fResult, fUpgrade, fAuthorized;

    if( FALSE == Info->fIsSamSrv 
        && FALSE == Info->fIsWorkGroup ) {
        GetDsDcName(Info);
        if( Info->fDcIsDsEnabled ) {
            //
            // Ok -- DS _is_ around.. so wipe out upgrade info.
            //
            DhcpSetAuthStatusUpgradedFlag(
                FALSE
                );
        }
    }
}

BOOL _inline
GetDomainNameInfo(
    IN OUT PDHCP_ROGUE_STATE_INFO Info
)
/*++

Routine Description:
    This routine is a collection of assorted items to do in init state --
    essentially get information such as domain-name etc which is available
    without network being present and which won't get changed for a boot.

Return Value:
    returns TRUE on success and FALSE on failure (fatal)

--*/
{
    ULONG Error;

    if( Info->fIsSamSrv ) {
        //
        // SBS SRV -- don't bother about domains.
        //
        
        return TRUE;
    }

    Info->fIsWorkGroup = FALSE;
    Info->fDcIsDsEnabled = TRUE;
    Error = GetDomainName(Info);
    
    //
    // ABORT -- fatal error - can't find Domain name
    //
    
    if( ERROR_SUCCESS != Error ) {
        ROGUEAUDITLOG( 
            DHCP_ROGUE_LOG_CANT_FIND_DOMAIN, 0, NULL, Error
            ); 
        ROGUEEVENTLOG( 
            DHCP_ROGUE_EVENT_CANT_FIND_DOMAIN, 0, NULL, Error 
            );
        
        DhcpPrint((DEBUG_ROGUE, "FATAL Couldn't get domain name\n"));
        return FALSE;
    }
        
    DhcpPrint((DEBUG_ROGUE, "LOG domain name = %ws\n",
               Info->fIsWorkGroup? L"[WorkGroup]"
               :Info->DomainDnsName )); 

    if( Info->fIsWorkGroup ) {
        //
        // Done for workgroups..
        //
        return TRUE;
    }

    //
    // For machines belonging to a DOMAIN -- format domain name
    // to send out when other servers query via inform..
    //

    DhcpGlobalDSDomainAnsi = LocalAlloc(
        LPTR,MAX_DNS_NAME_LEN 
        ); 
    if( NULL != DhcpGlobalDSDomainAnsi ) {
        wcstombs(
            DhcpGlobalDSDomainAnsi, 
            Info->DomainDnsName, 
            sizeof(Info->DomainDnsName)
            );
    }

    return TRUE;
}

BOOL _inline
CatchRedoAndNetReadyEvents(
    IN OUT PDHCP_ROGUE_STATE_INFO Info,
    IN ULONG TimeNow,
    OUT PULONG RetVal
)
/*++

Routine Description:
    Handle all kinds of redo-authorization requests as well as network
    ready events..  In case the state machine has been processed for this
    state, this routine returns TRUE indicating no more processing needs to
    be done -- just the return value provided in the second parameter
    should be returned.

    If DhcpGlobalRedoRogueStuff is set, then the value of the variabe
    DhcpGlobalRogueRedoScheduledTime is checked to see if we have to redo
    rogue detection right away or at a later time.. (depending on whether
    this value is in the past or current..)  If rogue detection had been
    scheduled explicitly, then we wipe out any upgrade information that we
    have (if we can see a DS enabled DC that is).  If the auth-check is
    scheduled for a time in future, the routine returns TRUE and sets the
    retval to the time diff to the scheduled time of auth-check.

Arguments:
    Info -- state info
    TimeNow -- current time
    RetVal -- Value to return from state machine if routine returns TRUE.

Return Value:
    FALSE -- indicating processing has to continue..
    TRUE -- processing has to stop, and RetVal has to be returned.
--*/
{
    if( DhcpGlobalRedoRogueStuff ) {

        //
        // Asked to restart Rogue detection?
        //

        Info->RogueState = ROGUE_STATE_START;
        RogueStopReceives( Info );
        ResetEvent(Info->WaitHandle);

        if( TimeNow < DhcpGlobalRogueRedoScheduledTime ) {
            //
            // Scheduled re-start time is in future.. wait until then..
            //
            *RetVal = ( DhcpGlobalRogueRedoScheduledTime - TimeNow );
            return TRUE;
        } else {
            if( 0 != DhcpGlobalRogueRedoScheduledTime ) {
                //
                // Specifically scheduled redo? Then we must
                // remove upgrade information if DS-enabled DC
                // is found
                //
                CheckAndWipeOutUpgradeInfo(Info);
            }
        }
        DhcpGlobalRedoRogueStuff = FALSE;
    }

    if( Info->fDhcp && Info->RogueState != ROGUE_STATE_INIT
        && 2 == Info->NoNetTriesCount
        && 0 == DhcpGlobalNumberOfNetsActive ) {
        //
        // No sockets that the server is bound to.  BAM!
        // No point doing any rogue detection.  Doesn't matter if we 
        // are authorized in the DS or not.  Lets go back to start and
        // wait till this situation is remedied.
        //

        Info->RogueState = ROGUE_STATE_START;
        RogueStopReceives( Info );

        *RetVal = INFINITE;
        return TRUE;
    }
    
    return FALSE;
}

ULONG
APIENTRY
RogueDetectStateMachine(
    IN OUT PDHCP_ROGUE_STATE_INFO Info OPTIONAL
)
/*++

Routine Description

    This routine is the Finite State Machine for the Rogue Detection
    portion of the DHCP server.  State is maintained in the Info struct
    especially the RogueState field.

    The various states are defined by the enum DHCP_ROGUE_STATE.

    This function returns the timeout that has to elapse before a
    state change can happen.  The second field <WaitHandle> is
    used for non-fixed state changes and it would be signalled if
    a state change happened asynchronously.  (This is useful to
    handle new packet arrival)  This field MUST be filled by caller.

    This handle should initially be RESET by the caller but after that
    the caller should not reset it, that is handled within by this
    function. (It must be a manual-reset function)

    The terminate event handle is used to signal termination and to
    initiate shutdown of the service.  This field MUST also be filled
    by caller.

Arguments

    Info -- Ptr to struct that holds all the state information

Return value

    This function returns the amount of time the caller is expected
    to wait before calling again.  This is in seconds.

    INFINITE -- this value is returned if the network is not ready yet.
       In this case, the caller is expected to call again soon after the
       network becomes available.

       This value is also returned upon termination...
--*/
{

    ULONG Error, TimeNow, RetVal;
    BOOL  fEnable;
    DWORD DisableRogueDetection = 0;

    Error = DhcpRegGetValue( DhcpGlobalRegParam,
                 DHCP_DISABLE_ROGUE_DETECTION,
                 DHCP_DISABLE_ROGUE_DETECTION_TYPE,
                 ( LPBYTE ) &DisableRogueDetection 
                 );
    if (( ERROR_SUCCESS == Error ) &&
    ( 0 != DisableRogueDetection )) {
    DhcpGlobalOkToService = TRUE;
    DhcpPrint(( DEBUG_ROGUE,
            "Rogue Detection Disabled\n"
            ));
    return INFINITE;
    } // if

    //
    // DHCP code passes NULL, BINL passes valid context
    //
    if( NULL == Info ) Info = &DhcpGlobalRogueInfo;
    TimeNow = (ULONG) time(NULL);

    //
    // Preprocess and check if we have to restart rogue detection..
    // or if the network just became available etc...
    // This "CatchRedoAndNetReadyEvents" would affect the state..
    //

    if( CatchRedoAndNetReadyEvents( Info, TimeNow, &RetVal ) ) {
        //
        // Redo or NetReady event filter did all the work
        // in this state... So, we should just return RetVal..
        //
        return RetVal;
    }

    //
    // NOTE THAT THIS CODE HAS THE
    // SWITCH STATEMENT WITH FALL THROUGHS EVERYWHERE!
    //

    while( TRUE ) switch ( Info->RogueState ) {
    case ROGUE_STATE_INIT :

        InitializeListHead( &Info->CachedServersList );
        Info->fIsSamSrv = AmIRunningOnSBSSrv();
        if( !GetDomainNameInfo(Info) ) {
            //
            // Error occurred!
            //
            goto Exit;
        }

        Error = RogueNetworkInit(Info);
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ROGUE, "FATAL Couldn't initialize"
                       " network: %ld\n", Error)); 
            ROGUEAUDITLOG( 
                DHCP_ROGUE_LOG_NETWORK_FAILURE, 0, NULL, Error
                );
            ROGUEEVENTLOG( 
                DHCP_ROGUE_EVENT_NETWORK_FAILURE, 0, NULL, Error
                );
            goto Exit;
        }

        Info->fDcIsDsEnabled = Info->fIsWorkGroup;
        if( FALSE == Info->fIsWorkGroup ) {
            Info->GetDsDcNameRetries = 0;
        }

        Info->RogueState = ROGUE_STATE_START;

    case ROGUE_STATE_START :

        if( Info->fDhcp && 0 == DhcpGlobalNumberOfNetsActive ) {
            ULONG RetVal;
            
            //
            // If there are no nets available at this time, then wait till
            // network becomes available again.
            //
            Info->RogueState = ROGUE_STATE_START;

            RetVal = INFINITE;
            if( 0 == Info->NoNetTriesCount ) {
                //
                // First time we are hitting this path.  Just return
                // some reasonable wait time to see if network is
                // available.
                //
                RetVal = DHCP_ROGUE_FIRST_NONET_TIME;
                Info->NoNetTriesCount ++;
            } else if( 1 == Info->NoNetTriesCount ) {
                //
                // Ok we have seen this exactly once before.
                // Log event.
                //
                Info->NoNetTriesCount ++;
                ROGUEAUDITLOG(
                    DHCP_ROGUE_LOG_NO_NETWORK, 0, NULL, 0
                    );
                ROGUEEVENTLOG(
                    DHCP_ROGUE_EVENT_NO_NETWORK, 0, NULL, 0
                    );
            }

            return RetVal;
        }

        if( Info->fDhcp ) {
            //
            // DhcpGlobalNumberOfNetsActive MUST be non-zero.
            // So, update Info->NoNetTriesCount.. so that no logs
            // are done ever after this.
            //
            Info->NoNetTriesCount = 2;
        }
        
        //
        // Domain Member only checks mainly to see if DS exists and we are
        // authorized in it.  If DS exists, record fact if we are authorized
        // or not authorized into the SECRET key. If server is not authorized,
        // we wait for some time and loop to this state.
        //

        if( FALSE == Info->fIsSamSrv && FALSE == Info->fIsWorkGroup ) {

            Info->GetDsDcNameRetries ++;
            Error = GetDsDcName(Info);

            if( (ERROR_SUCCESS != Error || FALSE == Info->fDcIsDsEnabled)  
                && Info->GetDsDcNameRetries <= DHCP_GET_DS_ROOT_RETRIES ) {

                //
                // RETRY to get the DS DC name.
                //

                return DHCP_GET_DS_ROOT_TIME;
            }

        }

        ValidateDsCacheInRegistry(Info);
        Info->StartTime = (ULONG) time(NULL);

        if( FALSE == Info->fIsSamSrv && FALSE == Info->fIsWorkGroup ) {

            //
            // RESET count - loop restarts if state changes to ROGUE_STATE_START
            //

            Info->GetDsDcNameRetries = 0;

            fEnable = ServiceCheckForDomain(Info);
            
            //
            // Only if we are disabling a service do we do that.. If
            // service needs to be enabled, it will be done after one round
            // of successful informs.
            //
            if( !fEnable ) {
                EnableOrDisableService(
                    Info,
                    fEnable,
                    (DhcpGlobalOkToService == fEnable)
                    );
            }
            if( !fEnable ) return DHCP_ROGUE_RUNTIME_RESTART_LONG;
        }

        Info->LastSeenIpAddress = 0;
        Info->LastSeenDomain[0] = L'\0';

        CleanupCachedEntries( Info, FALSE );
        Info->ProcessAckRetries = 0;

    case ROGUE_STATE_PREPARE_SEND_PACKET:

        Info->InformsSentCount = 0;
        Info->fSomeDsExists = FALSE;
        Info->nResponses = 0;

    case ROGUE_STATE_SEND_PACKET :

        Error = RogueSendDhcpInform(Info, (0 == Info->InformsSentCount));
        if( ERROR_SUCCESS != Error ) {
            //
            // ERROR - Couldn't send any inform!!!
            //

            Info->RogueState = ROGUE_STATE_START;
            return DHCP_ROGUE_RESTART_NET_ERROR;
        }

        DhcpPrint((DEBUG_ROGUE, "LOG -- Sent an INFORM\n"));
        Info->InformsSentCount ++;
        Info->WaitForAckRetries = 0;

        Info->RogueState = ROGUE_STATE_WAIT_FOR_RESP;
        Info->ReceiveTimeLimit = (ULONG)(time(NULL) + DHCP_ROGUE_WAIT_FOR_RESP_TIME);
        return DHCP_ROGUE_WAIT_FOR_RESP_TIME;

    case ROGUE_STATE_WAIT_FOR_RESP :

        Error = RogueReceiveAck(Info);
        Info->WaitForAckRetries ++;

        if( ERROR_SUCCESS == Error ) {
            if( Info->fIsSamSrv || (Info->fIsWorkGroup && Info->LastSeenDomain[0]) ) {
                //
                // FATAL Sam server saw a DHCP server out there!
                // FATAL or Workgroup server saw a Domain out there!
                //

                ROGUEAUDITLOG( 
                    Info->fIsWorkGroup ? DHCP_ROGUE_LOG_OTHER_SERVER 
                    : DHCP_ROGUE_LOG_SAM_OTHER_SERVER,
                    Info->LastSeenIpAddress,
                    Info->LastSeenDomain,
                    0
                    );
                ROGUEEVENTLOG( 
                    Info->fIsWorkGroup ? DHCP_ROGUE_EVENT_OTHER_SERVER 
                    : DHCP_ROGUE_EVENT_SAM_OTHER_SERVER,
                    Info->LastSeenIpAddress,
                    Info->LastSeenDomain,
                    0
                );
                goto Exit;
            }
        }
        
        TimeNow = (ULONG) time(NULL);
        if( ERROR_SEM_TIMEOUT != Error
            && Info->WaitForAckRetries <= DHCP_MAX_ACKS_PER_INFORM
            && TimeNow < Info->ReceiveTimeLimit ) {
            //
            // Continue to receive ACKS -- we can process them later.
            //

            return Info->ReceiveTimeLimit - TimeNow;
        }

        if( Info->InformsSentCount < DHCP_ROGUE_MAX_INFORMS_TO_SEND ) {
            //
            // We can still send some informs and collect more acks..
            // DO NOT RETURN -- just switch state and continue
            // in the main while(TRUE) loop
            //

            Info->RogueState = ROGUE_STATE_SEND_PACKET;
            continue;
        }

        //
        // We do not wish to do any more receives for a while.
        //
        RogueStopReceives(Info);

    case ROGUE_STATE_PROCESS_RESP :

        Info->ProcessAckRetries ++;

        DhcpPrint((DEBUG_ROGUE, "LOG-- processing ACKS\n"));
        if( Info->fIsSamSrv ) {
            //
            // SAM server -- couldn't have received any offers really.
            // if we had, then we would have been caught in the previous
            // state, and exited....
            // start service and continue sending discovers..
            //
            
            ASSERT( 0 == Info->nResponses);
            EnableOrDisableService( Info, TRUE, DhcpGlobalOkToService );
            Info->RogueState = ROGUE_STATE_PREPARE_SEND_PACKET;
            
            if( 1 == Info->ProcessAckRetries ) {
                return DHCP_ROGUE_RUNTIME_DELTA;
            } 
            return DHCP_ROGUE_RUNTIME_DELTA_LONG;
        }

        RogueProcessAcks(Info);

        if( Info->fSomeDsExists ) {
            //
            // If this were a workgroup or SBS server, we'd have quit by
            // now much earlier than this..
            //
            DhcpAssert( Info->DomainDnsName[0] );
        }

        //
        // code to validate the server in other DS's is removed
        //

        EnableOrDisableService( Info, TRUE , DhcpGlobalOkToService );

    if( (time(NULL) - Info->StartTime) > RogueAuthRecheckTime ) {
            //
            // Its time to re-start algorithmm...
            //
            ROGUEAUDITLOG( DHCP_ROGUE_LOG_RESTART , 0, NULL, 0);
            Info->RogueState = ROGUE_STATE_START;
            return DHCP_ROGUE_RUNTIME_RESTART;
        }

        //
        // just redo the send inform, receive acks, process acks loop
        //

        DhcpPrint((DEBUG_ROGUE, "LOG -- redo the whole thing\n"));
        Info->RogueState = ROGUE_STATE_PREPARE_SEND_PACKET;
        if( Info->ProcessAckRetries == 1) return DHCP_ROGUE_RUNTIME_DIFF;
        return DHCP_ROGUE_RUNTIME_DIFF_LONG;
    }


  Exit:

    ROGUEEVENTLOG( DHCP_ROGUE_EVENT_SHUTDOWN, 0, NULL, 0 );

    SetEvent(Info->TerminateEvent);
    if( ROGUE_STATE_INIT != Info->RogueState ) {
        //
        // If we failed right at start.. can't go back to any other
        // state if someone uses this without re-starting..
        // But otherwise, we can restart the whole shebang and to do
        // that we have to fake a ROGUE_STATE_START state, as here.
        //

        Info->RogueState = ROGUE_STATE_START;
        Info->GetDsDcNameRetries = 0;
    }

    return INFINITE;
}

DWORD
APIENTRY
DhcpRogueInit(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info  OPTIONAL,
    IN      HANDLE                 WaitEvent,
    IN      HANDLE                 TerminateEvent
)
/*++

Routine Description

    This routine initializes the rogue information state.  It does
    not really allocate much resources and can be called over multiple
    times.

Arguments

    Info -- this is a pointer to a struct to initialize. If NULL, a global
    struct is used.

    WaitEvent -- this is the event that caller should wait on for async changes.

    TerminateEvent -- this is the event that caller should wait on to know when
    to terminate.

    Return Values

    Win32 errors

Environment

    Any.  Thread safe.

--*/
{
    DWORD Error;

    if ( NULL == Info ) {

        Info = &DhcpGlobalRogueInfo;
        
    } else {

        Error = DhcpInitGlobalData( FALSE );
        if (Error != ERROR_SUCCESS) {
            return Error;
        }
    }

    if( INVALID_HANDLE_VALUE == WaitEvent || NULL == WaitEvent )
        return ERROR_INVALID_PARAMETER;
    if( INVALID_HANDLE_VALUE == TerminateEvent || NULL == TerminateEvent )
        return ERROR_INVALID_PARAMETER;

    if( Info->fInitialized ) return ERROR_SUCCESS;
    RtlZeroMemory(Info, sizeof(*Info));
    Info->WaitHandle = WaitEvent;
    Info->TerminateEvent = TerminateEvent;
    Info->SendSocket = INVALID_SOCKET;
    Info->RecvSocket = INVALID_SOCKET;
    InitializeListHead( &Info->CachedServersList );
    Info->fInitialized = TRUE;
    Info->fLogEvents = (
        (Info == &DhcpGlobalRogueInfo) 
        && (0 != DhcpGlobalRogueLogEventsLevel)
        );  
    DhcpGlobalRedoRogueStuff = FALSE;
    Info->fDhcp = (Info == &DhcpGlobalRogueInfo );

    // Get the Auth recheck time from the registry
    Error = DhcpRegGetValue( DhcpGlobalRegParam,
                 DHCP_ROGUE_AUTH_RECHECK_TIME,
                 DHCP_ROGUE_AUTH_RECHECK_TIME_TYPE,
                 ( LPBYTE ) &RogueAuthRecheckTime
                 );
    if ( ERROR_SUCCESS != Error ) {
    // The key is not present, use the default value
    RogueAuthRecheckTime = ROGUE_DEFAULT_AUTH_RECHECK_TIME;
    } // if
    else {
    // RogueAuthRecheckTime is in minutes, convert it to seconds
    RogueAuthRecheckTime *= 60;
    if ( RogueAuthRecheckTime < ROGUE_MIN_AUTH_RECHECK_TIME ) {
        RogueAuthRecheckTime = ROGUE_MIN_AUTH_RECHECK_TIME;

        // should we update the registry with the default value?
    } // if 
    } // else 

    return ERROR_SUCCESS;
} // DhcpRogueInit()

VOID
APIENTRY
DhcpRogueCleanup(
    IN OUT  PDHCP_ROGUE_STATE_INFO Info OPTIONAL
)
/*++

Routine Description

    This routine de-initializes any allocated memory for the Info structure
    passed in.

Arguments

    Info -- this is the same value that was passed to the DhcpRogueInit function.
            If the original pointer passed was NULL, this must be NULL too.

--*/
{
    BOOLEAN cleanup;

    if ( NULL == Info ) {

        Info = &DhcpGlobalRogueInfo;
        cleanup = FALSE;

    } else {

        cleanup = TRUE;
    }

    if( FALSE == Info->fInitialized ) return ;
    CleanupRogueStruct(Info);
    Info->fInitialized = FALSE;
    DhcpGlobalRedoRogueStuff = FALSE;

    if (cleanup) {
        DhcpCleanUpGlobalData( ERROR_SUCCESS, FALSE );
    }
}

VOID
DhcpScheduleRogueAuthCheck(
    VOID
)
/*++

Routine Description:
    Thsi routine schedules an authorization check
    for three minutes from teh current time.

--*/
{
    if( FALSE == DhcpGlobalRogueInfo.fJustUpgraded ) {
        //
        // Don't need one here..
        //
        return;
    }

    DhcpGlobalRogueRedoScheduledTime = (ULONG)(time(NULL) + 3 * 60);
    DhcpGlobalRedoRogueStuff = TRUE;
    SetEvent( DhcpGlobalRogueWaitEvent );
}

BOOLEAN
DhcpRogueAcceptEnterprise(
    IN      PCHAR                  ClientDomain,
    IN      ULONG                  ClientDomLen
)
/*++

Routine Description:

    This function determines whether we should respond to a request from a client
    that belongs to a different enterprise

Arguments:

    ClientDomain - string containing the client's enterprise
    ClientDomLen - length of this string

Return Value:

    TRUE if we should respond to this request
    FALSE if we should ignore this request

--*/
{
    LPWSTR                         Domain;
    ULONG                          Count;
    BOOL                           fIsEnabled;
    BOOLEAN                        RetVal;
    WCHAR                          DnsForestName[MAX_DNS_NAME_LEN];


#ifndef ROGUE_STRICT
    return TRUE;
#endif

    if( DhcpGlobalRogueInfo.fIsWorkGroup || DhcpGlobalRogueInfo.fIsSamSrv
        || FALSE == DhcpGlobalRogueInfo.fDcIsDsEnabled || 0 == ClientDomLen) {
        return FALSE;
    }

    Domain = LocalAlloc(LPTR, sizeof(WCHAR) * ( 1 + ClientDomLen ) );
    if( NULL == Domain ) return FALSE;

    Count = mbstowcs(Domain, ClientDomain, ClientDomLen );
    if( -1 == Count ) {
        LocalFree(Domain);
        return FALSE;
    }
    Domain[Count] = L'\0';

    RetVal = FALSE;
    if( ERROR_SUCCESS == GetDcNameForDomain(Domain, &fIsEnabled, DnsForestName ) ) {
        RetVal = (fIsEnabled &&
                  (0 != DnsNameCompare(DnsForestName, DhcpGlobalRogueInfo.DnsForestName))
        );
    }

    LocalFree(Domain);
    return RetVal;
}

#if DBG
VOID
APIENTRY
TestRogue(
    VOID
)
{
    HANDLE  Handles[2];
    DHCP_ROGUE_STATE_INFO Info;
    WCHAR Domain[MAX_DNS_NAME_LEN];
    WCHAR DnsForestName[MAX_DNS_NAME_LEN];
    ULONG SecondsToSleep, SleepTime, Error;
    WSADATA wsaData;
    ULONG SamSrv;
    BOOL fIsSamSrv;
    ULONG Flag;
    ULONG DhcpTestInitialize(void);

    WSAStartup( MAKEWORD(1,1) , &wsaData );
    DhcpTestInitialize();

    Handles[0] = CreateEvent( NULL, FALSE, FALSE, NULL );
    Handles[1] = CreateEvent( NULL, TRUE, FALSE, NULL );

    Error = DhcpRogueInit( &Info, Handles[1], Handles[0] );
    if( ERROR_SUCCESS != Error ) {
        printf("DhcpRogueInit failed %ld\n", Error);
        return;
    }

    printf("Do you want to manually configure domain details etc? [0 = NO, 1 = YES] : ");
    scanf("%ld", &Flag);
    if( Flag ) {
        printf( "Is this a SAM Server? [0 = NO, 1 = YES]: ");
        scanf("%ld", &SamSrv);
        if( SamSrv ) fIsSamSrv = TRUE;
        else {
            fIsSamSrv = FALSE;
            FakeIsSamSrv = &fIsSamSrv;

            printf("Machine DomainName [FQDN] to use ? [enter NONE for no domain]: ");
            scanf("%ws", Domain );

            FakeDomain = Domain;
            if( wcscmp(Domain, L"NONE") ) {
                printf("DnsForestName [FQDN] to use ? [enter NONE for no dns forest name]: \n");
                scanf("%ws", DnsForestName);

                FakeDnsForestName = DnsForestName;
            }
        }
    }

    do {
        SecondsToSleep = RogueDetectStateMachine(&Info);
        if( INFINITE == SecondsToSleep ) {
            SleepTime = INFINITE;
        } else {
            SleepTime = SecondsToSleep * 1000;
        }

        printf("SLEEPING %ld msecs\n", SleepTime);
        Error = WaitForMultipleObjects(2, Handles, FALSE, SleepTime );
        if( WAIT_OBJECT_0 == Error ) break;

        if( WAIT_OBJECT_0+1 == Error ) {
        } else if( WAIT_TIMEOUT != Error ) {
            break;
        }

    } while ( TRUE );

    printf("Wait failed? Error = %ld \n", GetLastError());

    DhcpRogueCleanup(&Info);
}
#endif DBG


//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\roguet.c ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:

    roguet.c

Abstract:

    test program for rogue detection

Author:

    Ramesh V (RameshV) 03-Aug-1998

Environment

    User Mode - Win32

Revision History

--*/

#include <dhcpsrv.h>

void _cdecl main (void) {
    void APIENTRY TestRogue(void);

    TestRogue();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\rpcapi2.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: all non-option/class related stuff are here. mostly subnet related.
// some also deal with the database.  RPC and their helper functions
//  -- For options related RPC implementation, pl look at rpcapi1.c.
//================================================================================

//================================================================================
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  GENERAL WARNING: Most of the routines in this file allocate memory using
//  MIDL functions because they are used in the RPC code path (??? Really, it
//  because that is how they were written before by Madan Appiah and co? )
//  So, BEWARE.   If you read this after getting burnt, there! I tried to tell ya.
//  -- RameshV
//================================================================================

#include    <dhcppch.h>
#include    <rpcapi.h>
#define     CONFIG_CHANGE_CHECK()  do{if( ERROR_SUCCESS == Error) DhcpRegUpdateTime(); } while(0)

//BeginExport(function)
DWORD
DhcpUpdateReservationInfo(                        // this is used in cltapi.c to update a reservation info
    IN      DWORD                  Address,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDLength
) //EndExport(function)
{
    DWORD                          Error;
    DWORD                          Flags;
    PM_SUBNET                      Subnet;
    PM_RESERVATION                 Reservation;

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        Address,
        &Subnet,
        NULL,
        NULL,
        &Reservation
    );

    if( ERROR_SUCCESS != Error ) {
        DhcpAssert(FALSE);
        return Error;
    }

    DhcpAssert(Reservation && Subnet);
    Error = MemReserveReplace(
        &(Subnet->Reservations),
        Address,
        Flags = Reservation->Flags,
        ClientUID,
        ClientUIDLength
    );

    return Error;
}

DWORD
DhcpSetSuperScopeV4(
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPWSTR                 SScopeName,
    IN      BOOL                   ChangeExisting
)
{
    DWORD                          Error;
    DWORD                          SScopeId;
    PM_SERVER                      Server;
    PM_SUBNET                      Subnet;
    PM_SSCOPE                      SScope;

    Server = DhcpGetCurrentServer();

    Error = MemServerGetAddressInfo(
        Server,
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_SUBNET_NOT_PRESENT;

    if( NULL == SScopeName ) {                    // remove this subnet from whatever sscope it is in
        SScopeId = Subnet->SuperScopeId;
        Subnet->SuperScopeId = 0;                 // removed it

        return NO_ERROR;
    }

    if( FALSE == ChangeExisting && 0 != Subnet->SuperScopeId ) {
        // Found this element in some other super scope .. return error
        return ERROR_DHCP_SUBNET_EXITS;
    }

    Error = MemServerFindSScope(
        Server,
        0,
        SScopeName,
        &SScope
    );
    if( ERROR_SUCCESS != Error ) {                // no supserscope exists by this name... create one
        Error = MemSScopeInit(
            &SScope,
            0,
            SScopeName
        );
        if( ERROR_SUCCESS != Error ) return Error;
        Error = MemServerAddSScope(Server,SScope);
        DhcpAssert( ERROR_SUCCESS == Error );
    }

    Subnet->SuperScopeId = SScope->SScopeId;

    return Error;
}

DWORD
DhcpDeleteSuperScope(
    IN      LPWSTR                 SScopeName
)
{
    DWORD                          Error;
    DWORD                          SScopeId;
    PM_SSCOPE                      SScope;
    ARRAY_LOCATION                 Loc;
    PARRAY                         pArray;
    PM_SUBNET                      Subnet;

    if( NULL == SScopeName ) return ERROR_INVALID_PARAMETER;

    Error = MemServerFindSScope(
        DhcpGetCurrentServer(),
        0,
        SScopeName,
        &SScope
    );
    if( ERROR_FILE_NOT_FOUND == Error ) {
        return ERROR_DHCP_SUBNET_NOT_PRESENT;
    }
    if( ERROR_SUCCESS != Error) return Error;

    DhcpAssert(SScope);
    Error = MemServerDelSScope(
        DhcpGetCurrentServer(),
        SScopeId = SScope->SScopeId,
        &SScope
    );
    DhcpAssert(ERROR_SUCCESS == Error && NULL != SScope );
    Error = MemSScopeCleanup(SScope);
    DhcpAssert( NO_ERROR == Error );

    //
    // Now find subnets that have this as the superscope and
    // change all of them to have no superscopes
    //

    pArray = &DhcpGetCurrentServer()->Subnets;
    Error = MemArrayInitLoc(pArray, &Loc);

    while( NO_ERROR == Error ) {
        
        Error = MemArrayGetElement(pArray, &Loc, (LPVOID *)&Subnet);
        DhcpAssert(ERROR_SUCCESS == Error && Subnet);

        if( Subnet->SuperScopeId == SScopeId ) {
            Subnet->SuperScopeId = 0;
        }

        Error = MemArrayNextLoc(pArray, &Loc);
    }

    DhcpAssert( ERROR_FILE_NOT_FOUND == Error );
    return NO_ERROR;
}

DWORD
DhcpGetSuperScopeInfo(
    IN OUT  LPDHCP_SUPER_SCOPE_TABLE  SScopeTbl
)
{
    DWORD                          Error;
    DWORD                          nSubnets;
    DWORD                          Index;
    DWORD                          i;
    DWORD                          First;
    PM_SERVER                      Server;
    PARRAY                         Subnets;
    PARRAY                         SuperScopes;
    PM_SUBNET                      Subnet;
    PM_SSCOPE                      SScope;
    ARRAY_LOCATION                 Loc;
    LPDHCP_SUPER_SCOPE_TABLE_ENTRY LocalTable;

    Server = DhcpGetCurrentServer();
    Subnets = &Server->Subnets;
    SuperScopes = &Server->SuperScopes;
    nSubnets = MemArraySize(Subnets);

    SScopeTbl->cEntries = 0;
    SScopeTbl->pEntries = NULL;

    if( 0 == nSubnets ) return ERROR_SUCCESS;
    LocalTable = MIDL_user_allocate(sizeof(DHCP_SUPER_SCOPE_TABLE_ENTRY)*nSubnets);
    if( NULL == LocalTable ) return ERROR_NOT_ENOUGH_MEMORY;

    Error = MemArrayInitLoc(Subnets, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error );
    for(Index = 0; Index < nSubnets ; Index ++ ) {
        Error = MemArrayGetElement(Subnets, &Loc, (LPVOID *)&Subnet);
        DhcpAssert(ERROR_SUCCESS == Error && Subnet);

        LocalTable[Index].SubnetAddress = Subnet->Address;
        LocalTable[Index].SuperScopeNumber = 0;
        LocalTable[Index].SuperScopeName = NULL;
        LocalTable[Index].NextInSuperScope = Index;

        if( Subnet->SuperScopeId ) {
            Error = MemServerFindSScope(
                Server,
                Subnet->SuperScopeId,
                NULL,
                &SScope
            );
            if( ERROR_SUCCESS == Error ) {
                LocalTable[Index].SuperScopeNumber = Subnet->SuperScopeId;
                LocalTable[Index].SuperScopeName = SScope->Name;
            }
        }

        Error = MemArrayNextLoc(Subnets, &Loc);
    }

    for( Index = 0; Index < nSubnets ; Index ++ ) {
        for( i = 0; i < Index ; i ++ ) {
            if( LocalTable[Index].SuperScopeNumber == LocalTable[i].SuperScopeNumber ) {
                LocalTable[Index].NextInSuperScope = i;
            }
        }
        for( i = Index + 1; i < nSubnets; i ++ ) {
            if( LocalTable[Index].SuperScopeNumber == LocalTable[i].SuperScopeNumber ) {
                LocalTable[Index].NextInSuperScope = i;
                break;
            }
        }
    }

    for( Index = 0; Index < nSubnets ; Index ++ ) {
        if( NULL == LocalTable[Index].SuperScopeName) continue;
        LocalTable[Index].SuperScopeName = CloneLPWSTR(LocalTable[Index].SuperScopeName);
        if( NULL == LocalTable[Index].SuperScopeName ) {
            for( i = 0; i < Index ; i ++ )
                if( NULL != LocalTable[Index].SuperScopeName ) MIDL_user_free(LocalTable[Index].SuperScopeName);
            MIDL_user_free(LocalTable);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    SScopeTbl->cEntries = nSubnets;
    SScopeTbl->pEntries = LocalTable;

    return ERROR_SUCCESS;
}

DWORD
DhcpCreateSubnet(
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
)
{
    DWORD                          Error, Error2;
    PM_SUBNET                      Subnet;

    if( SubnetAddress != SubnetInfo->SubnetAddress 
        || (SubnetAddress & SubnetInfo->SubnetMask ) != SubnetAddress ) {
        return ERROR_INVALID_PARAMETER;
    }

    // Name, Comment, State; PrimaryHost is ignored for now...

    Error = MemSubnetInit(
        &Subnet,
        SubnetInfo->SubnetAddress,
        SubnetInfo->SubnetMask,
        SubnetInfo->SubnetState,
        0,                                        // BUBBUG: SuperScopeId needs to be read from registry!
        SubnetInfo->SubnetName,
        SubnetInfo->SubnetComment
    );
    if( ERROR_SUCCESS != Error ) return Error;
    DhcpAssert(Subnet);

    Error = MemServerAddSubnet(DhcpGetCurrentServer(), Subnet);
    if( ERROR_SUCCESS != Error ) {
        Error2 = MemSubnetCleanup(Subnet);
        DhcpAssert(ERROR_SUCCESS == Error2);

        if( ERROR_OBJECT_ALREADY_EXISTS == Error ) {
            return ERROR_DHCP_SUBNET_EXISTS;
        }
        
        return Error;
    }

    return NO_ERROR;
}

DWORD
DhcpSubnetSetInfo(
    IN OUT  PM_SUBNET              Subnet,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
)
{
    DWORD                          Error;
    PM_SUBNET                      AlternateSubnet;

    Error = MemSubnetModify(
        Subnet,
        SubnetInfo->SubnetAddress,
        SubnetInfo->SubnetMask,
        SubnetInfo->SubnetState,
        Subnet->SuperScopeId,                     // use same old super scope
        SubnetInfo->SubnetName,
        SubnetInfo->SubnetComment
    );
    return Error;

}

DWORD
DhcpSetSubnetInfo(
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    if( SubnetAddress != SubnetInfo->SubnetAddress ||
        (SubnetAddress & SubnetInfo->SubnetMask) != SubnetAddress)
        return ERROR_INVALID_PARAMETER;

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_SUBNET_NOT_PRESENT;
    if( ERROR_SUCCESS != Error ) return Error;

    DhcpAssert(Subnet);

    return DhcpSubnetSetInfo(Subnet, SubnetInfo);
}

DWORD
DhcpGetSubnetInfo(
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_SUBNET_NOT_PRESENT;
    if( ERROR_SUCCESS != Error) return Error;

    DhcpAssert(NULL != Subnet);

    SubnetInfo->SubnetAddress = Subnet->Address;
    SubnetInfo->SubnetMask = Subnet->Mask;
    SubnetInfo->SubnetName = CloneLPWSTR(Subnet->Name);
    SubnetInfo->SubnetComment = CloneLPWSTR(Subnet->Description);
    SubnetInfo->SubnetState = Subnet->State;
    SubnetInfo->PrimaryHost.IpAddress = inet_addr("127.0.0.1");
    SubnetInfo->PrimaryHost.NetBiosName = CloneLPWSTR(L"");
    SubnetInfo->PrimaryHost.HostName = CloneLPWSTR(L"");

    return ERROR_SUCCESS;
}

BOOL
SubnetIsBootpOnly(
    IN      PM_SUBNET              Subnet
)
{
    PM_RANGE                       ThisRange;
    ARRAY_LOCATION                 Loc;
    ULONG                          Error;
    
    Error = MemArrayInitLoc(&Subnet->Ranges, &Loc);
    while( ERROR_SUCCESS == Error ) {
        MemArrayGetElement(&Subnet->Ranges, &Loc, &ThisRange);
        if( ThisRange->State & MM_FLAG_ALLOW_DHCP ) return FALSE;

        Error = MemArrayNextLoc(&Subnet->Ranges, &Loc);
    }

    return TRUE;
}

DWORD
DhcpEnumSubnets(
    IN      BOOL                   fSubnet,
    IN OUT  DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN OUT  LPDHCP_IP_ARRAY        EnumInfo,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Error, Error2;
    DWORD                          Index;
    DWORD                          Count;
    DWORD                          FilledSize;
    DWORD                          nSubnets;
    DWORD                          nToRead;
    PARRAY                         Subnets;
    PM_SUBNET                      Subnet;
    ARRAY_LOCATION                 Loc;
    DHCP_IP_ADDRESS               *IpArray;

    EnumInfo->NumElements = 0;
    EnumInfo->Elements = NULL;

    if( fSubnet ) Subnets = & (DhcpGetCurrentServer()->Subnets);
    else Subnets = &(DhcpGetCurrentServer()->MScopes);

    nSubnets = MemArraySize(Subnets);
    if( 0 == nSubnets || nSubnets <= *ResumeHandle)
        return ERROR_NO_MORE_ITEMS;

    if( nSubnets - *ResumeHandle > PreferredMaximum )
        nToRead = PreferredMaximum;
    else nToRead = nSubnets - *ResumeHandle;

    IpArray = MIDL_user_allocate(sizeof(DHCP_IP_ADDRESS)*nToRead);
    if( NULL == IpArray ) return ERROR_NOT_ENOUGH_MEMORY;

    Error = MemArrayInitLoc(Subnets, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error);
    
    for(Index = 0; Index < *ResumeHandle; Index ++ ) {
        Error = MemArrayNextLoc(Subnets, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    Count = Index;
    for( Index = 0; Index < nToRead; ) {
        Error = MemArrayGetElement(Subnets, &Loc, &Subnet);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != Subnet );

        IpArray[Index++] = Subnet->Address;

        Error = MemArrayNextLoc(Subnets, &Loc);
        if( ERROR_SUCCESS != Error ) break;
    }

    *nRead = Index;
    *nTotal = nSubnets - Count;
    *ResumeHandle += *nRead;

    EnumInfo->NumElements = Index;
    EnumInfo->Elements = IpArray;

    return ERROR_SUCCESS;
}

DWORD
DhcpDeleteSubnet(
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DWORD                  ForceFlag
)
{
    DWORD                          Error;
    DWORD                          SScopeId;
    PM_SUBNET                      Subnet;
    PM_SSCOPE                      SScope;

    // If force on, it should remove every record in the database for this subnet..
    if( ForceFlag != DhcpFullForce ) {
        Error = SubnetInUse( NULL /* dont bother abt regkey */, SubnetAddress);
        if( ERROR_SUCCESS != Error ) return Error;
    }

    Error = DhcpDeleteSubnetClients(SubnetAddress);
    // ignore the above error? 

    Error = MemServerDelSubnet(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_SUBNET_NOT_PRESENT;
    if( ERROR_SUCCESS != Error ) return Error;

    SScopeId = Subnet->SuperScopeId;

    // we have the M_SUBNET structure to remove
    // remove all the pending offers we've done on behalf of this subnet.
    // the requests for those ones (if any) will be NACK'ed.
    Error = DhcpRemoveMatchingCtxt(Subnet->Mask, Subnet->Address);
    // ignore this error, offers are anyway retracted on timeout.

    MemSubnetFree(Subnet);                        // evaporate this subnet all all related stuff
    return NO_ERROR;
}

DWORD
DhcpJetIterateOnAddresses(
    IN ULONG Start,
    IN ULONG End,
    IN BOOL (*IteratorFn)( ULONG IpAddress, PVOID Ctxt ),
    IN PVOID Ctxt
)
/*++

Iterate over every address in given range..

--*/
{
    ULONG Error, Size;

    //
    // Unfortunately we can't start from "Start" itself as the
    // prepareSearch routine starts from NEXT value..
    //
    Start --;
    LOCK_DATABASE();
    do {
        Error = DhcpJetPrepareSearch(
            DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
            (Start == -1)? TRUE: FALSE,
            &Start,
            sizeof(Start)
            );
        if( ERROR_SUCCESS != Error ) break;

        while( 1 ) {
            Size = sizeof(Start);
            Error = DhcpJetGetValue(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
                &Start,
                &Size
                );
            if( ERROR_SUCCESS  != Error ) break;
            if( Start > End ) break;

            if( IteratorFn( Start, Ctxt ) ) {
                Error = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            Error = DhcpJetNextRecord();
            if( ERROR_NO_MORE_ITEMS == Error ) {
                Error = ERROR_SUCCESS;
                break;
            }
        }
    } while ( 0 );

    UNLOCK_DATABASE();
    return Error;
}

typedef struct {
    BOOL fHuntForDhcpOrBootp;
    BOOL fFoundAny;
} DHCP_BOOTP_CHECK_CTXT;

BOOL
CheckForDhcpBootpLeases(
    IN ULONG IpAddress,
    IN OUT DHCP_BOOTP_CHECK_CTXT *Ctxt
)
/*++

Return Value:
    TRUE --> error
    FALSE === ev'rything appear ok

--*/
{
    ULONG Error, Size; 
    BYTE ClientType, AddressState;
    BOOL fReserved;
    
    Size = sizeof(AddressState);
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[STATE_INDEX].ColHandle,
        &AddressState,
        &Size
        );
    if( ERROR_SUCCESS == Error ) {
        //
        // If address deleted or not in active state, don't bother..
        //
        if( IsAddressDeleted(AddressState) 
            || !IS_ADDRESS_STATE_ACTIVE( AddressState ) ) {
            return FALSE;
        }
    }

    fReserved = DhcpServerIsAddressReserved(
        DhcpGetCurrentServer(),
        IpAddress
        );
    if( fReserved ) {
        //
        // Do not count reserved IP addresses..
        //
        return FALSE;
    }
    
    Size = sizeof(ClientType);
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[CLIENT_TYPE_INDEX].ColHandle,
        &ClientType,
        &Size
        );
    
    if( ERROR_SUCCESS != Error ) return FALSE;
    
    if( Ctxt->fHuntForDhcpOrBootp ) {
        if( CLIENT_TYPE_DHCP == ClientType ) {
            Ctxt->fFoundAny = TRUE;
            return TRUE;
        }
    }

    if( FALSE == Ctxt->fHuntForDhcpOrBootp ) {
        if( CLIENT_TYPE_BOOTP == ClientType ) {
            Ctxt->fFoundAny = TRUE;
            return TRUE;
        }
    }
            
    return FALSE;
}

DWORD
CheckRangeStateChangeAllowed(
    IN ULONG RangeStart,
    IN ULONG RangeEnd,
    IN ULONG OldState,
    IN ULONG NewState OPTIONAL
)
/*++

Routine Description:
    This routine checks to see if there are any DHCP clients
    in the specified range when the conversion would require no
    DHCP Clients and similarly for BOOTP Clients.

    A conversion to BootpOnly would be something that requires
    no DHCP Clients at the end.  Conversely, a conversion to
    DHCP Only requires absence of BOOTP clients at the end.

--*/
{
    BOOL fDhcpDisallowed = FALSE;
    DHCP_BOOTP_CHECK_CTXT Ctxt;

    if( 0 == NewState ) NewState = MM_FLAG_ALLOW_DHCP;

    if( OldState == NewState ) return ERROR_SUCCESS;
    if( NewState == (MM_FLAG_ALLOW_DHCP | MM_FLAG_ALLOW_BOOTP ) ) {
        return ERROR_SUCCESS;
    }

    if( NewState == MM_FLAG_ALLOW_DHCP ) {
        fDhcpDisallowed = FALSE;
    } else if( NewState == MM_FLAG_ALLOW_BOOTP ) {
        fDhcpDisallowed = TRUE;
    } else {
        return ERROR_INVALID_PARAMETER;
    }

    Ctxt.fHuntForDhcpOrBootp = fDhcpDisallowed;
    Ctxt.fFoundAny = FALSE;

    DhcpJetIterateOnAddresses(
        RangeStart,
        RangeEnd,
        CheckForDhcpBootpLeases,
        &Ctxt
        );

    if( Ctxt.fFoundAny ) return ERROR_DHCP_IPRANGE_CONV_ILLEGAL;
    return ERROR_SUCCESS;
}

DWORD
DhcpSubnetAddRange(
    IN      PM_SUBNET              Subnet,
    IN      ULONG                  State OPTIONAL,
    IN      DHCP_IP_RANGE          Range,
    IN      ULONG                  MaxBootpAllowed OPTIONAL
)
/*++

Routine Description:

    This routine adds a range to a subnet, or modifies the range if it already
    exists.  State tells the new state, and Range is the new Range.  If the
    range is an extension of a previous range, then an attempt is made to extend
    the Range as required.  Note that if State is zero, then the old state is
    left as is.

Arguments:

    Subnet -- pointer to the subnet object to be modified.
    State -- ZERO indicates same state as before.
             MM_FLAG_ALLOW_DHCP and MM_FLAG_ALLOW_BOOTP can be used as bit flags
             here.
    Range -- the value of the new range.. this can be an extension of an
             existing range..
    MaxBootpAllowed -- maximum number of bootp clietns allowed.  Not used if
             State is zero.

Return Values:

Win32 or DHCP errors.

--*/
{
    DWORD                          Error;
    ULONG                          BootpAllocated, OldMaxBootpAllowed, OldState;
    DWORD                          RangeStartOld, RangeStartNew;
    DWORD                          OldStartAddress;
    DWORD                          OldEndAddress;
    DWORD                          InUseClustersSize;
    DWORD                          UsedClustersSize;
    LPBYTE                         InUseClusters;
    LPBYTE                         UsedClusters;
    PM_RANGE                       OverlappingRange;


    //
    // Bug # 415758 requries that we do not allow multiple
    // ranges.  So, if Subnet->Ranges is not empty then don't
    // allow this range.  
    //
    
    if( MemArraySize(&Subnet->Ranges) ) {
        if( NO_ERROR != MemSubnetFindCollision(
            Subnet, Range.StartAddress, Range.EndAddress,
            &OverlappingRange, NULL ) ) {
            return ERROR_DHCP_INVALID_RANGE;
        }
    }
        
    
    OverlappingRange = NULL;
    Error = MemSubnetAddRange(
        Subnet,
        Range.StartAddress,
        Range.EndAddress,
        (ARGUMENT_PRESENT(ULongToPtr(State)))? State : MM_FLAG_ALLOW_DHCP,
        0,
        MaxBootpAllowed,
        &OverlappingRange
    );
    if( ERROR_OBJECT_ALREADY_EXISTS == Error 
        && OverlappingRange->Start == Range.StartAddress 
        && OverlappingRange->End == Range.EndAddress ) {

        //
        // Special case -- changing attributes only..
        // 
        if( !( ARGUMENT_PRESENT( ULongToPtr(State) ) ) ) {
            //
            // If nothing needs to be change.. why call?
            //
            return ERROR_DHCP_IPRANGE_EXITS;
        }
        Error = CheckRangeStateChangeAllowed(
            OverlappingRange->Start,
            OverlappingRange->End,
            OverlappingRange->State,
            State
            );
        if( ERROR_SUCCESS != Error ) return Error;

        OverlappingRange->State = State;
        OverlappingRange->MaxBootpAllowed = MaxBootpAllowed;
        Error = ERROR_SUCCESS;
    }

    if( ERROR_SUCCESS == Error ) {
        return NO_ERROR;
    }

    if( ERROR_OBJECT_ALREADY_EXISTS != Error ) return Error;
    DhcpAssert(NULL != OverlappingRange);    
    
    Error = CheckRangeStateChangeAllowed(
        OverlappingRange->Start,
        OverlappingRange->End,
        OverlappingRange->State,
        State
        );
    if( ERROR_SUCCESS != Error ) return Error;

    OldState = OverlappingRange->State;
    OldMaxBootpAllowed = OverlappingRange->MaxBootpAllowed;

    if( ARGUMENT_PRESENT( ULongToPtr(State) ) ) {
        OverlappingRange->State = State;
        OverlappingRange->MaxBootpAllowed = MaxBootpAllowed;
    } else {
        State = OldState;
        MaxBootpAllowed = OldMaxBootpAllowed;
    }

    BootpAllocated = OverlappingRange->BootpAllocated;
        
    Error = MemSubnetAddRangeExpandOrContract(
        Subnet,
        Range.StartAddress,
        Range.EndAddress,
        &OldStartAddress,
        &OldEndAddress
    );
    if( ERROR_SUCCESS != Error ) {
        //
        // If we couldn't expand, then restore old values..
        //
        OverlappingRange->State = OldState;
        OverlappingRange->MaxBootpAllowed = OldMaxBootpAllowed;
        return ERROR_DHCP_INVALID_RANGE;
    }

    return Error;
}

DWORD
DhcpSubnetAddExcl(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_RANGE          Excl
)
{
    DWORD                          Error;
    DWORD                          nElements;
    DWORD                          Index;
    PM_EXCL                        CollidingExcl;
    DHCP_IP_ADDRESS               *ExclRegFormat;
    PARRAY                         Exclusions;
    ARRAY_LOCATION                 Loc;

    Error = MemSubnetAddExcl(
        Subnet,
        Excl.StartAddress,
        Excl.EndAddress,
        &CollidingExcl
    );

    if( ERROR_SUCCESS != Error ) return ERROR_DHCP_INVALID_RANGE;

    return NO_ERROR;
}

DWORD
DhcpSubnetAddReservation(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_IP_ADDRESS        ReservedAddress,
    IN      LPBYTE                 RawHwAddr,
    IN      DWORD                  RawHwAddrLen,
    IN      DWORD                  Type
)
{
    DWORD                          Error;
    DWORD                          IpAddress;
    PM_RANGE                       Range;
    PM_RESERVATION                 Reservation;
    LPBYTE                         ClientUID = NULL;
    DWORD                          ClientUIDSize;
    DATE_TIME                      ZeroDateTime = { 0, 0 };
    BOOL                           ExistingClient;

    if( CFLAG_RESERVED_IN_RANGE_ONLY ) {
        //
        // Compiled with option to disallow reservations out of range
        //
        Error = MemSubnetGetAddressInfo(
            Subnet,
            ReservedAddress,
            &Range,
            NULL,
            &Reservation
            );
        if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_NOT_RESERVED_CLIENT;
        if( ERROR_SUCCESS != Error ) return Error;
    } else {
        //
        // Compiled with no restrictions on where a reservation can fit in..
        //
        if( (ReservedAddress & Subnet->Mask) != Subnet->Address ) {
            return ERROR_DHCP_NOT_RESERVED_CLIENT;
        }
    }

    ClientUID = NULL;
    Error = DhcpMakeClientUID(
        RawHwAddr,
        RawHwAddrLen,
        HARDWARE_TYPE_10MB_EITHERNET,
        Subnet->Address,
        &ClientUID,
        &ClientUIDSize
    );
    if( ERROR_SUCCESS != Error ) return Error;

    ExistingClient = FALSE;
    if( DhcpGetIpAddressFromHwAddress(ClientUID, (BYTE)ClientUIDSize, &IpAddress ) ) {
        if( IpAddress != ReservedAddress ) {      // we got some other address, release it!
            Error = DhcpRemoveClientEntry(
                IpAddress,
                ClientUID,
                ClientUIDSize,
                TRUE,
                FALSE
            );
            if( ERROR_DHCP_RESERVED_CLIENT == Error ) {
                return ERROR_DHCP_RESERVEDIP_EXITS;
            }
        } else ExistingClient = TRUE;             // only instance where we carry on with existing record
    } else {
        Error = DhcpJetOpenKey(
            DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
            &ReservedAddress,
            sizeof(ReservedAddress)
        );
        if( ERROR_SUCCESS == Error ) {
            Error = DhcpRemoveClientEntry(
                ReservedAddress, NULL, 0, TRUE, FALSE);
            if( ERROR_DHCP_RESERVED_CLIENT == Error ) {
                return ERROR_DHCP_RESERVEDIP_EXITS;
            }
            if( NO_ERROR != Error ) return Error;
        }
            
    }

    Error = DhcpCreateClientEntry(
        ReservedAddress,
        ClientUID,
        ClientUIDSize,
        ZeroDateTime,
        NULL,
        NULL,
        CLIENT_TYPE_UNSPECIFIED,
        (DWORD)(-1),
        ADDRESS_STATE_ACTIVE,
        ExistingClient
    );
    if( ERROR_SUCCESS == Error ) {
        Error = MemReserveAdd(
            &Subnet->Reservations,
            ReservedAddress,
            Type,
            ClientUID,
            ClientUIDSize
        );
        if( ERROR_SUCCESS != Error ) {
            if( ExistingClient ) {
                Error = ERROR_DHCP_RESERVEDIP_EXITS;
            } else {
                Error = ERROR_DHCP_ADDRESS_NOT_AVAILABLE;
            }
        } 
    }

    DhcpFreeMemory(ClientUID);

    if( ERROR_SUCCESS == Error ) {
        //
        // If everything went fine take over this
        // address.. don't know if DHCP-type is allowed
        // If not, mark it as BOOTP.
        //
        MemSubnetRequestAddress(
            Subnet, ReservedAddress, TRUE,
            FALSE, NULL, NULL
            );
        MemSubnetRequestAddress(
            Subnet, ReservedAddress, TRUE,
            TRUE, NULL, NULL
            );
    }
    
    return Error;
}

BOOL
AdminScopedMcastRange(
    IN DHCP_IP_RANGE Range
    )
{
    if( Range.EndAddress >= ntohl(inet_addr("239.0.0.0"))
        && Range.EndAddress <= ntohl(inet_addr("239.255.255.255"))) {
        return TRUE;
    }
    
    return FALSE;
}

DWORD
EndWriteApiForSubnetElement(
    IN LPSTR ApiName,
    IN DWORD Error,
    IN DWORD Subnet,
    IN PVOID Elt
    )
{
    LPDHCP_SUBNET_ELEMENT_DATA_V4 Info = Elt;
    DWORD Reservation;
    
    if( NO_ERROR != Error ) {
        return DhcpEndWriteApi( ApiName, Error );
    }

    Reservation = 0;
    if( DhcpReservedIps == Info->ElementType ) {
        Reservation = (
            Info->Element.ReservedIp->ReservedIpAddress );
    }
    
    return DhcpEndWriteApiEx(
        ApiName, Error, FALSE, FALSE, Subnet, 0, Reservation );
}

DWORD
DhcpAddSubnetElement(
    IN      PM_SUBNET              Subnet,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 ElementInfo,
    IN      BOOL                   fIsV5Call
)
{
    DWORD                          Error;
    ULONG                          Flag;
    DHCP_IP_RANGE                  Range;
    DHCP_BOOTP_IP_RANGE           *DhcpBootpRange;
    ULONG                          MaxBootpAllowed;

    if( DhcpSecondaryHosts == ElementInfo->ElementType ) {
        DhcpAssert(FALSE);
        return ERROR_CALL_NOT_IMPLEMENTED;
    }
    
    Flag = 0;
    
    switch( ElementInfo->ElementType ) {
    case DhcpIpRangesDhcpOnly :
    case DhcpIpRanges :
        Flag = MM_FLAG_ALLOW_DHCP; break;
    case DhcpIpRangesBootpOnly:
        Flag = MM_FLAG_ALLOW_BOOTP; break;
    case DhcpIpRangesDhcpBootp:
        Flag = MM_FLAG_ALLOW_DHCP | MM_FLAG_ALLOW_BOOTP;
        break;
    }

    if( 0 != Flag ) {
        //
        // It is an IpRange that we're trying to add..
        //

        if( NULL == ElementInfo->Element.IpRange ) {
            return ERROR_INVALID_PARAMETER;
        }
        
        if( fIsV5Call ) {
            DhcpBootpRange = (LPVOID) ElementInfo->Element.IpRange;
            Range.StartAddress = DhcpBootpRange->StartAddress;
            Range.EndAddress = DhcpBootpRange->EndAddress;
            if( Flag == (MM_FLAG_ALLOW_DHCP | MM_FLAG_ALLOW_BOOTP ) ) {
                MaxBootpAllowed = DhcpBootpRange->MaxBootpAllowed;
            } else {
                MaxBootpAllowed = ~0;
            }
        } else {
            Range = *ElementInfo->Element.IpRange;
            MaxBootpAllowed = ~0;
            Flag = 0;
        }

        if( Subnet->fSubnet || !AdminScopedMcastRange(Range) ) {
            return DhcpSubnetAddRange(
                Subnet,
                Flag,
                Range,
                MaxBootpAllowed
                );
        }

        //
        // Before adding mscope range, first check if the range
        // is in the administratively scoped region.  If so, then
        // we have to make sure that the range is atleast 256 elements
        // and also automatically insert an exclusion for the last 256.
        //

        if( Range.EndAddress < Range.StartAddress + 255 ) {
            return ERROR_MSCOPE_RANGE_TOO_SMALL;
        }

        //
        // Now add the range, and if successful, try to add the exclusion
        //
        
        Error = DhcpSubnetAddRange( Subnet, Flag, Range, MaxBootpAllowed );
        if( NO_ERROR != Error ) return Error;

        Range.StartAddress = Range.EndAddress - 255;
        return DhcpSubnetAddExcl( Subnet, Range );
        
    }

    if( DhcpExcludedIpRanges == ElementInfo->ElementType ) {

        return DhcpSubnetAddExcl(
            Subnet,
            *ElementInfo->Element.ExcludeIpRange
        );
    }

    if( DhcpReservedIps == ElementInfo->ElementType ) {
        return DhcpSubnetAddReservation(
            Subnet,
            ElementInfo->Element.ReservedIp->ReservedIpAddress,
            ElementInfo->Element.ReservedIp->ReservedForClient->Data,
            ElementInfo->Element.ReservedIp->ReservedForClient->DataLength,
            ElementInfo->Element.ReservedIp->bAllowedClientTypes
        );
    }
    return ERROR_INVALID_PARAMETER;
}

DWORD
DhcpEnumRanges(
    IN      PM_SUBNET              Subnet,
    IN      BOOL                   fOldStyle,
    IN OUT  DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN OUT  LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 LocalEnumInfo,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Error;
    DWORD                          FilledSize;
    DWORD                          Count;
    LONG                           Index;
    ULONG                          Type;
    DWORD                          nElements;
    LPDHCP_SUBNET_ELEMENT_DATA_V4  ElementArray;
    DHCP_SUBNET_ELEMENT_UNION_V4   ElementData;
    PARRAY                         Ranges;
    ARRAY_LOCATION                 Loc;
    PM_RANGE                       ThisRange;
    ULONG                          RangeSize = fOldStyle ? sizeof(DHCP_IP_RANGE):sizeof(DHCP_BOOTP_IP_RANGE);
    
    *nRead = *nTotal =0;
    LocalEnumInfo->NumElements =0;
    LocalEnumInfo->Elements = NULL;

    Ranges = &Subnet->Ranges;
    nElements = MemArraySize(Ranges);

    if( 0 == nElements || nElements <= *ResumeHandle )
        return ERROR_NO_MORE_ITEMS;

    Error = MemArrayInitLoc(Ranges, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error );

    for(Count = 0; Count < *ResumeHandle; Count ++ ) {
        Error = MemArrayNextLoc(Ranges, &Loc);
        if( ERROR_SUCCESS != Error ) {
            return ERROR_NO_MORE_ITEMS;
        }
    }

    ElementArray = MIDL_user_allocate(
        (nElements - Count)*sizeof(DHCP_SUBNET_ELEMENT_DATA_V4)
        );
    if( NULL == ElementArray ) return ERROR_NOT_ENOUGH_MEMORY;

    FilledSize = 0; Error = ERROR_SUCCESS;
    for(Index = 0; Count < nElements; Count ++ ) {
        Error = MemArrayGetElement(Ranges, &Loc, &ThisRange);
        DhcpAssert(ERROR_SUCCESS == Error && ThisRange);

        ElementData.IpRange = MIDL_user_allocate(RangeSize);
        if( NULL == ElementData.IpRange ) {
            while( -- Index >= 0 ) {
                MIDL_user_free(ElementArray[Index].Element.IpRange);
            }
            MIDL_user_free(ElementArray);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        if( fOldStyle ) {
            ElementData.IpRange->StartAddress = ThisRange->Start;
            ElementData.IpRange->EndAddress = ThisRange->End;
        } else {
            ((LPDHCP_BOOT_IP_RANGE)(ElementData.IpRange))->StartAddress = ThisRange->Start;
            ((LPDHCP_BOOT_IP_RANGE)(ElementData.IpRange))->EndAddress = ThisRange->End;
            ((LPDHCP_BOOT_IP_RANGE)(ElementData.IpRange))->BootpAllocated = ThisRange->BootpAllocated;
            ((LPDHCP_BOOT_IP_RANGE)(ElementData.IpRange))->MaxBootpAllowed = ThisRange->MaxBootpAllowed;
        }
        ElementArray[Index].Element = ElementData;

        if( fOldStyle ) {
            //
            // Old admin tool can understand only DhcpIpRanges -- nothin else
            //
            ElementArray[Index++].ElementType = DhcpIpRanges;
        } else {
            //
            // New admin tool can understand DhcpIpRangesDhcpOnly, BootpOnly or DhcpBootp
            //
            switch( ThisRange->State & (MM_FLAG_ALLOW_DHCP | MM_FLAG_ALLOW_BOOTP ) ) {
            case MM_FLAG_ALLOW_DHCP: Type = DhcpIpRangesDhcpOnly; break;
            case MM_FLAG_ALLOW_BOOTP: Type = DhcpIpRangesBootpOnly; break;
            default: Type = DhcpIpRangesDhcpBootp; break;
            }

            ElementArray[Index++].ElementType = Type;
        }

        FilledSize += RangeSize + sizeof(DHCP_SUBNET_ELEMENT_DATA_V4);
        if( FilledSize > PreferredMaximum ) {
            FilledSize -= RangeSize - sizeof(DHCP_SUBNET_ELEMENT_DATA_V4);
            Index --;
            MIDL_user_free(ElementData.IpRange);
            Error = ERROR_MORE_DATA;
            break;
        }
        Error = MemArrayNextLoc(Ranges, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error || Count == nElements-1);
    }

    if( 0 == Index ) {
        *nRead = *nTotal = 0;
        LocalEnumInfo->NumElements = 0;
        MIDL_user_free(LocalEnumInfo->Elements);
        LocalEnumInfo->Elements = NULL;
        return ERROR_NO_MORE_ITEMS;
    }

    if( nElements == Count ) Error = ERROR_SUCCESS;
    *nRead = Index;
    *nTotal = nElements - *ResumeHandle;
    *ResumeHandle = Count;
    LocalEnumInfo->NumElements = Index;
    LocalEnumInfo->Elements = ElementArray;
            
    return Error;
}

DWORD
DhcpEnumExclusions(
    IN      PM_SUBNET              Subnet,
    IN OUT  DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN OUT  LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 LocalEnumInfo,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Error;
    DWORD                          FilledSize;
    DWORD                          Count;
    LONG                           Index;
    DWORD                          nElements;
    LPDHCP_SUBNET_ELEMENT_DATA_V4  ElementArray;
    DHCP_SUBNET_ELEMENT_UNION_V4   ElementData;
    PARRAY                         Exclusions;
    ARRAY_LOCATION                 Loc;
    PM_EXCL                        ThisExcl;

    *nRead = *nTotal =0;
    LocalEnumInfo->NumElements =0;
    LocalEnumInfo->Elements = NULL;

    Exclusions = &Subnet->Exclusions;
    nElements = MemArraySize(Exclusions);

    if( 0 == nElements || nElements <= *ResumeHandle )
        return ERROR_NO_MORE_ITEMS;

    Error = MemArrayInitLoc(Exclusions, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error );

    for(Count = 0; Count < *ResumeHandle; Count ++ ) {
        Error = MemArrayNextLoc(Exclusions, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    ElementArray = MIDL_user_allocate((nElements - Count)*sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));
    if( NULL == ElementArray ) return ERROR_NOT_ENOUGH_MEMORY;

    FilledSize = 0; Error = ERROR_SUCCESS;
    for(Index = 0; Count < nElements; Count ++ ) {
        Error = MemArrayGetElement(Exclusions, &Loc, &ThisExcl);
        DhcpAssert(ERROR_SUCCESS == Error && ThisExcl);

        ElementData.ExcludeIpRange = MIDL_user_allocate(sizeof(DHCP_IP_RANGE));
        if( NULL == ElementData.ExcludeIpRange ) {
            while( -- Index >= 0 ) {
                MIDL_user_free(ElementArray[Index].Element.ExcludeIpRange);
            }
            MIDL_user_free(ElementArray);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        ElementData.ExcludeIpRange->StartAddress = ThisExcl->Start;
        ElementData.ExcludeIpRange->EndAddress = ThisExcl->End;
        ElementArray[Index].Element = ElementData;
        ElementArray[Index++].ElementType = DhcpExcludedIpRanges;

        FilledSize += sizeof(DHCP_IP_RANGE) + sizeof(DHCP_SUBNET_ELEMENT_DATA_V4);
        if( FilledSize > PreferredMaximum ) {
            FilledSize -= (DWORD)(sizeof(DHCP_IP_RANGE) - sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));
            Index --;
            MIDL_user_free(ElementData.ExcludeIpRange);
            Error = ERROR_MORE_DATA;
            break;
        }
        Error = MemArrayNextLoc(Exclusions, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error || Count == nElements-1);
    }

    if( nElements == Count ) Error = ERROR_SUCCESS;
    *nRead = Index;
    *nTotal = nElements - *ResumeHandle;
    *ResumeHandle = Count;
    LocalEnumInfo->NumElements = Index;
    LocalEnumInfo->Elements = ElementArray;

    return Error;
}

DWORD
DhcpEnumReservations(
    IN      PM_SUBNET              Subnet,
    IN OUT  DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN OUT  LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 LocalEnumInfo,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Error;
    DWORD                          FilledSize;
    DWORD                          Count;
    LONG                           Index;
    DWORD                          nElements;
    LPDHCP_SUBNET_ELEMENT_DATA_V4  ElementArray;
    DHCP_SUBNET_ELEMENT_UNION_V4   ElementData;
    PARRAY                         Reservations;
    ARRAY_LOCATION                 Loc;
    PM_RESERVATION                 ThisReservation;
    LPVOID                         Ptr1, Ptr2, Ptr3;

    *nRead = *nTotal =0;
    LocalEnumInfo->NumElements =0;
    LocalEnumInfo->Elements = NULL;

    Reservations = &Subnet->Reservations;
    nElements = MemArraySize(Reservations);

    if( 0 == nElements || nElements <= *ResumeHandle )
        return ERROR_NO_MORE_ITEMS;

    Error = MemArrayInitLoc(Reservations, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error );

    for(Count = 0; Count < *ResumeHandle; Count ++ ) {
        Error = MemArrayNextLoc(Reservations, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    ElementArray = MIDL_user_allocate((nElements - Count)*sizeof(DHCP_SUBNET_ELEMENT_DATA_V4));
    if( NULL == ElementArray ) return ERROR_NOT_ENOUGH_MEMORY;

    FilledSize = 0; Error = ERROR_SUCCESS;
    for(Index = 0; Count < nElements; Count ++ ) {
        Error = MemArrayGetElement(Reservations, &Loc, &ThisReservation);
        DhcpAssert(ERROR_SUCCESS == Error && ThisReservation);

        if( FilledSize + sizeof(DHCP_IP_RESERVATION_V4) + ThisReservation->nBytes > PreferredMaximum ) {
            Error = ERROR_MORE_DATA;
            break;
        }

        ElementData.ReservedIp = Ptr1 = MIDL_user_allocate(sizeof(DHCP_IP_RESERVATION_V4));
        if( NULL != Ptr1 ) {
            Ptr2 = MIDL_user_allocate(sizeof(*(ElementData.ReservedIp->ReservedForClient)));
            ElementData.ReservedIp->ReservedForClient = Ptr2;
        } else Ptr2 = NULL;
        if( NULL != Ptr2 ) {
            Ptr3 = MIDL_user_allocate(ThisReservation->nBytes);
            ElementData.ReservedIp->ReservedForClient->Data = Ptr3;
        } else Ptr3 = NULL;
        if( NULL == Ptr1 || NULL == Ptr2 || NULL == Ptr3 ) {
            if( NULL != Ptr1 ) MIDL_user_free(Ptr1);
            if( NULL != Ptr2 ) MIDL_user_free(Ptr2);
            if( NULL != Ptr3 ) MIDL_user_free(Ptr3);
            while( -- Index >= 0 ) {
                MIDL_user_free(ElementArray[Index].Element.ReservedIp->ReservedForClient->Data);
                MIDL_user_free(ElementArray[Index].Element.ReservedIp->ReservedForClient);
                MIDL_user_free(ElementArray[Index].Element.ReservedIp);
            }
            MIDL_user_free(ElementArray);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        memcpy(Ptr3, ThisReservation->ClientUID, ThisReservation->nBytes);
        ElementData.ReservedIp->ReservedForClient->DataLength = ThisReservation->nBytes;

        ElementData.ReservedIp->bAllowedClientTypes = (BYTE)ThisReservation->Flags;
        ElementData.ReservedIp->ReservedIpAddress = ThisReservation->Address;
        ElementArray[Index].Element = ElementData;
        ElementArray[Index++].ElementType = DhcpReservedIps;

        FilledSize += sizeof(DHCP_IP_RESERVATION_V4) + ThisReservation->nBytes;
        DhcpAssert(FilledSize <= PreferredMaximum);

        Error = MemArrayNextLoc(Reservations, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error || Count == nElements-1);
    }

    if( Count == nElements ) Error = ERROR_SUCCESS;
    *nRead = Index;
    *nTotal = nElements - *ResumeHandle;
    *ResumeHandle = Count;
    LocalEnumInfo->NumElements = Index;
    LocalEnumInfo->Elements = ElementArray;

    return Error;
}


DWORD
DhcpEnumSubnetElements(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN      BOOL                   fIsV5Call,
    IN OUT  LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 LocalEnumInfo,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    switch(EnumElementType) {
    case DhcpIpRanges:
        return DhcpEnumRanges(
            Subnet, TRUE, ResumeHandle, PreferredMaximum,
            LocalEnumInfo, nRead, nTotal
            );
    case DhcpIpRangesDhcpBootp :
        if( !fIsV5Call ) return ERROR_INVALID_PARAMETER;
        return DhcpEnumRanges(
            Subnet, FALSE, ResumeHandle, PreferredMaximum,
            LocalEnumInfo, nRead, nTotal
            );
    case DhcpSecondaryHosts:
        return ERROR_NOT_SUPPORTED;
    case DhcpReservedIps:
        return DhcpEnumReservations(
            Subnet, ResumeHandle, PreferredMaximum,
            LocalEnumInfo, nRead, nTotal
        );
    case DhcpExcludedIpRanges:
        return DhcpEnumExclusions(
            Subnet, ResumeHandle, PreferredMaximum,
            LocalEnumInfo, nRead, nTotal
        );
    default: return ERROR_INVALID_PARAMETER;
    }
}

DWORD
DhcpRemoveRange(
    IN      PM_SUBNET              Subnet,
    IN      LPDHCP_IP_RANGE        Range,
    IN      DHCP_FORCE_FLAG        ForceFlag
)
{
    DWORD                          Error;
    DWORD                          Start;
    PM_RANGE                       ThisRange;

    Error = MemSubnetGetAddressInfo(
        Subnet,
        Range->StartAddress,
        &ThisRange,
        NULL,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return ERROR_DHCP_INVALID_RANGE;

    if( ThisRange->Start != Range->StartAddress ||
        ThisRange->End  != Range->EndAddress )
        return ERROR_DHCP_INVALID_RANGE;

    if( DhcpFullForce != ForceFlag ) {
        if( MemBitGetSetBitsSize(ThisRange->BitMask) != 0 )
            return ERROR_DHCP_ELEMENT_CANT_REMOVE;
    }

    Error = MemSubnetDelRange(
        Subnet,
        Start = ThisRange->Start
    );
    return Error;
}

DWORD
DhcpRemoveReservation(
    IN      PM_SUBNET              Subnet,
    IN      LPDHCP_IP_RESERVATION_V4 Reservation
)
{
    DWORD                          Error;
    DWORD                          ReservedAddress;
    PM_RESERVATION                 ThisReservation;
    DHCP_CLIENT_UID                dupReservation;

    ReservedAddress = Reservation->ReservedIpAddress;

    Error = MemSubnetGetAddressInfo(
        Subnet,
        Reservation->ReservedIpAddress,
        NULL,
        NULL,
        &ThisReservation
    );

    if( ERROR_FILE_NOT_FOUND == Error )
    {
        DHCP_SEARCH_INFO    ClientInfo;

        // this might be because a bogus reservation from the db. Handle it as a regular lease:
        // the first parameter, DHCP_SRV_HANDLE ServerIpAddress is not used at all in DhcpDeleteClientInfo

        ClientInfo.SearchType = DhcpClientIpAddress;
        ClientInfo.SearchInfo.ClientIpAddress = Reservation->ReservedIpAddress;

        // instead of ERROR_DHCP_NOT_RESERVED_CLIENT, just return the result of deleting the regular lease.
        return R_DhcpDeleteClientInfo(NULL, &ClientInfo);
    }
    if( ERROR_SUCCESS != Error ) return Error;

    DhcpAssert(ThisReservation);

#if 0 // this check does not seem to be done before .. 
    if( ThisReservation->nBytes != Reservation->ReservedForClient->DataLength )
        return ERROR_DHCP_NOT_RESERVED_CLIENT;
    if( 0 != memcmp(ThisReservation->ClientUID, Reservation->ReservedForClient->Data, ThisReservation->nBytes))
        return ERROR_DHCP_NOT_RESERVED_CLIENT;
#endif

    dupReservation.DataLength = ThisReservation->nBytes;
    dupReservation.Data = DhcpAllocateMemory(dupReservation.DataLength);
    if (dupReservation.Data==NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlCopyMemory(dupReservation.Data, ThisReservation->ClientUID, dupReservation.DataLength);

    Error = MemReserveDel(
        &Subnet->Reservations,
        ReservedAddress
    );
    DhcpAssert(ERROR_SUCCESS == Error);

    Error = DhcpRemoveClientEntry(
        ReservedAddress,
        dupReservation.Data,
        dupReservation.DataLength,
        TRUE,
        FALSE
    );
    DhcpAssert(ERROR_SUCCESS == Error);

    DhcpFreeMemory(dupReservation.Data);
    return ERROR_SUCCESS;
}

DWORD
DhcpRemoveExclusion(
    IN      PM_SUBNET              Subnet,
    IN      LPDHCP_IP_RANGE        ExcludedRange
)
{
    DWORD                          Error;
    DWORD                          nElements;
    DWORD                          Index;
    PM_EXCL                        ThisExclusion, CollidingExcl;
    PARRAY                         Exclusions;
    ARRAY_LOCATION                 Loc;
    DHCP_IP_ADDRESS               *ExclRegFormat;

    Error = MemSubnetGetAddressInfo(
        Subnet,
        ExcludedRange->StartAddress,
        NULL,
        &ThisExclusion,
        NULL
    );
    if( ERROR_SUCCESS != Error ) return ERROR_DHCP_ELEMENT_CANT_REMOVE;

    DhcpAssert(ThisExclusion);

    if( ThisExclusion->Start != ExcludedRange->StartAddress ||
        ThisExclusion->End != ExcludedRange->EndAddress )
        return ERROR_INVALID_PARAMETER;

    Error = MemSubnetDelExcl(Subnet, ExcludedRange->StartAddress);
    if( ERROR_SUCCESS != Error ) return ERROR_DHCP_ELEMENT_CANT_REMOVE;
    return NO_ERROR;
}

DWORD
DhcpRemoveSubnetElement(
    IN      PM_SUBNET              Subnet,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    IN      BOOL                   fIsV5Call,
    IN      DHCP_FORCE_FLAG        ForceFlag
)
{
    DHCP_IP_RANGE                  Range, *Rangep;
    DHCP_BOOTP_IP_RANGE           *DhcpBootpRange;
    DhcpAssert(Subnet);
    switch(RemoveElementInfo->ElementType ) {
    case DhcpIpRangesDhcpOnly:
    case DhcpIpRangesDhcpBootp:
    case DhcpIpRangesBootpOnly:
    case DhcpIpRanges: 
        if( fIsV5Call ) {
            DhcpBootpRange = (PVOID)RemoveElementInfo->Element.IpRange;
            Range.StartAddress = DhcpBootpRange->StartAddress;
            Range.EndAddress = DhcpBootpRange->EndAddress;
            Rangep = &Range;
        } else {
            Rangep = RemoveElementInfo->Element.IpRange;
        }
        return  DhcpRemoveRange(Subnet,Rangep,ForceFlag);
    case DhcpSecondaryHosts: return ERROR_CALL_NOT_IMPLEMENTED;
    case DhcpReservedIps: return DhcpRemoveReservation(Subnet, RemoveElementInfo->Element.ReservedIp);
    case DhcpExcludedIpRanges: return DhcpRemoveExclusion(Subnet, RemoveElementInfo->Element.ExcludeIpRange);
    default: return ERROR_INVALID_PARAMETER;
    }
}

//================================================================================
//  the actual RPC code is here.. (all the subntapi routines)
//================================================================================

//BeginExport(function)
DWORD
R_DhcpSetSuperScopeV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPWSTR                 SuperScopeName,
    IN      BOOL                   ChangeExisting
) //EndExport(function)
{
    DWORD                          Error;

    Error = DhcpBeginWriteApi( "DhcpSetSuperScopeV4" );
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpSetSuperScopeV4(
        SubnetAddress,
        SuperScopeName,
        ChangeExisting
    );

    return DhcpEndWriteApiEx(
        "DhcpSetSuperScopeV4", Error, FALSE, FALSE,
        SubnetAddress, 0,0 );
}

//BeginExport(function)
DWORD
R_DhcpDeleteSuperScopeV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      LPWSTR                 SuperScopeName
) //EndExport(function)
{
    DWORD                          Error;

    Error = DhcpBeginWriteApi( "DhcpDeleteSuperScopeV4" );
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpDeleteSuperScope(SuperScopeName);

    return DhcpEndWriteApi("DhcpDeleteSuperScopeV4", Error );
}

//BeginExport(function)
DWORD
R_DhcpGetSuperScopeInfoV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    OUT     LPDHCP_SUPER_SCOPE_TABLE *SuperScopeTable
) //EndExport(function)
{
    DWORD                          Error;
    LPDHCP_SUPER_SCOPE_TABLE       LocalSuperScopeTable;

    Error = DhcpBeginReadApi( "DhcpGetSuperScopeInfoV4" );
    if( ERROR_SUCCESS != Error ) return Error;

    *SuperScopeTable = NULL;
    LocalSuperScopeTable = MIDL_user_allocate(sizeof(DHCP_SUPER_SCOPE_TABLE));
    if( NULL == LocalSuperScopeTable ) {
        DhcpEndReadApi( "DhcpGetSuperScopeInfoV4", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpGetSuperScopeInfo(LocalSuperScopeTable);
    if( ERROR_SUCCESS != Error ) {
        
        MIDL_user_free(LocalSuperScopeTable);
        LocalSuperScopeTable = NULL;
    } 

    *SuperScopeTable = LocalSuperScopeTable;

    DhcpEndReadApi( "DhcpGetSuperScopeInfoV4", Error );
    return Error;
}


//BeginExport(function)
DWORD
R_DhcpCreateSubnet(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
) //EndExport(function)
{
    DWORD                          Error;

    Error = DhcpBeginWriteApi( "DhcpCreateSubnet" );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpCreateSubnet(SubnetAddress, SubnetInfo);

    return DhcpEndWriteApiEx(
        "DhcpCreateSubnet", Error, FALSE, FALSE, SubnetAddress, 0,0  );
}

//BeginExport(function)
DWORD
R_DhcpSetSubnetInfo(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
) //EndExport(function)
{
    DWORD                          Error;

    Error = DhcpBeginWriteApi( "DhcpSetSubnetInfo" );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpSetSubnetInfo(SubnetAddress, SubnetInfo);

    return DhcpEndWriteApiEx(
        "DhcpSetSubnetInfo", Error, FALSE, FALSE, SubnetAddress, 0,0 );
}

//BeginExport(function)
DWORD
R_DhcpGetSubnetInfo(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    OUT     LPDHCP_SUBNET_INFO    *SubnetInfo
) //EndExport(function)
{
    DWORD                          Error;
    LPDHCP_SUBNET_INFO             LocalSubnetInfo;


    *SubnetInfo = NULL;

    Error = DhcpBeginReadApi( "DhcpGetSubnetInfo" );
    if( ERROR_SUCCESS != Error ) return Error;

    LocalSubnetInfo = MIDL_user_allocate(sizeof(DHCP_SUBNET_INFO));
    if( NULL == LocalSubnetInfo ) {
        DhcpEndReadApi( "DhcpGetSubnetInfo", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpGetSubnetInfo(SubnetAddress, LocalSubnetInfo);
    if( ERROR_SUCCESS != Error ) {
        MIDL_user_free(LocalSubnetInfo);
        LocalSubnetInfo = NULL;
    } 

    *SubnetInfo = LocalSubnetInfo;

    DhcpEndReadApi( "DhcpGetSubnetInfo", Error );
    return Error;
}

//BeginExport(function)
DWORD
R_DhcpEnumSubnets(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN      LPDHCP_IP_ARRAY       *EnumInfo,
    IN      DWORD                 *ElementsRead,
    IN      DWORD                 *ElementsTotal
) //EndExport(function)
{
    DWORD                          Error;
    LPDHCP_IP_ARRAY                LocalEnumInfo;

    *EnumInfo = NULL;

    Error = DhcpBeginReadApi( "DhcpEnumSubnets" );
    if( ERROR_SUCCESS != Error ) return Error;

    LocalEnumInfo = MIDL_user_allocate(sizeof(DHCP_IP_ARRAY));
    if( NULL == LocalEnumInfo ) {
        DhcpEndReadApi( "DhcpEnumSubnets", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpEnumSubnets(
        TRUE, ResumeHandle, 
        PreferredMaximum, LocalEnumInfo, ElementsRead, ElementsTotal
        );

    if( ERROR_SUCCESS != Error && ERROR_MORE_DATA != Error ) {
        MIDL_user_free(LocalEnumInfo);
    } else {
        *EnumInfo = LocalEnumInfo;
    }

    DhcpEndReadApi( "DhcpEnumSubnets", Error );
    return Error;
}

//BeginExport(function)
DWORD
R_DhcpDeleteSubnet(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_FORCE_FLAG        ForceFlag      // if TRUE delete all turds from memory/registry/database
) //EndExport(function)
{
    DWORD                          Error;

    Error = DhcpBeginWriteApi( "DhcpDeleteSubnet" );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpDeleteSubnet(SubnetAddress, ForceFlag);

    return DhcpEndWriteApiEx(
        "DhcpDeleteSubnet", Error, FALSE, FALSE, SubnetAddress, 0,0 );
}

//BeginExport(function)
DWORD
R_DhcpAddSubnetElementV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4  AddElementInfo
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    Error = DhcpBeginWriteApi( "DhcpAddSubnetElementV4" );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );

    if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
    else if( ERROR_SUCCESS == Error ) {
        Error = DhcpAddSubnetElement(Subnet, AddElementInfo, FALSE);
    }

    return EndWriteApiForSubnetElement(
        "DhcpAddSubnetElementV4", Error, SubnetAddress,
        AddElementInfo );
}
//BeginExport(function)
DWORD
R_DhcpAddSubnetElementV5(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V5  AddElementInfo
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    Error = DhcpBeginWriteApi( "DhcpAddSubnetElementV5" );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );

    if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
    else if( ERROR_SUCCESS == Error ) {
        Error = DhcpAddSubnetElement(Subnet, (PVOID)AddElementInfo, TRUE);
    }

    return EndWriteApiForSubnetElement(
        "DhcpAddSubnetElementV5", Error, SubnetAddress,
        AddElementInfo );
}

//BeginExport(function)
DWORD
R_DhcpEnumSubnetElementsV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    OUT     DWORD                 *ElementsRead,
    OUT     DWORD                 *ElementsTotal
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 LocalElementEnumInfo;

    *EnumElementInfo = NULL;
    *ElementsRead = 0;
    *ElementsTotal = 0;

    Error = DhcpBeginReadApi( "DhcpEnumSubnetElementsV4" );
    if( ERROR_SUCCESS != Error ) return Error;

    LocalElementEnumInfo = MIDL_user_allocate(sizeof(DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4));
    if( NULL == LocalElementEnumInfo ) {
        DhcpEndReadApi( "DhcpEnumSubnetElementsV4", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
    else if( ERROR_SUCCESS == Error ) {
        Error = DhcpEnumSubnetElements(
            Subnet,
            EnumElementType,
            ResumeHandle,
            PreferredMaximum,
            FALSE,
            LocalElementEnumInfo,
            ElementsRead,
            ElementsTotal
        );
    }

    if( ERROR_SUCCESS != Error 
        && ERROR_MORE_DATA != Error ) {
        MIDL_user_free(LocalElementEnumInfo);
    } else {
        *EnumElementInfo = LocalElementEnumInfo;
    }

    DhcpEndReadApi( "DhcpEnumSubnetElementsV4", Error );
    return Error;
}
//BeginExport(function)
DWORD
R_DhcpEnumSubnetElementsV5(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 *EnumElementInfo,
    OUT     DWORD                 *ElementsRead,
    OUT     DWORD                 *ElementsTotal
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 LocalElementEnumInfo;

    *EnumElementInfo = NULL;
    *ElementsRead = 0;
    *ElementsTotal = 0;

    Error = DhcpBeginReadApi( "DhcpEnumSubnetElementsV5" );
    if( ERROR_SUCCESS != Error ) return Error;

    LocalElementEnumInfo = MIDL_user_allocate(sizeof(DHCP_SUBNET_ELEMENT_INFO_ARRAY_V5));
    if( NULL == LocalElementEnumInfo ) {
        DhcpEndReadApi( "DhcpEnumSubnetElementsV4", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpApiAccessCheck(DHCP_VIEW_ACCESS);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
    else if( ERROR_SUCCESS == Error ) {
        Error = DhcpEnumSubnetElements(
            Subnet,
            EnumElementType,
            ResumeHandle,
            PreferredMaximum,
            TRUE,
            (PVOID)LocalElementEnumInfo,
            ElementsRead,
            ElementsTotal
        );
    }

    if( ERROR_SUCCESS != Error ) {
        MIDL_user_free(LocalElementEnumInfo);
    } else {
        *EnumElementInfo = (PVOID)LocalElementEnumInfo;
    }

    DhcpEndReadApi( "DhcpEnumSubnetElementsV4", Error );
    return Error;
}

//BeginExport(function)
DWORD
R_DhcpRemoveSubnetElementV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    IN      DHCP_FORCE_FLAG        ForceFlag
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    Error = DhcpBeginWriteApi( "DhcpRemoveSubnetElementV4" );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
    else if( ERROR_SUCCESS == Error ) {
        Error = DhcpRemoveSubnetElement(Subnet, RemoveElementInfo, FALSE, ForceFlag);
    }

    return EndWriteApiForSubnetElement(
        "DhcpRemoveSubnetElementV4", Error, SubnetAddress,
        RemoveElementInfo );
}

//BeginExport(function)
DWORD
R_DhcpRemoveSubnetElementV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V5 RemoveElementInfo,
    IN      DHCP_FORCE_FLAG        ForceFlag
) //EndExport(function)
{
    DWORD                          Error;
    PM_SUBNET                      Subnet;

    Error = DhcpBeginWriteApi( "DhcpRemoveSubnetElementV4" );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
    else if( ERROR_SUCCESS == Error ) {
        Error = DhcpRemoveSubnetElement(Subnet, (PVOID)RemoveElementInfo, TRUE, ForceFlag);
    }

    return EndWriteApiForSubnetElement(
        "DhcpRemoveSubnetElementV4", Error, SubnetAddress,
        RemoveElementInfo );
}

DWORD
R_DhcpScanDatabase(
    LPWSTR ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DWORD FixFlag,
    LPDHCP_SCAN_LIST *ScanList
    )
/*++

Routine Description:

    This function scans the database entries and registry bit-map for
    specified subnet scope and veryfies to see they match. If they
    don't match, this api will return the list of inconsistent entries.
    Optionally FixFlag can be used to fix the bad entries.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : Address of the subnet scope to verify.

    FixFlag : If this flag is TRUE, this api will fix the bad entries.

    ScanList : List of bad entries returned. The caller should free up
        this memory after it has been used.


Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error;
    PM_SUBNET   Subnet;

    DhcpPrint(( DEBUG_APIS, "DhcpScanDatabase is called.\n"));

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }


    DhcpAcquireWriteLock();

    Error = DhcpFlushBitmaps();
    DhcpAssert(ERROR_SUCCESS == Error);

    Error = MemServerGetAddressInfo(
        DhcpGetCurrentServer(),
        SubnetAddress,
        &Subnet,
        NULL,
        NULL,
        NULL
    );
    if( ERROR_FILE_NOT_FOUND == Error ) {
        DhcpReleaseWriteLock();
        return ERROR_DHCP_SUBNET_NOT_PRESENT;
    }
    
    if( ERROR_SUCCESS != Error) {
        DhcpReleaseWriteLock();
        return Error;
    }

    DhcpAssert(NULL != Subnet);

    Error = ScanDatabase(
        Subnet,
        FixFlag,
        ScanList
    );

    DhcpReleaseWriteLock();
    DhcpScheduleRogueAuthCheck();

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_APIS, "DhcpScanDatabase  failed, %ld.\n",
                        Error ));
    }

    return(Error);
}

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\rpcapi3.c ===
/*++

Copyright (C) 1997 Microsoft Corporation

Module Name:
    rpcapi3.c

Abstract:
    Miscellanious RPC APIs (essentially querying server status 
       and rogue detection stuff as well as starting/setting some stuff)

Environment:
    Usermode Win32 DHCP Server

--*/

#include    <dhcpreg.h>
#include    <dhcppch.h>
#include    <lmapibuf.h>
#include    <dsgetdc.h>
#include    <iptbl.h>
#include    <endpoint.h>

#define CONFIG_BACKUP_MAX_PATH  500

DWORD
R_DhcpServerQueryAttribute(
    IN LPWSTR ServerIpAddress,
    IN ULONG dwReserved,
    IN DHCP_ATTRIB_ID DhcpAttribId,
    OUT LPDHCP_ATTRIB *pDhcpAttrib
)
/*++

Routine Description:
    This routine queries the DHCP Server for the property identified by the
    parameter DhcpAttribId.   The return value can currently be one of the
    following types: DHCP_ATTRIB_TYPE_BOOL or DHCP_ATTRIB_TYPE_ULONG.

Arguments:
    ServerIpAddress -- string representation of server IP address, not used
    dwReserved -- must be zero, reserved for future use
    DhcpAttribId -- Attrib ID that is being queried
    pDhcpAttrib -- This pointer is filled with attrib ID (memory is
        allocated by routine and must be freed with DhcpRpcFreeMemory).

Return Value:
    ERROR_ACCESS_DENIED -- do not have viewing privilege on the server.
    ERROR_INVALID_PARAMETER -- invalid parameters passed
    ERROR_NOT_ENOUGH_MEMORY -- not enough memory to process
    ERROR_NOT_SUPPORTED -- requested attrib is not available
    ERROR_SUCCESS

--*/
{
    DWORD Error;

    DhcpPrint(( DEBUG_APIS, "R_DhcpServerQueryAttribute is called.\n")); 

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );
    if( Error != ERROR_SUCCESS ) return Error;

    if( NULL == pDhcpAttrib || 0 != dwReserved ) {
        return ERROR_INVALID_PARAMETER;
    }

    if( DHCP_ATTRIB_BOOL_IS_ROGUE != DhcpAttribId &&
        DHCP_ATTRIB_BOOL_IS_DYNBOOTP != DhcpAttribId &&
        DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC != DhcpAttribId &&
        DHCP_ATTRIB_BOOL_IS_ADMIN != DhcpAttribId &&
        DHCP_ATTRIB_BOOL_IS_BINDING_AWARE != DhcpAttribId &&
        DHCP_ATTRIB_ULONG_RESTORE_STATUS != DhcpAttribId ) {
        return ERROR_NOT_SUPPORTED;
    }

    (*pDhcpAttrib) = MIDL_user_allocate(sizeof(DHCP_ATTRIB));
    if( NULL == (*pDhcpAttrib) ) return ERROR_NOT_ENOUGH_MEMORY;

    (*pDhcpAttrib)->DhcpAttribId = DhcpAttribId;
    (*pDhcpAttrib)->DhcpAttribType = DHCP_ATTRIB_TYPE_BOOL;
    if( DHCP_ATTRIB_BOOL_IS_ROGUE == DhcpAttribId ) {
        if( DhcpGlobalNumberOfNetsActive == 0 ) {
            (*pDhcpAttrib)->DhcpAttribBool = FALSE;
        } else {
            (*pDhcpAttrib)->DhcpAttribBool = !DhcpGlobalOkToService;
        }
    } else if( DHCP_ATTRIB_BOOL_IS_DYNBOOTP == DhcpAttribId ) {
        (*pDhcpAttrib)->DhcpAttribBool = DhcpGlobalDynamicBOOTPEnabled;
    } else if( DHCP_ATTRIB_BOOL_IS_BINDING_AWARE == DhcpAttribId ) {
        (*pDhcpAttrib)->DhcpAttribBool = DhcpGlobalBindingsAware;
    } else if( DHCP_ATTRIB_BOOL_IS_ADMIN == DhcpAttribId ) {
        ULONG Err = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );
        (*pDhcpAttrib)->DhcpAttribBool = (ERROR_SUCCESS == Err);
    } else if( DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC == DhcpAttribId ) {
        PDOMAIN_CONTROLLER_INFO Info;

        Info = NULL;
        Error = DsGetDcNameW(
            NULL, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED,
            &Info
            );
        (*pDhcpAttrib)->DhcpAttribBool = (ERROR_SUCCESS == Error);
        if( NULL != Info ) NetApiBufferFree(Info);
    } else if( DHCP_ATTRIB_ULONG_RESTORE_STATUS == DhcpAttribId ) {
        (*pDhcpAttrib)->DhcpAttribUlong = DhcpGlobalRestoreStatus;
        (*pDhcpAttrib)->DhcpAttribType = DHCP_ATTRIB_TYPE_ULONG;
    }
    
    return ERROR_SUCCESS;
} // R_DhcpServerQueryAttribute()

DWORD
R_DhcpServerQueryAttributes(
    IN LPWSTR ServerIpAddress,
    IN ULONG dwReserved,
    IN ULONG dwAttribCount,
    IN LPDHCP_ATTRIB_ID pDhcpAttribs,
    OUT LPDHCP_ATTRIB_ARRAY *pDhcpAttribArr
)
/*++

Routine Description:
    This routine queries a bunch of properties from the DHCP Server.  In
    case some of the requested attributes aren't known to the server, it
    would still return the supported attributes (so you have to check the
    value in the pDhcpAttribArr parameter to see what attributes are
    available) -- and in this case an error ERROR_NOT_SUPPORTED is
    returned. 

Arguments:
    ServerIpAddress -- string representation of server IP address, not used
    dwReserved -- must be zero, reserved for future use
    dwAttribCount -- the number of attribs being queried
    pDhcpAttribs -- array of attributes being queried
    pDhcpAttribArr -- array of attributes being returned.  This could be
        NULL if there was an error, or it could be a set of attributes that
        the server supports.  (So, if the return value is
        ERROR_NOT_SUPPORTED, this parameter may still contain some value). 
        This should be freed via DhcpRpcFreeMemory.

Return Values:
    ERROR_ACCESS_DENIED -- do not have viewing privilege on the server.
    ERROR_INVALID_PARAMETER -- invalid parameters passed
    ERROR_NOT_ENOUGH_MEMORY -- not enough memory to process
    ERROR_NOT_SUPPORTED -- some requested attrib is not available
    ERROR_SUCCESS

--*/
{
    DWORD Error;
    ULONG i, nAttribs;
    LPDHCP_ATTRIB_ARRAY RetArr;

    DhcpPrint(( DEBUG_APIS, "R_DhcpServerQueryAttributes is called.\n"));

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );
    if( Error != ERROR_SUCCESS ) return Error;

    if( NULL == pDhcpAttribs || 0 == dwAttribCount ||
        0 != dwReserved || NULL == pDhcpAttribArr ) {
        return ERROR_INVALID_PARAMETER;
    }

    *pDhcpAttribArr = NULL;

    nAttribs = 0;
    for( i = 0; i < dwAttribCount; i ++ ) {
        if( DHCP_ATTRIB_BOOL_IS_ROGUE == pDhcpAttribs[i] 
            || DHCP_ATTRIB_BOOL_IS_DYNBOOTP == pDhcpAttribs[i] 
            || DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC == pDhcpAttribs[i]
            || DHCP_ATTRIB_BOOL_IS_ADMIN == pDhcpAttribs[i]
            || DHCP_ATTRIB_BOOL_IS_BINDING_AWARE == pDhcpAttribs[i]
            || DHCP_ATTRIB_ULONG_RESTORE_STATUS == pDhcpAttribs[i]  ) {
            nAttribs ++;
        }
    }

    if( nAttribs == 0 ) {
        //
        // No attrib is supported?
        // 
        return ERROR_NOT_SUPPORTED;
    }

    RetArr = MIDL_user_allocate(sizeof(*RetArr));
    if( NULL == RetArr ) return ERROR_NOT_ENOUGH_MEMORY;

    RetArr->NumElements = nAttribs;
    RetArr->DhcpAttribs = MIDL_user_allocate(sizeof(DHCP_ATTRIB)*nAttribs);
    if( NULL == RetArr->DhcpAttribs ) {
        MIDL_user_free(RetArr);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    nAttribs = 0;
    for( i = 0; i < dwAttribCount ; i ++) {
        if( DHCP_ATTRIB_BOOL_IS_ROGUE == pDhcpAttribs[i] ) {

            RetArr->DhcpAttribs[nAttribs].DhcpAttribId = pDhcpAttribs[i];
            RetArr->DhcpAttribs[nAttribs].DhcpAttribType = (
                DHCP_ATTRIB_TYPE_BOOL
                );
            if( DhcpGlobalNumberOfNetsActive == 0 ) {
                RetArr->DhcpAttribs[nAttribs++].DhcpAttribBool = FALSE;
            } else {
                RetArr->DhcpAttribs[nAttribs++].DhcpAttribBool = (
                    !DhcpGlobalOkToService
                    );
            }
        } else if ( DHCP_ATTRIB_BOOL_IS_DYNBOOTP == pDhcpAttribs[i] ) {
            
            RetArr->DhcpAttribs[nAttribs].DhcpAttribId = pDhcpAttribs[i];
            RetArr->DhcpAttribs[nAttribs].DhcpAttribType = (
                DHCP_ATTRIB_TYPE_BOOL
                );
            RetArr->DhcpAttribs[nAttribs++].DhcpAttribBool = (
                DhcpGlobalDynamicBOOTPEnabled
                );
        } else if ( DHCP_ATTRIB_BOOL_IS_ADMIN == pDhcpAttribs[i] ) {
            RetArr->DhcpAttribs[nAttribs].DhcpAttribId = pDhcpAttribs[i];
            RetArr->DhcpAttribs[nAttribs].DhcpAttribType = (
                DHCP_ATTRIB_TYPE_BOOL
                );
            RetArr->DhcpAttribs[nAttribs++].DhcpAttribBool = (
                ERROR_SUCCESS == DhcpApiAccessCheck( DHCP_ADMIN_ACCESS )
                );
        } else if (DHCP_ATTRIB_BOOL_IS_BINDING_AWARE == pDhcpAttribs[i] ) {
            RetArr->DhcpAttribs[nAttribs].DhcpAttribId = pDhcpAttribs[i];
            RetArr->DhcpAttribs[nAttribs].DhcpAttribType = (
                DHCP_ATTRIB_TYPE_BOOL
                );
            RetArr->DhcpAttribs[nAttribs++].DhcpAttribBool = DhcpGlobalBindingsAware; 

        } else if( DHCP_ATTRIB_BOOL_IS_PART_OF_DSDC == pDhcpAttribs[i] ) {
            PDOMAIN_CONTROLLER_INFO Info;
            
            Info = NULL;
            Error = DsGetDcNameW(
                NULL, NULL, NULL, NULL, DS_DIRECTORY_SERVICE_REQUIRED,
                &Info
                );
            RetArr->DhcpAttribs[nAttribs].DhcpAttribId = pDhcpAttribs[i];
            RetArr->DhcpAttribs[nAttribs].DhcpAttribType = (
                DHCP_ATTRIB_TYPE_BOOL
                );
            RetArr->DhcpAttribs[nAttribs++].DhcpAttribBool = (
                ERROR_SUCCESS == Error
                );
            if( NULL != Info ) NetApiBufferFree(Info);
        } else if( DHCP_ATTRIB_ULONG_RESTORE_STATUS ==  pDhcpAttribs[i] ) {
            RetArr->DhcpAttribs[nAttribs].DhcpAttribId = pDhcpAttribs[i];
            RetArr->DhcpAttribs[nAttribs].DhcpAttribType = (
                DHCP_ATTRIB_TYPE_ULONG
                );
            RetArr->DhcpAttribs[nAttribs++].DhcpAttribUlong = (
                DhcpGlobalRestoreStatus
                );
        }
    }

    *pDhcpAttribArr = RetArr;

    if( dwAttribCount == nAttribs ) return ERROR_SUCCESS;
    return ERROR_NOT_SUPPORTED;
}

DWORD
R_DhcpServerRedoAuthorization(
    IN LPWSTR ServerIpAddress,
    IN ULONG dwReserved
)
/*++

Routine Description:
    This routine restarts the rogue detection attempt right away so that if
    the server isn't authorized or is authorized, it can take appropriate
    action.  This API can be called only by administrators...

Parameters:
    ServerIpAddress -- Ip address of server in dotted string format
    dwReserved -- must be zero, unused

Return Value:
    ERROR_ACCESS_DENIED -- do not have admin priviledges on the dhcp server
    ERROR_SUCCESS

--*/
{
    ULONG Error;

    DhcpPrint(( DEBUG_APIS, "R_DhcpServerRedoAuthorization is called.\n"));

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );
    if( Error != ERROR_SUCCESS ) return Error;

    DhcpGlobalRogueRedoScheduledTime = 0;
    DhcpGlobalRedoRogueStuff = TRUE;    
    SetEvent(DhcpGlobalRogueWaitEvent);
    
    return ERROR_SUCCESS;
}

DWORD
R_DhcpGetServerBindingInfo(
    IN LPWSTR ServerIpAddress, // ignored
    IN ULONG dwReserved,
    OUT LPDHCP_BIND_ELEMENT_ARRAY *BindInfo
)
/*++

Routine Description:
    This routine gets the DHCP Server binding information.

Arguments:
    ServerIpAddress -- Ip address of server in dotted string format
    dwReserved -- must be zero, unused
    BindInfo -- On success the server returns the binding info through this.


Return Values:
    Win32 errors
 
--*/
{
    ULONG Error;

    DhcpPrint(( DEBUG_APIS, "R_DhcpGetServerBindingInfo is called.\n"));

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );
    if( Error != ERROR_SUCCESS ) return Error;

    if( 0 != dwReserved ) return ERROR_INVALID_PARAMETER;

    return DhcpGetBindingInfo( BindInfo );
}

DWORD
R_DhcpSetServerBindingInfo(
    IN LPWSTR ServerIpAddress,
    IN ULONG dwReserved,
    IN LPDHCP_BIND_ELEMENT_ARRAY BindInfo
)
/*++

Routine Description:
    This routine sets the DHCP Server binding information.

Arguments:
    ServerIpAddress -- Ip address of server in dotted string format
    dwReserved -- must be zero, unused
    BindInfo -- Binding information to set.

Return Values:
    Win32 errors

--*/
{
    ULONG Error, i, LastError;
    HKEY Key;

    DhcpPrint(( DEBUG_APIS, "R_DhcpGetServerBindingInfo is called.\n"));

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );
    if( Error != ERROR_SUCCESS ) return Error;

    if( 0 != dwReserved ) return ERROR_INVALID_PARAMETER;
    if( NULL == BindInfo ) return ERROR_INVALID_PARAMETER;

    return DhcpSetBindingInfo(BindInfo);
    
}    


DWORD
R_DhcpQueryDnsRegCredentials(
    IN LPWSTR ServerIpAddress,
    IN ULONG UnameSize,
    IN OUT LPWSTR Uname,
    IN ULONG DomainSize,
    IN OUT LPWSTR Domain
    )
{
    DWORD Error;
    WCHAR Passwd[ 256 ];
    DWORD PasswdSize = 0;
    
    
    DhcpPrint(( DEBUG_APIS, "R_DhcpQueryDnsRegCredentials is called.\n"));
    
    //
    // password size passed in bytes
    //

    PasswdSize = sizeof( Passwd );

    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );
    if( Error != ERROR_SUCCESS ) return Error;

    return DhcpQuerySecretUname(
        Uname, UnameSize*sizeof(WCHAR),
        Domain, DomainSize*sizeof(WCHAR),
        Passwd, PasswdSize );
}

DWORD
R_DhcpSetDnsRegCredentials(
    IN LPWSTR ServerIpAddress,
    IN LPWSTR Uname,
    IN LPWSTR Domain,
    IN LPWSTR Passwd
    )
{
    DWORD Error;
    
    DhcpPrint(( DEBUG_APIS, "R_DhcpSetDnsRegCredentials is called.\n"));

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );
    if( Error != ERROR_SUCCESS ) return Error;

    return DhcpSetSecretUnamePasswd( Uname, Domain, Passwd );        
}

DWORD
R_DhcpBackupDatabase(
    IN LPWSTR ServerIpAddress,
    IN LPWSTR Path
    )
{
    DWORD Error;
    LPSTR BackupPath;       // path for the database
    LPWSTR CfgBackupPath;    // path for configuration in registry
    
    DhcpPrint(( DEBUG_APIS, "R_DhcpBackupDatabase is called.\n"));

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );
    if( Error != ERROR_SUCCESS ) return Error;

    if( NULL == Path ) return ERROR_INVALID_PARAMETER;

    if( IsStringTroublesome( Path ) ) {
        return ERROR_INVALID_NAME;
    }
    
    BackupPath = DhcpUnicodeToOem( Path, NULL );
    if( NULL == BackupPath ) {
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    if ( !CreateDirectoryPathW( Path, &DhcpGlobalSecurityDescriptor )) {

        DhcpPrint((DEBUG_ERRORS, "R_DhcpBackupDatabase() : DhcpCreateDirectoryPathW(%ws): %ld\n", 
		   Path, Error ));
        DhcpFreeMemory( BackupPath );
        return Error;
    }
    

    DhcpPrint(( DEBUG_APIS, "R_DhcpBackupDatabase() : backing up to %s\n",
		BackupPath ));

    Error = DhcpBackupDatabase( BackupPath, TRUE );

    if ( ERROR_SUCCESS != Error ) {
	return Error;
    }

    // Save the configuration
    CfgBackupPath = (LPWSTR) DhcpAllocateMemory( CONFIG_BACKUP_MAX_PATH *
						 sizeof(WCHAR) );
    if (NULL != CfgBackupPath) {
	wcscpy( CfgBackupPath, Path );
	wcscat( CfgBackupPath, DHCP_KEY_CONNECT ); // append '\\'
	wcscat( CfgBackupPath, DHCP_BACKUP_CONFIG_FILE_NAME );
	
	DhcpPrint(( DEBUG_APIS, "Saving Backup configuration\n" ));

	Error = DhcpBackupConfiguration( CfgBackupPath );
	if ( ERROR_SUCCESS != Error) {
	    DhcpServerEventLog(
			       EVENT_SERVER_CONFIG_BACKUP, // TODO: Change this
			       EVENTLOG_ERROR_TYPE,
			       Error );
	    DhcpPrint(( DEBUG_ERRORS,
			"DhcpBackupConfiguration failed, %ld\n", Error ));
	} // if 

	DhcpFreeMemory( CfgBackupPath );
    } // if mem allocated

    DhcpFreeMemory( BackupPath );
    return Error;
} // R_DhcpBackupDatabase()

DWORD
R_DhcpRestoreDatabase(
    IN LPWSTR ServerIpAddress,
    IN LPWSTR Path
    )
{
    DWORD Error;
    LPWSTR JetBackupPath;
    LPWSTR CfgBackupPath;
    
    DhcpPrint(( DEBUG_APIS, "R_DhcpRestoreDatabase is called.\n"));

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );
    if( Error != ERROR_SUCCESS ) return Error;

    if( NULL == Path ) return ERROR_INVALID_PARAMETER;

    // Read the configuration from the file restore it to the registry
    
    CfgBackupPath = (LPWSTR) DhcpAllocateMemory( CONFIG_BACKUP_MAX_PATH *
						 sizeof( WCHAR ));
    if ( NULL != CfgBackupPath ) {
	wcscpy( CfgBackupPath, Path );
	wcscat( CfgBackupPath, DHCP_KEY_CONNECT );
	wcscat( CfgBackupPath, DHCP_BACKUP_CONFIG_FILE_NAME );

	DhcpPrint(( DEBUG_APIS, "Restoring (%ls) \n", CfgBackupPath ));

	// Save the parameters key
	Error = DhcpRestoreConfiguration( CfgBackupPath );
	if ( ERROR_SUCCESS != Error ) {
	    DhcpServerEventLog( EVENT_SERVER_CONFIG_RESTORE_FAILED,
				EVENTLOG_ERROR_TYPE, 
				Error );

	    DhcpPrint(( DEBUG_ERRORS,
			"DhcpBackupConfiguration failed, %ld\n", Error ));
	} // if
	
	DhcpFreeMemory( CfgBackupPath );
	if ( ERROR_SUCCESS != Error ) {
	    return ERROR_INTERNAL_ERROR;
	}
    } // if mem alloced

    //
    // If the restore is from the standard backup path, then the
    // current database need not be saved. Otherwise, we need
    // to save the current database so that this can be restored
    // if the other restore fails.
    //

    JetBackupPath = DhcpOemToUnicode( DhcpGlobalOemJetBackupPath, NULL);
    if( NULL == JetBackupPath ) {
        return ERROR_INTERNAL_ERROR;
    }

    if( 0 == _wcsicmp(Path, JetBackupPath) ) {
        DhcpFreeMemory( JetBackupPath ); JetBackupPath = NULL;
        Error = DhcpBackupDatabase(
            DhcpGlobalOemJetBackupPath, TRUE );
        if( NO_ERROR != Error ) return Error;
    }

    if( NULL != JetBackupPath ) DhcpFreeMemory( JetBackupPath );

    // Set RestoreDatabasePath key in the registry. Upon next startup,
    // database and the configuration will be updated from this location.
    Error = RegSetValueEx( DhcpGlobalRegParam,
			   DHCP_RESTORE_PATH_VALUE,
			   0, DHCP_RESTORE_PATH_VALUE_TYPE,
			   ( LPBYTE ) Path,
			   sizeof( WCHAR ) * ( wcslen( Path ) +1 ));

    return Error;
} // R_DhcpRestoreDatabase()

//
// EOF
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\rpcapi1.c ===
//================================================================================
// Copyright (C) 1997 Microsoft Corporation
// Author: RameshV
// Description: most of the rpc apis are here and some miscellaneous functions too
//================================================================================

//================================================================================
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  GENERAL WARNING: Most of the routines in this file allocate memory using
//  MIDL functions because they are used in the RPC code path (??? Really, it
//  because that is how they were written before by Madan Appiah and co? )
//  So, BEWARE.   If you read this after getting burnt, there! I tried to tell ya.
//  -- RameshV
//================================================================================

#include    <dhcppch.h>

#define     CONFIG_CHANGE_CHECK()  do{if( ERROR_SUCCESS == Error) DhcpRegUpdateTime(); } while(0)


typedef  struct _OPTION_BIN {
    DWORD                          DataSize;
    DHCP_OPTION_DATA_TYPE          OptionType;
    DWORD                          NumElements;
    BYTE                           Data[0];
} OPTION_BIN, *LPOPTION_BIN;

#define IS_SPACE_AVAILABLE(FilledSize, AvailableSize, RequiredSpace )   ((FilledSize) + (RequiredSpace) <= (AvailableSize) )

BOOL        _inline
CheckForVendor(
    IN      DWORD                  OptId,
    IN      BOOL                   IsVendor
)
{
    if( IsVendor ) return (256 <= OptId);
    return 256 > OptId;
}

DWORD       _inline
ConvertOptIdToRPCValue(
    IN      DWORD                  OptId,
    IN      BOOL                   IsVendorUnused
)
{
    return OptId % 256;
}

//BeginExport(inline)
DWORD       _inline
ConvertOptIdToMemValue(
    IN      DWORD                  OptId,
    IN      BOOL                   IsVendor
)
{
    if( IsVendor ) return OptId + 256;
    return OptId;
}
//EndExport(inline)

DWORD
DhcpUnicodeToUtf8Size(
    IN LPWSTR Str
    )
{
    return WideCharToMultiByte(
        CP_UTF8, 0, Str, -1, NULL, 0, NULL, NULL );
}

DWORD
DhcpUnicodeToUtf8(
    IN LPWSTR Str,
    IN LPSTR Buffer,
    IN ULONG BufSize
    )
{
    return WideCharToMultiByte(
        CP_UTF8, 0, Str, -1, Buffer, BufSize, NULL, NULL );
}
    
//BeginExport(function)
DWORD                                             // ERROR_MORE_DATA with DataSize as reqd size if buffer insufficient
DhcpParseRegistryOption(                          // parse the options to fill into this buffer
    IN      LPBYTE                 Value,         // input option buffer
    IN      DWORD                  Length,        // size of input buffer
    OUT     LPBYTE                 DataBuffer,    // output buffer
    OUT     DWORD                 *DataSize,      // given buffer space on input, filled buffer space on output
    IN      BOOL                   fUtf8
) //EndExport(function)
{
    LPOPTION_BIN                   OptBin;
    LPBYTE                         OptData;
    DWORD                          OptSize;
    DWORD                          OptType;
    DWORD                          nElements;
    DWORD                          i;
    DWORD                          NetworkULong;
    DWORD                          DataLength;
    DWORD                          FilledSize;
    DWORD                          AvailableSize;
    WORD                           NetworkUShort;

    FilledSize = 0;
    AvailableSize = *DataSize;
    *DataSize = 0;

    OptBin = (LPOPTION_BIN)Value;

    if(OptBin->DataSize != Length) {              // internal error!
        DhcpPrint((DEBUG_ERRORS, "Internal error while parsing options\n"));
        DhcpAssert(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    OptType = OptBin->OptionType;
    nElements = OptBin->NumElements;
    OptData = OptBin->Data;
    OptData = ROUND_UP_COUNT(sizeof(OPTION_BIN), ALIGN_WORST) + (LPBYTE)OptBin;

    for(i = 0; i < nElements ; i ++ ) {           // marshal the elements in the data buffer
        switch( OptType ) {
        case DhcpByteOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(BYTE)) ) {
                *DataBuffer = (BYTE)(*(DWORD UNALIGNED*)OptData);
                DataBuffer += sizeof(BYTE);
            }
            OptData += sizeof(DWORD);
            FilledSize += sizeof(BYTE);
            break;

        case DhcpWordOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(WORD)) ) {
                NetworkUShort = htons((WORD)(*(DWORD UNALIGNED*)OptData));
                SmbPutUshort( (LPWORD)DataBuffer, NetworkUShort );
                DataBuffer += sizeof(WORD);
            }
            OptData += sizeof(DWORD);
            FilledSize += sizeof(WORD);
            break;

        case DhcpDWordOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DWORD)) ) {
                NetworkULong = htonl(*(DWORD UNALIGNED *)OptData);
                SmbPutUlong( (LPDWORD)DataBuffer, NetworkULong );
                DataBuffer += sizeof(DWORD);
            }
            OptData += sizeof(DWORD);
            FilledSize += sizeof(DWORD);
            break;

        case DhcpDWordDWordOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DWORD)*2) ) {
                NetworkULong = htonl(((DWORD_DWORD UNALIGNED*)OptData)->DWord1);
                SmbPutUlong( (LPDWORD)DataBuffer, NetworkULong );
                DataBuffer += sizeof(DWORD);
                NetworkULong = htonl(((DWORD_DWORD UNALIGNED*)OptData)->DWord2);
                SmbPutUlong( (LPDWORD)DataBuffer, NetworkULong );
                DataBuffer += sizeof(DWORD);
            }
            OptData += sizeof(DWORD_DWORD);
            FilledSize += sizeof(DWORD_DWORD);
            break;

        case DhcpIpAddressOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DWORD) ) ) {
                NetworkULong = htonl(*(DHCP_IP_ADDRESS UNALIGNED *)OptData);
                SmbPutUlong( (LPDWORD)DataBuffer, NetworkULong );
                DataBuffer += sizeof(DWORD);
            }
            OptData += sizeof(DHCP_IP_ADDRESS);
            FilledSize += sizeof(DWORD);
            break;

        case DhcpStringDataOption:
            DataLength = *((WORD UNALIGNED*)OptData);
            OptData += sizeof(DWORD);

            DhcpAssert((wcslen((LPWSTR)OptData)+1)*sizeof(WCHAR) <= DataLength);
            if( fUtf8 ) {
                DataLength = DhcpUnicodeToUtf8Size((LPWSTR)OptData);
            } else {
                DataLength = DhcpUnicodeToOemSize((LPWSTR)OptData);
            }
            
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, DataLength ) ) {
                if( fUtf8 ) {
                    DhcpUnicodeToUtf8( (LPWSTR)OptData,(LPSTR)DataBuffer, DataLength );
                } else {
                    DhcpUnicodeToOem( (LPWSTR)OptData, (LPSTR)DataBuffer );
                }
                DataBuffer += DataLength;
            }

            FilledSize += DataLength ;
            DataLength = *((WORD UNALIGNED*)OptData);
            OptData += ROUND_UP_COUNT(DataLength, ALIGN_DWORD);
            break;

        case DhcpBinaryDataOption:
        case DhcpEncapsulatedDataOption:
            DataLength = *((WORD UNALIGNED *)OptData);
            OptData += sizeof(DWORD);

            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, DataLength) ) {
                RtlCopyMemory( DataBuffer, OptData, DataLength );
                DataBuffer += DataLength;
            }
            OptData += ROUND_UP_COUNT(DataLength, ALIGN_DWORD);
            FilledSize += DataLength;

            DhcpAssert( i == 0 );                 // should not be more than one binary element specified
            if( i > 0 ) {
                DhcpPrint(( DEBUG_OPTIONS, "Multiple Binary option packed\n"));
            }
            break;

        default:
            DhcpPrint(( DEBUG_OPTIONS, "Unknown option found\n"));
            break;
        }
    }

    *DataSize = FilledSize;
    if( FilledSize > AvailableSize ) return ERROR_MORE_DATA;

    return ERROR_SUCCESS;
}

DWORD
DhcpConvertOptionRPCToRegFormat(
    IN      LPDHCP_OPTION_DATA     Option,
    IN OUT  LPBYTE                 RegBuffer,     // OPTIONAL
    IN OUT  DWORD                 *BufferSize     // input: buffer size, output: filled buffer size
)
{
    OPTION_BIN                     Dummy;
    DWORD                          AvailableSize;
    DWORD                          FilledSize;
    DWORD                          nElements;
    DWORD                          i;
    DWORD                          DataLength;
    DWORD                          Length;
    DHCP_OPTION_DATA_TYPE          OptType;
    LPBYTE                         BufStart;

    AvailableSize = *BufferSize;
    FilledSize = 0;
    BufStart = RegBuffer;

    Dummy.DataSize = sizeof(Dummy);
    Dummy.OptionType = DhcpByteOption;
    Dummy.NumElements = 0;
    FilledSize = ROUND_UP_COUNT(sizeof(Dummy), ALIGN_WORST);

    RegBuffer += FilledSize;                      // will do this actual filling at the very end

    if( NULL == Option || 0 == Option->NumElements ) {
        OptType = DhcpByteOption;
        nElements =0;
    } else {
        OptType = Option->Elements[0].OptionType;
        nElements = Option->NumElements;
    }

    for( i = 0; i < nElements ; i ++ ) {          // marshal each argument in
        if( OptType != Option->Elements[i].OptionType ) {
            return ERROR_INVALID_PARAMETER;       // do not allow random option types, all got to be same
        }

        switch(OptType) {
        case DhcpByteOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DWORD)) ) {
                *((LPDWORD)RegBuffer) = Option->Elements[i].Element.ByteOption;
                RegBuffer += sizeof(DWORD);
            }
            FilledSize += sizeof(DWORD);
            break;
        case DhcpWordOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DWORD)) ) {
                *((LPDWORD)RegBuffer) = Option->Elements[i].Element.WordOption;
                RegBuffer += sizeof(DWORD);
            }
            FilledSize += sizeof(DWORD);
            break;
        case DhcpDWordOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DWORD) )) {
                *((LPDWORD)RegBuffer) = Option->Elements[i].Element.DWordOption;
                RegBuffer += sizeof(DWORD);
            }
            FilledSize += sizeof(DWORD);
            break;
        case DhcpDWordDWordOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DWORD_DWORD)) ) {
                *((LPDWORD_DWORD)RegBuffer) = Option->Elements[i].Element.DWordDWordOption;
                RegBuffer += sizeof(DWORD);
            }
            FilledSize += sizeof(DWORD_DWORD);
            break;
        case DhcpIpAddressOption:
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, sizeof(DHCP_IP_ADDRESS)) ) {
                *((LPDHCP_IP_ADDRESS)RegBuffer) = Option->Elements[i].Element.IpAddressOption;
                RegBuffer += sizeof(DHCP_IP_ADDRESS);
            }
            FilledSize += sizeof(DHCP_IP_ADDRESS);
            break;
        case DhcpStringDataOption:
            if( NULL == Option->Elements[i].Element.StringDataOption ) {
                DataLength = ROUND_UP_COUNT((FilledSize + sizeof(DWORD) + sizeof(WCHAR)), ALIGN_DWORD);
                DataLength -= FilledSize;
                if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, DataLength ) ) {
                    *(LPDWORD)RegBuffer = (DWORD) sizeof(WCHAR);
                    RegBuffer += sizeof(DWORD);
                    *(LPWSTR)RegBuffer = L'\0';
                    RegBuffer += ROUND_UP_COUNT(sizeof(WCHAR), ALIGN_DWORD);
                    DhcpAssert(sizeof(DWORD) + ROUND_UP_COUNT(sizeof(WCHAR),ALIGN_DWORD) == DataLength);
                }
                FilledSize += DataLength;
                break;
            }

            Length = (1+wcslen(Option->Elements[i].Element.StringDataOption))*sizeof(WCHAR);
            DataLength = ROUND_UP_COUNT((Length + FilledSize + sizeof(DWORD)), ALIGN_DWORD);
            DataLength -= FilledSize;

            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, DataLength) ) {
                *((LPDWORD)RegBuffer) = Length;
                RegBuffer += sizeof(DWORD);
                memcpy(RegBuffer, Option->Elements[i].Element.StringDataOption, Length );
                RegBuffer += ROUND_UP_COUNT(Length, ALIGN_DWORD);
                DhcpAssert(ROUND_UP_COUNT(Length,ALIGN_DWORD) + sizeof(DWORD) == DataLength);
            }
            FilledSize += DataLength;
            break;
        case DhcpBinaryDataOption:
        case DhcpEncapsulatedDataOption:
            Length = Option->Elements[i].Element.BinaryDataOption.DataLength;
            DataLength = ROUND_UP_COUNT((FilledSize+Length+sizeof(DWORD)), ALIGN_DWORD);
            DataLength -= FilledSize;
            if( IS_SPACE_AVAILABLE(FilledSize, AvailableSize, DataLength) ) {
                *((LPDWORD)RegBuffer) = Length;
                RegBuffer += sizeof(DWORD);
                memcpy(RegBuffer, Option->Elements[i].Element.BinaryDataOption.Data, Length);
                Length = ROUND_UP_COUNT(Length, ALIGN_DWORD);
                DhcpAssert(Length + sizeof(DWORD) == DataLength);
                RegBuffer += Length;
            }
            FilledSize += DataLength;
            break;
        default:
            return ERROR_INVALID_PARAMETER;       // Dont support any other kind of options
        }
    }
    // Length = ROUND_UP_COUNT(FilledSize, ALIGN_WORST);
    *BufferSize = FilledSize;
    if( AvailableSize < FilledSize ) return ERROR_MORE_DATA;

    Dummy.NumElements = nElements;
    Dummy.DataSize = *BufferSize;
    Dummy.OptionType = OptType;
    memcpy(BufStart, (LPBYTE)&Dummy, sizeof(Dummy));
    return ERROR_SUCCESS;
}

DWORD
DhcpConvertOptionRegToRPCFormat(
    IN      LPBYTE                 Buffer,
    IN      DWORD                  BufferSize,
    OUT     LPDHCP_OPTION_DATA     Option,        // struct pre-allocated, all sub fields will be allocated..
    OUT     DWORD                 *AllocatedSize  // OPTIONAL, total # of bytes allocated..
)
{
    LPOPTION_BIN                   OptBin;
    LPBYTE                         OptData;
    LPBYTE                         DataBuffer;
    DWORD                          OptSize;
    DWORD                          OptType;
    DWORD                          nElements;
    DWORD                          i;
    DWORD                          NetworkULong;
    DWORD                          DataLength;
    DWORD                          FilledSize;
    DWORD                          AvailableSize;
    WORD                           NetworkUShort;
    LPDHCP_OPTION_DATA_ELEMENT     Elements;

    FilledSize = 0;
    if( AllocatedSize ) *AllocatedSize = 0;

    OptBin = (LPOPTION_BIN)Buffer;

    if(OptBin->DataSize != BufferSize) {              // internal error!
        DhcpPrint((DEBUG_ERRORS, "Internal error while parsing options\n"));
        DhcpAssert(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    OptType = OptBin->OptionType;
    nElements = OptBin->NumElements;
    OptData = OptBin->Data;
    OptData = ROUND_UP_COUNT(sizeof(OPTION_BIN), ALIGN_WORST) + (LPBYTE)OptBin;

    Option->NumElements = 0;
    Option->Elements = NULL;

    if( 0 == nElements ) {
        return ERROR_SUCCESS;
    }

    Elements = (LPDHCP_OPTION_DATA_ELEMENT)MIDL_user_allocate(nElements*sizeof(DHCP_OPTION_DATA_ELEMENT));
    if( NULL == Elements ) return ERROR_NOT_ENOUGH_MEMORY;

    for(i = 0; i < nElements ; i ++ ) {           // marshal the elements in the data buffer
        Elements[i].OptionType = OptType;

        switch( OptType ) {
        case DhcpByteOption:
            Elements[i].Element.ByteOption = *((LPBYTE)OptData);
            OptData += sizeof(DWORD);
            break;

        case DhcpWordOption:
            Elements[i].Element.WordOption = (WORD)(*((LPDWORD)OptData));
            OptData += sizeof(DWORD);
            break;

        case DhcpDWordOption:
            Elements[i].Element.DWordOption = *((LPDWORD)OptData);
            OptData += sizeof(DWORD);
            break;

        case DhcpDWordDWordOption:
            Elements[i].Element.DWordDWordOption = *((LPDWORD_DWORD)OptData);
            OptData += sizeof(DWORD_DWORD);
            break;

        case DhcpIpAddressOption:
            Elements[i].Element.IpAddressOption = *((LPDHCP_IP_ADDRESS)OptData);
            OptData += sizeof(DHCP_IP_ADDRESS);
            break;

        case DhcpStringDataOption:
        case DhcpBinaryDataOption:
        case DhcpEncapsulatedDataOption:
            DataLength = *((LPWORD)OptData);
            OptData += sizeof(DWORD);

	    if ( 0 != DataLength) {
		DataBuffer = MIDL_user_allocate(DataLength);
		if( DataBuffer == NULL ) {
		    while( i -- >= 1 ) {                   // free all local strucutures..
			_fgs__DHCP_OPTION_DATA_ELEMENT(&Elements[i]);
		    }
		    MIDL_user_free(Elements);
		    return ERROR_NOT_ENOUGH_MEMORY;   // cleaned everything, so return silently
		}
		
		RtlCopyMemory( DataBuffer, OptData, DataLength );
		OptData += ROUND_UP_COUNT(DataLength, ALIGN_DWORD);
		FilledSize += DataLength;
	    } // if
	    else {
		DataBuffer = NULL;
	    }
	    if( OptType == DhcpStringDataOption ) {
		Elements[i].Element.StringDataOption = (LPWSTR)DataBuffer;
	    } else {
		Elements[i].Element.BinaryDataOption.DataLength = DataLength;
		Elements[i].Element.BinaryDataOption.Data = DataBuffer;
	    }

            DhcpAssert( i == 0 );                 // should not be more than one binary element specified
            if( i > 0 ) {
                DhcpPrint(( DEBUG_OPTIONS, "Multiple Binary option packed\n"));
            }
            break;

        default:
            DhcpPrint(( DEBUG_OPTIONS, "Unknown option found\n"));
            break;
        }
    }

    Option->NumElements = i;                      // this handles the case of a wrong option being ignored..
    Option->Elements = Elements;

    if(AllocatedSize ) {                          // if asked for allocated size, fill that in
        *AllocatedSize = nElements * sizeof(DHCP_OPTION_DATA_ELEMENT) + FilledSize;
    }
    return ERROR_SUCCESS;
}

DWORD
ConvertOptionInfoRPCToMemFormat(
    IN      LPDHCP_OPTION          OptionInfo,
    OUT     LPWSTR                *Name,
    OUT     LPWSTR                *Comment,
    OUT     DWORD                 *OptId,
    OUT     LPBYTE                *Value,
    OUT     DWORD                 *ValueSize
)
{
    DWORD                          Error;

    if( Name ) *Name = OptionInfo->OptionName;
    if( Comment ) *Comment = OptionInfo->OptionComment;
    if( OptId ) *OptId = (DWORD)(OptionInfo->OptionID);
    if( Value ) {
        *Value = NULL;
        if( !ValueSize ) return ERROR_INVALID_PARAMETER;
        *ValueSize = 0;
        Error = DhcpConvertOptionRPCToRegFormat(
            &OptionInfo->DefaultValue,
            NULL,
            ValueSize
        );

        if( ERROR_MORE_DATA != Error ) return Error;
        DhcpAssert(0 != *ValueSize);

        *Value = DhcpAllocateMemory(*ValueSize);
        if( NULL == *Value ) {
            *ValueSize = 0;
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        Error = DhcpConvertOptionRPCToRegFormat(
            &OptionInfo->DefaultValue,
            *Value,
            ValueSize
        );

        DhcpAssert(ERROR_MORE_DATA != Error);
        DhcpAssert(ERROR_SUCCESS == Error);

        if( ERROR_SUCCESS != Error ) {
            DhcpFreeMemory(*Value);
            *Value = NULL;
            *ValueSize = 0;
            return Error;
        }
    }

    return ERROR_SUCCESS;
}

DWORD       _inline
DhcpGetClassIdFromName(
    IN      LPWSTR                 Name,
    OUT     DWORD                 *ClassId
)
{
    DWORD                          Error;
    PM_CLASSDEF                    ClassDef;

    Error = ERROR_SUCCESS;
    if( NULL == Name ) *ClassId = 0;
    else {
        Error = MemServerGetClassDef(
            DhcpGetCurrentServer(),
            0,
            Name,
            0,
            NULL,
            &ClassDef
        );
        if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_CLASS_NOT_FOUND;
        else if( ERROR_SUCCESS == Error ) {
            DhcpAssert(ClassDef);
            if( ClassDef->IsVendor == TRUE ) {
                Error = ERROR_DHCP_CLASS_NOT_FOUND;
            } else {
                *ClassId = ClassDef->ClassId;
            }
        }
    }
    return Error;
}

DWORD       _inline
DhcpGetVendorIdFromName(
    IN      LPWSTR                 Name,
    OUT     DWORD                 *VendorId
)
{
    DWORD                          Error;
    PM_CLASSDEF                    ClassDef;

    Error = ERROR_SUCCESS;
    if( NULL == Name ) *VendorId = 0;
    else {
        Error = MemServerGetClassDef(
            DhcpGetCurrentServer(),
            0,
            Name,
            0,
            NULL,
            &ClassDef
        );
        if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_CLASS_NOT_FOUND;
        else if( ERROR_SUCCESS == Error ) {
            DhcpAssert(ClassDef);
            if( ClassDef->IsVendor == FALSE ) {
                Error = ERROR_DHCP_CLASS_NOT_FOUND;
            } else {
                *VendorId = ClassDef->ClassId;
            }
        }
    }
    return Error;
}

DWORD                                             // fail if class absent or exists in memory (registry obj may exist tho)
DhcpCreateOptionDef(                              // Create, fill the memory and write it to registry
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      DWORD                  OptId,
    IN      DWORD                  OptType,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptLen         // these should be ConvertOptionInfoRPCToMemFormat'ed
)
{
    DWORD                          Error;
    DWORD                          ClassId;
    DWORD                          VendorId;
    PM_OPTDEF                      OptDef;

    Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpGetVendorIdFromName(VendorName, &VendorId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerGetOptDef(
        DhcpGetCurrentServer(),
        ClassId,
        VendorId,
        OptId,
        Name,
        &OptDef
    );
    if( ERROR_FILE_NOT_FOUND != Error ) {
        if( ERROR_SUCCESS == Error ) Error = ERROR_DHCP_OPTION_EXITS;
        return Error;
    }

    Error = MemServerAddOptDef(
        DhcpGetCurrentServer(),
        ClassId,
        VendorId,
        OptId,
        Name,
        Comment,
        OptType,
        OptVal,
        OptLen
    );
    return Error;
}

DWORD
DhcpModifyOptionDef(                              // fill the memory and write it to registry (must exist)
    IN      LPWSTR                 Name,
    IN      LPWSTR                 Comment,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      DWORD                  OptId,
    IN      DWORD                  OptType,
    IN      LPBYTE                 OptVal,
    IN      DWORD                  OptLen         // these should be ConvertOptionInfoRPCToMemFormat'ed
)
{
    DWORD                          Error;
    DWORD                          ClassId;
    DWORD                          VendorId;

    Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpGetVendorIdFromName(VendorName, &VendorId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerDelOptDef(                   // now try to delete it from memory..
        DhcpGetCurrentServer(),
        ClassId,
        VendorId,
        OptId
    );
    if( ERROR_FILE_NOT_FOUND == Error ) {         // oops could not? then this option is not present..
        return ERROR_DHCP_OPTION_NOT_PRESENT;
    }

    Error =  DhcpCreateOptionDef(                 // cleared registry and memory, so safely create the option..
        Name,
        Comment,
        ClassName,
        VendorName,
        OptId,
        OptType,
        OptVal,
        OptLen
    );

    DhcpAssert(ERROR_DHCP_OPTION_EXITS != Error); // dont expect this to be a problem, as we just deleted it

    return Error;
}

LPWSTR
CloneLPWSTR(                                      // allocate and copy a LPWSTR type
    IN      LPWSTR                 Str
)
{
    LPWSTR                         S;

    if( NULL == Str ) return NULL;
    S = MIDL_user_allocate(sizeof(WCHAR)*(1+wcslen(Str)));
    if( NULL == S ) return NULL;                  // what else to do here? 
    wcscpy(S, Str);
    return S;
}

LPBYTE
CloneLPBYTE(
    IN      LPBYTE                 Bytes,
    IN      DWORD                  nBytes
)
{
    LPBYTE                         Ptr;

    DhcpAssert(Bytes && nBytes > 0);
    Ptr = MIDL_user_allocate(nBytes);
    if( NULL == Ptr ) return Ptr;
    memcpy(Ptr,Bytes,nBytes);

    return Ptr;
}

DWORD
DhcpGetOptionDefInternal(                         // search by classid and (optionid or option name) and fill RPC struct
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    IN      PM_OPTDEF              OptDef,
    OUT     LPDHCP_OPTION          OptionInfo,    // MIDL_user_allocate fields in the structure
    OUT     DWORD                 *AllocatedSize  // OPTIONAL # of bytes allocated
)
{
    DWORD                          Error;
    DWORD                          FilledSize;
    DWORD                          OptId = OptDef->OptId;

    FilledSize = 0;

    OptionInfo->OptionID = ConvertOptIdToRPCValue(OptId, TRUE);
    OptionInfo->OptionName = CloneLPWSTR(OptDef->OptName);
    if( OptDef->OptName ) FilledSize += sizeof(WCHAR)*(1+wcslen(OptDef->OptName));
    OptionInfo->OptionComment = CloneLPWSTR(OptDef->OptComment);
    if( OptDef->OptComment ) FilledSize += sizeof(WCHAR)*(1+wcslen(OptDef->OptComment));
    OptionInfo->OptionType = OptDef->Type;
    Error = DhcpConvertOptionRegToRPCFormat(
        OptDef->OptVal,
        OptDef->OptValLen,
        &OptionInfo->DefaultValue,
        AllocatedSize
    );
    if( AllocatedSize ) (*AllocatedSize) += FilledSize;

    if( ERROR_SUCCESS != Error ) {                // cleanup everything..
        _fgs__DHCP_OPTION(OptionInfo);            // lookup oldstub.c for this mystery
        if( AllocatedSize ) *AllocatedSize = 0;

        DhcpPrint((DEBUG_APIS, "DhcpGetOptionDefInternal(%ld):%ld [0x%lx]\n", OptId, Error, Error));
    }

    return Error;
}

DWORD
DhcpGetOptionDef(                                 // search by classid and (optionid or option name) and fill RPC struct
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      DWORD                  OptId,
    IN      LPWSTR                 OptName,
    OUT     LPDHCP_OPTION          OptionInfo,    // MIDL_user_allocate fields in the structure
    OUT     DWORD                 *AllocatedSize  // OPTIONAL # of bytes allocated
)
{
    DWORD                          Error;
    DWORD                          ClassId;
    DWORD                          VendorId;
    PM_OPTDEF                      OptDef;

    Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpGetVendorIdFromName(VendorName, &VendorId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerGetOptDef(
        DhcpGetCurrentServer(),
        ClassId,
        VendorId,
        OptId,
        OptName,
        &OptDef
    );
    if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_OPTION_NOT_PRESENT;
    if( ERROR_SUCCESS != Error ) return Error;

    return DhcpGetOptionDefInternal(
        ClassId,
        VendorId,
        OptDef,
        OptionInfo,
        AllocatedSize
    );
}

DWORD
DhcpEnumRPCOptionDefs(                            // enumerate for the RPC call
    IN      DWORD                  Flags,         // DHCP_FLAGS_OPTION_IS_VENDOR ==> this opt is vendor spec..
    IN OUT  DWORD                 *ResumeHandle,  // integer position in the registry..
    IN      LPWSTR                 ClassName,     // which class is being referred here?
    IN      LPWSTR                 VendorName,    // if opt is vendor specific, who is vendor?
    IN      DWORD                  PreferredMax,  // preferred max # of bytes..
    OUT     LPDHCP_OPTION_ARRAY   *OptArray,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Error, Error2;
    DWORD                          nElements;
    DWORD                          Index;
    DWORD                          Count;
    DWORD                          AllocatedSize;
    DWORD                          FilledSize;
    DWORD                          ClassId;
    DWORD                          VendorId;
    BOOL                           IsVendor;
    PARRAY                         pArray;
    ARRAY_LOCATION                 Loc;
    LPDHCP_OPTION_ARRAY            LocalOptArray;
    PM_OPTCLASSDEFLIST             OptClassDefList;
    PM_OPTDEFLIST                  OptDefList;
    PM_OPTDEF                      OptDef;

    *OptArray = NULL;
    *nRead = 0;
    *nTotal = 0;
    FilledSize = 0;

    IsVendor = ((Flags & DHCP_FLAGS_OPTION_IS_VENDOR) != 0);
    if( FALSE == IsVendor && 0 != Flags ) return ERROR_INVALID_PARAMETER;

    Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpGetVendorIdFromName(VendorName, &VendorId);
    if( ERROR_SUCCESS != Error ) return Error;

    *OptArray = NULL;
    *nRead = *nTotal = 0;

    OptClassDefList = &(DhcpGetCurrentServer()->OptDefs);
    Error = MemOptClassDefListFindOptDefList(
        OptClassDefList,
        ClassId,
        VendorId,
        &OptDefList
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_NO_MORE_ITEMS;
    if( ERROR_SUCCESS != Error ) return Error;

    nElements = MemArraySize(pArray = &OptDefList->OptDefArray);
    if( 0 == nElements || nElements <= *ResumeHandle ) {
        return ERROR_NO_MORE_ITEMS;
    }

    Count = 0;
    Error = MemArrayInitLoc(pArray, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error);
    while(Count < *ResumeHandle ) {
        Count ++;
        Error = MemArrayGetElement(pArray, &Loc, (LPVOID*)&OptDef);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != OptDef);
        DhcpPrint((DEBUG_APIS, "Discarding option <%ws>\n", OptDef->OptName));
        Error = MemArrayNextLoc(pArray, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    LocalOptArray = MIDL_user_allocate(sizeof(DHCP_OPTION_ARRAY));
    if( NULL == LocalOptArray ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LocalOptArray->NumElements = 0;
    LocalOptArray->Options = MIDL_user_allocate(sizeof(DHCP_OPTION)*(nElements- (*ResumeHandle)));
    if( NULL == LocalOptArray->Options ) {
        MIDL_user_free(LocalOptArray);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Index = 0;
    Error = ERROR_SUCCESS;
    while(Count < nElements ) {
        Count ++;

        Error = MemArrayGetElement(pArray, &Loc, (LPVOID*)&OptDef);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != OptDef);
        Error = MemArrayNextLoc(pArray, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error || Count == nElements);

        Error = ERROR_SUCCESS;
        if( !CheckForVendor(OptDef->OptId,IsVendor) ) continue;
        Error = DhcpGetOptionDef(
            ClassName,
            VendorName,
            OptDef->OptId,
            NULL,
            &(LocalOptArray->Options[Index]),
            &AllocatedSize
        );
        if( ERROR_SUCCESS != Error ) {
            LocalOptArray->NumElements = Index;
            _fgs__DHCP_OPTION_ARRAY( LocalOptArray );
            MIDL_user_free( LocalOptArray );
            return Error;
        }
        if( FilledSize + AllocatedSize + sizeof(DHCP_OPTION) < PreferredMax ) {
            FilledSize += AllocatedSize + sizeof(DHCP_OPTION);
            Index ++;
        } else {
            Error = ERROR_MORE_DATA;
            _fgs__DHCP_OPTION(&(LocalOptArray->Options[Index]));
            break;
        }
    }

    LocalOptArray->NumElements = Index;
    if( 0 == Index ) {
        MIDL_user_free(LocalOptArray->Options);
        MIDL_user_free(LocalOptArray);
        if( ERROR_SUCCESS == Error ) return ERROR_NO_MORE_ITEMS;
        return Error;
    }

    *OptArray = LocalOptArray;
    *nRead = Index;
    *nTotal = nElements - Count + Index;
    *ResumeHandle = Count;

    return Error;
}

DWORD
DhcpDeleteOptionDef(
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      DWORD                  OptionId
)
{
    DWORD                          Error;
    DWORD                          ClassId;
    DWORD                          VendorId;

    Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpGetVendorIdFromName(VendorName, &VendorId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemServerDelOptDef(
        DhcpGetCurrentServer(),
        ClassId,
        VendorId,
        OptionId
    );

    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_OPTION_NOT_PRESENT;
    return Error;
}

DWORD
EndWriteApiForScopeInfo(
    IN LPSTR ApiName,
    IN DWORD Error,
    IN LPDHCP_OPTION_SCOPE_INFO ScopeInfo
    )
{
    DWORD                          Scope, Mscope, Res;
    PM_SUBNET                      Subnet;
    PM_RESERVATION                 Reservation;

    if( NO_ERROR != Error ) {
        return DhcpEndWriteApi( ApiName, Error );
    }

    Scope = Mscope = Res = 0;

    Subnet = NULL; Reservation = NULL;
    switch( ScopeInfo->ScopeType ) {
    case DhcpSubnetOptions:
        Error = MemServerGetAddressInfo(
            DhcpGetCurrentServer(),
            ScopeInfo->ScopeInfo.SubnetScopeInfo,
            &Subnet, NULL, NULL, NULL );
        if( ERROR_SUCCESS != Error ) {            // got the subnet in question
            Subnet = NULL;
        }
        break;
    case DhcpMScopeOptions :
        Error = DhcpServerFindMScope(
            DhcpGetCurrentServer(),
            INVALID_MSCOPE_ID,
            ScopeInfo->ScopeInfo.MScopeInfo,
            &Subnet
            );

        if( ERROR_SUCCESS != Error ) {            // got the subnet in question
            Subnet = NULL;
        }
    case DhcpReservedOptions :
        Error = MemServerGetAddressInfo(
            DhcpGetCurrentServer(),
            ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpAddress,
            &Subnet, NULL, NULL, &Reservation
        );
        if( ERROR_SUCCESS != Error ) {            // found the reservation in question
            Subnet = NULL; Reservation = NULL;
        }
        break;
    }

    if( Reservation != NULL ) {
        Res = Reservation->Address;
    } else if( Subnet ) {
        if( Subnet->fSubnet ) {
            Scope = Subnet->Address;
        } else {
            Mscope = Subnet->MScopeId;
            if( 0 == Mscope ) Mscope = INVALID_MSCOPE_ID;
        }
    }

    return DhcpEndWriteApiEx(
        ApiName, NO_ERROR, FALSE, TRUE, Scope, Mscope, Res );
}                    
        
DWORD
DhcpSetOptionValue(                               // add/replace this option value to inmemory store and registry
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      DWORD                  OptId,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptData
)
{
    DWORD                          Error;
    DWORD                          ClassId;
    DWORD                          VendorId;
    PM_OPTDEF                      OptDef;
    PM_OPTDEFLIST                  OptDefList;
    PM_OPTCLASS                    OptClass;
    PM_OPTION                      Option;
    PM_OPTION                      DeletedOption;
    PM_SUBNET                      Subnet;
    PM_RESERVATION                 Reservation;
    LPBYTE                         Value;
    DWORD                          ValueSize;

    Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpGetVendorIdFromName(VendorName, &VendorId);
    if( ERROR_SUCCESS != Error ) return Error;

    if( DhcpDefaultOptions == ScopeInfo->ScopeType ) {
        Error = MemServerGetOptDef(               // dont allow option values without defs only for default values..
            DhcpGetCurrentServer(),
            0, // ClassId,                        // dont bother about the class id -- get this option anyways
            VendorId,
            OptId,
            NULL,
            &OptDef
        );
        if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_OPTION_NOT_PRESENT;
        if( ERROR_SUCCESS != Error ) return Error;
    }

    ValueSize = 0;
    Error = DhcpConvertOptionRPCToRegFormat(OptData, NULL, &ValueSize);
    if( ERROR_MORE_DATA != Error ) {
        DhcpAssert(ERROR_SUCCESS != Error);
        return Error;
    }

    Value = DhcpAllocateMemory(ValueSize);
    if( NULL == Value ) return ERROR_NOT_ENOUGH_MEMORY;

    Error = DhcpConvertOptionRPCToRegFormat(OptData, Value, &ValueSize);
    DhcpAssert(ERROR_MORE_DATA != Error);

    if( DhcpDefaultOptions == ScopeInfo->ScopeType ) {
        Error = MemServerAddOptDef(
            DhcpGetCurrentServer(),
            ClassId,
            VendorId,
            OptId,
            OptDef->OptName,
            OptDef->OptComment,
            OptDef->Type,
            Value,
            ValueSize
            );
        if(Value ) DhcpFreeMemory(Value);
        return Error;
    }

    Error = MemOptInit(
        &Option,
        OptId,
        ValueSize,
        Value
    );
    DhcpFreeMemory(Value);
    if( ERROR_SUCCESS != Error ) return Error;
    DeletedOption = NULL;

    if(DhcpGlobalOptions == ScopeInfo->ScopeType ) {
        OptClass = &(DhcpGetCurrentServer()->Options);
    } else if( DhcpSubnetOptions == ScopeInfo->ScopeType ) {
        Error = MemServerGetAddressInfo(
            DhcpGetCurrentServer(),
            ScopeInfo->ScopeInfo.SubnetScopeInfo,
            &Subnet,
            NULL,
            NULL,
            NULL
        );
        if( ERROR_SUCCESS == Error ) {            // got the subnet in question
            DhcpAssert(Subnet);
            OptClass = &(Subnet->Options);
            DhcpAssert(Subnet->Address == ScopeInfo->ScopeInfo.SubnetScopeInfo);
            OptClass = &Subnet->Options;
        }
    } else if( DhcpMScopeOptions == ScopeInfo->ScopeType ) {
        Error = DhcpServerFindMScope(
            DhcpGetCurrentServer(),
            INVALID_MSCOPE_ID,
            ScopeInfo->ScopeInfo.MScopeInfo,
            &Subnet
            );

        if( ERROR_SUCCESS == Error ) {            // got the subnet in question
            DhcpAssert(Subnet);
            OptClass = &(Subnet->Options);
        }
    } else if( DhcpReservedOptions == ScopeInfo->ScopeType ) {
        Error = MemServerGetAddressInfo(
            DhcpGetCurrentServer(),
            ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpAddress,
            &Subnet,
            NULL,
            NULL,
            &Reservation
        );
        if( ERROR_SUCCESS == Error ) {            // found the reservation in question
            if( NULL == Reservation ) {
                Error = ERROR_DHCP_NOT_RESERVED_CLIENT;
            }
        }

        if( ERROR_SUCCESS == Error ) {
            DhcpAssert(Subnet && Reservation);
            OptClass = &(Reservation->Options);
            if( Subnet->Address != ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress ) {
                DhcpAssert(FALSE);                // found it in a different subnet?
                Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
            } else {
                OptClass = &Reservation->Options;
            }
        }
    } else {
        DhcpAssert(FALSE);                        // expect one of the above as params..
        Error = ERROR_INVALID_PARAMETER;          // dont know anything better to return
    }

    if( ERROR_SUCCESS == Error ) {                // managed to save in registry
        DhcpAssert(OptClass);                     // we must have found the right option location to add to
        Error = MemOptClassAddOption(
            OptClass,
            Option,
            ClassId,
            VendorId,
            &DeletedOption                        // check to see if we replaced an existing option
        );
        if( ERROR_SUCCESS == Error && DeletedOption ) {
            MemFree(DeletedOption);               // if we did replace, free the old option
        }
    }

    if( ERROR_SUCCESS != Error ) {                // something went wrong, clean up
        ULONG LocalError = MemOptCleanup(Option);
        DhcpAssert(ERROR_SUCCESS == LocalError);
    }

    return Error;
}

DWORD
DhcpGetOptionValue(                               // fetch a specific option..
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory and fill in with data
)
{
    DWORD                          Error;
    DWORD                          ClassId;
    DWORD                          VendorId;
    LPDHCP_OPTION_VALUE            LocalOptionValue;
    PM_OPTDEF                      OptDef;
    PM_SERVER                      Server;
    PM_SUBNET                      Subnet;
    PM_RESERVATION                 Reservation;
    PM_OPTCLASS                    OptClass;
    PM_OPTLIST                     OptList;
    PM_OPTION                      Opt;

    *OptionValue = NULL;

    Server = DhcpGetCurrentServer();

    Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpGetVendorIdFromName(VendorName, &VendorId);
    if( ERROR_SUCCESS != Error ) return Error;

    if( DhcpDefaultOptions == ScopeInfo->ScopeType ) {
        Error = MemServerGetOptDef(               // check for optdef only for default options ...
            Server,
            0, // ClassId,                        // dont bother about class for getting option def's
            VendorId,
            OptId,
            NULL,
            &OptDef
        );
        if( ERROR_FILE_NOT_FOUND == Error ) Error = ERROR_DHCP_OPTION_NOT_PRESENT;
        if( ERROR_SUCCESS != Error ) return Error;
    }

    LocalOptionValue = MIDL_user_allocate(sizeof(DHCP_OPTION_VALUE));
    if( NULL == LocalOptionValue ) return ERROR_NOT_ENOUGH_MEMORY;
    LocalOptionValue->OptionID = ConvertOptIdToRPCValue(OptId, TRUE);

    if( DhcpDefaultOptions == ScopeInfo->ScopeType ) {
        Error = DhcpConvertOptionRegToRPCFormat(
            OptDef->OptVal,
            OptDef->OptValLen,
            &LocalOptionValue->Value,
            NULL
        );
        if( ERROR_SUCCESS != Error ) {
            MIDL_user_free(LocalOptionValue);
        }
        return Error;
    }

    switch(ScopeInfo->ScopeType) {
    case DhcpGlobalOptions : OptClass = &Server->Options; Error = ERROR_SUCCESS; break;
    case DhcpSubnetOptions:
        Error = MemServerGetAddressInfo(
            Server,
            ScopeInfo->ScopeInfo.SubnetScopeInfo,
            &Subnet,
            NULL,
            NULL,
            NULL
        );
        if( ERROR_SUCCESS == Error ) {
            DhcpAssert(Subnet);
            OptClass = &Subnet->Options;
        } else {
            if( ERROR_FILE_NOT_FOUND == Error )
                Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
        }
        break;
    case DhcpMScopeOptions:
        Error = DhcpServerFindMScope(
            DhcpGetCurrentServer(),
            INVALID_MSCOPE_ID,
            ScopeInfo->ScopeInfo.MScopeInfo,
            &Subnet
            );
        if( ERROR_SUCCESS == Error ) {
            DhcpAssert(Subnet);
            OptClass = &Subnet->Options;
        } else {
            if( ERROR_FILE_NOT_FOUND == Error )
                Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
        }
        break;
    case DhcpReservedOptions:
        Error = MemServerGetAddressInfo(
            Server,
            ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpAddress,
            &Subnet,
            NULL,
            NULL,
            &Reservation
        );
        if( ERROR_FILE_NOT_FOUND == Error ) {
            Error = ERROR_DHCP_NOT_RESERVED_CLIENT;
        } else if( ERROR_SUCCESS == Error ) {
            if( NULL == Subnet ) {
                Error = ERROR_DHCP_SUBNET_NOT_PRESENT ;
            } else if( NULL == Reservation ) {
                Error = ERROR_DHCP_NOT_RESERVED_CLIENT;
            } else if( Subnet->Address != ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress ) {
                Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
            } else {
                OptClass = &Reservation->Options;
            }
        }
        break;
    default:
        Error = ERROR_INVALID_PARAMETER;
    }

    if( ERROR_SUCCESS == Error ) {
        Error = MemOptClassFindClassOptions(
            OptClass,
            ClassId,
            VendorId,
            &OptList
        );
        if( ERROR_SUCCESS == Error ) {
            DhcpAssert(NULL != OptList);

            Error = MemOptListFindOption(
                OptList,
                OptId,
                &Opt
            );
        }
    }

    if( ERROR_SUCCESS == Error ) {
        DhcpAssert(Opt);
        DhcpAssert(Opt->OptId == OptId);
        Error = DhcpConvertOptionRegToRPCFormat(
            Opt->Val,
            Opt->Len,
            &LocalOptionValue->Value,
            NULL
        );
    }

    if( ERROR_SUCCESS != Error ) {
        MIDL_user_free(LocalOptionValue);
    } else {
        *OptionValue = LocalOptionValue;
    }

    return Error;
}

DWORD
FindOptClassForScope(                             // find the optclass array corresponding to scope...
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     PM_OPTCLASS           *OptClass       // fill in this ptr..
)
{
    DWORD                          Error;
    PM_SERVER                      Server;
    PM_SUBNET                      Subnet;
    PM_RESERVATION                 Reservation;

    Server = DhcpGetCurrentServer();

    switch(ScopeInfo->ScopeType) {
    case DhcpGlobalOptions:
        *OptClass = &Server->Options; Error = ERROR_SUCCESS; break;
    case DhcpSubnetOptions:
        Error = MemServerGetAddressInfo(
            Server,
            ScopeInfo->ScopeInfo.SubnetScopeInfo,
            &Subnet,
            NULL,
            NULL,
            NULL
        );
        if( ERROR_SUCCESS == Error ) {
            DhcpAssert(Subnet);
            *OptClass = &Subnet->Options;
        } else if( ERROR_FILE_NOT_FOUND == Error ) {
            Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
        }
        break;
    case DhcpMScopeOptions:
        Error = DhcpServerFindMScope(
            DhcpGetCurrentServer(),
            INVALID_MSCOPE_ID,
            ScopeInfo->ScopeInfo.MScopeInfo,
            &Subnet
        );
        if( ERROR_SUCCESS == Error ) {
            DhcpAssert(Subnet);
            *OptClass = &Subnet->Options;
        } else if( ERROR_FILE_NOT_FOUND == Error ) {
            Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
        }
        break;
    case DhcpReservedOptions:
        Error = MemServerGetAddressInfo(
            Server,
            ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpAddress,
            &Subnet,
            NULL,
            NULL,
            &Reservation
        );
        if( ERROR_SUCCESS == Error ) {
            DhcpAssert(Subnet);
            if( NULL == Reservation ) {
                Error = ERROR_DHCP_NOT_RESERVED_CLIENT;
            } else if( Subnet->Address != ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress ) {
                Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
            } else {
                *OptClass = &Reservation->Options;
            }
        } else if( ERROR_FILE_NOT_FOUND == Error ) {
            Error = ERROR_DHCP_NOT_RESERVED_CLIENT;
        }
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    return Error;
}

DWORD
DhcpEnumOptionValuesInternal(                     // scopeinfo can be anything but DhcpDefaultOptions
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DWORD                  ClassId,
    IN      DWORD                  VendorId,
    IN      BOOL                   IsVendor,      // do we want to enumerate only vendor or only non-vendor?
    IN OUT  DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Error;
    DWORD                          Index;
    DWORD                          Count;
    DWORD                          nElements;
    DWORD                          FilledSize;
    DWORD                          UsedSize;
    PM_SERVER                      Server;
    PM_SUBNET                      Subnet;
    PM_RESERVATION                 Reservation;
    PM_OPTCLASS                    OptClass;
    PM_OPTLIST                     OptList;
    PM_OPTION                      Opt;
    PM_OPTDEF                      OptDef;
    PARRAY                         pArray;
    ARRAY_LOCATION                 Loc;
    LPDHCP_OPTION_VALUE_ARRAY      LocalOptValueArray;
    LPDHCP_OPTION_VALUE            LocalOptValues;

    Server = DhcpGetCurrentServer();

    *OptionValues = NULL;
    *nRead = *nTotal = 0;

    Error = FindOptClassForScope(ScopeInfo, &OptClass);
    if( ERROR_SUCCESS != Error ) return Error;
    DhcpAssert(OptClass);

    Error = MemOptClassFindClassOptions(
        OptClass,
        ClassId,
        VendorId,
        &OptList
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_NO_MORE_ITEMS;

    nElements = MemArraySize(OptList);
    if( 0 == nElements || nElements <= *ResumeHandle ) return ERROR_NO_MORE_ITEMS;

    LocalOptValueArray = MIDL_user_allocate(sizeof(DHCP_OPTION_VALUE_ARRAY));
    if( NULL == LocalOptValueArray ) return ERROR_NOT_ENOUGH_MEMORY;

    LocalOptValues = MIDL_user_allocate(sizeof(DHCP_OPTION_VALUE)*(nElements - *ResumeHandle));
    if( NULL == LocalOptValues ) {
        MIDL_user_free(LocalOptValueArray);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LocalOptValueArray->NumElements = 0;
    LocalOptValueArray->Values = LocalOptValues;

    pArray = OptList;
    Error = MemArrayInitLoc(pArray, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error);

    for( Count = 0; Count < *ResumeHandle ; Count ++ ) {
        Error = MemArrayNextLoc(pArray, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    Index = 0; Error = ERROR_SUCCESS; FilledSize =0;
    while( Count < nElements ) {
        Count ++;

        Error = MemArrayGetElement(pArray, &Loc, &Opt);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != Opt);
        Error = MemArrayNextLoc(pArray, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error || Count == nElements);

        Error = ERROR_SUCCESS;
        if( !CheckForVendor(Opt->OptId, IsVendor) ) continue;

        Error = DhcpConvertOptionRegToRPCFormat(
            Opt->Val,
            Opt->Len,
            &LocalOptValues[Index].Value,
            &UsedSize
        );
        if( ERROR_SUCCESS != Error ) {
            LocalOptValueArray->NumElements = Index;
            _fgs__DHCP_OPTION_VALUE_ARRAY( LocalOptValueArray );
            MIDL_user_free(LocalOptValueArray);
            return Error;
        }

        if( FilledSize + UsedSize + sizeof(DHCP_OPTION_VALUE) > PreferredMaximum ) {
            _fgs__DHCP_OPTION_DATA( &LocalOptValues[Index].Value );
            Error = ERROR_MORE_DATA;
            break;
        } else {
            LocalOptValues[Index].OptionID = ConvertOptIdToRPCValue(Opt->OptId, TRUE);
            FilledSize += UsedSize + sizeof(DHCP_OPTION_VALUE);
            Index ++;
        }
    }

    if( 0 == Index ) {
        MIDL_user_free(LocalOptValues);
        MIDL_user_free(LocalOptValueArray);
        if( ERROR_SUCCESS == Error ) return ERROR_NO_MORE_ITEMS;
        else return Error;
    }

    LocalOptValueArray->NumElements = Index;
    *nRead = Index ;
    *nTotal = nElements - Count + Index;
    *ResumeHandle = Count;
    *OptionValues = LocalOptValueArray;
    return Error;
}

DWORD
DhcpEnumOptionValues(
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      BOOL                   IsVendor,
    IN OUT  DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Error;
    DWORD                          ClassId;
    DWORD                          VendorId;
    DWORD                          Index;
    DWORD                          Count;
    DWORD                          nElements;
    DWORD                          FilledSize;
    DWORD                          UsedSize;
    PM_SERVER                      Server;
    PM_OPTLIST                     OptList;
    PM_OPTION                      Opt;
    PM_OPTDEF                      OptDef;
    PM_OPTDEFLIST                  OptDefList;
    PARRAY                         pArray;
    ARRAY_LOCATION                 Loc;
    LPDHCP_OPTION_VALUE_ARRAY      LocalOptValueArray;
    LPDHCP_OPTION_VALUE            LocalOptValues;

    Server = DhcpGetCurrentServer();

    Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpGetVendorIdFromName(VendorName, &VendorId);
    if( ERROR_SUCCESS != Error ) return Error;

    *nRead = *nTotal = 0;
    *OptionValues = NULL;

    if( DhcpDefaultOptions == ScopeInfo->ScopeType ) {
        Error = MemOptClassDefListFindOptDefList(
            &(Server->OptDefs),
            ClassId,
            VendorId,
            &OptDefList
        );
        if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_NO_MORE_ITEMS;
        if( ERROR_SUCCESS != Error) return Error;
        DhcpAssert(OptDefList);
        nElements = MemArraySize(&OptDefList->OptDefArray);
        if( 0 == nElements || *ResumeHandle <= nElements)
            return ERROR_NO_MORE_ITEMS;

        LocalOptValueArray = MIDL_user_allocate(sizeof(DHCP_OPTION_VALUE_ARRAY));
        if( NULL == LocalOptValueArray ) return ERROR_NOT_ENOUGH_MEMORY;
        LocalOptValues = MIDL_user_allocate(sizeof(DHCP_OPTION_VALUE_ARRAY)*nElements - *ResumeHandle);
        if( NULL == LocalOptValues ) {
            MIDL_user_free(LocalOptValueArray);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        LocalOptValueArray->NumElements = 0;
        LocalOptValueArray->Values = LocalOptValues;

        pArray = &(OptDefList->OptDefArray);
        Error = MemArrayInitLoc(pArray, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error);

        for( Count = 0; Count < *ResumeHandle; Count ++ ) {
            Error = MemArrayNextLoc(pArray, &Loc);
            DhcpAssert(ERROR_SUCCESS == Error);
        }

        Error = ERROR_SUCCESS; Index = 0; FilledSize = 0;
        while( Count < nElements ) {
            Count ++;

            Error = MemArrayGetElement(pArray, &Loc, &OptDef);
            DhcpAssert(ERROR_SUCCESS == Error && NULL != OptDef);
            Error = MemArrayNextLoc(pArray, &Loc);
            DhcpAssert(ERROR_SUCCESS == Error || Count == nElements);
            Error = ERROR_SUCCESS;

            if( !CheckForVendor(OptDef->OptId, IsVendor) ) continue;

            Error = DhcpConvertOptionRegToRPCFormat(
                OptDef->OptVal,
                OptDef->OptValLen,
                &LocalOptValues[Index].Value,
                &UsedSize
            );
            if( ERROR_SUCCESS != Error ) {
                LocalOptValueArray->NumElements = Index;
                _fgs__DHCP_OPTION_VALUE_ARRAY( LocalOptValueArray );
                MIDL_user_free( LocalOptValueArray );
                return Error;
            }

            if( FilledSize + UsedSize + sizeof(DHCP_OPTION_VALUE) > PreferredMaximum ) {
                _fgs__DHCP_OPTION_DATA( &LocalOptValues[Index].Value );
                Error = ERROR_MORE_DATA;
                break;
            } else {
                LocalOptValues[Index].OptionID = ConvertOptIdToRPCValue(OptDef->OptId, TRUE);
                FilledSize += UsedSize + sizeof(DHCP_OPTION_VALUE);
                Index ++;
            }
        }
        LocalOptValueArray->NumElements = Index;
        *nRead = Index ;
        *nTotal = nElements - Count + Index;
        *ResumeHandle = Count;
        return Error;
    }

    return DhcpEnumOptionValuesInternal(
        ScopeInfo,
        ClassId,
        VendorId,
        IsVendor,
        ResumeHandle,
        PreferredMaximum,
        OptionValues,
        nRead,
        nTotal
    );
}

DWORD
DhcpRemoveOptionValue(
    IN      DWORD                  OptId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
)
{
    DWORD                          Error;
    DWORD                          RegError;
    DWORD                          ClassId;
    DWORD                          VendorId;
    PM_SERVER                      Server;
    PM_SUBNET                      Subnet;
    PM_RESERVATION                 Reservation;
    PM_OPTCLASS                    OptClass;
    PM_OPTLIST                     OptList;
    PM_OPTION                      Opt;
    PM_OPTDEF                      OptDef;
    PM_OPTDEFLIST                  OptDefList;

    Server = DhcpGetCurrentServer();

    Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpGetVendorIdFromName(VendorName, &VendorId);
    if( ERROR_SUCCESS != Error ) return Error;

    if( DhcpDefaultOptions == ScopeInfo->ScopeType )
        return ERROR_INVALID_PARAMETER;           // use DhcpRemoveOption in this case??

    switch(ScopeInfo->ScopeType) {
    case DhcpGlobalOptions:
        OptClass = &Server->Options; Error = ERROR_SUCCESS;
        break;
    case DhcpSubnetOptions:
        Error = MemServerGetAddressInfo(
            Server,
            ScopeInfo->ScopeInfo.SubnetScopeInfo,
            &Subnet,
            NULL,
            NULL,
            NULL
        );
        if( ERROR_FILE_NOT_FOUND == Error ) {
            Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
        } else if( ERROR_SUCCESS == Error ) {
            DhcpAssert(Subnet);
            OptClass = &Subnet->Options;
        }
        break;
    case DhcpMScopeOptions:
        Error = DhcpServerFindMScope(
            DhcpGetCurrentServer(),
            INVALID_MSCOPE_ID,
            ScopeInfo->ScopeInfo.MScopeInfo,
            &Subnet
            );

        if( ERROR_FILE_NOT_FOUND == Error ) {
            Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
        } else if( ERROR_SUCCESS == Error ) {
            DhcpAssert(Subnet);
            OptClass = &Subnet->Options;
        }
        break;
    case DhcpReservedOptions:
        Error = MemServerGetAddressInfo(
            Server,
            ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpAddress,
            &Subnet,
            NULL,
            NULL,
            &Reservation
        );
        if( ERROR_FILE_NOT_FOUND == Error || NULL == Reservation) {
            Error = ERROR_DHCP_NOT_RESERVED_CLIENT;
        } else {
            DhcpAssert(NULL != Subnet);
            if( Subnet->Address != ScopeInfo->ScopeInfo.ReservedScopeInfo.ReservedIpSubnetAddress ) {
                Error = ERROR_DHCP_SUBNET_NOT_PRESENT;
            } else {
                OptClass = &Reservation->Options;
            }
        }
        break;
    default:
        Error = ERROR_INVALID_PARAMETER;
    }

    if( ERROR_SUCCESS != Error ) return Error;

    Error = MemOptClassFindClassOptions(
        OptClass,
        ClassId,
        VendorId,
        &OptList
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_CLASS_NOT_FOUND;
    if( ERROR_SUCCESS != Error ) return Error;

    DhcpAssert(OptList);
    Error = MemOptListDelOption(
        OptList,
        OptId
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_OPTION_NOT_PRESENT;

    return Error;
}


//================================================================================
//  classid only stuff implemented here
//================================================================================
DWORD
DhcpCreateClass(
    IN      LPWSTR                 ClassName,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassComment,
    IN      LPBYTE                 ClassData,
    IN      DWORD                  ClassDataLength
)
{
    DWORD                          Error;
    DWORD                          ClassId;
    BOOL                           IsVendor;
    PM_CLASSDEF                    ClassDef = NULL;

    if( NULL == ClassName || NULL == ClassData || 0 == ClassDataLength )
        return ERROR_INVALID_PARAMETER;

    if( 0 != Flags && DHCP_FLAGS_OPTION_IS_VENDOR != Flags ) {
        return ERROR_INVALID_PARAMETER;
    }

    IsVendor = (0 != ( Flags & DHCP_FLAGS_OPTION_IS_VENDOR ));

    if( !IsVendor ) {
        Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    } else {
        Error = DhcpGetVendorIdFromName(ClassName, &ClassId);
    }
    
    if( ERROR_DHCP_CLASS_NOT_FOUND != Error ) {
        if( ERROR_SUCCESS != Error ) return Error;
        return ERROR_DHCP_CLASS_ALREADY_EXISTS;
    }
    
    Error = MemServerGetClassDef(
        DhcpGetCurrentServer(),
        0,
        NULL,
        ClassDataLength,
        ClassData,
        &ClassDef
        );
    if( ERROR_SUCCESS == Error ) {
        return ERROR_DHCP_CLASS_ALREADY_EXISTS;
    }
        
    ClassId = MemNewClassId();

    Error = MemServerAddClassDef(
        DhcpGetCurrentServer(),
        ClassId,
        IsVendor,
        ClassName,
        ClassComment,
        ClassDataLength,
        ClassData
    );

    return Error;
}

// Delete the global option definitison for the given vendorid..
DWORD       _inline
DhcpDeleteGlobalClassOptDefs(
    IN      LPWSTR                 ClassName,
    IN      ULONG                  ClassId,
    IN      BOOL                   IsVendor
)
{
    DWORD                          Error;
    PARRAY                         Opts;
    ARRAY_LOCATION                 Loc;
    PM_OPTCLASSDEFL_ONE            OptDefList1;
    PM_OPTDEFLIST                  OptDefList;
    PM_OPTDEF                      OptDef;
    PM_OPTION                      Option;
    PM_SERVER                      Server;

    Server = DhcpGetCurrentServer();

    //
    // First clear all relevant option definitions
    //

    for( Error = MemArrayInitLoc( &Server->OptDefs.Array, &Loc)
         ; ERROR_SUCCESS == Error ;
         Error = MemArrayNextLoc( &Server->OptDefs.Array, &Loc)
    ) {
        Error = MemArrayGetElement(&Server->OptDefs.Array, &Loc, &OptDefList1);
        DhcpAssert(ERROR_SUCCESS == Error);

        if( OptDefList1->VendorId != ClassId ) continue;

        // if( OptDefList1->IsVendor != IsVendor ) continue;
        // For now, we ignore IsVendor and assume it is always TRUE
        // meaning the option is defined to be deleted for that vendor CLASS.

        // DhcpAssert( TRUE == OptDefList1->IsVendor );

        // remove this optdeflist OFF of the main list..
        MemArrayDelElement(&Server->OptDefs.Array, &Loc, &OptDefList1);

        break;
    }

    if( ERROR_FILE_NOT_FOUND == Error ) {
        return ERROR_SUCCESS;
    }

    if( ERROR_SUCCESS != Error ) return Error;

    // we found the OptDefList1 we were looking for. Delete each optdef in it.
    // But simultaneously delete the registry optdefs for these options too.
    //

    for( Error = MemArrayInitLoc( &OptDefList1->OptDefList.OptDefArray, &Loc)
         ; ERROR_SUCCESS == Error ;
         Error = MemArrayNextLoc( &OptDefList1->OptDefList.OptDefArray, &Loc)
    ) {
        Error = MemArrayGetElement(&OptDefList1->OptDefList.OptDefArray, &Loc, &OptDef);
        DhcpAssert(ERROR_SUCCESS == Error);

        // clean the registry off the option OptDef...

        // Again, we are assuming that this is a VENDOR CLASS and so we're
        // deleting all relevant stuff.  If it is not a VENDOR CLASS then we'd
        // not have reached this loop at all? (as USER CLASSes cannot have options
        // definitions for them)

        // -- We should not be free'ing memory so casually.. this memory actually
        // should be free'd via a Mem API.  But good lord, please forgive this lapse.

        MemFree(OptDef);
    }

    // Free the list itself...
    Error = MemOptDefListCleanup(&OptDefList1->OptDefList);

    // Get rid of the OptDefList1 also... -- shouldn't free this badly..
    MemFree(OptDefList1);

    return Error;
}


DWORD       _inline
DhcpDeleteOptListOptionValues(
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      PM_OPTLIST             OptList,
    IN      PM_RESERVATION         Reservation,
    IN      PM_SUBNET              Subnet,
    IN      PM_SERVER              Server
)
{
    DWORD                          Error;
    ARRAY_LOCATION                 Loc;
    PM_OPTION                      Option;

    for( Error = MemArrayInitLoc( OptList, &Loc)
         ; ERROR_SUCCESS == Error ;
         Error = MemArrayNextLoc( OptList, &Loc)
    ) {
        Error = MemArrayGetElement( OptList, &Loc, &Option);
        DhcpAssert(ERROR_SUCCESS == Error);

        //
        // now cleanup the option
        //

        MemOptCleanup(Option);
    }

    // Now cleanup the option list..

    return MemOptListCleanup(OptList);
}

DWORD
DhcpDeleteOptClassOptionValues(
    IN      LPWSTR                 ClassNameIn,
    IN      ULONG                  ClassId,
    IN      BOOL                   IsVendor,
    IN      PM_OPTCLASS            OptClass,
    IN      PM_RESERVATION         Reservation,
    IN      PM_SUBNET              Subnet,
    IN      PM_SERVER              Server
)
{
    DWORD                          Error;
    ULONG                          IdToCheck;
    LPWSTR                         VendorName, ClassName;
    ARRAY_LOCATION                 Loc, Loc2;
    PM_ONECLASS_OPTLIST            OptOneList;
    PM_CLASSDEF                    ClassDef;
    PM_OPTION                      Option;

    //
    // Get Optlist for options defined for (ClassId/IsVendor)..
    //

    for( Error = MemArrayInitLoc( &OptClass->Array, &Loc)
         ; ERROR_SUCCESS == Error ;
    ) {
        Error = MemArrayGetElement(&OptClass->Array, &Loc, &OptOneList );
        DhcpAssert(ERROR_SUCCESS == Error);

        if( ClassId != (IsVendor? OptOneList->VendorId : OptOneList->ClassId ) ) {
            //
            // not what we are looking for
            //

            Error = MemArrayNextLoc( &OptClass->Array, &Loc);

        } else {

            //
            // matched -- got to remove all of the options defined..
            //

            if( IsVendor ) {
                VendorName = ClassNameIn;
                ClassName = NULL;
                IdToCheck = OptOneList->ClassId;
            } else {
                VendorName = NULL;
                ClassName = ClassNameIn;
                IdToCheck = OptOneList->VendorId;
            }

            if( 0 != IdToCheck ) {
                Error = MemServerGetClassDef(
                    Server,
                    IdToCheck,
                    NULL,
                    0,
                    NULL,
                    &ClassDef
                );
                DhcpAssert(ERROR_SUCCESS == Error);
                if( ERROR_SUCCESS == Error) {
                    if( IsVendor ) ClassName = ClassDef->Name;
                    else VendorName = ClassDef->Name;
                }
            }

            //
            // Now clear off the options(& OptList) from mem & registry
            //

            Error = DhcpDeleteOptListOptionValues(
                ClassName,
                VendorName,
                &OptOneList->OptList,
                Reservation,
                Subnet,
                Server
            );
            DhcpAssert(ERROR_SUCCESS == Error);

            //
            // Now clear off the OptOneList from off of OptClass also..
            //

            MemFree(OptOneList);

            MemArrayDelElement(&OptClass->Array, &Loc, &OptOneList);
            Error = MemArrayAdjustLocation(&OptClass->Array, &Loc);
        }
    }

    if( ERROR_FILE_NOT_FOUND != Error ) return Error;
    return ERROR_SUCCESS;
}

// Delete all the global options defined for the given vendor/classid
DWORD       _inline
DhcpDeleteGlobalClassOptValues(
    IN      LPWSTR                 ClassName,
    IN      ULONG                  ClassId,
    IN      BOOL                   IsVendor
)
{
    DWORD                          Error;
    PM_SERVER                      Server;

    Server = DhcpGetCurrentServer();

    return DhcpDeleteOptClassOptionValues(
        ClassName,
        ClassId,
        IsVendor,
        &Server->Options,
        NULL,  /* reservation */
        NULL,  /* subnet */
        Server /* server */
    );
}

// This function deletes all optiosn and optiondefs defined for a particular class
DWORD       _inline
DhcpDeleteGlobalClassOptions(
    IN      LPWSTR                 ClassName,
    IN      ULONG                  ClassId,
    IN      BOOL                   IsVendor
)
{
    DWORD                          Error;

    if( IsVendor ) {
        Error = DhcpDeleteGlobalClassOptDefs(ClassName, ClassId, IsVendor);
        if( ERROR_SUCCESS != Error ) return Error;
    }

    return DhcpDeleteGlobalClassOptValues(ClassName, ClassId, IsVendor);
}

DWORD
DhcpDeleteSubnetOptClassOptionValues(
    IN      LPWSTR                 ClassName,
    IN      ULONG                  ClassId,
    IN      BOOL                   IsVendor,
    IN      PM_SUBNET              Subnet,
    IN      PM_SERVER              Server
)
{
    ULONG                          Error;
    ARRAY_LOCATION                 Loc;
    PM_RESERVATION                 Reservation;

    Error = DhcpDeleteOptClassOptionValues(
        ClassName,
        ClassId,
        IsVendor,
        &Subnet->Options,
        NULL,
        Subnet,
        Server
    );
    DhcpAssert(ERROR_SUCCESS == Error);


    for( Error = MemArrayInitLoc(&Subnet->Reservations, &Loc)
         ; ERROR_SUCCESS == Error ;
         Error = MemArrayNextLoc(&Subnet->Reservations, &Loc)
    ) {
        Error = MemArrayGetElement(&Subnet->Reservations, &Loc, &Reservation);
        DhcpAssert(ERROR_SUCCESS == Error);

        Error = DhcpDeleteOptClassOptionValues(
            ClassName,
            ClassId,
            IsVendor,
            &Reservation->Options,
            Reservation,
            Subnet,
            Server
        );
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    return ERROR_SUCCESS;
}

DWORD       _inline
DhcpDeleteSubnetReservationOptions(
    IN      LPWSTR                 ClassName,
    IN      ULONG                  ClassId,
    IN      BOOL                   IsVendor
)
{
    DWORD                          Error;
    ARRAY_LOCATION                 Loc;
    PM_SERVER                      Server;
    PM_SUBNET                      Subnet;

    Server = DhcpGetCurrentServer();

    for( Error = MemArrayInitLoc(&Server->Subnets, &Loc)
         ; ERROR_SUCCESS == Error ;
         Error = MemArrayNextLoc(&Server->Subnets, &Loc)
    ) {
        Error = MemArrayGetElement(&Server->Subnets, &Loc, &Subnet);
        DhcpAssert(ERROR_SUCCESS == Error );

        Error = DhcpDeleteSubnetOptClassOptionValues(
            ClassName,
            ClassId,
            IsVendor,
            Subnet,
            Server
        );
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    for( Error = MemArrayInitLoc(&Server->MScopes, &Loc)
         ; ERROR_SUCCESS == Error ;
         Error = MemArrayNextLoc(&Server->MScopes, &Loc)
    ) {
        Error = MemArrayGetElement(&Server->MScopes, &Loc, &Subnet);
        DhcpAssert(ERROR_SUCCESS == Error );

        Error = DhcpDeleteSubnetOptClassOptionValues(
            ClassName,
            ClassId,
            IsVendor,
            Subnet,
            Server
        );
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    if( ERROR_FILE_NOT_FOUND != Error ) return Error;
    return ERROR_SUCCESS;
}


DWORD
DhcpDeleteClass(
    IN      LPWSTR                 ClassName
)
{
    DWORD                          Error;
    PM_CLASSDEF                    ClassDef;
    ULONG                          ClassId;
    BOOL                           IsVendor;

    Error = MemServerGetClassDef(
        DhcpGetCurrentServer(),
        0,
        ClassName,
        0,
        NULL,
        &ClassDef
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_CLASS_NOT_FOUND;

    //
    // found the class, remember class id to delete options..
    //

    IsVendor = ClassDef->IsVendor;
    ClassId = ClassDef->ClassId;

    Error = MemServerDelClassDef(
        DhcpGetCurrentServer(),
        0,
        ClassName,
        0,
        NULL
    );

    if( ERROR_SUCCESS != Error ) {
        return Error;
    }


    //
    // Now delete the options & optdefs defined for this class globally
    //

    Error = DhcpDeleteGlobalClassOptions(
        ClassName,
        ClassId,
        IsVendor
    );

    if( ERROR_SUCCESS != Error ) {
        return Error;
    }

    //
    // Now delete the options defined for this class for every subnet & reservation
    //

    Error = DhcpDeleteSubnetReservationOptions(
        ClassName,
        ClassId,
        IsVendor
    );

    return Error;
}

DWORD
DhcpModifyClass(
    IN      LPWSTR                 ClassName,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassComment,
    IN      LPBYTE                 ClassData,
    IN      DWORD                  ClassDataLength
)
{
    DWORD                          Error;
    DWORD                          ClassId;
    BOOL                           IsVendor;
    PM_CLASSDEF                    ClassDef = NULL;
    
    if( 0 != Flags && DHCP_FLAGS_OPTION_IS_VENDOR != Flags ) {
        return ERROR_INVALID_PARAMETER;
    }

    IsVendor = (0 != ( Flags & DHCP_FLAGS_OPTION_IS_VENDOR ));

    if( FALSE == IsVendor ) {
        Error = DhcpGetClassIdFromName(ClassName, &ClassId);
    } else {
        Error = DhcpGetVendorIdFromName(ClassName, &ClassId);
    }
    if( ERROR_SUCCESS != Error ) {
        return Error;
    }

    Error = MemServerGetClassDef(
        DhcpGetCurrentServer(),
        0,
        NULL,
        ClassDataLength,
        ClassData,
        &ClassDef
        );
    if( ERROR_SUCCESS == Error ) {
        if( ClassDef->ClassId != ClassId ) {
            return ERROR_DHCP_CLASS_ALREADY_EXISTS;
        }
    }
    
    Error = MemServerAddClassDef(
        DhcpGetCurrentServer(),
        ClassId,
        IsVendor,
        ClassName,
        ClassComment,
        ClassDataLength,
        ClassData
    );

    return Error;
}

DWORD
ConvertClassDefToRPCFormat(
    IN      PM_CLASSDEF            ClassDef,
    IN OUT  LPDHCP_CLASS_INFO      ClassInfo,
    OUT     DWORD                 *AllocatedSize
)
{
    DWORD                          Error;

    ClassInfo->ClassName = CloneLPWSTR(ClassDef->Name);
    ClassInfo->ClassComment = CloneLPWSTR(ClassDef->Comment);
    ClassInfo->ClassData = CloneLPBYTE(ClassDef->ActualBytes, ClassDef->nBytes);
    ClassInfo->ClassDataLength = ClassDef->nBytes;
    ClassInfo->Flags = 0;
    ClassInfo->IsVendor = ClassDef->IsVendor;

    if( NULL == ClassInfo->ClassName || NULL == ClassInfo->ClassData ) {
        if( ClassInfo->ClassName ) MIDL_user_free(ClassInfo->ClassName);
        if( ClassInfo->ClassComment ) MIDL_user_free(ClassInfo->ClassComment);
        if( ClassInfo->ClassData ) MIDL_user_free(ClassInfo->ClassData);

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if(AllocatedSize ) *AllocatedSize = (
        sizeof(WCHAR)*(1 + wcslen(ClassDef->Name)) +
        ((NULL == ClassDef->Comment)?0:(sizeof(WCHAR)*(1 + wcslen(ClassDef->Comment)))) +
        ClassDef->nBytes
    );

    return ERROR_SUCCESS;
}

DWORD
DhcpGetClassInfo(
    IN      LPWSTR                 ClassName,
    IN      LPBYTE                 ClassData,
    IN      DWORD                  ClassDataLength,
    OUT     LPDHCP_CLASS_INFO     *ClassInfo
)
{
    DWORD                          Error;
    LPDHCP_CLASS_INFO              LocalClassInfo;
    PM_CLASSDEF                    ClassDef;

    *ClassInfo = 0;
    Error = MemServerGetClassDef(
        DhcpGetCurrentServer(),
        0,
        ClassName,
        ClassDataLength,
        ClassData,
        &ClassDef
    );
    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_DHCP_CLASS_NOT_FOUND;
    if( ERROR_SUCCESS != Error ) return Error;

    DhcpAssert(ClassDef);

    LocalClassInfo = MIDL_user_allocate(sizeof(DHCP_CLASS_INFO));
    if( NULL == LocalClassInfo ) return ERROR_NOT_ENOUGH_MEMORY;

    Error = ConvertClassDefToRPCFormat(ClassDef, LocalClassInfo, NULL);
    if( ERROR_SUCCESS != Error ) {
        MIDL_user_free(LocalClassInfo);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    *ClassInfo = LocalClassInfo;
    return ERROR_SUCCESS;
}

DhcpEnumClasses(
    IN      DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_CLASS_INFO_ARRAY *ClassInfoArray,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
)
{
    DWORD                          Error;
    LONG                           Index;
    DWORD                          nElements;
    DWORD                          Count;
    DWORD                          FilledSize;
    DWORD                          UsedSize;
    LPDHCP_CLASS_INFO              LocalClassInfo;
    LPDHCP_CLASS_INFO_ARRAY        LocalClassInfoArray;
    PM_CLASSDEF                    ClassDef;
    PARRAY                         pArray;
    ARRAY_LOCATION                 Loc;

    pArray = &(DhcpGetCurrentServer()->ClassDefs.ClassDefArray);
    nElements = MemArraySize(pArray);

    *nRead = *nTotal = 0;
    *ClassInfoArray = NULL;

    if( 0 == nElements || nElements <= *ResumeHandle )
        return ERROR_NO_MORE_ITEMS;

    Error = MemArrayInitLoc(pArray, &Loc);
    DhcpAssert(ERROR_SUCCESS == Error);
    for(Count = 0; Count < *ResumeHandle ; Count ++ ) {
        Error = MemArrayNextLoc(pArray, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    LocalClassInfoArray = MIDL_user_allocate(sizeof(DHCP_CLASS_INFO_ARRAY));
    if( NULL == LocalClassInfoArray ) return ERROR_NOT_ENOUGH_MEMORY;
    LocalClassInfo = MIDL_user_allocate(sizeof(DHCP_CLASS_INFO)*(nElements - *ResumeHandle ));
    if( NULL == LocalClassInfo ) {
        MIDL_user_free(LocalClassInfoArray);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Index = 0; Error = ERROR_SUCCESS; FilledSize = 0;
    while( Count < nElements ) {
        Count ++;

        Error = MemArrayGetElement(pArray, &Loc, &ClassDef);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != ClassDef);
        Error = MemArrayNextLoc(pArray, &Loc);
        DhcpAssert(ERROR_SUCCESS == Error || nElements == Count);

        Error = ConvertClassDefToRPCFormat(
            ClassDef,
            &LocalClassInfo[Index],
            &UsedSize
        );
        if( ERROR_SUCCESS != Error ) {
            while(Index -- >= 1) {
                if(LocalClassInfo[Index].ClassName ) MIDL_user_free(LocalClassInfo[Index].ClassName);
                if(LocalClassInfo[Index].ClassComment ) MIDL_user_free(LocalClassInfo[Index].ClassComment);
                if(LocalClassInfo[Index].ClassData ) MIDL_user_free(LocalClassInfo[Index].ClassData);
            }
            MIDL_user_free(LocalClassInfo);
            MIDL_user_free(LocalClassInfoArray);
            return Error;
        }

        if( FilledSize + UsedSize + sizeof(DHCP_CLASS_INFO) > PreferredMaximum ) {
            if(LocalClassInfo[Index].ClassName ) MIDL_user_free(LocalClassInfo[Index].ClassName);
            if(LocalClassInfo[Index].ClassComment ) MIDL_user_free(LocalClassInfo[Index].ClassComment);
            if(LocalClassInfo[Index].ClassData ) MIDL_user_free(LocalClassInfo[Index].ClassData);
            Error = ERROR_MORE_DATA;
            break;
        }
        Index ++;
        FilledSize += UsedSize + sizeof(DHCP_CLASS_INFO);
        Error = ERROR_SUCCESS;
    }

    *nRead = Index;
    *nTotal = nElements - Count + Index;
    *ResumeHandle = Count;
    LocalClassInfoArray->NumElements = Index;
    LocalClassInfoArray->Classes = LocalClassInfo;

    *ClassInfoArray = LocalClassInfoArray;
    return Error;
}

//================================================================================
//  extended enum api's and helpers needed for that..
//================================================================================

typedef
VOID        (*OPTDEFFUNC) (PM_OPTDEF, DWORD, DWORD, LPVOID, LPVOID, LPVOID, LPVOID);

VOID
TraverseOptDefListAndDoFunc(                      // apply function each optdef in otpdeflist
    IN      PM_OPTDEFLIST          OptDefList,    // input list
    IN      DWORD                  ClassId,       // class id
    IN      DWORD                  VendorId,      // vendor id
    IN      OPTDEFFUNC             OptDefFunc,    // function to apply
    IN OUT  LPVOID                 Ctxt1,         // some parameter to OptDefFunc
    IN OUT  LPVOID                 Ctxt2,         // some parameter to OptDefFunc
    IN OUT  LPVOID                 Ctxt3,         // some parameter to OptDefFunc
    IN OUT  LPVOID                 Ctxt4          // some parameter to OptDefFunc
)
{
    DWORD                          Error;
    ARRAY                          Array;
    ARRAY_LOCATION                 Loc;
    PM_OPTDEF                      OptDef;

    for( Error = MemArrayInitLoc(&OptDefList->OptDefArray, &Loc)
         ; ERROR_FILE_NOT_FOUND != Error ;
         Error = MemArrayNextLoc(&OptDefList->OptDefArray, &Loc)
    ) {                                           // traverse the optdef list
        DhcpAssert(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&OptDefList->OptDefArray, &Loc, &OptDef);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != OptDef );

        OptDefFunc(OptDef, ClassId, VendorId, Ctxt1, Ctxt2, Ctxt3, Ctxt4);
    }
}

VOID
TraverseAllOptDefsAndDoFunc(                      // for all opt defs defined in this server call func
    IN      OPTDEFFUNC             OptDefFunc,    // function to apply
    IN OUT  LPVOID                 Ctxt1,         // some parameter to OptDefFunc
    IN OUT  LPVOID                 Ctxt2,         // some parameter to OptDefFunc
    IN OUT  LPVOID                 Ctxt3,         // some parameter to OptDefFunc
    IN OUT  LPVOID                 Ctxt4          // some parameter to OptDefFunc
)
{
    DWORD                          Error;
    PM_OPTCLASSDEFLIST             OptClassDefList;
    PM_OPTCLASSDEFL_ONE            OptClassDefList1;
    ARRAY                          Array;
    ARRAY_LOCATION                 Loc;

    OptClassDefList = &(DhcpGetCurrentServer()->OptDefs);
    for( Error = MemArrayInitLoc(&OptClassDefList->Array, &Loc)
         ; ERROR_FILE_NOT_FOUND != Error ;
         Error = MemArrayNextLoc(&OptClassDefList->Array, &Loc)
    ) {                                           // traverse the list of <list of opt defs>
        DhcpAssert(ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(&OptClassDefList->Array, &Loc, &OptClassDefList1);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != OptClassDefList1);

        TraverseOptDefListAndDoFunc(
            &OptClassDefList1->OptDefList,
            OptClassDefList1->ClassId,
            OptClassDefList1->VendorId,
            OptDefFunc,
            Ctxt1,
            Ctxt2,
            Ctxt3,
            Ctxt4
        );
    }
}

VOID
CountVendorOptDefsFunc(                           // function that just keeps count of venodr optdefs..
    IN      PM_OPTDEF              OptDef,
    IN      DWORD                  ClassIdunused,
    IN      DWORD                  VendorIdunused,
    IN OUT  LPVOID                 Ctxt1,         // this is actually a pointer to DWORD to keep count..
    IN OUT  LPVOID                 Ctxt2unused,
    IN OUT  LPVOID                 Ctxt3unused,
    IN OUT  LPVOID                 Ctxt4unused
)
{
    if( CheckForVendor(OptDef->OptId, TRUE ) ) {  // if this is a vendor option..
        (*((LPDWORD)Ctxt1))++;                    // treat Ctxt as a DWORD ptr and incr. count
    }
}

VOID
AddVendorOptDefsFunc(                             // add each vendor opt def found to arrays..
    IN      PM_OPTDEF              OptDef,        // this is the opt def in question
    IN      DWORD                  ClassId,       // class id if any
    IN      DWORD                  VendorId,      // vendor id if any..
    IN OUT  LPDWORD                MaxSize,       // this is the max size of the arrays..
    IN OUT  LPDWORD                nFilled,       // this is the # we actually filled in..
    IN      LPDHCP_ALL_OPTIONS     AllOptions,    // the struct to fill in venodr options..
    IN      LPVOID                 Unused         // not used
)
{
    DWORD                          Error;
    PM_CLASSDEF                    ClassDef;
    LPWSTR                         Tmp = NULL;

    if( 0 == *MaxSize ) {                         // some error occurred before and this was set to zero
        return;                                   // to signify no more processing should be done..
    }

    if( !CheckForVendor(OptDef->OptId, TRUE) ) {  // not a vendor specific option, ignore this
        return;
    }

    if( *nFilled >= *MaxSize ) {                  // internal error!
        DhcpAssert(FALSE);
        return;
    }

    if( 0 != VendorId ) {                         // try to get the vendor name, if any
        Error = MemServerGetClassDef(
            DhcpGetCurrentServer(),
            VendorId,
            NULL,
            0,
            NULL,
            &ClassDef
        );
        if( ERROR_SUCCESS != Error ) {            // internal error?!!
            *MaxSize = 0;                         // set this to zero, so we dont do anything anymore
            return;
        }

        if( FALSE == ClassDef->IsVendor ) {       // what we thought of as vendor-id is not actuall that?
            DhcpAssert(FALSE);
        }

        Tmp = CloneLPWSTR(ClassDef->Name);
        AllOptions->VendorOptions[*nFilled].VendorName = Tmp;
        if( NULL == Tmp ) {                       // could not clone the name for some reason?
            *MaxSize = 0;                         // set this, so that we dont do anything in next calls..
            return;
        }
    }

    Error = DhcpGetOptionDefInternal(
        ClassId,
        VendorId,
        OptDef,
        &AllOptions->VendorOptions[*nFilled].Option,
        NULL
    );
    if( ERROR_SUCCESS != Error ) {                // could not fix the options stuff...
        *MaxSize = 0;                             // dont bother doing any more of this...
        if( Tmp ) {
            MIDL_user_free(Tmp);
        }
    }

    (*nFilled) ++;                                // since we successfully got one more option, mark it..
}
DWORD
DhcpCountAllVendorOptions(                        // count the # of vendor options defined..
    VOID
)
{
    DWORD                          Count;

    Count = 0;
    TraverseAllOptDefsAndDoFunc(                  // execute fn for each optdef found..
        (OPTDEFFUNC)CountVendorOptDefsFunc,       // counting function
        (LPVOID)&Count,                           // just increment this ctxt value for each vendor opt
        NULL,
        NULL,
        NULL
    );

    return Count;                                 // at the end of this Count would have been set correcly..
}

DWORD
DhcpFillAllVendorOptions(                         // now fill in all the required vendor options..
    IN      DWORD                  NumElements,   // # we expect for total # of elements,
    IN OUT  LPDWORD                nFilled,       // # of elements filled in? initially zero
    IN      LPDHCP_ALL_OPTIONS     AllOptions     // structure to fill in (fills AllOptions->VendorOptions[i])
)
{
    DWORD                          AttemptedNum;

    AttemptedNum = NumElements;                   // we should expect to fill in these many

    TraverseAllOptDefsAndDoFunc(                  // execute fn for each optdef found
        (OPTDEFFUNC)AddVendorOptDefsFunc,         // add each vendor opt def found in the way..
        (LPVOID)&NumElements,                     // first ctxt parameter
        (LPVOID)nFilled,                          // second ctxt parameter
        (LPVOID)AllOptions,                       // third parameter
        (LPVOID)NULL                              // fourth..
    );

    if( *nFilled < AttemptedNum ) {               // could not fill in the requested #...
        return ERROR_NOT_ENOUGH_MEMORY;           // duh! need to be more intelligent... what is exact error?
    }
    return ERROR_SUCCESS;
}

DWORD
DhcpGetAllVendorOptions(                          // get all vendor spec stuff only
    IN      DWORD                  Flags,         // unused..
    IN OUT  LPDHCP_ALL_OPTIONS     OptionStruct   // filled in the NamedVendorOptions field..
)
{
    DWORD                          Error;
    DWORD                          nVendorOptions;
    DWORD                          MemReqd;
    LPVOID                         Mem, Mem2;

    nVendorOptions = DhcpCountAllVendorOptions(); // first count this so that we can allocate space..
    if( 0 == nVendorOptions ) {                   // if no vendor options, nothing more to do..
        return ERROR_SUCCESS;
    }

    MemReqd = sizeof(*(OptionStruct->VendorOptions))*nVendorOptions;
    Mem = MIDL_user_allocate(MemReqd);
    if( NULL == Mem ) return ERROR_NOT_ENOUGH_MEMORY;
    memset(Mem, 0, MemReqd);

    OptionStruct->VendorOptions = Mem;

    Error = DhcpFillAllVendorOptions(             // now fill in the vendor options..
        nVendorOptions,                           // expected size is this..
        &OptionStruct->NumVendorOptions,
        OptionStruct
    );

    return Error;
}

DWORD
DhcpGetAllOptions(
    IN      DWORD                  Flags,         // unused?
    IN OUT  LPDHCP_ALL_OPTIONS     OptionStruct   // fill the fields of this structure
)
{
    DWORD                          Error;
    DWORD                          nRead;
    DWORD                          nTotal, n;
    LPWSTR                         UseClassName;
    DHCP_RESUME_HANDLE             ResumeHandle;

    if( 0 != Flags ) {                            // dont understand any flags ..
        return ERROR_INVALID_PARAMETER;
    }

    OptionStruct->Flags = 0;
    OptionStruct->VendorOptions = NULL;
    OptionStruct->NumVendorOptions = 0;
    OptionStruct->NonVendorOptions = NULL;

    ResumeHandle = 0;
    Error = DhcpEnumRPCOptionDefs(                // first read non-vendor options
        0,
        &ResumeHandle,
        NULL,
        NULL,
        0xFFFFFFF,                                // really huge max would cause all options to be read..
        &OptionStruct->NonVendorOptions,
        &nRead,
        &nTotal
    );
    DhcpAssert(ERROR_MORE_DATA != Error && ERROR_NOT_ENOUGH_MEMORY != Error);
    if( ERROR_NO_MORE_ITEMS == Error ) Error = ERROR_SUCCESS;
    if( ERROR_SUCCESS != Error ) goto Cleanup;

    Error = DhcpGetAllVendorOptions(Flags, OptionStruct);
    if( ERROR_SUCCESS == Error ) {                // if everything went fine, nothing more to do..
        return ERROR_SUCCESS;
    }

  Cleanup:
    if( OptionStruct->NonVendorOptions ) {
        _fgs__DHCP_OPTION_ARRAY(OptionStruct->NonVendorOptions);
        MIDL_user_free(OptionStruct->NonVendorOptions);
        OptionStruct->NonVendorOptions = NULL;
    }
    if( OptionStruct->NumVendorOptions ) {
        for( n = 0; n < OptionStruct->NumVendorOptions; n ++ ) {
            if( OptionStruct->VendorOptions[n].VendorName ) {
                MIDL_user_free(OptionStruct->VendorOptions[n].VendorName);
            }
            _fgs__DHCP_OPTION(&(OptionStruct->VendorOptions[n].Option));
        }
        MIDL_user_free(OptionStruct->VendorOptions);
        OptionStruct->NumVendorOptions = 0;
        OptionStruct->VendorOptions = NULL;
    }
    return Error;
}

LPWSTR
CloneClassNameForClassId(                         // get class name for class id and clone it..
    IN      DWORD                  ClassId
)
{
    DWORD                          Error;
    PM_CLASSDEF                    ClassDef;

    Error = MemServerGetClassDef(                 // search current server
        DhcpGetCurrentServer(),
        ClassId,
        NULL,
        0,
        NULL,
        &ClassDef
    );
    if( ERROR_SUCCESS != Error ) {                // could not get the class info requested
        DhcpAssert(FALSE);
        return NULL;
    }

    if( FALSE != ClassDef->IsVendor ) {           // this is actually a vendor class?
        DhcpAssert(FALSE);
        return NULL;
    }

    return CloneLPWSTR(ClassDef->Name);
}

LPWSTR
CloneVendorNameForVendorId(                       // get Vendor name for vendor id and clone it..
    IN      DWORD                  VendorId
)
{
    DWORD                          Error;
    PM_CLASSDEF                    ClassDef;

    Error = MemServerGetClassDef(                 // search current server
        DhcpGetCurrentServer(),
        VendorId,
        NULL,
        0,
        NULL,
        &ClassDef
    );
    if( ERROR_SUCCESS != Error ) {                // could not get the class info requested
        DhcpAssert(FALSE);
        return NULL;
    }

    if( TRUE != ClassDef->IsVendor ) {            // this is actually just a user class?
        DhcpAssert(FALSE);
        return NULL;
    }

    return CloneLPWSTR(ClassDef->Name);
}

DWORD
GetOptionValuesInternal(                          // get all option values for a given scope
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,   // specify scope
    IN      DWORD                  ClassId,       // for this exact class
    IN      DWORD                  VendorId,      // for this exact vendor
    IN      BOOL                   IsVendor,      // TRUE ==> get vendor opts only, false ==> get non=vendor ..
    IN      LPDHCP_ALL_OPTION_VALUES OptionValues // fill in this struct at index given by NumElements
)
{
    DWORD                          Error;
    DWORD                          i;
    DWORD                          nRead, nTotal;
    DHCP_RESUME_HANDLE             ResumeHandle;

    i = OptionValues->NumElements;
    OptionValues->Options[i].ClassName = NULL;    // initialize, no cleanup will be done in this func..
    OptionValues->Options[i].VendorName = NULL;   // caller should cleanup last element in case of error returns..
    OptionValues->Options[i].OptionsArray = NULL;

    if( 0 == ClassId ) {
        OptionValues->Options[i].ClassName = NULL;
    } else {
        OptionValues->Options[i].ClassName = CloneClassNameForClassId(ClassId);
        if( NULL == OptionValues->Options[i].ClassName ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if( 0 == VendorId ) {
        OptionValues->Options[i].VendorName = NULL;
        OptionValues->Options[i].IsVendor = FALSE;
    } else {
        OptionValues->Options[i].VendorName = CloneVendorNameForVendorId(VendorId);
        OptionValues->Options[i].IsVendor = TRUE;
        if( NULL == OptionValues->Options[i].VendorName ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    ResumeHandle = 0;
    nRead = nTotal = 0;
    Error = DhcpEnumOptionValuesInternal(
        ScopeInfo,
        ClassId,
        VendorId,
        IsVendor,
        &ResumeHandle,
        0xFFFFFFFF,
        &(OptionValues->Options[i].OptionsArray),
        &nRead,
        &nTotal
    );
    if( ERROR_NO_MORE_ITEMS == Error ) Error = ERROR_SUCCESS;

    if( ERROR_SUCCESS == Error ) {
        OptionValues->NumElements ++;
    }
    return Error;
}
DWORD
GetOptionValuesForSpecificClassVendorId(
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DWORD                    ClassId,
    IN      DWORD                    VendorId,
    IN      LPDHCP_ALL_OPTION_VALUES OptionValues
) {
    DWORD                            Error;
    DWORD                            i;

    i = OptionValues->NumElements ;
    Error = GetOptionValuesInternal(
        ScopeInfo,
        ClassId,
        VendorId,
        /* IsVendor */ FALSE,
        OptionValues
    );
    if( ERROR_SUCCESS != Error ) {
        if( OptionValues->Options[i].ClassName )
            MIDL_user_free(OptionValues->Options[i].ClassName);
        if( OptionValues->Options[i].VendorName )
            MIDL_user_free(OptionValues->Options[i].VendorName);
        if( OptionValues->Options[i].OptionsArray ) {
            _fgs__DHCP_OPTION_VALUE_ARRAY(OptionValues->Options[i].OptionsArray);
        }

        return Error;
    }
    i = OptionValues->NumElements ;
    Error = GetOptionValuesInternal(
        ScopeInfo,
        ClassId,
        VendorId,
        /* IsVendor */ TRUE,
        OptionValues
    );
    if( ERROR_SUCCESS != Error ) {
        if( OptionValues->Options[i].ClassName )
            MIDL_user_free(OptionValues->Options[i].ClassName);
        if( OptionValues->Options[i].VendorName )
            MIDL_user_free(OptionValues->Options[i].VendorName);
        if( OptionValues->Options[i].OptionsArray ) {
            _fgs__DHCP_OPTION_VALUE_ARRAY(OptionValues->Options[i].OptionsArray);
        }

        return Error;
    }

    return ERROR_SUCCESS;
}

DWORD
DhcpGetAllOptionValues(
    IN      DWORD                  Flags,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN OUT  LPDHCP_ALL_OPTION_VALUES OptionValues
)
{
    DWORD                          Error;
    DWORD                          NumElements;
    DWORD                          i;
    ARRAY_LOCATION                 Loc;
    LPARRAY                        Array;
    PM_OPTCLASS                    OptClass;
    PM_ONECLASS_OPTLIST            OptClass1;
    DHCP_RESUME_HANDLE             ResumeHandle;

    OptionValues->Flags = 0;
    OptionValues->NumElements = 0;
    OptionValues->Options = NULL;

    Error =  FindOptClassForScope(ScopeInfo, &OptClass);
    if( ERROR_SUCCESS != Error ) {                // did not find this scope's optclass..
        return Error;
    }

    NumElements = 0;
    Array = &OptClass->Array;
    for( Error = MemArrayInitLoc(Array, &Loc)
         ; ERROR_FILE_NOT_FOUND != Error ;
         Error = MemArrayNextLoc(Array, &Loc)
    ) {                                           // traverse the options list..
        DhcpAssert( ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(Array, &Loc, &OptClass1);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != OptClass1 );

        NumElements ++;
    }


    if( 0 != NumElements ) {
        NumElements *= 2;                         // one for vendor specific, one for otherwise..
        OptionValues->Options = MIDL_user_allocate(NumElements*sizeof(*(OptionValues->Options)));
        if( NULL == OptionValues->Options ) {     // could not allocate space..
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    for( Error = MemArrayInitLoc(Array, &Loc)
         ; ERROR_FILE_NOT_FOUND != Error ;
         Error = MemArrayNextLoc(Array, &Loc)
    ) {                                           // traverse the options list..
        DhcpAssert( ERROR_SUCCESS == Error);

        Error = MemArrayGetElement(Array, &Loc, &OptClass1);
        DhcpAssert(ERROR_SUCCESS == Error && NULL != OptClass1 );

        Error = GetOptionValuesForSpecificClassVendorId(
            ScopeInfo,
            OptClass1->ClassId,
            OptClass1->VendorId,
            OptionValues
        );
        if( ERROR_SUCCESS != Error ) {            // something went wrong..
            goto Cleanup;
        }
    }

    return ERROR_SUCCESS;

Cleanup:

    // Now we have to undo and free all the concerned memory..
    for( i = 0; i < OptionValues->NumElements ; i ++ ) {
        if( OptionValues->Options[i].ClassName )
            MIDL_user_free(OptionValues->Options[i].ClassName);
        if( OptionValues->Options[i].VendorName )
            MIDL_user_free(OptionValues->Options[i].VendorName);
        if( OptionValues->Options[i].OptionsArray ) {
            _fgs__DHCP_OPTION_VALUE_ARRAY(OptionValues->Options[i].OptionsArray);
        }
    }
    OptionValues->NumElements = 0;
    OptionValues->Options = NULL;

    return Error;
}

//================================================================================
//  the real rpc stubs are here
//================================================================================

//
// RPC stubs for OPTIONS and CLASSES -- old rpc stubs are at the bottom..
//

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_EXITS if option is already there
R_DhcpCreateOptionV5(                             // create a new option (must not exist)
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) //EndExport(function)
{
    DWORD                          Error;
    LPWSTR                         Name;
    LPWSTR                         Comment;
    LPBYTE                         Value;
    DWORD                          ValueSize;
    DWORD                          OptId;
    BOOL                           IsVendor;

    DhcpAssert( OptionInfo != NULL );

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpCreateOptionV5" );
    if ( Error != ERROR_SUCCESS ) return Error;

    OptId = ConvertOptIdToMemValue(OptionId, IsVendor);

    Error =  ConvertOptionInfoRPCToMemFormat(
        OptionInfo,
        &Name,
        &Comment,
        NULL,
        &Value,
        &ValueSize
    );
    if( ERROR_SUCCESS == Error ) {

        Error = DhcpCreateOptionDef(
            Name,
            Comment,
            ClassName,
            VendorName,
            OptId,
            OptionInfo->OptionType,
            Value,
            ValueSize
            );
    }

    if( Value ) DhcpFreeMemory(Value);

    return DhcpEndWriteApiEx(
        "DhcpCreateOptionV5", Error, FALSE, TRUE, 0,0,0 );
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
R_DhcpSetOptionInfoV5(                            // Modify existing option's fields
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) //EndExport(function)
{
    DWORD                          Error;
    LPWSTR                         Name;
    LPWSTR                         Comment;
    LPBYTE                         Value;
    DWORD                          ValueSize;
    DWORD                          OptId;
    BOOL                           IsVendor;

    DhcpAssert( OptionInfo != NULL );

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpSetOptionInfoV5" );
    if ( Error != ERROR_SUCCESS ) return Error;

    OptId = ConvertOptIdToMemValue(OptionID, IsVendor);

    Error =  ConvertOptionInfoRPCToMemFormat(
        OptionInfo,
        &Name,
        &Comment,
        NULL,
        &Value,
        &ValueSize
    );
    if( ERROR_SUCCESS == Error ) {

        Error = DhcpModifyOptionDef(
            Name,
            Comment,
            ClassName,
            VendorName,
            OptId,
            OptionInfo->OptionType,
            Value,
            ValueSize
            );
    }
    
    if( Value ) DhcpFreeMemory(Value);

    return DhcpEndWriteApiEx(
        "DhcpSetOptionInfoV5", Error, FALSE, TRUE, 0,0,0 );
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT
R_DhcpGetOptionInfoV5(                            // retrieve the information from off the mem structures
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory using MIDL functions
) //EndExport(function)
{
    DWORD                          Error;
    BOOL                           IsVendor;

    DhcpAssert( OptionInfo != NULL );

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginReadApi( "DhcpGetOptionInfoV5" );
    if ( Error != ERROR_SUCCESS ) return Error;

    *OptionInfo = MIDL_user_allocate(sizeof(DHCP_OPTION));
    if( NULL == *OptionInfo ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        DhcpEndReadApi( "DhcpGetOptionInfoV5", Error );
        return Error;
    }
    
    OptionID = ConvertOptIdToMemValue(OptionID, IsVendor);
    Error = DhcpGetOptionDef(
        ClassName,
        VendorName,
        OptionID,
        NULL,
        *OptionInfo,
        NULL
    );

    if( ERROR_FILE_NOT_FOUND == Error ) {
        Error = ERROR_DHCP_OPTION_NOT_PRESENT;
    }

    if( ERROR_SUCCESS != Error ) {
        MIDL_user_free(*OptionInfo);
        *OptionInfo = NULL;
    }

    DhcpEndReadApi( "DhcpGetOptionInfoV5", Error );
    return Error;
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
R_DhcpEnumOptionsV5(                              // enumerate the options defined
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,  // must be zero intially and then never touched
    IN      DWORD                  PreferredMaximum, // max # of bytes of info to pass along
    OUT     LPDHCP_OPTION_ARRAY   *Options,       // fill this option array
    OUT     DWORD                 *OptionsRead,   // fill in the # of options read
    OUT     DWORD                 *OptionsTotal   // fill in the total # here
) //EndExport(function)
{
    DWORD                          Error;
    BOOL                           IsVendor;

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginReadApi( "DhcpEnumOptionV5" );
    if ( Error != ERROR_SUCCESS ) return Error;

    Error = DhcpEnumRPCOptionDefs(
        Flags,
        ResumeHandle,
        ClassName,
        VendorName,
        PreferredMaximum,
        Options,
        OptionsRead,
        OptionsTotal
    );

    DhcpEndReadApi( "DhcpEnumOptionV5", Error );
    return Error;
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option not existent
R_DhcpRemoveOptionV5(                             // remove the option definition from the registry
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) //EndExport(function)
{
    DWORD                          Error;
    BOOL                           IsVendor;

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpRemoveOptionV5" );
    if ( Error != ERROR_SUCCESS ) return( Error );

    OptionID = ConvertOptIdToMemValue(OptionID, IsVendor);
    Error = DhcpDeleteOptionDef(
        ClassName,
        VendorName,
        OptionID
    );

    return DhcpEndWriteApiEx(
        "DhcpRemoveOptionV5", Error, FALSE, TRUE, 0,0,0 );
}

//BeginExport(function)
DWORD                                             // OPTION_NOT_PRESENT if option is not defined
R_DhcpSetOptionValueV5(                           // replace or add a new option value
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) //EndExport(function)
{
    DWORD                          Error;
    BOOL                           IsVendor;

    DhcpAssert( OptionValue != NULL );

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpSetOptionValueV5" );
    if ( Error != ERROR_SUCCESS ) return( Error );

    OptionId = ConvertOptIdToMemValue(OptionId, IsVendor);

    Error = DhcpSetOptionValue(
        ClassName,                                // no class
        VendorName,
        OptionId,
        ScopeInfo,
        OptionValue
    );

    return EndWriteApiForScopeInfo(
        "DhcpSetOptionValueV5", Error, ScopeInfo );
}

//BeginExport(function)
DWORD                                             // not atomic!!!!
R_DhcpSetOptionValuesV5(                          // set a bunch of options
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) //EndExport(function)
{
    DWORD                          NumElements;
    DWORD                          Error;
    DWORD                          Index;
    BOOL                           IsVendor;

    DhcpAssert( OptionValues != NULL );

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    NumElements = OptionValues->NumElements;
    if( 0 == NumElements ) return ERROR_SUCCESS;

    Error = DhcpBeginWriteApi( "DhcpSetOptionValueV5" );
    if ( Error != ERROR_SUCCESS ) return( Error );

    for( Index = 0; Index < NumElements ; Index ++ ) {
        Error = DhcpSetOptionValue(               // call the subroutine to do the real get operation
            ClassName,
            VendorName,
            ConvertOptIdToMemValue(OptionValues->Values[Index].OptionID,IsVendor),
            ScopeInfo,
            &OptionValues->Values[Index].Value
        );
        if( ERROR_SUCCESS != Error ) break;
    }

    return EndWriteApiForScopeInfo(
        "DhcpSetOptionValueV5", Error, ScopeInfo );
}

//BeginExport(function)
DWORD
R_DhcpGetOptionValueV5(                           // fetch the required option at required level
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory using MIDL_user_allocate
) //EndExport(function)
{
    DWORD                          Error;
    BOOL                           IsVendor;

    DhcpAssert( *OptionValue == NULL );

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginReadApi( "DhcpGetOptionValueV5" );
    if ( Error != ERROR_SUCCESS )  return Error ;

    Error = DhcpGetOptionValue(
        ConvertOptIdToMemValue(OptionID,IsVendor),
        ClassName,
        VendorName,
        ScopeInfo,
        OptionValue
    );

    DhcpEndReadApi( "DhcpGetOptionValueV5", Error );
    return Error;
}

//BeginExport(function)
DWORD
R_DhcpEnumOptionValuesV5(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) //EndExport(function)
{
    DWORD                          Error;
    BOOL                           IsVendor;

    DhcpPrint(( DEBUG_APIS, "R_DhcpEnumOptionValues is called.\n"));
    DhcpAssert( OptionValues != NULL );

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginReadApi( "DhcpEnumOptionValuesV5" );
    if ( Error != ERROR_SUCCESS )  return Error ;

    Error = DhcpEnumOptionValues(
        ScopeInfo,
        ClassName,
        VendorName,
        IsVendor,
        ResumeHandle,
        PreferredMaximum,
        OptionValues,
        OptionsRead,
        OptionsTotal
    );

    DhcpEndReadApi( "DhcpEnumOptionValuesV5", Error );
    return Error;
}

//BeginExport(function)
DWORD
R_DhcpRemoveOptionValueV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) //EndExport(function)
{
    DWORD                          Error;
    BOOL                           IsVendor;

    IsVendor = (0 != (Flags & DHCP_FLAGS_OPTION_IS_VENDOR));
    if( FALSE == IsVendor && 0 != Flags ) {       // unknown flags..
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpRemoveOptionValueV5" );
    if ( Error != ERROR_SUCCESS )  return Error ;

    Error = DhcpRemoveOptionValue(
        ConvertOptIdToMemValue(OptionID,IsVendor),
        ClassName,
        VendorName,
        ScopeInfo
    );

    return EndWriteApiForScopeInfo(
        "DhcpRemoveOptionValueV5", Error, ScopeInfo );
}

//================================================================================
//  ClassID only APIs (only NT 5 Beta2 and after)
//================================================================================

//BeginExport(function)
DWORD
R_DhcpCreateClass(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) //EndExport(function)
{
    DWORD                          Error;

    if( NULL == ClassInfo || NULL == ClassInfo->ClassName ||
        0 == ClassInfo->ClassDataLength || NULL == ClassInfo->ClassData ) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpCreateClass" );
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpCreateClass(
        ClassInfo->ClassName,
        ClassInfo->IsVendor?DHCP_FLAGS_OPTION_IS_VENDOR:0,
        ClassInfo->ClassComment,
        ClassInfo->ClassData,
        ClassInfo->ClassDataLength
    );

    return DhcpEndWriteApiEx(
        "DhcpCreateClass", Error, TRUE, FALSE, 0,0,0 );
}

//BeginExport(function)
DWORD
R_DhcpModifyClass(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) //EndExport(function)
{
    DWORD                          Error;

    if( NULL == ClassInfo || NULL == ClassInfo->ClassName ||
        0 == ClassInfo->ClassDataLength || NULL == ClassInfo->ClassData ) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpBeginWriteApi( "DhcpModifyClass" );
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpModifyClass(
        ClassInfo->ClassName,
        ClassInfo->IsVendor?DHCP_FLAGS_OPTION_IS_VENDOR:0,
        ClassInfo->ClassComment,
        ClassInfo->ClassData,
        ClassInfo->ClassDataLength
    );

    return DhcpEndWriteApiEx(
        "DhcpModifyClass", Error, TRUE, FALSE, 0,0,0 );
}

//BeginExport(function)
DWORD
R_DhcpDeleteClass(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPWSTR                 ClassName
) //EndExport(function)
{
    DWORD                          Error;

    if( NULL == ClassName ) return ERROR_INVALID_PARAMETER;

    Error = DhcpBeginWriteApi( "DhcpDeleteClass" );
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpDeleteClass(ClassName);
    
    return DhcpEndWriteApiEx(
        "DhcpDeleteClass", Error, TRUE, FALSE, 0,0,0 );
}

//BeginExport(function)
DWORD
R_DhcpGetClassInfo(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      PartialClassInfo,
    OUT     LPDHCP_CLASS_INFO     *FilledClassInfo
) //EndExport(function)
{
    DWORD                          Error;

    if( NULL == PartialClassInfo || NULL == FilledClassInfo ) return ERROR_INVALID_PARAMETER;
    if( NULL == PartialClassInfo->ClassName && NULL == PartialClassInfo->ClassData )
        return ERROR_INVALID_PARAMETER;
    if( NULL == PartialClassInfo->ClassName && 0 == PartialClassInfo->ClassDataLength )
        return ERROR_INVALID_PARAMETER;

    Error = DhcpBeginReadApi( "DhcpGetClassInfo" );
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpGetClassInfo(
        PartialClassInfo->ClassName,
        PartialClassInfo->ClassData,
        PartialClassInfo->ClassDataLength,
        FilledClassInfo
    );

    DhcpEndReadApi( "DhcpGetClassInfo", Error );
    return Error;
}

//BeginExport(function)
DWORD
R_DhcpEnumClasses(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_CLASS_INFO_ARRAY *ClassInfoArray,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
) //EndExport(function)
{
    DWORD                          Error;

    if( NULL == ClassInfoArray || NULL == nRead || NULL == nTotal )
        return ERROR_INVALID_PARAMETER;

    Error = DhcpBeginReadApi( "DhcpEnumClasses" );
    if( NO_ERROR != Error ) return Error;
    
    Error = DhcpEnumClasses(
        ResumeHandle,
        PreferredMaximum,
        ClassInfoArray,
        nRead,
        nTotal
    );

    DhcpEndReadApi( "DhcpEnumClasses", Error );
    return Error;
}

//BeginExport(function)
DWORD
R_DhcpGetAllOptionValues(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_ALL_OPTION_VALUES *Values
) //EndExport(function)
{
    DWORD                          Error;
    LPDHCP_ALL_OPTION_VALUES       LocalValues;

    Error = DhcpBeginReadApi( "DhcpGetAllOptionValues" );
    if( NO_ERROR != Error ) return Error;
    
    LocalValues = MIDL_user_allocate(sizeof(*LocalValues));
    if( NULL == LocalValues ) {
        DhcpEndReadApi( "DhcpGetAllOptionValues", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpGetAllOptionValues(
        Flags,
        ScopeInfo,
        LocalValues
    );
    
    if( ERROR_SUCCESS != Error ) {
        MIDL_user_free(LocalValues);
        LocalValues = NULL;
    }
    
    *Values = LocalValues;
    DhcpEndReadApi( "DhcpGetAllOptionValues", Error );

    return Error;
}

//BeginExport(function)
DWORD
R_DhcpGetAllOptions(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    OUT     LPDHCP_ALL_OPTIONS    *Options
) //EndExport(function)
{
    DWORD                          Error;
    LPDHCP_ALL_OPTIONS             LocalOptions;


    Error = DhcpBeginReadApi( "DhcpGetAllOptions" );
    if ( Error != ERROR_SUCCESS ) return Error;

    LocalOptions = MIDL_user_allocate(sizeof(*LocalOptions));
    if( NULL == LocalOptions ) {
        DhcpEndReadApi( "DhcpGetAllOptions", ERROR_NOT_ENOUGH_MEMORY );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Error = DhcpGetAllOptions(
        Flags,
        LocalOptions
    );

    if( ERROR_SUCCESS != Error ) {
        MIDL_user_free(LocalOptions);
        LocalOptions = NULL;
    }
    *Options = LocalOptions;

    DhcpEndReadApi( "DhcpGetAllOptions", Error );
    return Error;
}


//================================================================================
//  NT 5 beta1 and before -- the stubs for those are here...
//================================================================================
//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_EXITS if option is already there
R_DhcpCreateOption(                               // create a new option (must not exist)
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPDHCP_OPTION          OptionInfo
) //EndExport(function)
{
    return R_DhcpCreateOptionV5(
        ServerIpAddress,
        0,
        OptionId,
        NULL,
        NULL,
        OptionInfo
    );
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
R_DhcpSetOptionInfo(                              // Modify existing option's fields
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION          OptionInfo
) //EndExport(function)
{
    return R_DhcpSetOptionInfoV5(
        ServerIpAddress,
        0,
        OptionID,
        NULL,
        NULL,
        OptionInfo
    );
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT
R_DhcpGetOptionInfo(                              // retrieve the information from off the mem structures
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory using MIDL functions
) //EndExport(function)
{
    return R_DhcpGetOptionInfoV5(
        ServerIpAddress,
        0,
        OptionID,
        NULL,
        NULL,
        OptionInfo
    );
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
R_DhcpEnumOptions(                                // enumerate the options defined
    IN      LPWSTR                 ServerIpAddress,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,  // must be zero intially and then never touched
    IN      DWORD                  PreferredMaximum, // max # of bytes of info to pass along
    OUT     LPDHCP_OPTION_ARRAY   *Options,       // fill this option array
    OUT     DWORD                 *OptionsRead,   // fill in the # of options read
    OUT     DWORD                 *OptionsTotal   // fill in the total # here
) //EndExport(function)
{
    return R_DhcpEnumOptionsV5(
        ServerIpAddress,
        0,
        NULL,
        NULL,
        ResumeHandle,
        PreferredMaximum,
        Options,
        OptionsRead,
        OptionsTotal
    );
}

//BeginExport(function)
DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option not existent
R_DhcpRemoveOption(                               // remove the option definition from the registry
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID
) //EndExport(function)
{
    return R_DhcpRemoveOptionV5(
        ServerIpAddress,
        0,
        OptionID,
        NULL,
        NULL
    );
}

//BeginExport(function)
DWORD                                             // OPTION_NOT_PRESENT if option is not defined
R_DhcpSetOptionValue(                             // replace or add a new option value
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) //EndExport(function)
{
    return R_DhcpSetOptionValueV5(
        ServerIpAddress,
        0,
        OptionID,
        NULL,
        NULL,
        ScopeInfo,
        OptionValue
    );
}

//BeginExport(function)
DWORD                                             // not atomic!!!!
R_DhcpSetOptionValues(                            // set a bunch of options
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) //EndExport(function)
{
    return R_DhcpSetOptionValuesV5(
        ServerIpAddress,
        0,
        NULL,
        NULL,
        ScopeInfo,
        OptionValues
    );
}

//BeginExport(function)
DWORD
R_DhcpGetOptionValue(                             // fetch the required option at required level
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory using MIDL_user_allocate
) //EndExport(function)
{
    return R_DhcpGetOptionValueV5(
        ServerIpAddress,
        0,
        OptionID,
        NULL,
        NULL,
        ScopeInfo,
        OptionValue
    );
}

//BeginExport(function)
DWORD
R_DhcpEnumOptionValues(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) //EndExport(function)
{
    return R_DhcpEnumOptionValuesV5(
        ServerIpAddress,
        0,
        NULL,
        NULL,
        ScopeInfo,
        ResumeHandle,
        PreferredMaximum,
        OptionValues,
        OptionsRead,
        OptionsTotal
    );
}

//BeginExport(function)
DWORD
R_DhcpRemoveOptionValue(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) //EndExport(function)
{
    return R_DhcpRemoveOptionValueV5(
        ServerIpAddress,
        0,
        OptionID,
        NULL,
        NULL,
        ScopeInfo
    );
}

//================================================================================
//  plumbing some default stuff.
//================================================================================

DWORD
SetDefaultConfigInfo(
    VOID
)
{
    ULONG Error;
    DWORD ZeroDword = 0;
    DHCP_OPTION_DATA_ELEMENT OptDataElt = {
        DhcpDWordOption
    };
    DHCP_OPTION_DATA OptData = {
        1,
        &OptDataElt
    };

#define OPTION_VALUE_BUFFER_SIZE 50

    BYTE OptValueBuffer[ OPTION_VALUE_BUFFER_SIZE ];
    BYTE NetbiosOptValueBuffer[ OPTION_VALUE_BUFFER_SIZE ];
    BYTE CsrOptValueBuffer[ OPTION_VALUE_BUFFER_SIZE ];
    BYTE ReleaseOptValueBuffer[ OPTION_VALUE_BUFFER_SIZE ];

    ULONG OptValueBufferSize = 0;
    ULONG NetbiosOptValueBufferSize = 0;
    ULONG CsrOptValueBufferSize = 0;
    ULONG ReleaseOptValueBufferSize = 0;

    //
    // Fill option value struct..
    //
    OptDataElt.Element.DWordOption = 1;
    ReleaseOptValueBufferSize = sizeof(ReleaseOptValueBuffer);
    Error = DhcpConvertOptionRPCToRegFormat(
        &OptData,
        ReleaseOptValueBuffer,
        &ReleaseOptValueBufferSize
        );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_INIT, "DhcpConvertOptionRPCToRegFormat: %ld\n", Error));
        return Error;
    }

    //
    // Fill option value struct..
    //
    OptDataElt.Element.DWordOption = 0;
    OptValueBufferSize = sizeof(OptValueBuffer);
    Error = DhcpConvertOptionRPCToRegFormat(
        &OptData,
        OptValueBuffer,
        &OptValueBufferSize
        );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_INIT, "DhcpConvertOptionRPCToRegFormat: %ld\n", Error));
        return Error;
    }

    //
    // Fill option value struct..
    //
    OptDataElt.Element.DWordOption = 1;
    NetbiosOptValueBufferSize = sizeof(OptValueBuffer);
    Error = DhcpConvertOptionRPCToRegFormat(
        &OptData,
        NetbiosOptValueBuffer,
        &NetbiosOptValueBufferSize
        );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_INIT, "DhcpConvertOptionRPCToRegFormat: %ld\n", Error));
        return Error;
    }

    //
    // Fill option value struct..
    //
    OptDataElt.OptionType = DhcpBinaryDataOption;
    OptDataElt.Element.BinaryDataOption.DataLength = 0;
    OptDataElt.Element.BinaryDataOption.Data = NULL;
    CsrOptValueBufferSize = sizeof(OptValueBuffer);
    
    Error = DhcpConvertOptionRPCToRegFormat(
        &OptData,
        CsrOptValueBuffer,
        &CsrOptValueBufferSize
        );
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_INIT, "DhcpConvertOptionRPCToRegFormat: %ld\n", Error));
        return Error;
    }

    //
    // Create user classes -- ignore errors
    //

    Error = DhcpCreateClass(
        GETSTRING( DHCP_MSFT_RRAS_CLASS_NAME ),
        0, 
        GETSTRING( DHCP_MSFT_RRAS_CLASS_DESCR_NAME),
        DHCP_RAS_CLASS_TXT,
        sizeof(DHCP_RAS_CLASS_TXT)-1
        );
    if( NO_ERROR != Error && ERROR_DHCP_CLASS_ALREADY_EXISTS != Error ) {
        //
        // Ignore error
        //
        DhcpPrint((DEBUG_INIT, "DhcpCreateClass RRAS failed: %lx\n", Error));
    }

    Error = DhcpCreateClass(
        GETSTRING( DHCP_MSFT_DYNBOOTP_CLASS_NAME),
        0,
        GETSTRING( DHCP_MSFT_DYNBOOTP_CLASS_DESCR_NAME),
        DHCP_BOOTP_CLASS_TXT,
        sizeof(DHCP_BOOTP_CLASS_TXT)-1
        );
    if( NO_ERROR != Error && ERROR_DHCP_CLASS_ALREADY_EXISTS != Error ) {
        //
        // Ignore error
        //
        DhcpPrint((DEBUG_INIT, "DhcpCreateClass BOOTP failed: %lx\n", Error));
    }
    
    //
    // First create MICROSFT vendor classes..
    //

    Error = DhcpCreateClass(
        GETSTRING( DHCP_MSFT50_CLASS_NAME ),
        DHCP_FLAGS_OPTION_IS_VENDOR,
        GETSTRING( DHCP_MSFT50_CLASS_DESCR_NAME ),
        DHCP_MSFT50_CLASS_TXT,
        sizeof(DHCP_MSFT50_CLASS_TXT)-1
        );
    if( ERROR_SUCCESS != Error && ERROR_DHCP_CLASS_ALREADY_EXISTS != Error ) {
        //
        // Dont ignore errors..
        //
        DhcpPrint((DEBUG_INIT, "DhcpCreateClass msft50 failed:%lx\n", Error));
        DhcpAssert(FALSE);

        goto Cleanup;
    }

    Error = DhcpCreateClass(
        GETSTRING( DHCP_MSFT98_CLASS_NAME ),
        DHCP_FLAGS_OPTION_IS_VENDOR,
        GETSTRING( DHCP_MSFT98_CLASS_DESCR_NAME ),
        DHCP_MSFT98_CLASS_TXT,
        sizeof(DHCP_MSFT98_CLASS_TXT)-1
        );
    if( ERROR_SUCCESS != Error && ERROR_DHCP_CLASS_ALREADY_EXISTS != Error ) {
        //
        // Dont ignore errors..
        //
        DhcpPrint((DEBUG_INIT, "DhcpCreateClass msft98 failed:%lx\n", Error));
        DhcpAssert(FALSE);

        goto Cleanup;
    }

    Error = DhcpCreateClass(
        GETSTRING( DHCP_MSFT_CLASS_NAME ),
        DHCP_FLAGS_OPTION_IS_VENDOR,
        GETSTRING( DHCP_MSFT_CLASS_DESCR_NAME ),
        DHCP_MSFT_CLASS_TXT,
        sizeof(DHCP_MSFT_CLASS_TXT)-1
        );
    if( ERROR_SUCCESS != Error && ERROR_DHCP_CLASS_ALREADY_EXISTS != Error ) {
        //
        // Cant ignore this error..
        //
        DhcpPrint((DEBUG_INIT, "DhcpCreateClass msft failed:%lx\n", Error));
        DhcpAssert(FALSE);

        goto Cleanup;
    }

    Error = ERROR_INTERNAL_ERROR;
    
    DhcpGlobalMsft2000Class = DhcpServerGetVendorId(
        DhcpGetCurrentServer(),
        DHCP_MSFT50_CLASS_TXT,
        sizeof(DHCP_MSFT50_CLASS_TXT)-1
        );
    if( 0 == DhcpGlobalMsft2000Class ) {
        DhcpPrint((DEBUG_INIT, "MSFT50 Class isn't present..\n"));

        goto Cleanup;
    }

    DhcpGlobalMsft98Class = DhcpServerGetVendorId(
        DhcpGetCurrentServer(),
        DHCP_MSFT98_CLASS_TXT,
        sizeof(DHCP_MSFT98_CLASS_TXT)-1
        );
    if( 0 == DhcpGlobalMsft98Class ) {
        DhcpPrint((DEBUG_INIT, "MSFT98 Class isn't present..\n"));

        goto Cleanup;
    }
    
    DhcpGlobalMsftClass = DhcpServerGetVendorId(
        DhcpGetCurrentServer(),
        DHCP_MSFT_CLASS_TXT,
        sizeof(DHCP_MSFT_CLASS_TXT)-1
        );
    if( 0 == DhcpGlobalMsftClass ) {
        DhcpPrint((DEBUG_INIT, "MSFT Class isn't present..\n"));

        goto Cleanup;
    }

    //
    // Create the default user classes ??
    //
    
    //
    // Create Default option definitions..
    //

    //
    // Netbiosless option
    //
    Error = DhcpCreateOptionDef(
        GETSTRING( DHCP_NETBIOS_VENDOR_OPTION_NAME ),
        GETSTRING( DHCP_NETBIOS_VENDOR_DESCR_NAME ),
        NULL,
        GETSTRING( DHCP_MSFT_CLASS_NAME ),
        ConvertOptIdToMemValue(OPTION_MSFT_VENDOR_NETBIOSLESS, TRUE),
        DhcpUnaryElementTypeOption,
        NetbiosOptValueBuffer,
        NetbiosOptValueBufferSize
        );
    if( ERROR_SUCCESS != Error && ERROR_DHCP_OPTION_EXITS != Error ) {
        //
        // Don't ignore errors..
        //
        DhcpPrint((DEBUG_INIT, "Create Netbiosless option failed: %lx\n", Error));
        DhcpAssert(FALSE);

        goto Cleanup;
    }

    //
    // Create Release on shutdown and other options
    //
    Error = DhcpCreateOptionDef(
        GETSTRING( DHCP_RELEASE_SHUTDOWN_VENDOR_OPTION_NAME ),
        GETSTRING( DHCP_RELEASE_SHUTDOWN_VENDOR_DESCR_NAME ),
        NULL,
        GETSTRING( DHCP_MSFT_CLASS_NAME ),
        ConvertOptIdToMemValue(OPTION_MSFT_VENDOR_FEATURELIST, TRUE),
        DhcpUnaryElementTypeOption,
        OptValueBuffer,
        OptValueBufferSize
        );
    if( ERROR_SUCCESS != Error && ERROR_DHCP_OPTION_EXITS != Error ) {
        //
        // Don't ignore errors..
        //
        DhcpPrint((DEBUG_INIT, "Create ReleaseOnShutdown option failed: %lx\n", Error));
        DhcpAssert(FALSE);

        goto Cleanup;
    }

    //
    // Create metric-base option
    //
    Error = DhcpCreateOptionDef(
        GETSTRING( DHCP_METRICBASE_VENDOR_OPTION_NAME ),
        GETSTRING( DHCP_METRICBASE_VENDOR_DESCR_NAME ),
        NULL,
        GETSTRING( DHCP_MSFT_CLASS_NAME ),
        ConvertOptIdToMemValue(OPTION_MSFT_VENDOR_METRIC_BASE, TRUE),
        DhcpUnaryElementTypeOption,
        OptValueBuffer,
        OptValueBufferSize
        );
    if( ERROR_SUCCESS != Error && ERROR_DHCP_OPTION_EXITS != Error ) {
        //
        // Don't ignore errors..
        //
        DhcpPrint((DEBUG_INIT, "Create metricbase option failed: %lx\n", Error));
        DhcpAssert(FALSE);

        goto Cleanup;
    }

    //
    // Create same set of options as before for MSFT50 class..
    //
    
    //
    // Netbiosless option
    //
    Error = DhcpCreateOptionDef(
        GETSTRING( DHCP_NETBIOS_VENDOR_OPTION_NAME ),
        GETSTRING( DHCP_NETBIOS_VENDOR_DESCR_NAME ),
        NULL,
        GETSTRING( DHCP_MSFT50_CLASS_NAME ),
        ConvertOptIdToMemValue(OPTION_MSFT_VENDOR_NETBIOSLESS, TRUE),
        DhcpUnaryElementTypeOption,
        NetbiosOptValueBuffer,
        NetbiosOptValueBufferSize
        );
    if( ERROR_SUCCESS != Error && ERROR_DHCP_OPTION_EXITS != Error ) {
        //
        // Don't ignore errors..
        //
        DhcpPrint((DEBUG_INIT, "Create Netbiosless50 option failed: %lx\n", Error));
        DhcpAssert(FALSE);

        goto Cleanup;
    }

    //
    // Create Release on shutdown and other options
    //
    Error = DhcpCreateOptionDef(
        GETSTRING( DHCP_RELEASE_SHUTDOWN_VENDOR_OPTION_NAME ),
        GETSTRING( DHCP_RELEASE_SHUTDOWN_VENDOR_DESCR_NAME ),
        NULL,
        GETSTRING( DHCP_MSFT50_CLASS_NAME ),
        ConvertOptIdToMemValue(OPTION_MSFT_VENDOR_FEATURELIST, TRUE),
        DhcpUnaryElementTypeOption,
        ReleaseOptValueBuffer,
        ReleaseOptValueBufferSize
        );
    if( ERROR_SUCCESS != Error && ERROR_DHCP_OPTION_EXITS != Error ) {
        //
        // Don't ignore errors..
        //
        DhcpPrint((DEBUG_INIT, "Create ReleaseOnShutdown50 option failed: %lx\n", Error));
        DhcpAssert(FALSE);

        goto Cleanup;
    }

    //
    // Create metric base option
    //
    Error = DhcpCreateOptionDef(
        GETSTRING( DHCP_METRICBASE_VENDOR_OPTION_NAME ),
        GETSTRING( DHCP_METRICBASE_VENDOR_DESCR_NAME ),
        NULL,
        GETSTRING( DHCP_MSFT50_CLASS_NAME ),
        ConvertOptIdToMemValue(OPTION_MSFT_VENDOR_METRIC_BASE, TRUE),
        DhcpUnaryElementTypeOption,
        OptValueBuffer,
        OptValueBufferSize
        );
    if( ERROR_SUCCESS != Error && ERROR_DHCP_OPTION_EXITS != Error ) {
        //
        // Don't ignore errors..
        //
        DhcpPrint((DEBUG_INIT, "Create metricbase50 option failed: %lx\n", Error));
        DhcpAssert(FALSE);

        goto Cleanup;
    }

    Error = DhcpCreateOptionDef(
        GETSTRING( DHCP_MSFT_CSR_OPTION_NAME ),
        GETSTRING( DHCP_MSFT_CSR_DESCR_NAME ),
        NULL,
        NULL,
        OPTION_CLASSLESS_ROUTES,
        DhcpUnaryElementTypeOption,
        CsrOptValueBuffer,
        CsrOptValueBufferSize
        );
    
    return DhcpConfigSave(
        TRUE, TRUE, 0,0,0);

 Cleanup:

    ASSERT( NO_ERROR != Error );

    return Error;
}

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\scan.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    scan.c

Abstract:

    This module contains the implementation for the APIs that update
    the list of IP addresses that the server can distribute.

Author:

    Madan Appiah (madana)  13-Oct-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#include "dhcppch.h"
#include <mmapi.h>

#include <mdhcpsrv.h>
typedef struct _BITMAP_ENTRY {
    DHCP_IP_ADDRESS ClusterAddress;
    DWORD ClusterBitMap;
    DHCP_IP_ADDRESS RangeStartAddress;
    DHCP_IP_ADDRESS RangeEndAddress;
} BITMAP_ENTRY, *LPBITMAP_ENTRY;

DWORD
MemReserveFindByAddress(
    IN      PM_RESERVATIONS        Reservation,
    IN      DWORD                  Address,
    OUT     PM_RESERVATION        *Res
);


INT __cdecl
CmpReservedAddress(
    const void *Entry1,
    const void *Entry2
    )
{
    DHCP_IP_ADDRESS Ip1 = *(DHCP_IP_ADDRESS *)Entry1;
    DHCP_IP_ADDRESS Ip2 = *(DHCP_IP_ADDRESS *)Entry2;

    if( Ip1 == Ip2 ) return 0;
    if( Ip1 > Ip2 ) return 1;
    return -1;
}

INT __cdecl
CmpBitmapEntry(
    const void *Entry1,
    const void *Entry2
    )
{
    if( ((LPBITMAP_ENTRY)Entry1)->ClusterAddress ==
            ((LPBITMAP_ENTRY)Entry2)->ClusterAddress ) {
        return(0);
    }
    else if( ((LPBITMAP_ENTRY)Entry1)->ClusterAddress >
                ((LPBITMAP_ENTRY)Entry2)->ClusterAddress ) {
        return(1);
    }
    return(-1);
}

BOOL
FoundInBitMap(
    LPBITMAP_ENTRY BitMapList,
    LPBITMAP_ENTRY EndBitMapList,
    DHCP_IP_ADDRESS IpAddress,
    LPBITMAP_ENTRY *LastPointer
    )
/*++

Routine Description:

    This function checks to see that a given IP address is in the
    BITMAP. if it is, returns TRUE otherwise FALSE.

Arguments:

    BitMapList - BITMAP list.

    EndBitMapList - end of bitmap list.

    IpAddress - address to look at.

    LastPointer - location where last search was found.

Return Value:

    TRUE or FALSE.
--*/
{
    //
    // begin search from last found entry.
    //

    LPBITMAP_ENTRY NextEntry = *LastPointer;
    DHCP_IP_ADDRESS Address;

    DhcpAssert( NextEntry < EndBitMapList );
    for ( ; ; ) {

        Address = NextEntry->ClusterAddress;

        //
        // check address is in the current cluster.
        //

        if( (IpAddress >= Address) &&
                (IpAddress < (Address + CLUSTER_SIZE)) ) {

            DWORD Bit = 0x1 << (IpAddress - Address);

            //
            // return current cluster for next search.
            //

            *LastPointer = NextEntry;

            if( NextEntry->ClusterBitMap & Bit ) {

                //
                // address is marked in the bitmap.
                //

                return( TRUE );
            }

            return( FALSE );
        }

        NextEntry++;
        if ( NextEntry >= EndBitMapList ) {

            //
            // move back to the begining of the cluster array.
            //

            NextEntry = BitMapList;
        }

        if( NextEntry ==  *LastPointer ) {

            //
            // we are done searching the entire cluster array.
            //

            return(FALSE);
        }
    }

    DhcpAssert( FALSE );
}

BOOL
FoundInDatabase(
    LPDHCP_IP_ADDRESS DatabaseList,
    LPDHCP_IP_ADDRESS EndDatabaseList,
    DHCP_IP_ADDRESS NextAddress,
    LPDHCP_IP_ADDRESS *LastEntry
    )
/*++

Routine Description:

    This function scans for a database entry from the database list. It
    it is found in the list it returns TRUE otherwise it returns FALSE.

Arguments:

    DatabaseList - list of database entries.

    EndDatabaseListCount - end of database entries list.

    NextAddress - lookup entry.

    LastEntry - pointer to last found entry.

Return Value:

    TRUE or FALSE.
--*/
{

    //
    // start search from next to last found entry.
    //

    LPDHCP_IP_ADDRESS NextEntry = *LastEntry;

    do {

        NextEntry++;

        if( NextEntry >= EndDatabaseList ) {

            //
            // move back to the begining of the list.
            //

            NextEntry = DatabaseList;

        }

        if( *NextEntry == NextAddress ) {

            *LastEntry = NextEntry;
            return(TRUE);
        }

    } while ( NextEntry != *LastEntry );


    return(FALSE);
}

BOOL
FindNextAddress(
    LPBITMAP_ENTRY *NextCluster,
    DHCP_IP_ADDRESS *NextAddress,
    LPBITMAP_ENTRY EndBitMapList
    )
/*++

Routine Description:

    This function returns next used address from the bit map.

Arguments:

    NextCluster - pointer to next cluster entry pointer.

    NextAddress - pointer to an address location. on entry it contains
        the last returned address and on exit it will have next address.
        It is set to zero if this is begining of the serach.

    EndBitMapList - end of BitMap list.

Return Value:

    TRUE or FALSE.

--*/
{
    DHCP_IP_ADDRESS Address;
    LPBITMAP_ENTRY Cluster = *NextCluster;

    //
    // if this is start of the address search, set the address to
    // the first cluster address.
    //

    if( *NextAddress == 0 ) {
        Address = Cluster->ClusterAddress;
    }
    else {

        //
        // otherwise search from next to last found address.
        //

        Address = *NextAddress + 1;
    }

    for ( ; ; ) {

        //
        // is this address in the current cluster ?
        //

        if( Address < Cluster->ClusterAddress + CLUSTER_SIZE ) {

            //
            // check this address is used.
            //

            if( Cluster->ClusterBitMap &
                    (0x1 << (Address - Cluster->ClusterAddress)) ) {

                if( Address <= Cluster->RangeEndAddress ) {

                    *NextAddress = Address;
                    *NextCluster = Cluster;
                    return( TRUE );
                }

            }

            Address++;
        }
        else {

            //
            // move to next cluster;
            //

            Cluster++;

            if( Cluster >= EndBitMapList ) {
                //
                // end of search.
                //

                return( FALSE );
            }

            //
            // next possible used address.
            //

            Address = Cluster->ClusterAddress;
        }
    }

    DhcpAssert( FALSE );
}


DWORD
InitBadList(
    LPDHCP_SCAN_LIST *ScanList
    )
/*++

Routine Description:

    This function initialize scan list.

Arguments:

    ScanList - pointer to scan list.

Return Value:

    WINDOWS errors.
--*/
{

    DhcpAssert( *ScanList == NULL );

    //
    // make new scan list.
    //
    // Note : DhcpAllocateMemory zeros the returned memory block, so
    // (*ScanList)->NumScanItems should be set to 0 and
    // (*ScanList)->NumScanItems should be set to NULL.
    //

    *ScanList = DhcpAllocateMemory( sizeof(DHCP_SCAN_LIST) );

    if( *ScanList == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    return( ERROR_SUCCESS );
}

DWORD
AddToBadList(
    LPDHCP_SCAN_LIST *ScanList,
    DHCP_IP_ADDRESS Address,
    DHCP_SCAN_FLAG Fix
    )
/*++

Routine Description:

    This function adds another bad entry to scan list.

Arguments:

    ScanList - pointer to scan list.

    Address - bad address.

    Fix - type of fix required.

Return Value:

    WINDOWS errors.
--*/
{
    LPDHCP_SCAN_LIST List = *ScanList;
    LPDHCP_SCAN_ITEM NextItem;
    ULONG i;

#define ENTRIES_TO_ALLOCATE_ATTIME     100

    DhcpAssert( List != NULL );

    //
    // First check to see if the bad list already has this
    // address..
    //
    for( i = 0; i < List->NumScanItems ; i ++ ) {
        if( List->ScanItems[i].IpAddress == Address ) {
            //
            // Already there?  A database fix takes
            // precedence over a registr fix..
            //
            if( DhcpDatabaseFix == Fix ) {
                List->ScanItems[i].ScanFlag = DhcpDatabaseFix;
            }
            return ERROR_SUCCESS;
        }
    }

    if( (List->NumScanItems % ENTRIES_TO_ALLOCATE_ATTIME) == 0) {

        LPDHCP_SCAN_ITEM NewScanItems;

        //
        // expand items memory.
        //

        NewScanItems = DhcpAllocateMemory(
                        sizeof(DHCP_SCAN_ITEM) *
                            (List->NumScanItems +
                                ENTRIES_TO_ALLOCATE_ATTIME) );

        if( NewScanItems == NULL  ) {
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        if( List->NumScanItems != 0 ) {

			//
			// copy old items.
			//

            memcpy(
                NewScanItems,
                List->ScanItems,
                sizeof(DHCP_SCAN_ITEM) *
                    List->NumScanItems );

            DhcpFreeMemory( List->ScanItems );
        }

        List->ScanItems = NewScanItems;
    }

    NextItem = &List->ScanItems[List->NumScanItems];

    NextItem->IpAddress = Address;
    NextItem->ScanFlag = Fix;
    List->NumScanItems++;

    *ScanList = List;

    return( ERROR_SUCCESS );
}


DWORD
VerifyLists(
    PM_SUBNET Subnet,
    LPDHCP_IP_ADDRESS DatabaseList,
    DWORD DatabaseListCount,
    LPBITMAP_ENTRY BitMapList,
    DWORD BitMapListCount,
    DHCP_IP_ADDRESS *ReservedList,
    ULONG ReserveListCount,
    LPDHCP_SCAN_LIST *ScanList
    )
/*++

Routine Description:

    This function goes throught the database list and registry list and
    match each other and determines all mismatch entries to for a
    scanlist.

Arguments:

    DatabaseList : List of database entries, ip addresses.

    DatabaseListCount : count of ip addresses.

    BitMapList : list of clusters.

    BitMapListCount : count of clusters.

    ScanList : list of bad entries returned.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error = ERROR_SUCCESS;
    LPDHCP_IP_ADDRESS DatabaseEntry;
    LPBITMAP_ENTRY NextCluster;
    DHCP_IP_ADDRESS NextAddress;
    LPBITMAP_ENTRY LastCluster;
    LPDHCP_IP_ADDRESS LastDBEntry;
    LPBITMAP_ENTRY EndBitMapList = BitMapList + BitMapListCount;
    LPDHCP_IP_ADDRESS EndDatabaseList = DatabaseList + DatabaseListCount;
    ULONG i;

    DhcpAssert( *ScanList == NULL );

    //
    // init scan list.
    //

    Error = InitBadList( ScanList );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    // sort bitmap array.
    //

    if( BitMapListCount != 0 ) {

        qsort(
            (PVOID)BitMapList,
            (size_t)BitMapListCount,
            (size_t)sizeof(BITMAP_ENTRY),
            CmpBitmapEntry );

    }

    if( ReserveListCount != 0 ) {
        qsort(
            (PVOID)ReservedList,
            (size_t)ReserveListCount,
            sizeof(DHCP_IP_ADDRESS),
            CmpReservedAddress
            );
    }

    //
    // scan database entries and check each entry against the bitmap.
    //

    if( DatabaseListCount ) {

        LastCluster = BitMapList;
        for( DatabaseEntry = DatabaseList;
                DatabaseEntry < EndDatabaseList;
                    DatabaseEntry++ ) {


            //
            // find it in bitmap.
            //

            if( (BitMapListCount == 0) ||
                !FoundInBitMap(
                    BitMapList,
                    EndBitMapList,
                    *DatabaseEntry,
                    &LastCluster ) ) {

                if( !DhcpServerIsAddressReserved(
                    DhcpGetCurrentServer(), *DatabaseEntry )  ) {

                    Error = AddToBadList(
                        ScanList,
                        *DatabaseEntry,
                        DhcpRegistryFix
                    );

                    if( Error != ERROR_SUCCESS ){
                        goto Cleanup;
                    }
                }
            }
        }
    }

    if ( BitMapListCount ) {

        //
        // init search.
        //

        NextCluster = BitMapList;
        NextAddress = 0;
        LastDBEntry =
            (DatabaseListCount == 0) ? DatabaseList : (EndDatabaseList - 1);

        while( FindNextAddress( &NextCluster, &NextAddress, EndBitMapList ) ) {

            if( (DatabaseListCount == 0) ||
                !FoundInDatabase(
                    DatabaseList,
                    EndDatabaseList,
                    NextAddress,
                    &LastDBEntry ) ) {

                if( !DhcpSubnetIsAddressExcluded(
                    Subnet, NextAddress) ) {

                    Error = AddToBadList(
                                ScanList,
                                NextAddress,
                                DhcpDatabaseFix );

                    if( Error != ERROR_SUCCESS ){
                        goto Cleanup;
                    }
                }
            }
        }
    }

    if( ReserveListCount ) {

        LastDBEntry =
            (DatabaseListCount == 0) ? DatabaseList : (EndDatabaseList - 1);

        for( i = 0; i < ReserveListCount ; i ++ ) {
            if( (DatabaseListCount == 0 ) ||
                !FoundInDatabase(
                    DatabaseList, EndDatabaseList,
                    ReservedList[i], &LastDBEntry
                    )
                ) {
                Error = AddToBadList(
                    ScanList, ReservedList[i], DhcpDatabaseFix
                    );
                if( ERROR_SUCCESS != Error ) goto Cleanup;
            }
        }
    }

Cleanup:

    if( Error != ERROR_SUCCESS ) {

        //
        // freeup the scan list.
        //

        if( *ScanList != NULL ) {
            if( (*ScanList)->ScanItems != NULL ) {
                DhcpFreeMemory( (*ScanList)->ScanItems );
            }

            DhcpFreeMemory( *ScanList );
            *ScanList = NULL;
        }
    }

    return( Error );
}


DWORD
AppendClustersToList(
    LPBITMAP_ENTRY *BitMapList,
    DWORD *BitMapListCount,
    DWORD *MaxCount,
    DHCP_IP_ADDRESS RangeStartAddress,
    DHCP_IP_ADDRESS RangeEndAddress,
    LPDHCP_BINARY_DATA InUseBinaryData,
    LPDHCP_BINARY_DATA UsedBinaryData
    )
/*++

Routine Description:

    Append list of new cluster entries to BitMapList. If necessary this
    function allocates memory for BitMapList or expands the old buffer.

Arguments:

    BitMapList : Pointer to list bit map cluster. Caller should free up
        the memory after use.

    BitMapListCount : Count of entries in the above list.

    MaxCount :  Count entries that fit in the current BitMapList Buffer.

    RangeStartAddress : start of this range.

    RangeEndAddress : end of this range.

    InUseBinaryData : Current range InUseCluster list.

    UsedBinaryData : Current subnet range UsedCluster list.

Return Value:

    WINDOWS errors.
--*/
{
    LPBITMAP_ENTRY List = *BitMapList;
    DWORD Count = *BitMapListCount;
    DWORD MaximumCount = *MaxCount;

    LPIN_USE_CLUSTERS InUseClusters = (LPIN_USE_CLUSTERS)InUseBinaryData->Data;
    LPUSED_CLUSTERS UsedClusters = (LPUSED_CLUSTERS)UsedBinaryData->Data;

    DWORD TempCount;
    LPBITMAP_ENTRY Entry;
    DWORD i;

#define ALLOC_NUM_ENTRIES_AT_TIME   128

    if( List == NULL ) {

        DhcpAssert( MaximumCount == 0 );
        DhcpAssert( Count == 0 );

        //
        // allocate first chunk of memory.
        //

        List = DhcpAllocateMemory(
                    sizeof(BITMAP_ENTRY) *
                        ALLOC_NUM_ENTRIES_AT_TIME );

        if( List == NULL ) {
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        MaximumCount = ALLOC_NUM_ENTRIES_AT_TIME;
    }

    //
    // check to see we have enough space in the buffer for new entries
    // to append.
    //

    TempCount = InUseClusters->NumInUseClusters +
                    UsedClusters->NumUsedClusters;

    //
    // special case: add at least an entry for this range,
    // so that the fix routine will get to know
    // abou this range.
    //

    if( TempCount == 0 ) {
        TempCount = 1;
    }

    if( (Count + TempCount) > MaximumCount ) {

        LPBITMAP_ENTRY NewBitMapList;

        //
        // enlarge the buffer.
        //

        MaximumCount += (((TempCount / ALLOC_NUM_ENTRIES_AT_TIME) + 1) *
                            ALLOC_NUM_ENTRIES_AT_TIME );


        NewBitMapList = DhcpAllocateMemory(
                            sizeof(BITMAP_ENTRY) *
                               MaximumCount );


        if( NewBitMapList == NULL ) {
            return( ERROR_NOT_ENOUGH_MEMORY );
        }

        //
        // Copy old data to new buffer.
        //

        memcpy(
            NewBitMapList,
            List,
            Count * sizeof(BITMAP_ENTRY) );

        //
        // freeup old memory.
        //

        DhcpFreeMemory( List );

        List = NewBitMapList;
    }

    DhcpAssert( (TempCount + Count) < MaximumCount );

    //
    // new copy in use entries.
    //

    Entry = &List[Count];

    if( (InUseClusters->NumInUseClusters != 0) ||
            (UsedClusters->NumUsedClusters != 0 ) ) {

        for( i = 0; i < InUseClusters->NumInUseClusters; i++ ) {

            Entry->ClusterAddress = InUseClusters->Clusters[i].ClusterAddress;
            Entry->ClusterBitMap = InUseClusters->Clusters[i].ClusterBitMap;
            Entry->RangeStartAddress = RangeStartAddress;
            Entry->RangeEndAddress = RangeEndAddress;
            Entry++;
        }

        for( i = 0; i < UsedClusters->NumUsedClusters; i++ ) {

            Entry->ClusterAddress = UsedClusters->Clusters[i];
            Entry->ClusterBitMap = (DWORD)(-1);
            Entry->RangeStartAddress = RangeStartAddress;
            Entry->RangeEndAddress = RangeEndAddress;
            Entry++;
        }
    }
    else {

        //
        // special case: add at least an entry for this range,
        // so that the fix routine will get to know
        // abou this range.
        //

        Entry->ClusterAddress = RangeStartAddress;
        Entry->ClusterBitMap = (DWORD)(0);
        Entry->RangeStartAddress = RangeStartAddress;
        Entry->RangeEndAddress = RangeEndAddress;
        Entry++;
    }

    Count += (DWORD)(Entry - &List[Count]); // check ??

    *BitMapList = List;
    *BitMapListCount = Count;
    *MaxCount = MaximumCount;

    return( ERROR_SUCCESS );
}

DWORD
FillRangesClusterFunc(
    IN      PM_RANGE               Range,
    IN      LPBITMAP_ENTRY        *BitMapList,
    IN      LPDWORD                BitMapListCount,
    IN      LPDWORD                MaxBitMapListCount,
    IN      LPDHCP_BINARY_DATA     InUseBinaryData,
    IN      LPDHCP_BINARY_DATA     UsedBinaryData
)
{
    return AppendClustersToList(
        BitMapList,
        BitMapListCount,
        MaxBitMapListCount,
        Range->Start,
        Range->End,
        InUseBinaryData,
        UsedBinaryData
    );
}

DWORD
GetRegistryBitMap(
    PM_SUBNET Subnet,
    LPBITMAP_ENTRY *BitMapList,
    DWORD *BitMapListCount
    )
/*++

Routine Description:

Arguments:

    SubnetMask : Pointer to a location where the subnet mask of the
        above subnet is returned.

    BitMapList : Pointer to list bit map cluster. Caller should free up
        the memory after use.

    BitMapListCount : Count of entries in the above list.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error;

    DWORD MaxBitMapListCount = 0;

    DhcpAssert( *BitMapList == NULL );

    Error = DhcpLoopThruSubnetRanges(
        Subnet,
        BitMapList,
        BitMapListCount,
        &MaxBitMapListCount,
        FillRangesClusterFunc
    );

Cleanup:

    if (Error != ERROR_SUCCESS ) {

        //
        // if aren't successful free up return buffers.
        //

        if( *BitMapList != NULL ) {
            DhcpFreeMemory( *BitMapList );
        }

        *BitMapListCount = 0;
    }

    return( Error );
}


DWORD
GetDatabaseList(
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_IP_ADDRESS *DatabaseList,
    DWORD *DatabaseListCount
    )
/*++

Routine Description:

    Read ipaddresses of the database entries that belong to the given
    subnet.

Arguments:

    SubnetAddress : Address of the subnet scope to verify.

    DatabaseList : pointer to list of ip address. caller should free up
        the memory after use.

    DatabaseListCount : count of ip addresses in the above list.

Return Value:

    WINDOWS errors.
--*/
{

    DWORD Error;
    JET_ERR JetError;
    JET_RECPOS JetRecordPosition;
    DWORD TotalExpRecCount = 1;
    DWORD RecordCount = 0;
    LPDHCP_IP_ADDRESS IpList = NULL;
    DWORD i;

    //
    // move the database pointer to the begining.
    //

    Error = DhcpJetPrepareSearch(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                TRUE,   // Search from start
                NULL,
                0
                );


    if( Error != ERROR_SUCCESS ) {
        if( Error == ERROR_NO_MORE_ITEMS ) {

            *DatabaseList = NULL;
            *DatabaseListCount = 0;
            Error = ERROR_SUCCESS;
        }
        goto Cleanup;
    }

    //
    // determine total number of records in the database.
    //
    // There is no way to determine the total number of records, other
    // than  walk through the db. do it.
    //


    while ( (Error = DhcpJetNextRecord() ) == ERROR_SUCCESS )  {
         TotalExpRecCount++;
    }

    if ( Error != ERROR_NO_MORE_ITEMS ) {
        goto Cleanup;
    }

    //
    // move back the database pointer to the begining.
    //

    Error = DhcpJetPrepareSearch(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                TRUE,   // Search from start
                NULL,
                0
                );


    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // allocate memory for return list.
    //

    IpList = DhcpAllocateMemory( sizeof(DHCP_IP_ADDRESS) * TotalExpRecCount );

    if( IpList == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // read database entries.
    //

    for( i = 0; i < TotalExpRecCount; i++ ) {

        DHCP_IP_ADDRESS IpAddress;
        DHCP_IP_ADDRESS SubnetMask;
        DHCP_IP_ADDRESS realSubnetMask;
        DWORD Size;

        //
        // read ip address of the current record.
        //

        Size = sizeof(IpAddress);
        Error = DhcpJetGetValue(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
                    &IpAddress,
                    &Size );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
        DhcpAssert( Size == sizeof(IpAddress) );

        Size = sizeof(SubnetMask);
        Error = DhcpJetGetValue(
                    DhcpGlobalClientTable[SUBNET_MASK_INDEX].ColHandle,
                    &SubnetMask,
                    &Size );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }
        DhcpAssert( Size == sizeof(SubnetMask) );

        realSubnetMask = DhcpGetSubnetMaskForAddress(IpAddress);
        if( realSubnetMask != SubnetMask ) {
            DhcpPrint((DEBUG_ERRORS, "Ip Address <%s> ",inet_ntoa(*(struct in_addr *)&IpAddress)));
            DhcpPrint((DEBUG_ERRORS, "has subnet mask <%s> in db, must be ",inet_ntoa(*(struct in_addr *)&SubnetMask)));
            DhcpPrint((DEBUG_ERRORS, " <%s>\n",inet_ntoa(*(struct in_addr *)&realSubnetMask)));
            DhcpAssert( realSubnetMask == SubnetMask && "GetDatabaseList (scan.c)");
        }

        if( (IpAddress & realSubnetMask) == SubnetAddress ) {

            //
            // append this address to list.
            //

            IpList[RecordCount++] = IpAddress;
        }

        //
        // move to next record.
        //

        Error = DhcpJetNextRecord();

        if( Error != ERROR_SUCCESS ) {

            if( Error == ERROR_NO_MORE_ITEMS ) {
                Error = ERROR_SUCCESS;
                break;
            }

            goto Cleanup;
        }
    }

#if DBG

    //
    // we should be pointing to end of database.

    Error = DhcpJetNextRecord();
    DhcpAssert( Error == ERROR_NO_MORE_ITEMS );
    Error = ERROR_SUCCESS;

#endif // DBG

    *DatabaseList = IpList;
    IpList = NULL;
    *DatabaseListCount = RecordCount;

Cleanup:

    if( IpList != NULL ) {
        DhcpFreeMemory( IpList );
    }

    return( Error );
}


DWORD
CreateClientDBEntry(
    DHCP_IP_ADDRESS ClientIpAddress,
    DHCP_IP_ADDRESS SubnetMask,
    LPBYTE ClientHardwareAddress,
    DWORD HardwareAddressLength,
    DATE_TIME LeaseTerminates,
    LPWSTR MachineName,
    LPWSTR ClientInformation,
    DHCP_IP_ADDRESS ServerIpAddress,
    BYTE AddressState,
    BYTE ClientType
    )
/*++

Routine Description:

    This function creates a client entry in the client database.

Arguments:

    ClientIpAddress - IP address of the client.

    SubnetAddress - Subnet address of the client.

    ClientHardareAddress - The hardware address of this client.

    HardwareAddressLength - The length, in bytes, of the hardware address.

    LeaseDuration - The duration of the lease, in seconds.

    MachineName - The hostname of the client machine.  If NULL, the
        client information is unknown.

    ClientInformation - A client information string.  If NULL, the
        client information is unknown.

    ServerIpAddress - IpAddress of the server which supplied the lease
        to the client.

    AddressState - The new state of the address.

Return Value:

    The status of the operation.

--*/
{
    DWORD Error;
    BOOL TransactBegin = FALSE;
    JET_ERR JetError = JET_errSuccess;

    //
    // start transaction before a create/update database record.
    //

    Error = DhcpJetBeginTransaction();

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    TransactBegin = TRUE;

    Error = DhcpJetPrepareUpdate(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
                &ClientIpAddress,
                sizeof( ClientIpAddress ),
                TRUE );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
                &ClientIpAddress,
                sizeof( ClientIpAddress ) );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[SUBNET_MASK_INDEX].ColHandle,
                &SubnetMask,
                sizeof(SubnetMask) );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[STATE_INDEX].ColHandle,
                &AddressState,
                sizeof(AddressState) );

    if( ERROR_SUCCESS != Error ) {
        goto Cleanup;
    }
    
    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[CLIENT_TYPE_INDEX].ColHandle,
                &ClientType,
                sizeof(ClientType) );

    if( ERROR_SUCCESS != Error ) {
        goto Cleanup;
    }
    
    //
    // Write the information for this client.
    //

    //
    // ClientHarwardAddress can't be NULL.
    //

    DhcpAssert( (ClientHardwareAddress != NULL) &&
                    (HardwareAddressLength > 0) );

    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
                ClientHardwareAddress,
                HardwareAddressLength
                );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
                MachineName,
                (MachineName == NULL) ? 0 :
                    (wcslen(MachineName) + 1) * sizeof(WCHAR) );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[MACHINE_INFO_INDEX].ColHandle,
                ClientInformation,
                (ClientInformation == NULL) ? 0 :
                    (wcslen(ClientInformation) + 1) * sizeof(WCHAR) );

    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[LEASE_TERMINATE_INDEX].ColHandle,
                &LeaseTerminates,
                sizeof(LeaseTerminates));

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[SERVER_NAME_INDEX].ColHandle,
                DhcpGlobalServerName,
                DhcpGlobalServerNameLen );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    Error = DhcpJetSetValue(
                DhcpGlobalClientTable[SERVER_IP_ADDRESS_INDEX].ColHandle,
                &ServerIpAddress,
                sizeof(ServerIpAddress) );

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // commit changes.
    //

    JetError = JetUpdate(
                    DhcpGlobalJetServerSession,
                    DhcpGlobalClientTableHandle,
                    NULL,
                    0,
                    NULL );

    Error = DhcpMapJetError( JetError, "M:Scan:Create:Update" );

Cleanup:

    if ( Error != ERROR_SUCCESS ) {

        //
        // if the transaction has been started, then roll back to the
        // start point, so that we will not leave the database
        // inconsistence.
        //

        if( TransactBegin == TRUE ) {
            DWORD LocalError;

            LocalError = DhcpJetRollBack();
            DhcpAssert( LocalError == ERROR_SUCCESS );
        }

        DhcpPrint(( DEBUG_ERRORS, "Can't create client entry in the "
                    "database, %ld.\n", Error));

    }
    else {

        //
        // commit the transaction before we return.
        //

        DhcpAssert( TransactBegin == TRUE );

        if( TransactBegin == TRUE ) {

            DWORD LocalError;

            LocalError = DhcpJetCommitTransaction();
            DhcpAssert( LocalError == ERROR_SUCCESS );
        }
    }

    return( Error );
}


DWORD
FixBadEntries(
    PM_SUBNET Subnet,
    LPBITMAP_ENTRY BitMapList,
    DWORD BitMapListCount,
    LPDHCP_SCAN_LIST ScanList
    )
/*++

Routine Description:

    This functions goes through the bad entries list and fixes either
    the database or registry appropriately.

Arguments:

    SubnetAddress : Subnet address.

    BitMapList : list of clusters.

    BitMapListCount : count of clusters.

    ScanList : list of bad entries returned.

Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error;
    DWORD ReturnError = ERROR_SUCCESS;
    LPDHCP_SCAN_ITEM BadEntry;
    LPDHCP_SCAN_ITEM EndBadEntry;
    BOOL RegistryModified = FALSE;
    LPBITMAP_ENTRY NextBitMapCluster;
    LPBITMAP_ENTRY NewBitMapList = NULL;
    DWORD dwUnused;
    CHAR                *HardwareAddressBuffer = NULL;
    DWORD               nHardwareAddressBuffer = 0;


    DhcpAssert( BitMapList != NULL );
    DhcpAssert( ScanList != NULL );

    EndBadEntry =  ScanList->ScanItems + ScanList->NumScanItems;

    for( BadEntry = ScanList->ScanItems;
            BadEntry < EndBadEntry;
                BadEntry++ ) {

        //
        // For each registry fix mark the corresponding bit in the bit
        // map.
        //

        if( BadEntry->ScanFlag == DhcpRegistryFix ) {

            DHCP_IP_ADDRESS BadAddress;
            BOOL BitFound;

            //
            // scan bitmap and fix appropriate bitmap cluster.
            //

            BadAddress = BadEntry->IpAddress;
            BitFound = FALSE;

            // set the BadAddress bit into the memory bitmask (reconcile with the memory).
            // normally, Error should be ERROR_SUCCESS.
		    Error = DhcpSubnetRequestSpecificAddress(
                Subnet,
                BadAddress
            );

            // shouldn't happen..
            if (Error != ERROR_SUCCESS)
                continue;

            for( NextBitMapCluster = BitMapList;
                    NextBitMapCluster  < BitMapList + BitMapListCount;
                        NextBitMapCluster++ ) {

                DHCP_IP_ADDRESS ClusterAddress;

                ClusterAddress = NextBitMapCluster->ClusterAddress;

                //
                // is the bad address in this cluster.
                //

                if( (BadAddress >= ClusterAddress) &&
                        (BadAddress < (ClusterAddress + CLUSTER_SIZE)) ) {

                    DWORD Bit = 0x1 << (BadAddress - ClusterAddress);

                    DhcpAssert( (NextBitMapCluster->ClusterBitMap & Bit) == 0 );

                    NextBitMapCluster->ClusterBitMap |= Bit;
                    BitFound = TRUE;
                    break;
                }
            }

            if( !BitFound ) {

                //
                // if the bad address is not found in the existing
                // clusters, check to see this address is within any
                // one of the existing ranges, if so this bit must be
                // from one of the unused clusters. Create a new
                // cluster and add to list.
                //

                for( NextBitMapCluster = BitMapList;
                        NextBitMapCluster  < BitMapList + BitMapListCount;
                            NextBitMapCluster++ ) {

                    DHCP_IP_ADDRESS RangeStartAddress;
                    DHCP_IP_ADDRESS RangeEndAddress;

                    RangeStartAddress = NextBitMapCluster->RangeStartAddress;
                    RangeEndAddress = NextBitMapCluster->RangeEndAddress;

                    if( (BadAddress  >= RangeStartAddress) &&
                            (BadAddress <=RangeEndAddress ) ) {

                        DHCP_IP_ADDRESS ClusterAddress;
                        DWORD BitMap;
                        BITMAP_ENTRY BitMapCluster;

                        //
                        // Found a range that fits this address.
                        //

                        ClusterAddress = RangeStartAddress +
                            (BadAddress - RangeStartAddress) -
                                ((BadAddress - RangeStartAddress) %
                                    CLUSTER_SIZE);

                        BitMap =  0x1 << (BadAddress - ClusterAddress);

                        BitMapCluster.ClusterAddress = ClusterAddress;
                        BitMapCluster.ClusterBitMap = BitMap;
                        BitMapCluster.RangeStartAddress = RangeStartAddress;
                        BitMapCluster.RangeEndAddress = RangeEndAddress;

                        if( (BitMapListCount %
                                ALLOC_NUM_ENTRIES_AT_TIME) != 0 ) {

                            //
                            // we still have room left in the buffer, use it.
                            //

                            BitMapList[BitMapListCount] = BitMapCluster;
                            BitMapListCount++;
                        }
                        else {

                            //
                            // allocate new memory to fit
                            // ALLOC_NUM_ENTRIES_AT_TIME additional
                            // entries.
                            //

                            NewBitMapList =
                                DhcpAllocateMemory(
                                    sizeof(BITMAP_ENTRY) *
                                        (BitMapListCount +
                                         ALLOC_NUM_ENTRIES_AT_TIME) );

                            DhcpAssert( NewBitMapList != NULL );

                            if( NewBitMapList != NULL ) {

                                //
                                // copy old data.
                                //

                                memcpy( NewBitMapList,
                                        BitMapList,
                                        sizeof(BITMAP_ENTRY) *
                                            BitMapListCount );

                                //
                                // copy new pointer to old pointer.
                                // the caller will free up the old
                                // pointer, this function should
                                // freeup the new pointer at the end.
                                //

                                BitMapList = NewBitMapList;

                                //
                                // now copy new entry.
                                //

                                BitMapList[BitMapListCount] = BitMapCluster;
                                BitMapListCount++;
                            }
                        } // allocate more memory.

                        break; // we are done with this bad address.

                    } // range found.
                } // search ranges.
            } // !BitFound

            //
            // bit map should be written back in the registry.
            //

            RegistryModified = TRUE;
        }
        else if( BadEntry->ScanFlag == DhcpDatabaseFix ) {

            DHCP_IP_ADDRESS     IpAddress;
            WCHAR               MachineNameBuffer[DHCP_IP_KEY_LEN];
            LPWSTR              MachineName;
            DWORD               nClientHardwareAddress;
            ULONG               ClientUIDSize;
            LPBYTE              ClientUID;
            DATE_TIME           Lease;

            // get the IpAddress of this BadEntry
            IpAddress = BadEntry->IpAddress;

            // we don't know the machine's name, so we fake it to
            // the string representation of the IpAddress
            MachineName = DhcpRegIpAddressToKey(
                            IpAddress,
                            MachineNameBuffer );

            // find out if this is a reserved address, which case we will have the real hardware address
            Error = DhcpFindReservationByAddress(Subnet, IpAddress, &ClientUID, &ClientUIDSize);

            // find out the maximal size of the client's hardware address,
            // regardless it will be faked or not.

            nClientHardwareAddress = (Error == ERROR_SUCCESS) ? ClientUIDSize : DHCP_IP_KEY_LEN;

            // make sure there is enough space in HardwareAddressBuffer
            // for holding nClientHardwareAddress bytes

            if (nClientHardwareAddress > nHardwareAddressBuffer)
            {
                // need to grow the HardwareAddressBuffer
                if (HardwareAddressBuffer != NULL)
                    DhcpFreeMemory(HardwareAddressBuffer);

                // in order to avoid initial frequent reallocations, do not alloc less than DHCP_IP_KEY_LEN bytes
                nHardwareAddressBuffer = (nClientHardwareAddress > DHCP_IP_KEY_LEN) ?
                                          nClientHardwareAddress : DHCP_IP_KEY_LEN;

                HardwareAddressBuffer = DhcpAllocateMemory(nHardwareAddressBuffer);

                //*** handle here the allocation failure ***
                if (HardwareAddressBuffer == NULL)
                {
                    // as above, when buffer allocation fails, don't give up,
                    // skip to the next 'BadEntry'
                    nHardwareAddressBuffer = 0;
                    continue;
                }
            }

            // next, get the values for HardwareAddressBuffer, nClientHardwareAddress
            // and Lease variables
            if (Error == ERROR_SUCCESS)
            {
                // if the IpAddress is a reservation, then the lease = 0 Reserved(inactive)
                // and the HardwareAddress is copied from the registry
                Lease.dwLowDateTime = DHCP_DATE_TIME_ZERO_LOW;
                Lease.dwHighDateTime = DHCP_DATE_TIME_ZERO_HIGH;

                memcpy(HardwareAddressBuffer, ClientUID, nClientHardwareAddress);
            }
            else
            {
                // this is a regular IpAddress, so the lease is copied from the subnet options
                // and the Hardware address is faked to the binary encoding of the
                // IpAddress string representation
                DHCP_IP_ADDRESS         NetworkIpAddress;
                DHCP_REQUEST_CONTEXT    Ctxt;
                LPBYTE                  OptionData = NULL;
                DWORD                   OptionDataLength = 0;
                DWORD                   LeaseDuration;

                //
                // get lease duration.
                //
                Ctxt.Server = DhcpGetCurrentServer();
                Ctxt.Range = NULL;
                Ctxt.Reservation = NULL;
                Ctxt.Subnet = Subnet;
                Ctxt.ClassId = 0;

                Error =  DhcpGetParameter(
                            IpAddress,
                            &Ctxt,
                            OPTION_LEASE_TIME,
                            &OptionData,
          