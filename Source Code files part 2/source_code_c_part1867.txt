       liTotal = ClearTypePerformanceLoopA(hwnd , hdc);

           liBigTotal += liTotal;
           liDelta = (ULONG) ((liTotal * 1000) / liFreq);
           dprintf( "  Opaque Time[%d] : %d millisec",LoopCount,liDelta );

           /* antialiazed transparent: */
           SetBkMode( hdc, TRANSPARENT );
           elfdvA.elfEnumLogfontEx.elfLogFont.lfQuality =  jQuality;
           elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight = -MinEmHeight;

           liTotal = ClearTypePerformanceLoopA(hwnd , hdc);

           liBigTotal += liTotal;
           liDelta = (ULONG) ((liTotal * 1000) / liFreq);
           dprintf( "  Trsp Solid Time[%d] : %d millisec",LoopCount,liDelta );

           /* antialiazed transparent: */
           isGradientBackground = TRUE;
           elfdvA.elfEnumLogfontEx.elfLogFont.lfQuality =  jQuality;
           elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight = -MinEmHeight;

           liTotal = ClearTypePerformanceLoopA(hwnd , hdc);

           liBigTotal += liTotal;
           liDelta = (ULONG) ((liTotal * 1000) / liFreq);
           dprintf( "  Trsp Grad Time[%d] : %d millisec",LoopCount,liDelta );

       }
       else
       {
           SetBkMode( hdc, OPAQUE );

           isGradientBackground = FALSE;

           elfdvW.elfEnumLogfontEx.elfLogFont.lfQuality =  jQuality;
           elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight = -MinEmHeight;

           liTotal = ClearTypePerformanceLoopW(hwnd , hdc);

           liBigTotal += liTotal;
           liDelta = (ULONG) ((liTotal * 1000) / liFreq);
           dprintf( " Opaque Time[%d] : %d millisec",LoopCount,liDelta );

           SetBkMode( hdc, TRANSPARENT );
           elfdvW.elfEnumLogfontEx.elfLogFont.lfQuality =  jQuality;
           elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight = -MinEmHeight;

           liTotal = ClearTypePerformanceLoopW(hwnd , hdc);

           liBigTotal += liTotal;
           liDelta = (ULONG) ((liTotal * 1000) / liFreq);
           dprintf( " Trsp Solid Time[%d] : %d millisec",LoopCount,liDelta );

           isGradientBackground = TRUE;
           elfdvW.elfEnumLogfontEx.elfLogFont.lfQuality =  jQuality;
           elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight = -MinEmHeight;

           liTotal = ClearTypePerformanceLoopW(hwnd , hdc);

           liBigTotal += liTotal;
           liDelta = (ULONG) ((liTotal * 1000) / liFreq);
           dprintf( " Trsp Grad Time[%d] : %d millisec",LoopCount,liDelta );

       }

   if (!isCharCodingUnicode)
   {
       elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight = oldHeight;
       elfdvA.elfEnumLogfontEx.elfLogFont.lfQuality = oldQuality;
   }
   else
   {
       elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight = oldHeight;
       elfdvW.elfEnumLogfontEx.elfLogFont.lfQuality = oldQuality;
   }

   isGradientBackground = oldIsGradientBackground;
    liDelta = (ULONG) ((liBigTotal * 1000) / liFreq);
   dprintf( " TextOutPerformance :" );
   dprintf( " TotalTime : %d millisec",liDelta );

   dUpdateNow( TRUE );

//   DeleteTestIC( hdc );
   ReleaseDC(hwnd,hdc);

}


void ClearTypePerformance ( HWND hwnd )
{

  DWORD dwOldBatchLimit = GdiSetBatchLimit(1);

  dprintf( " Monochrome TextOutPerformance :" );
  ClearTypePerformanceInternal(hwnd, NONANTIALIASED_QUALITY );

  dprintf( " " );
  dprintf( " Antialiased TextOutPerformance :" );
  ClearTypePerformanceInternal(hwnd, ANTIALIASED_QUALITY );


  dprintf( " " );
  dprintf( " ClearType TextOutPerformance :" );
  ClearTypePerformanceInternal(hwnd, CLEARTYPE_QUALITY );

  GdiSetBatchLimit(dwOldBatchLimit);

}


#endif

//*****************************************************************************
//**************************   P R I N T   I T   ******************************
//*****************************************************************************

void PrintIt( HWND hwnd )
 {
  HDC     hdcPrinter;
  DOCINFO di;
  INT     iOldHeight, iOldWidth;
  LONG    yP, yS, xP, xS;

  hdcPrinter = CreatePrinterDC();

  if( lpfnStartDoc )
    {
     di.cbSize      = sizeof(DOCINFO);
     di.lpszDocName = "FontTest";
     di.lpszOutput  = NULL;
     di.lpszDatatype= NULL;
     di.fwType      = 0;

     dprintf( "Calling StartDoc" );
     dprintf( "  rc = %d", StartDoc( hdcPrinter, (LPDOCINFO)&di ) );
    }
   else
    {
     dprintf( "Sending STARTDOC" );
     Escape( hdcPrinter, STARTDOC, lstrlen("FontTest"), "FontTest", NULL );
    }

  if( lpfnStartPage )
    {
     dprintf( "Calling StartPage" );
     dprintf( "  rc = %d", StartPage( hdcPrinter ) );
    }

  // Height = -(PointSize * Number of pixels per logical inch along the device height)/72.
  // So the ratio of font heights on two devices is same as the ratio of the pixels
  // number per logical inch.

  if (!isCharCodingUnicode)  {
      iOldHeight = elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight;
      iOldWidth  = elfdvA.elfEnumLogfontEx.elfLogFont.lfWidth;
  }
  else {
      iOldHeight = elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight;
      iOldWidth  = elfdvW.elfEnumLogfontEx.elfLogFont.lfWidth;
  }

  yP = GetDeviceCaps(hdcPrinter, LOGPIXELSY);
  yS = GetDeviceCaps(GetDC(hwnd), LOGPIXELSY);

  xP = GetDeviceCaps(hdcPrinter, LOGPIXELSX);
  xS = GetDeviceCaps(GetDC(hwnd), LOGPIXELSX);

  if (!isCharCodingUnicode)  {
      elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight = MulDiv(iOldHeight,yP, yS);
      elfdvA.elfEnumLogfontEx.elfLogFont.lfWidth  = MulDiv(iOldWidth,xP, xS);
  }
  else {
      elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight = MulDiv(iOldHeight,yP, yS);
      elfdvW.elfEnumLogfontEx.elfLogFont.lfWidth  = MulDiv(iOldWidth,xP, xS);
  }

  SetDCMapMode( hdcPrinter, wMappingMode );

  SetTextColor( hdcPrinter, dwRGB );
  SetBkMode( hdcPrinter, TRANSPARENT );
  SetTextCharacterExtra( hdcPrinter, nCharExtra );
  SetTextJustification( hdcPrinter, nBreakExtra, nBreakCount );

  DrawDCAxis( NULL, hdcPrinter , TRUE);

  if(       hwndMode == hwndRings )
    DrawRings( NULL, hdcPrinter );
   else if( hwndMode == hwndString )
    DrawString( NULL, hdcPrinter );
   else if( hwndMode == hwndWaterfall )
    DrawWaterfall( NULL, hdcPrinter );
   else if( hwndMode == hwndWhirl )
    DrawWhirl( NULL, hdcPrinter );
   else if( hwndMode == hwndAnsiSet )
    DrawAnsiSet( NULL, hdcPrinter );
   else if( hwndMode == hwndGlyphSet )
    DrawGlyphSet( NULL, hdcPrinter );

//   else if( hwndMode == hwndWidths )
//    DrawWidths( NULL, hdcPrinter );
   else
    dprintf( "Can't print current mode" );

  if( lpfnEndPage )
    {
     dprintf( "Calling EndPage" );
     dprintf( "  rc = %d", EndPage( hdcPrinter ) );
    }
   else
    {
     dprintf( "Sending NEWFRAME" );
     Escape( hdcPrinter, NEWFRAME, 0, NULL, NULL );
    }

  if( lpfnEndDoc )
    {
     dprintf( "Calling EndDoc" );
     dprintf( "  rc = %d", EndDoc( hdcPrinter ) );
    }
   else
    {
     dprintf( "Sending ENDDOC" );
     dprintf( "  rc = %d", Escape( hdcPrinter, ENDDOC, 0, NULL, NULL ) );
    }

  // Restore the height for the screen dc

  if (!isCharCodingUnicode)  {
      elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight = iOldHeight;
      elfdvA.elfEnumLogfontEx.elfLogFont.lfWidth  = iOldWidth;
  }
  else {
      elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight = iOldHeight;
      elfdvW.elfEnumLogfontEx.elfLogFont.lfWidth  = iOldWidth;
  }

  dprintf( "Deleting Printer DC" );
  DeleteTestIC( hdcPrinter );
  dprintf( "Done printing!" );
 }



 void ChangeCharCoding( HWND hwnd, WPARAM wParam )
 {
  HMENU hMenu;


  hMenu = GetMenu( hwnd );
  CheckMenuItem( hMenu, wCharCoding, MF_UNCHECKED );
  CheckMenuItem( hMenu, (UINT)wParam,  MF_CHECKED );

  wCharCoding = (UINT)wParam;

  isCharCodingUnicode = (wCharCoding == IDM_CHARCODING_UNICODE)? TRUE : FALSE;

  if (!isCharCodingUnicode)
  {
    dprintf("Switching to ANSI/MBCS");
	EnableMenuItem(hMenu, 7, MF_BYPOSITION | MF_ENABLED);
	EnableMenuItem(hMenu, 8, MF_BYPOSITION | MF_GRAYED);
  }
  else
  {
    dprintf("Switching to Unicode");
	EnableMenuItem(hMenu, 7, MF_BYPOSITION | MF_GRAYED);
	EnableMenuItem(hMenu, 8, MF_BYPOSITION | MF_ENABLED);
  }
	  
}

//*****************************************************************************
//*******************   C H A N G E   M A P   M O D E   ***********************
//*****************************************************************************

void ChangeMapMode( HWND hwnd, WPARAM wParam )
 {
  HMENU hMenu;
  HDC   hdc;
  POINT ptl;


  hMenu = GetMenu( hwnd );
  CheckMenuItem( hMenu, wMappingMode, MF_UNCHECKED );
  CheckMenuItem( hMenu, (UINT)wParam,   MF_CHECKED );

  hdc = GetDC( hwnd );
  SetDCMapMode( hdc, wMappingMode );
  if (!isCharCodingUnicode)
  {
      ptl.x = elfdvA.elfEnumLogfontEx.elfLogFont.lfWidth;
      ptl.y = elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight;
  }
  else
  {
      ptl.x = elfdvW.elfEnumLogfontEx.elfLogFont.lfWidth;
      ptl.y = elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight;
  }

  LPtoDP( hdc, &ptl, 1 );

  wMappingMode = (UINT)wParam;
  SetDCMapMode( hdc, wMappingMode );

  DPtoLP( hdc, &ptl, 1 );

  ptl.x = abs(ptl.x);
  ptl.y = abs(ptl.y);

  if (!isCharCodingUnicode)
  {
      elfdvA.elfEnumLogfontEx.elfLogFont.lfWidth  =
          (elfdvA.elfEnumLogfontEx.elfLogFont.lfWidth  >= 0 ? ptl.x : -ptl.x);  // Preserve Sign
      elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight =
          (elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight >= 0 ? ptl.y : -ptl.y);
      SyncElfdvAtoW (&elfdvW, &elfdvA);
  }
  else
  {
      elfdvW.elfEnumLogfontEx.elfLogFont.lfWidth  =
          (elfdvW.elfEnumLogfontEx.elfLogFont.lfWidth  >= 0 ? ptl.x : -ptl.x);  // Preserve Sign
      elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight =
          (elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight >= 0 ? ptl.y : -ptl.y);
      SyncElfdvWtoA (&elfdvA, &elfdvW);
  }
  ReleaseDC( hwnd, hdc );
 }


//*****************************************************************************
//************************   G E T   S P A C I N G   **************************
//*****************************************************************************


LPINT GetSpacing( HDC hdc, LPVOID lpszString )
 {
  LPINT  lpdx;
  LPSTR  lpszStringA = lpszString;
  LPWSTR lpszStringW = lpszString;  // only one will be used depending on charcoding

  int   i,j;
  ABC   abc;
  DWORD cbString;
  DWORD dwCP = GetCodePage(hdc);

//-----------------------  Apply Requested Spacing  ---------------------------

  if( wSpacing == IDM_USEDEFAULTSPACING ) return NULL;

  if( wSpacing == IDM_PDX    ) return lpintdx;
  if( wSpacing == IDM_PDXPDY ) return lpintdx;

  if (!isCharCodingUnicode)
     cbString = lstrlenA(lpszStringA);
  else
     cbString = lstrlenW(lpszStringW);

  lpdx = (LPINT)aDx;

  switch( wSpacing )
  {
   case IDM_USEWIDTHSPACING:
          dprintf("iwc :   ch   : Width");
          break;

   case IDM_USEABCSPACING:
          dprintf("iwc  :   ch   :  A  :  B  :  C  : A+B+C");
          break;

   case IDM_PDX:
          dprintf("iwc  :   ch   :  dx ");
          break;

   case IDM_PDXPDY:
   case IDM_RANDOMPDXPDY:
          dprintf("iwc  :   ch   :  dx : dy ");
          break;
  }


  for( i = 0, j = 0; i < (INT)cbString; i++, j++)
  {
    UINT u;
	BOOL resultOK;
    BOOL bDBCS = FALSE;
    int  iWidth;
    int  iHeight = 0;

	if (!isCharCodingUnicode)
     if (bDBCS = IsDBCSLeadByteEx(dwCP, lpszStringA[i]))
     {
         u = (UINT)(BYTE)lpszStringA[i];
         u <<= 8;
         u |= (UINT)(BYTE)lpszStringA[i+1];
     }
     else
     {
         u = (UINT)(BYTE)lpszStringA[i];
     }
	else
		 u = (UINT) lpszStringW[i];

     switch( wSpacing )
     {
      case IDM_USEWIDTHSPACING:

			 if (!isCharCodingUnicode)
				 GetCharWidthA( hdc, u, u, &iWidth);
			 else
				 GetCharWidthW( hdc, u, u, &iWidth);

             if (bDBCS)
             {
               aDx[i++] = 0;
             }
             aDx[i] = iWidth;
             dprintf("%2ld  : 0x%4lx : 0x%lx == %ld", j, u, iWidth, iWidth);
             break;

      case IDM_USEABCSPACING:
             abc.abcA = abc.abcB = abc.abcC = 0;
			 if (!isCharCodingUnicode)
				resultOK = GetCharABCWidthsA( hdc, u, u, &abc );
			 else
				resultOK = GetCharABCWidthsW( hdc, u, u, &abc );

             if ( resultOK )
               iWidth = abc.abcA + (int)abc.abcB + abc.abcC;
             else
			   if (!isCharCodingUnicode)
			      GetCharWidthA( hdc, u, u, &iWidth);
			   else
			      GetCharWidthW( hdc, u, u, &iWidth);

             if (bDBCS)
             {
               aDx[i++] = 0;
             }

             aDx[i] = iWidth;
             dprintf("%ld : 0x%lx : 0x%lx : 0x%lx  : 0x%lx : 0x%lx ",
                        j,     u,  abc.abcA, abc.abcB, abc.abcC, iWidth);
             break;

      case IDM_RANDOMPDXPDY:
			 if (!isCharCodingUnicode)
				 GetCharWidthA( hdc, u, u, &iWidth);
			 else
				 GetCharWidthW( hdc, u, u, &iWidth);

             if (wETO & ETO_PDY)
                iHeight = rand() % 10 - 5; // more or less random number in range (-5,5)

             if (bDBCS)
             {
               aDx[2*i] = 0;
               aDx[2*i + 1] = 0;
               i++;
             }

             aDx[2*i] = iWidth;
             aDx[2*i + 1] = iHeight;
             dprintf("%ld : 0x%lx : 0x%lx : 0x%lx", j, u, iWidth, iHeight);

             break;
     }

  }

//---------------------------  Apply Kerning  ---------------------------------

  if( wKerning == IDM_APIKERNING )
    {
     int           nPairs;
     LPKERNINGPAIR lpkp;

//     dprintf( "GetKerningPairs kerning" );

     nPairs = GetKerningPairs( hdc, 0, NULL );

     if( nPairs > 0 )
      {
       lpkp = (LPKERNINGPAIR)calloc( 1, nPairs * sizeof(KERNINGPAIR) );
       if (!isCharCodingUnicode)
          GetKerningPairsA( hdc, nPairs, lpkp );
       else
          GetKerningPairsW( hdc, nPairs, lpkp );

       for( i = 0; i < (INT)cbString-1; i++ )
        {
         int  j;
         UINT f, s;

         if (!isCharCodingUnicode)
         {
             f = (UINT)(BYTE)lpszStringA[i];
             s = (UINT)(BYTE)lpszStringA[i+1];
         }
         else
         {
             f = (UINT)lpszStringW[i];
             s = (UINT)lpszStringW[i+1];
         }

         for( j = 0; j < nPairs; j++ )
          {
           if( f == lpkp[j].wFirst  &&
               s == lpkp[j].wSecond    )
            {
//             dprintf( "  %c%c == %c%c = %d", lpkp[j].wFirst, lpkp[j].wSecond, lpszString[i], lpszString[i+1], lpkp[j].iKernAmount );

             aDx[i] += lpkp[j].iKernAmount;
             break;
            }
          }
        }

       if( lpkp ) free( lpkp );
      }
    }
   else if( wKerning == IDM_ESCAPEKERNING )
    {
     WORD          wSize;
     int           wrc;
     EXTTEXTMETRIC etm;
     LPKERNPAIR    lpkp;


//     dprintf( "Escape kerning" );


     memset( &etm, 0, sizeof(etm) );
     wSize = sizeof(etm);
//     dprintf( "Calling Escape for EXTTEXTMETRIC" );
     wrc = ExtEscape( hdc, GETEXTENDEDTEXTMETRICS, 0, NULL, sizeof(EXTTEXTMETRIC), (BYTE *)&etm);
//   wrc = Escape( hdc, GETEXTENDEDTEXTMETRICS, sizeof(WORD), (LPCSTR)&wSize, &etm );
//     dprintf( "  wrc = %d", wrc );

     if( etm.etmKernPairs > 0 )
      {
       wSize = etm.etmKernPairs * sizeof(KERNPAIR);
       lpkp = (LPKERNPAIR)calloc( 1, wSize );

//       dprintf( "Calling ExtEscape for GETPAIRKERNTABLE" );
       wrc = ExtEscape( hdc, GETPAIRKERNTABLE, 0, NULL, wSize, (BYTE *)lpkp );
//       dprintf( "  wrc = %u", wrc );

       for( i = 0; i < (INT)cbString-1; i++ )
        {
         int  j;
         WORD wPair;

         wPair = (WORD)lpszStringA[i] + ((WORD)lpszStringA[i+1] << 8);

         for( j = 0; j < etm.etmKernPairs; j++ )
          {
           if( wPair == lpkp[j].wBoth )
            {
//             dprintf( "  %c%c == %c%c = %d", lpkp[j].wBoth & 0x00FF, lpkp[j].wBoth >> 8, lpszString[i], lpszString[i+1], lpkp[j].sAmount);

             aDx[i] += lpkp[j].sAmount;
             break;
            }
          }
        }

       if( lpkp ) free( lpkp );
      }
    }

  return lpdx;
 }

//*****************************************************************************
//********************   M Y   E X T   T E X T   O U T   **********************
//*****************************************************************************



void MyExtTextOut( HDC hdc, int x, int y, DWORD wFlags, LPRECT lpRect, LPVOID lpszString, int cbString, LPINT lpdx )
{
  int  i, iStart;
  LPSTR lpszStringA  = lpszString;
  LPWSTR lpszStringW = lpszString;
  DWORD  wFlags2;


  if ( lpRect || (wFlags & ETO_GLYPH_INDEX) || (lpdx && (wFlags & ETO_PDY)))
    wFlags2 = wFlags;
  else
    wFlags2 = 0;

  if (bGTEExt)
    doGetTextExtentEx(hdc,x,y,lpszString, cbString);

  if (bGCP)
  {
    doGCP(hdc, x, y, lpszString, cbString);
  }
  else
  {
    if(lpdx && !wUpdateCP )
    {
        GenExtTextOut( hdc, x, y, wFlags2, lpRect, lpszString, cbString, lpdx );
    }
    else if (wUpdateCP)
    {
      SetTextAlign( hdc, wTextAlign | TA_UPDATECP );
      MoveToEx( hdc, x, y ,0);

      iStart = 0;
      for( i = 1; i < cbString+1; i++ )
      {
        BOOL isTerm;
        if (!isCharCodingUnicode)
            isTerm = (lpszStringA[i] == ' ' || lpszStringA[i] == '\0');
        else
            isTerm = (lpszStringW[i] == L' ' || lpszStringW[i] == L'\0');

        if( isTerm )
        {
          if (!isCharCodingUnicode)
              GenExtTextOut( hdc, x, y, wFlags2, lpRect, &lpszStringA[iStart], i-iStart, (lpdx ? &lpdx[iStart] : NULL) );
          else
              GenExtTextOut( hdc, x, y, wFlags2, lpRect, &lpszStringW[iStart], i-iStart, (lpdx ? &lpdx[iStart] : NULL) );
          iStart = i;
        }
      }
    }
    else
    {
        GenExtTextOut( hdc, x, y, wFlags2, lpRect, lpszString, cbString, NULL);
    }
  }
}


//*****************************************************************************
//*********************   S H O W   L O G   F O N T   *************************
//*****************************************************************************

void ShowLogFont( void )
 {
  dprintf( "  LOGFONT:" );
  dprintf( "    lfFaceName       = '%s'",  elfdvA.elfEnumLogfontEx.elfLogFont.lfFaceName       );
  dprintf( "    lfHeight         = %d",    elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight         );
  dprintf( "    lfWidth          = %d",    elfdvA.elfEnumLogfontEx.elfLogFont.lfWidth          );
  dprintf( "    lfEscapement     = %d",    elfdvA.elfEnumLogfontEx.elfLogFont.lfEscapement     );
  dprintf( "    lfOrientation    = %d",    elfdvA.elfEnumLogfontEx.elfLogFont.lfOrientation    );
  dprintf( "    lfWeight         = %d",    elfdvA.elfEnumLogfontEx.elfLogFont.lfWeight         );
  dprintf( "    lfItalic         = %d",    elfdvA.elfEnumLogfontEx.elfLogFont.lfItalic         );
  dprintf( "    lfUnderline      = %d",    elfdvA.elfEnumLogfontEx.elfLogFont.lfUnderline      );
  dprintf( "    lfStrikeOut      = %d",    elfdvA.elfEnumLogfontEx.elfLogFont.lfStrikeOut      );
  dprintf( "    lfCharSet        = %d",    elfdvA.elfEnumLogfontEx.elfLogFont.lfCharSet        );
  dprintf( "    lfOutPrecision   = %d",    elfdvA.elfEnumLogfontEx.elfLogFont.lfOutPrecision   );
  dprintf( "    lfClipPrecision  = %d",    elfdvA.elfEnumLogfontEx.elfLogFont.lfClipPrecision  );
  dprintf( "    lfQuality        = %d",    elfdvA.elfEnumLogfontEx.elfLogFont.lfQuality        );
  dprintf( "    lfPitchAndFamily = 0x%.2X",elfdvA.elfEnumLogfontEx.elfLogFont.lfPitchAndFamily );
 }


//*****************************************************************************
//***********************   R E S I Z E   P R O C   ***************************
//*****************************************************************************

int cxMain, cyMain;
int cxMode, cyMode;
int cxDebug, cyDebug;


void ResizeProc( HWND hwnd )
 {
  HDC   hdc;
  RECT  rcl, rclMain;
  POINT ptl;

  MSG   msg;



  SetCapture( hwnd );                            // Capture All Mouse Messages
  SetCursor( LoadCursor( NULL, IDC_SIZEWE ) );

  hdc = GetDC( hwnd );

  GetClientRect( hwndMain, &rclMain );
  GetClientRect( hwndMode, &rcl );

  rcl.left   = rcl.right;
  rcl.right += cxBorder;

  DrawFocusRect( hdc, &rcl );

  do
   {
    while( !PeekMessage( &msg, hwnd, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE ) );

    if( msg.message == WM_MOUSEMOVE )
     {
      GetCursorPos( &ptl );
      ScreenToClient( hwnd, &ptl );
      DrawFocusRect( hdc, &rcl );

      if( ptl.x < 3*cxBorder                 ) ptl.x = 3*cxBorder;
      if( ptl.x > rclMain.right - 3*cxBorder ) ptl.x = rclMain.right - 3*cxBorder;

      //SetCursorPos( &ptl );

      rcl.left  = ptl.x;
      rcl.right = rcl.left + cxBorder;

      DrawFocusRect( hdc, &rcl );
     }
   } while( msg.message != WM_LBUTTONUP );

  DrawFocusRect( hdc, &rcl );
  ReleaseDC( hwnd, hdc );
  ReleaseCapture();                              // Let Go of Mouse


  MoveWindow( hwndGlyph,     0, 0, rcl.left, rclMain.bottom, FALSE );
  MoveWindow( hwndRings,     0, 0, rcl.left, rclMain.bottom, FALSE );
  MoveWindow( hwndString,    0, 0, rcl.left, rclMain.bottom, FALSE );
  MoveWindow( hwndWaterfall, 0, 0, rcl.left, rclMain.bottom, FALSE );
  MoveWindow( hwndWhirl,     0, 0, rcl.left, rclMain.bottom, FALSE );
  MoveWindow( hwndAnsiSet,   0, 0, rcl.left, rclMain.bottom, FALSE );
  MoveWindow( hwndGlyphSet,  0, 0, rcl.left, rclMain.bottom, FALSE );
  MoveWindow( hwndWidths,    0, 0, rcl.left, rclMain.bottom, FALSE );

  cxMain  = rclMain.right;
  cyMain  = rclMain.bottom;
  cxMode  = rcl.left;
  cyMode  = rclMain.bottom;
  cxDebug = rclMain.right-rcl.right;
  cyDebug = rclMain.bottom;

  InvalidateRect( hwndMode, NULL, TRUE );
  InvalidateRect( hwndMain, &rcl, TRUE );

  MoveWindow( hwndDebug, rcl.right, 0, rclMain.right-rcl.right, rclMain.bottom, TRUE );
 }


//*****************************************************************************
//***********************   S E L E C T   M O D E   ***************************
//*****************************************************************************

void SelectMode( HWND hwnd, WPARAM wParam )
 {
  UINT  i;
  HMENU hMenu;


  hMenu = GetMenu( hwnd );

  // Check if requested mode is disabled, force to String Mode if so

  if( GetMenuState( hMenu, (UINT)wParam, MF_BYCOMMAND ) & MF_GRAYED ) wParam = IDM_STRINGMODE;
  wMode = (UINT)wParam;

  for( i = IDM_GLYPHMODE; i <= IDM_WIDTHSMODE; i++ )
   {
    CheckMenuItem( hMenu, i, MF_UNCHECKED );
   }


  CheckMenuItem( hMenu, wMode, MF_CHECKED );

  ShowWindow( hwndGlyph,     SW_HIDE );
  ShowWindow( hwndRings,     SW_HIDE );
  ShowWindow( hwndString,    SW_HIDE );
  ShowWindow( hwndWaterfall, SW_HIDE );
  ShowWindow( hwndWhirl,     SW_HIDE );
  ShowWindow( hwndAnsiSet,   SW_HIDE );
  ShowWindow( hwndGlyphSet,  SW_HIDE );
  ShowWindow( hwndWidths,    SW_HIDE );

  switch( LOWORD(wParam) )
   {
    case IDM_GLYPHMODE:
    case IDM_BEZIERMODE:
    case IDM_NATIVEMODE:    hwndMode = hwndGlyph;     break;
    case IDM_RINGSMODE:     hwndMode = hwndRings;     break;
    case IDM_STRINGMODE:    hwndMode = hwndString;    break;
    case IDM_WATERFALLMODE: hwndMode = hwndWaterfall; break;
    case IDM_WHIRLMODE:     hwndMode = hwndWhirl;     break;
    case IDM_ANSISETMODE:   hwndMode = hwndAnsiSet;   break;
    case IDM_GLYPHSETMODE:  hwndMode = hwndGlyphSet;  break;
    case IDM_WIDTHSMODE:    hwndMode = hwndWidths;    break;
   }

  if( wParam == IDM_GLYPHMODE )
    EnableMenuItem( hMenu, IDM_WRITEGLYPH, MF_ENABLED );
   else
    EnableMenuItem( hMenu, IDM_WRITEGLYPH, MF_GRAYED );


  ShowWindow( hwndMode, SW_SHOWNORMAL );
 }


//*****************************************************************************
//**********   G E T   P R I V A T E   P R O F I L E   D W O R D   ************
//*****************************************************************************

DWORD GetPrivateProfileDWORD( LPSTR lpszApp, LPSTR lpszKey, DWORD dwDefault, LPSTR lpszINI )
 {
  char szText[16];


  wsprintf( szText, "0x%.8lX", dwDefault );
  GetPrivateProfileString( lpszApp, lpszKey, szText, szText, sizeof(szText), lpszINI );

  return (DWORD)strtoul( szText, NULL, 16 );
 }


//*****************************************************************************
//*********   W R I T E   P R I V A T E   P R O F I L E   D W O R D   *********
//*****************************************************************************

void WritePrivateProfileDWORD( LPSTR lpszApp, LPSTR lpszKey, DWORD dw, LPSTR lpszINI )
 {
  char szText[16];

  wsprintf( szText, "0x%.8lX", dw );
  WritePrivateProfileString( lpszApp, lpszKey, szText, lpszINI );
 }


//*****************************************************************************
//**********   W R I T E   P R I V A T E   P R O F I L E   I N T   ************
//*****************************************************************************

void WritePrivateProfileInt( LPSTR lpszApp, LPSTR lpszKey, int i, LPSTR lpszINI )
 {
  char szText[16];

  wsprintf( szText, "%d", i );
  WritePrivateProfileString( lpszApp, lpszKey, szText, lpszINI );
 }


//*****************************************************************************
//******************   X   G E T   P R O C   A D D R E S S   ******************
//*****************************************************************************

FARPROC XGetProcAddress( LPSTR lpszModule, LPSTR lpszProc )
 {
  return GetProcAddress( GetModuleHandle(lpszModule), lpszProc );
 }


//*****************************************************************************
//*******************   V E R S I O N   S P E C I F I C S   *******************
//*****************************************************************************

void VersionSpecifics( HWND hwnd )
 {
  HMENU hMenu;



  *(FARPROC*)& lpfnCreateScalableFontResource = XGetProcAddress( "GDI32", "CreateScalableFontResourceA" );
  *(FARPROC*)& lpfnEnumFontFamilies           = XGetProcAddress( "GDI32", "EnumFontFamiliesA"           );
  *(FARPROC*)& lpfnEnumFontFamiliesEx         = XGetProcAddress( "GDI32", "EnumFontFamiliesExA"         );
  *(FARPROC*)& lpfnGetCharABCWidthsA          = XGetProcAddress( "GDI32", "GetCharABCWidthsA"           );
  *(FARPROC*)& lpfnGetFontData                = XGetProcAddress( "GDI32", "GetFontData"                 );
  *(FARPROC*)& lpfnGetGlyphOutlineA           = XGetProcAddress( "GDI32", "GetGlyphOutlineA"            );

  *(FARPROC*)& lpfnGetOutlineTextMetricsA     = XGetProcAddress( "GDI32", "GetOutlineTextMetricsA"      );
  *(FARPROC*)& lpfnGetRasterizerCaps          = XGetProcAddress( "GDI32", "GetRasterizerCaps"           );

// UNICODE
  *(FARPROC*)& lpfnGetCharABCWidthsW          = XGetProcAddress( "GDI32", "GetCharABCWidthsW"           );
  *(FARPROC*)& lpfnGetGlyphOutlineW           = XGetProcAddress( "GDI32", "GetGlyphOutlineW"            );
  *(FARPROC*)& lpfnGetOutlineTextMetricsW     = XGetProcAddress( "GDI32", "GetOutlineTextMetricsW"      );
// END UNICODE

  *(FARPROC*)& lpfnStartDoc  = XGetProcAddress( "GDI32", "StartDocA" );
  *(FARPROC*)& lpfnStartPage = XGetProcAddress( "GDI32", "StartPage" );
  *(FARPROC*)& lpfnEndPage   = XGetProcAddress( "GDI32", "EndPage"   );
  *(FARPROC*)& lpfnEndDoc    = XGetProcAddress( "GDI32", "EndDoc"    );
  *(FARPROC*)& lpfnAbortDoc  = XGetProcAddress( "GDI32", "AbortDoc"  );


//  dprintf( "lpfnCreateScalableFontResource = 0x%.8lX", lpfnCreateScalableFontResource );
//  dprintf( "lpfnEnumFontFamilies           = 0x%.8lX", lpfnEnumFontFamilies           );
//  dprintf( "lpfnGetCharABCWidths           = 0x%.8lX", lpfnGetCharABCWidths           );
//  dprintf( "lpfnGetFontData                = 0x%.8lX", lpfnGetFontData                );
//  dprintf( "lpfnGetGlyphOutline            = 0x%.8lX", lpfnGetGlyphOutline            );
//  dprintf( "lpfnGetOutlineTextMetrics      = 0x%.8lX", lpfnGetOutlineTextMetrics      );
//  dprintf( "lpfnGetRasterizerCaps          = 0x%.8lX", lpfnGetRasterizerCaps          );



  hMenu = GetMenu( hwnd );

  if( !lpfnCreateScalableFontResource ) EnableMenuItem( hMenu, IDM_CREATESCALABLEFONTRESOURCE, MF_GRAYED );
  if( !lpfnEnumFontFamilies           ) EnableMenuItem( hMenu, IDM_ENUMFONTFAMILIES,           MF_GRAYED );
  if( !lpfnEnumFontFamiliesEx         ) EnableMenuItem( hMenu, IDM_ENUMFONTFAMILIESEX,         MF_GRAYED );
  if( !lpfnGetCharABCWidthsA ||
      !lpfnGetCharABCWidthsA          ) EnableMenuItem( hMenu, IDM_GLYPHMODE,                  MF_GRAYED );
  if( !lpfnGetFontData                ) EnableMenuItem( hMenu, IDM_GETFONTDATA,                MF_GRAYED );
  if( !lpfnGetGlyphOutlineA ||
      !lpfnGetGlyphOutlineW           )
   {
    EnableMenuItem( hMenu, IDM_GLYPHMODE, MF_GRAYED );
    EnableMenuItem( hMenu, IDM_NATIVEMODE, MF_GRAYED );
    EnableMenuItem( hMenu, IDM_BEZIERMODE, MF_GRAYED );
   }
  if( !lpfnGetOutlineTextMetricsA ||
      !lpfnGetOutlineTextMetricsW     ) EnableMenuItem( hMenu, IDM_GETOUTLINETEXTMETRICS, MF_GRAYED );
  if( !lpfnGetRasterizerCaps          ) EnableMenuItem( hMenu, IDM_GETRASTERIZERCAPS,     MF_GRAYED );

 }


//*****************************************************************************
//************   M M   A N I S O T R O P I C   D L G   P R O C   **************
//*****************************************************************************

INT_PTR CALLBACK MMAnisotropicDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
 {
  switch( msg )
   {
    case WM_INITDIALOG:
              SetDlgItemInt( hdlg, IDD_XWE, xWE, TRUE );
              SetDlgItemInt( hdlg, IDD_YWE, yWE, TRUE );
              SetDlgItemInt( hdlg, IDD_XWO, xWO, TRUE );
              SetDlgItemInt( hdlg, IDD_YWO, yWO, TRUE );

              SetDlgItemInt( hdlg, IDD_XVE, xVE, TRUE );
              SetDlgItemInt( hdlg, IDD_YVE, yVE, TRUE );
              SetDlgItemInt( hdlg, IDD_XVO, xVO, TRUE );
              SetDlgItemInt( hdlg, IDD_YVO, yVO, TRUE );

              return TRUE;


    case WM_COMMAND:
              switch( LOWORD(wParam) )
               {
                case IDOK:
                       xWE = (int)GetDlgItemInt( hdlg, IDD_XWE, NULL, TRUE );
                       yWE = (int)GetDlgItemInt( hdlg, IDD_YWE, NULL, TRUE );
                       xWO = (int)GetDlgItemInt( hdlg, IDD_XWO, NULL, TRUE );
                       yWO = (int)GetDlgItemInt( hdlg, IDD_YWO, NULL, TRUE );

                       xVE = (int)GetDlgItemInt( hdlg, IDD_XVE, NULL, TRUE );
                       yVE = (int)GetDlgItemInt( hdlg, IDD_YVE, NULL, TRUE );
                       xVO = (int)GetDlgItemInt( hdlg, IDD_XVO, NULL, TRUE );
                       yVO = (int)GetDlgItemInt( hdlg, IDD_YVO, NULL, TRUE );

                       EndDialog( hdlg, TRUE );
                       return TRUE;

                case IDCANCEL:
                       EndDialog( hdlg, FALSE );
                       return TRUE;
               }

              break;


    case WM_CLOSE:
              EndDialog( hdlg, FALSE );
              return TRUE;

   }

  return FALSE;
 }


//*****************************************************************************
//******************   G E T   D L G   I T E M   D W O R D   ******************
//*****************************************************************************

DWORD GetDlgItemDWORD( HWND hdlg, int id )
 {
  static char szDWORD[16];


  szDWORD[0] = '\0';
  GetDlgItemText( hdlg, id, szDWORD, sizeof(szDWORD) );

  return (DWORD)atol( szDWORD );
 }

//*****************************************************************************
//******************   G E T   D L G   I T E M   D W O R D   ******************
//*****************************************************************************

ULONG_PTR GetDlgItemULONG_PTR( HWND hdlg, int id )
 {
  static char szULONG_PTR[32];


  szULONG_PTR[0] = '\0';
  GetDlgItemText( hdlg, id, szULONG_PTR, sizeof(szULONG_PTR) );

  return (ULONG_PTR)atol( szULONG_PTR );
 }


//*****************************************************************************
//******************   S E T   D L G   I T E M   D W O R D   ******************
//*****************************************************************************

void SetDlgItemDWORD( HWND hdlg, int id, DWORD dw )
 {
  static char szDWORD[16];

  szDWORD[0] = '\0';
  wsprintf( szDWORD, "%lu", dw );
  SetDlgItemText( hdlg, id, szDWORD );
 }


//*****************************************************************************
//*******************   S E T   D L G   I T E M   L O N G   *******************
//*****************************************************************************

void SetDlgItemLONG( HWND hdlg, int id, LONG l )
 {
  static char szLONG[16];

  szLONG[0] = '\0';
  wsprintf( szLONG, "%ld", l );
  SetDlgItemText( hdlg, id, szLONG );
 }


//*****************************************************************************
//******************   D O   G E T   F O N T   D A T A   **********************
//*****************************************************************************

#define BUFFER_SIZE  4096

typedef BYTE *HPBYTE;

void DoGetFontData( char szTable[], DWORD dwOffset, DWORD cbData, DWORD dwSize, PSTR pszFile )
 {
  HDC    hdc;
  HFONT  hFont, hFontOld;

  HANDLE hData;
  HPBYTE hpData;
  DWORD  dwrc;
  DWORD  dwTable;


  hData  = NULL;
  hpData = NULL;

  hdc = CreateTestIC();

  hFont    = CreateFontIndirectWrapperA( &elfdvA );
  hFontOld = SelectObject( hdc, hFont );

  if( dwSize )
   {
    hData  = GlobalAlloc( GHND, dwSize );
    hpData = (HPBYTE)GlobalLock( hData );
   }

//  dwTable = ( ((DWORD)(szTable[0]) <<  0) +
//              ((DWORD)(szTable[1]) <<  8) +
//              ((DWORD)(szTable[2]) << 16) +
//              ((DWORD)(szTable[3]) << 24)   );


  dwTable = *(LPDWORD)szTable;

  if(!strcmp(szTable,"0"))
  {
  // get the whole file
      dwTable = 0;
  }


  dprintf( "Calling GetFontData" );
  dprintf( "  dwTable  = 0x%.8lX (%s)", dwTable, szTable  );
  dprintf( "  dwOffset = %lu",     dwOffset );
  dprintf( "  lpData   = 0x%.8lX", hpData   );
  dprintf( "  cbData   = %ld",     cbData   );
  dprintf( "  hBuf     = 0x%.4X",  hData    );
  dprintf( "  dwBuf    = %ld",     dwSize   );

  dwrc = lpfnGetFontData( hdc, dwTable, dwOffset, hpData, cbData );

  dprintf( "  dwrc = %ld", dwrc );

  SelectObject( hdc, hFontOld );
  DeleteObject( hFont );
  DeleteTestIC( hdc );

  if( dwrc && lstrlen(pszFile) > 0 )
   {
    int    fh;
    WORD   wCount;
    DWORD  dw;
    LPBYTE lpb;


    lpb = (LPBYTE)calloc( 1, BUFFER_SIZE );

    fh = _lcreat( pszFile, 0 );

    wCount = 0;
    for( dw = 0; dw < dwrc; dw++ )
     {
      lpb[wCount++] = hpData[dw];

      if( wCount == BUFFER_SIZE )
       {
        dprintf( "  Writing %u bytes", wCount );
        _lwrite( fh, lpb, wCount );
        wCount = 0;
       }
     }

    if( wCount > 0 )
     {
      dprintf( "  Writing %u bytes", wCount );
      _lwrite( fh, lpb, wCount );
     }

    _lclose( fh );
    free( lpb );
   }


  if( hData )
   {
    GlobalUnlock( hData );
    GlobalFree( hData );
   }
 }


//*****************************************************************************
//*************   G E T   F O N T   D A T A   D L G   P R O C   ***************
//*****************************************************************************

INT_PTR CALLBACK GetFontDataDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
 {
  static DWORD dwOffset;
  static DWORD dwChunk;
  static DWORD dwSize;
  static char  szTable[5];
  static char  szFile[260];


  switch( msg )
   {
    case WM_INITDIALOG:
              SetDlgItemText( hdlg, IDD_DWTABLE, szTable );
              SendDlgItemMessage( hdlg, IDD_DWTABLE, EM_LIMITTEXT, sizeof(szTable)-1, 0 );

              SetDlgItemDWORD( hdlg, IDD_DWOFFSET, dwOffset );
              SetDlgItemLONG(  hdlg, IDD_DWCHUNK,  (LONG)dwChunk );
              SetDlgItemDWORD( hdlg, IDD_DWSIZE,   dwSize );

              SetDlgItemText( hdlg, IDD_LPSZFILE, szFile );
              SendDlgItemMessage( hdlg, IDD_LPSZFILE, EM_LIMITTEXT, sizeof(szFile)-1, 0 );

              return TRUE;


    case WM_COMMAND:
              switch( LOWORD(wParam) )
               {
                case IDOK:
                       szTable[0] = '\0';
                       szTable[1] = '\0';
                       szTable[2] = '\0';
                       szTable[3] = '\0';
                       szTable[4] = '\0';
                       GetDlgItemText( hdlg, IDD_DWTABLE, szTable, sizeof(szTable) );

                       dwOffset = GetDlgItemDWORD( hdlg, IDD_DWOFFSET );
                       dwChunk  = GetDlgItemDWORD( hdlg, IDD_DWCHUNK );
                       dwSize   = GetDlgItemDWORD( hdlg, IDD_DWSIZE );

                       szFile[0] = 0;
                       GetDlgItemText( hdlg, IDD_LPSZFILE, szFile, sizeof(szFile) );

                       DoGetFontData( szTable, dwOffset, dwChunk, dwSize, szFile );

                       EndDialog( hdlg, TRUE );
                       return TRUE;

                case IDCANCEL:
                       EndDialog( hdlg, FALSE );
                       return TRUE;
               }

              break;


    case WM_CLOSE:
              EndDialog( hdlg, FALSE );
              return TRUE;

   }

  return FALSE;
 }


//*****************************************************************************
//******   C R E A T E   S C A L A B L E    F O N T    D L G   P R O C   ******
//*****************************************************************************

INT_PTR CALLBACK CreateScalableFontDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
 {
  int    rc;
  LPSTR  lpszResourceFile, lpszFontFile, lpszCurrentPath;

  static UINT fHidden;
  static DWORD temp;
  static char szResourceFile[260];
  static char szFontFile[260];
  static char szCurrentPath[260];


  switch( msg )
   {
    case WM_INITDIALOG:
              SetDlgItemInt( hdlg, IDD_FHIDDEN, fHidden, FALSE );
              SetDlgItemText( hdlg, IDD_LPSZRESOURCEFILE, szResourceFile );
              SetDlgItemText( hdlg, IDD_LPSZFONTFILE,     szFontFile     );
              SetDlgItemText( hdlg, IDD_LPSZCURRENTPATH,  szCurrentPath  );

              SendDlgItemMessage( hdlg, IDD_LPSZRESOURCEFILE, EM_LIMITTEXT, sizeof(szResourceFile), 0);
              SendDlgItemMessage( hdlg, IDD_LPSZFONTFILE,     EM_LIMITTEXT, sizeof(szFontFile),     0);
              SendDlgItemMessage( hdlg, IDD_LPSZCURRENTPATH,  EM_LIMITTEXT, sizeof(szCurrentPath),  0);

              return TRUE;


    case WM_COMMAND:
              switch( LOWORD( wParam ) )
               {
                case IDOK:
                       szResourceFile[0] = 0;
                       szFontFile[0]     = 0;
                       szCurrentPath[0]  = 0;
                       // need ia64 cleanup :

                       temp = (UINT)GetDlgItemInt( hdlg, IDD_FHIDDEN, NULL, FALSE );

                       fHidden = (UINT)temp;

                       GetDlgItemText( hdlg, IDD_LPSZRESOURCEFILE, szResourceFile, sizeof(szResourceFile) );
                       GetDlgItemText( hdlg, IDD_LPSZFONTFILE,     szFontFile,     sizeof(szFontFile)     );
                       GetDlgItemText( hdlg, IDD_LPSZCURRENTPATH,  szCurrentPath,  sizeof(szCurrentPath)  );

                       dprintf( "Calling CreateScalableFontResource" );

                       lpszResourceFile = (lstrlen(szResourceFile) ? szResourceFile : NULL);
                       lpszFontFile     = (lstrlen(szFontFile)     ? szFontFile     : NULL);
                       lpszCurrentPath  = (lstrlen(szCurrentPath)  ? szCurrentPath  : NULL);

                       rc = lpfnCreateScalableFontResource( fHidden, lpszResourceFile, lpszFontFile, lpszCurrentPath );

                       dprintf( "  rc = %d", rc );

                       EndDialog( hdlg, TRUE );
                       return TRUE;

                case IDCANCEL:
                       EndDialog( hdlg, FALSE );
                       return TRUE;
               }

              break;


    case WM_CLOSE:
              EndDialog( hdlg, FALSE );
              return TRUE;

   }

  return FALSE;
 }


#ifdef USERGETWVTPERF

typedef LONG (*LPWINVERIFYTRUST) (HWND, GUID *, LPVOID);


//**********************************************************************************
//**********   W V T   F O N T   E V A L U A T I O N    D L G   P R O C   **********
//**********************************************************************************

ULONG AuthenticFontSignature_MemPtr(BYTE *pbFile, ULONG cbFile, GUID *pguid, BOOL fFileCheck)
{
    GUID                    gV2 = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    WINTRUST_DATA           sWTD;
    WINTRUST_BLOB_INFO      sWTBI;
    HANDLE                  hDll;
    LPWINVERIFYTRUST        lpWinVerifyTrust = NULL;
    ULONG                   fl;
    
    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
    memset(&sWTBI, 0x00, sizeof(WINTRUST_BLOB_INFO));

    sWTD.cbStruct       = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice     = WTD_UI_NONE;
    sWTD.dwUnionChoice  = WTD_CHOICE_BLOB;
    sWTD.pBlob          = &sWTBI;
    sWTBI.cbStruct      = sizeof(WINTRUST_BLOB_INFO);
    sWTBI.gSubject      = *pguid;
    sWTBI.cbMemObject   = cbFile;
    sWTBI.pbMemObject   = pbFile;

//    hDll = LoadLibrary("wintrust");
    fl = 0;
    
//    if(hDll)
//    {
//        lpWinVerifyTrust = (LPWINVERIFYTRUST) GetProcAddress(hDll, "WinVerifyTrustEx");
//        if(lpWinVerifyTrust)
//        {
            if (WinVerifyTrust((HWND) 10, &gV2, &sWTD) == ERROR_SUCCESS)
            {
//               dprintf((" We have succeed to do it\n"));
                 fl = TRUE;
            }
            else
            {
//               dprintf((" Oh, no it failed\n"));
            }
//        }                        
//        FreeLibrary(hDll);
//     }

     return fl;
}


ULONG AuthenticFontSignature_FileHandle(HANDLE hFile, GUID *pguid, BOOL fFileCheck)
{
    GUID                    gV2 = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    WINTRUST_DATA           sWTD;
    WINTRUST_FILE_INFO      sWTFI;
    HANDLE                  hDll;
    LPWINVERIFYTRUST        lpWinVerifyTrust = NULL;
    ULONG                   fl;
    
    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
    memset(&sWTFI, 0x00, sizeof(WINTRUST_FILE_INFO));

    sWTD.cbStruct       = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice     = WTD_UI_NONE;
    sWTD.dwUnionChoice  = WTD_CHOICE_FILE;
    sWTD.pFile          = &sWTFI;
    sWTFI.cbStruct      = sizeof(WINTRUST_FILE_INFO);
    sWTFI.hFile         = hFile;
    sWTFI.pcwszFilePath = NULL;
    sWTFI.pgKnownSubject = pguid;

//    hDll = LoadLibrary("wintrust");
    fl = 0;
    
//    if(hDll)
//    {
//        lpWinVerifyTrust = (LPWINVERIFYTRUST) GetProcAddress(hDll, "WinVerifyTrustEx");
//        if(lpWinVerifyTrust)
//        {
            if (WinVerifyTrust((HWND) 10, &gV2, &sWTD) == ERROR_SUCCESS)
            {
//               dprintf((" We have succeed to do it\n"));
                 fl = TRUE;
            }
            else
            {
//               dprintf((" Oh, no it failed\n"));
            }
//        }                        
//        FreeLibrary(hDll);
//     }

     return fl;
}


ULONG AuthenticFontSignature_FilePath(LPWSTR pwszPathFileName, GUID *pguid, BOOL fFileCheck)
{
    GUID                    gV2 = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    WINTRUST_DATA           sWTD;
    WINTRUST_FILE_INFO      sWTFI;
    HANDLE                  hDll;
    LPWINVERIFYTRUST        lpWinVerifyTrust = NULL;
    ULONG                   fl;
    
    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
    memset(&sWTFI, 0x00, sizeof(WINTRUST_FILE_INFO));

    sWTD.cbStruct       = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice     = WTD_UI_NONE;
    sWTD.dwUnionChoice  = WTD_CHOICE_FILE;
    sWTD.pFile          = &sWTFI;
    sWTFI.cbStruct      = sizeof(WINTRUST_FILE_INFO);
    sWTFI.hFile         = INVALID_HANDLE_VALUE;
    sWTFI.pcwszFilePath = pwszPathFileName;
    sWTFI.pgKnownSubject = pguid;

//    hDll = LoadLibrary("wintrust");
    fl = 0;
    
//    if(hDll)
//    {
//        lpWinVerifyTrust = (LPWINVERIFYTRUST) GetProcAddress(hDll, "WinVerifyTrustEx");
//        if(lpWinVerifyTrust)
//        {
            if (WinVerifyTrust((HWND) 10, &gV2, &sWTD) == ERROR_SUCCESS)
            {
//               dprintf((" We have succeed to do it\n"));
                 fl = TRUE;
            }
            else
            {
//               dprintf((" Oh, no it failed\n"));
            }
//        }                        
//        FreeLibrary(hDll);
//     }

     return fl;
}

ULONG HashFile_MemPtr (HCRYPTPROV hProv, BYTE *pbFile, ULONG cbFile)
{

    HCRYPTHASH hHash;
    BYTE *pbHash = NULL;
    ULONG cbHash = 16;
    ALG_ID alg_id = CALG_MD5;

    // Set hHashTopLevel to be the hash object.
    if (!CryptCreateHash(hProv, alg_id, 0, 0, &hHash)) {
        dprintf ("Error during CryptCreateHash.\n");
        goto done;
    }

    // Allocate memory for the hash value.
    if ((pbHash = (BYTE *) malloc (cbHash)) == NULL) {
        dprintf ("Error in malloc.\n");
        goto done;
    }

    //// Pump the bytes of the new file into the hash function
    if (!CryptHashData (hHash, pbFile, cbFile, 0)) {
        dprintf ("Error during CryptHashData.\n");
        goto done;
    }
		
    //// Compute the top-level hash value, and place the resulting
    //// hash value into pbHashTopLevel.
    if (!CryptGetHashParam(hHash, HP_HASHVAL, pbHash, &cbHash, 0)) {
        dprintf ("Error during CryptGetHashParam (hash value)\n");
        goto done;
    }

done:
    if (pbHash) {
        free (pbHash);
    }

    return TRUE;
}




// WVT Performance tests
#define PERF_CRYPTHASHDATA_ONLY 0
#define PERF_WVT_ONLY           1
#define PERF_EVERYTHING         2

INT_PTR CALLBACK GetWVTPerfDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
 {
  int    rc = 0;
  ULONG  i;
  LPSTR  lpszFile = NULL;
  WCHAR  wPathFileName[260];
  BOOL   fFileHandle;
  BOOL   fFilePath;
  HANDLE hFile = NULL;
  HANDLE hMapFile = NULL;
  BYTE   *pbFile = NULL;
  ULONG  cbFile = 0;

  BOOL   fFileCheck;
  GUID   gFont = CRYPT_SUBJTYPE_FONT_IMAGE;
  GUID   guid;
  GUID *ptheguid = NULL;

  HCRYPTPROV hProv = 0;
  HMODULE hdll = NULL;
  ULONG  ulPerfTest;
  ULONG  ulIterations;

  _int64 liStart;
  _int64 liNow;
  _int64 liFreq;
  ULONG  liDelta;
  
  static char szFile[260];
  switch( msg )
   {
    case WM_INITDIALOG:
              SetDlgItemText( hdlg, IDD_LPSZFILE, szFile );
              SendDlgItemMessage( hdlg, IDD_LPSZFILE, EM_LIMITTEXT, sizeof(szFile), 0);

              // turn on the Memory Pointer radio button
              CheckRadioButton(hdlg, IDC_WVT_FILE_PATH, IDC_WVT_MEM_PTR, IDC_WVT_MEM_PTR);

              // turn on the Memory Pointer radio button
              CheckRadioButton(hdlg, IDC_CRYPTHASHDATA_ONLY, IDC_EVERYTHING, IDC_EVERYTHING);

              // turn on the Font Hint radio button
              CheckDlgButton(hdlg, IDC_FONT_HINT, 1);

              // default number of iterations is 1              
              SetDlgItemInt ( hdlg, IDC_WVT_ITERATIONS, 1, TRUE);

              gTime = 0;
              SetTimer(hdlg, 0, 1000, (TIMERPROC) Mytimer);
                
              return TRUE;


    case WM_COMMAND:
              switch( LOWORD( wParam ) )
               {
                case IDOK:
                       
                       szFile[0] = 0;

                       GetDlgItemText( hdlg, IDD_LPSZFILE, szFile, sizeof(szFile) );

                       dprintf( "Evaluate TT in WVT's performance" );

                       lpszFile = (lstrlen(szFile) ? szFile : NULL);

dprintf ("lpszFile: '%s'", lpszFile);

                       MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, lpszFile, -1,
                                           wPathFileName, 260);

                       fFileHandle = (IsDlgButtonChecked(hdlg, IDC_WVT_FILE_HANDLE) ? TRUE : FALSE);
                       fFilePath = (IsDlgButtonChecked(hdlg, IDC_WVT_FILE_PATH) ? TRUE : FALSE);

                       if (IsDlgButtonChecked (hdlg, IDC_CRYPTHASHDATA_ONLY)) {
                           ulPerfTest = PERF_CRYPTHASHDATA_ONLY;
                       } else if (IsDlgButtonChecked (hdlg, IDC_WVT_ONLY)) {
                           ulPerfTest = PERF_WVT_ONLY;
                       } else if (IsDlgButtonChecked (hdlg, IDC_EVERYTHING)) {
                           ulPerfTest = PERF_EVERYTHING;
                       }

                       if (IsDlgButtonChecked(hdlg, IDC_FONT_HINT)) {
                           guid = gFont;
                           fFileCheck = FALSE;
                       } else 
                           fFileCheck = TRUE;

                       ulIterations = GetDlgItemInt(hdlg, IDC_WVT_ITERATIONS, NULL, TRUE);

dprintf ("fFileHandle: %d", fFileHandle);
dprintf ("fFilePath : %d", fFilePath);
dprintf ("fFileCheck: %d", fFileCheck);
dprintf ("ulPerfTest: %d", ulPerfTest);
dprintf ("wPathFileName: '%S'", wPathFileName);
dprintf ("ulIterations: %d", ulIterations);

                       if ((hdll = LoadLibraryA ("mssipotf")) == NULL) {
                           dprintf ("LoadLibraryA(mssipotf) failed.");
                       }

                       if (!fFilePath && !fFileHandle && (ulPerfTest != PERF_CRYPTHASHDATA_ONLY)) {

                           if (fFileCheck) {
                               dprintf ("Bad combination of options.");
                               break;
                           }
                           dprintf ("Mapping file and verifying ...");
                           if (ulPerfTest == PERF_EVERYTHING) {
                               QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
                           }
                           for(i = 0; i < ulIterations; i++) {
                               // convert file path name into a file handle
                               if ((hFile = CreateFile (lpszFile,
                                                        GENERIC_READ,
                                                        0,
                                                        NULL,
                                                        OPEN_EXISTING,
                                                        0,
                                                        NULL)) == INVALID_HANDLE_VALUE) {
                                   dprintf ("Error in CreateFile.");
                                   goto done;
                               }
                                                        
                               // map the file into memory before calling WVT
                               if ((hMapFile = CreateFileMapping (hFile,
                                                        NULL,
                                                        PAGE_READONLY,
                                                        0,
                                                        0,
                                                        NULL)) == NULL) {
                                   dprintf ("Error in CreateFileMapping.");
                                   goto done;
                               }
                               if ((pbFile = (BYTE *) MapViewOfFile (hMapFile,
                                                                    FILE_MAP_READ,
                                                                    0,
                                                                    0,
                                                                    0)) == NULL) {
                                   dprintf ("Error in MapViewOfFile.");
                                   goto done;
                               }
                               if ((cbFile = GetFileSize (hFile, NULL)) == 0xFFFFFFFF) {
                                   dprintf ("Error in GetFileSize.");
                                   goto done;
                               }

                               if (ulPerfTest == PERF_WVT_ONLY) {  
                                   QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
                               }
                               rc = AuthenticFontSignature_MemPtr (pbFile, cbFile, &guid, fFileCheck);

                               if (rc == 0)
                               {
                                   dprintf( "  AuthenticFontSignature_MemPtr failed");
                                   dprintf( "  rc = %d", rc );
                               }

                               if (ulPerfTest == PERF_WVT_ONLY) {
                                   QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
                                   QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);
                               }

                               // unmap the file
                               if (hMapFile) {
// dprintf ("Unmapping file (1) ...");
                                   CloseHandle (hMapFile);
                               }
                               if (pbFile) {
// dprintf ("Unmapping file (2) ...");
                                   UnmapViewOfFile (pbFile);
                               }
                               if (hFile) {
// dprintf ("Unmapping file (3) ...");
                                   CloseHandle (hFile);
                               }

                           }
                           if (ulPerfTest == PERF_EVERYTHING) {
                               QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
                               QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);
                           }

                       } else if (fFileHandle) {

dprintf ("Creating and using file handle to verify ...");

                           if (fFileCheck) {
                               ptheguid = NULL;
                           } else {
                               ptheguid = &guid;
                           }
                           if (ulPerfTest == PERF_EVERYTHING) {
                               QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
                           }
                           for(i = 0; i < ulIterations; i++) {
                               // convert file path name into a file handle
                               if ((hFile = CreateFile (lpszFile,
                                                        GENERIC_READ,
                                                        0,
                                                        NULL,
                                                        OPEN_EXISTING,
                                                        0,
                                                        NULL)) == INVALID_HANDLE_VALUE) {
                                   dprintf ("Error in CreateFile.");
                                   goto done;
                               }
                               if (ulPerfTest == PERF_WVT_ONLY) {
                                   QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
                               }
                               rc = AuthenticFontSignature_FileHandle (hFile, ptheguid, fFileCheck);
                               if (rc == 0)
                               {
                                   dprintf( "  AuthenticFontSignature_FileHandle failed");
                                   dprintf( "  rc = %d", rc );
                               }
                               if (ulPerfTest == PERF_WVT_ONLY) {
                                   QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
                                   QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);
                               }

                               if (hFile) {
                                   CloseHandle (hFile);
                               }    
                           }
                           if (ulPerfTest == PERF_EVERYTHING) {
                               QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
                               QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);
                           }

                       } else if (fFilePath) {

dprintf ("Using file pathname to verify ...");

                           if (fFileCheck) {
                               ptheguid = NULL;
                           } else {
                               ptheguid = &guid;
                           }
                           if ((ulPerfTest == PERF_EVERYTHING) ||
                               (ulPerfTest == PERF_WVT_ONLY)) {
                               QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
                           }
                           for(i = 0; i < ulIterations; i++) 
                               rc = AuthenticFontSignature_FilePath (wPathFileName, ptheguid, fFileCheck);

                              if (rc == 0)
                               {
                                   dprintf( "  AuthenticFontSignature_FilePath failed");
                                   dprintf( "  rc = %d", rc );
                               }
                           if ((ulPerfTest == PERF_EVERYTHING) ||
                               (ulPerfTest == PERF_WVT_ONLY)) {
                               QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
                               QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);
                           }
                       } else {

                           // ASSERT: ulPerfTest == 0

dprintf ("Performing CryptHashData only on the file ...\n");

                           // convert file path name into a file handle
                           if ((hFile = CreateFile (lpszFile,
                                 GENERIC_READ,
                                 0,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL)) == INVALID_HANDLE_VALUE) {
                               printf ("Error in CreateFile.\n");
                               goto done;
                           }
                            
                           // map the file into memory before calling WVT
                           if ((hMapFile = CreateFileMapping (hFile,
                                 NULL,
                                 PAGE_READONLY,
                                 0,
                                 0,
                                 NULL)) == NULL) {
                               printf ("Error in CreateFileMapping.\n");
                               goto done;
                           } 
                           if ((pbFile = (BYTE *) MapViewOfFile (hMapFile,
                                              FILE_MAP_READ,
                                              0,
                                              0,
                                              0)) == NULL) {
                               printf ("Error in MapViewOfFile.\n");
                               goto done;
                           }
                           if ((cbFile = GetFileSize (hFile, NULL)) == 0xFFFFFFFF) {
                               printf ("Error in GetFileSize.\n");
                               goto done;
                           }
#if DBG
dprintf ("pbFile = %d\n", pbFile);
dprintf ("cbFile = %d\n", cbFile);
#endif

                           // Set hProv to point to a cryptographic context of the default CSP.
                           if (!CryptAcquireContext (&hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
                               printf ("Error during CryptAcquireContext.  ");
                               printf ("last error = %x.\n", GetLastError ());
                               goto done;
                           }

                           QueryPerformanceCounter((LARGE_INTEGER *) &liStart);

                           for(i = 0; i < ulIterations; i++) {
                               rc = HashFile_MemPtr (hProv, pbFile, cbFile);
                              if (rc == 0)
                               {
                                   dprintf( "  HashFile_MemPtr failed");
                                   dprintf( "  rc = %d", rc );
                               }
                           }

                           QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
                           QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);

                           if (hProv) {
                               CryptReleaseContext(hProv, 0);
                           }

                           // unmap the file
                           if (hMapFile) {
#if DBG
dprintf ("Unmapping file (1) ...\n");
#endif
                               CloseHandle (hMapFile);
                           }
                           if (pbFile) {
#if DBG
dprintf ("Unmapping file (2) ...\n");
#endif
                               UnmapViewOfFile (pbFile);
                           }
                           if (hFile) {
#if DBG
dprintf ("Unmapping file (3) ...\n");
#endif
                               CloseHandle (hFile);
                           }
                       }

done:                       

                       dprintf( "  rc = %d", rc );
                       if( rc )
                       {
                           	liNow = liNow - liStart;
                        	liDelta = (ULONG) ((liNow * 1000) / liFreq);
                            dprintf( "  Time is %d milliseconds", liDelta );
                       }
                       else
                       {
                           dprintf((" Failed to get WVT performance"));
                       }

                       if (hdll) {
                           FreeLibrary (hdll);
                       }
                       EndDialog( hdlg, TRUE );
                       return TRUE;

                case IDCANCEL:
                       EndDialog( hdlg, FALSE );
                       return TRUE;

                case IDC_WVT_FILE_PATH:
                case IDC_WVT_FILE_HANDLE:
                case IDC_WVT_MEM_PTR:
                       CheckRadioButton (hdlg,
                           IDC_WVT_FILE_PATH, IDC_WVT_MEM_PTR, LOWORD(wParam));
                       return TRUE;                       
                case IDC_CRYPTHASHDATA_ONLY:
                case IDC_WVT_ONLY:
                case IDC_EVERYTHING:
                       CheckRadioButton (hdlg,
                           IDC_CRYPTHASHDATA_ONLY, IDC_EVERYTHING, LOWORD(wParam));
                       return TRUE;
               }

              break;
              

    case WM_CLOSE:

              KillTimer(hdlg, 0);
              
              EndDialog( hdlg, FALSE );
              return TRUE;

   }

  return FALSE;
 }
#endif


//*****************************************************************************
//**********   A D D   F O N T   R E S O U R C E   D L G   P R O C   **********
//*****************************************************************************

INT_PTR CALLBACK AddFontResourceDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
 {
  int    rc;
  LPSTR  lpszFile;

  static char szFile[260];


  switch( msg )
   {
    case WM_INITDIALOG:
              SetDlgItemText( hdlg, IDD_LPSZFILE, szFile );
              SendDlgItemMessage( hdlg, IDD_LPSZFILE, EM_LIMITTEXT, sizeof(szFile), 0);

              return TRUE;


    case WM_COMMAND:
              switch( LOWORD( wParam ) )
               {
                case IDOK:
                       szFile[0] = 0;

                       GetDlgItemText( hdlg, IDD_LPSZFILE, szFile, sizeof(szFile) );

                       dprintf( "Calling AddFontResource" );

                       lpszFile = (lstrlen(szFile) ? szFile : NULL);

                       rc = AddFontResource( lpszFile );

                       dprintf( "  rc = %d", rc );

                       EndDialog( hdlg, TRUE );
                       return TRUE;

                case IDCANCEL:
                       EndDialog( hdlg, FALSE );
                       return TRUE;
               }

              break;


    case WM_CLOSE:
              EndDialog( hdlg, FALSE );
              return TRUE;

   }

  return FALSE;
 }


//*****************************************************************************
//**********   A D D   F O N T   R E S O U R C E E X   D L G   P R O C   ******
//*****************************************************************************

INT_PTR CALLBACK AddFontResourceExDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
 {
#ifdef GI_API
  int    rc;
  LPSTR  lpszFile;
  DWORD  fl;
  INT_PTR result;

  static char szFile[260];
  DESIGNVECTOR dvMMInfo;

  switch( msg )
   {
    case WM_INITDIALOG:
              SetDlgItemText( hdlg, IDD_LPSZFILE, szFile );
              SendDlgItemMessage( hdlg, IDD_LPSZFILE, EM_LIMITTEXT, sizeof(szFile), 0);

              return TRUE;


    case WM_COMMAND:
              switch( LOWORD( wParam ) )
               {
                case IDOK:
                       szFile[0] = 0;

                       // read the check buttons and the font filename
                       GetDlgItemText( hdlg, IDD_LPSZFILE, szFile, sizeof(szFile) );
                       fl = IsDlgButtonChecked( hdlg, IDD_PRIVATE) ? FR_PRIVATE : 0;
                       fl |= IsDlgButtonChecked( hdlg, IDD_NOTENUM) ? FR_NOT_ENUM : 0;

                      // read the axes information
                      if (!fReadDesignVector(hdlg, (LPDESIGNVECTOR) &dvMMInfo))
                                               {
                                                   ShowDialogBox( AddFontResourceExDlgProc, IDB_ADDFONTRESOURCEEX, NULL);
                                                       return FALSE;
                                               }

                       dprintf( "Calling AddFontResourceEx" );

                       lpszFile = (lstrlen(szFile) ? szFile : NULL);

                       rc = AddFontResourceEx( lpszFile, fl, NULL);
                       dprintf( "  rc = %d", rc);

                       EndDialog( hdlg, TRUE );
                       return TRUE;

                case IDCANCEL:
                       EndDialog( hdlg, FALSE );
                       return TRUE;
               }

              break;


    case WM_CLOSE:
              EndDialog( hdlg, FALSE );
              return TRUE;

   }

#endif

  return FALSE;
 }



//*****************************************************************************
//******   R E M O V E   F O N T   R E S O U R C E   D L G   P R O C   ********
//*****************************************************************************

INT_PTR CALLBACK RemoveFontResourceDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
 {
  int    rc;
  LPSTR  lpszFile;

  static char szFile[260];


  switch( msg )
   {
    case WM_INITDIALOG:
              SetDlgItemText( hdlg, IDD_LPSZFILE, szFile );
              SendDlgItemMessage( hdlg, IDD_LPSZFILE, EM_LIMITTEXT, sizeof(szFile), 0);

              return TRUE;


    case WM_COMMAND:
              switch( LOWORD( wParam ) )
               {
                case IDOK:
                       szFile[0] = 0;

                       GetDlgItemText( hdlg, IDD_LPSZFILE, szFile, sizeof(szFile) );

                       dprintf( "Calling RemoveFontResource" );

                       lpszFile = (lstrlen(szFile) ? szFile : NULL);

                       rc = RemoveFontResource( lpszFile );

                       dprintf( "  rc = %d", rc );

                       EndDialog( hdlg, TRUE );
                       return TRUE;

                case IDCANCEL:
                       EndDialog( hdlg, FALSE );
                       return TRUE;
               }

              break;


    case WM_CLOSE:
              EndDialog( hdlg, FALSE );
              return TRUE;

   }

  return FALSE;
 }


//*****************************************************************************
//******   R E M O V E   F O N T   R E S O U R C E E X   D L G   P R O C   ****
//*****************************************************************************

INT_PTR CALLBACK RemoveFontResourceExDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
 {
#ifdef GI_API

  int    rc;
  LPSTR  lpszFile;
  DWORD  fl;

  static char szFile[260];
  DESIGNVECTOR dvMMInfo;

  switch( msg )
   {
    case WM_INITDIALOG:
              SetDlgItemText( hdlg, IDD_LPSZFILE, szFile );
              SendDlgItemMessage( hdlg, IDD_LPSZFILE, EM_LIMITTEXT, sizeof(szFile), 0);

              return TRUE;


    case WM_COMMAND:
              switch( LOWORD( wParam ) )
               {
                case IDOK:
                       szFile[0] = 0;

                       // read filename and the check buttons.
                       GetDlgItemText( hdlg, IDD_LPSZFILE, szFile, sizeof(szFile) );
                       fl = IsDlgButtonChecked( hdlg, IDD_PRIVATE) ? FR_PRIVATE : 0;
                       fl |= IsDlgButtonChecked( hdlg, IDD_NOTENUM) ? FR_NOT_ENUM : 0;

                       // read the axes information
                       if (!fReadDesignVector(hdlg, (LPDESIGNVECTOR) &dvMMInfo))
                       {
                           ShowDialogBox( RemoveFontResourceExDlgProc, IDB_REMOVEFONTRESOURCEEX, NULL);
                               return FALSE;
                       }

                       dprintf( "Calling RemoveFontResourceEx" );

                       lpszFile = (lstrlen(szFile) ? szFile : NULL);

                       rc = RemoveFontResourceEx( lpszFile, fl, NULL);

                       dprintf( "  rc = %d", rc );

                       EndDialog( hdlg, TRUE );
                       return TRUE;

                case IDCANCEL:
                       EndDialog( hdlg, FALSE );
                       return TRUE;
               }

              break;


    case WM_CLOSE:
              EndDialog( hdlg, FALSE );
              return TRUE;

   }

#endif

  return FALSE;
 }


//**********************************************************************
//****   ADD   F O N T   MEM R E S O U R C E E X   DLG P R O C   *******
//**********************************************************************

INT_PTR CALLBACK AddFontMemResourceExDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
#ifdef GI_API
  HANDLE    hMMFont;
  ULONG     cFonts;
  LPSTR  lpszFile;
  HANDLE  hFile, hFileMapping;
  DWORD   lastError;

  static char szFile[260];
  DESIGNVECTOR dvMMInfo;

  switch( msg )
   {
    case WM_INITDIALOG:
              SetDlgItemText( hdlg, IDD_LPSZFILE, szFile );
              SendDlgItemMessage( hdlg, IDD_LPSZFILE, EM_LIMITTEXT, sizeof(szFile), 0);

              return TRUE;


    case WM_COMMAND:
              switch( LOWORD( wParam ) )
              {
                  case IDOK:
                      szFile[0] = 0;

                      // read the check buttons and the font filename
                      GetDlgItemText( hdlg, IDD_LPSZFILE, szFile, sizeof(szFile) );

                      dprintf( "Calling AddFontMemResourceEx" );

                      lpszFile = (lstrlen(szFile) ? szFile : NULL);

                      // read the axes information
                      if (!fReadDesignVector(hdlg, (LPDESIGNVECTOR) &dvMMInfo))
                      {
                          ShowDialogBox( AddFontResourceExDlgProc, IDB_ADDFONTRESOURCEEX, NULL);
                          return FALSE;
                      }

                      if (lpszFile)
                      {
                          hFile = CreateFile(lpszFile, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

                          if (hFile != INVALID_HANDLE_VALUE)
                          {
                              DWORD   cjSize;
                              PVOID   pFontFile;

                              cjSize = GetFileSize(hFile, NULL);

                              if (cjSize == -1)
                              {
                                  dprintf("GetFileSize() failed\n");
                                  return TRUE;
                              }

                              hFileMapping = CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, "mappingobject");

                              if (hFileMapping)
                              {
                                  pFontFile = MapViewOfFile(hFileMapping, FILE_MAP_READ, 0, 0, 0);

                                  if(pFontFile)
                                  {
                                      hMMFont = AddFontMemResourceEx(pFontFile, cjSize, NULL, &cFonts);
                                      dprintf("hMMFont = %ld  cFonts = %ld\n", hMMFont, cFonts);

                                      UnmapViewOfFile(pFontFile);
                                  }
                                  else
                                  {
                                      dprintf("MapViewOfFile() failed\n");
                                  }
                                  CloseHandle(hFileMapping);
                              }
                              else
                              {
                                  dprintf("CreateFileMapping() failed\n");
                              }
                              CloseHandle(hFile);
                          }
                      }

                      EndDialog( hdlg, TRUE );

                      if (hMMFont)
                          return TRUE;
                      else
                          return FALSE;
                  case IDCANCEL:
                      EndDialog( hdlg, FALSE );
                      return TRUE;
              }
              break;

    case WM_CLOSE:
              EndDialog( hdlg, FALSE );
              return TRUE;

   }

#endif

  return FALSE;
}


//********************************************************************
//****   REMOVE   F O N T   MEM R E S O U R C E E X   P R O C   ******
//********************************************************************

INT_PTR CALLBACK RemoveFontMemResourceExDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
#ifdef GI_API

    HANDLE  hMMFont;
    BOOL    bRet;

    switch( msg )
    {
        case WM_INITDIALOG:
            return TRUE;


        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {
                case IDOK:
                    dprintf("Calling RemoveFontMemResourceEx()\n");
                    hMMFont = (HANDLE)GetDlgItemULONG_PTR(hdlg, IDD_HMMFONT );

                    bRet = RemoveFontMemResourceEx(hMMFont);
                    dprintf("bRet = %d\n", bRet);

                    EndDialog( hdlg, TRUE );
                    return TRUE;

                case IDCANCEL:
                    EndDialog( hdlg, FALSE );
                    return TRUE;
            }

            break;

        case WM_CLOSE:
            EndDialog( hdlg, FALSE );
            return TRUE;
    }

#endif  // GI_API

    return FALSE;
}


//*****************************************************************************
//*********************   U S E   S T O C K   F O N T   ***********************
//*****************************************************************************

void UseStockFont( WORD w )
 {
  int   nIndex, nCount;
  HFONT hFont;


  switch( w )
   {
    case IDM_ANSIFIXEDFONT:     nIndex = ANSI_FIXED_FONT;     break;
    case IDM_ANSIVARFONT:       nIndex = ANSI_VAR_FONT;       break;
    case IDM_DEVICEDEFAULTFONT: nIndex = DEVICE_DEFAULT_FONT; break;
    case IDM_OEMFIXEDFONT:      nIndex = OEM_FIXED_FONT;      break;
    case IDM_SYSTEMFONT:        nIndex = SYSTEM_FONT;         break;
    case IDM_SYSTEMFIXEDFONT:   nIndex = SYSTEM_FIXED_FONT;   break;
    case IDM_DEFAULTGUIFONT:    nIndex = DEFAULT_GUI_FONT;    break;
    default:                    nIndex = SYSTEM_FIXED_FONT;   break;
   }

  dprintf( "GetStockObject( %d )", nIndex );
  hFont = GetStockObject(nIndex);
  dprintf( "  hFont = 0x%.4X", hFont );

//  dprintf( "GetObject for size" );
//  nCount = GetObject( hFont, 0, NULL );
//  dprintf( "  nCount = %d", nCount );

  dprintf( "GetObject" );
  nCount = GetObject( hFont, sizeof(elfdvA.elfEnumLogfontEx.elfLogFont), (LPSTR)&elfdvA.elfEnumLogfontEx.elfLogFont );
  dprintf( "  nCount = %d", nCount );
 }


//*****************************************************************************
//*********************   M A I N   W N D   P R O C   *************************
//*****************************************************************************

char szINIFile[128];

LRESULT CALLBACK MainWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
 {
  HMENU hMenu;
  UINT  wtMode;
  int i;

  static OPENFILENAME ofn;
  static char         szNewLog[256];
  static LPSTR        lpszFilter = "Log Files\0*.LOG\0\0";

  CHOOSEFONTA cf;
  CHOOSEFONTW cfW;

  HMODULE hMod;
/* flag used for ChooseFontExA, ChooseFontExW and ChooseFontX : */
   
#define CHF_DESIGNVECTOR  0x0001

  FARPROC lpfnChooseFont, lpfnChooseFontEx;

  int len;
  WCHAR lfFaceNameW[LF_FACESIZE];

  switch( msg )
   {
    case WM_CREATE:
           lstrcpy( elfdvA.elfEnumLogfontEx.elfLogFont.lfFaceName, "Arial" );
           elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight = 10;

           pdlg.lStructSize = sizeof(pdlg);
           pdlg.hwndOwner   = hwnd;
           pdlg.hDevMode    = NULL;
           pdlg.hDevNames   = NULL;
           pdlg.Flags       = PD_RETURNDEFAULT;

           PrintDlg( &pdlg );


           dwRGBBackground = RGB( 255,   0, 255 );


           szINIFile[0] = '\0';                     // Compose INI File Name
           _getcwd( szINIFile, sizeof(szINIFile) );
           strcat( szINIFile, "\\FONTTEST.INI" );


           lstrcpy( szLogFile, "FONTTEST.LOG" );

           wMode           = (UINT)GetPrivateProfileInt( "Options", "Program Mode", IDM_STRINGMODE,        szINIFile );
           wTextAlign      = (WORD)GetPrivateProfileInt( "Options", "TextAlign",    TA_BOTTOM | TA_LEFT,   szINIFile );
           iBkMode         = (WORD)GetPrivateProfileInt( "Options", "BkMode",       OPAQUE,                szINIFile );
           wETO           = (DWORD)GetPrivateProfileInt( "Options", "ETO Options",  0,                     szINIFile );
           wSpacing        = (UINT)GetPrivateProfileInt( "Options", "Spacing",      IDM_USEDEFAULTSPACING, szINIFile );
           wKerning        = (UINT)GetPrivateProfileInt( "Options", "Kerning",      IDM_NOKERNING,         szINIFile );
           wUpdateCP       = (WORD)GetPrivateProfileInt( "Options", "UpdateCP",     FALSE,                 szINIFile );
           wUsePrinterDC   = (WORD)GetPrivateProfileInt( "Options", "UsePrinterDC", FALSE,             szINIFile );

           wCharCoding     = (UINT)GetPrivateProfileInt( "Options", "CharCoding",   IDM_CHARCODING_MBCS,   szINIFile );
           if (wCharCoding == IDM_CHARCODING_UNICODE)
           {
               wCharCoding = IDM_CHARCODING_MBCS;       // to be changed in ChangeCharCoding
               ChangeCharCoding (hwnd, IDM_CHARCODING_UNICODE);
           }
           else
           {
               wCharCoding = IDM_CHARCODING_UNICODE;    // to be changed in ChangeCharCoding
               ChangeCharCoding (hwnd, IDM_CHARCODING_MBCS);
           }


           wMappingMode    = (UINT)GetPrivateProfileInt( "Mapping", "Mode", IDM_MMTEXT, szINIFile );

           hMenu = GetMenu( hwnd );
           CheckMenuItem( hMenu, wSpacing,     MF_CHECKED );
           CheckMenuItem( hMenu, wMappingMode, MF_CHECKED );
           CheckMenuItem( hMenu, wKerning,     MF_CHECKED );
           CheckMenuItem( hMenu, IDM_UPDATECP, (wUpdateCP ? MF_CHECKED : MF_UNCHECKED) );
           CheckMenuItem( hMenu, IDM_USEPRINTERDC, (wUsePrinterDC ? MF_CHECKED : MF_UNCHECKED) );

           if( wSpacing == IDM_USEDEFAULTSPACING )
             {
              EnableMenuItem( hMenu, IDM_NOKERNING,     MF_GRAYED );
              EnableMenuItem( hMenu, IDM_APIKERNING,    MF_GRAYED );
              EnableMenuItem( hMenu, IDM_ESCAPEKERNING, MF_GRAYED );
             }

           xWE = (int)GetPrivateProfileInt( "Mapping", "xWE", 1, szINIFile );
           yWE = (int)GetPrivateProfileInt( "Mapping", "yWE", 1, szINIFile );
           xWO = (int)GetPrivateProfileInt( "Mapping", "xWO", 0, szINIFile );
           yWO = (int)GetPrivateProfileInt( "Mapping", "yWO", 0, szINIFile );

           xVE = (int)GetPrivateProfileInt( "Mapping", "xVE", 1, szINIFile );
           yVE = (int)GetPrivateProfileInt( "Mapping", "yVE", 1, szINIFile );
           xVO = (int)GetPrivateProfileInt( "Mapping", "xVO", 0, szINIFile );
           yVO = (int)GetPrivateProfileInt( "Mapping", "yVO", 0, szINIFile );
           bAdvanced = (int)GetPrivateProfileInt( "Mapping", "Advanced", bAdvanced, szINIFile );

           elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight         = (int) GetPrivateProfileInt( "Font", "lfHeight",         10, szINIFile );
           elfdvA.elfEnumLogfontEx.elfLogFont.lfWidth          = (int) GetPrivateProfileInt( "Font", "lfWidth",           0, szINIFile );
           elfdvA.elfEnumLogfontEx.elfLogFont.lfEscapement     = (int) GetPrivateProfileInt( "Font", "lfEscapement",      0, szINIFile );
           elfdvA.elfEnumLogfontEx.elfLogFont.lfOrientation    = (int) GetPrivateProfileInt( "Font", "lfOrientation",     0, szINIFile );
           elfdvA.elfEnumLogfontEx.elfLogFont.lfWeight         = (int) GetPrivateProfileInt( "Font", "lfWeight",          0, szINIFile );
           elfdvA.elfEnumLogfontEx.elfLogFont.lfItalic         = (BYTE)GetPrivateProfileInt( "Font", "lfItalic",          0, szINIFile );
           elfdvA.elfEnumLogfontEx.elfLogFont.lfUnderline      = (BYTE)GetPrivateProfileInt( "Font", "lfUnderline",       0, szINIFile );
           elfdvA.elfEnumLogfontEx.elfLogFont.lfStrikeOut      = (BYTE)GetPrivateProfileInt( "Font", "lfStrikeOut",       0, szINIFile );
           elfdvA.elfEnumLogfontEx.elfLogFont.lfCharSet        = (BYTE)GetPrivateProfileInt( "Font", "lfCharSet",         0, szINIFile );
           elfdvA.elfEnumLogfontEx.elfLogFont.lfOutPrecision   = (BYTE)GetPrivateProfileInt( "Font", "lfOutPrecision",    0, szINIFile );
           elfdvA.elfEnumLogfontEx.elfLogFont.lfClipPrecision  = (BYTE)GetPrivateProfileInt( "Font", "lfClipPrecision",   0, szINIFile );
           elfdvA.elfEnumLogfontEx.elfLogFont.lfQuality        = (BYTE)GetPrivateProfileInt( "Font", "lfQuality",         0, szINIFile );
           elfdvA.elfEnumLogfontEx.elfLogFont.lfPitchAndFamily = (BYTE)GetPrivateProfileInt( "Font", "lfPitchAndFamily",  0, szINIFile );

           GetPrivateProfileString( "Font", "lfFaceName", "Arial", elfdvA.elfEnumLogfontEx.elfLogFont.lfFaceName,
               sizeof(elfdvA.elfEnumLogfontEx.elfLogFont.lfFaceName), szINIFile );

           len = (int)GetPrivateProfileInt( "Font", "lfFaceNameWlength", 0, szINIFile);
           if (len > 0)
               GetPrivateProfileStruct( "Font", "lfFaceNameW", 
                                        (LPVOID)lfFaceNameW, 
                                        2*(len+1), szINIFile);
           else
               lfFaceNameW[0] = L'\0';

           SyncElfdvAtoW (&elfdvW, &elfdvA);
           if (!isCharCodingUnicode)
               ; // do nothing
           else
           {
               wcscpy (elfdvW.elfEnumLogfontEx.elfLogFont.lfFaceName, (LPWSTR)lfFaceNameW);
               SyncElfdvWtoA (&elfdvA, &elfdvW);
           }

           dwRGBText       = GetPrivateProfileDWORD( "Colors", "dwRGBText",       dwRGBText,       szINIFile );
           dwRGBBackground = GetPrivateProfileDWORD( "Colors", "dwRGBBackground", dwRGBBackground, szINIFile );

           GetPrivateProfileString( "View", "szString", "Font Test", szStringA, sizeof(szStringA), szINIFile );

           len = (int)GetPrivateProfileInt( "View", "szStringWlength", 0, szINIFile);
           
           if (len > 0)
               GetPrivateProfileStruct( "View", "szStringW", (LPVOID)szStringW, 2*(len+1), szINIFile);
           else
               szStringW[0] = L'\0';

           if (!isCharCodingUnicode)
               SyncszStringWith(IDM_CHARCODING_UNICODE); 
           else
               SyncszStringWith(IDM_CHARCODING_MBCS); 

           isGradientBackground = (BOOL) GetPrivateProfileInt("Options", "GradientBackground", FALSE, szINIFile);
           
           CheckMenuItem( hMenu, IDM_SETSOLIDBACKGROUND, (isGradientBackground ? MF_UNCHECKED : MF_CHECKED) );
           CheckMenuItem( hMenu, IDM_SETGRADIENTBACKGROUND, (isGradientBackground ? MF_CHECKED : MF_UNCHECKED) );
           
           dwRGBSolidBackgroundColor = GetPrivateProfileDWORD("Color", "dwRGBSolidBackgroundColor", RGB(0xff, 0xff, 0xff) , szINIFile);
           dwRGBLeftBackgroundColor = GetPrivateProfileDWORD("Color", "dwRGBLeftBackgroundColor", RGB(0xff, 0xff, 0xff), szINIFile);
           dwRGBRightBackgroundColor = GetPrivateProfileDWORD("Color", "dwRGBRightBackgroundColor", RGB(0, 0, 0), szINIFile);

           PostMessage( hwnd, WM_USER, 0, 0 );

           return 0;


    case WM_PAINT:

        {
            PAINTSTRUCT ps;
            HDC hdc;

            hdc = BeginPaint(hwnd,&ps);
            PatBlt(
                hdc
              , ps.rcPaint.left
              , ps.rcPaint.top
              , ps.rcPaint.right - ps.rcPaint.left
              , ps.rcPaint.bottom - ps.rcPaint.top
              , WHITENESS
                );
            EndPaint(hwnd, &ps);
        }
           return 0;


    case WM_LBUTTONDOWN:
           ResizeProc( hwnd );
           break;

    case WM_USER:
           VersionSpecifics( hwnd );
           SelectMode( hwnd, wMode );
           break;

#if 0
    case WM_SIZE:
           {
            int cxClient, cyClient;

            cxClient = LOWORD(lParam);
            cyClient = HIWORD(lParam);

            MoveWindow( hwndGlyph,     0, 0, rcl.left, cyClient, FALSE );
            MoveWindow( hwndRings,     0, 0, rcl.left, cyClient, FALSE );
            MoveWindow( hwndString,    0, 0, rcl.left, cyClient, FALSE );
            MoveWindow( hwndWaterfall, 0, 0, rcl.left, cyClient, FALSE );
            MoveWindow( hwndWhirl,     0, 0, rcl.left, cyClient, FALSE );
            MoveWindow( hwndAnsiSet,   0, 0, rcl.left, cyClient, FALSE );
            MoveWindow( hwndGlyphSet,  0, 0, rcl.left, cyClient, FALSE );

            InvalidateRect( hwndMode, NULL, TRUE );
            InvalidateRect( hwndMain, &rcl, TRUE );

            MoveWindow( hwndDebug, rcl.right, 0, rclMain.right-rcl.right, rclMain.bottom, TRUE );
           }

           break;
#endif


    case WM_COMMAND:
           switch( LOWORD( wParam ) )
            {
             case IDM_DEBUG:
                    hMenu = GetMenu( hwnd );
                    Debugging = !Debugging;

                    iCount = 0;
                    SendMessage( hwndDebug, LB_RESETCONTENT, 0, 0 );

                    //ShowWindow( hwndDebug, Debugging ? SW_SHOWNORMAL: SW_HIDE );
                    CheckMenuItem( hMenu, IDM_DEBUG, Debugging ? MF_CHECKED : MF_UNCHECKED );

                    return 0;


             case IDM_OPENLOG:
                    lstrcpy( szNewLog, szLogFile );
                    ofn.lStructSize       = sizeof(ofn);
                    ofn.hwndOwner         = hwnd;
                    ofn.lpstrFilter       = lpszFilter;
                    ofn.lpstrCustomFilter = NULL;
                    ofn.nMaxCustFilter    = 0L;
                    ofn.nFilterIndex      = 0L;
                    ofn.lpstrFile         = szNewLog;
                    ofn.nMaxFile          = sizeof(szNewLog);
                    ofn.lpstrFileTitle    = NULL;
                    ofn.nMaxFileTitle     = 0L;
                    ofn.lpstrInitialDir   = NULL;
                    ofn.lpstrTitle        = "Log Filename";
                    ofn.Flags             = OFN_OVERWRITEPROMPT;
                    ofn.lpstrDefExt       = "LOG";
                    ofn.lCustData         = 0;

                    if( GetSaveFileName( &ofn ) )
                     {
                      int fh;

                      bLogging = TRUE;
                      lstrcpy( szLogFile, szNewLog );

                      dprintf( "szNewLog = '%s'", szNewLog );

                      //  OpenFile( szLogFile, NULL, OF_DELETE );


                      fh = _lcreat( szLogFile, 0 );  // Nuke any existing log
                      _lclose( fh );

                      hMenu = GetMenu( hwnd );
                      EnableMenuItem( hMenu, IDM_OPENLOG,  MF_GRAYED  );
                      EnableMenuItem( hMenu, IDM_CLOSELOG, MF_ENABLED );
                     }

                    return 0;


             case IDM_CLOSELOG:
                    bLogging = FALSE;
                    hMenu = GetMenu( hwnd );
                    EnableMenuItem( hMenu, IDM_OPENLOG,  MF_ENABLED );
                    EnableMenuItem( hMenu, IDM_CLOSELOG, MF_GRAYED  );

                    return 0;


             case IDM_CLEARSTRING:
                    szStringA[0] = '\0';
                    szStringW[0] = L'\0';
                    InvalidateRect( hwndMode, NULL, TRUE );
                    return 0;

             case IDM_EDITSTRING:
                    ShowDialogBox( StringEditDlgProc, IDB_EDITSTRING, 0 );
                    InvalidateRect( hwndMode, NULL, TRUE );
                    return 0;

             case IDM_EDITGLYPHINDEX:
                    ShowDialogBox( GlyphIndexEditDlgProc, IDB_EDITGLYPHINDEX, 0 );
                    InvalidateRect( hwndMode, NULL, TRUE );
                    return 0;

             case IDM_CLEARDEBUG:
                    iCount = 0;
                    SendMessage( hwndDebug, LB_RESETCONTENT, 0, 0 );
                    return 0;


             case IDM_PRINT:
                    PrintIt(hwnd);
                    break;


             case IDM_PRINTERSETUP:
                    if( hdcCachedPrinter )
                     {
                      DeleteDC( hdcCachedPrinter );
                      hdcCachedPrinter = NULL;
                     }

                    pdlg.Flags = PD_NOPAGENUMS | PD_PRINTSETUP | PD_USEDEVMODECOPIES;
                    if( !PrintDlg( &pdlg ) )
                     {
                      DWORD dwErr;

                      dwErr = CommDlgExtendedError();

                      if( dwErr == PDERR_DEFAULTDIFFERENT )
                        {
                         LPDEVNAMES lpdn;

                         lpdn = (LPDEVNAMES)GlobalLock( pdlg.hDevNames );
                         lpdn->wDefault &= ~DN_DEFAULTPRN;
                         GlobalUnlock( pdlg.hDevNames );

                         if( !PrintDlg( &pdlg ) )
                           dwErr = CommDlgExtendedError();
                          else
                           dwErr = 0;

                         lpdn = (LPDEVNAMES)GlobalLock( pdlg.hDevNames );
                         lpdn->wDefault |= DN_DEFAULTPRN;
                         GlobalUnlock( pdlg.hDevNames );
                        }

                      if( dwErr ) dprintf( "PrinterDlg error: 0x%.8lX", dwErr );
                     }

                    if( wUsePrinterDC ) InvalidateRect( hwndMode, NULL, TRUE );

                    break;

             case IDM_GLYPHMODE:
             case IDM_NATIVEMODE:
             case IDM_BEZIERMODE:
             case IDM_RINGSMODE:
             case IDM_STRINGMODE:
             case IDM_WATERFALLMODE:
             case IDM_WHIRLMODE:
             case IDM_ANSISETMODE:
             case IDM_GLYPHSETMODE:
             case IDM_WIDTHSMODE:
                    SelectMode( hwnd, wParam );
                    return 0;


             case IDM_GGOMATRIX:
                    ShowDialogBox( GGOMatrixDlgProc, IDB_GGOMATRIX, 0 );
                    InvalidateRect( hwndMode, NULL, TRUE );

                    return 0;


             case IDM_WRITEGLYPH:
                    WriteGlyph( "GLYPH.BMP" );
                    return 0;

             case IDM_USEGLYPHINDEX:
                    hMenu = GetMenu( hwnd );

                    wUseGlyphIndex = !wUseGlyphIndex;
                    CheckMenuItem( hMenu, (UINT)wParam, (wUseGlyphIndex ? MF_CHECKED : MF_UNCHECKED) );

                    if (wUseGlyphIndex) 
                         wETO |= ETO_GLYPH_INDEX;
                    else wETO &= ~ETO_GLYPH_INDEX;

                    InvalidateRect( hwndMode, NULL, TRUE );

                    return 0;

             case IDM_USEPRINTERDC:
                    hMenu = GetMenu( hwnd );

                    wUsePrinterDC = !wUsePrinterDC;
                    CheckMenuItem( hMenu, (UINT)wParam, (wUsePrinterDC ? MF_CHECKED : MF_UNCHECKED) );

                    InvalidateRect( hwndMode, NULL, TRUE );

                    return 0;

             case IDM_CHARCODING_MBCS:
             case IDM_CHARCODING_UNICODE:
                    ChangeCharCoding( hwnd, wParam );
                    InvalidateRect( hwndMode, NULL, TRUE );
                    return 0;

             case IDM_MMHIENGLISH:
             case IDM_MMLOENGLISH:
             case IDM_MMHIMETRIC:
             case IDM_MMLOMETRIC:
             case IDM_MMTEXT:
             case IDM_MMTWIPS:
                    ChangeMapMode( hwnd, wParam );
                    InvalidateRect( hwndMode, NULL, TRUE );
                    return 0;


             case IDM_MMANISOTROPIC:
                    ShowDialogBox( MMAnisotropicDlgProc, IDB_MMANISOTROPIC, NULL );
                    ChangeMapMode( hwnd, wParam );
                    InvalidateRect( hwndMode, NULL, TRUE );
                    return 0;

             case IDM_COMPATIBLE_MODE:
                hMenu = GetMenu(hwnd);
                bAdvanced = FALSE;
                CheckMenuItem(hMenu, IDM_COMPATIBLE_MODE, MF_CHECKED);
                CheckMenuItem(hMenu, IDM_ADVANCED_MODE, MF_UNCHECKED);
                InvalidateRect( hwndMode, NULL, TRUE );
                return 0;

             case IDM_ADVANCED_MODE:
                hMenu = GetMenu(hwnd);
                bAdvanced = TRUE;
                CheckMenuItem(hMenu, IDM_COMPATIBLE_MODE, MF_UNCHECKED);
                CheckMenuItem(hMenu, IDM_ADVANCED_MODE, MF_CHECKED);
                InvalidateRect( hwndMode, NULL, TRUE );
                return 0;

            case IDM_WORLD_TRANSFORM:
                ShowDialogBox( SetWorldTransformDlgProc, IDB_SETWORLDTRANSFORM, NULL);
                InvalidateRect( hwndMode, NULL, TRUE );
                return 0;

             case IDM_CLIPELLIPSE:
                    hMenu = GetMenu( hwnd );
                    bClipEllipse = !bClipEllipse;
                    CheckMenuItem( hMenu, (UINT)wParam, (bClipEllipse ? MF_CHECKED : MF_UNCHECKED) );
                    InvalidateRect( hwndMode, NULL, TRUE );
                    return 0;

             case IDM_CLIPPOLYGON:
                    hMenu = GetMenu( hwnd );
                    bClipPolygon = !bClipPolygon;
                    CheckMenuItem( hMenu, (UINT)wParam, (bClipPolygon ? MF_CHECKED : MF_UNCHECKED) );
                    InvalidateRect( hwndMode, NULL, TRUE );
                    return 0;

             case IDM_CLIPRECTANGLE:
                    hMenu = GetMenu( hwnd );
                    bClipRectangle = !bClipRectangle;
                    CheckMenuItem( hMenu, (UINT)wParam, (bClipRectangle ? MF_CHECKED : MF_UNCHECKED) );
                    InvalidateRect( hwndMode, NULL, TRUE );
                    return 0;


             case IDM_CHOOSEFONTDIALOG:
                    wtMode = (UINT)wMappingMode;
                    ChangeMapMode( hwnd, IDM_MMTEXT );

                    if (!isCharCodingUnicode)
                    {
                        cf.lStructSize = sizeof(CHOOSEFONTA);
                        cf.hwndOwner   = hwnd;
                        cf.lpLogFont   = (LPLOGFONTA)&elfdvA;
                        cf.Flags       = CF_SCREENFONTS | CF_EFFECTS | CF_INITTOLOGFONTSTRUCT | CF_MM_DESIGNVECTOR;
                        // cf.Flags       = CF_PRINTERFONTS | CF_EFFECTS | CF_INITTOLOGFONTSTRUCT;
                        cf.hDC         = NULL;

                        if( wUsePrinterDC )
                         {
                          cf.hDC   =  CreatePrinterDC();
                          cf.Flags |= CF_BOTH;
                         }

                        hMod = LoadLibrary("comdlg32mm.dll");
                        if ((hMod) && (lpfnChooseFont = GetProcAddress(hMod, "ChooseFontA")))
                        {
                            dprintf("Calling alternate ChooseFontA() function");
                            lpfnChooseFont( &cf );
                            FreeLibrary(hMod);
                        }
                        else
                        {
                            dprintf("Failed to load new library.");
                            dprintf("Calling standard ChooseFontA() function");
                            ChooseFontA( &cf );
                            
                        }

                        dprintf("Resetting values of MM Axes");
                        elfdvA.elfDesignVector.dvNumAxes = 0;  // reset to avoid errors

                        if( cf.hDC )
                         {
                          DeleteTestIC( cf.hDC );
                          cf.hDC = NULL;
                         }

                        dwRGBText = cf.rgbColors;

                        SyncElfdvAtoW (&elfdvW, &elfdvA);
                    }
                    else
                    {
                        cfW.lStructSize = sizeof(CHOOSEFONTW);
                        cfW.hwndOwner   = hwnd;
                        cfW.lpLogFont   = (LPLOGFONTW)&elfdvW;
                        cfW.Flags       = CF_SCREENFONTS | CF_EFFECTS | CF_INITTOLOGFONTSTRUCT | CF_MM_DESIGNVECTOR;
                        cfW.hDC         = NULL;

                        if( wUsePrinterDC )
                         {
                          cfW.hDC   =  CreatePrinterDC();
                          cfW.Flags |= CF_BOTH;
                         }

                        hMod = LoadLibrary("comdlg32mm.dll");
                        if ((hMod) && (lpfnChooseFont = GetProcAddress(hMod, "ChooseFontW")))
                        {
                            dprintf("Calling alternate ChooseFontW() function");
                            lpfnChooseFont( &cfW );
                            FreeLibrary(hMod);
                        }
                        else
                        {
                            dprintf("Failed to load new library.");
                            dprintf("Calling standard ChooseFontW() function");
                            ChooseFontW( &cfW );
                        }
                        dprintf("Resetting values of MM Axes");
                        elfdvW.elfDesignVector.dvNumAxes = 0;  // reset to avoid errors

                        if( cfW.hDC )
                         {
                          DeleteTestIC( cfW.hDC );
                          cfW.hDC = NULL;
                         }

                        dwRGBText = cfW.rgbColors;

                        SyncElfdvWtoA (&elfdvA, &elfdvW);
                    }

                    ChangeMapMode( hwnd, wtMode );
                    InvalidateRect( hwndMode, NULL, TRUE );

                    return 0;


             case IDM_CHOOSEFONTDIALOGEX:
                    wtMode = (UINT)wMappingMode;
                    ChangeMapMode( hwnd, IDM_MMTEXT );

                    if (!isCharCodingUnicode)
                    {
                        cf.lStructSize = sizeof(CHOOSEFONTA);
                        cf.hwndOwner   = hwnd;
                        cf.lpLogFont   = (LPLOGFONTA)&elfdvA;
                        cf.Flags       = CF_SCREENFONTS | CF_EFFECTS | CF_INITTOLOGFONTSTRUCT | CF_MM_DESIGNVECTOR;
                        // cf.Flags       = CF_PRINTERFONTS | CF_EFFECTS | CF_INITTOLOGFONTSTRUCT;
                        cf.hDC         = NULL;

                        if( wUsePrinterDC )
                         {
                          cf.hDC   =  CreatePrinterDC();
                          cf.Flags |= CF_BOTH;
                         }

                        hMod = LoadLibrary("comdlg32mm.dll");
                        if ((hMod) && (lpfnChooseFontEx = GetProcAddress(hMod, "ChooseFontExA")))
                        {
                            dprintf("Calling ChooseFontExA() function");
                            lpfnChooseFontEx( &cf, CHF_DESIGNVECTOR );
                            FreeLibrary(hMod);
                        }
                        else
                        {
                            dprintf("Failed to load new library.");
                            dprintf("Calling standard ChooseFontA() function");
                            ChooseFontA( &cf );
                            dprintf("Resetting values of MM Axes");
                            elfdvA.elfDesignVector.dvNumAxes = 0;  // reset to avoid errors
                            
                        }

                        if( cf.hDC )
                         {
                          DeleteTestIC( cf.hDC );
                          cf.hDC = NULL;
                         }

                        dwRGBText = cf.rgbColors;

                        SyncElfdvAtoW (&elfdvW, &elfdvA);
                    }
                    else
                    {
                        cfW.lStructSize = sizeof(CHOOSEFONTW);
                        cfW.hwndOwner   = hwnd;
                        cfW.lpLogFont   = (LPLOGFONTW)&elfdvW;
                        cfW.Flags       = CF_SCREENFONTS | CF_EFFECTS | CF_INITTOLOGFONTSTRUCT | CF_MM_DESIGNVECTOR;
                        cfW.hDC         = NULL;

                        if( wUsePrinterDC )
                         {
                          cfW.hDC   =  CreatePrinterDC();
                          cfW.Flags |= CF_BOTH;
                         }

                        hMod = LoadLibrary("comdlg32mm.dll");
                        if ((hMod) && (lpfnChooseFontEx = GetProcAddress(hMod, "ChooseFontExW")))
                        {
                            dprintf("Calling ChooseFontExW() function");
                            lpfnChooseFontEx( &cfW, CHF_DESIGNVECTOR );
                            FreeLibrary(hMod);
                        }
                        else
                        {
                            dprintf("Failed to load new library.");
                            dprintf("Calling standard ChooseFontW() function");
                            ChooseFontW( &cfW );
                            dprintf("Resetting values of MM Axes");
                            elfdvW.elfDesignVector.dvNumAxes = 0;  // reset to avoid errors
                        }

                        if( cfW.hDC )
                         {
                          DeleteTestIC( cfW.hDC );
                          cfW.hDC = NULL;
                         }

                        dwRGBText = cfW.rgbColors;

                        SyncElfdvWtoA (&elfdvA, &elfdvW);
                    }

                    ChangeMapMode( hwnd, wtMode );
                    InvalidateRect( hwndMode, NULL, TRUE );

                    return 0;


             case IDM_CREATEFONTDIALOG:
                    if (!isCharCodingUnicode)
                        ShowDialogBox( CreateFontDlgProcA, IDB_CREATEFONT, NULL );
                    else
                        ShowDialogBox( CreateFontDlgProcW, IDB_CREATEFONT, NULL );
                    InvalidateRect( hwndMode, NULL, TRUE );
                    return 0;


             case IDM_ANSIFIXEDFONT:
             case IDM_ANSIVARFONT:
             case IDM_DEVICEDEFAULTFONT:
             case IDM_OEMFIXEDFONT:
             case IDM_SYSTEMFONT:
             case IDM_SYSTEMFIXEDFONT:
             case IDM_DEFAULTGUIFONT:
                    UseStockFont( (WORD) wParam );
                    InvalidateRect( hwndMode, NULL, TRUE );
                    return 0;

             case IDM_GCP :
                    ShowDialogBox( GcpDlgProc, IDB_GCP, NULL);
                    InvalidateRect( hwndMode, NULL, TRUE );
                    return 0;

             case IDM_GTEEXT :
                    ShowDialogBox( GTEExtDlgProc, IDB_GTEEXT, NULL);
                    InvalidateRect( hwndMode, NULL, TRUE );
                    return 0;

             case IDM_SETXTCHAR :
                    ShowDialogBox( SetTxtChExDlgProc, IDB_SETXTCHAR, NULL );
                    InvalidateRect( hwndMode, NULL, TRUE );
                    return 0;

             case IDM_SETXTJUST :
                    ShowDialogBox( SetTxtJustDlgProc, IDB_SETXTJUST, NULL );
                    InvalidateRect( hwndMode, NULL, TRUE );
                    return 0;

             case IDM_SETTEXTCOLOR:
             case IDM_SETBACKGROUNDCOLOR:
             case IDM_SETSOLIDBACKGROUNDCOLOR:
             case IDM_SETLEFTGRADIENTCOLOR:
             case IDM_SETRIGHTGRADIENTCOLOR:

                    {
                     int         i;
                     CHOOSECOLOR cc;
                     DWORD       dwCustom[16];


                     for( i = 0; i < 16; i++ ) dwCustom[i] = RGB(255,255,255);

                     memset( &cc, 0, sizeof(cc) );

                     cc.lStructSize  = sizeof(cc);
                     cc.hwndOwner    = hwnd;
                     cc.rgbResult    = ( wParam==IDM_SETTEXTCOLOR ? dwRGBText : dwRGBBackground );
                     cc.lpCustColors = (LPDWORD)dwCustom;
                     cc.Flags        = CC_RGBINIT;

                     if( ChooseColor(&cc) )
                      {
                        switch(wParam)
                        {
                         case IDM_SETTEXTCOLOR:
                            dwRGBText = cc.rgbResult;
                            break;

                         case IDM_SETBACKGROUNDCOLOR:
                            dwRGBBackground = cc.rgbResult;
                            break;

                         case IDM_SETSOLIDBACKGROUNDCOLOR:
                            dwRGBSolidBackgroundColor = cc.rgbResult;
                            break;

                         case IDM_SETLEFTGRADIENTCOLOR:
                            dwRGBLeftBackgroundColor = cc.rgbResult;
                            break;

                         case IDM_SETRIGHTGRADIENTCOLOR:
                            dwRGBRightBackgroundColor = cc.rgbResult;
                            break;
                        }

                       InvalidateRect( hwndMode, NULL, TRUE );
                      }
                    }

                    return 0;


             case IDM_SHOWLOGFONT:
                    ShowLogFont();
                    return 0;


             case IDM_USEDEFAULTSPACING:
             case IDM_USEWIDTHSPACING:
             case IDM_USEABCSPACING:
             case IDM_PDX:
             case IDM_PDXPDY:
             case IDM_RANDOMPDXPDY:
                    hMenu = GetMenu( hwnd );

                    if (wUseGlyphIndex != 0)
                      if (wParam == IDM_USEWIDTHSPACING || wParam == IDM_USEABCSPACING)
                      {
                          MessageBox(hwnd, "You cannot choose this option together with using glyph indices!", "Error", MB_OK);
                          return 0;
                      }
                     
                    if (wParam == IDM_PDX && wSpacing == IDM_PDXPDY)
                    {
                        if (lpintdx)
                        {
                            for (i=0; i<sizePdx; i++)
                                 lpintdx[i] = (i<sizePdx/2)? lpintdx[2*i] : 0;
                            sizePdx = sizePdx/2;
                        }
                    }

                    if (wParam == IDM_PDXPDY && wSpacing != IDM_PDXPDY)
                    {
                        if (lpintdx)
                        {
                            for (i=sizePdx-1; i>=0; i--)
                            {
                                lpintdx[2*i]   = lpintdx[i];
                                lpintdx[2*i+1] = 0;
                            }
                            sizePdx *= 2;
                        }
                    }

                    // make the actual switch now
                    CheckMenuItem( hMenu, wSpacing, MF_UNCHECKED );
                    CheckMenuItem( hMenu, (UINT)wParam, MF_CHECKED );
                    wSpacing = (UINT)wParam;

                    if ((wSpacing == IDM_PDXPDY) || (wSpacing == IDM_RANDOMPDXPDY))
                        wETO |= ETO_PDY;
                    else
                        wETO &= ~ETO_PDY;

                    if((wSpacing == IDM_USEDEFAULTSPACING) || (wSpacing == IDM_PDXPDY) || (wSpacing == IDM_RANDOMPDXPDY))
                      {
                       EnableMenuItem( hMenu, IDM_NOKERNING,     MF_GRAYED );
                       EnableMenuItem( hMenu, IDM_APIKERNING,    MF_GRAYED );
                       EnableMenuItem( hMenu, IDM_ESCAPEKERNING, MF_GRAYED );
                      }
                     else
                      {
                       EnableMenuItem( hMenu, IDM_NOKERNING,     MF_ENABLED );
                       EnableMenuItem( hMenu, IDM_APIKERNING,    MF_ENABLED );
                       EnableMenuItem( hMenu, IDM_ESCAPEKERNING, MF_ENABLED );
                      }

                    InvalidateRect( hwndMode, NULL, TRUE );

                    return 0;


             case IDM_NOKERNING:
             case IDM_APIKERNING:
             case IDM_ESCAPEKERNING:
                    hMenu = GetMenu( hwnd );

                    CheckMenuItem( hMenu, wKerning,  MF_UNCHECKED );
                    CheckMenuItem( hMenu, (UINT)wParam, MF_CHECKED );

                    wKerning = (UINT)wParam;
                    InvalidateRect( hwndMode, NULL, TRUE );

                    return 0;


             case IDM_UPDATECP:
                    hMenu = GetMenu( hwnd );

                    wUpdateCP = !wUpdateCP;
                    CheckMenuItem( hMenu, (UINT)wParam, (wUpdateCP ? MF_CHECKED : MF_UNCHECKED) );

                    InvalidateRect( hwndMode, NULL, TRUE );

                    return 0;

             case IDM_ENUMFONTS:
                    ShowEnumFonts( hwnd );
                    InvalidateRect( hwndMode, NULL, TRUE );
                    return 0;

             case IDM_ENUMFONTFAMILIES:
                    ShowEnumFontFamilies( hwnd );
                    InvalidateRect( hwndMode, NULL, TRUE );
                    return 0;

             case IDM_ENUMFONTFAMILIESEX:
                    ShowEnumFontFamiliesEx( hwnd);
                    InvalidateRect( hwndMode, NULL, TRUE);
                    return 0;

             case IDM_GETEXTENDEDTEXTMETRICS:
                    ShowExtendedTextMetrics( hwnd );
                    return 0;

             case IDM_GETPAIRKERNTABLE:
                    ShowPairKerningTable( hwnd );
                    return 0;

             case IDM_GETOUTLINETEXTMETRICS:
                    ShowOutlineTextMetrics( hwnd );
                    return 0;

             case IDM_GETRASTERIZERCAPS:
                    ShowRasterizerCaps();
                    return 0;

             case IDM_GETTEXTEXTENT:
                    ShowTextExtent( hwnd );
                    return 0;

             case IDM_GETUNICODERANGES:
                    ShowFontUnicodeRanges( hwnd );
                    return 0;

             case IDM_GETTEXTEXTENTI:
                    ShowTextExtentI( hwnd );
                    return 0;

             case IDM_GETCHARWIDTHI:
                    ShowCharWidthI( hwnd );
                    return 0;

             case IDM_GETTEXTFACE:
                    ShowTextFace( hwnd );
                    return 0;

             case IDM_GETTEXTMETRICS:
                    ShowTextMetrics( hwnd );
                    return 0;

             case IDM_GETTEXTCHARSETINFO:
                    ShowTextCharsetInfo( hwnd );
                    return 0;

             case IDM_GETFONTLANGUAGEINFO:
                    ShowFontLanguageInfo( hwnd );
                    return 0;

             case IDM_GETFONTDATA:
                    ShowDialogBox( GetFontDataDlgProc, IDB_GETFONTDATA, NULL );
                    return 0;

             case IDM_CREATESCALABLEFONTRESOURCE:
                    ShowDialogBox( CreateScalableFontDlgProc, IDB_CREATESCALABLEFONTRESOURCE, NULL );
                    return 0;

             case IDM_ADDFONTRESOURCE:
                    ShowDialogBox( AddFontResourceDlgProc, IDB_ADDFONTRESOURCE, NULL );
                    return 0;

             case IDM_ADDFONTRESOURCEEX:
                    ShowDialogBox( AddFontResourceExDlgProc, IDB_ADDFONTRESOURCEEX, NULL);
                    return 0;


             case IDM_REMOVEFONTRESOURCE:
                    ShowDialogBox( RemoveFontResourceDlgProc, IDB_REMOVEFONTRESOURCE, NULL );
                    return 0;


             case IDM_REMOVEFONTRESOURCEEX:
                    ShowDialogBox( RemoveFontResourceExDlgProc, IDB_REMOVEFONTRESOURCEEX, NULL );
                    return 0;

             case IDM_ADDFONTMEMRESOURCEEX:
                    //ShowAddFontMemResourceEx(hwnd);
                    ShowDialogBox(AddFontMemResourceExDlgProc, IDB_ADDFONTMEMRESOURCEEX, NULL);
                    return 0;

             case IDM_REMOVEFONTMEMRESOURCEEX:
                    //ShowRemoveFontMemResourceEx(hwnd);
                    ShowDialogBox(RemoveFontMemResourceExDlgProc, IDB_REMOVEFONTMEMRESOURCEEX, NULL);
                    return 0;

             case IDM_SETTEXTOUTOPTIONS:
                    ShowDialogBox( SetTextOutOptionsDlgProc, IDB_TEXTOUTOPTIONS, NULL );
                    InvalidateRect( hwndMode, NULL, TRUE );
                    return 0;

             #ifdef  USERGETCHARWIDTH

             case IDM_GETCHARWIDTHINFO:
                    ShowCharWidthInfo( hwnd );
                    return 0;

             #endif


             #ifdef  USERGETWVTPERF

             case IDM_GETWVTPERF:
                    ShowDialogBox( GetWVTPerfDlgProc, IDB_GETWVTPERF, NULL);
                    return 0;

             #endif

             #ifdef GI_API
             case IDM_TEXTOUTPERF:
                    TextOutPerformance( hwnd );
                    return 0;
             case IDM_CLEARTYPEPERF:
                    ClearTypePerformance( hwnd );
                    return 0;
             #endif

             case IDM_GETKERNINGPAIRS:
                    GetKerningPairsDlgProc( hwnd );
                    return 0;


             case IDM_ENABLEEUDC:      
                    ShowEnableEudc( hwnd );
                    return 0;

             case IDM_EUDCLOADLINKW:
                    ShowDialogBox(EudcLoadLinkWDlgProc, IDB_EUDCLOADLINKW, NULL);
                    return 0;

             case IDM_EUDCUNLOADLINKW:
                    ShowDialogBox(EudcUnLoadLinkWDlgProc, IDB_EUDCUNLOADLINKW, NULL);
                    return 0;

             case IDM_GETEUDCTIMESTAMP:      
                    ShowGetEudcTimeStamp( hwnd );
                    return 0;

             case IDM_GETEUDCTIMESTAMPEXW:
                    ShowGetEudcTimeStampExW( hwnd );
                    return 0;

             case IDM_GETSTRINGBITMAPA:      
                    ShowDialogBox(ShowGetStringBitMapAProc, IDB_GETSTRINGBITMAPA, NULL);
                    return 0;

             case IDM_GETSTRINGBITMAPW:    
                    ShowDialogBox(ShowGetStringBitMapWProc, IDB_GETSTRINGBITMAPW, NULL);
                    return 0;

             case IDM_GETFONTASSOCSTATUS:
                    ShowGetFontAssocStatus (hwnd );
                    return 0;

             case IDM_CHARWIDTHTEST:
                    CharWidthTestForAntiAliasing( hwnd, &elfdvA.elfEnumLogfontEx.elfLogFont );
                    return 0;

             case IDM_CHARWIDTHTESTALL:
                    CharWidthTestAllForAntiAliasing( hwnd );
                    return 0;

             case IDM_SETSOLIDBACKGROUND:
             case IDM_SETGRADIENTBACKGROUND:
                    hMenu = GetMenu( hwnd );

                    isGradientBackground = (wParam == IDM_SETGRADIENTBACKGROUND);
           
                    CheckMenuItem( hMenu, IDM_SETSOLIDBACKGROUND, (isGradientBackground ? MF_UNCHECKED : MF_CHECKED) );
                    CheckMenuItem( hMenu, IDM_SETGRADIENTBACKGROUND, (isGradientBackground ? MF_CHECKED : MF_UNCHECKED) );
                    InvalidateRect( hwndMode, NULL, TRUE );

                    return 0;
             
             default:
                    return 0;
            }


    case WM_MOUSEACTIVATE:
    case WM_SETFOCUS:
           SetFocus( hwndMode );
           return 0;


    case WM_DESTROY:
           if( hdcCachedPrinter ) DeleteDC( hdcCachedPrinter );

           WritePrivateProfileInt( "Font", "lfHeight",         elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight,         szINIFile );
           WritePrivateProfileInt( "Font", "lfWidth",          elfdvA.elfEnumLogfontEx.elfLogFont.lfWidth,          szINIFile );
           WritePrivateProfileInt( "Font", "lfEscapement",     elfdvA.elfEnumLogfontEx.elfLogFont.lfEscapement,     szINIFile );
           WritePrivateProfileInt( "Font", "lfOrientation",    elfdvA.elfEnumLogfontEx.elfLogFont.lfOrientation,    szINIFile );
           WritePrivateProfileInt( "Font", "lfWeight",         elfdvA.elfEnumLogfontEx.elfLogFont.lfWeight,         szINIFile );
           WritePrivateProfileInt( "Font", "lfItalic",         elfdvA.elfEnumLogfontEx.elfLogFont.lfItalic,         szINIFile );
           WritePrivateProfileInt( "Font", "lfUnderline",      elfdvA.elfEnumLogfontEx.elfLogFont.lfUnderline,      szINIFile );
           WritePrivateProfileInt( "Font", "lfStrikeOut",      elfdvA.elfEnumLogfontEx.elfLogFont.lfStrikeOut,      szINIFile );
           WritePrivateProfileInt( "Font", "lfCharSet",        elfdvA.elfEnumLogfontEx.elfLogFont.lfCharSet,        szINIFile );
           WritePrivateProfileInt( "Font", "lfOutPrecision",   elfdvA.elfEnumLogfontEx.elfLogFont.lfOutPrecision,   szINIFile );
           WritePrivateProfileInt( "Font", "lfClipPrecision",  elfdvA.elfEnumLogfontEx.elfLogFont.lfClipPrecision,  szINIFile );
           WritePrivateProfileInt( "Font", "lfQuality",        elfdvA.elfEnumLogfontEx.elfLogFont.lfQuality,        szINIFile );
           WritePrivateProfileInt( "Font", "lfPitchAndFamily", elfdvA.elfEnumLogfontEx.elfLogFont.lfPitchAndFamily, szINIFile );

           WritePrivateProfileString( "Font", "lfFaceName", elfdvA.elfEnumLogfontEx.elfLogFont.lfFaceName, szINIFile );

           WritePrivateProfileInt( "Font", "lfFaceNameWlength", 
                                    wcslen(elfdvW.elfEnumLogfontEx.elfLogFont.lfFaceName), szINIFile );
           WritePrivateProfileStruct( "Font", "lfFaceNameW", 
                                      (LPVOID)elfdvW.elfEnumLogfontEx.elfLogFont.lfFaceName, 
                                      2*(wcslen(elfdvW.elfEnumLogfontEx.elfLogFont.lfFaceName)+1), szINIFile);

           WritePrivateProfileDWORD( "Colors", "dwRGBText",       dwRGBText,       szINIFile );
           WritePrivateProfileDWORD( "Colors", "dwRGBBackground", dwRGBBackground, szINIFile );
           WritePrivateProfileDWORD( "Colors", "dwRGBSolidBackgroundColor", dwRGBSolidBackgroundColor, szINIFile );
           WritePrivateProfileDWORD( "Colors", "dwRGBLeftBackgroundColor", dwRGBLeftBackgroundColor, szINIFile );
           WritePrivateProfileDWORD( "Colors", "dwRGBRightBackgroundColor", dwRGBRightBackgroundColor, szINIFile );

           WritePrivateProfileInt( "Options", "Program Mode", wMode,         szINIFile );
           WritePrivateProfileInt( "Options", "TextAlign",    wTextAlign,    szINIFile );
           WritePrivateProfileInt( "Options", "BkMode",       iBkMode,       szINIFile );
           WritePrivateProfileInt( "Options", "ETO Options",  wETO,          szINIFile );
           WritePrivateProfileInt( "Options", "Spacing",      wSpacing,      szINIFile );
           WritePrivateProfileInt( "Options", "Kerning",      wKerning,      szINIFile );
           WritePrivateProfileInt( "Options", "UpdateCP",     wUpdateCP,     szINIFile );
           WritePrivateProfileInt( "Options", "UsePrinterDC", wUsePrinterDC, szINIFile );
           WritePrivateProfileInt( "Options", "CharCoding",   wCharCoding,   szINIFile );
           WritePrivateProfileInt( "Options", "GradientBackground",   isGradientBackground,   szINIFile );

           WritePrivateProfileInt( "Mapping", "Mode", (int)wMappingMode, szINIFile );

           WritePrivateProfileInt( "Mapping", "xWE", xWE, szINIFile );
           WritePrivateProfileInt( "Mapping", "yWE", yWE, szINIFile );
           WritePrivateProfileInt( "Mapping", "xWO", xWO, szINIFile );
           WritePrivateProfileInt( "Mapping", "yWO", yWO, szINIFile );

           WritePrivateProfileInt( "Mapping", "xVE", xVE, szINIFile );
           WritePrivateProfileInt( "Mapping", "yVE", yVE, szINIFile );
           WritePrivateProfileInt( "Mapping", "xVO", xVO, szINIFile );
           WritePrivateProfileInt( "Mapping", "yVO", yVO, szINIFile );
           WritePrivateProfileInt( "Mapping", "Advanced", bAdvanced, szINIFile );

           WritePrivateProfileString( "View", "szString", szStringA, szINIFile );
           //WritePrivateProfileStringW( L"View", L"szStringW", szStringW, L"\\awork\\fonttest.tig\\fonttest.ini");
           WritePrivateProfileInt( "View", "szStringWlength", wcslen(szStringW), szINIFile );
           WritePrivateProfileStruct( "View", "szStringW", (LPVOID)szStringW, 2*(wcslen(szStringW)+1), szINIFile);

           PostQuitMessage( 0 );
           return 0;
   }


  return DefWindowProc( hwnd, msg, wParam, lParam );
 }

//*****************************************************************************
//*******************   G E T   D L G   I T E M   F L O A T *******************
//*****************************************************************************

FLOAT
GetDlgItemFLOAT(
      HWND  hdlg
    , int   id
    )
{
    char ach[50];

    memset(ach,0,sizeof(ach));
    return((FLOAT)(GetDlgItemText(hdlg,id,ach,sizeof(ach))?atof(ach):0.0));
}

//*****************************************************************************
//*******************   S E T   D L G   I T E M   F L O A T *******************
//*****************************************************************************

void
SetDlgItemFLOAT(
      HWND    hdlg
    , int     id
    , FLOAT   e
    )
{
  static char ach[25];

  ach[0] = '\0';
  sprintf(ach, "%f", (double) e);
  SetDlgItemText(hdlg, id, ach);
}

//*****************************************************************************
//************   SETWORLDTRANSFORM             D L G   P R O C   **************
//*****************************************************************************

INT_PTR CALLBACK
SetWorldTransformDlgProc(
      HWND      hdlg
    , UINT      msg
    , WPARAM    wParam
    , LPARAM    lParam
    )
{
    switch(msg)
    {
    case WM_INITDIALOG:

        SetDlgItemFLOAT(hdlg, IDD_VALUE_EM11, xf.eM11);
        SetDlgItemFLOAT(hdlg, IDD_VALUE_EM12, xf.eM12);
        SetDlgItemFLOAT(hdlg, IDD_VALUE_EM21, xf.eM21);
        SetDlgItemFLOAT(hdlg, IDD_VALUE_EM22, xf.eM22);
        SetDlgItemFLOAT(hdlg, IDD_VALUE_EDX , xf.eDx );
        SetDlgItemFLOAT(hdlg, IDD_VALUE_EDY , xf.eDy );

        return(TRUE);

    case WM_COMMAND:

        switch( LOWORD( wParam ) )
        {
        case IDOK:

            xf.eM11  =  GetDlgItemFLOAT(hdlg, IDD_VALUE_EM11);
            xf.eM12  =  GetDlgItemFLOAT(hdlg, IDD_VALUE_EM12);
            xf.eM21  =  GetDlgItemFLOAT(hdlg, IDD_VALUE_EM21);
            xf.eM22  =  GetDlgItemFLOAT(hdlg, IDD_VALUE_EM22);
            xf.eDx   =  GetDlgItemFLOAT(hdlg, IDD_VALUE_EDX );
            xf.eDy   =  GetDlgItemFLOAT(hdlg, IDD_VALUE_EDY );

            EndDialog( hdlg, TRUE );
            return(TRUE);

        case IDCANCEL:

            EndDialog( hdlg, FALSE );
            return TRUE;
        }

        break;

    case WM_CLOSE:

        EndDialog(hdlg, FALSE);
        return(TRUE);
    }

    return(FALSE);
}



/******************************Public*Routine******************************\
*
* BOOL GenExtTextOut, text in path if so required
*
* History:
*  19-Sep-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL GenExtTextOut(
    HDC hdc,
    int x, int y,
    DWORD wFlags, LPRECT lpRect,
    LPVOID lpszString, int cbString, LPINT lpdx
    )
{
	BOOL bRet;
	if (bStrokePath || bFillPath)
	{
		BeginPath(hdc);
	}

	if (!isCharCodingUnicode)
		bRet = ExtTextOutA(hdc, x, y, wFlags, lpRect, lpszString, cbString, lpdx);
	else
		bRet = ExtTextOutW(hdc, x, y, wFlags, lpRect, lpszString, cbString, lpdx);

	if (bStrokePath || bFillPath)
	{
		EndPath(hdc);

		if (fillMode == ALTERNATE_FILL)
			SetPolyFillMode(hdc, ALTERNATE);
		else
			SetPolyFillMode(hdc, WINDING);

		if (bStrokePath && bFillPath)
			StrokeAndFillPath(hdc);
		else if (bStrokePath)
			StrokePath(hdc);
		else
			FillPath(hdc);
	}
   return bRet;
}


//*****************************************************************************
//*******************      Read Design Vector   *******************************
//*****************************************************************************
//**  This routine reads the design vector from the dialog box.



BOOL fReadDesignVector(
	HWND hdlg,
	LPDESIGNVECTOR lpdvMMInfo)
{
UINT i;


    lpdvMMInfo->dvNumAxes= GetDlgItemDWORD( hdlg, IDC_NUMEDITAXES);

    // currently, we do not support more than 4 axes though
    // the API supports upto 16 axes.
    if (lpdvMMInfo->dvNumAxes > 4)
	{	
	    MessageBox(hdlg, "Number of Axes should be <= 4", NULL,
										MB_OK | MB_ICONSTOP | MB_APPLMODAL);
	    EndDialog(hdlg, FALSE);	
		return FALSE;
	}

    for  (i = 0 ; i < lpdvMMInfo->dvNumAxes; i++)
    {
        lpdvMMInfo->dvValues[i] = (LONG) GetDlgItemDWORD( hdlg, IDC_TAGVALUE1 + i*2 );
    }

    return TRUE;

}


//************************************************************************//
//                                                                        //
// Function :  CreateFontIndirectWrapperW                                  //
//                                                                        //
// Parameters: pointer to the ENUMLOGFONTEXDEV structure.                 //
//                                                                        //
// Thread safety: none.                                                   //
//                                                                        //
// Task performed:  This function calls CreateFontIndirect if the number  //
//                  of axes in the DESIGNVECTOR is zero or if the app is  //
//                  not running on NT5.0 Else, the wrapper calls the      //
//                  CreateFontIndirectEx version to create the font.      //
//                                                                        //
//************************************************************************//


HFONT   CreateFontIndirectWrapperW(
                  ENUMLOGFONTEXDVW * pelfdv)
{

    #ifndef GI_API

        return CreateFontIndirectW((LOGFONTW *) &(pelfdv->elfEnumLogfontEx.elfLogFont));

    #else


    if (pelfdv->elfDesignVector.dvNumAxes)
    {
        return CreateFontIndirectExW(pelfdv);
    }
    else
    {
        return CreateFontIndirectW((LOGFONTW *) &(pelfdv->elfEnumLogfontEx.elfLogFont));
    }

    #endif

}

HFONT   CreateFontIndirectWrapperA(
                  ENUMLOGFONTEXDVA * pelfdv)

{

    #ifndef GI_API

        return CreateFontIndirect((LOGFONTA *) &(pelfdv->elfEnumLogfontEx.elfLogFont));

    #else


    if (pelfdv->elfDesignVector.dvNumAxes)
    {
        return CreateFontIndirectEx(pelfdv);
    }
    else
    {
        return CreateFontIndirect((LOGFONTA *) &(pelfdv->elfEnumLogfontEx.elfLogFont));
    }

    #endif

}


//*****************************************************************************
//*******************      SyncWith             *******************************
//*****************************************************************************
//* This function will synchronize Unicode and MBCS versions of szStringA/W string buffers.

BOOL SyncStringsAandW (int mode, LPSTR lpszStringA, LPWSTR lpszStringW, int cch)
{
	int nChar;
	int currentCP;

	DWORD *charSet; 
	CHARSETINFO myCSI;
    
    if (!isCharCodingUnicode)
        charSet = UlongToPtr(elfdvA.elfEnumLogfontEx.elfLogFont.lfCharSet);
    else
        charSet = UlongToPtr(elfdvW.elfEnumLogfontEx.elfLogFont.lfCharSet);
	TranslateCharsetInfo( (DWORD *)charSet, &myCSI, TCI_SRCCHARSET);

    currentCP = myCSI.ciACP;
  	// dprintf ("Selected Code Page: %d", currentCP);

	switch (mode)
	{
	case IDM_CHARCODING_MBCS:
		nChar = WideCharToMultiByte(currentCP, 0, lpszStringW, -1, 
												  lpszStringA, cch, 
												  NULL, NULL);
		if (nChar == 0) 
        {
			dprintf ("Error with Unicode->MBCS conversion");
            return FALSE;
        }
		break;

	case IDM_CHARCODING_UNICODE:
		nChar = MultiByteToWideChar(currentCP, 0, lpszStringA, -1, 
                                                  lpszStringW, cch);
		if (nChar == 0) 
        {
			dprintf ("Error with MBCS ->Unicode conversion");
            return FALSE;
        }
		break;

	default:
		return FALSE;
	}
	return TRUE;
}

//*****************************************************************************
//*******************      szStringSyncWith     *******************************
//*****************************************************************************
//* This function will synchronize Unicode and MBCS versions of szStringA/W string buffers.

BOOL SyncszStringWith (int mode)
{
    return SyncStringsAandW(mode, szStringA, szStringW, MAX_TEXT);
}

BOOL SyncStringAtoW (LPWSTR lpszStringW, LPSTR lpszStringA, int cch)
{
    return SyncStringsAandW (IDM_CHARCODING_UNICODE, lpszStringA, lpszStringW, cch);
}

BOOL SyncStringWtoA (LPSTR lpszStringA, LPWSTR lpszStringW, int cch)
{
    return SyncStringsAandW (IDM_CHARCODING_MBCS, lpszStringA, lpszStringW, cch);
}

//*****************************************************************************
//****************   SyncElfdvAtoW / SyncElfdvWtoA     ************************
//*****************************************************************************
//* These functions synchronize Unicode and MBCS versions of elfdvA/W logfont structures.

BOOL SyncElfdvAtoW (ENUMLOGFONTEXDVW *elfdv1, ENUMLOGFONTEXDVA *elfdv2)
{
    BOOL ok = TRUE;

    elfdv1->elfEnumLogfontEx.elfLogFont.lfHeight         = elfdv2->elfEnumLogfontEx.elfLogFont.lfHeight;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfWidth          = elfdv2->elfEnumLogfontEx.elfLogFont.lfWidth;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfEscapement     = elfdv2->elfEnumLogfontEx.elfLogFont.lfEscapement;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfOrientation    = elfdv2->elfEnumLogfontEx.elfLogFont.lfOrientation;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfWeight         = elfdv2->elfEnumLogfontEx.elfLogFont.lfWeight;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfItalic         = elfdv2->elfEnumLogfontEx.elfLogFont.lfItalic;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfUnderline      = elfdv2->elfEnumLogfontEx.elfLogFont.lfUnderline;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfStrikeOut      = elfdv2->elfEnumLogfontEx.elfLogFont.lfStrikeOut;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfCharSet        = elfdv2->elfEnumLogfontEx.elfLogFont.lfCharSet;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfOutPrecision   = elfdv2->elfEnumLogfontEx.elfLogFont.lfOutPrecision;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfClipPrecision  = elfdv2->elfEnumLogfontEx.elfLogFont.lfClipPrecision;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfQuality        = elfdv2->elfEnumLogfontEx.elfLogFont.lfQuality;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily = elfdv2->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily;

    ok &= SyncStringAtoW (elfdv1->elfEnumLogfontEx.elfLogFont.lfFaceName, elfdv2->elfEnumLogfontEx.elfLogFont.lfFaceName, LF_FACESIZE);

    ok &= SyncStringAtoW (elfdv1->elfEnumLogfontEx.elfFullName          , elfdv2->elfEnumLogfontEx.elfFullName, LF_FULLFACESIZE);
    ok &= SyncStringAtoW (elfdv1->elfEnumLogfontEx.elfStyle             , elfdv2->elfEnumLogfontEx.elfStyle   , LF_FACESIZE);
    ok &= SyncStringAtoW (elfdv1->elfEnumLogfontEx.elfScript            , elfdv2->elfEnumLogfontEx.elfScript  , LF_FACESIZE);

    memcpy(&(elfdv1->elfDesignVector), &(elfdv2->elfDesignVector), sizeof(DESIGNVECTOR));

    return ok;
}

//*****************************************************************************
//****************   SyncElfdvAtoW / SyncElfdvWtoA     ************************
//*****************************************************************************
//* These functions synchronize Unicode and MBCS versions of elfdvA/W logfont structures.

BOOL SyncElfdvWtoA (ENUMLOGFONTEXDVA *elfdv1, ENUMLOGFONTEXDVW *elfdv2)
{
    BOOL ok;

    elfdv1->elfEnumLogfontEx.elfLogFont.lfHeight         = elfdv2->elfEnumLogfontEx.elfLogFont.lfHeight;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfWidth          = elfdv2->elfEnumLogfontEx.elfLogFont.lfWidth;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfEscapement     = elfdv2->elfEnumLogfontEx.elfLogFont.lfEscapement;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfOrientation    = elfdv2->elfEnumLogfontEx.elfLogFont.lfOrientation;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfWeight         = elfdv2->elfEnumLogfontEx.elfLogFont.lfWeight;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfItalic         = elfdv2->elfEnumLogfontEx.elfLogFont.lfItalic;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfUnderline      = elfdv2->elfEnumLogfontEx.elfLogFont.lfUnderline;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfStrikeOut      = elfdv2->elfEnumLogfontEx.elfLogFont.lfStrikeOut;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfCharSet        = elfdv2->elfEnumLogfontEx.elfLogFont.lfCharSet;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfOutPrecision   = elfdv2->elfEnumLogfontEx.elfLogFont.lfOutPrecision;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfClipPrecision  = elfdv2->elfEnumLogfontEx.elfLogFont.lfClipPrecision;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfQuality        = elfdv2->elfEnumLogfontEx.elfLogFont.lfQuality;
    elfdv1->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily = elfdv2->elfEnumLogfontEx.elfLogFont.lfPitchAndFamily;

    ok &= SyncStringWtoA (elfdv1->elfEnumLogfontEx.elfLogFont.lfFaceName, elfdv2->elfEnumLogfontEx.elfLogFont.lfFaceName, LF_FACESIZE);

    ok &= SyncStringWtoA (elfdv1->elfEnumLogfontEx.elfFullName          , elfdv2->elfEnumLogfontEx.elfFullName, LF_FULLFACESIZE);
    ok &= SyncStringWtoA (elfdv1->elfEnumLogfontEx.elfStyle             , elfdv2->elfEnumLogfontEx.elfStyle   , LF_FACESIZE);
    ok &= SyncStringWtoA (elfdv1->elfEnumLogfontEx.elfScript            , elfdv2->elfEnumLogfontEx.elfScript  , LF_FACESIZE);

    memcpy(&(elfdv1->elfDesignVector), &(elfdv2->elfDesignVector), sizeof(DESIGNVECTOR));

    return ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\eudc.h ===
//************************************************************************//
//                                                                        
// Filename :  eudc.h
//                                                                       
// Description: Just function prototypes declarations.
//                                                                        
// Created by:  Rajesh Munshi                                            
//                                                                       
// History:     Created on 08/14/97
//                                                                       
//************************************************************************//


// Constants used in EudcLoadLink() calls

#define FONTLINK_SYSTEM   0
#define FONTLINK_USER     1

// Size of the bitmap used for GetStringBitmap calls

#define  BITMAP_SIZE   1000




// Function prototypes.

VOID ShowEnableEudc(HANDLE hwnd);
VOID ShowGetEudcTimeStamp(HANDLE hwnd);
VOID ShowGetEudcTimeStampExW(HANDLE hwnd);
VOID ShowGetFontAssocStatus(HANDLE hwnd);

// Function prototypes for the actual EUDC calls.

BOOL  APIENTRY EnableEUDC(BOOL);
UINT  APIENTRY GetFontAssocStatus(HDC hdc);
ULONG APIENTRY GetEUDCTimeStamp();
ULONG APIENTRY GetEUDCTimeStampExW(LPWSTR lpwstrBaseFaceName);
ULONG APIENTRY EudcLoadLinkW(LPCWSTR pBaseFaceName, LPCWSTR pEudcFontPath, INT iPriority, INT iFontLinkType);
ULONG APIENTRY EudcUnloadLinkW(LPCWSTR pBaseFaceName, LPCWSTR pEudcFontPath);
UINT  APIENTRY GetStringBitmapA(HDC hdc, LPSTR lpszString, UINT uStrlen, BYTE* pByte, UINT uSize);
UINT  APIENTRY GetStringBitmapW(HDC hdc, LPWSTR lpszString, UINT uStrlen, BYTE* pByte, UINT uSize);


// Dialog box call back functions

INT_PTR CALLBACK EudcLoadLinkWDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK EudcUnLoadLinkWDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ShowGetStringBitMapAProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ShowGetStringBitMapWProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\enum.c ===
#include <windows.h>
#include <commdlg.h>

#include <malloc.h>
#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include "fonttest.h"
#include "enum.h"

#include "dialogs.h"


typedef struct _VALUETEXT
          {
           int  Value;
           char *pszValue;
          } VALUETEXT, *PVALUETEXT, FAR *LPVALUETEXT;



VALUETEXT aWeights[] =
            {
             { FW_DONTCARE,   "FW_DONTCARE"   },
             { FW_THIN,       "FW_THIN"       },
             { FW_EXTRALIGHT, "FW_EXTRALIGHT" },
             { FW_LIGHT,      "FW_LIGHT"      },
             { FW_NORMAL,     "FW_NORMAL"     },
             { FW_MEDIUM,     "FW_MEDIUM"     },
             { FW_SEMIBOLD,   "FW_SEMIBOLD"   },
             { FW_BOLD,       "FW_BOLD"       },
             { FW_EXTRABOLD,  "FW_EXTRABOLD"  },
             { FW_HEAVY,      "FW_HEAVY"      },
             { 0,             0               }
            };

VALUETEXT aCharSet[] =
            {
             { DEFAULT_CHARSET,  "DEFAULT_CHARSET"  },
             { ANSI_CHARSET,     "ANSI_CHARSET"     },
             { SYMBOL_CHARSET,   "SYMBOL_CHARSET"   },
             { SHIFTJIS_CHARSET, "SHIFTJIS_CHARSET" },
             { OEM_CHARSET,      "OEM_CHARSET"      },
        { HANGEUL_CHARSET,  "HANGEUL_CHARSET"  },
        { GB2312_CHARSET,   "GB2312_CHARSET"   },
        { CHINESEBIG5_CHARSET, "CHINESEBIG5_CHARSET" },
        { JOHAB_CHARSET,    "JOHAB_CHARSET" },
        { HEBREW_CHARSET,   "HEBREW_CHARSET" },
        { ARABIC_CHARSET,   "ARABIC_CHARSET" },
        { GREEK_CHARSET,    "GREEK_CHARSET" },
        { TURKISH_CHARSET,  "TURKISH_CHARSET" },
        { THAI_CHARSET,     "THAI_CHARSET" },
        { EASTEUROPE_CHARSET,  "EASTEUROPE_CHARSET" },
        { RUSSIAN_CHARSET,     "RUSSIAN_CHARSET" },
        { MAC_CHARSET,      "MAC_CHARSET" },
        { BALTIC_CHARSET,   "BALTIC_CHARSET" },
        { VIETNAMESE_CHARSET, "VIETNAMESE_CHARSET"},
        { 0,                0                  }
            };

VALUETEXT aOutPrecision[] =
            {
             { OUT_DEFAULT_PRECIS,         "OUT_DEFAULT_PRECIS"   },
             { OUT_STRING_PRECIS,          "OUT_STRING_PRECIS"    },
             { OUT_CHARACTER_PRECIS,       "OUT_CHARACTER_PRECIS" },
             { OUT_STROKE_PRECIS,          "OUT_STROKE_PRECIS"    },
             { OUT_TT_PRECIS,              "OUT_TT_PRECIS"        },
             { OUT_DEVICE_PRECIS,          "OUT_DEVICE_PRECIS"    },
             { OUT_RASTER_PRECIS,          "OUT_RASTER_PRECIS"    },
             { OUT_TT_ONLY_PRECIS,         "OUT_TT_ONLY_PRECIS"   },
             { OUT_OUTLINE_PRECIS,         "OUT_OUTLINE_PRECIS"   },
             { OUT_SCREEN_OUTLINE_PRECIS,  "OUT_SCREEN_OUTLINE_PRECIS"},
             { OUT_PS_ONLY_PRECIS,         "OUT_PS_ONLY_PRECIS"   },
             { 0,                    0                      }
            };

VALUETEXT aClipPrecision[] =
            {
             { CLIP_DEFAULT_PRECIS,   "CLIP_DEFAULT_PRECIS"   },
             { CLIP_CHARACTER_PRECIS, "CLIP_CHARACTER_PRECIS" },
             { CLIP_STROKE_PRECIS,    "CLIP_STROKE_PRECIS"    },
//             { CLIP_MASK,             "CLIP_MASK"             },
//             { CLIP_LH_ANGLES,        "CLIP_LH_ANGLES"        },
//             { CLIP_TT_ALWAYS,        "CLIP_TT_ALWAYS"        },
//             { CLIP_ENCAPSULATE,      "CLIP_ENCAPSULATE"      },
             { 0,                     0                         }
            };

VALUETEXT aQuality[] =
            {
             { DEFAULT_QUALITY,  "DEFAULT_QUALITY"  },
             { DRAFT_QUALITY,    "DRAFT_QUALITY"    },
             { PROOF_QUALITY,    "PROOF_QUALITY"    },
             { NONANTIALIASED_QUALITY,  "NONANTIALIASED_QUALITY"},
             { ANTIALIASED_QUALITY,     "ANTIALIASED_QUALITY"   },
             { CLEARTYPE_QUALITY,       "CLEARTYPE_QUALITY"   },
             { 0,                0                  }
            };

VALUETEXT aPitch[] =
            {
             { DEFAULT_PITCH,  "DEFAULT_PITCH"  },
             { FIXED_PITCH,    "FIXED_PITCH"    },
             { VARIABLE_PITCH, "VARIABLE_PITCH" },
             { 0,              0                }
            };

VALUETEXT aFamily[] =
            {
             { FF_DONTCARE,   "FF_DONTCARE"   },
             { FF_ROMAN,      "FF_ROMAN"      },
             { FF_SWISS,      "FF_SWISS"      },
             { FF_MODERN,     "FF_MODERN"     },
             { FF_SCRIPT,     "FF_SCRIPT"     },
             { FF_DECORATIVE, "FF_DECORATIVE" },
             { 0,             0               }
            };




//*****************************************************************************
//*********************   F I L L   C O M B O   B O X   ***********************
//*****************************************************************************

void FillComboBox( HWND hdlg, int id, PVALUETEXT apv, int iSelValue )
 {
  int  i, Index;
  char szText[32];


  Index = -1;
  for( i = 0; apv[i].pszValue; i++ )
   {
    SendDlgItemMessage( hdlg, id, CB_ADDSTRING, 0, (LPARAM)(LPSTR)apv[i].pszValue );
    if( apv[i].Value == iSelValue ) Index = i;
   }

  if( Index != -1 )
    {
     SendDlgItemMessage( hdlg, id, CB_SETCURSEL, (WPARAM)Index, 0);
    }
   else
    {
     wsprintf( szText, "0x%.4X", iSelValue );
     SendDlgItemMessage( hdlg, id, WM_SETTEXT, 0, (LPARAM)(LPSTR)szText );
    }
 }


//*****************************************************************************
//************   G E T   C O M B O   B O X   S E L E C T I O N   **************
//*****************************************************************************

int GetComboBoxSelection( HWND hdlg, int id, PVALUETEXT apv )
 {
  DWORD dwIndex;
  char  szText[32];



  dwIndex = (DWORD)SendDlgItemMessage( hdlg, id, CB_GETCURSEL, 0, 0);

  if( dwIndex != CB_ERR )
    {
     return apv[dwIndex].Value;
    }
   else
    {
     SendDlgItemMessage( hdlg, id, WM_GETTEXT, sizeof(szText), (LPARAM)(LPSTR)szText );
     return (int)strtol( szText, NULL, 0 );
    }

  return 0;
 }


//*****************************************************************************
//*******************   G E T   E D I T   I N T E G E R   *********************
//*****************************************************************************

int GetEditInteger( HWND hdlg, int id )
 {
  char szText[32];

  GetDlgItemText( hdlg, id, (LPSTR)szText, sizeof(szText) );
  return (int)strtol( szText, NULL, 0 );
 }



//*****************************************************************************
//***************   C R E A T E   F O N T   D L G   P R O C   *****************
//*****************************************************************************

INT_PTR CALLBACK CreateFontDlgProcA( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
 {
  BYTE lfClip, lfPitch, lfFamily;
  UINT  iNumAxes;

  switch( msg )
   {
    case WM_INITDIALOG:
              SetDlgItemInt( hdlg, IDD_NHEIGHT,      elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight,      TRUE );
              SetDlgItemInt( hdlg, IDD_NWIDTH,       elfdvA.elfEnumLogfontEx.elfLogFont.lfWidth,       TRUE );
              SetDlgItemInt( hdlg, IDD_NESCAPEMENT,  elfdvA.elfEnumLogfontEx.elfLogFont.lfEscapement,  TRUE );
              SetDlgItemInt( hdlg, IDD_NORIENTATION, elfdvA.elfEnumLogfontEx.elfLogFont.lfOrientation, TRUE );
              SetDlgItemInt( hdlg, IDD_NWEIGHT,      elfdvA.elfEnumLogfontEx.elfLogFont.lfWeight,      TRUE );

              SendDlgItemMessage( hdlg, IDD_ITALIC,    BM_SETCHECK, elfdvA.elfEnumLogfontEx.elfLogFont.lfItalic,    0 );
              SendDlgItemMessage( hdlg, IDD_UNDERLINE, BM_SETCHECK, elfdvA.elfEnumLogfontEx.elfLogFont.lfUnderline, 0 );
              SendDlgItemMessage( hdlg, IDD_STRIKEOUT, BM_SETCHECK, elfdvA.elfEnumLogfontEx.elfLogFont.lfStrikeOut, 0 );
 
              FillComboBox( hdlg, IDD_NWEIGHT,       aWeights,       (WORD)elfdvA.elfEnumLogfontEx.elfLogFont.lfWeight        );

              FillComboBox( hdlg, IDD_CHARSET,       aCharSet,       (WORD)elfdvA.elfEnumLogfontEx.elfLogFont.lfCharSet       );
              FillComboBox( hdlg, IDD_OUTPUTPRECISION,  aOutPrecision,  (WORD)elfdvA.elfEnumLogfontEx.elfLogFont.lfOutPrecision  );

              lfClip = elfdvA.elfEnumLogfontEx.elfLogFont.lfClipPrecision;
              FillComboBox( hdlg, IDD_CLIPPRECISION, aClipPrecision, (WORD)(lfClip & CLIP_MASK) );
              CheckDlgButton( hdlg, IDD_CLIP_ENCAPSULATE, lfClip & CLIP_EMBEDDED  );
              CheckDlgButton( hdlg, IDD_CLIP_LH_ANGLES,   lfClip & CLIP_LH_ANGLES );
              CheckDlgButton( hdlg, IDD_CLIP_TT_ALWAYS,   lfClip & CLIP_TT_ALWAYS );


              FillComboBox( hdlg, IDD_QUALITY,       aQuality,       (WORD)elfdvA.elfEnumLogfontEx.elfLogFont.lfQuality       );

              lfPitch  = elfdvA.elfEnumLogfontEx.elfLogFont.lfPitchAndFamily & (BYTE)0x0F;
              FillComboBox( hdlg, IDD_PITCH, aPitch, (WORD)(lfPitch & 0x03) );
              CheckDlgButton( hdlg, IDD_PITCH_TT, lfPitch & 0x04 );

              lfFamily = elfdvA.elfEnumLogfontEx.elfLogFont.lfPitchAndFamily & (BYTE)0xF0;
              FillComboBox( hdlg, IDD_FAMILY, aFamily, (WORD)lfFamily );

              SetDlgItemText( hdlg, IDD_LPFAMILY, elfdvA.elfEnumLogfontEx.elfLogFont.lfFaceName );

              SetDlgItemInt ( hdlg, IDC_NUMEDITAXES, elfdvA.elfDesignVector.dvNumAxes,     TRUE );

              if (elfdvA.elfDesignVector.dvNumAxes > 0)
              {
                 SetDlgItemInt ( hdlg, IDC_TAGVALUE1, elfdvA.elfDesignVector.dvValues[0],  TRUE );
                 SetDlgItemInt ( hdlg, IDC_TAGVALUE2, elfdvA.elfDesignVector.dvValues[1],  TRUE );
                 SetDlgItemInt ( hdlg, IDC_TAGVALUE3, elfdvA.elfDesignVector.dvValues[2],  TRUE );
                 SetDlgItemInt ( hdlg, IDC_TAGVALUE4, elfdvA.elfDesignVector.dvValues[3],  TRUE );
              }

              return TRUE;


    case WM_COMMAND:
              switch( LOWORD(wParam ) )
               {
                case IDD_OK:
                       elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight      = GetEditInteger( hdlg, IDD_NHEIGHT      );
                       elfdvA.elfEnumLogfontEx.elfLogFont.lfWidth       = GetEditInteger( hdlg, IDD_NWIDTH       );
                       elfdvA.elfEnumLogfontEx.elfLogFont.lfEscapement  = GetEditInteger( hdlg, IDD_NESCAPEMENT  );
                       elfdvA.elfEnumLogfontEx.elfLogFont.lfOrientation = GetEditInteger( hdlg, IDD_NORIENTATION );

                       elfdvA.elfEnumLogfontEx.elfLogFont.lfWeight      = GetComboBoxSelection( hdlg, IDD_NWEIGHT, aWeights );

                       elfdvA.elfEnumLogfontEx.elfLogFont.lfItalic    = (BYTE)SendDlgItemMessage( hdlg, IDD_ITALIC,    BM_GETCHECK, 0, 0 );
                       elfdvA.elfEnumLogfontEx.elfLogFont.lfUnderline = (BYTE)SendDlgItemMessage( hdlg, IDD_UNDERLINE, BM_GETCHECK, 0, 0 );
                       elfdvA.elfEnumLogfontEx.elfLogFont.lfStrikeOut = (BYTE)SendDlgItemMessage( hdlg, IDD_STRIKEOUT, BM_GETCHECK, 0, 0 );

                       elfdvA.elfEnumLogfontEx.elfLogFont.lfCharSet       = (BYTE)GetComboBoxSelection( hdlg, IDD_CHARSET,      aCharSet       );
                       elfdvA.elfEnumLogfontEx.elfLogFont.lfOutPrecision  = (BYTE)GetComboBoxSelection( hdlg, IDD_OUTPUTPRECISION,  aOutPrecision  );

                       lfClip = (BYTE)GetComboBoxSelection( hdlg, IDD_CLIPPRECISION, aClipPrecision );
                       lfClip |= (IsDlgButtonChecked(hdlg, IDD_CLIP_ENCAPSULATE) ? CLIP_EMBEDDED  : 0);
                       lfClip |= (IsDlgButtonChecked(hdlg, IDD_CLIP_LH_ANGLES)   ? CLIP_LH_ANGLES : 0);
                       lfClip |= (IsDlgButtonChecked(hdlg, IDD_CLIP_TT_ALWAYS)   ? CLIP_TT_ALWAYS : 0);
                       elfdvA.elfEnumLogfontEx.elfLogFont.lfClipPrecision = lfClip;

                       elfdvA.elfEnumLogfontEx.elfLogFont.lfQuality = (BYTE)GetComboBoxSelection( hdlg, IDD_QUALITY, aQuality );

                       lfPitch = (BYTE)GetComboBoxSelection( hdlg, IDD_PITCH, aPitch );
                       lfPitch |= (IsDlgButtonChecked(hdlg, IDD_PITCH_TT) ? 0x04 : 0);

                       lfFamily = (BYTE)GetComboBoxSelection( hdlg, IDD_FAMILY, aFamily );

                       elfdvA.elfEnumLogfontEx.elfLogFont.lfPitchAndFamily = lfPitch | lfFamily;

                       GetDlgItemText( hdlg, IDD_LPFAMILY, elfdvA.elfEnumLogfontEx.elfLogFont.lfFaceName, 
                           sizeof(elfdvA.elfEnumLogfontEx.elfLogFont.lfFaceName ) );

                       iNumAxes = GetEditInteger( hdlg, IDC_NUMEDITAXES);                       
                       elfdvA.elfDesignVector.dvNumAxes = iNumAxes;

                       if (iNumAxes)
                       {
                            UINT i;

                            for (i = 0; i < iNumAxes; i++)
                            {
                                elfdvA.elfDesignVector.dvValues[i] =
                                    (LONG) GetEditInteger( hdlg, IDC_TAGVALUE1 + i*2 );
                            }

                            dprintf("Information on DV:");
                            dprintf("Number of axes = %d", elfdvA.elfDesignVector.dvNumAxes);
                            dprintf("Axes Values: %d %d %d %d",
                                    elfdvA.elfDesignVector.dvValues[0],
                                    elfdvA.elfDesignVector.dvValues[1],
                                    elfdvA.elfDesignVector.dvValues[2],
                                    elfdvA.elfDesignVector.dvValues[3]);
                       }

                       SyncElfdvAtoW (&elfdvW, &elfdvA);

                       EndDialog( hdlg, TRUE );
                       return TRUE;

                case IDCANCEL:
                case IDD_CANCEL:
                       EndDialog( hdlg, FALSE );
                       return TRUE;
               }

              break;


    case WM_CLOSE:
              EndDialog( hdlg, FALSE );
              return TRUE;
   }

  return FALSE;
 }

//*****************************************************************************
//***************   C R E A T E   F O N T   D L G   P R O C   *****************
//*****************************************************************************

INT_PTR CALLBACK CreateFontDlgProcW( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
 {
  BYTE lfClip, lfPitch, lfFamily;
  UINT  iNumAxes;

  switch( msg )
   {
    case WM_INITDIALOG:
              SetDlgItemInt( hdlg, IDD_NHEIGHT,      elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight,      TRUE );
              SetDlgItemInt( hdlg, IDD_NWIDTH,       elfdvW.elfEnumLogfontEx.elfLogFont.lfWidth,       TRUE );
              SetDlgItemInt( hdlg, IDD_NESCAPEMENT,  elfdvW.elfEnumLogfontEx.elfLogFont.lfEscapement,  TRUE );
              SetDlgItemInt( hdlg, IDD_NORIENTATION, elfdvW.elfEnumLogfontEx.elfLogFont.lfOrientation, TRUE );
              SetDlgItemInt( hdlg, IDD_NWEIGHT,      elfdvW.elfEnumLogfontEx.elfLogFont.lfWeight,      TRUE );

              SendDlgItemMessage( hdlg, IDD_ITALIC,    BM_SETCHECK, elfdvW.elfEnumLogfontEx.elfLogFont.lfItalic,    0 );
              SendDlgItemMessage( hdlg, IDD_UNDERLINE, BM_SETCHECK, elfdvW.elfEnumLogfontEx.elfLogFont.lfUnderline, 0 );
              SendDlgItemMessage( hdlg, IDD_STRIKEOUT, BM_SETCHECK, elfdvW.elfEnumLogfontEx.elfLogFont.lfStrikeOut, 0 );

              FillComboBox( hdlg, IDD_NWEIGHT,       aWeights,       (WORD)elfdvW.elfEnumLogfontEx.elfLogFont.lfWeight        );

              FillComboBox( hdlg, IDD_CHARSET,       aCharSet,       (WORD)elfdvW.elfEnumLogfontEx.elfLogFont.lfCharSet       );
              FillComboBox( hdlg, IDD_OUTPUTPRECISION,  aOutPrecision,  (WORD)elfdvW.elfEnumLogfontEx.elfLogFont.lfOutPrecision  );

              lfClip = elfdvW.elfEnumLogfontEx.elfLogFont.lfClipPrecision;
              FillComboBox( hdlg, IDD_CLIPPRECISION, aClipPrecision, (WORD)(lfClip & CLIP_MASK) );
              CheckDlgButton( hdlg, IDD_CLIP_ENCAPSULATE, lfClip & CLIP_EMBEDDED  );
              CheckDlgButton( hdlg, IDD_CLIP_LH_ANGLES,   lfClip & CLIP_LH_ANGLES );
              CheckDlgButton( hdlg, IDD_CLIP_TT_ALWAYS,   lfClip & CLIP_TT_ALWAYS );


              FillComboBox( hdlg, IDD_QUALITY,       aQuality,       (WORD)elfdvW.elfEnumLogfontEx.elfLogFont.lfQuality       );

              lfPitch  = elfdvW.elfEnumLogfontEx.elfLogFont.lfPitchAndFamily & (BYTE)0x0F;
              FillComboBox( hdlg, IDD_PITCH, aPitch, (WORD)(lfPitch & 0x03) );
              CheckDlgButton( hdlg, IDD_PITCH_TT, lfPitch & 0x04 );

              lfFamily = elfdvW.elfEnumLogfontEx.elfLogFont.lfPitchAndFamily & (BYTE)0xF0;
              FillComboBox( hdlg, IDD_FAMILY, aFamily, (WORD)lfFamily );

              SetDlgItemTextW( hdlg, IDD_LPFAMILY, elfdvW.elfEnumLogfontEx.elfLogFont.lfFaceName );

              SetDlgItemInt ( hdlg, IDC_NUMEDITAXES, elfdvW.elfDesignVector.dvNumAxes,     TRUE );

              if (elfdvW.elfDesignVector.dvNumAxes > 0)
              {
                 SetDlgItemInt ( hdlg, IDC_TAGVALUE1, elfdvW.elfDesignVector.dvValues[0],  TRUE );
                 SetDlgItemInt ( hdlg, IDC_TAGVALUE2, elfdvW.elfDesignVector.dvValues[1],  TRUE );
                 SetDlgItemInt ( hdlg, IDC_TAGVALUE3, elfdvW.elfDesignVector.dvValues[2],  TRUE );
                 SetDlgItemInt ( hdlg, IDC_TAGVALUE4, elfdvW.elfDesignVector.dvValues[3],  TRUE );
              }

              return TRUE;


    case WM_COMMAND:
              switch( LOWORD(wParam ) )
               {
                case IDD_OK:
                       elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight      = GetEditInteger( hdlg, IDD_NHEIGHT      );
                       elfdvW.elfEnumLogfontEx.elfLogFont.lfWidth       = GetEditInteger( hdlg, IDD_NWIDTH       );
                       elfdvW.elfEnumLogfontEx.elfLogFont.lfEscapement  = GetEditInteger( hdlg, IDD_NESCAPEMENT  );
                       elfdvW.elfEnumLogfontEx.elfLogFont.lfOrientation = GetEditInteger( hdlg, IDD_NORIENTATION );

                       elfdvW.elfEnumLogfontEx.elfLogFont.lfWeight      = GetComboBoxSelection( hdlg, IDD_NWEIGHT, aWeights );

                       elfdvW.elfEnumLogfontEx.elfLogFont.lfItalic    = (BYTE)SendDlgItemMessage( hdlg, IDD_ITALIC,    BM_GETCHECK, 0, 0 );
                       elfdvW.elfEnumLogfontEx.elfLogFont.lfUnderline = (BYTE)SendDlgItemMessage( hdlg, IDD_UNDERLINE, BM_GETCHECK, 0, 0 );
                       elfdvW.elfEnumLogfontEx.elfLogFont.lfStrikeOut = (BYTE)SendDlgItemMessage( hdlg, IDD_STRIKEOUT, BM_GETCHECK, 0, 0 );

                       elfdvW.elfEnumLogfontEx.elfLogFont.lfCharSet       = (BYTE)GetComboBoxSelection( hdlg, IDD_CHARSET,      aCharSet       );
                       elfdvW.elfEnumLogfontEx.elfLogFont.lfOutPrecision  = (BYTE)GetComboBoxSelection( hdlg, IDD_OUTPUTPRECISION,  aOutPrecision  );

                       lfClip = (BYTE)GetComboBoxSelection( hdlg, IDD_CLIPPRECISION, aClipPrecision );
                       lfClip |= (IsDlgButtonChecked(hdlg, IDD_CLIP_ENCAPSULATE) ? CLIP_EMBEDDED  : 0);
                       lfClip |= (IsDlgButtonChecked(hdlg, IDD_CLIP_LH_ANGLES)   ? CLIP_LH_ANGLES : 0);
                       lfClip |= (IsDlgButtonChecked(hdlg, IDD_CLIP_TT_ALWAYS)   ? CLIP_TT_ALWAYS : 0);
                       elfdvW.elfEnumLogfontEx.elfLogFont.lfClipPrecision = lfClip;

                       elfdvW.elfEnumLogfontEx.elfLogFont.lfQuality = (BYTE)GetComboBoxSelection( hdlg, IDD_QUALITY, aQuality );

                       lfPitch = (BYTE)GetComboBoxSelection( hdlg, IDD_PITCH, aPitch );
                       lfPitch |= (IsDlgButtonChecked(hdlg, IDD_PITCH_TT) ? 0x04 : 0);

                       lfFamily = (BYTE)GetComboBoxSelection( hdlg, IDD_FAMILY, aFamily );

                       elfdvW.elfEnumLogfontEx.elfLogFont.lfPitchAndFamily = lfPitch | lfFamily;

                       GetDlgItemTextW( hdlg, IDD_LPFAMILY, elfdvW.elfEnumLogfontEx.elfLogFont.lfFaceName, 
                           sizeof(elfdvW.elfEnumLogfontEx.elfLogFont.lfFaceName ) );

                       iNumAxes = GetEditInteger( hdlg, IDC_NUMEDITAXES);                       
                       elfdvW.elfDesignVector.dvNumAxes = iNumAxes;

                       if (iNumAxes)
                       {
                            UINT i;

                            for (i = 0; i < iNumAxes; i++)
                            {
                                elfdvW.elfDesignVector.dvValues[i] =
                                    (LONG) GetEditInteger( hdlg, IDC_TAGVALUE1 + i*2 );
                            }

                            dprintf("Information on DV:");
                            dprintf("Number of axes = %d", elfdvW.elfDesignVector.dvNumAxes);
                            dprintf("Axes Values: %d %d %d %d",
                                    elfdvW.elfDesignVector.dvValues[0],
                                    elfdvW.elfDesignVector.dvValues[1],
                                    elfdvW.elfDesignVector.dvValues[2],
                                    elfdvW.elfDesignVector.dvValues[3]);
                       }

                       SyncElfdvWtoA (&elfdvA, &elfdvW);

                       EndDialog( hdlg, TRUE );
                       return TRUE;

                case IDCANCEL:
                case IDD_CANCEL:
                       EndDialog( hdlg, FALSE );
                       return TRUE;
               }

              break;


    case WM_CLOSE:
              EndDialog( hdlg, FALSE );
              return TRUE;
   }

  return FALSE;
 }


//*****************************************************************************
//********************   E N U M   F O N T S   P R O C   **********************
//*****************************************************************************


#define SIZEOFDESIGNVECTOR(cAxes) (sizeof(DESIGNVECTOR) + ((cAxes) - 1) * sizeof(LONG))
#define SIZEOFAXESLISTA(cAxes) (sizeof(AXESLISTA) + ((cAxes) - 1) * sizeof(AXISINFOA))
#define ALIGN4(X) (((X) + 3) & ~3)

#define MAX_FONTS  7000


char *pszWeights[] =
      {
       "Regular ",
       "Thin ",
       "Extra Light ",
       "Light ",
       "Regular ",
       "Medium ",
       "SemiBold ",
       "Bold ",
       "ExtraBold ",
       "Heavy "
      };



BOOL         bUseEnumFontFamilies;
BOOL         bUseEnumFontFamiliesEx;

HWND         hdlgEnum;

int          nFonts;

short             anFontType[MAX_FONTS];
ENUMLOGFONTEX    *alpLogFont[MAX_FONTS];
NEWTEXTMETRICEX  *alpTextMetric[MAX_FONTS];


int CALLBACK DlgEnumFontsProc( LPLOGFONT lplf, LPTEXTMETRIC lptm, short sFontType, LPSTR lpstr )
 {
  static char szName[128];
  ENUMLOGFONTEXDVA* pelfex = (ENUMLOGFONTEXDVA *)lplf;
  ENUMTEXTMETRICA * petm = (ENUMTEXTMETRICA *)lptm;

  DWORD          cjDV = 0;
  DWORD          cjAL = 0;
  DESIGNVECTOR  *pdv;
  DWORD          cAxes;
  AXESLISTA     *paxla;
  DWORD          cNumAxes;


  if( nFonts >= MAX_FONTS )
   {
    dprintf( "Too many fonts enumerated (>%d), choke...", MAX_FONTS );
    return 0;
   }

   pdv = &pelfex->elfDesignVector;
   cAxes = pdv->dvNumAxes;

   if (cAxes > MAX_AXES)
       cAxes = MAX_AXES;

   cjDV = SIZEOFDESIGNVECTOR(cAxes);

   paxla = &petm->etmAxesList;
   cNumAxes = paxla->axlNumAxes;
   if (cNumAxes > MAX_AXES)
       cNumAxes = MAX_AXES;
   cjAL = SIZEOFAXESLISTA(cNumAxes);


  anFontType[nFonts]      = sFontType;
  alpLogFont[nFonts]     = (ENUMLOGFONTEX*)malloc(sizeof(ENUMLOGFONTEXA) + cjDV);
  alpTextMetric[nFonts]  = (NEWTEXTMETRICEX*)malloc(sizeof(NEWTEXTMETRICEXA) + cjAL);

  if (alpLogFont[nFonts] && alpTextMetric[nFonts])
  {
    memcpy(alpLogFont[nFonts], pelfex, sizeof(ENUMLOGFONTEXA) + cjDV);

    lstrcpy( szName, pelfex->elfEnumLogfontEx.elfFullName );

    memcpy(alpTextMetric[nFonts], petm, sizeof(NEWTEXTMETRICEXA) + cjAL);
  }
  else
  {
    dprintf("alloc failed,alpLogFont[%d] = 0x%lx, cj=%ld, alpTextMetric[%d] = 0x%lx, cj=%ld",
        nFonts, alpLogFont[nFonts], sizeof(ENUMLOGFONTEXA) + cjDV,
        nFonts, alpTextMetric[nFonts], sizeof(NEWTEXTMETRICEXA) + cjAL);
  }

  SendDlgItemMessage( hdlgEnum, IDD_FONTS, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szName );

  nFonts++;

  return 1;
}


//*****************************************************************************
//********************   F R E E   E N U M   I N F O   ************************
//*****************************************************************************

void FreeEnumInfo( void )
 {
  int i;


  nFonts = 0;

  for( i = 0; i < MAX_FONTS; i++ )
   {
    anFontType[i] = 0;

    if( alpLogFont[i] )
     {
      free( alpLogFont[i] );
      alpLogFont[i] = NULL;
     }

    if( alpTextMetric[i] )
     {
      free( alpTextMetric[i] );
      alpTextMetric[i] = NULL;
     }

   }
 }


//*****************************************************************************
//**********************   F I L L   M E T R I C S   **************************
//*****************************************************************************

ENUMLOGFONTEX lfDud;    // Sleazy, but works perfectly
NEWTEXTMETRIC tmDud;


void FillMetrics( HWND hdlg, WORD wSel )
 {
  LPLOGFONT    lplf;
  LPTEXTMETRIC lptm;
  char         szText[128];
  DESIGNVECTOR *pdv;
  DWORD         flType;
  AXESLISTA    *paxla;


  lplf = (LPLOGFONT)alpLogFont[wSel];
  if( !lplf )
  {
      lplf = (LPLOGFONT)&lfDud;
      flType  = 0;
  }
  else
    flType = anFontType[wSel];

  lptm = (LPTEXTMETRIC)alpTextMetric[wSel]; if( !lptm ) lptm = (LPTEXTMETRIC)&tmDud;

  sprintf( szText, "0x%lx:%s%s%s",
                     anFontType[wSel],
                     (anFontType[wSel] & RASTER_FONTTYPE) ? "RASTER_FONTTYPE " : "",
                     (anFontType[wSel] & DEVICE_FONTTYPE) ? "DEVICE_FONTTYPE " : "",
                     (anFontType[wSel] & TRUETYPE_FONTTYPE) ? "TRUETYPE_FONTTYPE": ""
                     );
  SetDlgItemText( hdlg, IDD_NFONTTYPE, szText );

//---------------------  Fill In LOGFONT Information  -------------------------

  sprintf( szText, "%d", lplf->lfHeight );
  SetDlgItemText( hdlg, IDD_LFHEIGHT, szText );

  sprintf( szText, "%d", lplf->lfWidth );
  SetDlgItemText( hdlg, IDD_LFWIDTH, szText );

  sprintf( szText, "%d", lplf->lfEscapement );
  SetDlgItemText( hdlg, IDD_LFESCAPEMENT, szText );

  sprintf( szText, "%d", lplf->lfOrientation );
  SetDlgItemText( hdlg, IDD_LFORIENTATION, szText );

  sprintf( szText, "%d", lplf->lfWeight );
  SetDlgItemText( hdlg, IDD_LFWEIGHT, szText );

  sprintf( szText, "%d", lplf->lfItalic );
  SetDlgItemText( hdlg, IDD_LFITALIC, szText );

  sprintf( szText, "%d", lplf->lfUnderline );
  SetDlgItemText( hdlg, IDD_LFUNDERLINE, szText );

  sprintf( szText, "%d", lplf->lfStrikeOut );
  SetDlgItemText( hdlg, IDD_LFSTRIKEOUT, szText );

  sprintf( szText, "%d", lplf->lfCharSet );
  SetDlgItemText( hdlg, IDD_LFCHARSET, szText );

  sprintf( szText, "%d", lplf->lfOutPrecision );
  SetDlgItemText( hdlg, IDD_LFOUTPRECISION, szText );

  sprintf( szText, "%d", lplf->lfClipPrecision );
  SetDlgItemText( hdlg, IDD_LFCLIPPRECISION, szText );

  sprintf( szText, "%d", lplf->lfQuality );
  SetDlgItemText( hdlg, IDD_LFQUALITY, szText );

  sprintf( szText, "0x%.2X", lplf->lfPitchAndFamily );
  SetDlgItemText( hdlg, IDD_LFPITCHANDFAMILY, szText );

  SetDlgItemText( hdlg, IDD_LFFACENAME, lplf->lfFaceName );

  SetDlgItemText( hdlg, IDD_ELFFULLNAME, ((ENUMLOGFONTEX *)lplf)->elfFullName );
  SetDlgItemText( hdlg, IDD_ELFSTYLE,    ((ENUMLOGFONTEX *)lplf)->elfStyle );
  SetDlgItemText( hdlg, IDD_ELFSCRIPT, ((ENUMLOGFONTEX *)lplf)->elfScript );

  {
     DWORD iAxes;
     DWORD cAxes;

     // if (((NEWTEXTMETRIC *)lptm)->ntmFlags & NTM_MM_INSTANCE)
     {
        pdv = (DESIGNVECTOR*)((BYTE *)lplf + sizeof(ENUMLOGFONTEXA));
        cAxes  = pdv->dvNumAxes;
        if (pdv->dvNumAxes > MAX_AXES)
            cAxes = MAX_AXES;

        sprintf(szText, "0X%lx", pdv->dvReserved);
        SetDlgItemText( hdlg, IDD_DVRESERVED, szText );
        sprintf(szText, "%ld", pdv->dvNumAxes);
        SetDlgItemText( hdlg, IDD_DVNUMAXES, szText );

        for (iAxes = 0; iAxes < cAxes; iAxes++)
        {
            szText[0] = 0;
            szText[1] = 0;
            szText[2] = 0;
            szText[3] = 0;
            szText[4] = 0;
            SetDlgItemText( hdlg, IDD_TAG0 + 2*iAxes, szText );
            sprintf(szText, "%ld",pdv->dvValues[iAxes]);
            SetDlgItemText( hdlg, IDD_VALUE0 + 2*iAxes, szText );
        }

        // clean the rest:

        strcpy(szText, "n/a");
        for (iAxes = cAxes; iAxes < MAX_AXES; iAxes++)
        {
            SetDlgItemText( hdlg, IDD_TAG0 + 2*iAxes, szText );
            SetDlgItemText( hdlg, IDD_VALUE0 + 2*iAxes, szText );
        }
     }

     // if (((NEWTEXTMETRIC *)lptm)->ntmFlags & NTM_MULTIPLEMASTER)
     {
         paxla = (AXESLISTA *)((BYTE *)lptm + ALIGN4(sizeof(NEWTEXTMETRICEX)));
         cAxes = paxla->axlNumAxes;
         if (paxla->axlNumAxes > MAX_AXES)
            cAxes = MAX_AXES;

         sprintf(szText, "0X%lx", paxla->axlReserved);
         SetDlgItemText( hdlg, IDD_AXLRESERVED, szText );
         sprintf(szText, "%ld", paxla->axlNumAxes);
         SetDlgItemText( hdlg, IDD_AXLNUMAXES, szText );

        for (iAxes = 0; iAxes < cAxes; iAxes++)
        {
            szText[0] = 0;
            szText[1] = 0;
            szText[2] = 0;
            szText[3] = 0;
            szText[4] = 0;
            SetDlgItemText( hdlg, IDD_AXTAG0 + 5*iAxes, szText );

            sprintf(szText, "%ld",paxla->axlAxisInfo[iAxes].axMinValue);
            SetDlgItemText( hdlg, IDD_AXMINVAL0 + 5*iAxes, szText );

            sprintf(szText, "%ld",paxla->axlAxisInfo[iAxes].axMaxValue);
            SetDlgItemText( hdlg, IDD_AXMAXVAL0 + 5*iAxes, szText );

            SetDlgItemText( hdlg, IDD_AXNAME0 + 5*iAxes,
                            paxla->axlAxisInfo[iAxes].axAxisName);


        }

        // clean the rest

        strcpy(szText, "n/a");
        for (iAxes = cAxes; iAxes < MAX_AXES; iAxes++)
        {
            SetDlgItemText( hdlg, IDD_AXTAG0    + 5*iAxes, szText );
            SetDlgItemText( hdlg, IDD_AXMINVAL0 + 5*iAxes, szText );
            SetDlgItemText( hdlg, IDD_AXMAXVAL0 + 5*iAxes, szText );
            SetDlgItemText( hdlg, IDD_AXDEFVAL0 + 5*iAxes, szText );
            SetDlgItemText( hdlg, IDD_AXNAME0   + 5*iAxes, szText);
        }
     }
  }

//--------------------  Fill In TEXTMETRIC Information  -----------------------

  sprintf( szText, "%d", lptm->tmHeight );
  SetDlgItemText( hdlg, IDD_TMHEIGHT, szText );

  sprintf( szText, "%d", lptm->tmAscent );
  SetDlgItemText( hdlg, IDD_TMASCENT, szText );

  sprintf( szText, "%d", lptm->tmDescent );
  SetDlgItemText( hdlg, IDD_TMDESCENT, szText );

  sprintf( szText, "%d", lptm->tmInternalLeading );
  SetDlgItemText( hdlg, IDD_TMINTERNALLEADING, szText );

  sprintf( szText, "%d", lptm->tmExternalLeading );
  SetDlgItemText( hdlg, IDD_TMEXTERNALLEADING, szText );

  sprintf( szText, "%d", lptm->tmAveCharWidth );
  SetDlgItemText( hdlg, IDD_TMAVECHARWIDTH, szText );

  sprintf( szText, "%d", lptm->tmMaxCharWidth );
  SetDlgItemText( hdlg, IDD_TMMAXCHARWIDTH, szText );

  sprintf( szText, "%d", lptm->tmWeight );
  SetDlgItemText( hdlg, IDD_TMWEIGHT, szText );

  sprintf( szText, "%d", lptm->tmItalic );
  SetDlgItemText( hdlg, IDD_TMITALIC, szText );

  sprintf( szText, "%d", lptm->tmUnderlined );
  SetDlgItemText( hdlg, IDD_TMUNDERLINED, szText );

  sprintf( szText, "%d", lptm->tmStruckOut );
  SetDlgItemText( hdlg, IDD_TMSTRUCKOUT, szText );

  sprintf( szText, "%d", lptm->tmFirstChar );
  SetDlgItemText( hdlg, IDD_TMFIRSTCHAR, szText );

  sprintf( szText, "%d", lptm->tmLastChar );
  SetDlgItemText( hdlg, IDD_TMLASTCHAR, szText );

  sprintf( szText, "%d", lptm->tmDefaultChar );
  SetDlgItemText( hdlg, IDD_TMDEFAULTCHAR, szText );

  sprintf( szText, "%d", lptm->tmBreakChar );
  SetDlgItemText( hdlg, IDD_TMBREAKCHAR, szText );

  sprintf( szText, "0x%.2X", lptm->tmPitchAndFamily );
  SetDlgItemText( hdlg, IDD_TMPITCHANDFAMILY, szText );

  sprintf( szText, "%d", lptm->tmCharSet );
  SetDlgItemText( hdlg, IDD_TMCHARSET, szText );

  sprintf( szText, "%d", lptm->tmOverhang );
  SetDlgItemText( hdlg, IDD_TMOVERHANG, szText );

  sprintf( szText, "%d", lptm->tmDigitizedAspectX );
  SetDlgItemText( hdlg, IDD_TMDIGITIZEDASPECTX, szText );

  sprintf( szText, "%d", lptm->tmDigitizedAspectY );
  SetDlgItemText( hdlg, IDD_TMDIGITIZEDASPECTY, szText );

  if( alpLogFont[wSel])
    {
     sprintf( szText, "0x%lx", alpTextMetric[wSel]->ntmTm.ntmFlags);
     SetDlgItemText( hdlg, IDD_NTMFLAGS, szText);

     SetDlgItemInt( hdlg, IDD_NTMSIZEEM, alpTextMetric[wSel]->ntmTm.ntmSizeEM, FALSE);
     SetDlgItemInt( hdlg, IDD_NTMCELLHEIGHT, alpTextMetric[wSel]->ntmTm.ntmCellHeight, FALSE);
     SetDlgItemInt( hdlg, IDD_NTMAVGWIDTH, alpTextMetric[wSel]->ntmTm.ntmAvgWidth, FALSE);

     sprintf(szText, "0x%lx", alpTextMetric[wSel]->ntmFontSig.fsUsb[0]);
     SetDlgItemText( hdlg, IDD_USB0, szText);
     sprintf(szText, "0x%lx", alpTextMetric[wSel]->ntmFontSig.fsUsb[1]);
     SetDlgItemText( hdlg, IDD_USB1, szText);
     sprintf(szText, "0x%lx", alpTextMetric[wSel]->ntmFontSig.fsUsb[2]);
     SetDlgItemText( hdlg, IDD_USB2, szText);
     sprintf(szText, "0x%lx", alpTextMetric[wSel]->ntmFontSig.fsUsb[3]);
     SetDlgItemText( hdlg, IDD_USB3, szText);
     sprintf(szText, "0x%lx", alpTextMetric[wSel]->ntmFontSig.fsCsb[0]);
     SetDlgItemText( hdlg, IDD_CSB0, szText);
     sprintf(szText, "0x%lx", alpTextMetric[wSel]->ntmFontSig.fsCsb[1]);
     SetDlgItemText( hdlg, IDD_CSB1, szText);

    }
  else
    {
     SetDlgItemText( hdlg, IDD_NTMFLAGS,      "n/a");
     SetDlgItemText( hdlg, IDD_NTMSIZEEM,     "n/a");
     SetDlgItemText( hdlg, IDD_NTMCELLHEIGHT, "n/a");
     SetDlgItemText( hdlg, IDD_NTMAVGWIDTH,   "n/a");

     SetDlgItemText( hdlg, IDD_USB0, "n/a");
     SetDlgItemText( hdlg, IDD_USB1, "n/a");
     SetDlgItemText( hdlg, IDD_USB2, "n/a");
     SetDlgItemText( hdlg, IDD_USB3, "n/a");
     SetDlgItemText( hdlg, IDD_CSB0, "n/a");
     SetDlgItemText( hdlg, IDD_CSB1, "n/a");
    }
 }


//*****************************************************************************
//****************   S H O W   E N U M   F O N T S   D L G   ******************
//*****************************************************************************

char szFaceName[128];

INT_PTR CALLBACK EnumFontsDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
 {
  HDC     hdc;
  FARPROC lpEnumProc;
  LPSTR   lpsz;
  int     rc;
  WORD    wSel;
  CHAR    lpszEnumFontFam[] = "EnumFontFamilies";
  CHAR    lpszEnumFontFamEx[] = "EnumFontFamiliesEx";
  LPLOGFONT lplf;

  switch( msg )
   {
    case WM_INITDIALOG:
              if( bUseEnumFontFamilies)
                SendMessage( hdlg, WM_SETTEXT, 0, (LPARAM)lpszEnumFontFam);
              else if(bUseEnumFontFamiliesEx)
                SendMessage( hdlg, WM_SETTEXT, 0, (LPARAM)lpszEnumFontFamEx);

              SetDlgItemText( hdlg, IDD_LPSZFACENAME, szFaceName );

              FillMetrics( hdlg, 0 );

              PostMessage( hdlg, WM_COMMAND, IDD_SCREENDC, 0);

              return TRUE;


    case WM_COMMAND:
              switch( LOWORD(wParam) )
               {
                case IDD_SCREENDC:
                case IDD_PRINTERDC:
                case IDD_ENUMERATE:
                       GetDlgItemText( hdlg, IDD_LPSZFACENAME, szFaceName, sizeof(szFaceName) );
                       SendDlgItemMessage( hdlg, IDD_FONTS, LB_RESETCONTENT, 0, 0 );

                       FreeEnumInfo();

                       hdlgEnum = hdlg;

                       if( SendDlgItemMessage( hdlg, IDD_SCREENDC, BM_GETCHECK, 0, 0 ) )
                         hdc = CreateDC( "DISPLAY", NULL, NULL, NULL );
                        else if( SendDlgItemMessage( hdlg, IDD_PRINTERDC, BM_GETCHECK, 0, 0 ) )
                         hdc = CreatePrinterDC();
                        else
                         hdc = CreateDC( "DISPLAY", NULL, NULL, NULL );

                       lpEnumProc = (FARPROC) MakeProcInstance( DlgEnumFontsProc, hInst );

                       dprintf( "Calling EnumFonts( '%s' )", szFaceName );

                       if( lstrlen(szFaceName) == 0 )
                         lpsz = NULL;
                        else
                         lpsz = szFaceName;

                       if( bUseEnumFontFamiliesEx )
                         {
                          BOOL  bTanslated;

                          lplf = (LPLOGFONT)malloc( sizeof(LOGFONT) );
                          lplf->lfCharSet = (BYTE)GetDlgItemInt( hdlg, IDE_CHARSET, &bTanslated, FALSE);
                          if( !bTanslated )
                            SetDlgItemInt( hdlg, IDE_CHARSET, DEFAULT_CHARSET, FALSE);
                          if(!lpsz) lplf->lfFaceName[0] = '\0';
                          else lstrcpy(lplf->lfFaceName, lpsz);
                          lplf->lfPitchAndFamily = 0;
                          rc = lpfnEnumFontFamiliesEx( hdc, lplf, (FONTENUMPROC) lpEnumProc, NULL, 0 );
                         }
                        else if( bUseEnumFontFamilies )
                          rc = lpfnEnumFontFamilies( hdc, lpsz, (FONTENUMPROC) lpEnumProc, NULL );
                         else
                          rc = EnumFonts( hdc, lpsz, (FONTENUMPROC) lpEnumProc, 0 );

                       dprintf( "  rc = %d", rc );

                       FreeProcInstance( lpEnumProc );
                       if(hdc != hdcCachedPrinter) DeleteDC( hdc );

                       FillMetrics( hdlg, 0 );
                       SendDlgItemMessage( hdlg, IDD_FONTS, LB_SETCURSEL, 0, 0 );

                       SetFocus( GetDlgItem( hdlg, IDD_FONTS ) );

                       return TRUE;


                case IDD_FONTS:
                       if( HIWORD(wParam) == LBN_SELCHANGE )
                         {
                          wSel = (WORD)SendDlgItemMessage( hdlg, IDD_FONTS, LB_GETCURSEL, 0, 0 );
                          if( wSel == 0xFFFF ) return TRUE;

                          FillMetrics( hdlg, wSel );
                         }
                        else if( HIWORD(wParam) == LBN_DBLCLK )
                         {
                          wSel = (WORD)SendDlgItemMessage( hdlg, IDD_FONTS, LB_GETCURSEL, 0, 0 );
                          if( wSel == 0xFFFF ) return TRUE;

                          SetDlgItemText( hdlg, IDD_LPSZFACENAME, alpLogFont[wSel]->elfLogFont.lfFaceName );
                          PostMessage( hdlg, WM_COMMAND, IDD_ENUMERATE, 0 );
                         }

                       return TRUE;


                case IDD_CREATEFONT:
                       wSel = (WORD)SendDlgItemMessage( hdlg, IDD_FONTS, LB_GETCURSEL, 0, 0 );
                       if( wSel == 0xFFFF ) wSel = 0;;

                       memcpy( &elfdvW.elfEnumLogfontEx.elfLogFont, alpLogFont[wSel], sizeof(LOGFONT) );

                       EndDialog( hdlg, TRUE );
                       return TRUE;


                case IDCANCEL:
                case IDD_CANCEL:
                       FreeEnumInfo();
                       EndDialog( hdlg, FALSE );
                       return TRUE;
               }

              break;


    case WM_CLOSE:
              FreeEnumInfo();
              EndDialog( hdlg, FALSE );
              return TRUE;

   }

  return FALSE;
 }


//*****************************************************************************
//********************   S H O W   E N U M   F O N T S   **********************
//*****************************************************************************

void ShowEnumFonts( HWND hwnd )
 {
  bUseEnumFontFamilies = FALSE;
  bUseEnumFontFamiliesEx = FALSE;
  ShowDialogBox( EnumFontsDlgProc, IDB_ENUMFONTS, NULL );
 }


//*****************************************************************************
//************   S H O W   E N U M   F O N T   F A M I L I E S   **************
//*****************************************************************************

void ShowEnumFontFamilies( HWND hwnd )
 {
  bUseEnumFontFamilies = TRUE;
  bUseEnumFontFamiliesEx = FALSE;
  ShowDialogBox( EnumFontsDlgProc, IDB_ENUMFONTS, NULL );
 }


//*****************************************************************************
//************ S H O W   E N U M   F O N T   F A M I L I E S E X   ************
//*****************************************************************************

void ShowEnumFontFamiliesEx( HWND hwnd )
{
 bUseEnumFontFamilies = FALSE;
 bUseEnumFontFamiliesEx = TRUE;
 ShowDialogBox( EnumFontsDlgProc, IDB_ENUMFONTS, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\eudc.c ===
//************************************************************************//
//                                                                        
// Filename :  eudc.c                                                  
//                                                                       
// Description: Code for testing various EUDC APIs. Some of the APIs
//              need user input hence the dialog-box callbacks are
//              used.
//                                                                        
// Program Model: Just calls the APIs with the input and prints out
//                the output
//                                                                                                                                                
// Created by:  Rajesh Munshi                                            
//                                                                       
// History:     Created on 08/14/97
//                                                                       
//************************************************************************//
#include <windows.h>
#include <commdlg.h>
#include <wingdi.h>

#include "fonttest.h"
#include "dialogs.h"
#include "eudc.h"


//************************************************************************//
//                                                                        
// Function :  ShowEnableEudc                                          
//                                                                        
// Parameters: pointer to the application window handle                              
//                                                                       
// Return Value: none                                    
//                                                                        
// Task performed:  This function calls EnableEUDC() API,
//                  to "enable or disable" EUDC depending
//                  on the User selection.                                  
//
//************************************************************************//


VOID ShowEnableEudc( HANDLE hwnd )
{
#ifdef EUDC_API

HMENU hMenu;
INT  bPrevState;


    hMenu = GetMenu( hwnd );

    // If it's already checked, then disable EUDC
    if ( GetMenuState(hMenu, IDM_ENABLEEUDC, MF_BYCOMMAND) & MF_CHECKED)
    { 
        CheckMenuItem( hMenu, IDM_ENABLEEUDC, MF_UNCHECKED   );
        bPrevState = EnableEUDC(FALSE);
        dprintf("Disabled system wide and per-user Eudc information");
        dprintf("Earlier EUDC state was: %d", bPrevState);
    }
    // Else enable EUDC
    else
    {
        CheckMenuItem( hMenu, IDM_ENABLEEUDC, MF_CHECKED   );
        bPrevState = EnableEUDC(TRUE);
        dprintf("Enabled system wide and per-user Eudc information");
        dprintf("Earlier EUDC state was: %d", bPrevState);
    }

#endif

    return;    

}



//************************************************************************//
//                                                                        
// Function :  EudcLoadLinkWDlgProc                                          
//                                                                        
// Parameters: for the dialog box callback procedures.                              
//                                                                       
// Return Value: TRUE/FALSE.   
//                                                                        
// Task performed:  This function displays and handles the dialog box
//                  for EudcLoadLinkW API(). It processes the user input
//                  and calls EudcLoadLinkW().   
//
//************************************************************************//

INT_PTR CALLBACK EudcLoadLinkWDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
#ifdef EUDC_API

static char szFile[MAX_PATH+1];
static char szFaceName[MAX_PATH+1];
WCHAR  wszFile[MAX_PATH+1];
WCHAR  wszFaceName[MAX_PATH+1];
INT    iPriority;
INT    iFontLinkType;
ULONG  uRet;    


    switch( msg )
    {
        case WM_INITDIALOG:
            SetDlgItemText( hdlg, IDD_LPSZFILE, szFile );
            SendDlgItemMessage( hdlg, IDD_LPSZFILE, EM_LIMITTEXT, sizeof(szFile), 0);
            SetDlgItemText( hdlg, IDD_LPSZFACENAME, szFaceName );
            SendDlgItemMessage( hdlg, IDD_LPSZFACENAME, EM_LIMITTEXT, sizeof(szFaceName), 0);
            CheckRadioButton(hdlg, IDD_SYSTEM, IDD_USER, IDD_SYSTEM);

            return TRUE;


        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {
                case IDOK:

                    szFile[0] = 0;
                    szFaceName[0] = 0;

                    GetDlgItemText( hdlg, IDD_LPSZFILE, szFile, sizeof(szFile) );
                    GetDlgItemText( hdlg, IDD_LPSZFACENAME, szFaceName, sizeof(szFaceName) );

                    if (MultiByteToWideChar(GetACP(), 0, szFile, -1, wszFile, MAX_PATH) == 0)
                    {
                        dprintf("Failed in MultiByteToWideChar(%s)", szFile);
                        return TRUE;
                    }

                    if (MultiByteToWideChar(GetACP(), 0, szFaceName, -1, wszFaceName, MAX_PATH) == 0)
                    {
                        dprintf("Failed in MultiByteToWideChar(%s)", szFaceName);
                        return TRUE;
                    }

                    iPriority = GetDlgItemInt(hdlg, IDD_PRIORITY, NULL, TRUE );   
                    
                    if (IsDlgButtonChecked(hdlg, IDD_SYSTEM) == BST_CHECKED)
                    {
                        iFontLinkType = FONTLINK_SYSTEM;
                    }
                    else
                    {
                        iFontLinkType = FONTLINK_USER;
                    }

                    dprintf("Calling EudcLoadLinkW(%s, %s, %d, %d)", szFaceName, szFile, iPriority, iFontLinkType);                    
                    uRet = EudcLoadLinkW(wszFaceName, wszFile, iPriority, iFontLinkType);
                    dprintf("EudcLoadLinkW returned: %d", uRet);

                    EndDialog( hdlg, TRUE );
                    return TRUE;

                case IDCANCEL:
                    EndDialog( hdlg, FALSE );
                    return TRUE;
            }

            break;

        case WM_CLOSE:
            EndDialog( hdlg, FALSE );
            return TRUE;
    }

#endif

    return FALSE;
}



//************************************************************************//
//                                                                        
// Function :  EudcUnLoadLinkWDlgProc                                          
//                                                                        
// Parameters: for the dialog box callback procedures.                              
//                                                                       
// Return Value: TRUE/FALSE.   
//                                                                        
// Task performed:  This function displays and handles the dialog box
//                  for EudcUnLoadLinkW API(). It processes the user input
//                  and calls EudcUnLoadLinkW().   
//
//************************************************************************//


INT_PTR CALLBACK EudcUnLoadLinkWDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
#ifdef EUDC_API

static char szFile[MAX_PATH+1];
static char szFaceName[MAX_PATH+1];
WCHAR  wszFile[MAX_PATH+1];
WCHAR  wszFaceName[MAX_PATH+1];
ULONG  uRet;    


    switch( msg )
    {
        case WM_INITDIALOG:
            SetDlgItemText( hdlg, IDD_LPSZFILE, szFile );
            SendDlgItemMessage( hdlg, IDD_LPSZFILE, EM_LIMITTEXT, sizeof(szFile), 0);
            SetDlgItemText( hdlg, IDD_LPSZFACENAME, szFaceName );
            SendDlgItemMessage( hdlg, IDD_LPSZFACENAME, EM_LIMITTEXT, sizeof(szFaceName), 0);

            return TRUE;


        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {
                case IDOK:

                    szFile[0] = 0;
                    szFaceName[0] = 0;

                    GetDlgItemText( hdlg, IDD_LPSZFILE, szFile, sizeof(szFile) );
                    GetDlgItemText( hdlg, IDD_LPSZFACENAME, szFaceName, sizeof(szFaceName) );

                    if (MultiByteToWideChar(GetACP(), 0, szFile, -1, wszFile, MAX_PATH) == 0)
                    {
                        dprintf("Failed in MultiByteToWideChar(%s)", szFile);
                        return TRUE;
                    }

                    if (MultiByteToWideChar(GetACP(), 0, szFaceName, -1, wszFaceName, MAX_PATH) == 0)
                    {
                        dprintf("Failed in MultiByteToWideChar(%s)", szFaceName);
                        return TRUE;
                    }

                    dprintf("Calling EudcUnLoadLinkW(%s, %s)", szFaceName, szFile);                    
                    uRet = EudcUnloadLinkW(wszFaceName, wszFile);
                    dprintf("EudcUnLoadLinkW returned: %d", uRet);

                    EndDialog( hdlg, TRUE );
                    return TRUE;

                case IDCANCEL:
                    EndDialog( hdlg, FALSE );
                    return TRUE;
            }

            break;

        case WM_CLOSE:
            EndDialog( hdlg, FALSE );
            return TRUE;
    }

#endif

    return FALSE;
}



//************************************************************************//
//                                                                        
// Function :  ShowGetEudcTimeStampExW                                          
//                                                                        
// Parameters: pointer to the application window handle                              
//                                                                       
// Return Value: none                                    
//                                                                        
// Task performed:  This function simply calls GetEUDCTimeStamp()
//
//************************************************************************//


VOID ShowGetEudcTimeStamp( HANDLE hwnd )
{
#ifdef EUDC_API

ULONG uRet;

    uRet = GetEUDCTimeStamp();
    dprintf("GetEUDCTimeStamp() returned: %u", uRet);    

#endif
}



//************************************************************************//
//                                                                        
// Function :  ShowGetEudcTimeStampExW                                          
//                                                                        
// Parameters: pointer to the application window handle                              
//                                                                       
// Return Value: none                                    
//                                                                        
// Task performed:  This function creates a DC, selects the current
//                  font and calls GetEUDCTimeStampExW() on that font.
//
//************************************************************************//


VOID ShowGetEudcTimeStampExW( HANDLE hwnd )
{
#ifdef EUDC_API

ULONG uRet;
WCHAR lpwstrFaceName[LF_FACESIZE];


    if (!MultiByteToWideChar(GetACP(), 0, elfdvA.elfEnumLogfontEx.elfLogFont.lfFaceName,
                        lstrlen(elfdvA.elfEnumLogfontEx.elfLogFont.lfFaceName),
                        lpwstrFaceName, LF_FACESIZE))
    {
        dprintf("Failed in MultiByteToWideChar for the string: %s",
                elfdvA.elfEnumLogfontEx.elfLogFont.lfFaceName);
        return;
    }

    uRet = GetEUDCTimeStampExW(lpwstrFaceName);

    dprintf("GetEUDCTimeStamp(%s) returned: %u", 
                elfdvA.elfEnumLogfontEx.elfLogFont.lfFaceName, uRet);    
#endif
}



//************************************************************************//
//                                                                        
// Function :  ShowGetStringBitMapAProc                                          
//                                                                        
// Parameters: for the dialog box callback procedures.                              
//                                                                       
// Return Value: TRUE/FALSE.   
//                                                                        
// Task performed:  This function displays and handles the dialog box
//                  for GetStringBitMapA API(). It processes the user input
//                  and calls GetStringBitMapA().   
//
//************************************************************************//


INT_PTR CALLBACK ShowGetStringBitMapAProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
#ifdef EUDC_API

HDC    hdcTest;
HFONT  hFont, hFontOld;
UINT   uRet; 
static char szString[MAX_PATH+1];
INT    iSize = BITMAP_SIZE;
INT    iLenString;
PBYTE  pByte;


    switch( msg )
    {
        case WM_INITDIALOG:
            SetDlgItemText( hdlg, IDD_STRING, szString );
            SendDlgItemMessage( hdlg, IDD_STRING, EM_LIMITTEXT, sizeof(szString), 0);
            
            return TRUE;

        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {
                case IDOK:

                    szString[0] = 0;
                    
                    GetDlgItemText( hdlg, IDD_STRING, szString, sizeof(szString) );

                    if ((iLenString = strlen(szString)) > 1)
                    {
                        MessageBox( hdlg, "You can enter text comprising of only one character",
                                        "GetStringBitmapA", MB_ICONERROR | MB_OK | MB_APPLMODAL);
                        return FALSE;
                    }

                    if ((pByte = GlobalAlloc(GPTR, iSize)) == NULL)
                    {
                        dprintf("Failed in allocating %d bytes", iSize);
                        return TRUE;
                    }

                    hdcTest = CreateTestIC();
                    hFont    = CreateFontIndirectWrapperA( &elfdvA );
                    hFontOld = SelectObject( hdcTest, hFont );

                    uRet = GetStringBitmapA(hdcTest, szString, iLenString, pByte, iSize);
                    dprintf("GetStringBitmapA(%s) returned: %d", szString, uRet);

                    SelectObject( hdcTest, hFontOld );
                    DeleteObject( hFont );
                    DeleteDC( hdcTest );  

                    EndDialog( hdlg, TRUE );
                    return TRUE;

                case IDCANCEL:
                    EndDialog( hdlg, FALSE );
                    return TRUE;
            }

            break;

        case WM_CLOSE:
            EndDialog( hdlg, FALSE );
            return TRUE;
    }

#endif
    return FALSE;

}



//************************************************************************//
//                                                                        
// Function :  ShowGetStringBitMapWProc                                    
//                                                                        
// Parameters: for the dialog box callback procedures.                              
//                                                                       
// Return Value: TRUE/FALSE.   
//                                                                        
// Task performed:  This function displays and handles the dialog box
//                  for GetStringBitMapW API(). It processes the user input
//                  and calls GetStringBitMapW().   
//
//************************************************************************//


INT_PTR CALLBACK ShowGetStringBitMapWProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
#ifdef EUDC_API

HDC    hdcTest;
HFONT  hFont, hFontOld;
UINT   uRet; 
static char szString[MAX_PATH+1];
WCHAR  wszString[2];
INT    iSize = BITMAP_SIZE;
INT    iLenString;
PBYTE  pByte;


    switch( msg )
    {
        case WM_INITDIALOG:
            SetDlgItemText( hdlg, IDD_STRING, szString );
            SendDlgItemMessage( hdlg, IDD_STRING, EM_LIMITTEXT, sizeof(szString), 0);
            
            return TRUE;

        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {
                case IDOK:

                    szString[0] = 0;
                    
                    GetDlgItemText( hdlg, IDD_STRING, szString, sizeof(szString) );

                    if ((iLenString = strlen(szString)) > 1)
                    {
                        MessageBox( hdlg, "You can enter text comprising of only one character",
                                        "GetStringBitmapA", MB_ICONERROR | MB_OK | MB_APPLMODAL);
                        return FALSE;
                    }

                    if (MultiByteToWideChar(GetACP(), 0, szString, -1, wszString, 2) == 0)
                    {
                        dprintf("Failed in MultiByteToWideChar(%s)", szString);
                        return TRUE;
                    }

                    if ((pByte = GlobalAlloc(GPTR, iSize)) == NULL)
                    {
                        dprintf("Failed in allocating %d bytes", iSize);
                        return TRUE;
                    }

                    hdcTest = CreateTestIC();
                    hFont    = CreateFontIndirectWrapperA( &elfdvA );
                    hFontOld = SelectObject( hdcTest, hFont );

                    uRet = GetStringBitmapW(hdcTest, wszString, iLenString, pByte, iSize);
                    dprintf("GetStringBitmapW(%s) returned: %d", szString, uRet);

                    SelectObject( hdcTest, hFontOld );
                    DeleteObject( hFont );
                    DeleteDC( hdcTest );  
                    
                    EndDialog( hdlg, TRUE );
                    return TRUE;

                case IDCANCEL:
                    EndDialog( hdlg, FALSE );
                    return TRUE;
            }

            break;

        case WM_CLOSE:
            EndDialog( hdlg, FALSE );
            return TRUE;
    }

#endif
    return FALSE;

}



//************************************************************************//
//                                                                        
// Function :  ShowGetFontAssocStatus                                          
//                                                                        
// Parameters: pointer to the application window handle                              
//                                                                       
// Return Value: none                                    
//                                                                        
// Task performed:  This function creates a DC, selects the current
//                  font and calls GetFontAssocStatus() on that font.
//
//************************************************************************//


VOID ShowGetFontAssocStatus( HANDLE hwnd )
{
#ifdef EUDC_API

HDC   hdcTest;
HFONT hFont, hFontOld;
UINT  uRet; 


  hdcTest = CreateTestIC();

  hFont    = CreateFontIndirectWrapperA( &elfdvA );
  hFontOld = SelectObject( hdcTest, hFont );

  uRet = GetFontAssocStatus(hdcTest);
  dprintf("GetFontAssocStatus(hdc) returned: %u", uRet);

  SelectObject( hdcTest, hFontOld );
  DeleteObject( hFont );

  DeleteDC( hdcTest );

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\gcp.h ===
#if 0
// i do not see that this is needed in gcp.c

void cmapTable(void);
UINT FAR PASCAL SWAPW(UINT) ;
DWORD FAR PASCAL SWAPD(DWORD);
BOOL FAR PASCAL ResetLPKs() ;

DWORD FAR PASCAL GetTextExtentEx(HDC, LPCSTR, int, int, int FAR *, int FAR *);
INT_PTR CALLBACK ChooseCharsetDlgProc( HWND hdlg, unsigned msg, WORD wParam, LONG lParam );

#endif


#define GCP_FONT_GLYPHS 0x0004

void doGetTextExtentEx(HDC hdc,int x,int y, LPVOID lpszString, int cbString);
INT_PTR CALLBACK GTEExtDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK SetTxtChExDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK SetTxtJustDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam );
void doGCP(HDC hdc, int x, int y, LPVOID lpszString, int cbString);
INT_PTR CALLBACK GcpDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam );
void RunExtents(void);
void doGcpCaret(HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by fonttest.rc
//
#define IDC_GGO_BITMAP                  1002
#define IDC_GGO_NATIVE                  1003
#define IDC_GGO_BEZIER                  1009
#define IDC_GGO_METRICS                 1004
#define IDC_GGO_GRAY2_BITMAP            1005
#define IDC_GGO_GRAY4_BITMAP            1006
#define IDC_GGO_GRAY8_BITMAP            1007
#define IDC_GGO_GLYPH_INDEX             1008
#define IDC_GGO_UNHINTED                1009
#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\gcp.c ===
#include <windows.h>
#include <cderr.h>
#include <commdlg.h>

#include <direct.h>
#include <malloc.h>
#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

#include "fonttest.h"
#include "gcp.h"
#include "dialogs.h"
// #include "resource.h"

BOOL bJustify    = FALSE;
BOOL bListGFLI   = FALSE;
BOOL bShadowText = FALSE;
BOOL bGTEExt     = FALSE;
BOOL bGCP        = FALSE;
BOOL bDprintf    = FALSE;
BOOL bUseKern    = FALSE;
BOOL bOutString  = FALSE;
BOOL bUseLPCaret = FALSE;
BOOL bUseLPorder = FALSE;
BOOL bUseLPdx    = FALSE;
BOOL bUseGI      = FALSE;
int  iMaxWidth   = -1;
int  iMaxGTEExtWidth = -1;
BOOL bReturn_nFit = TRUE;

BOOL bPdxPdy     = FALSE;
extern HWND hwndMode;

#define TA_CENTER_ONLY  4     // TA_CENTER==6, TA_RIGHT=2, clever huh!

/*****************************************************************************/

void RunExtents(void)
{
}

/*****************************************************************************/

INT_PTR CALLBACK GcpDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
    switch( msg )
    {
    case WM_INITDIALOG:
        {
            char sz[10] ;

            CheckDlgButton( hdlg, IDD_LPDX,       bUseLPdx );
            CheckDlgButton( hdlg, IDD_GI,         bUseGI );
            CheckDlgButton( hdlg, IDD_SHADOW,     bShadowText );
            CheckDlgButton( hdlg, IDD_GFLI,       bListGFLI );
            CheckDlgButton( hdlg, IDD_GCPDPRINTF, bDprintf );
            CheckDlgButton( hdlg, IDD_KERNSTRING, bUseKern );
            CheckDlgButton( hdlg, IDD_OUTSTRING,  bOutString );
            CheckDlgButton( hdlg, IDD_JUSTIFY,    bJustify );
            CheckDlgButton( hdlg, IDD_LPCARET,    bUseLPCaret );
            CheckDlgButton( hdlg, IDD_LPORDER,    bUseLPorder );

            wsprintf( sz, "%ld", iMaxWidth );
            SetDlgItemText( hdlg, IDD_MAXWIDTH, sz );
            return TRUE;
        }

    case WM_CLOSE:
        EndDialog( hdlg, FALSE );
        return TRUE;

    case WM_COMMAND:
        switch( LOWORD( wParam ) )
        {
            case IDOK:
            {
                UINT bTranslated ;
                int      i;

                i = (int)GetDlgItemInt( hdlg, IDD_MAXWIDTH, &bTranslated, TRUE );
                if ( !bTranslated )
                {
                    MessageBox(hdlg, "Error in Translation of MaxWidth",
                                        NULL, MB_OK );
                    break;
                }
                iMaxWidth   = i ;
                bUseLPorder = IsDlgButtonChecked( hdlg, IDD_LPORDER );
                bJustify    = IsDlgButtonChecked( hdlg, IDD_JUSTIFY );
                bUseLPdx    = IsDlgButtonChecked( hdlg, IDD_LPDX) ;
                bUseLPCaret = IsDlgButtonChecked( hdlg, IDD_LPCARET) ;
                bUseGI      = IsDlgButtonChecked( hdlg, IDD_GI );
                bShadowText = IsDlgButtonChecked( hdlg, IDD_SHADOW);
                bListGFLI   = IsDlgButtonChecked( hdlg, IDD_GFLI);
                bDprintf    = IsDlgButtonChecked( hdlg, IDD_GCPDPRINTF );
                bUseKern    = IsDlgButtonChecked( hdlg, IDD_KERNSTRING );
                bOutString  = IsDlgButtonChecked( hdlg, IDD_OUTSTRING);

                bGCP = bUseLPdx | bUseGI;

                #if 0
                if ( (dwRGBTextExt == dwRGBText) ||
                     (dwRGBTextExt == dwRGBBackground))
                {
                    InvalidateRect( hwndMode, NULL, TRUE );
                    SendMessage( hwndMain, WM_COMMAND,
                              IDM_SETTEXTEXTCOLOR, 0);
                }
                #endif
            }

            case IDCANCEL:
                EndDialog( hdlg, (wParam == IDOK) );
                return TRUE;
        }
        break;
    }
    return FALSE;
}

/*****************************************************************************/

void doGCP(HDC hdc, int x, int y, LPVOID lpszString, int cbString)
{
    LPSTR           lpszStringA = lpszString;
    LPWSTR          lpszStringW = lpszString;
    DWORD           oldColour ;
    UINT            oldMode ;
    DWORD           limitGTE ;
    DWORD           limitGCP ;
    HBRUSH          hbr ;
    RECT            rc ;
    GCP_RESULTS     gcp;
    DWORD           dwFlags ;
    UINT           *pOrder   = NULL;
    LPWSTR          pGlyphs  = NULL;
    int            *pdx      = NULL;
    PSTR            pOutStrA = NULL;
    PWSTR           pOutStrW = NULL;
    LPSTR           lpszOrigA = lpszString;
    LPWSTR          lpszOrigW = lpszString;
    int            *pCaret   = NULL;
    LPINT           ReallpDx = NULL;
    UINT            oldAlign;
    DWORD           wETO2 = wETO;

    oldAlign = SetTextAlign(hdc, wTextAlign);

    if (bShadowText)
    {
        GenExtTextOut( hdc, x, y, 0, NULL, lpszString, cbString, NULL);
    }

    if ( bUseLPdx )
    {
        pdx = (int *)LocalAlloc( LPTR, sizeof(int) * cbString );
        if ( !pdx )
            dprintf( "ERROR: Cant create pdx" );
    }

    if ( bUseLPorder )
    {
        pOrder = (UINT *)LocalAlloc( LPTR, sizeof(int) * cbString );
        if ( !pOrder )
                dprintf( "ERROR: Cant create pOrder" );
    }

    if ( bUseLPCaret )
    {
        pCaret = (int *)LocalAlloc( LPTR, sizeof(int) * cbString );
        if ( !pCaret )
                dprintf( "ERROR: Cant create pCaret" );
    }

    if ( bOutString )
    {
        pOutStrA = (PSTR)LocalAlloc( LPTR, sizeof(char) * cbString );
        pOutStrW = (PWSTR)LocalAlloc( LPTR, sizeof(WCHAR) * cbString );
        if ( !pOutStrA || !pOutStrW )
                dprintf( "ERROR: Cant create pOutStr" );
    }

    if ( bUseGI)
    {
        pGlyphs = LocalAlloc( LPTR, sizeof(pGlyphs[0]) * cbString );
        if ( !pGlyphs )
                dprintf( "ERROR: Cant create pGlyphs" );
    }
    {
        SIZE size;
        if (!isCharCodingUnicode)
            GetTextExtentPointA(hdc, lpszStringA, cbString, &size);
        else
            GetTextExtentPointW(hdc, lpszStringW, cbString, &size);
        limitGTE = (DWORD)((USHORT)size.cx | (size.cy << 16));
    }
    dwFlags  = GetFontLanguageInfo(hdc);
    if (bListGFLI)
        dprintf("GetFontLanguageInfo = %8.8lx", dwFlags);

    if (!bUseKern)
        dwFlags &= ~GCP_USEKERNING;

    if (bJustify)
        dwFlags |= GCP_JUSTIFY;

    if (dwFlags & 0x8000)
    {
        dprintf("ERROR in GetFontLanguageInfo");
        limitGCP    = 0L;
        gcp.lpDx    = NULL;
        gcp.nGlyphs = cbString;
    }
    else
    {
        if ( iMaxWidth != -1 )
            dwFlags |= GCP_MAXEXTENT;

        gcp.lStructSize = sizeof(gcp);
        if (!isCharCodingUnicode)
            gcp.lpOutString = pOutStrA ?(LPSTR)pOutStrA :NULL;
        else
            gcp.lpOutString = pOutStrW ?(LPSTR)pOutStrW :NULL;
        gcp.lpOrder     = pOrder ?(UINT far *)pOrder  :NULL;
        gcp.lpCaretPos  = pCaret ?(int far *)pCaret  :NULL;
        gcp.lpClass     = NULL;
        gcp.lpGlyphs    = pGlyphs ? pGlyphs : NULL;
        gcp.lpDx        = pdx ? (int far *)pdx  :NULL;
        gcp.nMaxFit     = 2;
        gcp.nGlyphs     = cbString;

        if (!isCharCodingUnicode)
            limitGCP = GetCharacterPlacementA(hdc, lpszStringA, cbString, iMaxWidth,
                                              (LPGCP_RESULTSA)&gcp, dwFlags );
        else
            limitGCP = GetCharacterPlacementW(hdc, lpszStringW, cbString, iMaxWidth,
                                              (LPGCP_RESULTSW)&gcp, dwFlags );


        if (limitGCP == 0)
            dprintf( "Error: GCP returned NULL, using ETO normally" );
        else
        {
            ReallpDx = gcp.lpDx;            // avoid fonttest drawing bug!

            if ( (iMaxWidth == -1) && (limitGTE != limitGCP) &&
                !(dwFlags | (GCP_USEKERNING | GCP_JUSTIFY)) )
            {
                dprintf( "ERROR: GTExt Limits: H:%d, W:%d",
                         HIWORD(limitGTE), LOWORD(limitGTE));
                dprintf( "       GCP Limits: H:%d, W:%d",
                         HIWORD(limitGCP), LOWORD(limitGCP));
            }

            if ( gcp.lpGlyphs )
            {
                wETO2 |= ETO_GLYPH_INDEX ;
                lpszStringA = (LPSTR)gcp.lpGlyphs;
                lpszStringW = (LPWSTR)gcp.lpGlyphs;

            }
            else if (gcp.lpOutString)
            {
                lpszStringA = (LPSTR)gcp.lpOutString;
                lpszStringW = (LPWSTR)gcp.lpOutString;
            }

            cbString = gcp.nMaxFit ;

            if (bDprintf)
            {
                UINT i;

                dprintf( "idx:str=glyf:dx:  caret:order:outstring");
                for (i=0; i<gcp.nGlyphs; i++)
                {
                    dprintf( "%2.2x: %4.2x =%4.4x-%4.4x-%4.4x--%4.4x--%4.2x",
                             i,
                             (!isCharCodingUnicode)? lpszOrigA[i]:lpszOrigW[i],
                             pGlyphs ? pGlyphs[i] :0,
                             pdx     ? pdx[i] :0,
                             pCaret  ? pCaret[i] :0,
                             pOrder  ? pOrder[i] :0,
                             (!isCharCodingUnicode)? (UCHAR)(pOutStrA ? pOutStrA[i] :0) : (WCHAR)(pOutStrW ? pOutStrW[i] :0) );
                }

                if (gcp.nGlyphs != (UINT)cbString)
                {
                    dprintf( "   ----------- nGlyphs limit");
                    for (i=gcp.nGlyphs; i<(UINT)cbString; i++)
                    {
                       dprintf( "%2.2x: %4.2x =%4.4x-%4.4x-%4.4x--%4.4x--%4.2x",
                                 i,
                                 (!isCharCodingUnicode)? lpszOrigA[i]:lpszOrigW[i],
                                 0,
                                 0,
                                 pCaret  ?pCaret[i] :0,
                                 pOrder  ?pOrder[i] :0,
                                 (!isCharCodingUnicode)? (UCHAR)(pOutStrA ? pOutStrA[i] :0) : (WCHAR)(pOutStrW ? pOutStrW[i] :0) );
                    }
                }
                dprintf( "(w,h) = (%d,%d)", LOWORD(limitGCP), HIWORD(limitGCP));
            }
        }
    }

    if (bShadowText && limitGCP)
    {
        oldColour = SetTextColor( hdc, dwRGBText );
        oldMode = SetBkMode( hdc, TRANSPARENT );
    }

    if (!isCharCodingUnicode)
        GenExtTextOut( hdc, x, y, wETO2, NULL, lpszStringA, gcp.nGlyphs, ReallpDx);
    else
        GenExtTextOut( hdc, x, y, wETO2, NULL, lpszStringW, gcp.nGlyphs, ReallpDx);

    if ((gcp.nGlyphs != (UINT)cbString) && (hwndMode == hwndString) && pGlyphs && pdx)
    {
        int x;UINT i;

        x = 10;

        SetTextAlign( hdc, TA_LEFT);
        SetTextColor(hdc, 0L);

        for (i=0; i<gcp.nGlyphs; i++)
        {
            if (!isCharCodingUnicode)
                GenExtTextOut( hdc, x, 10, ETO_GLYPH_INDEX, NULL,
                                     (LPSTR)&pGlyphs[i], 1, NULL );
            else
                GenExtTextOut( hdc, x, 10, ETO_GLYPH_INDEX, NULL,
                                     (LPWSTR)&pGlyphs[i], 1, NULL );

            x += (pdx[i] + 20);
        }
    }

    if (bShadowText && limitGCP)
    {
        if (dwFlags & GCP_JUSTIFY)
            limitGTE = limitGCP;

        hbr       = CreateSolidBrush( 0 );
        rc.left   = x ;
        rc.top    = y ;
        rc.right  = x + LOWORD(limitGTE);
        rc.bottom = y + HIWORD(limitGTE) ;

        if ( wTextAlign & TA_CENTER_ONLY )
        {
            rc.left -= LOWORD(limitGTE)/2 ;
            rc.right -= LOWORD(limitGTE)/2 ;
        }
        else if ( wTextAlign & TA_RIGHT )
        {
            rc.left -= LOWORD(limitGTE) ;
            rc.right -= LOWORD(limitGTE) ;
        }

        FrameRect( hdc, &rc, hbr );
        DeleteObject( hbr );

        SetTextColor( hdc, oldColour );
        SetBkMode( hdc, oldMode );
    }

    SetTextAlign(hdc, oldAlign);

    if ( pGlyphs )
        LocalFree((HANDLE)pGlyphs);

    if ( pOrder )
        LocalFree((HANDLE)pOrder);

    if( pdx )
        LocalFree((HANDLE)pdx);

    if( pCaret )
        LocalFree((HANDLE)pCaret);

    if( pOutStrA )
        LocalFree((HANDLE)pOutStrA);

    if( pOutStrW )
        LocalFree((HANDLE)pOutStrW);

    bGCP = FALSE;
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//
// fill in the caret positioning array.  Needs the class, order, TA_, pdx
//
void NEAR PASCAL doCaretPos(HDC hdc, GCP_RESULTS far *gcp, int Width)
{
int  *pBits;
UINT i;  int x;
UINT nGlyphs;

nGlyphs = gcp->nGlyphs;

pBits = LocalAlloc( LMEM_FIXED, nGlyphs*sizeof(int));
for (x=0,i=0; i<nGlyphs; i++)
    {
    pBits[i] = x;
    x += gcp->lpDx[i];
    }

//
// do the first character
//
switch ( ((wTextAlign & TA_RTLREADING)?1:0) +
         ((gcp->lpClass[0] == GCPCLASS_HEBREW) ?2:0))
    {
    case 0:
        dprintf("1st latin,LtoR");
        gcp->lpCaretPos[0] = 0;
        break;

    case 1:
        dprintf("1st latin,RtoL");
        gcp->lpCaretPos[0] = pBits[gcp->lpOrder[0]];
        break;

    case 2:
        dprintf("1st hebrew,LtoR");
        if (gcp->lpOrder[0] == nGlyphs-1)
            gcp->lpCaretPos[0] = Width;
        else
            gcp->lpCaretPos[0] = pBits[gcp->lpOrder[0]+1];
        break;

    case 3:
        dprintf("1st hebrew,RtoL");
        gcp->lpCaretPos[0] = Width;
        break;
    }

//NOLASTINGCP//nGlyphs--;
//NOLASTINGCP//
//NOLASTINGCP//if (nGlyphs)
//NOLASTINGCP//    {
//NOLASTINGCP//    //
//NOLASTINGCP//    // do the last character
//NOLASTINGCP//    //
//NOLASTINGCP//    switch ( ((wTextAlign & TA_RTLREADING)?1:0) +
//NOLASTINGCP//            ((gcp->lpClass[nGlyphs] == GCPCLASS_HEBREW) ?2:0))
//NOLASTINGCP//        {
//NOLASTINGCP//        case 0:
//NOLASTINGCP//            dprintf("last latin,LtoR");
//NOLASTINGCP//            gcp->lpCaretPos[nGlyphs] = Width;
//NOLASTINGCP//            break;
//NOLASTINGCP//
//NOLASTINGCP//        case 1:
//NOLASTINGCP//            dprintf("last latin,RtoL");
//NOLASTINGCP//            gcp->lpCaretPos[nGlyphs] = pBits[gcp->lpOrder[nGlyphs]+1];
//NOLASTINGCP//            break;
//NOLASTINGCP//
//NOLASTINGCP//        case 2:
//NOLASTINGCP//            dprintf("last hebrew,LtoR");
//NOLASTINGCP//            gcp->lpCaretPos[nGlyphs] = pBits[gcp->lpOrder[nGlyphs]];
//NOLASTINGCP//            break;
//NOLASTINGCP//
//NOLASTINGCP//        case 3:
//NOLASTINGCP//            dprintf("last hebrew,RtoL");
//NOLASTINGCP//            gcp->lpCaretPos[nGlyphs] = 0;
//NOLASTINGCP//            break;
//NOLASTINGCP//        }

    //
    // do middle characters
    //
    for (i=1; i<nGlyphs; i++)
        {
        x = gcp->lpOrder[i];
        if (gcp->lpClass[i] == GCPCLASS_HEBREW)
            {
            if( ++x == (int)nGlyphs )
                {
                gcp->lpCaretPos[i] = Width;
                continue;
                }
            }
        gcp->lpCaretPos[i] = pBits[x];
        }
//NOLASTINGCP//    }

LocalFree((HANDLE)pBits);
}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

void doGcpCaret(HWND hwnd)
{
HDC hdc;
int *pCaret;
LPWSTR pGlyphsLoc;
int *pdx;
char *pClass;
UINT *pOrder;

int nString ;
int i;
HFONT  hFont, hFontOld;
GCP_RESULTS gcp;
DWORD           dwFlags ;
int height, h;
char sz[8];
TEXTMETRIC tm;

if( hwndMode != hwndString )
    {
    dprintf( "Only available in String mode");
    return ;
    }
nString = lstrlen(szStringA);
dprintf( szStringA);

hFont = CreateFontIndirectWrapperA( &elfdvA );

if( !hFont )
        {
        dprintf( "Couldn't create font" );
        return;
        }

hdc = GetDC( hwnd );
hFontOld = SelectObject( hdc, hFont );

SetDCMapMode( hdc, wMappingMode );

SetBkMode( hdc, OPAQUE );
SetBkColor( hdc, dwRGBBackground );
SetTextAlign( hdc, wTextAlign & TA_RTLREADING);
SetTextColor( hdc, dwRGBText );

pCaret  = (int *)LocalAlloc(LMEM_FIXED, nString*2);
pdx     = (int *)LocalAlloc(LMEM_FIXED, nString*2);
pGlyphsLoc = LocalAlloc(LMEM_FIXED, nString*sizeof(pGlyphsLoc[0]));
pOrder  = (UINT*)LocalAlloc(LMEM_FIXED, nString*2);
pClass  = (char*)LocalAlloc(LMEM_FIXED, nString);

gcp.lStructSize = sizeof(gcp);
gcp.lpOutString = NULL;
gcp.lpOrder     = pOrder;
gcp.lpCaretPos  = pCaret;
gcp.lpClass     = pClass;
gcp.lpGlyphs    = pGlyphsLoc;
gcp.lpDx        = pdx;
gcp.nGlyphs     = nString;
gcp.nMaxFit     = 2;

dwFlags = GetFontLanguageInfo(hdc) | GCP_DIACRITIC |GCP_LIGATE |GCP_GLYPHSHAPE | GCP_REORDER;
dwFlags = GetCharacterPlacement(hdc, szStringA, nString, 0,
                                                (LPGCP_RESULTS)&gcp, dwFlags);
dprintf( "gcp returned w=%d, h=%d",LOWORD(dwFlags),HIWORD(dwFlags));

ExtTextOut(hdc,10,10,ETO_GLYPH_INDEX,NULL,(LPSTR)pGlyphsLoc,gcp.nGlyphs,pdx);

GetTextMetrics(hdc, &tm);
if (tm.tmCharSet == HEBREW_CHARSET)
    doCaretPos(hdc, &gcp, (int)LOWORD(dwFlags));

SelectObject(hdc, GetStockObject(SYSTEM_FONT));
GetTextMetrics(hdc, &tm);
height = (h = 10 + HIWORD(dwFlags)) + tm.tmHeight;;
SetTextAlign(hdc, TA_CENTER);

for (i=0; i<nString; i++)
    {
    dprintf("caret %x = %x", i, pCaret[i]);
    MoveTo(hdc, 10+pCaret[i], h);
    LineTo(hdc, 10+pCaret[i], height);
    wsprintf(sz, "%d", i);
    TextOut(hdc, 10+pCaret[i], height, sz, lstrlen(sz));
    height += tm.tmHeight;
    }

LocalFree((HANDLE) pCaret );
LocalFree((HANDLE) pGlyphsLoc);
LocalFree((HANDLE) pdx    );
LocalFree((HANDLE) pClass );
LocalFree((HANDLE) pOrder );

SelectObject( hdc, hFontOld );
DeleteObject( hFont );
CleanUpDC( hdc );
SelectObject( hdc, GetStockObject( BLACK_PEN ) );
ReleaseDC( hwnd, hdc );
}



/******************************Public*Routine******************************\
*
* GTEExtDlgProc
*
* History:
*  21-Aug-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


INT_PTR CALLBACK GTEExtDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
    switch( msg )
    {
    case WM_INITDIALOG:
        {
            char sz[10] ;

            wsprintf( sz, "%ld", iMaxGTEExtWidth );
            SetDlgItemText(hdlg, IDD_GTEEXT_MAXWIDTH, sz);
            CheckDlgButton( hdlg, IDD_NFIT, bReturn_nFit);
            return TRUE;
        }

    case WM_CLOSE:
        EndDialog( hdlg, FALSE );
        return TRUE;

    case WM_COMMAND:
        switch( LOWORD( wParam ) )
        {
            case IDOK:
            {
                UINT bTranslated ;
                int  i;

                i = (int)GetDlgItemInt( hdlg, IDD_GTEEXT_MAXWIDTH, &bTranslated, TRUE );
                if ( !bTranslated )
                {
                    MessageBox(hdlg, "Error in Translation of MaxWidth",
                                        NULL, MB_OK );
                    break;
                }
                iMaxGTEExtWidth   = i ;
                bReturn_nFit = IsDlgButtonChecked(hdlg, IDD_NFIT) ;
            }
            bGTEExt = TRUE;
            case IDCANCEL:
                EndDialog( hdlg, (wParam == IDOK) );
                return TRUE;
        }
        break;
    }
    return FALSE;
}



/******************************Public*Routine******************************\
*
* doGetTextExtentEx, test the corresponding API
*
* History:
*  21-Aug-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



void doGetTextExtentEx(
HDC     hdc,
int     x,
int     y,
LPVOID  lpszString,
int     cbString
)
{
    int res;
    LPSTR  lpszStringA = lpszString;
    LPWSTR lpszStringW = lpszString;

    int   i;
    SIZE            size;
    int            *pdx      = NULL;
    int             nFit = 0, *pnFit;

// set of local variables to support indexed version of this same API

    SIZE            sizeI;
    int            *pdxI      = NULL;
    int             nFitI = 0, *pnFitI;

    LPWORD          pgi = 0;

    size.cx  = size.cy  = 0;
    sizeI.cx = sizeI.cy = 0;

    if (pdx = (int *)LocalAlloc( LPTR, (2 * sizeof(int) + sizeof(WORD)) * cbString))
    {

        pdxI = &pdx[cbString];
        pgi  = (LPWORD)&pdxI[cbString];

        if (bReturn_nFit)
        {
            pnFit = &nFit;
            pnFitI = &nFitI;
        }
        else
        {
            pnFit = NULL;
            pnFitI = NULL;
        }

        if (!isCharCodingUnicode)
            res=GetTextExtentExPointA (
                hdc,             // HDC
                lpszStringA,     // LPCSTR
                cbString,        // int
                iMaxGTEExtWidth, // int
                pnFit,           // LPINT
                pdx,             // LPINT
                &size);          // LPSIZE
        else
            res=GetTextExtentExPointW (
                hdc,             // HDC
                lpszStringW,     // LPCWSTR
                cbString,        // int
                iMaxGTEExtWidth, // int
                pnFit,           // LPINT
                pdx,             // LPINT
                &size);          // LPSIZE

        if (res)
        {

            if (!bReturn_nFit)
            {
                nFit = cbString; // i
            }
            else
            {
                dprintf( "iMaxWidth = %ld, nFit = %ld", iMaxGTEExtWidth, nFit);
            }

            dprintf( "(w,h) = (%ld,%ld)", size.cx, size.cy);

            dprintf( " i : str : pdx  ");
            for (i = 0; i < nFit; i++)
            {
                if (!isCharCodingUnicode)
                    dprintf( "%3.2d: %.3d : %4.4d",
                             i,
                             (UCHAR)(lpszStringA[i]),
                             pdx[i]
                             );
                else
                    dprintf( "%3.2d: %.3d : %4.4d",
                             i,
                             (WCHAR)(lpszStringW[i]),
                             pdx[i]
                             );
            }
        }
        else
        {
            dprintf( "GetTextExtentExPointA/W failed ");
        }

        #ifdef GI_API

        if (!isCharCodingUnicode)
            res = GetGlyphIndicesA(hdc, lpszStringA,cbString, pgi, 0);
        else
            res = GetGlyphIndicesW(hdc, lpszStringW,cbString, pgi, 0);
        if (res != GDI_ERROR)
        {
            if (GetTextExtentExPointI (
                hdc,             // HDC
                pgi,             // LPCSTR
                cbString,        // int
                iMaxGTEExtWidth, // int
                pnFitI,          // LPINT
                pdxI,            // LPINT
                &sizeI))         // LPSIZE
            {
                if (!bReturn_nFit)
                {
                    nFitI = cbString; // i
                }

                if (nFit != nFitI)
                {
                    dprintf( "nFit != nFitI !!!, nFit = %ld, nFitI = %ld", nFit, nFitI);
                }
                else
                {
                    if (size.cx != sizeI.cx)
                    {
                        dprintf("size.cx != sizeI.cx, size.cx = %ld, sizeI.cx = %ld", size.cx, sizeI.cx);
                    }
                    else
                    {
                        if (size.cy != sizeI.cy)
                        {
                            dprintf("size.cy != sizeI.cy, size.cy = %ld, sizeI.cy = %ld", size.cy, sizeI.cy);
                        }
                        else
                        {
                            BOOL bRet = TRUE;
                            for (i = 0; i < nFitI; i++)
                            {
                                if (pdx[i] != pdxI[i])
                                {
                                    dprintf("pdx[%ld] != pdxI[%ld], pdx[%ld] = %ld, pdxI[%ld] = %ld",
                                                  i,           i,        i,   pdx[i],    i,    pdxI[i]);
                                    bRet = FALSE;
                                }
                            }
                            if (bRet)
                            {
                                dprintf("GetTextExtentExPointI consistent with GetTextExtentExPointA/W");
                            }
                        }
                    }
                }
            }
            else
            {
                dprintf( "GetTextExtentExPointI failed");
            }
        }
        else
        {
            if (!isCharCodingUnicode)
                dprintf( "GetGlyphIndicesA(%s) failed",lpszStringA);
            else
                dwprintf( L"GetGlyphIndicesW(%s) failed",lpszStringW);
        }

        #endif

        LocalFree((HANDLE)pdx);
    }
    else
    {
        dprintf( "pdx allocation failed ");
    }

    bGTEExt = FALSE;
}



/******************************Public*Routine******************************\
*
* SetTxtChExDlgProc
*
* History:
*  06-Nov-1995 -by- Tessie Wu [tessiew]
* Wrote it.
\**************************************************************************/
INT_PTR CALLBACK SetTxtChExDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
   switch( msg )
   {
    case WM_CLOSE:
      EndDialog( hdlg, FALSE );
      return TRUE;

    case WM_COMMAND:
      switch( LOWORD( wParam ) )
      {
      case IDOK:
        {
         BOOL bTranslated ;

         nCharExtra = (int)GetDlgItemInt( hdlg, IDD_SETXTCHAR_NCHAREXT, &bTranslated, TRUE);
        }
      case IDCANCEL:
        EndDialog( hdlg, (wParam == IDOK) );
        return TRUE;
      }
      break;
   }
   return FALSE;
}


/******************************Public*Routine******************************\
*
* SetTxtJustDlgProc
*
* History:
*  07-Nov-1995 -by- Tessie Wu [tessiew]
* Wrote it.
\**************************************************************************/
INT_PTR CALLBACK SetTxtJustDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
   switch( msg )
   {
    case WM_CLOSE:
      EndDialog( hdlg, FALSE );
      return TRUE;

    case WM_COMMAND:
      switch( LOWORD( wParam ) )
      {
      case IDOK:
        {
         BOOL bTranslated ;

         nBreakExtra = (int)GetDlgItemInt( hdlg, IDD_SETXTJUST_NBKEXT, &bTranslated, TRUE);
         nBreakCount = (int)GetDlgItemInt( hdlg, IDD_SETXTJUST_NBKCNT, &bTranslated, TRUE);
        }
      case IDCANCEL:
        EndDialog( hdlg, (wParam == IDOK) );
        return TRUE;
      }
      break;
   }
   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\glyph.h ===
#define SZGLYPHCLASS "Glyph Window"

void    WriteGlyph( LPSTR lpszFile );
LRESULT CALLBACK GlyphWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK GGOMatrixDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\rings.c ===
#include <windows.h>
#include <commdlg.h>

#include <malloc.h>
#include <math.h>
#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include "fonttest.h"
#include "rings.h"

#include "dialogs.h"


//*****************************************************************************
//*************************   D R A W   R I N G S   ***************************
//*****************************************************************************

#define PI     (3.1415926)
#define TWOPI  (2.0*PI)
#define PI4    (PI/4.0)

HDC hdcCachedPrinter = 0;

void DrawRings( HWND hwnd, HDC hdc )
 {
  double Angle, dAngle, Radius;

  int    i, x, y;
  HFONT  hFont, hFontOld;

  int myStrlen;

  if (!isCharCodingUnicode)
    myStrlen = lstrlenA(szStringA);
  else
    myStrlen = lstrlenW(szStringW);

  if( myStrlen == 0 ) return;

  Radius = cxDC / 4;
  dAngle = 360.0 / (double)myStrlen;

  Ellipse( hdc, xDC + cxDC/2-(int)Radius, yDC + cyDC/2-(int)Radius,
                xDC + cxDC/2+(int)Radius, yDC + cyDC/2+(int)Radius  );

  Angle = 0.0;

  for( i = 0; i < myStrlen; i++, Angle += dAngle )
   {
    if (!isCharCodingUnicode)
    {
        elfdvA.elfEnumLogfontEx.elfLogFont.lfEscapement  = elfdvA.elfEnumLogfontEx.elfLogFont.lfOrientation = (int)(10.0*Angle);
        hFont = CreateFontIndirectWrapperA( &elfdvA );
    }
    else 
    {
        elfdvW.elfEnumLogfontEx.elfLogFont.lfEscapement  = elfdvW.elfEnumLogfontEx.elfLogFont.lfOrientation = (int)(10.0*Angle);
        hFont = CreateFontIndirectWrapperW( &elfdvW );
    }
    
    if( !hFont )
     {
      dprintf( "Couldn't create font for Angle = %d", (int)Angle );
      continue;
     }

    hFontOld = SelectObject( hdc, hFont );

    SetTextAlign( hdc, wTextAlign );
    SetBkMode( hdc, iBkMode );
    SetBkColor( hdc, dwRGBBackground );
    SetTextColor( hdc, dwRGBText );

    x = xDC + cxDC/2 + (int)(Radius * sin( TWOPI * Angle / 360.0 ) );
    y = yDC + cyDC/2 + (int)(Radius * cos( TWOPI * Angle / 360.0 ) );

//    dprintf( "  x, y = %d, %d", x, y );

    if (!isCharCodingUnicode)
        TextOutA( hdc, x, y, &szStringA[i], 1 );
    else
        TextOutW( hdc, x, y, &szStringW[i], 1 );

    MoveToEx( hdc, x-cxDC/150, y          ,0);
    LineTo( hdc, x+cxDC/150, y          );
    MoveToEx( hdc, x,          y-cxDC/150 ,0);
    LineTo( hdc, x,          y+cxDC/150 );

    SelectObject( hdc, hFontOld );
    DeleteObject( hFont );
   }

  if (!isCharCodingUnicode)
      elfdvA.elfEnumLogfontEx.elfLogFont.lfEscapement = 
        elfdvA.elfEnumLogfontEx.elfLogFont.lfOrientation = 0;
  else
      elfdvW.elfEnumLogfontEx.elfLogFont.lfEscapement = 
        elfdvW.elfEnumLogfontEx.elfLogFont.lfOrientation = 0;
 }


//*****************************************************************************
//*********************   R I N G S   W N D   P R O C   ***********************
//*****************************************************************************

LRESULT CALLBACK RingsWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
 {
  HDC         hdc;
  PAINTSTRUCT ps;
  HCURSOR     hCursor;


  switch( msg )
   {
//    case WM_CREATE:
//           return NULL;


    case WM_CHAR:
           HandleChar( hwnd, wParam );
           return 0;


    case WM_PAINT:
           hCursor = SetCursor( LoadCursor( NULL, MAKEINTRESOURCE(IDC_WAIT) ) );
           ShowCursor( TRUE );

           //ClearDebug();
           //dprintf( "Drawing rings" );

           hdc = BeginPaint( hwnd, &ps );
           SetDCMapMode( hdc, wMappingMode );

           SetTextCharacterExtra( hdc, nCharExtra );

           SetTextJustification( hdc, nBreakExtra, nBreakCount );

           DrawDCAxis( hwnd, hdc , TRUE);

           DrawRings( hwnd, hdc );

           CleanUpDC( hdc );

           SelectObject( hdc, GetStockObject( BLACK_PEN ) );
           EndPaint( hwnd, &ps );

           //dprintf( "  Finished drawing rings" );

           ShowCursor( FALSE );
           SetCursor( hCursor );

           return 0;

    case WM_DESTROY:
           return 0;
   }


  return DefWindowProc( hwnd, msg, wParam, lParam );
 }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\glyphset.c ===
#include <windows.h>
#include <commdlg.h>

#include <malloc.h>
#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include "fonttest.h"

#include "dialogs.h"


//*****************************************************************************
//*************************   D R A W   GLYPHSET     **************************
//*****************************************************************************


//************************************************************************//
//                                                                        //
// Function :  DrawGlyphSet                                               //
//                                                                        //
// Parameters: handles to the window and DC                               //
//                                                                        //
// Thread safety: none.                                                   //
//                                                                        //
// Task performed:  This function displays the dialog box to choose a new //
//                  font. It then gets the number of Glyphs the font has  //
//                  by reading the fontdata. It calls a function to       //
//                  display all the fonts and performs the necessary      //
//                  cleanup.                                              //
//                                                                        //
//************************************************************************//


void DrawGlyphSet( HWND hwnd, HDC hdc )
{
HFONT  hFont, hFontOld;          // Handle to the new and old fonts                   
  
DWORD  dwrc;                     // For the call to the GetFontData
CHAR  szTable[] = "maxp";  // Name of the table we are interested in.
DWORD dwTable = *(LPDWORD)szTable;
DWORD dwSize;

BYTE pNumGlyphs[2] = {0x00, 0x01};// default value of 256 for the number of glyphs
WORD *wpNumGlyphs;


    if (!isCharCodingUnicode)
        hFont    = CreateFontIndirectWrapperA( &elfdvA );
    else
        hFont    = CreateFontIndirectWrapperW( &elfdvW );

    if( !hFont )
    {
        dprintf( "Couldn't create font");
        return;
    }


    if ( hFontOld = SelectObject( hdc, hFont ))
    {
        // Get the size of buffer required to hold the font data
        dwSize = GetFontData(hdc, dwTable, 0, NULL, 0);

        wpNumGlyphs = (WORD *) pNumGlyphs;

        if((dwSize != (DWORD)(-1)) && (dwSize < 64))
        {
            BYTE hpData[64];

            dprintf( "Calling GetFontData" );
            dprintf( "  dwTable   = 0x%.8lX (%s)", dwTable, szTable);
            dprintf( "  dwBufSize = %ld",     dwSize  );

            // Get the actual font-data.
            dwrc = GetFontData( hdc, dwTable, 0, hpData, dwSize );

            // Take care of the reverse-Indian !!
            pNumGlyphs[0] = *(hpData+5);
            pNumGlyphs[1] = *(hpData+4);

            dprintf( "  dwrc = %ld", dwrc );
        }

        dprintf( "  Total Number of Glyphs = %d", *wpNumGlyphs);

        // Display all the glyphs.
        VDisplayGlyphs( hwnd, hdc, *wpNumGlyphs );
        hFont = SelectObject(hdc, hFontOld);
    }

    DeleteObject(hFont);
       
}


//************************************************************************//
//                                                                        //
// Function :  VDisplayGlyphs                                             //
//                                                                        //
// Parameters: handles to the window and DC, number of glyphs in the font //
//                                                                        //
// Thread safety: none.                                                   //
//                                                                        //
// Task performed:  This function displays all the fonts by calling       //
//                  ExtTextOut and specifying that the fonts are specified//
//                  by the index. 16 fonts are shown on every line.       //
//                                                                        //
//************************************************************************//


void VDisplayGlyphs( HWND hwnd, HDC hdc, WORD wNumGlyphs )
{
TEXTMETRIC tm;
WORD ach[16];
LONG apdx[16];
LONG y = 0;
WORD i;
WORD iGlyphs;


    GetTextMetrics(hdc, &tm);
    iGlyphs = min(16, wNumGlyphs);
	   
    for (i = 0; i < iGlyphs ; i++)
        {
        apdx[i] = tm.tmMaxCharWidth;       // Spacing between two characters 
        ach[i] = i;                        // Init the string
        }

    SetBkMode( hdc, iBkMode );
    SetBkColor( hdc, dwRGBBackground );
    SetTextColor( hdc, dwRGBText );
    SetTextAlign( hdc, TA_TOP | TA_LEFT );

    // Actual display of the glyphs, in batches of 16.
    while (wNumGlyphs > 0)
    {
        iGlyphs = min(16, wNumGlyphs);

        ExtTextOut( hdc, 0, y, ETO_GLYPH_INDEX, NULL, (LPSTR)ach, iGlyphs, apdx );

        wNumGlyphs -= iGlyphs;
        y+= tm.tmHeight;

        iGlyphs = min(16, wNumGlyphs);

        for (i = 0; i < iGlyphs ; i++)
        {
            ach[i] += 16;
        }
    }
}



//*****************************************************************************
//*********************   GlyphSet   W N D   P R O C   ***********************
//*****************************************************************************

//************************************************************************//
//                                                                        //
// Function :  GlyphSetWndProc                                            //
//                                                                        //
// Parameters: handles to the window and the message parameters           //
//                                                                        //
// Thread safety: none.                                                   //
//                                                                        //
// Task performed:  Handles window messages when the user selects or      //
//                  deselects the glyphset option.                        //
//                                                                        //
//************************************************************************//


LRESULT CALLBACK GlyphSetWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
 {
  HDC         hdc;
  PAINTSTRUCT ps;
  HCURSOR     hCursor;


  switch( msg )
   {
    case WM_PAINT:
           hCursor = SetCursor( LoadCursor( NULL, MAKEINTRESOURCE(IDC_WAIT) ) );
           ShowCursor( TRUE );

           hdc = BeginPaint( hwnd, &ps );
           SetDCMapMode( hdc, wMappingMode );

           SetTextCharacterExtra( hdc, nCharExtra );

           DrawDCAxis( hwnd, hdc, TRUE);

           DrawGlyphSet( hwnd, hdc );

           CleanUpDC( hdc );

           SelectObject( hdc, GetStockObject( BLACK_PEN ) );
           EndPaint( hwnd, &ps );

           ShowCursor( FALSE );
           SetCursor( hCursor );

           return 0;

    case WM_DESTROY:
           return 0;
   }


  return DefWindowProc( hwnd, msg, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\glyph.c ===
#include <windows.h>
#include <commdlg.h>

#include <malloc.h>
#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>


#include "dialogs.h"
#include "fonttest.h"
#include "glyph.h"
#include "resource.h"

#define ASCENDERCOLOR  PALETTERGB( 128,   0,   0 )
#define DESCENDERCOLOR PALETTERGB(   0, 128,   0 )

int      Margin;

#define  MAX_TEXT     128
char     szText[MAX_TEXT];

void DrawBezier( HWND hwnd, HDC hdc );

// gGGO is a global structure that keeps the state of the GGO
// options.

// gray can hold one of the following:

// GGO_BITMAP;
// GGO_GRAY2_BITMAP
// GGO_GRAY4_BITMAP
// GGO_GRAY8_BITMAP

typedef struct {
    unsigned int gray;
    unsigned int flags;
} GGOSTRUCT;

GGOSTRUCT gGGO = {GGO_BITMAP,0};


DWORD    dwxFlags = 0L;
HDC      hdcTest;                  // DC to Test Metrics, Bitmaps, etc... on
HFONT    hFont, hFontOld;
int      xVE, yVE, xWE, yWE, xLPI, yLPI;

//*****************************************************************************
//************************   G L Y P H   D A T A   ****************************
//*****************************************************************************

HPEN   hPenOutline;
HPEN   hPenA;
HPEN   hPenB;
HPEN   hPenC;
HPEN   hPenBox;
HBRUSH hBrushAscend;
HBRUSH hBrushDescend;
WORD wChar = '1';
int  iWidth;
double        deM11, deM12, deM21, deM22;
MAT2          mat2 = {{0,1},{0,0},{0,0},{0,1}};
GLYPHMETRICS  gm;

#define MAX_BOX  260
#define MARGIN    50

int Scale = 1;
int xBase = 0;
int yBase = 0;
int cxClient, cyClient;

TEXTMETRIC tm;

//*****************************************************************************
//*********************   C R E A T E   T E S T   D C   ***********************
//*****************************************************************************

HDC CreateTestDC( void )
{
    DWORD dwVE, dwWE;
    SIZE size;

    //  hdcTest = CreateDC( "DISPLAY", NULL, NULL, NULL );
    //  if( !hdcTest ) return hdcTest;

    hdcTest = CreateTestIC();
    if( !hdcTest ) {
        return NULL;
    }
    SetDCMapMode( hdcTest, wMappingMode );
    GetViewportExtEx(hdcTest,&size);
    dwVE = (DWORD) (65536 * size.cy + size.cx);

    GetWindowExtEx(hdcTest, &size);
    dwWE = (DWORD) (65536 * size.cy + size.cx);

    xVE = abs( (int)LOWORD(dwVE) );
    yVE = abs( (int)HIWORD(dwVE) );
    xWE = abs( (int)LOWORD(dwWE) );
    yWE = abs( (int)HIWORD(dwWE) );

    xLPI = GetDeviceCaps( hdcTest, LOGPIXELSX );
    yLPI = GetDeviceCaps( hdcTest, LOGPIXELSY );

    if (!isCharCodingUnicode)
        hFont    = CreateFontIndirectWrapperA( &elfdvA );
    else
        hFont    = CreateFontIndirectWrapperW( &elfdvW );
    hFontOld = SelectObject( hdcTest, hFont );

    SetTextColor( hdcTest, dwRGB );
    return hdcTest;
}

//*****************************************************************************
//*******************   D E S T R O Y   T E S T   D C   ***********************
//*****************************************************************************

void DestroyTestDC( void )
{
    SelectObject( hdcTest, hFontOld );
    DeleteObject( hFont );
    //  DeleteDC( hdcTest );
    DeleteTestIC( hdcTest );
}

//*****************************************************************************
//****************************   M A P   X   **********************************
//*****************************************************************************

int MapX( int x )
{
    return Scale * x;
}

//*****************************************************************************
//****************************   M A P   Y   **********************************
//*****************************************************************************

int MapY( int y )
{
    return MulDiv( Scale * y, xLPI, yLPI );
}

//*****************************************************************************
//************************   F I L L   P I X E L   ****************************
//*****************************************************************************

void FillPixel( HDC hdc, int x, int y, int xBrush )
{
    if( Scale > 1 ) {
        SelectObject( hdc, GetStockObject(xBrush) );
        Rectangle( hdc, MapX(x), MapY(y)-1, MapX(x+1)+1, MapY(y+1) );
    } else {
        COLORREF cr;

        switch( xBrush ) {

        case BLACK_BRUSH:
            cr = PALETTEINDEX( 0);
            break;

        case GRAY_BRUSH:
            cr = PALETTEINDEX( 7);
            break;

        case LTGRAY_BRUSH:
            cr = PALETTEINDEX( 8);
            break;

        default:
            cr = PALETTEINDEX(15);
            break;
        }
        SetPixel( hdc, MapX(x), MapY(y), cr );
    }
}

void MyFillPixel( HDC hdc, int x, int y )
{
        if ( Scale > 1 )
        Rectangle( hdc, MapX(x), MapY(y)-1, MapX(x+1)+1, MapY(y+1) );
        else
                PatBlt( hdc, MapX(x), MapY(y), 1, 1, PATCOPY );
}

//*****************************************************************************
//**************************   D R A W   B O X   ******************************
//*****************************************************************************

void DrawBox( HWND hwnd, HDC hdc )
{
    int   x, y, xSpace, ySpace, xScale, yScale;
    RECT  rcl;

    //--------------------------  Draw Character Box  -----------------------------

    GetClientRect( hwnd, &rcl );
    cxClient = rcl.right;
    cyClient = rcl.bottom;
    dprintf( "rcl.right, bottom = %d, %d", rcl.right, rcl.bottom );

    Margin = min( rcl.bottom / 8, rcl.right / 8 );
    xSpace = rcl.right  - 2*Margin;               // Available Box for Glyph
    ySpace = rcl.bottom - 2*Margin;

    GetTextMetrics( hdcTest, &tm );
    dprintf( "tmMaxCharWidth    = %d", tm.tmMaxCharWidth );
    dprintf( "tmAscent, Descent = %d,%d", tm.tmAscent, tm.tmDescent );

    tm.tmAscent       = MulDiv( tm.tmAscent,       yVE, yWE );
    tm.tmDescent      = MulDiv( tm.tmDescent,      yVE, yWE );
    tm.tmMaxCharWidth = MulDiv( tm.tmMaxCharWidth, xVE, xWE );

    xScale = xSpace / (tm.tmAscent+tm.tmDescent);
    yScale = ySpace / (tm.tmMaxCharWidth);

    Scale = min( xScale, yScale );                // Choose smallest
    if( Scale < 1 ) {
        Scale = 1;
    }
    SetMapMode( hdc, MM_ANISOTROPIC );
    SetViewportExtEx( hdc, 1, 1, 0);                 // Make y-axis go up
    SetViewportOrgEx( hdc, 0, rcl.bottom, 0);

    xBase = Margin;
    yBase = Margin + Scale * tm.tmDescent;
    dprintf( "xBase, yBase = %d, %d", xBase, yBase );

    SetWindowExtEx(hdc, 1, -1, 0);
    SetWindowOrgEx( hdc, -xBase, -yBase, 0);
    SelectObject( hdc, hPenBox );
    SelectObject( hdc, hBrushAscend );
    Rectangle( hdc, 0, -1, MapX(tm.tmMaxCharWidth)+1, MapY(tm.tmAscent) );
    SelectObject( hdc, hBrushDescend );
    Rectangle( hdc, 0, 0, MapX(tm.tmMaxCharWidth)+1, MapY(-tm.tmDescent)-1 );

    //------------------------------ Overlay Grid  --------------------------------

    SelectObject( hdc, hPenBox );
    if( Scale > 1 ) {
        for( x = 0; x <= tm.tmMaxCharWidth; x++ ) {
            MoveToEx( hdc, MapX(x), MapY(-tm.tmDescent), 0);
            LineTo( hdc, MapX(x), MapY(tm.tmAscent) );
        }
        for( y = -tm.tmDescent; y <= tm.tmAscent; y++ ) {
            MoveToEx( hdc, 0,MapY(y), 0);
            LineTo( hdc, MapX(tm.tmMaxCharWidth), MapY(y) );
        }
    }
}

//*****************************************************************************
//***********************   D R A W   B I T M A P   ***************************
//*****************************************************************************

typedef BYTE *HPBYTE;

void DrawBitmap( HWND hwnd, HDC hdc )
{
    int    x, xOut, y, nx, ny, r, gox, goy, cbRaster;
    BYTE   m, b;
    HPBYTE hpb;
    DWORD  dwrc;
    unsigned uFormat;       // to be passed to GetGlyphOutline
        int cLevels;            // number of levels in TT-bitmap
        int D,Q,R,E;
        int  iLevel;
        HBRUSH *pb, *pbOut, hbBlue, hbPixelOff;

        HLOCAL  hBrushHandleArray = 0;
        HBRUSH *pBrushHandleArray = 0;

    //-------------------------  Query Size of BitMap  ----------------------------

    HPBYTE hStart   = NULL;
    HPBYTE hpbStart = NULL;
        hbPixelOff  = CreateSolidBrush(RGB(255,255,255));
        if (hbPixelOff == 0) {
                dprintf(" hbPixelOff == 0");
                goto Exit;
        }
        hbBlue = CreateSolidBrush(RGB(0,0,255));
        if ( hbBlue == 0 ) {
                dprintf(" hbBlue == 0");
                goto Exit;
        }

    dprintf( "GetGlyphOutline bitmap size '%c'", wChar );
    dprintf( "flags = %u", gGGO.flags);

	dprintf( "Character code: %x", (UINT) wChar);

    uFormat = (gGGO.gray | gGGO.flags);

	if (! isCharCodingUnicode)
		dwrc =
			lpfnGetGlyphOutlineA(
				hdcTest,        // screen dc
				wChar,          // character to be queried
				uFormat,        // GGO_* stuff
				&gm,            // request GLYPHMETRICS to be returned
				0L,             // size request ==> size of buffer must be zero
				NULL,           // size request ==> no bitmap buffer provided
				&mat2           // recieves extra transform matrix
				);
	else
		dwrc =
			lpfnGetGlyphOutlineW(
				hdcTest,        // screen dc
				wChar,          // character to be queried
				uFormat,        // GGO_* stuff
				&gm,            // request GLYPHMETRICS to be returned
				0L,             // size request ==> size of buffer must be zero
				NULL,           // size request ==> no bitmap buffer provided
				&mat2           // recieves extra transform matrix
				);

    dprintf( "  dwrc            = %ld",   dwrc );
    dprintf( "  gmBlackBoxX,Y   = %u,%u", gm.gmBlackBoxX, gm.gmBlackBoxY );
    dprintf( "  gmptGlyphOrigin = %d,%d", gm.gmptGlyphOrigin.x, gm.gmptGlyphOrigin.y );
    dprintf( "  gmCellIncX,Y    = %d,%d", gm.gmCellIncX, gm.gmCellIncY );

    if( (long)dwrc == -1L ) {
        dprintf( "*** GetGlyphOutline failed" );
        goto Exit;
    }
    if( gm.gmBlackBoxX * gm.gmBlackBoxY / 8 > (WORD)dwrc ) {
        dprintf( "BOGUS bitmap size!" );
        dprintf( "  BlackBoxX,Y says %u bytes", gm.gmBlackBoxX * gm.gmBlackBoxY / 8 );
        dprintf( "  GetGlyphOutline says %lu bytes", dwrc );
        goto Exit;
    }
    hStart   = GlobalAlloc( GMEM_MOVEABLE, dwrc );
    dprintf( " hStart = 0x%.4X", hStart );
    if( !hStart ) {
        goto Exit;
    }
    hpbStart = (HPBYTE)GlobalLock( hStart );
    dprintf( "  hpbStart = 0x%.8lX", hpbStart );
    if( !hpbStart ) {
        goto Exit;
    }

    //-------------------------  Actually Get Bitmap  -----------------------------

    dprintf( "Calling GetGlyphOutline for bitmap" );
	if (! isCharCodingUnicode)
		dwrc =
			lpfnGetGlyphOutlineA(
				hdcTest,
				wChar,
				uFormat,
				&gm,
				dwrc,
				hpbStart,
				&mat2
				);
	else
		dwrc =
			lpfnGetGlyphOutlineW(
				hdcTest,
				wChar,
				uFormat,
				&gm,
				dwrc,
				hpbStart,
				&mat2
				);

    dprintf( "  dwrc            = %ld",   dwrc );

    if( (long)dwrc == -1L ) {
        dprintf( "*** GetGlyphOutline failed" );
        goto Exit;
    }

    //------------------------  Draw Bitmap on Screen  ----------------------------

    nx = gm.gmBlackBoxX;
    ny = gm.gmBlackBoxY;

        switch ( gGGO.gray )
        {
        case GGO_BITMAP:
                cbRaster = ( nx + 31 ) / 32;
                cLevels = 2;
                break;
        case GGO_GRAY2_BITMAP:
                cbRaster = ( nx + 3 ) / 4;
                cLevels = 5;
                break;
        case GGO_GRAY4_BITMAP:
                cbRaster = ( nx + 3 ) / 4;
                cLevels = 17;
                break;
        case GGO_GRAY8_BITMAP:
                cbRaster = ( nx + 3 ) / 4;
                cLevels = 65;
                break;
        default:
                dprintf(" bogus gGGO.gray");
                goto Exit;
        }
        cbRaster *= sizeof(DWORD);                      // # bytes per scan

        if ( gGGO.gray != GGO_BITMAP ) {
                // set up a DDA for the colors

                D = cLevels - 1;                                // denominator
                Q = 255 / D;                                    // quotient
                R = 255 % D;                                    // remainder
                E = D - (D / 2) - 1;                    // error term

                // allocate an array of brush handles

                hBrushHandleArray = LocalAlloc(LMEM_FIXED, sizeof(HBRUSH) * cLevels);
                if (hBrushHandleArray == 0) {
                        dprintf(" hBrushHandleArray == 0");
                        goto Exit;
                }
                pBrushHandleArray = (HBRUSH*) LocalLock(hBrushHandleArray);
                if (pBrushHandleArray == 0) {
                        dprintf(" pBrushHandleArray == 0");
                        goto Exit;
                }

                // initialize loop variables

                iLevel = 0;
                pb = pBrushHandleArray;
                pbOut = pb + cLevels;

                for ( ; pb < pbOut; pb++ ) {
                        BYTE j;
                        const static BYTE GAMMA[256] = {
                             0, 0x03, 0x05, 0x07, 0x09, 0x0a, 0x0c, 0x0d
                        , 0x0f, 0x11, 0x12, 0x13, 0x15, 0x16, 0x18, 0x19
                        , 0x1a, 0x1c, 0x1d, 0x1e, 0x20, 0x21, 0x22, 0x24
                        , 0x25, 0x26, 0x27, 0x29, 0x2a, 0x2b, 0x2c, 0x2d
                        , 0x2f, 0x30, 0x31, 0x32, 0x33, 0x35, 0x36, 0x37
                        , 0x38, 0x39, 0x3a, 0x3b, 0x3d, 0x3e, 0x3f, 0x40
                        , 0x41, 0x42, 0x43, 0x44, 0x45, 0x47, 0x48, 0x49
                        , 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51
                        , 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x59, 0x5a
                        , 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62
                        , 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a
                        , 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72
                        , 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x78, 0x79
                        , 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81
                        , 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89
                        , 0x8a, 0x8b, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90
                        , 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98
                        , 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f
                        , 0xa0, 0xa1, 0xa2, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6
                        , 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xab, 0xac, 0xad
                        , 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb3, 0xb4
                        , 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbb
                        , 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc1, 0xc2
                        , 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc8, 0xc9
                        , 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xce, 0xcf, 0xd0
                        , 0xd1, 0xd2, 0xd3, 0xd4, 0xd4, 0xd5, 0xd6, 0xd7
                        , 0xd8, 0xd9, 0xda, 0xda, 0xdb, 0xdc, 0xdd, 0xde
                        , 0xdf, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe4
                        , 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xea, 0xeb
                        , 0xec, 0xed, 0xee, 0xef, 0xef, 0xf0, 0xf1, 0xf2
                        , 0xf3, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf8
                        , 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfd, 0xfe, 0xff
                        };

                        // On the screen I want the background color
                        // to be white and the text color to be black.
                        // This means that iLevel = 0 corresponds to
                        // full luminance and iLevel = 255 corresponds
                        // to zero luminance.
                        //
                        // We must also gamma correct

                        j = GAMMA[255-iLevel];

                        *pb = CreateSolidBrush( RGB(j,j,j) );
                        if ( *pb ==0 ) {
                                dprintf( "CreateHatchBrush failed");
                                goto Exit;
                        }
                        iLevel += Q;
                        if ((E -= R) < 0) {
                                iLevel += 1;
                                E += D;
                        }
                }
        }
    dprintf( "  cbRaster = %d", cbRaster );

    SelectObject( hdc, hPenBox );
    gox = (gm.gmCellIncX >= 0 ? gm.gmptGlyphOrigin.x : 0);
    goy = abs(gm.gmptGlyphOrigin.y) - 1;
    for( r = 0; r < ny; r++ ) {
        y = goy - r;
        if( y > cyClient-yBase )
            continue;
        hpb = hpbStart + r * cbRaster;
        x = gox;
        xOut = min(gox + nx, cxClient - xBase + 1);
        if ( gGGO.gray == GGO_BITMAP ) {
            for( m = 0; x < xOut; x++ )  {
                int xBrush;

                if( m == 0 ) {
                    m = 0x0080;
                    b = *hpb;
                    hpb += 1;
                }
                if( m & b ) {
                    xBrush = BLACK_BRUSH;
                } else {
                    if( y >= 0 ) {
                        xBrush = LTGRAY_BRUSH;
                    } else {
                        xBrush = GRAY_BRUSH;
                    }
                }
                FillPixel( hdc, x, y, xBrush );
                m >>= 1;
            }
        } else {
            // gray pixel case
            for ( ; x < xOut; x++, hpb++ ) {
                HBRUSH hb;
                hb = pBrushHandleArray[*hpb];
                hb = SelectObject(hdc, hb);
                MyFillPixel(hdc,x,y);
                SelectObject(hdc, hb);
            }
        }
    }

Exit:
    if( hpbStart ) {
        GlobalUnlock( hStart );
    }
    if( hStart   ) {
        GlobalFree( hStart );
    }
        if ( pBrushHandleArray ) {
                // delete brushes
                pb = pBrushHandleArray + cLevels;
                for ( pb = pBrushHandleArray; pb < pbOut + cLevels; pb++ ) {
                        if (*pb) {
                                DeleteObject(*pb);
                        }
                }
        }
        if ( hBrushHandleArray ) {
                LocalUnlock( hBrushHandleArray );
                LocalFree( hBrushHandleArray );
        }
        if ( hbPixelOff ) {
                DeleteObject( hbPixelOff );
        }
        if ( hbBlue ) {
                DeleteObject( hbBlue );
        }
}

//*****************************************************************************
//************************   P R I N T   F I X E D   **************************
//*****************************************************************************

void PrintPointFX( LPSTR lpszIntro, POINTFX pfx )
{
    //  dprintf( "%Fs%d.%.3u, %d.%.3u", lpszIntro,
    //                                  pfx.x.value, (int)(((long)pfx.x.fract*1000L)/65536L),
    //                                  pfx.y.value, (int)(((long)pfx.y.fract*1000L)/65536L)  );

    long l1, l2;

    l1 = *(LONG *)&pfx.x.fract;
    l2 = *(LONG *)&pfx.y.fract;
    dprintf( "%Fs%.3f,%.3f", lpszIntro, (double)(l1) / 65536.0, (double)(l2) / 65536.0 );
}

//*****************************************************************************
//****************************   M A P   F X   ********************************
//*****************************************************************************

double FixedToFloat( FIXED fx )
{
    return (double)(*(long *)&fx) / 65536.0;
}

//*****************************************************************************
//****************************   M A P   F X   ********************************
//*****************************************************************************

double dxLPI, dyLPI, dxScale, dyScale;

int MapFX( FIXED fx )
{
    return (int)(dxScale * FixedToFloat(fx));
}

//*****************************************************************************
//****************************   M A P   F Y   ********************************
//*****************************************************************************

int MapFY( FIXED fy )
{
    return (int)(dyScale * FixedToFloat(fy));
}

//*****************************************************************************
//************************   D R A W   X   M A R K   **************************
//*****************************************************************************

int xdx = 2;
int xdy = 2;

void DrawXMark( HDC hdc, POINTFX ptfx )
{
    int  x, y;

    x = MapFX( ptfx.x );
    y = MapFY( ptfx.y );


    MoveToEx( hdc, x-xdx, y-xdy ,0);
    LineTo( hdc, x+xdx, y+xdy );
    MoveToEx( hdc, x-xdx, y+xdy , 0);
    LineTo( hdc, x+xdx, y-xdy );
}


//*****************************************************************************
//**********************   D R A W   T 2   C U R V E   ************************
//*****************************************************************************

typedef struct _PTL
{
    LONG x;
    LONG y;
} PTL, FAR *LPPTL;

//
//
//   Formula for the T2 B-Spline:
//
//
//     f(t) = (A-2B+C)*t^2 + (2B-2A)*t + A
//
//   where
//
//     t = 0..1
//
//

void DrawT2Curve( HDC hdc, PTL ptlA, PTL ptlB, PTL ptlC )
{
    double x, y;
    double fax, fbx, fcx, fay, fby, fcy, ax, vx, x0, ay, vy, y0, t;

    fax = (double)(ptlA.x) / 65536.0;
    fbx = (double)(ptlB.x) / 65536.0;
    fcx = (double)(ptlC.x) / 65536.0;

    fay = (double)(ptlA.y) / 65536.0;
    fby = (double)(ptlB.y) / 65536.0;
    fcy = (double)(ptlC.y) / 65536.0;

    ax = fax - 2*fbx + fcx;
    vx = 2*fbx - 2*fax;
    x0 = fax;

    ay = fay - 2*fby + fcy;
    vy = 2*fby - 2*fay;
    y0 = fay;

    MoveToEx( hdc, (int)(dxScale*x0), (int)(dyScale*y0) , 0);

    for( t = 0.0; t < 1.0; t += 1.0/10.0 ) {
        x = ax*t*t + vx*t + x0;
        y = ay*t*t + vy*t + y0;
        LineTo( hdc, (int)(dxScale*x), (int)(dyScale*y) );
    }
}

//*****************************************************************************
//************************   D R A W   N A T I V E   **************************
//*****************************************************************************

void DrawNative( HWND hwnd, HDC hdc )
{
    DWORD  dwrc;
    LPBYTE            lpb;
    LPTTPOLYGONHEADER lpph, pTTPH;
    HPEN   hPen;
    int    nItem;
    long   cbOutline, cbTotal;

        hPen = 0;
        pTTPH = 0;

    //-------------------  Query Buffer Size and Allocate It  ---------------------

    dprintf( "GetGlyphOutline native size '%c'", wChar );
   	if (! isCharCodingUnicode)
		dwrc =
			lpfnGetGlyphOutlineA(
				hdcTest,
				wChar,
				(GGO_NATIVE | gGGO.flags),
				&gm,
				0,
				0,
				&mat2
				);
	else
		dwrc =
			lpfnGetGlyphOutlineW(
				hdcTest,
				wChar,
				(GGO_NATIVE | gGGO.flags),
				&gm,
				0,
				0,
				&mat2
				);

    dprintf( "  dwrc            = %ld",   dwrc );
    dprintf( "  gmBlackBoxX,Y   = %u,%u", gm.gmBlackBoxX, gm.gmBlackBoxY );
    dprintf( "  gmptGlyphOrigin = %d,%d", gm.gmptGlyphOrigin.x, gm.gmptGlyphOrigin.y );
    dprintf( "  gmCellIncX,Y    = %d,%d", gm.gmCellIncX, gm.gmCellIncY );

    if( (long)dwrc == -1L || dwrc == 0L ) {
        dprintf( "*** GetGlyphOutline failed" );
        goto Exit;
    }

// font seals.ttf with glyph having 20K+ points goes over this limit
//    if( dwrc > 16384L ) {
//        dprintf( "Reported native size questionable (>16K), aborting" );
//        goto Exit;
//    }

    pTTPH = lpph = (LPTTPOLYGONHEADER) calloc( 1, dwrc );
    if( pTTPH == NULL ) {
        dprintf( "*** Native calloc failed!" );
        goto Exit;
    }

    //-----------------------  Get Native Format Buffer  --------------------------

    lpph->cb = dwrc;

    dprintf( "Calling GetGlyphOutline for native format" );
   	if (! isCharCodingUnicode)
		dwrc =
			lpfnGetGlyphOutlineA(
				hdcTest,
				wChar,
				(GGO_NATIVE | gGGO.flags),
				&gm,
				dwrc,
				(LPPOINT)lpph,
				&mat2
				);
	else
		dwrc =
			lpfnGetGlyphOutlineW(
				hdcTest,
				wChar,
				(GGO_NATIVE | gGGO.flags),
				&gm,
				dwrc,
				(LPPOINT)lpph,
				&mat2
				);

    dprintf( "  dwrc = %lu", dwrc );

    if( (long)dwrc == -1L || dwrc == 0L ) {
        dprintf( "*** GetGlyphOutline failed" );
        goto Exit;
    }

    //--------------------  Print Out the Buffer Contents  ------------------------

    dxLPI   = (double)xLPI;
    dyLPI   = (double)yLPI;
    dxScale = (double)Scale;
    dyScale = (double)Scale * dxLPI / dyLPI;

    cbTotal = dwrc;
    while( cbTotal > 0 ) {
        HPEN    hPenOld;
        POINTFX ptfxLast;

        dprintf( "Polygon Header:" );
        dprintf(      "  cb       = %lu", lpph->cb       );
        dprintf(      "  dwType   = %d",  lpph->dwType   );
        PrintPointFX( "  pfxStart = ",    lpph->pfxStart );

        DrawXMark( hdc, lpph->pfxStart );

        nItem = 0;
        lpb   = (LPBYTE)lpph + sizeof(TTPOLYGONHEADER);

        //----  Calculate size of data  ----

        cbOutline = (long)lpph->cb - sizeof(TTPOLYGONHEADER);
        ptfxLast = lpph->pfxStart;        // Starting Point
        while( cbOutline > 0 ) {
            int           n;
            UINT          u;
            LPTTPOLYCURVE lpc;

            dprintf( "  cbOutline = %ld", cbOutline );
            nItem++;
            lpc = (LPTTPOLYCURVE)lpb;
            switch( lpc->wType ) {
            case TT_PRIM_LINE:

                dprintf( "  Item %d: Line",         nItem );
                break;

            case TT_PRIM_QSPLINE:

                dprintf( "  Item %d: QSpline",      nItem );
                break;

            default:

                dprintf( "  Item %d: unknown type %u", nItem, lpc->wType );
                break;
            }
            dprintf( "    # of points: %d", lpc->cpfx );
            for( u = 0; u < lpc->cpfx; u++ ) {
                PrintPointFX( "      Point = ", lpc->apfx[u] );
                DrawXMark( hdc, lpc->apfx[u] );
            }
            hPen = CreatePen(PS_SOLID, 2, RGB(255,255,0));
            hPenOld = SelectObject( hdc, hPen );
            switch( lpc->wType ) {
            case TT_PRIM_LINE:
                {
                int x, y;

                x = MapFX( ptfxLast.x );
                y = MapFY( ptfxLast.y );
                MoveToEx( hdc, x, y , 0);
                for( u = 0; u < lpc->cpfx; u++ ) {
                    x = MapFX( lpc->apfx[u].x );
                    y = MapFY( lpc->apfx[u].y );
                    LineTo( hdc, x, y );
                }
                break;
                }

            case TT_PRIM_QSPLINE:
                {
                LPPTL lpptls;
                PTL   ptlA, ptlB, ptlC;

                ptlA = *(LPPTL)&ptfxLast;         // Convert to LONG POINT
                lpptls = (LPPTL)lpc->apfx;        // LONG POINT version

                for( u = 0; u < (UINT) lpc->cpfx-1; u++ ) {
                    ptlB = lpptls[u];

                    // If not on last spline, compute C

                    if ( u < (UINT) lpc->cpfx-2 ) {
                        ptlC.x = (ptlB.x + lpptls[u+1].x) / 2;
                        ptlC.y = (ptlB.y + lpptls[u+1].y) / 2;
                    } else {
                        ptlC = lpptls[u+1];
                    }
                    DrawT2Curve( hdc, ptlA, ptlB, ptlC );
                    ptlA = ptlC;
                }
                break;
                }
            }
            SelectObject( hdc, hPenOld );
            ptfxLast = lpc->apfx[lpc->cpfx-1];
            n          = sizeof(TTPOLYCURVE) + sizeof(POINTFX) * (lpc->cpfx - 1);
            lpb       += n;
            cbOutline -= n;
        }

        if( memcmp( &ptfxLast, &lpph->pfxStart, sizeof(ptfxLast) ) ) {
            HPEN hPenOld;
            int  x, y;

            hPenOld = SelectObject( hdc, hPen );
            x = MapFX( ptfxLast.x );
            y = MapFY( ptfxLast.y );
            MoveToEx( hdc, x, y , 0);
            x = MapFX( lpph->pfxStart.x );
            y = MapFY( lpph->pfxStart.y );
            LineTo( hdc, x, y );
            SelectObject( hdc, hPenOld );
        }
        dprintf( "ended at cbOutline = %ld", cbOutline );
        cbTotal -= lpph->cb;
        lpph     = (LPTTPOLYGONHEADER)lpb;
    }
    dprintf( "ended at cbTotal = %ld", cbTotal );

Exit:
        if (hPen)
                DeleteObject(hPen);
    if( pTTPH )
        free( pTTPH );
}

//*****************************************************************************
//**************************   D R A W   A B C   ******************************
//*****************************************************************************

void DrawABC( HWND hwnd, HDC hdc )
{
    int   rc;
    ABC   abc;

    abc.abcA = 0;
    abc.abcB = 0;
    abc.abcC = 0;

    if (! isCharCodingUnicode)
        dprintf( "Calling GetCharABCWidthsA" );
    else
        dprintf( "Calling GetCharABCWidthsW" );

	if (! isCharCodingUnicode)
		rc = lpfnGetCharABCWidthsA( hdcTest, wChar, wChar, (LPABC)&abc );
	else
		rc = lpfnGetCharABCWidthsW( hdcTest, wChar, wChar, (LPABC)&abc );
    dprintf( "    rc = %d", rc );

    dprintf( "  A = %d, B = %u, C = %d", abc.abcA, abc.abcB, abc.abcC );

    abc.abcA  = MulDiv( abc.abcA, xVE, xWE );
    abc.abcB  = MulDiv( abc.abcB, xVE, xWE );
    abc.abcC  = MulDiv( abc.abcC, xVE, xWE );

    SelectObject( hdc, hPenA );
    MoveToEx( hdc, MapX(abc.abcA), MapY(-tm.tmDescent) - Margin/4 , 0);
    LineTo( hdc, MapX(abc.abcA), MapY(tm.tmAscent) );

    SelectObject( hdc, hPenB );
    MoveToEx( hdc, MapX(abc.abcA+abc.abcB), MapY(-tm.tmDescent) - Margin/2 ,0);
    LineTo( hdc, MapX(abc.abcA+abc.abcB), MapY(tm.tmAscent) );

    SelectObject( hdc, hPenC );
    MoveToEx( hdc, MapX(abc.abcA+abc.abcB+abc.abcC), MapY(-tm.tmDescent) - (3*Margin)/4 ,0);
    LineTo( hdc, MapX(abc.abcA+abc.abcB+abc.abcC), MapY(tm.tmAscent) );
}

//*****************************************************************************
//************************   D R A W   G L Y P H   ****************************
//*****************************************************************************

void DrawGlyph( HWND hwnd, HDC hdc )
{
    dprintf( "DrawGlyph" );
    if (!isCharCodingUnicode)
        dprintf( "  lfHeight, Width = %d,%d", elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight, 
            elfdvA.elfEnumLogfontEx.elfLogFont.lfWidth );
    else
        dprintf( "  lfHeight, Width = %d,%d", elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight, 
            elfdvW.elfEnumLogfontEx.elfLogFont.lfWidth );

    DrawBox(    hwnd, hdc );
    DrawBitmap( hwnd, hdc );
    if( wMode == IDM_NATIVEMODE ) {
        DrawNative( hwnd, hdc );
    }
    if( wMode == IDM_BEZIERMODE ) {
        DrawBezier( hwnd, hdc );
    }
    DrawABC(    hwnd, hdc );
    dprintf( "Done drawing glyph" );
}

//*****************************************************************************
//***********************   W R I T E   G L Y P H   ***************************
//*****************************************************************************

#define MAX_BUFFER  8192

/*+++

    WriteGlyph creates at bitmap file (.bmf) for the
    current glyph in the current mode.

---*/

void WriteGlyph( LPSTR lpszFile )
{
    int x, y, cbRaster, fh;
    HANDLE hStart;
    DWORD  dwrc;
    BITMAPFILEHEADER bfh;
    BITMAPINFOHEADER bih;
    HLOCAL hmemRGB;
    RGBQUAD *argb, *prgb, *prgbLast;
    unsigned cjRGB; // size of RGB array in BYTE's
    BYTE i, E, Q, R, cLevels;
    WORD wByte;
    BYTE *lpBuffer, *lpb, *hpb, *hpbStart;

    // ajGamma is a an array of gamma corrected
    // color values. This is used to convert
    // from color space to voltage space.
    //
    //  ajGamma[i] = floor( ((i/255)^gamma - 1 + 1/2 )
    //
    //  gamma = 2.33
    //
    //  i = 0..255 (color value)
    //
    //  ajGamma[i] (voltage value) = 0..255

    static const BYTE ajGamma[256] = {
       0, 0x00, 0x01, 0x01, 0x02, 0x02, 0x03, 0x03
  , 0x04, 0x04, 0x05, 0x05, 0x06, 0x07, 0x07, 0x08
  , 0x09, 0x09, 0x0a, 0x0b, 0x0b, 0x0c, 0x0d, 0x0d
  , 0x0e, 0x0f, 0x10, 0x10, 0x11, 0x12, 0x13, 0x13
  , 0x14, 0x15, 0x16, 0x17, 0x17, 0x18, 0x19, 0x1a
  , 0x1b, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x1f, 0x20
  , 0x21, 0x22, 0x23, 0x24, 0x25, 0x25, 0x26, 0x27
  , 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2c, 0x2d, 0x2e
  , 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x35
  , 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d
  , 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45
  , 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c
  , 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54
  , 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c
  , 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64
  , 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d
  , 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75
  , 0x76, 0x77, 0x78, 0x79, 0x7b, 0x7c, 0x7d, 0x7e
  , 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86
  , 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f
  , 0x90, 0x91, 0x92, 0x94, 0x95, 0x96, 0x97, 0x98
  , 0x99, 0x9a, 0x9b, 0x9c, 0x9e, 0x9f, 0xa0, 0xa1
  , 0xa2, 0xa3, 0xa4, 0xa5, 0xa7, 0xa8, 0xa9, 0xaa
  , 0xab, 0xac, 0xad, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3
  , 0xb4, 0xb5, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc
  , 0xbd, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc6
  , 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcd, 0xce, 0xcf
  , 0xd0, 0xd1, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8
  , 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xe0, 0xe1, 0xe2
  , 0xe3, 0xe4, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xec
  , 0xed, 0xee, 0xef, 0xf0, 0xf2, 0xf3, 0xf4, 0xf5
  , 0xf6, 0xf8, 0xf9, 0xfa, 0xfb, 0xfd, 0xfe, 0xff
  };

    CreateTestDC();
    hStart = 0;
    dprintf( "GetGlyphOutline bitmap size '%c'", wChar );
	if (! isCharCodingUnicode)
		dwrc =
			lpfnGetGlyphOutlineA(
				hdcTest,
				wChar,
				(GGO_BITMAP | gGGO.flags),
				&gm,
				0,
				0,
				&mat2
				);
	else
		dwrc =
			lpfnGetGlyphOutlineW(
				hdcTest,
				wChar,
				(GGO_BITMAP | gGGO.flags),
				&gm,
				0,
				0,
				&mat2
				);

    dprintf( "  dwrc            = %ld",   dwrc );
    dprintf( "  gmBlackBoxX,Y   = %u,%u", gm.gmBlackBoxX, gm.gmBlackBoxY );
    dprintf( "  gmptGlyphOrigin = %d,%d", gm.gmptGlyphOrigin.x, gm.gmptGlyphOrigin.y );
    dprintf( "  gmCellIncX,Y    = %d,%d", gm.gmCellIncX, gm.gmCellIncY );

    if( dwrc == (unsigned) -1 || dwrc == 0 ) {
        dprintf( "*** GetGlyphOutline failed" );
        goto Exit;
    }
    if( gm.gmBlackBoxX * gm.gmBlackBoxY / 8 > (WORD)dwrc ) {
        dprintf( "BOGUS bitmap size!" );
        dprintf( "  BlackBoxX,Y says %u bytes", gm.gmBlackBoxX * gm.gmBlackBoxY / 8 );
        dprintf( "  GetGlyphOutline says %lu bytes", dwrc );
        goto Exit;
    }
    hStart   = GlobalAlloc( GMEM_MOVEABLE, dwrc );
    dprintf( "  hStart = 0x%.4X", hStart );
    if( !hStart ) {
        goto Exit;
    }
    hpbStart = (HPBYTE)GlobalLock( hStart );
    dprintf( "  hpbStart = 0x%.8lX", hpbStart );
    if( !hpbStart ) {
        goto Exit;
    }
    dprintf( "Calling GetGlyphOutline for bitmap" );
   	if (! isCharCodingUnicode)
		dwrc =
			lpfnGetGlyphOutlineA(
			hdcTest,
			wChar,
			(gGGO.gray | gGGO.flags),
			&gm,
			dwrc,
			(LPBYTE)hpbStart,
			&mat2
			);
	else
		dwrc =
			lpfnGetGlyphOutlineW(
			hdcTest,
			wChar,
			(gGGO.gray | gGGO.flags),
			&gm,
			dwrc,
			(LPBYTE)hpbStart,
			&mat2
			);

    dprintf( "  dwrc            = %u",   dwrc );
    if( dwrc == (unsigned) -1 || dwrc == 0 ) {
        dprintf( "*** GetGlyphOutline failed" );
        goto Exit;
    }
    fh = _lcreat( "GLYPH.BMP", 0 );
    dprintf( "  fh = %d", fh );
    if( fh == HFILE_ERROR ) {
        goto Exit;
    }

    // cLevels    =: number of possible values in bitmap. The allowed values
    //               are 0..cLevels-1
    // biClrUsed  =: number of colors used in palette that follows immediately
    //               after the BITMAPINFOHEADER data. This number is equal to
    //               cLevels which is what you will find for all the gray
    //               bitmap cases. Monochrome is special, because we set biClrUsed
    //               to zero. This indicates that the number of colors used is
    //               equal to 2^biBitCount. In the case of monochrome biBitCount = 1
    //               and so 2^biBitCount = 2^1 = 2 = cLevels.
    // biBitCount =: Number of bits assigned to each pixel = 1 (monochrome), 8 gray

    switch ( gGGO.gray ) {
    case GGO_BITMAP:
                // monochrome to you and me
        cLevels = 2;
        bih.biClrUsed  = 0;
        bih.biBitCount = 1;
        break;
    case GGO_GRAY2_BITMAP:
        bih.biClrUsed  = cLevels = 5;
        bih.biBitCount = 8;
        break;
    case GGO_GRAY4_BITMAP:
        bih.biClrUsed  = cLevels = 17;
        bih.biBitCount = 8;
        break;
    case GGO_GRAY8_BITMAP:
        bih.biClrUsed  = cLevels = 65;
        bih.biBitCount = 8;
        break;
    default:
        dprintf( " gGGO = %-#x is bogus", (gGGO.gray | gGGO.flags));
        goto Exit;
    }

#define SIZEOFBMFH 14

    cjRGB           = cLevels * sizeof(RGBQUAD);
    bfh.bfOffBits   = SIZEOFBMFH + sizeof(bih) + cjRGB;

    bfh.bfType      = (((UINT)'M') << 8) + (UINT)'B';
    bfh.bfSize      = bfh.bfOffBits + dwrc;
    bfh.bfReserved1 = 0;
    bfh.bfReserved2 = 0;

    // we have to write the header to the file just like a 16-bit
    // x86 machine would have

    dprintf("  Writing BITMAPFILEHEADER:");

    dwrc = (DWORD) _lwrite((HFILE) fh,(const char*) &bfh.bfType, sizeof(bfh.bfType) );
    if (dwrc != HFILE_ERROR)
        dprintf("   bfType      = %2x (%u bytes)", bfh.bfType, dwrc);
    dwrc = (DWORD) _lwrite((HFILE) fh,(const char*) &bfh.bfSize, sizeof(bfh.bfSize) );
    if (dwrc != HFILE_ERROR)
        dprintf("   bfSize      = %u (%u bytes)", bfh.bfSize, dwrc);
    dwrc = (DWORD) _lwrite((HFILE) fh,(const char*) &bfh.bfReserved1, sizeof(bfh.bfReserved1));
    if (dwrc != HFILE_ERROR)
        dprintf("   bfReserved1 = %u (%u bytes)", bfh.bfReserved1, dwrc);
    dwrc = (DWORD) _lwrite((HFILE) fh,(const char*) &bfh.bfReserved2, sizeof(bfh.bfReserved2));
    if (dwrc != HFILE_ERROR)
        dprintf("   bfReserved2 = %u (%u bytes)", bfh.bfReserved2, dwrc);
    dwrc = (DWORD) _lwrite((HFILE) fh,(const char*) &bfh.bfOffBits,   sizeof(bfh.bfOffBits)  );
    if (dwrc != HFILE_ERROR)
        dprintf("   bfOffBits   = %u (%u bytes)", bfh.bfOffBits, dwrc);

    // the file pointer is now at byte number 14 in the file

    // fortunately all the elements of the BITINFOHEADER are aligned
    // so a straight forward copy to the file will produce something
    // than an old 16-bit x86 machine would be happy with

    bih.biSize          = sizeof(bih);
    bih.biWidth         = gm.gmBlackBoxX;
    bih.biHeight        = gm.gmBlackBoxY;
    bih.biPlanes        = 1;        // required value
  //bih.biBitCount already set
    bih.biCompression   = BI_RGB;   // uncompressed format
    bih.biSizeImage     = 0;        // may be zero for BI_RGB bitmaps
    bih.biXPelsPerMeter = 1;        // nobody cares about this anyway
    bih.biYPelsPerMeter = 1;        // nobody cares about this anyway
  //bih.biClrUsed already set
    bih.biClrImportant  = 0;        // indicates that all colors are important

    dprintf( "  Writing BITMAPINFOHEADER: rc = %d", _lwrite( fh, (LPCSTR) &bih, sizeof(bih)));
    dprintf( "  biSize          = %u", bih.biSize         );
    dprintf( "  biWidth         = %d", bih.biWidth        );
    dprintf( "  biHeight        = %d", bih.biHeight       );
    dprintf( "  biPlanes        = %d", bih.biPlanes       );
    dprintf( "  biBitCount      = %u", bih.biBitCount     );
    dprintf( "  biCompression   = %u", bih.biCompression  );
    dprintf( "  biSizeImage     = %u", bih.biSizeImage    );
    dprintf( "  biXPelsPerMeter = %d", bih.biXPelsPerMeter);
    dprintf( "  biYPelsPerMeter = %d", bih.biYPelsPerMeter);
    dprintf( "  biClrUsed       = %u", bih.biClrUsed      );
    dprintf( "  biClrImportant  = %u", bih.biClrImportant );
    dprintf( " " );

    // create a palette in memory corresponding to the
    // voltages corresponding to the glyph in question

    hmemRGB = LocalAlloc(LMEM_FIXED, cLevels * sizeof(*argb));
    if ( hmemRGB == 0 ) {
        dprintf("  LocalAlloc Failed");
        goto Exit;
    }
    argb = (RGBQUAD*) LocalLock(hmemRGB);
    if ( argb == 0 ) {
        dprintf(" LocalLock Failed");
        goto Exit;
    }

    Q = 256 / cLevels;                       // scaled level increment
    R = 256 % cLevels;                       // error increment
    E = cLevels - (cLevels / 2) - 1 ;        // initialize error term

    dprintf( "RGBQUAD array" );
    prgb     = argb;
    prgbLast = argb + (unsigned) cLevels - 1;
    for (i = 0; prgb < prgbLast; prgb++, i += Q, E -= R) {
        if ( (char) E < 0 ) {
            i += 1;
            E += cLevels;
        }
        prgb->rgbRed = prgb->rgbGreen = prgb->rgbBlue = ajGamma[i];
        prgb->rgbReserved = 0;
        dprintf("      %2x", ajGamma[i]);
    }
    prgb->rgbRed = prgb->rgbGreen = prgb->rgbBlue = 255;
    prgb->rgbReserved = 0;
    dprintf("      %2x", 255);
    // assert(prgb == prgbLast);
    // assert(ajGamma[255] == 255);

    // write the palette to the file

    dwrc = _lwrite( fh,(LPCSTR) argb, cjRGB );
    dprintf( " Writing RGBQUAD's rc = %u", dwrc);
    if ( dwrc == HFILE_ERROR ) {
        goto Exit;
    }

    // calculate the number of bytes per scan

    cbRaster = gm.gmBlackBoxX;
    cbRaster = gGGO.gray == GGO_BITMAP ? (cbRaster+31)/32 : (cbRaster+3)/4;
    cbRaster *= sizeof(DWORD);
    dprintf( "  cbRaster = %d", cbRaster );

    lpBuffer = (LPBYTE)malloc( MAX_BUFFER );
    dprintf( "  lpBuffer = 0x%.8lX", lpBuffer );

    wByte    = 0;
    lpb    = lpBuffer;

    // the TrueType bitmap has the top of the image at the lowest address
    // in memory whereas it is the windows convention that a bitmap
    // is usually rasterized bottom to to top so we must reverse
    // the scans when copying to file.
    //
    // MikeGi's strategy is to start at the last tt scan in memory and
    // copy the bytes to a buffer checking each time to see if the buffer
    // is full. Whenever the buffer is full it is flushed to the file.
    // Upon the completion of a scan, the pointer to the source image is
    // decremented to the start of previous scan in memory.

    for ( y = gm.gmBlackBoxY-1; y >= 0; y-- ) {
        hpb = hpbStart + (long)y * (long) cbRaster;
        for ( x = 0; x < cbRaster; x++ ) {
            *lpb++ = *hpb++;                            // write to buffer
            wByte++;                                    // inc buffer count
            if ( wByte == MAX_BUFFER ) {                // is buffer full?
                dprintf( "Writing %u bytes", wByte );   // yes, flush
                _lwrite( fh, lpBuffer, wByte );
                wByte = 0;
                lpb   = lpBuffer;                       // reset pointer
            }                                           // into buffer
        }                                               // to point to start
    }
    if( wByte > 0 ) {                                   // stuff left
        dprintf( "Writing %u bytes", wByte );           // in buffer?
        _lwrite( fh, lpBuffer, wByte );                 // yes, flush
    }
    dprintf( "Closing .BMP file" );
    _lclose( fh );
    free( lpBuffer );

Exit:
    if( hpbStart ) {
        GlobalUnlock( hStart );
    }
    if( hStart   ) {
        GlobalFree( hStart );
    }
    if ( argb ) {
        if ( hmemRGB ) {
            LocalUnlock( hmemRGB );
            LocalFree( hmemRGB );
        }
    }
    DestroyTestDC();
}

//*****************************************************************************
//*********************   G L Y P H   W N D   P R O C   ***********************
//*****************************************************************************

LRESULT CALLBACK GlyphWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    HDC         hdc;
    PAINTSTRUCT ps;
    HCURSOR     hCursor;

    switch( msg )     {
    case WM_CREATE:

        lstrcpy( szText, "Hello" );
        hPenOutline   = CreatePen( PS_SOLID, 1, RGB(   0, 255, 255 ) );
        hPenA         = CreatePen( PS_SOLID, 1, RGB( 255,   0,   0 ) );
        hPenB         = CreatePen( PS_SOLID, 1, RGB( 255,   0, 255 ) );
        hPenC         = CreatePen( PS_SOLID, 1, RGB(   0, 255,   0 ) );
        hPenBox       = CreatePen( PS_SOLID, 1, RGB(  32,  32,  32 ) );
        hBrushAscend  = CreateSolidBrush( ASCENDERCOLOR );
        hBrushDescend = CreateSolidBrush( DESCENDERCOLOR );
        deM11 = deM22 = 1.0;
        deM12 = deM21 = 0.0;
        return 0;

    case WM_PAINT:

        hCursor = SetCursor( LoadCursor( NULL, MAKEINTRESOURCE(IDC_WAIT) ) );
        ShowCursor( TRUE );
        ClearDebug();
        dprintf( "Painting glyph window" );
        hdc = BeginPaint( hwnd, &ps );
        SetTextCharacterExtra( hdc, nCharExtra );
        SetTextJustification( hdc, nBreakExtra, nBreakCount );
        CreateTestDC();
        DrawGlyph( hwnd, hdc );
        DestroyTestDC();
        SelectObject( hdc, GetStockObject( BLACK_PEN ) );
        EndPaint( hwnd, &ps );
        dprintf( "Finished painting" );
        ShowCursor( FALSE );
        SetCursor( hCursor );
        return 0;

    case WM_CHAR:

        wChar = (WORD) wParam;
        InvalidateRect( hwndGlyph, NULL, TRUE );
        return 0;

    case WM_DESTROY:

        DeleteObject( hPenOutline );
        DeleteObject( hPenA );
        DeleteObject( hPenB );
        DeleteObject( hPenC );
        DeleteObject( hPenBox );
        DeleteObject( hBrushAscend );
        DeleteObject( hBrushDescend );
        return 0;
    }
    return DefWindowProc( hwnd, msg, wParam, lParam );
}

//*****************************************************************************
//*****************   S E T   D L G   I T E M   F L O A T   *******************
//*****************************************************************************

void SetDlgItemFloat( HWND hdlg, int id, double d )
{
    char szText[32];

    sprintf( szText, "%.3f", d );
    SetDlgItemText( hdlg, id, szText );
}

//*****************************************************************************
//*****************   G E T   D L G   I T E M   F L O A T   *******************
//*****************************************************************************

double GetDlgItemFloat( HWND hdlg, int id )
{
    char szText[32];

    szText[0] = 0;
    GetDlgItemText( hdlg, id, szText, sizeof(szText) );

    return atof( szText );
}

//*****************************************************************************
//*********************   F L O A T   T O   F I X E D   ***********************
//*****************************************************************************

FIXED FloatToFixed( double d )
{
    long l;

    l = (long)(d * 65536L);
    return *(FIXED *)&l;
}

//*****************************************************************************
//****************   G G O   M A T R I X   D L G   P R O C   ******************
//*****************************************************************************

INT_PTR CALLBACK GGOMatrixDlgProc( HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam )
{
    int iCheck;
    char szWchar[32];

    switch( msg ) {
    case WM_INITDIALOG:

        wsprintf(szWchar, "%x", wChar);
        SetDlgItemText( hdlg, IDD_WCHAR, szWchar );

        SetDlgItemFloat( hdlg, IDD_M11, deM11 );
        SetDlgItemFloat( hdlg, IDD_M12, deM12 );
        SetDlgItemFloat( hdlg, IDD_M21, deM21 );
        SetDlgItemFloat( hdlg, IDD_M22, deM22 );

        // clear all the buttons

        CheckDlgButton(hdlg, IDC_GGO_BITMAP,       0);
        CheckDlgButton(hdlg, IDC_GGO_NATIVE,       0);
        CheckDlgButton(hdlg, IDC_GGO_BEZIER,       0);
        CheckDlgButton(hdlg, IDC_GGO_METRICS,      0);
        CheckDlgButton(hdlg, IDC_GGO_GRAY2_BITMAP, 0);
        CheckDlgButton(hdlg, IDC_GGO_GRAY4_BITMAP, 0);
        CheckDlgButton(hdlg, IDC_GGO_GRAY8_BITMAP, 0);
        CheckDlgButton(hdlg, IDC_GGO_GLYPH_INDEX,  0);
        CheckDlgButton(hdlg, IDC_GGO_UNHINTED,     0);

        // one or none of the following can be set
        // GGO_BITMAP, GGO_NATIVE, GGO_METRICS, GGO_GRAY[248]

        switch ( gGGO.gray ) {
        case GGO_BITMAP:        iCheck = IDC_GGO_BITMAP;        break;
        case GGO_GRAY2_BITMAP:  iCheck = IDC_GGO_GRAY2_BITMAP;  break;
        case GGO_GRAY4_BITMAP:  iCheck = IDC_GGO_GRAY4_BITMAP;  break;
        case GGO_GRAY8_BITMAP:  iCheck = IDC_GGO_GRAY8_BITMAP;  break;
        default:
            dprintf("bogus gray value");
        }
        CheckDlgButton( hdlg, iCheck, 1 );

        // GGO_GLYPH_INDEX is set separately

        if ( gGGO.flags & GGO_GLYPH_INDEX )
            CheckDlgButton( hdlg, IDC_GGO_GLYPH_INDEX, 1 );
        if ( gGGO.flags & GGO_UNHINTED )
            CheckDlgButton( hdlg, IDC_GGO_UNHINTED, 1 );
        return TRUE;

    case WM_COMMAND:

        switch( LOWORD( wParam ) ) {
        case IDOK:

            deM11 = GetDlgItemFloat( hdlg, IDD_M11 );
            deM12 = GetDlgItemFloat( hdlg, IDD_M12 );
            deM21 = GetDlgItemFloat( hdlg, IDD_M21 );
            deM22 = GetDlgItemFloat( hdlg, IDD_M22 );

            mat2.eM11 = FloatToFixed( deM11 );
            mat2.eM12 = FloatToFixed( deM12 );
            mat2.eM21 = FloatToFixed( deM21 );
            mat2.eM22 = FloatToFixed( deM22 );

            gGGO.gray = gGGO.flags = 0;
            if (IsDlgButtonChecked(hdlg, IDC_GGO_BITMAP))
                gGGO.gray = GGO_BITMAP;
            else if (IsDlgButtonChecked(hdlg, IDC_GGO_GRAY2_BITMAP))
                gGGO.gray = GGO_GRAY2_BITMAP;
            else if (IsDlgButtonChecked(hdlg, IDC_GGO_GRAY4_BITMAP))
                gGGO.gray = GGO_GRAY4_BITMAP;
            else if (IsDlgButtonChecked(hdlg, IDC_GGO_GRAY8_BITMAP))
                gGGO.gray = GGO_GRAY8_BITMAP;
            else
                gGGO.gray = GGO_BITMAP;

            if (IsDlgButtonChecked(hdlg, IDC_GGO_GLYPH_INDEX)) {
                gGGO.flags |= GGO_GLYPH_INDEX;
            }

            if (IsDlgButtonChecked(hdlg, IDC_GGO_UNHINTED)) {
                gGGO.flags |= GGO_UNHINTED;
            }

            GetDlgItemText( hdlg, IDD_WCHAR, szWchar, sizeof(szWchar) );
            wChar = (WORD) strtol(szWchar, 0, 16);

            EndDialog( hdlg, TRUE );
            return TRUE;

        case IDCANCEL:

            EndDialog( hdlg, FALSE );
            return TRUE;
        }
        break;

        case WM_CLOSE:

            EndDialog( hdlg, FALSE );
            return TRUE;
    }
    return FALSE;
}






void DrawBezier( HWND hwnd, HDC hdc )
{
    DWORD  dwrc;
    LPBYTE            lpb;
    LPTTPOLYGONHEADER lpph, pTTPH;
    HPEN   hPen;
    int    nItem;
    long   cbOutline, cbTotal;
    POINT   *pptStart;

    hPen = 0;
    pTTPH = 0;

    if (!(hPen = CreatePen(PS_SOLID, 2, RGB(255,255,0))))
        return;


    //-------------------  Query Buffer Size and Allocate It  ---------------------

    dprintf( "GetGlyphOutline,  Bezier Mode, size '%c'", wChar );
	if (! isCharCodingUnicode)
		dwrc =
			lpfnGetGlyphOutlineA(
				hdcTest,
				wChar,
				(GGO_BEZIER | gGGO.flags),
				&gm,
				0,
				0,
				&mat2
				);
	else
		dwrc =
			lpfnGetGlyphOutlineW(
				hdcTest,
				wChar,
				(GGO_BEZIER | gGGO.flags),
				&gm,
				0,
				0,
				&mat2
				);

    dprintf( "  dwrc            = %ld",   dwrc );
    dprintf( "  gmBlackBoxX,Y   = %u,%u", gm.gmBlackBoxX, gm.gmBlackBoxY );
    dprintf( "  gmptGlyphOrigin = %d,%d", gm.gmptGlyphOrigin.x, gm.gmptGlyphOrigin.y );
    dprintf( "  gmCellIncX,Y    = %d,%d", gm.gmCellIncX, gm.gmCellIncY );

    if ((long)dwrc == -1L || dwrc == 0L ) {
        dprintf( "*** GetGlyphOutline failed" );
        return;
    }


    pTTPH = lpph = (LPTTPOLYGONHEADER) calloc( 1, (WORD)dwrc );
    if( pTTPH == NULL ) {
        dprintf( "*** Native calloc failed!" );
        return;
    }

    //-----------------------  Get Native Format Buffer  --------------------------

    lpph->cb = dwrc;

    dprintf( "Calling GetGlyphOutline for native format" );
   	if (! isCharCodingUnicode)
		dwrc =
			lpfnGetGlyphOutlineA(
				hdcTest,
				wChar,
				(GGO_BEZIER | gGGO.flags),
				&gm,
				dwrc,
				(LPPOINT)lpph,
				&mat2
				);
	else
		dwrc =
			lpfnGetGlyphOutlineW(
				hdcTest,
				wChar,
				(GGO_BEZIER | gGGO.flags),
				&gm,
				dwrc,
				(LPPOINT)lpph,
				&mat2
				);

    dprintf( "  dwrc = %lu", dwrc );

    if( (long)dwrc == -1L || dwrc == 0L ) {
        dprintf( "*** GetGlyphOutline failed" );
        if (pTTPH)
            free( pTTPH );
        return;
    }

    //--------------------  Print Out the Buffer Contents  ------------------------

    dxLPI   = (double)xLPI;
    dyLPI   = (double)yLPI;
    dxScale = (double)Scale;
    dyScale = (double)Scale * dxLPI / dyLPI;

    cbTotal = dwrc;
    while( cbTotal > 0 )
    {
        HPEN    hPenOld;

        dprintf( "Polygon Header:" );
        dprintf(      "  cb       = %lu", lpph->cb       );
        dprintf(      "  dwType   = %d",  lpph->dwType   );
        PrintPointFX( "  pfxStart = ",    lpph->pfxStart );

        DrawXMark( hdc, lpph->pfxStart );

        nItem = 0;
        lpb   = (LPBYTE)lpph + sizeof(TTPOLYGONHEADER);

        //----  Calculate size of data  ----

        cbOutline = (long)lpph->cb - sizeof(TTPOLYGONHEADER);
        pptStart = (POINT *)&lpph->pfxStart;        // Starting Point

        pptStart->x = MapFX(lpph->pfxStart.x );
        pptStart->y = MapFY(lpph->pfxStart.y );


        while( cbOutline > 0 )
        {
            int           n;
            UINT          u;
            LPTTPOLYCURVE lpc;

            dprintf( "  cbOutline = %ld", cbOutline );
            nItem++;
            lpc = (LPTTPOLYCURVE)lpb;
            switch( lpc->wType )
            {
            case TT_PRIM_LINE:

                dprintf( "  Item %d: Line",         nItem );
                break;

            case TT_PRIM_CSPLINE:

                dprintf( "  Item %d: CSpline",      nItem );
                break;

            default:

                dprintf( "  Item %d: unknown type %u", nItem, lpc->wType );
                break;
            }
            dprintf( "    # of points: %d", lpc->cpfx );
            for( u = 0; u < lpc->cpfx; u++ )
            {
                PrintPointFX( "      Point = ", lpc->apfx[u] );
                DrawXMark( hdc, lpc->apfx[u] );

                ((POINT *)lpc->apfx)[u].x = MapFX( lpc->apfx[u].x );
                ((POINT *)lpc->apfx)[u].y = MapFY( lpc->apfx[u].y );
            }
            hPenOld = SelectObject( hdc, hPen );

            MoveToEx( hdc, pptStart->x, pptStart->y , 0);

            switch( lpc->wType )
            {
            case TT_PRIM_LINE:

                PolylineTo(hdc, (POINT *)lpc->apfx, (DWORD)lpc->cpfx);
                break;

            case TT_PRIM_CSPLINE:

                PolyBezierTo(hdc, (POINT *)lpc->apfx, (DWORD)lpc->cpfx);
                break;
            }
            SelectObject( hdc, hPenOld );
            pptStart = (POINT *)&lpc->apfx[lpc->cpfx - 1];        // Starting Point
            n          = sizeof(TTPOLYCURVE) + sizeof(POINTFX) * (lpc->cpfx - 1);
            lpb       += n;
            cbOutline -= n;
        }

        hPenOld = SelectObject( hdc, hPen );
        pptStart = (POINT *)&lpph->pfxStart;        // Starting Point
        LineTo( hdc, pptStart->x, pptStart->y);
        SelectObject( hdc, hPenOld );

        dprintf( "ended at cbOutline = %ld", cbOutline );
        cbTotal -= lpph->cb;
        lpph     = (LPTTPOLYGONHEADER)lpb;
    }

    dprintf( "ended at cbTotal = %ld", cbTotal );

    if (hPen)
        DeleteObject(hPen);

    if( pTTPH )
        free( pTTPH );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\stringw.h ===
void    DrawString( HWND hwnd, HDC hdc );
LRESULT CALLBACK StringWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\waterfal.h ===
void    DrawWaterfall( HWND hwnd, HDC hdc );
LRESULT CALLBACK WaterfallWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\rings.h ===
void    DrawRings( HWND hwnd, HDC hdc );
LRESULT CALLBACK RingsWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\whirl.h ===
void    DrawWhirl( HWND hwnd, HDC hdc );
LRESULT CALLBACK WhirlWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\widths.c ===
#include <windows.h>
#include <commdlg.h>

#include <malloc.h>
#include <math.h>
#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include "fonttest.h"
#include "widths.h"


//*****************************************************************************
//************************   D R A W   W I D T H S   **************************
//*****************************************************************************

int xBase, yBase;
int cxCell, cyCell;

int aWidths[256];
ABC abcWidths[256];


void DrawWidths( HWND hwnd, HDC hdc )
 {
  HDC   hdcTest;
  HFONT hFont, hFontOld;
  int   iFontHeight;

  HFONT    hfNumA, hfNumAOld;
  LOGFONTA lfNumA;


  int    i, x, y;
  char szChars[10];
  char szHex[10];
  char szWidths[10];
  char szWidthsA[10];
  char szWidthsB[10];
  char szWidthsC[10];

  int  iDoubleLine = 2;

  TEXTMETRIC tm;

//-----------------------  Get Widths on Test IC  -----------------------------

  hdcTest = CreateTestIC();

  if (!isCharCodingUnicode)
    hFont    = CreateFontIndirectWrapperA( &elfdvA );
  else
    hFont    = CreateFontIndirectWrapperW( &elfdvW );

  hFontOld = SelectObject( hdcTest, hFont );

  for( i = 0; i < 256; i++ ) aWidths[i] = 0;

  GetCharWidth( hdcTest, 0, 255, aWidths );
  if (!GetCharABCWidths(hdcTest, 0, 255, abcWidths))
  {
      for (i = 0; i < 256 ; i++)
      {
          abcWidths[i].abcA = abcWidths[i].abcC = 0;
          abcWidths[i].abcB = aWidths[i];
      }
  }

  SelectObject( hdcTest, hFontOld );
  DeleteObject( hFont );

  DeleteDC( hdcTest );


//------------------------  Dump Widths to Screen  ----------------------------

  if (!isCharCodingUnicode)
  {
      iFontHeight = elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight;

      elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight = -MulDiv(10, GetDeviceCaps(hdc, LOGPIXELSY), 72);

      hFont    = CreateFontIndirectWrapperA( &elfdvA );
      hFontOld = SelectObject( hdc, hFont );

      // Restore the actual font height in the LOGFONT structure
      elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight = iFontHeight;

  }
  else
  {
      iFontHeight = elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight;
      elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight = -MulDiv(10, GetDeviceCaps(hdc, LOGPIXELSY), 72);

      hFont    = CreateFontIndirectWrapperW( &elfdvW );
      hFontOld = SelectObject( hdc, hFont );

      // Restore the actual font height in the LOGFONT structure
      elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight = iFontHeight;
  }

// we want all the numbers, ie charcode in hex, ABCD widths all in the same
// uniform arial font.
// We do not want to try to display those in the symbol font

  memset(&lfNumA, 0, sizeof(LOGFONTA));
  lfNumA.lfHeight = -MulDiv(10, GetDeviceCaps(hdc, LOGPIXELSY), 72);

  strcpy(lfNumA.lfFaceName, "Arial");
  hfNumA = CreateFontIndirectA(&lfNumA);

  GetTextMetrics( hdc, &tm );

  xBase  = tm.tmAveCharWidth;
  yBase  = tm.tmAscent;

  cxCell = 20; 
  cyCell = 18;

 // SetBkMode( hdc, OPAQUE );
 // SetBkColor( hdc,   PALETTERGB( 128, 128, 128 ) );

  for(i = 0; i < 256; i ++)
  {
      wsprintf(szChars, "%c ", (i ? i : 1));
      wsprintf(szHex, "%.2X ", i);
      wsprintf(szWidths, "%d ", aWidths[i]);
      wsprintf(szWidthsA, "%d ", abcWidths[i].abcA);
      wsprintf(szWidthsB, "%d ", abcWidths[i].abcB);
      wsprintf(szWidthsC, "%d ", abcWidths[i].abcC);

      x = xBase + 3*(i%16)*cxCell + iDoubleLine;
      y = yBase + 2*(i/16)*cyCell + iDoubleLine;

      SetTextColor( hdc, PALETTERGB(0, 0, 0));
      TextOut( hdc, x+iDoubleLine, y, szChars,  lstrlen(szChars)  );

      hfNumAOld = SelectObject(hdc, hfNumA); // we want these five numbers in arial

      TextOut( hdc, x+iDoubleLine, y+cyCell, szWidthsA,  lstrlen(szWidthsA)  );

      x += cxCell;

      TextOut( hdc, x, y, szHex,  lstrlen(szHex)  );
      TextOut( hdc, x, y+cyCell, szWidthsB,  lstrlen(szWidthsB)  );

      x += cxCell;
      TextOut( hdc, x, y, szWidths,  lstrlen(szWidths)  );
      TextOut( hdc, x, y+cyCell, szWidthsC,  lstrlen(szWidthsC)  );

      SelectObject(hdc, hfNumAOld);
   }

  for( x = 0; x <= 48; x++ )
   {
    MoveToEx( hdc, x * cxCell + xBase, yBase, 0);
    LineTo( hdc, x * cxCell + xBase, 32 * cyCell + yBase );

    if (x%3 == 0)
    {
        MoveToEx( hdc, x * cxCell + xBase + iDoubleLine, yBase, 0);
        LineTo( hdc, x * cxCell + xBase + iDoubleLine, 32 * cyCell + yBase );
    }
   }

  for( y = 0; y <= 32; y++ )
   {
    MoveToEx( hdc,               xBase, y * cyCell + yBase ,0);
    LineTo( hdc, 48 * cxCell + xBase, y * cyCell + yBase );

    if (y%2 == 0)
    {
        MoveToEx( hdc,               xBase, y * cyCell + yBase + iDoubleLine,0);
        LineTo( hdc, 48 * cxCell + xBase, y * cyCell + yBase + iDoubleLine);
    }
   }

  SelectObject( hdc, hFontOld );
  DeleteObject( hFont );
  DeleteObject(hfNumA);
 }


//*****************************************************************************
//********************   W I D T H S   W N D   P R O C   **********************
//*****************************************************************************

LRESULT CALLBACK WidthsWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
 {
  HDC         hdc;
  PAINTSTRUCT ps;
  HCURSOR     hCursor;


  switch( msg )
   {
    case WM_PAINT:
           hCursor = SetCursor( LoadCursor( NULL, MAKEINTRESOURCE(IDC_WAIT) ) );
           ShowCursor( TRUE );

           dprintf( "Calling DrawWidths" );

           hdc = BeginPaint( hwnd, &ps );

           SetTextCharacterExtra( hdc, nCharExtra );

           SetTextJustification( hdc, nBreakExtra, nBreakCount );

           DrawWidths( hwnd, hdc );

           EndPaint( hwnd, &ps );

           ShowCursor( FALSE );
           SetCursor( hCursor );

           return 0;

    case WM_DESTROY:
           return 0;
   }


  return DefWindowProc( hwnd, msg, wParam, lParam );
 }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\whirl.c ===
#include <windows.h>
#include <commdlg.h>

#include <malloc.h>
#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include "fonttest.h"
#include "whirl.h"

#include "dialogs.h"


//*****************************************************************************
//*************************   D R A W   W H I R L   ***************************
//*****************************************************************************

void DrawWhirl( HWND hwnd, HDC hdc )
 {
  int		iAngle;
  HFONT		hFont, hFontOld;
  HBRUSH	hOldBrush = NULL;
  HBRUSH	hBrush = NULL;

  for( iAngle = 0; iAngle < 3600; iAngle += 300 )
   {
    if (!isCharCodingUnicode)  {
        elfdvA.elfEnumLogfontEx.elfLogFont.lfEscapement  = elfdvA.elfEnumLogfontEx.elfLogFont.lfOrientation = iAngle;
        hFont    = CreateFontIndirectWrapperA( &elfdvA );
    }
    else {
        elfdvW.elfEnumLogfontEx.elfLogFont.lfEscapement  = elfdvW.elfEnumLogfontEx.elfLogFont.lfOrientation = iAngle;
        hFont    = CreateFontIndirectWrapperW( &elfdvW );
    }

    if( !hFont )
     {
      dprintf( "Couldn't create font for iAngle = %d", iAngle );
      continue;
     }

    hFontOld = SelectObject( hdc, hFont );

    SetBkMode( hdc, iBkMode );
    SetBkColor( hdc, dwRGBBackground );
    SetTextColor( hdc, dwRGBText );
    hBrush = CreateSolidBrush( dwRGBText );
    hOldBrush = SelectObject( hdc, hBrush );

    SetTextAlign( hdc, wTextAlign );

//    wsprintf( szText, "This is %s %dpt at %d%c", (LPSTR)lf.lfFaceName, lf.lfHeight, iAngle/10, 176 );
//    TextOut( hdc, cxDC/2, cyDC/2, szText, lstrlen(szText) );

    if (wUseGlyphIndex)
    {
        MyExtTextOut( hdc, xDC+cxDC/2, yDC+cyDC/2, wETO, 0, wszStringGlyphIndex, SizewszStringGlyph, lpintdx );
    }
    else
	if (!isCharCodingUnicode)
		MyExtTextOut( hdc, xDC+cxDC/2, yDC+cyDC/2, wETO, 0, szStringA, lstrlenA(szStringA), GetSpacing( hdc, szStringA ) );
	else
		MyExtTextOut( hdc, xDC+cxDC/2, yDC+cyDC/2, wETO, 0, szStringW, lstrlenW(szStringW), GetSpacing( hdc, szStringW ) );

    SelectObject( hdc, hOldBrush );
    DeleteObject( hBrush );
    SelectObject( hdc, hFontOld );
    DeleteObject( hFont );

    MoveToEx(hdc, xDC+cxDC/2-cxDC/150, yDC+cyDC/2          ,0);
    LineTo  (hdc, xDC+cxDC/2+cxDC/150, yDC+cyDC/2          );
    MoveToEx(hdc, xDC+cxDC/2,          yDC+cyDC/2-cxDC/150 ,0);
    LineTo  (hdc, xDC+cxDC/2,          yDC+cyDC/2+cxDC/150 );
   }

  if (!isCharCodingUnicode)
    elfdvA.elfEnumLogfontEx.elfLogFont.lfEscapement = elfdvA.elfEnumLogfontEx.elfLogFont.lfOrientation = 0;
  else
    elfdvW.elfEnumLogfontEx.elfLogFont.lfEscapement = elfdvW.elfEnumLogfontEx.elfLogFont.lfOrientation = 0;
 }


//*****************************************************************************
//*********************   W H I R L   W N D   P R O C   ***********************
//*****************************************************************************

LRESULT CALLBACK WhirlWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
 {
  HDC         hdc;
  PAINTSTRUCT ps;
  HCURSOR     hCursor;


  switch( msg )
   {
//    case WM_CREATE:
//           return NULL;


    case WM_CHAR:
           HandleChar( hwnd, wParam );
           return 0;


    case WM_PAINT:
           hCursor = SetCursor( LoadCursor( NULL, MAKEINTRESOURCE(IDC_WAIT) ) );
           ShowCursor( TRUE );

           //ClearDebug();
           //dprintf( "Drawing whirl" );

           hdc = BeginPaint( hwnd, &ps );
           SetDCMapMode( hdc, wMappingMode );

           SetTextCharacterExtra( hdc, nCharExtra );

           DrawDCAxis( hwnd, hdc , TRUE);

           DrawWhirl( hwnd, hdc );

           CleanUpDC( hdc );

           SelectObject( hdc, GetStockObject( BLACK_PEN ) );
           EndPaint( hwnd, &ps );

           //dprintf( "  Finished drawing whirl" );

           ShowCursor( FALSE );
           SetCursor( hCursor );

           return 0;

    case WM_DESTROY:
           return 0;
   }


  return DefWindowProc( hwnd, msg, wParam, lParam );
 }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\waterfal.c ===
#include <windows.h>
#include <commdlg.h>

#include <malloc.h>
#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include "fonttest.h"
#include "waterfal.h"

#include "dialogs.h"


//*****************************************************************************
//********************   D R A W   W A T E R F A L L   ************************
//*****************************************************************************

void DrawWaterfall( HWND hwnd, HDC hdc )
 {
  int		oldHeight, iSize, y;
  HFONT		hFont, hFontOld;
  POINT		ptl;
  HBRUSH	hOldBrush = NULL;
  HBRUSH	hBrush = NULL;

  DWORD dw;
  int   xWE, yWE, xVE, yVE;


  static TEXTMETRIC tm;
  static char       szTextA[128];
  static WCHAR      szTextW[128];



  if (!isCharCodingUnicode)
    oldHeight = elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight;
  else
    oldHeight = elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight;

  {
    SIZE size;

    GetWindowExtEx(hdc, &size);
    dw = (DWORD) (65536 * size.cy + size.cx);
  }
  xWE = abs(LOWORD(dw));
  yWE = abs(HIWORD(dw));

  {
      SIZE size;

      GetViewportExtEx(hdc, &size);
      dw = (DWORD) (65536 * size.cy + size.cx);
  }
  xVE = abs(LOWORD(dw));
  yVE = abs(HIWORD(dw));

//  dprintf( "xWE, yWE = %d, %d", xWE,yWE );
//  dprintf( "xVE, yVE = %d, %d", xVE,yVE );

  y = max( 10, yWE/10);

  for( iSize = 1; iSize < 31; iSize++ )
   {
    ptl.x = MulDiv( iSize, GetDeviceCaps(hdc,LOGPIXELSX), 72 );
    ptl.y = MulDiv( iSize, GetDeviceCaps(hdc,LOGPIXELSY), 72 );

    if (!isCharCodingUnicode)
    {
        elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight = -abs( MulDiv( ptl.y, yWE, yVE ) );
        elfdvA.elfEnumLogfontEx.elfLogFont.lfEscapement = 
            elfdvA.elfEnumLogfontEx.elfLogFont.lfOrientation = 0;
    }
    else
    {
        elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight = -abs( MulDiv( ptl.y, yWE, yVE ) );
        elfdvW.elfEnumLogfontEx.elfLogFont.lfEscapement = 
            elfdvW.elfEnumLogfontEx.elfLogFont.lfOrientation = 0;
    }

    if (!isCharCodingUnicode)
        hFont    = CreateFontIndirectWrapperA( &elfdvA );
    else
        hFont    = CreateFontIndirectWrapperW( &elfdvW );

    if( !hFont )
     {
      dprintf( "Couldn't create font for iSize = %d", iSize );
      continue;
     }

    hFontOld = SelectObject( hdc, hFont );
    GetTextMetrics( hdc, &tm );

//    dprintf( "Size,lfHgt,tmHgt = %d, %d, %d", iSize, lf.lfHeight, tm.tmHeight );

    SetBkMode( hdc, iBkMode );
    SetBkColor( hdc, dwRGBBackground );
    SetTextColor( hdc, dwRGBText );
    hBrush = CreateSolidBrush( dwRGBText );
    hOldBrush = SelectObject( hdc, hBrush );

	sprintf( szTextA, "%s @%dpt", (LPSTR)szStringA, iSize );
	swprintf( szTextW, L"%s @%dpt", (LPWSTR)szStringW, iSize );

    if (wUseGlyphIndex)
    {
        MyExtTextOut( hdc, max(10,xWE/10), y, wETO, 0, wszStringGlyphIndex, SizewszStringGlyph, lpintdx );
    }
    else
	if (!isCharCodingUnicode)
		MyExtTextOut( hdc, max(10,xWE/10), y, wETO, 0, szTextA, lstrlenA(szTextA), GetSpacing( hdc, szTextA ) );
	else
		MyExtTextOut( hdc, max(10,xWE/10), y, wETO, 0, szTextW, lstrlenW(szTextW), GetSpacing( hdc, szTextW ) );

    y += tm.tmHeight;

    SelectObject( hdc, hOldBrush );
    DeleteObject( hBrush );
    SelectObject( hdc, hFontOld );
    DeleteObject( hFont );
   }

   if (!isCharCodingUnicode)
     elfdvA.elfEnumLogfontEx.elfLogFont.lfHeight = oldHeight;
   else
     elfdvW.elfEnumLogfontEx.elfLogFont.lfHeight = oldHeight;

 }


//*****************************************************************************
//****************   W A T E R F A L L   W N D   P R O C   ********************
//*****************************************************************************

LRESULT CALLBACK WaterfallWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
 {
  HDC         hdc;
  PAINTSTRUCT ps;
  HCURSOR     hCursor;


  switch( msg )
   {
//    case WM_CREATE:
//           return NULL;

    case WM_PAINT:
           hCursor = SetCursor( LoadCursor( NULL, MAKEINTRESOURCE(IDC_WAIT) ) );
           ShowCursor( TRUE );

           hdc = BeginPaint( hwnd, &ps );
           SetDCMapMode( hdc, wMappingMode );

           SetTextCharacterExtra( hdc, nCharExtra );

           SetTextJustification( hdc, nBreakExtra, nBreakCount );

           DrawDCAxis( hwnd, hdc , TRUE);

           DrawWaterfall( hwnd, hdc );

           CleanUpDC( hdc );

           SelectObject( hdc, GetStockObject( BLACK_PEN ) );
           EndPaint( hwnd, &ps );

           ShowCursor( FALSE );
           SetCursor( hCursor );

           return 0;

    case WM_DESTROY:
           return 0;
   }


  return DefWindowProc( hwnd, msg, wParam, lParam );
 }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\stringw.c ===
#include <windows.h>
#include <commdlg.h>

#include <malloc.h>
#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include "fonttest.h"
#include "stringw.h"

#include "dialogs.h"


//*****************************************************************************
//************************   D R A W   S T R I N G   **************************
//*****************************************************************************

void DrawString( HWND hwnd, HDC hdc )
{
  HFONT		hFont, hFontOld;
  HBRUSH	hOldBrush = NULL;
  HBRUSH	hBrush = NULL;
  RECT		rcl;
  int		dx;

  if (!isCharCodingUnicode)
    hFont    = CreateFontIndirectWrapperA( &elfdvA );
  else
    hFont    = CreateFontIndirectWrapperW( &elfdvW );

  if( !hFont )
   {
    dprintf( "Couldn't create font" );
    return;
   }

  hFontOld = SelectObject( hdc, hFont );

  SetTextAlign( hdc, wTextAlign );
  SetBkMode( hdc, iBkMode );
  SetBkColor( hdc, dwRGBBackground );
  SetTextColor( hdc, dwRGBText );
  hBrush = CreateSolidBrush( dwRGBText );
  hOldBrush = SelectObject( hdc, hBrush );

  rcl.top    = yDC + cyDC/2 - cyDC/4;
  rcl.left   = xDC + cxDC/2 - cxDC/4;
  rcl.bottom = yDC + cyDC/2 + cyDC/4;
  rcl.right  = xDC + cxDC/2 + cxDC/4;

  if (wUseGlyphIndex)
  {
      MyExtTextOut( hdc, xDC+cxDC/2, yDC+cyDC/2, wETO, &rcl, wszStringGlyphIndex, SizewszStringGlyph, lpintdx );
  }
  else
  {
      if (!isCharCodingUnicode)
	    MyExtTextOut( hdc, xDC+cxDC/2, yDC+cyDC/2, wETO, &rcl, szStringA, lstrlenA(szStringA), GetSpacing( hdc, szStringA ) );
      else
        MyExtTextOut( hdc, xDC+cxDC/2, yDC+cyDC/2, wETO, &rcl, szStringW, lstrlenW(szStringW), GetSpacing( hdc, szStringW ) );
  }

  dx = cxDC / 150;
  if (dx < 0) dx = -dx;

  MoveToEx(hdc, xDC+cxDC/2-dx, yDC+cyDC/2    ,0);
  LineTo  (hdc, xDC+cxDC/2+dx, yDC+cyDC/2    );
  MoveToEx(hdc, xDC+cxDC/2,    yDC+cyDC/2-dx ,0);
  LineTo  (hdc, xDC+cxDC/2,    yDC+cyDC/2+3*dx );


  SelectObject( hdc, hOldBrush );
  DeleteObject( hBrush );
  SelectObject( hdc, hFontOld );
  DeleteObject( hFont );
}


//*****************************************************************************
//********************   S T R I N G   W N D   P R O C   **********************
//*****************************************************************************

LRESULT CALLBACK StringWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
 {
  HDC         hdc;
  PAINTSTRUCT ps;
  HCURSOR     hCursor;


  switch( msg )
   {
    case WM_CHAR:
           HandleChar( hwnd, wParam );
           return 0;


    case WM_PAINT:
           hCursor = SetCursor( LoadCursor( NULL, MAKEINTRESOURCE(IDC_WAIT) ) );
           ShowCursor( TRUE );

           //ClearDebug();
           //dprintf( "Drawing string" );

           hdc = BeginPaint( hwnd, &ps );
           SetDCMapMode( hdc, wMappingMode );

           SetBkMode( hdc, OPAQUE );
           SetBkColor( hdc, dwRGBBackground );
           SetTextColor( hdc, dwRGBText );
           SetTextCharacterExtra( hdc, nCharExtra );
           SetTextJustification( hdc, nBreakExtra, nBreakCount );

           DrawDCAxis( hwnd, hdc , TRUE);

           DrawString( hwnd, hdc );

           CleanUpDC( hdc );

           SelectObject( hdc, GetStockObject( BLACK_PEN ) );
           EndPaint( hwnd, &ps );

           //dprintf( "  Finished drawing string" );

           ShowCursor( FALSE );
           SetCursor( hCursor );

           return 0;

    case WM_DESTROY:
           return 0;
   }


  return DefWindowProc( hwnd, msg, wParam, lParam );
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\widths.h ===
void    DrawWidths( HWND hwnd, HDC hdc );
LRESULT CALLBACK WidthsWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\cdids.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    cdids.h

Abstract:

    This module contains the resource ID definitions for the Win32
    common dialogs.

Revision History:

--*/



//
//  Include Files.
//

#include <shlobj.h>




//
//  Constant Declarations.
//

#define IDA_OPENFILE         100
#define IDA_OPENFILEVIEW     101
#define IDA_PRINTFOLDER      102

#define IDC_PARENT           (FCIDM_BROWSERFIRST + 1)
#define IDC_NEWFOLDER        (FCIDM_BROWSERFIRST + 2)
#define IDC_VIEWLIST         (FCIDM_BROWSERFIRST + 3)
#define IDC_VIEWDETAILS      (FCIDM_BROWSERFIRST + 4)
#define IDC_DROPDRIVLIST     (FCIDM_BROWSERFIRST + 5)
#define IDC_REFRESH          (FCIDM_BROWSERFIRST + 6)
#define IDC_PREVIOUSFOLDER   (FCIDM_BROWSERFIRST + 7)
#define IDC_JUMPDESKTOP      (FCIDM_BROWSERFIRST + 9)
#define IDC_VIEWMENU         (FCIDM_BROWSERFIRST + 10)
#define IDC_RECENTFILES      (FCIDM_BROWSERFIRST + 11)
#define IDC_MYDOCUMENTS      (FCIDM_BROWSERFIRST + 12)
#define IDC_DESKTOP          (FCIDM_BROWSERFIRST + 13)
#define IDC_FAVORITES        (FCIDM_BROWSERFIRST + 14)
#define IDC_MYNETPLACES      (FCIDM_BROWSERFIRST + 15) 
#define IDC_BACK             (FCIDM_BROWSERFIRST + 16)
#define IDC_MYCOMPUTER       (FCIDM_BROWSERFIRST + 17)

#define DUMMYFILEOPENORD     400

#define FCIDM_FIRST          FCIDM_GLOBALFIRST
#define FCIDM_LAST           FCIDM_GLOBALLAST

#define MH_POPUPS            600

#define MH_ITEMS             (700 - FCIDM_FIRST)
#define MH_TOOLTIPBASE       (MH_ITEMS - (FCIDM_LAST - FCIDM_FIRST))


#define IDB_JUMPDESKTOP      800
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\color2.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    color2.c

Abstract:

    This module implements the support for the Win32 color dialog.

Revision History:

--*/



//
//  Include Files.
//

#include "comdlg32.h"
#include "color.h"

// from pwin32.h
#define MMoveTo(hdc, x, y)        MoveToEx(hdc, x, y, NULL)





////////////////////////////////////////////////////////////////////////////
//
//  ChangeColorSettings
//
//  Updates color shown.
//
////////////////////////////////////////////////////////////////////////////

VOID ChangeColorSettings(
    register PCOLORINFO pCI)
{
    register HDC hDC;
    HWND hDlg = pCI->hDialog;
    DWORD dwRGBcolor = pCI->currentRGB;

    RGBtoHLS(dwRGBcolor);
    if (gLum != pCI->currentLum)
    {
        hDC = GetDC(hDlg);
        EraseLumArrow(hDC, pCI);
        pCI->currentLum = gLum;
        HLStoHLSPos(COLOR_LUM, pCI);
        LumArrowPaint(hDC, pCI->nLumPos, pCI);
        ReleaseDC(hDlg, hDC);
    }
    if ((gHue != pCI->currentHue) || (gSat != pCI->currentSat))
    {
        pCI->currentHue = gHue;
        pCI->currentSat = gSat;
        InvalidateRect(hDlg, (LPRECT)&pCI->rLumPaint, FALSE);
        hDC = GetDC(hDlg);
        EraseCrossHair(hDC, pCI);
        HLStoHLSPos(COLOR_HUE, pCI);
        HLStoHLSPos(COLOR_SAT, pCI);
        CrossHairPaint(hDC, pCI->nHuePos, pCI->nSatPos, pCI);
        ReleaseDC(hDlg, hDC);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  LumArrowPaint
//
////////////////////////////////////////////////////////////////////////////

VOID LumArrowPaint(
    HDC hDC,
    SHORT y,
    PCOLORINFO pCI)
{
    HBRUSH hBrush;
    int x, h;

    hBrush = SelectObject(hDC, GetSysColorBrush(COLOR_BTNTEXT));

    for (x = pCI->rLumScroll.left + 2, h = 1;
         x < pCI->rLumScroll.right - 2;
         x++, h += 2)
    {
        PatBlt(hDC, x, y - h / 2, 1, h, PATCOPY);
    }

    SelectObject(hDC, hBrush);
}


////////////////////////////////////////////////////////////////////////////
//
//  EraseLumArrow
//
////////////////////////////////////////////////////////////////////////////

VOID EraseLumArrow(
    HDC hDC,
    PCOLORINFO pCI)
{
    HBRUSH hBrush;
    RECT Rect;

    hBrush = (HBRUSH)SendMessage( pCI->hDialog,
                                  WM_CTLCOLORDLG,
                                  (WPARAM)hDC,
                                  (LPARAM)pCI->hDialog );

    Rect.left   = pCI->rLumScroll.left + 1;
    Rect.right  = pCI->rLumScroll.right;
    Rect.top    = pCI->nLumPos - (pCI->rLumScroll.right - pCI->rLumScroll.left);
    Rect.bottom = pCI->nLumPos + (pCI->rLumScroll.right - pCI->rLumScroll.left) + 1;

    FillRect(hDC, &Rect, hBrush);
}


////////////////////////////////////////////////////////////////////////////
//
//  EraseCrossHair
//
////////////////////////////////////////////////////////////////////////////

VOID EraseCrossHair(
    HDC hDC,
    PCOLORINFO pCI)
{
    HBITMAP hOldBitmap;
    WORD distancex, distancey;
    WORD topy, bottomy, leftx, rightx;
    RECT rRainbow;

    CopyRect(&rRainbow, &pCI->rRainbow);

    distancex = (WORD)(10 * cxBorder);
    distancey = (WORD)(10 * cyBorder);
    topy    = ((WORD)rRainbow.top > pCI->nSatPos - distancey)
                  ? (WORD)rRainbow.top
                  : pCI->nSatPos - distancey;
    bottomy = ((WORD)rRainbow.bottom < pCI->nSatPos + distancey)
                  ? (WORD)rRainbow.bottom
                  : pCI->nSatPos + distancey;
    leftx   = ((WORD)rRainbow.left > pCI->nHuePos - distancex)
                  ? (WORD)rRainbow.left
                  : pCI->nHuePos - distancex;
    rightx  = ((WORD)rRainbow.right < pCI->nHuePos + distancex)
                  ? (WORD)rRainbow.right
                  : pCI->nHuePos + distancex;

    hOldBitmap = SelectObject(hDCFastBlt, hRainbowBitmap);
    BitBlt( hDC,
            leftx,
            topy,
            rightx - leftx,
            bottomy - topy,
            hDCFastBlt,
            leftx - (WORD)rRainbow.left,
            topy - (WORD)rRainbow.top,
            SRCCOPY );
    SelectObject(hDCFastBlt, hOldBitmap);
}


////////////////////////////////////////////////////////////////////////////
//
//  CrossHairPaint
//
////////////////////////////////////////////////////////////////////////////

VOID CrossHairPaint(
    register HDC hDC,
    SHORT x,
    SHORT y,
    PCOLORINFO pCI)
{
    SHORT distancex, distancey;
    SHORT topy, bottomy, topy2, bottomy2;
    SHORT leftx, rightx, leftx2, rightx2;
    RECT rRainbow;

    CopyRect(&rRainbow, &pCI->rRainbow);
    distancex = (SHORT)(5 * cxBorder);
    distancey = (SHORT)(5 * cyBorder);
    topy     = (SHORT)((rRainbow.top > y - 2 * distancey)
                         ? rRainbow.top
                         : y - 2 * distancey);
    bottomy  = (SHORT)((rRainbow.bottom < y + 2 * distancey)
                         ? rRainbow.bottom
                         : y + 2 * distancey);
    leftx    = (SHORT)((rRainbow.left > x - 2 * distancex)
                         ? rRainbow.left
                         : x - 2 * distancex);
    rightx   = (SHORT)((rRainbow.right < x + 2 * distancex)
                         ? rRainbow.right
                         : x + 2 * distancex);
    topy2    = (SHORT)((rRainbow.top > y - distancey)
                         ? rRainbow.top
                         : y - distancey);
    bottomy2 = (SHORT)((rRainbow.bottom < y + distancey)
                         ? rRainbow.bottom
                         : y + distancey);
    leftx2 = (SHORT)((rRainbow.left > x - distancex)
                         ? rRainbow.left
                         : x - distancex);
    rightx2 = (SHORT)((rRainbow.right < x + distancex)
                         ? rRainbow.right
                         : x + distancex);
    if (rRainbow.top < topy2)
    {
        if ((x - 1) >= rRainbow.left)
        {
            MMoveTo(hDC, x - 1, topy2);
            LineTo(hDC, x - 1, topy);
        }
        if ((int)x < rRainbow.right)
        {
            MMoveTo(hDC, x, topy2);
            LineTo(hDC, x, topy);
        }
        if ((x + 1) < rRainbow.right)
        {
            MMoveTo(hDC, x + 1, topy2);
            LineTo(hDC, x + 1, topy);
        }
    }
    if (rRainbow.bottom > bottomy2)
    {
        if ((x - 1) >= rRainbow.left)
        {
            MMoveTo(hDC, x - 1, bottomy2);
            LineTo(hDC, x - 1, bottomy);
        }
        if ((int)x < rRainbow.right)
        {
            MMoveTo(hDC, x, bottomy2);
            LineTo(hDC, x, bottomy);
        }
        if ((x + 1) < rRainbow.right)
        {
            MMoveTo(hDC, x + 1, bottomy2);
            LineTo(hDC, x + 1, bottomy);
        }
    }
    if (rRainbow.left < leftx2)
    {
        if ((y - 1) >= rRainbow.top)
        {
            MMoveTo(hDC, leftx2, y - 1);
            LineTo(hDC, leftx, y - 1);
        }
        if ((int)y < rRainbow.bottom)
        {
            MMoveTo(hDC, leftx2, y);
            LineTo(hDC, leftx, y);
        }
        if ((y + 1) < rRainbow.bottom)
        {
            MMoveTo(hDC, leftx2, y + 1);
            LineTo(hDC, leftx, y + 1);
        }
    }
    if (rRainbow.right > rightx2)
    {
        if ((y - 1) >= rRainbow.top)
        {
            MMoveTo(hDC, rightx2, y - 1);
            LineTo(hDC, rightx, y - 1);
        }
        if ((int)y < rRainbow.bottom)
        {
            MMoveTo(hDC, rightx2, y);
            LineTo(hDC, rightx, y);
        }
        if ((y + 1) < rRainbow.bottom)
        {
            MMoveTo(hDC, rightx2, y + 1);
            LineTo(hDC, rightx, y + 1);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  NearestSolid
//
////////////////////////////////////////////////////////////////////////////

VOID NearestSolid(
    register PCOLORINFO pCI)
{
    register HDC hDC;
    HWND hDlg = pCI->hDialog;

    hDC = GetDC(hDlg);
    EraseCrossHair(hDC, pCI);
    EraseLumArrow(hDC, pCI);
    RGBtoHLS(pCI->currentRGB = GetNearestColor(hDC, pCI->currentRGB));
    pCI->currentHue = gHue;
    pCI->currentLum = gLum;
    pCI->currentSat = gSat;
    HLStoHLSPos(0, pCI);
    CrossHairPaint(hDC, pCI->nHuePos, pCI->nSatPos, pCI);
    LumArrowPaint(hDC, pCI->nLumPos, pCI);
    ReleaseDC(hDlg, hDC);
    SetHLSEdit(0, pCI);
    SetRGBEdit(0, pCI);
    InvalidateRect(hDlg, (LPRECT)&pCI->rColorSamples, FALSE);
    InvalidateRect(hDlg, (LPRECT)&pCI->rLumPaint, FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  HLSPostoHLS
//
////////////////////////////////////////////////////////////////////////////

VOID HLSPostoHLS(
    SHORT nHLSEdit,
    register PCOLORINFO pCI)
{
    switch (nHLSEdit)
    {
        case COLOR_HUE:
        {
            pCI->currentHue = (WORD)((pCI->nHuePos - pCI->rRainbow.left) *
                                     (RANGE - 1) / (pCI->nHueWidth - 1));
            break;
        }
        case COLOR_SAT:
        {
            pCI->currentSat = (WORD)(RANGE -
                                     (pCI->nSatPos - pCI->rRainbow.top) *
                                     RANGE / (pCI->nSatHeight - 1));
            break;
        }
        case COLOR_LUM:
        {
            pCI->currentLum = (WORD)(RANGE -
                                     (pCI->nLumPos - pCI->rLumPaint.top) *
                                     RANGE / (pCI->nLumHeight - 1));
            break;
        }
        default:
        {
            pCI->currentHue = (WORD)((pCI->nHuePos - pCI->rRainbow.left) *
                                     (RANGE - 1) / pCI->nHueWidth);
            pCI->currentSat = (WORD)(RANGE -
                                     (pCI->nSatPos - pCI->rRainbow.top) *
                                     RANGE / pCI->nSatHeight);
            pCI->currentLum = (WORD)(RANGE -
                                     (pCI->nLumPos - pCI->rLumPaint.top) *
                                     RANGE / pCI->nLumHeight);
            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  HLStoHLSPos
//
////////////////////////////////////////////////////////////////////////////

VOID HLStoHLSPos(
    SHORT nHLSEdit,
    register PCOLORINFO pCI)
{
    switch (nHLSEdit)
    {
        case ( COLOR_HUE ) :
        {
            pCI->nHuePos = (WORD)(pCI->rRainbow.left + pCI->currentHue *
                                  pCI->nHueWidth / (RANGE - 1));
            break;
        }
        case COLOR_SAT:
        {
            pCI->nSatPos = (WORD)(pCI->rRainbow.top +
                                  (RANGE - pCI->currentSat) *
                                  (pCI->nSatHeight - 1) / RANGE);
            break;
        }
        case COLOR_LUM:
        {
            pCI->nLumPos = (WORD)(pCI->rLumPaint.top +
                                  (RANGE - pCI->currentLum) *
                                  (pCI->nLumHeight - 1) / RANGE);
            break;
        }
        default:
        {
            pCI->nHuePos = (WORD)(pCI->rRainbow.left + pCI->currentHue *
                                  pCI->nHueWidth / (RANGE - 1));
            pCI->nSatPos = (WORD)(pCI->rRainbow.top +
                                  (RANGE - pCI->currentSat) *
                                  (pCI->nSatHeight - 1) / RANGE);
            pCI->nLumPos = (WORD)(pCI->rLumPaint.top +
                                  (RANGE - pCI->currentLum) *
                                  (pCI->nLumHeight - 1) / RANGE);
            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SetHLSEdit
//
////////////////////////////////////////////////////////////////////////////

VOID SetHLSEdit(
    SHORT nHLSEdit,
    register PCOLORINFO pCI)
{
    register HWND hRainbowDlg = pCI->hDialog;

    switch (nHLSEdit)
    {
        case ( COLOR_HUE ) :
        {
            SetDlgItemInt(hRainbowDlg, COLOR_HUE, pCI->currentHue, FALSE);
            break;
        }
        case ( COLOR_SAT ) :
        {
            SetDlgItemInt(hRainbowDlg, COLOR_SAT, pCI->currentSat, FALSE);
            break;
        }
        case ( COLOR_LUM ) :
        {
            SetDlgItemInt(hRainbowDlg, COLOR_LUM, pCI->currentLum, FALSE);
            break;
        }
        default :
        {
            SetDlgItemInt(hRainbowDlg, COLOR_HUE, pCI->currentHue, FALSE);
            SetDlgItemInt(hRainbowDlg, COLOR_SAT, pCI->currentSat, FALSE);
            SetDlgItemInt(hRainbowDlg, COLOR_LUM, pCI->currentLum, FALSE);
            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SetRGBEdit
//
////////////////////////////////////////////////////////////////////////////

VOID SetRGBEdit(
    SHORT nRGBEdit,
    PCOLORINFO pCI)
{
    register HWND hRainbowDlg = pCI->hDialog;
    DWORD rainbowRGB = pCI->currentRGB;

    switch (nRGBEdit)
    {
        case ( COLOR_RED ) :
        {
            SetDlgItemInt(hRainbowDlg, COLOR_RED, GetRValue(rainbowRGB), FALSE);
            break;
        }
        case ( COLOR_GREEN ) :
        {
            SetDlgItemInt(hRainbowDlg, COLOR_GREEN, GetGValue(rainbowRGB), FALSE);
            break;
        }
        case ( COLOR_BLUE ) :
        {
            SetDlgItemInt(hRainbowDlg, COLOR_BLUE, GetBValue(rainbowRGB), FALSE);
            break;
        }
        default :
        {
            SetDlgItemInt(hRainbowDlg, COLOR_RED, GetRValue(rainbowRGB), FALSE);
            SetDlgItemInt(hRainbowDlg, COLOR_GREEN, GetGValue(rainbowRGB), FALSE);
            SetDlgItemInt(hRainbowDlg, COLOR_BLUE, GetBValue(rainbowRGB), FALSE);
            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  InitRainbow
//
//  Returns TRUE iff we make it.
//
////////////////////////////////////////////////////////////////////////////

BOOL InitRainbow(
    register PCOLORINFO pCI)
{
    HDC hDC;
    WORD Sat, Hue;
    HBITMAP hOldBitmap;
    RECT Rect;
    HBRUSH hbrSwipe;
    WORD nHueWidth, nSatHeight;
    register HWND hRainbowDlg = pCI->hDialog;

    RGBtoHLS(pCI->currentRGB);

    SetupRainbowCapture(pCI);

    nHueWidth = pCI->nHueWidth = (WORD)(pCI->rRainbow.right -
                                        pCI->rRainbow.left);
    nSatHeight = pCI->nSatHeight = (WORD)(pCI->rRainbow.bottom -
                                          pCI->rRainbow.top);

    pCI->currentHue = gHue;
    pCI->currentSat = gSat;
    pCI->currentLum = gLum;

    HLStoHLSPos(0, pCI);
    SetRGBEdit(0, pCI);
    SetHLSEdit(0, pCI);

    if (!hRainbowBitmap)
    {
        hDC = GetDC(hRainbowDlg);
        hRainbowBitmap = CreateCompatibleBitmap(hDC, nHueWidth, nSatHeight);
        if (!hRainbowBitmap)
        {
            return (FALSE);
        }
    }

    hOldBitmap = SelectObject(hDCFastBlt, hRainbowBitmap);

    //
    //  NOTE: The final pass through this loop paints on and past the end
    //        of the selected bitmap.  Windows is a good product, and doesn't
    //        let such foolishness happen.
    //
    Rect.bottom = 0;
    for (Sat = RANGE; Sat > 0; Sat -= SATINC)
    {
        Rect.top = Rect.bottom;
        Rect.bottom = (nSatHeight * RANGE - (Sat - SATINC) * nSatHeight) / RANGE;
        Rect.right = 0;

        for (Hue = 0; Hue < (RANGE - 1); Hue += HUEINC)
        {
            Rect.left = Rect.right;
            Rect.right = ((Hue + HUEINC) * nHueWidth) / RANGE;
            hbrSwipe = CreateSolidBrush(HLStoRGB(Hue, RANGE / 2, Sat));
            FillRect(hDCFastBlt, &Rect, hbrSwipe);
            DeleteObject(hbrSwipe);
        }
    }

    SelectObject(hDCFastBlt, hOldBitmap);
    ReleaseDC(hRainbowDlg, hDC);

    UpdateWindow(hRainbowDlg);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PaintRainbow
//
////////////////////////////////////////////////////////////////////////////

VOID PaintRainbow(
    HDC hDC,
    LPRECT lpRect,
    register PCOLORINFO pCI)
{
    HBITMAP hOldBitmap;

    if (!hRainbowBitmap)
    {
        return;
    }
    hOldBitmap = SelectObject(hDCFastBlt, hRainbowBitmap);
    BitBlt( hDC,
            lpRect->left,
            lpRect->top,
            lpRect->right - lpRect->left,
            lpRect->bottom - lpRect->top,
            hDCFastBlt,
            lpRect->left - pCI->rRainbow.left,
            lpRect->top - pCI->rRainbow.top,
            SRCCOPY );
    SelectObject(hDCFastBlt, hOldBitmap);
    CrossHairPaint(hDC, pCI->nHuePos, pCI->nSatPos, pCI);
    UpdateWindow(pCI->hDialog);
}


////////////////////////////////////////////////////////////////////////////
//
//  RainbowPaint
//
////////////////////////////////////////////////////////////////////////////

void RainbowPaint(
    register PCOLORINFO pCI,
    HDC hDC,
    LPRECT lpPaintRect)
{
    WORD Lum;
    RECT Rect;
    HBRUSH hbrSwipe;

    //
    //  Paint the Current Color Sample.
    //
    if (IntersectRect((LPRECT)&Rect, lpPaintRect, (LPRECT)&(pCI->rCurrentColor)))
    {
        hbrSwipe = CreateSolidBrush(pCI->currentRGB);
        FillRect(hDC, (LPRECT)&Rect, hbrSwipe);
        DeleteObject(hbrSwipe);
    }

    //
    //  Paint the Nearest Pure Color Sample.
    //
    if (IntersectRect((LPRECT)&Rect, lpPaintRect, (LPRECT)&(pCI->rNearestPure)))
    {
        hbrSwipe = CreateSolidBrush(GetNearestColor(hDC, pCI->currentRGB));
        FillRect(hDC, (LPRECT)&Rect, hbrSwipe);
        DeleteObject(hbrSwipe);
    }

    //
    //  Paint the Luminosity Range.
    //
    if (IntersectRect((LPRECT)&Rect, lpPaintRect, (LPRECT)&(pCI->rLumPaint)))
    {
        Rect.left = pCI->rLumPaint.left;
        Rect.right = pCI->rLumPaint.right;
        Rect.top = pCI->rLumPaint.bottom - LUMINC / 2;
        Rect.bottom = pCI->rLumPaint.bottom;
        hbrSwipe = CreateSolidBrush(HLStoRGB( pCI->currentHue,
                                              0,
                                              pCI->currentSat ));
        FillRect(hDC, (LPRECT)&Rect, hbrSwipe);
        DeleteObject(hbrSwipe);
        for (Lum = LUMINC; Lum < RANGE; Lum += LUMINC)
        {
            Rect.bottom = Rect.top;
            Rect.top = (((pCI->rLumPaint.bottom + LUMINC / 2) * (DWORD)RANGE -
                         (Lum + LUMINC) * pCI->nLumHeight) / RANGE);
            hbrSwipe = CreateSolidBrush(HLStoRGB( pCI->currentHue,
                                                  Lum,
                                                  pCI->currentSat ));
            FillRect(hDC, (LPRECT)&Rect, hbrSwipe);
            DeleteObject(hbrSwipe);
        }
        Rect.bottom = Rect.top;
        Rect.top = pCI->rLumPaint.top;
        hbrSwipe = CreateSolidBrush(HLStoRGB( pCI->currentHue,
                                              RANGE,
                                              pCI->currentSat ));
        FillRect(hDC, (LPRECT)&Rect, hbrSwipe);
        DeleteObject(hbrSwipe);

        //
        //  Paint the bounding rectangle only when it might be necessary.
        //
        if (!EqualRect(lpPaintRect, (LPRECT)&pCI->rLumPaint))
        {
            hbrSwipe = SelectObject(hDC, GetStockObject(NULL_BRUSH));
            Rectangle( hDC,
                       pCI->rLumPaint.left - 1,
                       pCI->rLumPaint.top - 1,
                       pCI->rLumPaint.right + 1,
                       pCI->rLumPaint.bottom + 1 );
            SelectObject(hDC, hbrSwipe);
        }
    }

    //
    //  Paint the Luminosity Arrow.
    //
    if (IntersectRect((LPRECT)&Rect, lpPaintRect, (LPRECT)&pCI->rLumScroll))
    {
        LumArrowPaint(hDC, pCI->nLumPos, pCI);
    }

    if (IntersectRect((LPRECT)&Rect, lpPaintRect, (LPRECT)&pCI->rRainbow))
    {
        PaintRainbow(hDC, (LPRECT)&Rect, pCI);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Color conversion routines --
//
//  RGBtoHLS() takes a DWORD RGB value, translates it to HLS, and stores the
//  results in the global vars H, L, and S.  HLStoRGB takes the current values
//  of H, L, and S and returns the equivalent value in an RGB DWORD.  The vars
//  H, L and S are written to only by 1) RGBtoHLS (initialization) or 2) the
//  scrollbar handlers.
//
//  A point of reference for the algorithms is Foley and Van Dam, pp. 618-19.
//  Their algorithm is in floating point.
//
//  There are potential roundoff errors lurking throughout here.
//     (0.5 + x/y) without floating point,
//     (x / y) phrased ((x + (y / 2)) / y) yields very small roundoff error.
//  This makes many of the following divisions look funny.
//
//
//  H,L, and S vary over 0 - HLSMAX.
//  R,G, and B vary over 0 - RGBMAX.
//  HLSMAX BEST IF DIVISIBLE BY 6.
//  RGBMAX, HLSMAX must each fit in a byte.
//
//  Hue is undefined if Saturation is 0 (grey-scale).
//  This value determines where the Hue scrollbar is initially set for
//  achromatic colors.
//
////////////////////////////////////////////////////////////////////////////

#define UNDEFINED (HLSMAX * 2 / 3)


////////////////////////////////////////////////////////////////////////////
//
//  RGBtoHLS
//
////////////////////////////////////////////////////////////////////////////

VOID RGBtoHLS(
    DWORD lRGBColor)
{
    WORD R, G, B;                 // input RGB values
    WORD cMax,cMin;               // max and min RGB values
    WORD cSum,cDif;
    SHORT Rdelta, Gdelta, Bdelta; // intermediate value: % of spread from max

    //
    //  get R, G, and B out of DWORD.
    //
    R = GetRValue(lRGBColor);
    G = GetGValue(lRGBColor);
    B = GetBValue(lRGBColor);

    //
    //  Calculate lightness.
    //
    cMax = max(max(R, G), B);
    cMin = min(min(R, G), B);
    cSum = cMax + cMin;
    gLum = (WORD)(((cSum * (DWORD)HLSMAX) + RGBMAX) / (2 * RGBMAX));

    cDif = cMax - cMin;
    if (!cDif)
    {
        //
        //  r = g = b --> Achromatic case.
        //
        gSat = 0;                         // saturation
        gHue = UNDEFINED;                 // hue
    }
    else
    {
        //
        //  Chromatic case.
        //

        //
        //  Saturation.
        //
        //  Note: Division by cSum is not a problem, as cSum can only
        //        be 0 if the RGB value is 0L, and that is achromatic.
        //
        if (gLum <= (HLSMAX / 2))
        {
            gSat = (WORD)(((cDif * (DWORD) HLSMAX) + (cSum / 2) ) / cSum);
        }
        else
        {
            gSat = (WORD)((DWORD)((cDif * (DWORD)HLSMAX) +
                               (DWORD)((2 * RGBMAX - cSum) / 2)) /
                       (2 * RGBMAX - cSum));
        }

        //
        //  Hue.
        //
        Rdelta = (SHORT)((((cMax - R) * (DWORD)(HLSMAX / 6)) + (cDif / 2) ) / cDif);
        Gdelta = (SHORT)((((cMax - G) * (DWORD)(HLSMAX / 6)) + (cDif / 2) ) / cDif);
        Bdelta = (SHORT)((((cMax - B) * (DWORD)(HLSMAX / 6)) + (cDif / 2) ) / cDif);

        if (R == cMax)
        {
            gHue = Bdelta - Gdelta;
        }
        else if (G == cMax)
        {
            gHue = (WORD)((HLSMAX / 3) + Rdelta - Bdelta);
        }
        else  // (B == cMax)
        {
            gHue = (WORD)(((2 * HLSMAX) / 3) + Gdelta - Rdelta);
        }

        if ((short)gHue < 0)
        {
            //
            //  This can occur when R == cMax and G is > B.
            //
            gHue += HLSMAX;
        }
        if (gHue >= HLSMAX)
        {
            gHue -= HLSMAX;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  HueToRGB
//
//  Utility routine for HLStoRGB.
//
////////////////////////////////////////////////////////////////////////////

WORD HueToRGB(
    WORD n1,
    WORD n2,
    WORD hue)
{
    if (hue >= HLSMAX)
    {
        hue -= HLSMAX;
    }

    //
    //  Return r, g, or b value from this tridrant.
    //
    if (hue < (HLSMAX / 6))
    {
        return ((WORD)(n1 + (((n2 - n1) * hue + (HLSMAX / 12)) / (HLSMAX / 6))));
    }
    if (hue < (HLSMAX/2))
    {
        return (n2);
    }
    if (hue < ((HLSMAX*2)/3))
    {
        return ((WORD)(n1 + (((n2 - n1) * (((HLSMAX * 2) / 3) - hue) +
                       (HLSMAX / 12)) / (HLSMAX / 6))));
    }
    else
    {
        return (n1);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  HLStoRGB
//
////////////////////////////////////////////////////////////////////////////

DWORD HLStoRGB(
    WORD hue,
    WORD lum,
    WORD sat)
{
    WORD R, G, B;                      // RGB component values
    WORD Magic1, Magic2;               // calculated magic numbers

    if (sat == 0)
    {
        //
        //  Achromatic case.
        //
        R = G = B = (WORD)((lum * RGBMAX) / HLSMAX);
    }
    else
    {
        //
        //  Chromatic case
        //

        //
        //  Set up magic numbers.
        //
        if (lum <= (HLSMAX / 2))
        {
            Magic2 = (WORD)((lum * ((DWORD)HLSMAX + sat) + (HLSMAX / 2)) / HLSMAX);
        }
        else
        {
            Magic2 = lum + sat -
                     (WORD)(((lum * sat) + (DWORD)(HLSMAX / 2)) / HLSMAX);
        }
        Magic1 = (WORD)(2 * lum - Magic2);

        //
        //  Get RGB, change units from HLSMAX to RGBMAX.
        //
        R = (WORD)(((HueToRGB(Magic1, Magic2, (WORD)(hue + (HLSMAX / 3))) *
                     (DWORD)RGBMAX + (HLSMAX / 2))) / HLSMAX);
        G = (WORD)(((HueToRGB(Magic1, Magic2, hue) *
                     (DWORD)RGBMAX + (HLSMAX / 2))) / HLSMAX);
        B = (WORD)(((HueToRGB(Magic1, Magic2, (WORD)(hue - (HLSMAX / 3))) *
                     (DWORD)RGBMAX + (HLSMAX / 2))) / HLSMAX);
    }
    return (RGB(R, G, B));
}


////////////////////////////////////////////////////////////////////////////
//
//  RGBEditChange
//
//  Checks the edit box for a valid entry and updates the Hue, Sat, and Lum
//  edit controls if appropriate.  Also updates Lum picture and current
//  color sample.
//
//  nDlgID - Dialog ID of Red, Green or Blue edit control.
//
////////////////////////////////////////////////////////////////////////////

SHORT RGBEditChange(
    SHORT nDlgID,
    PCOLORINFO pCI)
{
    BOOL bOK;               // check that value in edit control is uint
    BYTE *currentValue;     // pointer to byte in RGB to change (or reset)
    SHORT nVal;
    TCHAR cEdit[3];
    register HWND hDlg = pCI->hDialog;

    currentValue = (BYTE *)&pCI->currentRGB;
    switch (nDlgID)
    {
        case ( COLOR_GREEN ) :
        {
            currentValue++;
            break;
        }
        case ( COLOR_BLUE ) :
        {
            currentValue += 2;
            break;
        }
    }
    nVal = (SHORT)GetDlgItemInt(hDlg, nDlgID, (BOOL FAR *)&bOK, FALSE);
    if (bOK)
    {
        if (nVal > RGBMAX)
        {
            nVal = RGBMAX;
            SetDlgItemInt(hDlg, nDlgID, nVal, FALSE);
        }
        if (nVal != (SHORT) *currentValue)
        {
            *currentValue = LOBYTE(nVal);
            ChangeColorSettings(pCI);
            SetHLSEdit(nDlgID, pCI);
        }
    }
    else if (GetDlgItemText(hDlg, nDlgID, (LPTSTR)cEdit, 2))
    {
        SetRGBEdit(nDlgID, pCI);
        SendDlgItemMessage(hDlg, nDlgID, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
    }
    return (SHORT)(bOK ? TRUE : FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\color.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    color.c

Abstract:

    This module implements the Win32 color dialog.

Revision History:

--*/



//
//  Include Files.
//

#include "comdlg32.h"
#include "color.h"

// from pwin32.h
#define LONG2POINT(l, pt)    ((pt).x = (SHORT)LOWORD(l), (pt).y = (SHORT)HIWORD(l))




//
//  Global Variables.
//

DWORD rgbBoxColorDefault[COLORBOXES] =
{
 0x8080FF, 0x80FFFF, 0x80FF80, 0x80FF00, 0xFFFF80, 0xFF8000, 0xC080FF, 0xFF80FF,
 0x0000FF, 0x00FFFF, 0x00FF80, 0x40FF00, 0xFFFF00, 0xC08000, 0xC08080, 0xFF00FF,
 0x404080, 0x4080FF, 0x00FF00, 0x808000, 0x804000, 0xFF8080, 0x400080, 0x8000FF,
 0x000080, 0x0080FF, 0x008000, 0x408000, 0xFF0000, 0xA00000, 0x800080, 0xFF0080,
 0x000040, 0x004080, 0x004000, 0x404000, 0x800000, 0x400000, 0x400040, 0x800040,
 0x000000, 0x008080, 0x408080, 0x808080, 0x808040, 0xC0C0C0, 0x400040, 0xFFFFFF,
 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF,
 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF
};

RECT rColorBox[COLORBOXES];

UINT msgCOLOROKA;
UINT msgSETRGBA;

UINT msgCOLOROKW;
UINT msgSETRGBW;

LPCCHOOKPROC glpfnColorHook = 0;





#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  ChooseColorA
//
//  ANSI entry point for ChooseColor when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI ChooseColorA(
    LPCHOOSECOLORA pCCA)
{
    LPCHOOSECOLORW pCCW;
    BOOL bRet;
    DWORD cbLen;
    COLORINFO CI;

    ZeroMemory(&CI, sizeof(COLORINFO));

    if (!pCCA)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pCCA->lStructSize != sizeof(CHOOSECOLORA))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if (!(pCCW = (LPCHOOSECOLORW)LocalAlloc(LPTR, sizeof(CHOOSECOLORW))))
    {
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
        return (FALSE);
    }

    //
    //  Init simple invariants.
    //
    pCCW->lStructSize = sizeof(CHOOSECOLORW);
    pCCW->hwndOwner = pCCA->hwndOwner;
    pCCW->hInstance = pCCA->hInstance;
    pCCW->lpfnHook = pCCA->lpfnHook;

    //
    //  TemplateName array invariant.
    //
    if (pCCA->Flags & CC_ENABLETEMPLATE)
    {
        if (!IS_INTRESOURCE(pCCA->lpTemplateName))
        {
            cbLen = lstrlenA(pCCA->lpTemplateName) + 1;
            if (!(pCCW->lpTemplateName = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
            {
                StoreExtendedError(CDERR_MEMALLOCFAILURE);
                return (FALSE);
            }
            else
            {
                MultiByteToWideChar( CP_ACP,
                                     0,
                                     pCCA->lpTemplateName,
                                     -1,
                                     (LPWSTR)pCCW->lpTemplateName,
                                     cbLen );
            }
        }
        else
        {
            pCCW->lpTemplateName = (LPWSTR)pCCA->lpTemplateName;
        }
    }
    else
    {
        pCCW->lpTemplateName = NULL;
    }

    CI.pCC = pCCW;
    CI.pCCA = pCCA;
    CI.ApiType = COMDLG_ANSI;

    ThunkChooseColorA2W(&CI);
    if (bRet = ChooseColorX(&CI))
    {
        ThunkChooseColorW2A(&CI);
    }

    if (!IS_INTRESOURCE(pCCW->lpTemplateName))
    {
        LocalFree((HLOCAL)pCCW->lpTemplateName);
    }

    LocalFree(pCCW);

    return (bRet);
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  ChooseColorW
//
//  Stub UNICODE function for ChooseColor when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI ChooseColorW(
    LPCHOOSECOLORW pCCW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#endif



////////////////////////////////////////////////////////////////////////////
//
//  ChooseColor
//
//  The ChooseColor function creates a system-defined dialog box from
//  which the user can select a color.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI ChooseColor(
    LPCHOOSECOLOR pCC)
{
    COLORINFO CI;

    ZeroMemory(&CI, sizeof(COLORINFO));

    CI.pCC = pCC;
    CI.ApiType = COMDLG_WIDE;

    return ( ChooseColorX(&CI) );
}


////////////////////////////////////////////////////////////////////////////
//
//  ChooseColorX
//
//  Worker routine for the ChooseColor api.
//
////////////////////////////////////////////////////////////////////////////

BOOL ChooseColorX(
    PCOLORINFO pCI)
{
    LPCHOOSECOLOR pCC = pCI->pCC;
    INT_PTR iRet = FALSE;
    TCHAR szDialog[cbDlgNameMax];
    LPTSTR lpDlg;
    HANDLE hDlgTemplate;
    HRSRC hRes;
#ifdef UNICODE
    UINT uiWOWFlag = 0;
#endif

    //
    //  Initialize the error code.
    //
    StoreExtendedError(0);
    bUserPressedCancel = FALSE;

    if (!pCC)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pCC->lStructSize != sizeof(CHOOSECOLOR))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if (pCC->Flags & CC_ENABLEHOOK)
    {
        if (!pCC->lpfnHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pCC->lpfnHook = 0;
    }

    if (pCC->Flags & CC_ENABLETEMPLATE)
    {
        //
        //  Both custom instance handle and the dialog template name are
        //  user specified. Locate the dialog resource in the specified
        //  instance block and load it.
        //
        if (!(hRes = FindResource( (HMODULE)pCC->hInstance,
                                   pCC->lpTemplateName,
                                   RT_DIALOG )))
        {
            StoreExtendedError(CDERR_FINDRESFAILURE);
            return (FALSE);
        }
        if (!(hDlgTemplate = LoadResource((HMODULE)pCC->hInstance, hRes)))
        {
            StoreExtendedError(CDERR_LOADRESFAILURE);
            return (FALSE);
        }
    }
    else if (pCC->Flags & CC_ENABLETEMPLATEHANDLE)
    {
        //
        //  A handle to the pre-loaded resource has been specified.
        //
        hDlgTemplate = pCC->hInstance;
    }
    else
    {
        if (!LoadString( g_hinst,
                         dlgChooseColor,
                         szDialog,
                         cbDlgNameMax - 1 ))
        {
            StoreExtendedError(CDERR_LOADSTRFAILURE);
            return (FALSE);
        }
        lpDlg = szDialog;

        if (!(hRes = FindResource(g_hinst, lpDlg, RT_DIALOG)))
        {
            StoreExtendedError(CDERR_FINDRESFAILURE);
            return (FALSE);
        }
        if (!(hDlgTemplate = LoadResource(g_hinst, hRes)))
        {
            StoreExtendedError(CDERR_LOADRESFAILURE);
            return (FALSE);
        }
    }

    if (LockResource(hDlgTemplate))
    {
        if (pCI->pCC->Flags & CC_ENABLEHOOK)
        {
            glpfnColorHook = GETHOOKFN(pCI->pCC);
        }

#ifdef UNICODE
        if (IS16BITWOWAPP(pCC))
        {
            uiWOWFlag = SCDLG_16BIT;
        }

        iRet = DialogBoxIndirectParamAorW( g_hinst,
                                           (LPDLGTEMPLATE)hDlgTemplate,
                                           pCC->hwndOwner,
                                           ColorDlgProc,
                                           (LPARAM)pCI,
                                           uiWOWFlag );
#else
        iRet = DialogBoxIndirectParam( g_hinst,
                                       (LPDLGTEMPLATE)hDlgTemplate,
                                       pCC->hwndOwner,
                                       ColorDlgProc,
                                       (LPARAM)pCI );
#endif
        glpfnColorHook = 0;
        if (iRet == -1 || ((iRet == 0) && (!bUserPressedCancel) && (!GetStoredExtendedError())) )
        {
            StoreExtendedError(CDERR_DIALOGFAILURE);
        }
    }
    else
    {
        StoreExtendedError(CDERR_LOCKRESFAILURE);
    }

    return (iRet == IDOK);
}


////////////////////////////////////////////////////////////////////////////
//
//  ColorDlgProc
//
//  Color Dialog.
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK ColorDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PCOLORINFO pCI;
    BOOL bRet;
    BOOL bHookRet = FALSE;

    int temp;
    PAINTSTRUCT ps;
    HDC hDC;
    RECT rRect;
    RECT rcTemp;
    SHORT id;
    WORD nVal;
    BOOL bUpdateExample = FALSE;
    BOOL bOK;
    HWND hPointWnd;
    TCHAR cEdit[3];
    DWORD FAR *lpCust ;
    int i;
    POINT pt;
    LPCCHOOKPROC lpfnHook;

    //
    //  The call to PvGetInst will fail until set under WM_INITDIALOG.
    //
    if (pCI = (PCOLORINFO)GetProp(hDlg, COLORPROP))
    {
        lpfnHook = GETHOOKFN(pCI->pCC);

        if ((lpfnHook) &&
            (bRet = (* lpfnHook)(hDlg, wMsg, wParam, lParam)))
        {
            if ((wMsg == WM_COMMAND) &&
                (GET_WM_COMMAND_ID(wParam, lParam) == IDCANCEL))
            {
                //
                //  Set global flag stating that the user pressed cancel.
                //
                bUserPressedCancel = TRUE;
            }

            return (bRet);
        }
    }
    else if (wMsg != WM_INITDIALOG)
    {
        if (glpfnColorHook &&
            (bRet = (*glpfnColorHook)(hDlg, wMsg, wParam, lParam)))
        {
            return (bRet);
        }
        else
        {
            return (FALSE);
        }
    }

    switch (wMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            //
            //  Change cursor to hourglass.
            //
            HourGlass(TRUE);

            pCI = (PCOLORINFO)lParam;

            SetProp(hDlg, COLORPROP, (HANDLE)pCI);
            glpfnColorHook = 0;

            bRet = InitColor(hDlg, wParam, pCI);

            //
            //  Change cursor back to arrow.
            //
            HourGlass(FALSE);

            return (bRet);
            break;
        }
        case ( WM_MOVE ) :
        {
            if (pCI)
            {
                SetupRainbowCapture(pCI);
            }
            return(FALSE);
            break;
        }
        case ( WM_LBUTTONDBLCLK ) :
        {
            LONG2POINT(lParam, pt);
            if (PtInRect((LPRECT)&pCI->rNearestPure, pt))
            {
                NearestSolid(pCI);
            }
            break;
        }
        case ( WM_MOUSEMOVE ) :
        {
            //
            //  Dialog Boxes don't receive MOUSEMOVE unless mouse is captured.
            //  If mouse isn't captured, break.
            //
            if (!bMouseCapture)
            {
                break;
            }

            // Fall Thru...
        }
        case ( WM_LBUTTONDOWN ) :
        {
            LONG2POINT(lParam, pt);
            if (PtInRect((LPRECT)&pCI->rRainbow, pt))
            {
                if (wMsg == WM_LBUTTONDOWN)
                {
                    hDC = GetDC(hDlg);
                    EraseCrossHair(hDC, pCI);
                    ReleaseDC(hDlg, hDC);
                }

                pCI->nHuePos = LOWORD(lParam);
                HLSPostoHLS(COLOR_HUE, pCI);
                SetHLSEdit(COLOR_HUE, pCI);

                pCI->nSatPos = HIWORD(lParam);
                HLSPostoHLS(COLOR_SAT, pCI);
                SetHLSEdit(COLOR_SAT, pCI);
                pCI->currentRGB = HLStoRGB( pCI->currentHue,
                                            pCI->currentLum,
                                            pCI->currentSat );
                pCI->currentRGB = MapColor(pCI, pCI->currentRGB);

                hDC = GetDC(hDlg);
                RainbowPaint(pCI, hDC, (LPRECT)&pCI->rLumPaint);
                RainbowPaint(pCI, hDC, (LPRECT)&pCI->rColorSamples);
                ReleaseDC(hDlg, hDC);

                SetRGBEdit(0, pCI);

                if (!bMouseCapture)
                {
                    SetCapture(hDlg);
                    CopyRect(&rcTemp, &pCI->rRainbow);
                    ClientToScreen(hDlg, (LPPOINT)&rcTemp.left);
                    ClientToScreen(hDlg, (LPPOINT)&rcTemp.right);
                    ClipCursor(&rcTemp);
                    bMouseCapture = TRUE;
                }
            }
            else if ( PtInRect((LPRECT)&pCI->rLumPaint, pt) ||
                      PtInRect((LPRECT)&pCI->rLumScroll, pt) )
            {
                hDC = GetDC(hDlg);
                EraseLumArrow(hDC, pCI);
                LumArrowPaint(hDC, pCI->nLumPos = HIWORD(lParam), pCI);
                HLSPostoHLS(COLOR_LUM, pCI);
                SetHLSEdit(COLOR_LUM, pCI);
                pCI->currentRGB = HLStoRGB( pCI->currentHue,
                                            pCI->currentLum,
                                            pCI->currentSat );
                pCI->currentRGB = MapColor(pCI, pCI->currentRGB);

                RainbowPaint(pCI, hDC, (LPRECT)&pCI->rColorSamples);
                ReleaseDC(hDlg, hDC);
                ValidateRect(hDlg, (LPRECT)&pCI->rLumScroll);
                ValidateRect(hDlg, (LPRECT)&pCI->rColorSamples);

                SetRGBEdit(0, pCI);

                if (!bMouseCapture)
                {
                    SetCapture(hDlg);
                    CopyRect(&rcTemp, &pCI->rLumScroll);
                    ClientToScreen(hDlg, (LPPOINT)&rcTemp.left);
                    ClientToScreen(hDlg, (LPPOINT)&rcTemp.right);
                    ClipCursor(&rcTemp);
                    bMouseCapture = TRUE;
                }
            }
            else
            {
                hPointWnd = ChildWindowFromPoint(hDlg, pt);
                if (hPointWnd == GetDlgItem(hDlg, COLOR_BOX1))
                {
                    rRect.top    = rColorBox[0].top;
                    rRect.left   = rColorBox[0].left;
                    rRect.right  = rColorBox[NUM_BASIC_COLORS - 1].right +
                                   BOX_X_MARGIN;
                    rRect.bottom = rColorBox[NUM_BASIC_COLORS - 1].bottom +
                                   BOX_Y_MARGIN;
                    temp = (NUM_BASIC_COLORS) / NUM_X_BOXES;
                    id = 0;
                }
                else if (hPointWnd == GetDlgItem(hDlg, COLOR_CUSTOM1))
                {
                    rRect.top    = rColorBox[NUM_BASIC_COLORS].top;
                    rRect.left   = rColorBox[NUM_BASIC_COLORS].left;
                    rRect.right  = rColorBox[COLORBOXES - 1].right + BOX_X_MARGIN;
                    rRect.bottom = rColorBox[COLORBOXES - 1].bottom + BOX_Y_MARGIN;
                    temp = (NUM_CUSTOM_COLORS) / NUM_X_BOXES;
                    id = NUM_BASIC_COLORS;
                }
                else
                {
                    return (FALSE);
                }

                if (hPointWnd != GetFocus())
                {
                    SetFocus(hPointWnd);
                }

                if (HIWORD(lParam) >= (WORD)rRect.bottom)
                {
                    break;
                }
                if (LOWORD(lParam) >= (WORD)rRect.right)
                {
                    break;
                }
                if (HIWORD(lParam) < (WORD)rRect.top)
                {
                    break;
                }
                if (LOWORD(lParam) < (WORD)rRect.left)
                {
                    break;
                }

                //
                //  Make sure the click wasn't on a border between squares.
                //
                if ( ((LOWORD(lParam) - rRect.left) % nBoxWidth) >=
                     (nBoxWidth - BOX_X_MARGIN) )
                {
                    break;
                }
                if ( ((HIWORD(lParam) - rRect.top) % nBoxHeight) >=
                     (nBoxHeight - BOX_Y_MARGIN) )
                {
                    break;
                }

                //
                //  Now calculate which square was selected.
                //
                id += ((HIWORD(lParam) - rRect.top) * temp /
                       (rRect.bottom - rRect.top)) * NUM_X_BOXES;

                id += ((LOWORD(lParam) - rRect.left) * NUM_X_BOXES) /
                       (SHORT)(rRect.right - rRect.left);

                if ((id < nDriverColors) || (id >= NUM_BASIC_COLORS))
                {
                    ChangeBoxSelection(pCI, id);
                    pCI->nCurBox = id;
                    ChangeBoxFocus(pCI, id);
                    if (id >= NUM_BASIC_COLORS)
                    {
                        pCI->nCurMix = pCI->nCurBox;
                    }
                    else
                    {
                        pCI->nCurDsp = pCI->nCurBox;
                    }
                    pCI->currentRGB = pCI->rgbBoxColor[pCI->nCurBox];
                    pCI->currentRGB = MapColor(pCI, pCI->currentRGB);

                    hDC = GetDC(hDlg);
                    if (pCI->bFoldOut)
                    {
                        ChangeColorSettings(pCI);
                        SetHLSEdit(0, pCI);
                        SetRGBEdit(0, pCI);
                        RainbowPaint(pCI, hDC, (LPRECT)&pCI->rColorSamples);
                    }
                    PaintBox(pCI, hDC, pCI->nCurDsp);
                    PaintBox(pCI, hDC, pCI->nCurMix);
                    ReleaseDC(hDlg, hDC);
                }
            }
            break;
        }
        case ( WM_LBUTTONUP ) :
        {
            LONG2POINT(lParam, pt);
            if (bMouseCapture)
            {
                bMouseCapture = FALSE;
                SetCapture(NULL);
                ClipCursor((LPRECT)NULL);
                if (PtInRect((LPRECT)&pCI->rRainbow, pt))
                {
                    hDC = GetDC(hDlg);
                    CrossHairPaint( hDC,
                                    pCI->nHuePos = LOWORD(lParam),
                                    pCI->nSatPos = HIWORD(lParam),
                                    pCI );
                    RainbowPaint(pCI, hDC, (LPRECT)&pCI->rLumPaint);
                    ReleaseDC(hDlg, hDC);
                    ValidateRect(hDlg, (LPRECT)&pCI->rRainbow);
                }
                else if (PtInRect((LPRECT)&pCI->rLumPaint, pt))
                {
                    //
                    //  Update Sample Shown.
                    //
                    hDC = GetDC(hDlg);
                    LumArrowPaint(hDC, pCI->nLumPos, pCI);
                    ReleaseDC(hDlg, hDC);
                    ValidateRect(hDlg, (LPRECT)&pCI->rLumPaint);
                }
            }
            break;
        }
        case ( WM_CHAR ) :
        {
            if (wParam == VK_SPACE)
            {
                if (GetFocus() == GetDlgItem(hDlg, COLOR_BOX1))
                {
                    temp = pCI->nCurDsp;
                }
                else if (GetFocus() == GetDlgItem(hDlg, COLOR_CUSTOM1))
                {
                    temp = pCI->nCurMix;
                }
                else
                {
                    return (FALSE);
                }
                pCI->currentRGB = pCI->rgbBoxColor[temp];
                pCI->currentRGB = MapColor(pCI, pCI->currentRGB);

                if (pCI->bFoldOut)
                {
                    ChangeColorSettings(pCI);
                    SetHLSEdit(0, pCI);
                    SetRGBEdit(0, pCI);
                }
                InvalidateRect(hDlg, (LPRECT)&pCI->rColorSamples, FALSE);
                ChangeBoxSelection(pCI, (short)temp);
                pCI->nCurBox = (short)temp;
                bUpdateExample = TRUE;
            }
            break;
        }
        case ( WM_KEYDOWN ) :
        {
            if (ColorKeyDown(wParam, &temp, pCI))
            {
                ChangeBoxFocus(pCI, (SHORT)temp);
            }
            break;
        }
        case ( WM_GETDLGCODE ) :
        {
            return (DLGC_WANTALLKEYS | DLGC_WANTARROWS | DLGC_HASSETSEL);
            break;
        }
        case ( WM_COMMAND ) :
        {
            if (!pCI)
            {
                return (FALSE);
            }

            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case ( IDOK ) :
                {
                    pCI->pCC->rgbResult = pCI->currentRGB;
                    goto LeaveDialog;
                }
                case ( IDCANCEL ) :
                {
                    bUserPressedCancel = TRUE;
LeaveDialog:
                    if (bMouseCapture)
                    {
                        bMouseCapture = FALSE;
                        SetCapture(NULL);
                        ClipCursor((LPRECT)NULL);
                    }
                    lpCust = pCI->pCC->lpCustColors;
                    for ( i = NUM_BASIC_COLORS;
                          i < NUM_BASIC_COLORS + NUM_CUSTOM_COLORS;
                          i++ )
                    {
                        *lpCust++ = pCI->rgbBoxColor[i];
                    }

                    bRet = (GET_WM_COMMAND_ID(wParam, lParam) == IDOK);
                    lpfnHook = GETHOOKFN(pCI->pCC);

#ifdef UNICODE
                    if (pCI->ApiType == COMDLG_ANSI)
                    {
                        if (bRet && lpfnHook)
                        {
                            ThunkChooseColorW2A(pCI);
                            bHookRet = (*lpfnHook)( hDlg,
                                                    msgCOLOROKA,
                                                    0,
                                                    (LONG_PTR)(LPTSTR)pCI->pCCA );
                        }
                    }
                    else
#endif
                    {
                        if (bRet && lpfnHook)
                        {
                            bHookRet = (*lpfnHook)( hDlg,
                                                    msgCOLOROKW,
                                                    0,
                                                    (LONG_PTR)(LPTSTR)pCI->pCC );
                        }
                    }

                    if (bHookRet)
                    {
#ifdef UNICODE
                        if (pCI->ApiType == COMDLG_ANSI)
                        {
                            ThunkChooseColorA2W(pCI);
                            pCI->pCC->lCustData = pCI->pCCA->lCustData;
                        }
#endif
                        break;
                    }
                }
                case ( IDABORT ) :
                {
                    if (pCI->pCC->Flags & CC_ENABLEHOOK)
                    {
                        glpfnColorHook = GETHOOKFN(pCI->pCC);
                    }

                    RemoveProp(hDlg, COLORPROP);
                    EndDialog( hDlg,
                               (GET_WM_COMMAND_ID(wParam, lParam) == IDABORT)
                                   ? (BOOL)lParam
                                   : bRet );

                    if (hRainbowBitmap)
                    {
                        DeleteObject(hRainbowBitmap);
                        hRainbowBitmap = NULL;
                    }
                    if (hDCFastBlt)
                    {
                        DeleteDC(hDCFastBlt);
                        hDCFastBlt = 0;
                    }
                    break;
                }
                case ( pshHelp ) :
                {
#ifdef UNICODE
                    if (pCI->ApiType == COMDLG_ANSI)
                    {
                        if (msgHELPA && pCI->pCC->hwndOwner)
                        {
                            ThunkChooseColorW2A(pCI);
                            SendMessage( pCI->pCC->hwndOwner,
                                         msgHELPA,
                                         (WPARAM)hDlg,
                                         (LPARAM)pCI->pCCA );
                            ThunkChooseColorA2W(pCI);
                            pCI->pCC->lCustData = pCI->pCCA->lCustData;
                        }
                    }
                    else
#endif
                    {
                        if (msgHELPW && pCI->pCC->hwndOwner)
                        {
                            SendMessage( pCI->pCC->hwndOwner,
                                         msgHELPW,
                                         (WPARAM)hDlg,
                                         (LPARAM)pCI->pCC );
                        }
                    }
                    break;
                }
                case ( COLOR_SOLID ) :
                {
                    NearestSolid(pCI);
                    break;
                }
                case ( COLOR_RED ) :
                case ( COLOR_GREEN ) :
                case ( COLOR_BLUE ) :
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        RGBEditChange(GET_WM_COMMAND_ID(wParam, lParam), pCI);
                        InvalidateRect(hDlg, (LPRECT)&pCI->rColorSamples, FALSE);
                    }
                    else if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS)
                    {
                        GetDlgItemInt( hDlg,
                                       GET_WM_COMMAND_ID(wParam, lParam),
                                       &bOK,
                                       FALSE );
                        if (!bOK)
                        {
                            SetRGBEdit(GET_WM_COMMAND_ID(wParam, lParam), pCI);
                        }
                    }
                    break;
                }
                case ( COLOR_HUE ) :
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        nVal = (WORD)GetDlgItemInt(hDlg, COLOR_HUE, &bOK, FALSE);
                        if (bOK)
                        {
                            if (nVal > RANGE - 1)
                            {
                                nVal = RANGE - 1;
                                SetDlgItemInt(hDlg, COLOR_HUE, (int)nVal, FALSE);
                            }
                            if (nVal != pCI->currentHue)
                            {
                                hDC = GetDC(hDlg);
                                EraseCrossHair(hDC, pCI);
                                pCI->currentHue = nVal;
                                pCI->currentRGB = HLStoRGB( nVal,
                                                            pCI->currentLum,
                                                            pCI->currentSat );
                                pCI->currentRGB = MapColor(pCI, pCI->currentRGB);

                                SetRGBEdit(0, pCI);
                                HLStoHLSPos(COLOR_HUE, pCI);
                                CrossHairPaint( hDC,
                                                pCI->nHuePos,
                                                pCI->nSatPos,
                                                pCI );
                                ReleaseDC(hDlg, hDC);
                                InvalidateRect( hDlg,
                                                (LPRECT)&pCI->rLumPaint,
                                                FALSE );
                                InvalidateRect( hDlg,
                                                (LPRECT)&pCI->rColorSamples,
                                                FALSE );
                                UpdateWindow(hDlg);
                            }
                        }
                        else if (GetDlgItemText(
                                       hDlg,
                                       COLOR_HUE,
                                       (LPTSTR)cEdit,
                                       2 ))
                        {
                            SetHLSEdit(COLOR_HUE, pCI);
                            SendDlgItemMessage(
                                       hDlg,
                                       COLOR_HUE,
                                       EM_SETSEL,
                                       (WPARAM)0,
                                       (LPARAM)-1 );
                        }
                    }
                    else if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS)
                    {
                        GetDlgItemInt(hDlg, COLOR_HUE, &bOK, FALSE);
                        if (!bOK)
                        {
                            SetHLSEdit(COLOR_HUE, pCI);
                        }
                    }
                    break;
                }
                case ( COLOR_SAT ) :
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        nVal = (WORD)GetDlgItemInt(hDlg, COLOR_SAT, &bOK, FALSE);
                        if (bOK)
                        {
                            if (nVal > RANGE)
                            {
                                nVal = RANGE;
                                SetDlgItemInt(hDlg, COLOR_SAT, (int)nVal, FALSE);
                            }
                            if (nVal != pCI->currentSat)
                            {
                                hDC = GetDC(hDlg);
                                EraseCrossHair(hDC, pCI);
                                pCI->currentSat = nVal;
                                pCI->currentRGB = HLStoRGB( pCI->currentHue,
                                                            pCI->currentLum,
                                                            nVal );
                                pCI->currentRGB = MapColor(pCI, pCI->currentRGB);

                                SetRGBEdit(0, pCI);
                                HLStoHLSPos(COLOR_SAT, pCI);
                                CrossHairPaint( hDC,
                                                pCI->nHuePos,
                                                pCI->nSatPos,
                                                pCI );
                                ReleaseDC(hDlg, hDC);
                                InvalidateRect( hDlg,
                                                (LPRECT)&pCI->rLumPaint,
                                                FALSE );
                                InvalidateRect( hDlg,
                                                (LPRECT)&pCI->rColorSamples,
                                                FALSE );
                                UpdateWindow(hDlg);
                            }
                        }
                        else if (GetDlgItemText(
                                       hDlg,
                                       COLOR_SAT,
                                       (LPTSTR)cEdit,
                                       2 ))
                        {
                            SetHLSEdit(COLOR_SAT, pCI);
                            SendDlgItemMessage(
                                       hDlg,
                                       COLOR_SAT,
                                       EM_SETSEL,
                                       (WPARAM)0,
                                       (LPARAM)-1 );
                        }
                    }
                    else if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS)
                    {
                        GetDlgItemInt(hDlg, COLOR_SAT, &bOK, FALSE);
                        if (!bOK)
                        {
                            SetHLSEdit(COLOR_SAT, pCI);
                        }
                    }
                    break;
                }
                case ( COLOR_LUM ) :
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        nVal = (WORD)GetDlgItemInt(hDlg, COLOR_LUM, &bOK, FALSE);
                        if (bOK)
                        {
                            if (nVal > RANGE)
                            {
                                nVal = RANGE;
                                SetDlgItemInt(hDlg, COLOR_LUM, (int)nVal, FALSE);
                            }
                            if (nVal != pCI->currentLum)
                            {
                                hDC = GetDC(hDlg);
                                EraseLumArrow(hDC, pCI);
                                pCI->currentLum = nVal;
                                HLStoHLSPos(COLOR_LUM, pCI);
                                pCI->currentRGB = HLStoRGB( pCI->currentHue,
                                                            nVal,
                                                            pCI->currentSat );
                                pCI->currentRGB = MapColor(pCI, pCI->currentRGB);

                                SetRGBEdit(0, pCI);
                                LumArrowPaint(hDC, pCI->nLumPos, pCI);
                                ReleaseDC(hDlg, hDC);
                                InvalidateRect( hDlg,
                                                (LPRECT)&pCI->rColorSamples,
                                                FALSE );
                                UpdateWindow(hDlg);
                            }
                        }
                        else if (GetDlgItemText(
                                       hDlg,
                                       COLOR_LUM,
                                       (LPTSTR)cEdit,
                                       2 ))
                        {
                            SetHLSEdit(COLOR_LUM, pCI);
                            SendDlgItemMessage(
                                       hDlg,
                                       COLOR_LUM,
                                       EM_SETSEL,
                                       (WPARAM)0,
                                       (LPARAM)-1 );
                        }
                    }
                    else if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS)
                    {
                        GetDlgItemInt(hDlg, COLOR_LUM, &bOK, FALSE);
                        if (!bOK)
                        {
                            SetHLSEdit(COLOR_LUM, pCI);
                        }
                    }
                    break;
                }
                case ( COLOR_ADD ) :
                {
                    pCI->rgbBoxColor[pCI->nCurMix] = pCI->currentRGB;
                    InvalidateRect(hDlg, (LPRECT)rColorBox + pCI->nCurMix, FALSE);

                    if (pCI->nCurMix >= COLORBOXES - 1)
                    {
                        pCI->nCurMix = NUM_BASIC_COLORS;
                    }
#if HORIZONTELINC
                    else
                    {
                        pCI->nCurMix++;
                    }
#else
                    else if (pCI->nCurMix >= NUM_BASIC_COLORS + 8)
                    {
                        //
                        //  Increment nCurBox VERTICALLY!  extra code
                        //  for vertical instead of horizontal increment.
                        //
                        pCI->nCurMix -= 7;
                    }
                    else
                    {
                        pCI->nCurMix += 8;
                    }
#endif
                    break;
                }
                case ( COLOR_MIX ) :
                {
                    //
                    //  Change cursor to hourglass.
                    //
                    HourGlass(TRUE);

                    InitRainbow(pCI);

                    //
                    //  Code relies on COLOR_HUE through COLOR_BLUE being
                    //  consecutive.
                    //
                    for (temp = COLOR_HUE; temp <= COLOR_BLUE; temp++)
                    {
                        EnableWindow(GetDlgItem(hDlg, temp), TRUE);
                    }
                    for (temp = COLOR_HUEACCEL; temp <= COLOR_BLUEACCEL; temp++)
                    {
                        EnableWindow(GetDlgItem(hDlg, temp), TRUE);
                    }

                    EnableWindow(GetDlgItem(hDlg, COLOR_ADD), TRUE);
                    EnableWindow(GetDlgItem(hDlg, COLOR_SOLID), TRUE);
                    EnableWindow(GetDlgItem(hDlg, COLOR_SOLID_RIGHT), TRUE);
                    EnableWindow(GetDlgItem(hDlg, COLOR_MIX), FALSE);

                    GetWindowRect(hDlg, (LPRECT)&rcTemp);

                    SetWindowPos( hDlg,
                                  NULL,
                                  pCI->rOriginal.left,
                                  pCI->rOriginal.top,
                                  pCI->rOriginal.right - pCI->rOriginal.left,
                                  pCI->rOriginal.bottom - pCI->rOriginal.top,
                                  SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE );

                    //
                    //  Only invalidate exposed area.
                    //
                    rcTemp.right = rcTemp.left;
                    rcTemp.left = pCI->rOriginal.left;
                    InvalidateRect(hDlg, (LPRECT)&rcTemp, FALSE);

                    //
                    //  Change cursor back to arrow.
                    //
                    HourGlass(FALSE);

                    SetFocus(GetDlgItem(hDlg, COLOR_HUE));
                    pCI->bFoldOut = TRUE;

                    break;
                }
            }
            break;
        }
        case ( WM_QUERYNEWPALETTE ) :
        {
            if (pCI->hPal)
            {
                HDC hdc = GetDC(hDlg);

                SelectPalette(hdc, pCI->hPal, FALSE);
                i = RealizePalette(hdc);
                ReleaseDC(hDlg, hdc);

                if (i > 0)
                {
                    InvalidateRect(hDlg, NULL, FALSE);
                }
            }
            break;
        }
        case ( WM_PALETTECHANGED ) :
        {
            if (pCI->hPal && (HWND)wParam != hDlg)
            {
                InvalidateRect(hDlg, NULL, FALSE);
            }
            break;
        }
        case ( WM_PAINT ) :
        {
            BeginPaint(hDlg, (LPPAINTSTRUCT)&ps);
            ColorPaint(hDlg, pCI, ps.hdc, (LPRECT)&ps.rcPaint);
            EndPaint(hDlg, (LPPAINTSTRUCT)&ps);
            break;
        }
        case ( WM_HELP ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPTSTR)aColorHelpIDs );
            }
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)wParam,
                         NULL,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)aColorHelpIDs );
            }
            break;
        }
        default :
        {
            if (wMsg == msgSETRGBA || wMsg == msgSETRGBW)
            {
                if (ChangeColorBox(pCI, (DWORD)lParam))
                {
                    pCI->currentRGB = MapColor(pCI, (DWORD) lParam);

                    if (pCI->nCurBox < pCI->nCurMix)
                    {
                        pCI->nCurDsp = pCI->nCurBox;
                    }
                    else
                    {
                        pCI->nCurMix = pCI->nCurBox;
                    }
                }
                if (pCI->bFoldOut)
                {
                    pCI->currentRGB = MapColor(pCI, (DWORD) lParam);
                    ChangeColorSettings(pCI);
                    SetHLSEdit(0, pCI);
                    SetRGBEdit(0, pCI);
                    hDC = GetDC(hDlg);
                    RainbowPaint(pCI, hDC, (LPRECT)&pCI->rColorSamples);
                    ReleaseDC(hDlg, hDC);
                }
                break;
            }
            return (FALSE);
            break;
        }
    }
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ChangeColorBox
//
//  Update box shown.
//
////////////////////////////////////////////////////////////////////////////

BOOL ChangeColorBox(
    register PCOLORINFO pCI,
    DWORD dwRGBcolor)
{
    register short nBox;

    for (nBox = 0; nBox < COLORBOXES; nBox++)
    {
        if (pCI->rgbBoxColor[nBox] == dwRGBcolor)
        {
            break;
        }
    }
    if (nBox >= COLORBOXES)
    {
        //
        //  Color Not Found.  Now What Should We Do?
        //
    }
    else
    {
        ChangeBoxSelection(pCI, nBox);
        pCI->nCurBox = nBox;
    }

    return (nBox < COLORBOXES);
}


////////////////////////////////////////////////////////////////////////////
//
//  HiLiteBox
//
////////////////////////////////////////////////////////////////////////////

VOID HiLiteBox(
    HDC hDC,
    SHORT nBox,
    SHORT fStyle)
{
    RECT rRect;
    HBRUSH hBrush;

    CopyRect((LPRECT)&rRect, (LPRECT)rColorBox + nBox);
    rRect.left--, rRect.top--, rRect.right++, rRect.bottom++;
    hBrush = CreateSolidBrush((fStyle & 1) ? 0L : GetSysColor(COLOR_3DFACE));
    FrameRect(hDC, (LPRECT)&rRect, hBrush);
    DeleteObject(hBrush);
}


////////////////////////////////////////////////////////////////////////////
//
//  ChangeBoxSelection
//
////////////////////////////////////////////////////////////////////////////

VOID ChangeBoxSelection(
    PCOLORINFO pCI,
    SHORT nNewBox)
{
    register HDC hDC;
    register HWND hDlg = pCI->hDialog;

    hDC = GetDC(hDlg);
    HiLiteBox(hDC, pCI->nCurBox, 0);
    HiLiteBox(hDC, nNewBox, 1);
    ReleaseDC(hDlg, hDC);
    pCI->currentRGB = pCI->rgbBoxColor[nNewBox];
    pCI->currentRGB = MapColor(pCI, pCI->currentRGB);
}


////////////////////////////////////////////////////////////////////////////
//
//  ChangeBoxFocus
//
//  Can't trust the state of the XOR for DrawFocusRect, so must draw
//  the rectangle in the window background color first.
//
////////////////////////////////////////////////////////////////////////////

VOID ChangeBoxFocus(
    PCOLORINFO pCI,
    SHORT nNewBox)
{
    HANDLE hDlg = pCI->hDialog;
    HDC    hDC;
    RECT   rRect;
    LPWORD nCur = (LPWORD)((nNewBox < (NUM_BASIC_COLORS))
                               ? (LONG_PTR)&pCI->nCurDsp
                               : (LONG_PTR)&pCI->nCurMix);
    HPEN   hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DFACE));
    HBRUSH hBrush = GetStockObject(HOLLOW_BRUSH);

    hDC = GetDC(hDlg);
    hPen = SelectObject(hDC, hPen);
    hBrush = SelectObject(hDC, hBrush);
    CopyRect((LPRECT)&rRect, (LPRECT)rColorBox + *nCur);
    InflateRect((LPRECT)&rRect, 3, 3);
    Rectangle(hDC, rRect.left, rRect.top, rRect.right, rRect.bottom);
    CopyRect((LPRECT)&rRect, (LPRECT)rColorBox + (*nCur = nNewBox));
    InflateRect((LPRECT)&rRect, 3, 3);
    Rectangle(hDC, rRect.left, rRect.top, rRect.right, rRect.bottom);
    DrawFocusRect(hDC, (LPRECT)&rRect);
    hPen = SelectObject(hDC, hPen);
    SelectObject(hDC, hBrush);
    ReleaseDC(hDlg, hDC);
    DeleteObject(hPen);
}


////////////////////////////////////////////////////////////////////////////
//
//  ColorKeyDown
//
////////////////////////////////////////////////////////////////////////////

BOOL ColorKeyDown(
    WPARAM wParam,
    int *id,
    PCOLORINFO pCI)
{
    WORD temp;

    temp = (WORD)GetWindowLong(GetFocus(), GWL_ID);
    if (temp == COLOR_BOX1)
    {
        temp = pCI->nCurDsp;
    }
    else if (temp == COLOR_CUSTOM1)
    {
        temp = pCI->nCurMix;
    }
    else
    {
        return (FALSE);
    }

    switch (wParam)
    {
        case ( VK_UP ) :
        {
            if (temp >= (NUM_BASIC_COLORS + NUM_X_BOXES))
            {
                temp -= NUM_X_BOXES;
            }
            else if ((temp < NUM_BASIC_COLORS) && (temp >= NUM_X_BOXES))
            {
                temp -= NUM_X_BOXES;
            }
            break;
        }
        case ( VK_HOME ) :
        {
            if (temp == pCI->nCurDsp)
            {
                temp = 0;
            }
            else
            {
                temp = NUM_BASIC_COLORS;
            }
            break;
        }
        case ( VK_END ) :
        {
            if (temp == pCI->nCurDsp)
            {
                temp = (WORD)(nDriverColors - 1);
            }
            else
            {
                temp = COLORBOXES - 1;
            }
            break;
        }
        case ( VK_DOWN ) :
        {
            if (temp < (NUM_BASIC_COLORS - NUM_X_BOXES))
            {
                temp += NUM_X_BOXES;
            }
            else if ((temp >= (NUM_BASIC_COLORS)) &&
                     (temp < (COLORBOXES - NUM_X_BOXES)))
            {
                temp += NUM_X_BOXES;
            }
            break;
        }
        case ( VK_LEFT ) :
        {
            if (temp % NUM_X_BOXES)
            {
                temp--;
            }
            break;
        }
        case ( VK_RIGHT ) :
        {
            if (!(++temp % NUM_X_BOXES))
            {
                --temp;
            }
            break;
        }
    }

    //
    //  If we've received colors from the driver, make certain the arrow would
    //  not take us to an undefined color.
    //
    if ((temp >= (WORD)nDriverColors) && (temp < NUM_BASIC_COLORS))
    {
        temp = pCI->nCurDsp;
    }

    *id = temp;
    return ((temp != pCI->nCurDsp) && (temp != pCI->nCurMix));
}


////////////////////////////////////////////////////////////////////////////
//
//  FillBox
//
////////////////////////////////////////////////////////////////////////////

VOID FillBox(
    PCOLORINFO pCI,
    HDC hDC,
    LPRECT prc,
    COLORREF rgb)
{
    HBRUSH hBrush;
    RECT rc = *prc;

    DrawEdge(hDC, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);

    hBrush = CreateSolidBrush(MapColor(pCI, rgb));
    FillRect(hDC, &rc, hBrush);
    DeleteObject(hBrush);
}


////////////////////////////////////////////////////////////////////////////
//
//  PaintBox
//
////////////////////////////////////////////////////////////////////////////

VOID PaintBox(
    PCOLORINFO pCI,
    register HDC hDC,
    SHORT i)
{
    if ((i < NUM_BASIC_COLORS) && (i >= nDriverColors))
    {
        return;
    }

    FillBox(pCI, hDC, &rColorBox[i], pCI->rgbBoxColor[i]);

    if (i == (short)pCI->nCurBox)
    {
        HiLiteBox(hDC, i, 1);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  InitScreenCoords
//
//  Returns TRUE iff we make it.
//
////////////////////////////////////////////////////////////////////////////

BOOL InitScreenCoords(
    HWND hDlg,
    PCOLORINFO pCI)
{
    RECT rRect;
    SHORT i;
//  DWORD *lpDriverRGB;
    HWND hBox1, hCustom1;

    hBox1 = GetDlgItem(hDlg, COLOR_BOX1);
    hCustom1 = GetDlgItem(hDlg, COLOR_CUSTOM1);
    lpprocStatic = (WNDPROC)GetWindowLongPtr(hBox1, GWLP_WNDPROC);
    SetWindowLongPtr(hBox1, GWLP_WNDPROC, (LONG_PTR)WantArrows);
    SetWindowLongPtr(hCustom1, GWLP_WNDPROC, (LONG_PTR)WantArrows);

    GetWindowRect(hBox1, (LPRECT)&rRect);
    ScreenToClient(hDlg, (LPPOINT)&rRect.left);
    ScreenToClient(hDlg, (LPPOINT)&rRect.right);
    rRect.left += (BOX_X_MARGIN + 1) / 2;
    rRect.top += (BOX_Y_MARGIN + 1) / 2;
    rRect.right -= (BOX_X_MARGIN + 1) / 2;
    rRect.bottom -= (BOX_Y_MARGIN + 1) / 2;
    nBoxWidth = (SHORT)((rRect.right - rRect.left) / NUM_X_BOXES);
    nBoxHeight = (SHORT)((rRect.bottom - rRect.top) /
                         (NUM_BASIC_COLORS / NUM_X_BOXES));

    //
    //  Assume no colors from driver.
    //
    nDriverColors = 0;

    for (i = 0; i < NUM_BASIC_COLORS; i++)
    {
        rColorBox[i].left = rRect.left + nBoxWidth * (i % NUM_X_BOXES);
        rColorBox[i].right = rColorBox[i].left + nBoxWidth - BOX_X_MARGIN;
        rColorBox[i].top = rRect.top + nBoxHeight * (i / NUM_X_BOXES);
        rColorBox[i].bottom = rColorBox[i].top + nBoxHeight - BOX_Y_MARGIN;

        //
        //  Setup the colors.  If the driver still has colors to give, take it.
        //  If not, if the driver actually gave colors, set the color to white.
        //  Otherwise set to the default colors.
        //
        if (i < nDriverColors)
        {
            // pCI->rgbBoxColor[i] = *lpDriverRGB++;
        }
        else
        {
            pCI->rgbBoxColor[i] = nDriverColors
                                      ? 0xFFFFFF
                                      : rgbBoxColorDefault[i];
        }
    }

    //
    //  If no driver colors, use default number.
    //
    if (!nDriverColors)
    {
        nDriverColors = NUM_BASIC_COLORS;
    }

    GetWindowRect(hCustom1, (LPRECT)&rRect);
    ScreenToClient(hDlg, (LPPOINT)&rRect.left);
    ScreenToClient(hDlg, (LPPOINT)&rRect.right);
    rRect.left += (BOX_X_MARGIN + 1) / 2;
    rRect.top += (BOX_Y_MARGIN + 1) / 2;
    rRect.right -= (BOX_X_MARGIN + 1) / 2;
    rRect.bottom -= (BOX_Y_MARGIN + 1) / 2;

    for (; i < COLORBOXES; i++)
    {
        rColorBox[i].left = rRect.left +
                       nBoxWidth * ((i - (NUM_BASIC_COLORS)) % NUM_X_BOXES);
        rColorBox[i].right = rColorBox[i].left + nBoxWidth - BOX_X_MARGIN;
        rColorBox[i].top = rRect.top +
                       nBoxHeight * ((i - (NUM_BASIC_COLORS)) / NUM_X_BOXES);
        rColorBox[i].bottom = rColorBox[i].top + nBoxHeight - BOX_Y_MARGIN;
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetupRainbowCapture
//
////////////////////////////////////////////////////////////////////////////

VOID SetupRainbowCapture(
    PCOLORINFO pCI)
{
    HWND hwnd;
    HWND hDlg = pCI->hDialog;

    hwnd = GetDlgItem(hDlg, COLOR_RAINBOW);
    GetClientRect(hwnd, &pCI->rRainbow);
    MapWindowPoints(hwnd, hDlg, (LPPOINT)&pCI->rRainbow, 2);

    hwnd = GetDlgItem(hDlg, COLOR_LUMSCROLL);
    GetClientRect(hwnd, &pCI->rLumPaint);
    MapWindowPoints(hwnd, hDlg, (LPPOINT)&pCI->rLumPaint, 2);

    hwnd = GetDlgItem(hDlg, COLOR_CURRENT);
    GetClientRect(hwnd, &pCI->rColorSamples);
    MapWindowPoints(hwnd, hDlg, (LPPOINT)&pCI->rColorSamples, 2);

    pCI->rLumScroll = pCI->rLumPaint;
    pCI->rLumScroll.left = pCI->rLumScroll.right;
    pCI->rLumScroll.right += cxSize / 2;
    pCI->nLumHeight = (WORD)(pCI->rLumPaint.bottom - pCI->rLumPaint.top);

    pCI->rNearestPure = pCI->rColorSamples;
    pCI->rCurrentColor = pCI->rColorSamples;
    pCI->rCurrentColor.right = (pCI->rColorSamples.left + pCI->rColorSamples.right) / 2;
    pCI->rNearestPure.left = pCI->rCurrentColor.right;
}


////////////////////////////////////////////////////////////////////////////
//
//  InitColor
//
//  Returns TRUE iff everything's OK.
//
////////////////////////////////////////////////////////////////////////////

BOOL InitColor(
    HWND hDlg,
    WPARAM wParam,
    PCOLORINFO pCI)
{
    SHORT i;
    RECT rRect;
    LPCHOOSECOLOR pCC = pCI->pCC;
    HDC hDC;
    DWORD FAR *lpCust;
    BOOL bRet;
    HWND hCtlSolid = GetDlgItem(hDlg, COLOR_SOLID);

    if (!hDCFastBlt)
    {
        hDC = GetDC(hDlg);
        hDCFastBlt = CreateCompatibleDC(hDC);
        ReleaseDC(hDlg, hDC);
        if (!hDCFastBlt)
        {
            return(FALSE);
        }
    }

    pCI->hDialog = hDlg;

    SetupRainbowCapture(pCI);

    if (pCC->Flags & CC_RGBINIT)
    {
        pCI->currentRGB = pCC->rgbResult;
    }
    else
    {
        pCI->currentRGB = 0L;
    }
    if (pCC->Flags & (CC_PREVENTFULLOPEN | CC_FULLOPEN))
    {
        EnableWindow(GetDlgItem(hDlg, COLOR_MIX), FALSE);
    }

    if (pCC->Flags & CC_SOLIDCOLOR)
    {
        ShowWindow(GetDlgItem(hDlg, COLOR_SOLID_RIGHT), SW_HIDE);
    }

    if (pCC->Flags & CC_FULLOPEN)
    {
        InitRainbow(pCI);
        pCI->bFoldOut = TRUE;
        RGBtoHLS(pCI->currentRGB);
        pCI->currentHue = gHue;
        pCI->currentSat = gSat;
        pCI->currentLum = gLum;
        SetRGBEdit(0, pCI);
        SetHLSEdit(0, pCI);
    }
    else
    {
        //
        //  Code relies on COLOR_HUE through COLOR_BLUE being consecutive.
        //
        for (i = COLOR_HUE; i <= COLOR_BLUE; i++)
        {
            EnableWindow(GetDlgItem(hDlg, i), FALSE);
        }
        for (i = COLOR_HUEACCEL; i <= COLOR_BLUEACCEL; i++)
        {
            EnableWindow(GetDlgItem(hDlg, i), FALSE);
        }

        EnableWindow(GetDlgItem(hDlg, COLOR_ADD), FALSE);

        EnableWindow(hCtlSolid, FALSE);
        EnableWindow(GetDlgItem(hDlg, COLOR_SOLID_RIGHT), FALSE);

        pCI->bFoldOut = FALSE;

        GetWindowRect(GetDlgItem(hDlg, COLOR_BOX1), &rRect);
        i = (SHORT)rRect.right;
        GetWindowRect(GetDlgItem(hDlg, COLOR_RAINBOW), &rRect);
        GetWindowRect(hDlg, &(pCI->rOriginal));
        MoveWindow( hDlg,
                    pCI->rOriginal.left,
                    pCI->rOriginal.top,
                    (rRect.left + i) / 2 - pCI->rOriginal.left,
                    pCI->rOriginal.bottom - pCI->rOriginal.top,
                    FALSE );
    }

    InitScreenCoords(hDlg, pCI);

    lpCust = pCC->lpCustColors;
    for (i = NUM_BASIC_COLORS; i < NUM_BASIC_COLORS + NUM_CUSTOM_COLORS; i++)
    {
        pCI->rgbBoxColor[i] = *lpCust++;
    }

    pCI->nCurBox = pCI->nCurDsp = 0;
    pCI->nCurMix = NUM_BASIC_COLORS;
    ChangeColorBox(pCI, pCI->currentRGB);
    if (pCI->nCurBox < pCI->nCurMix)
    {
        pCI->nCurDsp = pCI->nCurBox;
    }
    else
    {
        pCI->nCurMix = pCI->nCurBox;
    }

    if (!(pCC->Flags & CC_SHOWHELP))
    {
        HWND hHelp;

        EnableWindow(hHelp = GetDlgItem(hDlg, pshHelp), FALSE);
        ShowWindow(hHelp, SW_HIDE);
    }

    SetWindowLong( hCtlSolid,
                   GWL_STYLE,
                   GetWindowLong(hCtlSolid, GWL_STYLE) & (~WS_TABSTOP) );

    if (pCC->lpfnHook)
    {
        LPCCHOOKPROC lpfnHook = GETHOOKFN(pCC);

#ifdef UNICODE
        if (pCI->ApiType == COMDLG_ANSI)
        {
            ThunkChooseColorW2A(pCI);
            bRet = ((* lpfnHook)( hDlg,
                                  WM_INITDIALOG,
                                  wParam,
                                  (LPARAM)pCI->pCCA ));

            //
            //  Strange win 31 example uses lCustData to hold a temporary
            //  variable that it passes back to calling function.
            //
            ThunkChooseColorA2W(pCI);
            pCC->lCustData = pCI->pCCA->lCustData;
        }
        else
#endif
        {
            bRet = ((* lpfnHook)( hDlg,
                                  WM_INITDIALOG,
                                  wParam,
                                  (LPARAM)pCC ));
        }
    }
    else
    {
        bRet = TRUE;
    }

    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  ColorPaint
//
////////////////////////////////////////////////////////////////////////////

VOID ColorPaint(
    HWND hDlg,
    PCOLORINFO pCI,
    HDC hDC,
    LPRECT lpPaintRect)
{
    SHORT i;
    HWND hFocus;

    for (i = 0; i < nDriverColors; i++)
    {
        PaintBox(pCI, hDC, i);
    }
    for (i = NUM_BASIC_COLORS; i < COLORBOXES; i++)
    {
        PaintBox(pCI, hDC, i);
    }

    //
    //  Must redraw focus as well as paint boxes.
    //
    hFocus = GetFocus();
    if (hFocus == GetDlgItem(hDlg, COLOR_BOX1))
    {
        i = pCI->nCurDsp;
    }
    else if (hFocus == GetDlgItem(hDlg, COLOR_CUSTOM1))
    {
        i = pCI->nCurMix;
    }
    else
    {
        goto NoDrawFocus;
    }
    ChangeBoxFocus(pCI, i);

NoDrawFocus:
    RainbowPaint(pCI, hDC, lpPaintRect);
}


////////////////////////////////////////////////////////////////////////////
//
//  WantArrows
//
////////////////////////////////////////////////////////////////////////////

LONG WINAPI WantArrows(
    HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    PCOLORINFO pCI;
    RECT rcTemp;
    HDC hDC;
    WORD temp;

    switch (msg)
    {
        case ( WM_GETDLGCODE ) :
        {
            return (DLGC_WANTARROWS | DLGC_WANTCHARS);
            break;
        }
        case WM_KEYDOWN:
        case WM_CHAR:
        {
            return ((LONG) SendMessage(GetParent(hWnd), msg, wParam, lParam));
            break;
        }
        case ( WM_SETFOCUS ) :
        case ( WM_KILLFOCUS ) :
        {
            if (pCI = (PCOLORINFO) GetProp(GetParent(hWnd), COLORPROP))
            {
                if (GetWindowLong(hWnd, GWL_ID) == COLOR_BOX1)
                {
                    temp = pCI->nCurDsp;
                }
                else
                {
                    temp = pCI->nCurMix;
                }

                hDC = GetDC(GetParent(hWnd));
                CopyRect((LPRECT)&rcTemp, (LPRECT)rColorBox + temp);
                InflateRect((LPRECT)&rcTemp, 3, 3);
                DrawFocusRect(hDC, (LPRECT)&rcTemp);
                ReleaseDC(GetParent(hWnd), hDC);
                break;
            }

            //  Fall thru...
        }
        default :
        {
            return ((LONG)CallWindowProc(lpprocStatic, hWnd, msg, wParam, lParam));
        }
    }
    return ((LONG)CallWindowProc(lpprocStatic, hWnd, msg, wParam, lParam));
}


////////////////////////////////////////////////////////////////////////////
//
//  MapColor
//
////////////////////////////////////////////////////////////////////////////

DWORD MapColor(
    PCOLORINFO pCI,
    DWORD rgb)
{
    if (pCI->pCC->Flags & CC_SOLIDCOLOR)
    {
        HDC hdc = GetDC(NULL);

        rgb = GetNearestColor(hdc, rgb);
        ReleaseDC(NULL, hdc);
    }

    return (rgb);
}


////////////////////////////////////////////////////////////////////////////
//
//  TermColor
//
////////////////////////////////////////////////////////////////////////////

VOID TermColor()
{
    if (hRainbowBitmap)
    {
        DeleteObject(hRainbowBitmap);
        hRainbowBitmap = NULL;
    }
    if (hDCFastBlt)
    {
        DeleteDC(hDCFastBlt);
        hDCFastBlt = 0;
    }
}






/*========================================================================*/
/*                 Ansi->Unicode Thunk routines                           */
/*========================================================================*/

#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  ThunkChooseColorA2W
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkChooseColorA2W(
    PCOLORINFO pCI)
{
    LPCHOOSECOLORW pCCW = pCI->pCC;
    LPCHOOSECOLORA pCCA = pCI->pCCA;

    pCCW->lCustData = pCCA->lCustData;
    pCCW->Flags = pCCA->Flags;

    pCCW->hInstance = pCCA->hInstance;

    pCCW->lpfnHook = pCCA->lpfnHook;

    //
    //  CC_RGBINIT conditional = time it takes to do it => just do it.
    //
    pCCW->rgbResult = pCCA->rgbResult;

    pCCW->lpCustColors = pCCA->lpCustColors;
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkChooseColorW2A
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkChooseColorW2A(
    PCOLORINFO pCI)
{
    LPCHOOSECOLORW pCCW = pCI->pCC;
    LPCHOOSECOLORA pCCA = pCI->pCCA;

    //
    //  Supposedly invariant, but not necessarily.
    //
    pCCA->Flags = pCCW->Flags;
    pCCA->lCustData = pCCW->lCustData;

    pCCA->lpfnHook = pCCW->lpfnHook;

    pCCA->rgbResult = pCCW->rgbResult;
    pCCA->lpCustColors = pCCW->lpCustColors;
}


#ifdef WINNT

////////////////////////////////////////////////////////////////////////////
//
//  Ssync_ANSI_UNICODE_CC_For_WOW
//
//  Function to allow NT WOW to keep the ANSI & UNICODE versions of
//  the CHOOSEFONT structure in ssync as required by many 16-bit apps.
//  See notes for Ssync_ANSI_UNICODE_Struct_For_WOW() in dlgs.c.
//
////////////////////////////////////////////////////////////////////////////

VOID Ssync_ANSI_UNICODE_CC_For_WOW(
    HWND hDlg,
    BOOL f_ANSI_to_UNICODE)
{
    PCOLORINFO pCI;

    if (pCI = (PCOLORINFO)GetProp(hDlg, COLORPROP))
    {
        if (pCI->pCC && pCI->pCCA)
        {
            if (f_ANSI_to_UNICODE)
            {
                ThunkChooseColorA2W(pCI);
            }
            else
            {
                ThunkChooseColorW2A(pCI);
            }
        }
    }
}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\color.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    color.h

Abstract:

    This module contains the header information for the Win32 color dialogs.

Revision History:

--*/



//
//  Include Files.
//

#include <colordlg.h>
#include <help.h>




//
//  Constant Declarations.
//

#define COLORBOXES           64
#define NUM_X_BOXES          8
#define BOX_X_MARGIN         5
#define BOX_Y_MARGIN         5
//
//  Range of values for HLS scrollbars.
//  HLS-RGB conversions work best when RANGE is divisible by 6.
//
#define RANGE                240

#define HLSMAX               RANGE
#define RGBMAX               255

#define HUEINC               4
#define SATINC               8
#define LUMINC               8


//
//  This used to be in wingdi.h, but recently moved to wingdip.h
//  Including wingdip.h causes too many compiler errors, so define
//  the one constant we need here.
//
#define HS_DITHEREDTEXTCLR   9

#define COLORPROP  (LPCTSTR) 0xA000L




//
//  Typedef Declarations.
//

typedef struct {
    UINT           ApiType;
    LPCHOOSECOLOR  pCC;
    HANDLE         hLocal;
    HANDLE         hDialog;
    HPALETTE       hPal;
    DWORD          currentRGB;
    WORD           currentHue;
    WORD           currentSat;
    WORD           currentLum;
    WORD           nHueWidth;
    WORD           nSatHeight;
    WORD           nLumHeight;
    WORD           nCurMix;
    WORD           nCurDsp;
    WORD           nCurBox;
    WORD           nHuePos;
    WORD           nSatPos;
    WORD           nLumPos;
    RECT           rOriginal;
    RECT           rRainbow;
    RECT           rLumScroll;
    RECT           rLumPaint;
    RECT           rCurrentColor;
    RECT           rNearestPure;
    RECT           rColorSamples;
    BOOL           bFoldOut;
    DWORD          rgbBoxColor[COLORBOXES];
#ifdef UNICODE
    LPCHOOSECOLORA pCCA;
#endif
} COLORINFO;

typedef COLORINFO *PCOLORINFO;

#define LPDIS LPDRAWITEMSTRUCT




//
//  Extern Declarations.
//

extern HDC hDCFastBlt;
extern DWORD rgbClient;
extern WORD gHue,gSat,gLum;
extern HBITMAP hRainbowBitmap;
extern BOOL bMouseCapture;
extern WNDPROC lpprocStatic;
extern SHORT nDriverColors;
extern DWORD rgbBoxColor[COLORBOXES];

extern TCHAR szOEMBIN[];

extern RECT rColorBox[COLORBOXES];
extern SHORT nBoxHeight, nBoxWidth;
extern HWND hSave;
extern WNDPROC qfnColorDlg;




//
//  Context Help IDs.
//

const static DWORD aColorHelpIDs[] =             // Context Help IDs
{
    COLOR_BOX1,        IDH_COLOR_BASIC,
    COLOR_CUSTOM1,     IDH_COLOR_CUSTOM_CUSTOM,
    COLOR_MIX,         IDH_COLOR_DEFINE,
    COLOR_RAINBOW,     IDH_COLOR_SAMPLE_COLOR,
    COLOR_LUMSCROLL,   IDH_COLOR_SAMPLE_SCROLL,
    COLOR_CURRENT,     IDH_COLOR_COLOR_SOLID,
    COLOR_SOLID,       IDH_COLOR_COLOR_SOLID,
    COLOR_SOLID_LEFT,  IDH_COLOR_COLOR_SOLID,
    COLOR_SOLID_RIGHT, IDH_COLOR_COLOR_SOLID,
    COLOR_HUEACCEL,    IDH_COLOR_HUE,
    COLOR_HUE,         IDH_COLOR_HUE,
    COLOR_SATACCEL,    IDH_COLOR_SAT,
    COLOR_SAT,         IDH_COLOR_SAT,
    COLOR_LUMACCEL,    IDH_COLOR_LUM,
    COLOR_LUM,         IDH_COLOR_LUM,
    COLOR_REDACCEL,    IDH_COLOR_RED,
    COLOR_RED,         IDH_COLOR_RED,
    COLOR_GREENACCEL,  IDH_COLOR_GREEN,
    COLOR_GREEN,       IDH_COLOR_GREEN,
    COLOR_BLUEACCEL,   IDH_COLOR_BLUE,
    COLOR_BLUE,        IDH_COLOR_BLUE,
    COLOR_ADD,         IDH_COLOR_ADD,

    0, 0
};




//
// Function Prototypes.
//

//
//  color.c
//
BOOL
ChooseColorX(
    PCOLORINFO pCI);

BOOL_PTR CALLBACK
ColorDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam);

BOOL
ChangeColorBox(
    register PCOLORINFO pCI,
    DWORD dwRGBcolor);

VOID
HiLiteBox(
    HDC hDC,
    SHORT nBox,
    SHORT fStyle);

VOID
ChangeBoxSelection(
    PCOLORINFO pCI,
    SHORT nNewBox);

VOID
ChangeBoxFocus(
    PCOLORINFO pCI,
    SHORT nNewBox);

BOOL
ColorKeyDown(
    WPARAM wParam,
    int *id,
    PCOLORINFO pCI);

VOID
PaintBox(
    PCOLORINFO pCI,
    register HDC hDC,
    SHORT i);

BOOL
InitScreenCoords(
    HWND hDlg,
    PCOLORINFO pCI);

VOID
SetupRainbowCapture(
    PCOLORINFO pCI);

BOOL
InitColor(
    HWND hDlg,
    WPARAM wParam,
    PCOLORINFO pCI);

VOID
ColorPaint(
    HWND hDlg,
    PCOLORINFO pCI,
    HDC hDC,
    LPRECT lpPaintRect);

LONG WINAPI
WantArrows(
    HWND hWnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam);

DWORD
MapColor(
    PCOLORINFO pCI,
    DWORD rgb);

VOID
TermColor();


#ifdef UNICODE
  VOID
  ThunkChooseColorA2W(
      PCOLORINFO pCI);

  VOID
  ThunkChooseColorW2A(
      PCOLORINFO pCI);
#endif


//
//  color2.c
//
VOID
ChangeColorSettings(
    register PCOLORINFO pCI);

VOID
LumArrowPaint(
    HDC hDC,
    SHORT y,
    PCOLORINFO pCI);

VOID
EraseLumArrow(
    HDC hDC,
    PCOLORINFO pCI);

VOID
EraseCrossHair(
    HDC hDC,
    PCOLORINFO pCI);

VOID
CrossHairPaint(
    register HDC hDC,
    SHORT x,
    SHORT y,
    PCOLORINFO pCI);

VOID
NearestSolid(
    register PCOLORINFO pCI);

VOID
HLSPostoHLS(
    SHORT nHLSEdit,
    register PCOLORINFO pCI);

VOID
HLStoHLSPos(
    SHORT nHLSEdit,
    register PCOLORINFO pCI);

VOID
SetHLSEdit(
    SHORT nHLSEdit,
    register PCOLORINFO pCI);

VOID
SetRGBEdit(
    SHORT nRGBEdit,
    PCOLORINFO pCI);

BOOL
InitRainbow(
    register PCOLORINFO pCI);

VOID
PaintRainbow(
    HDC hDC,
    LPRECT lpRect,
    register PCOLORINFO pCI);

void
RainbowPaint(
    register PCOLORINFO pCI,
    HDC hDC,
    LPRECT lpPaintRect);

VOID
RGBtoHLS(
    DWORD lRGBColor);

WORD
HueToRGB(
    WORD n1,
    WORD n2,
    WORD hue);

DWORD
HLStoRGB(
    WORD hue,
    WORD lum,
    WORD sat);

SHORT
RGBEditChange(
    SHORT nDlgID,
    PCOLORINFO pCI);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\data.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    data.c

Abstract:

    This module contains the global data for the Win32 common dialogs.
    Anything added here must have 'extern' added to privcomd.h.

Revision History:

--*/



//
//  Include Files.
//

#include "comdlg32.h"




//
//  Global Variables.
//

//
//  FileOpen
//
TCHAR szOEMBIN[]        = TEXT("OEMBIN");
TCHAR szNull[]          = TEXT("");
TCHAR szStar[]          = TEXT("*");
TCHAR szStarDotStar[12] = TEXT("*.*");
TCHAR szDotStar[]       = TEXT(".*");

TCHAR const szMyDocsReg[]     = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Documents");
TCHAR const szMyDocsDisable[] = TEXT("DisableStartInMyDocs");
TCHAR const szMyDocsHidden[]  = TEXT("HideMyDocsFolder");
TCHAR const szMRURegPath[]=TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\OpenSaveMRU");
SIZE  g_sizeDlg;

TCHAR g_szInitialCurDir[MAX_PATH];

BOOL g_bDisableMyDocs;
BOOL g_bMyDocsHidden;


//
//  Color
//
DWORD rgbClient;
WORD gHue, gSat, gLum;
HBITMAP hRainbowBitmap;
BOOL bMouseCapture;
WNDPROC lpprocStatic;
SHORT nDriverColors;
BOOL bUserPressedCancel;

HWND hSave;

WNDPROC qfnColorDlg = NULL;
HDC hDCFastBlt = NULL;

SHORT cyCaption, cyBorder, cyVScroll;
SHORT cxVScroll, cxBorder, cxSize;
SHORT nBoxHeight, nBoxWidth;


//
//  dlgs.c
//
HINSTANCE g_hinst = NULL;

BOOL bMouse;                      // system has a mouse
BOOL bCursorLock;
WORD wWinVer;                     // Windows version
WORD wDOSVer;                     // DOS version

UINT msgHELPA;                    // initialized using RegisterWindowMessage
UINT msgHELPW;                    // initialized using RegisterWindowMessage

HDC hdcMemory = HNULL;            // temp DC used to draw bitmaps
HBITMAP hbmpOrigMemBmp = HNULL;   // bitmap originally selected into hdcMemory

OFN_DISKINFO gaDiskInfo[MAX_DISKS];

CRITICAL_SECTION g_csLocal;
CRITICAL_SECTION g_csNetThread;
CRITICAL_SECTION g_csExtError;

DWORD dwNumDisks;

HANDLE hMPR;
HANDLE hMPRUI;
HANDLE hLNDEvent;

DWORD g_tlsiCurDlg;    // TLS index used to get the ptr to current CURDLG struct
                       // for each thread (see CURDLG in comdlg32.h)

DWORD g_tlsiExtError;  // ExtErrors are the most recent error per thread.

DWORD cbNetEnumBuf;
LPTSTR gpcNetEnumBuf;

#ifdef WX86
  PALLOCCALLBX86 pfnAllocCallBx86;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\comdlg32.inc ===
#
#  Common settings for comdlg32
#

INCLUDES = ..\..\comdlg32mm;$(INCLUDES)

!include $(CCSHELL_DIR)\common.inc

SOURCES_USED = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\comdlg32.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    comdlg32.h

Abstract:

    This module contains the private header information for the Win32
    common dialogs.

Revision History:

--*/



#ifndef COMDLG_COMDLG32
#define COMDLG_COMDLG32

#ifdef __cplusplus
extern "C" {
#endif




//
//  Include Files.
//

#define STRICT
#define _WIN32_DCOM

#ifdef WINNT                // These files ALWAYS have to be first
  #include <nt.h>
  #include <ntrtl.h>
  #include <nturtl.h>
#endif

#include <windows.h>
#include <windowsx.h>
#include <shlwapi.h>        // must be included before shlobj.h
#include <ccstock.h>
#ifdef WINNT_ENV
  #include <shlwapip.h>
#endif

#include <commdlg.h>
#include <dlgs.h>
#include "isz.h"
#include "cderr.h"

#ifdef WINNT
  #include <wowcmndg.h>
  #include <winuserp.h>
  #include <npapi.h>
#else
  #include <krnlcmn.h>
#endif

#include <platform.h>
#include <port32.h>

//
//  Constant Declarations.
//

#define SEM_NOERROR               0x8003

//
//  There really should be no "max" path lengths, but for now,
//  since unc will take up RMLEN (lmcons.h), make it 98.
//
#define CCHUNCPATH                98
#define CCHNETPATH                358

#define MAX_THREADS               128

#define CHAR_A                    TEXT('a')
#define CHAR_CAP_A                TEXT('A')
#define CHAR_C                    TEXT('c')
#define CHAR_Z                    TEXT('z')
#define CHAR_NULL                 TEXT('\0')
#define CHAR_COLON                TEXT(':')
#define CHAR_BSLASH               TEXT('\\')
#define CHAR_DOT                  TEXT('.')
#define CHAR_QMARK                TEXT('?')
#define CHAR_STAR                 TEXT('*')
#define CHAR_SLASH                TEXT('/')
#define CHAR_SPACE                TEXT(' ')
#define CHAR_QUOTE                TEXT('"')
#define CHAR_PLUS                 TEXT('+')
#define CHAR_LTHAN                TEXT('<')
#define CHAR_BAR                  TEXT('|')
#define CHAR_COMMA                TEXT(',')
#define CHAR_LBRACKET             TEXT('[')
#define CHAR_RBRACKET             TEXT(']')
#define CHAR_EQUAL                TEXT('=')
#define CHAR_SEMICOLON            TEXT(';')

#define STR_BLANK                 TEXT("")
#define STR_SEMICOLON             TEXT(";")

#define IS_DOTEND(ch)   ((ch) == CHAR_DOT || (ch) == 0 || ((ch) != CHAR_STAR))

#define PARSE_DIRECTORYNAME       -1
#define PARSE_INVALIDDRIVE        -2
#define PARSE_INVALIDPERIOD       -3
#define PARSE_MISSINGDIRCHAR      -4
#define PARSE_INVALIDCHAR         -5
#define PARSE_INVALIDDIRCHAR      -6
#define PARSE_INVALIDSPACE        -7
#define PARSE_EXTENSIONTOOLONG    -8
#define PARSE_FILETOOLONG         -9
#define PARSE_EMPTYSTRING         -10
#define PARSE_WILDCARDINDIR       -11
#define PARSE_WILDCARDINFILE      -12
#define PARSE_INVALIDNETPATH      -13
#define PARSE_NOXMEMORY           -14

#define OF_FILENOTFOUND           2
#define OF_PATHNOTFOUND           3
#define OF_NOFILEHANDLES          4
#define OF_ACCESSDENIED           5         // OF_NODISKINFLOPPY
#define OF_WRITEPROTECTION        19
#define OF_SHARINGVIOLATION       32
#define OF_NETACCESSDENIED        65
#define OF_DISKFULL               82
#define OF_INT24FAILURE           83
#define OF_CREATENOMODIFY         96
#define OF_NODRIVE                97
#define OF_PORTNAME               98
#define OF_LAZYREADONLY           99
#define OF_DISKFULL2              112

#ifndef DCE_UNICODIZED
  #define DeviceCapabilitiesExA DeviceCapabilitiesEx
#endif

//
//  Used to determine which type of message to send to the app.
//
#define COMDLG_ANSI               0x0
#define COMDLG_WIDE               0x1

#define HNULL                     ((HANDLE) 0)

#define cbResNameMax              32
#define cbDlgNameMax              32




//
//  Platform specific definitions.
//

#ifdef WINNT
  #define IS16BITWOWAPP(p) ((p)->Flags & CD_WOWAPP)
#else
  #define IS16BITWOWAPP(p) (GetProcessDword(0, GPD_FLAGS) & GPF_WIN16_PROCESS)
#endif

#ifdef WX86
  #define ISWX86APP(p)            ((p)->Flags & CD_WX86APP)
  #define GETGENERICHOOKFN(p,fn)  (ISWX86APP(p) ? Wx86GetX86Callback((p)->fn) : (p)->fn)
#else
  #define ISWX86APP(p)            (FALSE)
  #define GETGENERICHOOKFN(p,fn)  ((p)->fn)
#endif

#define GETHOOKFN(p)            GETGENERICHOOKFN(p,lpfnHook)
#define GETPRINTHOOKFN(p)       GETGENERICHOOKFN(p,lpfnPrintHook)
#define GETSETUPHOOKFN(p)       GETGENERICHOOKFN(p,lpfnSetupHook)
#define GETPAGEPAINTHOOKFN(p)   GETGENERICHOOKFN(p,lpfnPagePaintHook)

#ifndef CD_WX86APP
  #define CD_WX86APP      (0)     // Nothing special if we don't have it defined
#endif




//
//  Typedef Declarations.
//




//
//  External Declarations.
//

extern HINSTANCE g_hinst;              // instance handle of library

extern SHORT cyCaption, cyBorder, cyVScroll;
extern SHORT cxVScroll, cxBorder, cxSize;

extern TCHAR szNull[];
extern TCHAR szStar[];
extern TCHAR szStarDotStar[];

extern BOOL bMouse;                    // system has a mouse
extern BOOL bCursorLock;
extern BOOL bWLO;                      // running with WLO
extern BOOL bDBCS;                     // running DBCS
extern WORD wWinVer;                   // windows version
extern WORD wDOSVer;                   // DOS version
extern BOOL bUserPressedCancel;        // user pressed cancel button

//
//  initialized via RegisterWindowMessage
//
extern UINT msgWOWLFCHANGE;
extern UINT msgWOWDIRCHANGE;
extern UINT msgWOWCHOOSEFONT_GETLOGFONT;

extern UINT msgLBCHANGEA;
extern UINT msgSHAREVIOLATIONA;
extern UINT msgFILEOKA;
extern UINT msgCOLOROKA;
extern UINT msgSETRGBA;
extern UINT msgHELPA;

extern UINT msgLBCHANGEW;
extern UINT msgSHAREVIOLATIONW;
extern UINT msgFILEOKW;
extern UINT msgCOLOROKW;
extern UINT msgSETRGBW;
extern UINT msgHELPW;

extern UINT g_cfCIDA;




//
//  Function Prototypes.
//

VOID TermFind(void);
VOID TermColor(void);
VOID TermFont(void);
VOID TermFile(void);
VOID TermPrint(void);

void FreeImports(void);

//
//  dlgs.c
//
VOID
HourGlass(
    BOOL bOn);

void
StoreExtendedError(
    DWORD dwError);

DWORD
GetStoredExtendedError(void);

HBITMAP WINAPI
LoadAlterBitmap(
    int id,
    DWORD rgbReplace,
    DWORD rgbInstead);

VOID
AddNetButton(
    HWND hDlg,
    HANDLE hInstance,
    int dyBottomMargin,
    BOOL bAddAccel,
    BOOL bTryLowerRight,
    BOOL bTryLowerLeft);

BOOL
IsNetworkInstalled(void);

//
//  parse.c
//
int
ParseFileNew(
    LPTSTR pszPath,
    int *pnExtOffset,
    BOOL bWowApp,
    BOOL bNewStyle);

int
ParseFileOld(
    LPTSTR pszPath,
    int *pnExtOffset,
    int *pnOldExt,
    BOOL bWowApp,
    BOOL bNewStyle);

DWORD
ParseFile(
    LPTSTR lpstrFileName,
    BOOL bLFNFileSystem,
    BOOL bWowApp,
    BOOL bNewStyle);

LPTSTR
PathRemoveBslash(
    LPTSTR lpszPath);

BOOL
IsWild(
    LPTSTR lpsz);

VOID
AppendExt(
    LPTSTR lpszPath,
    LPCTSTR lpExtension,
    BOOL bWildcard);

BOOL
IsUNC(
    LPCTSTR lpszPath);

BOOL
PortName(
    LPTSTR lpszFileName);

BOOL
IsDirectory(
    LPTSTR pszPath);

int
WriteProtectedDirCheck(
    LPTSTR lpszFile);

BOOL
FOkToWriteOver(
    HWND hDlg,
    LPTSTR szFileName);

int
CreateFileDlg(
    HWND hDlg,
    LPTSTR szPath);




//
//  Fileopen specific stuff stashed here so we can free it upon
//  a DLL_PROCESS_DETACH.
//
typedef struct _OFN_DISKINFO {
    UINT   cchLen;           // number of chars allocated in 4 lptstrs
    LPTSTR lpAbbrName;       // single line form
    LPTSTR lpMultiName;      // drop-down form
    LPTSTR lpName;           // true form (for comparisons)
    LPTSTR lpPath;           // path prefix (a:, or \\server\share) for file searches
    TCHAR  wcDrive;          // drive letter, 0 for unc
    BOOL   bCasePreserved;
    DWORD  dwType;
    BOOL   bValid;
} OFN_DISKINFO;

#define MAX_DISKS                 100
#define WNETENUM_BUFFSIZE         0x4000

//
//  Defines for AddNetButton.
//
#define FILE_LEFT_MARGIN          5
#define FILE_RIGHT_MARGIN         3
#define FILE_TOP_MARGIN           0
#define FILE_BOTTOM_MARGIN        3


#ifdef WX86
  //
  // Wx86 support for calling from RISC into x86 hooks
  //
  PVOID
  Wx86GetX86Callback(
      PVOID lpfnHook);

  typedef PVOID
  (*PALLOCCALLBX86)(
      PVOID pfnx86,
      ULONG CBParamType,
      PVOID ThunkDebug,
      PULONG  pLogFlags);

  extern PALLOCCALLBX86 pfnAllocCallBx86;
#endif


#ifdef __cplusplus
};  // extern "C"
#endif


// For WOW support on WINNT
#ifdef WINNT
  VOID Ssync_ANSI_UNICODE_Struct_For_WOW(HWND hDlg, BOOL fDirection, DWORD dwID);
  VOID Ssync_ANSI_UNICODE_CC_For_WOW(HWND hDlg, BOOL f_ANSI_to_UNICODE);
  VOID Ssync_ANSI_UNICODE_CF_For_WOW(HWND hDlg, BOOL f_ANSI_to_UNICODE);
  VOID Ssync_ANSI_UNICODE_OFN_For_WOW(HWND hDlg, BOOL f_ANSI_to_UNICODE);
  VOID Ssync_ANSI_UNICODE_PD_For_WOW(HWND hDlg, BOOL f_ANSI_to_UNICODE);
#endif

// For nested FileOpen/Save common dialog support (something several 16-bit apps
// are known to do).  We keep a list of all the dialogs that are active for each
// thread in a process.  We make the assumption that common dialogs are THREAD 
// modal -- so the first CURDLG struct in the list for a given thread is the 
// currently active dialog (has the focus) for that thread.  The ptr to the head
// of the list is stored in the thread local storage (TLS) for the thread --
// indexed by g_tlsiCurDlg.  Bug #100453 et. al.
typedef struct _CURDLG {
  DWORD           dwCurDlgNum;     // incremental dlg number (per process)
  LPTSTR          lpstrCurDir;     // current directory for the current dialog
  struct _CURDLG *next;
} CURDLG; 
typedef CURDLG *LPCURDLG;



#endif // !COMDLG_COMDLG32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\dllload.c ===
#define _OLE32_         // for DECLSPEC_IMPORT delay load

#include <windows.h>
#include <winnetwk.h>
#include <winnetp.h>

void _GetProcFromDLL(HMODULE* phinst, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
    // If it's already loaded, return.
    if (*ppfn)
        return;

    if (*phinst == NULL) {
        *phinst = LoadLibraryA(pszDLL);
        if (*phinst == NULL) {
            return;
        }
    }
    *ppfn = GetProcAddress(*phinst, pszProc);
}

#define DELAY_LOAD_MAP(_hinst, _dll, _ret, _fnpriv, _fn, _args, _nargs, _err) \
_ret __stdcall _fnpriv _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)               \
    return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err)    DELAY_LOAD_MAP(_hinst, _dll, _ret, _fn, _fn, _args, _nargs, _err)

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_BOOL(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, BOOL, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)

#define DELAY_LOAD_WNET(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, WN_NOT_SUPPORTED)

#define DELAY_MAP_DWORD(_hinst, _dll, _fnpriv, _fn, _args, _nargs) DELAY_LOAD_MAP(_hinst, _dll, DWORD, _fnpriv, _fn, _args, _nargs, 0)

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)              \
    _pfn##_fn _nargs;       \
    return;                     \
}

// --------- MPR.DLL ---------------

HMODULE g_hmodMPR = NULL;

DELAY_LOAD_WNET(g_hmodMPR, MPR.DLL, WNetConnectionDialog, (HWND  hwnd, DWORD dwType), (hwnd, dwType));

DELAY_LOAD_WNET(g_hmodMPR, MPR.DLL, WNetCloseEnum, (HANDLE hEnum), (hEnum));

#ifdef UNICODE

DELAY_LOAD_WNET(g_hmodMPR, MPR.DLL, WNetEnumResourceW,
       (HANDLE  hEnum, LPDWORD lpcCount, LPVOID  lpBuffer, LPDWORD lpBufferSize),
       (hEnum, lpcCount, lpBuffer, lpBufferSize));

DELAY_LOAD_WNET(g_hmodMPR, MPR.DLL, WNetOpenEnumW,
       (DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum),
       (dwScope, dwType, dwUsage, lpNetResource, lphEnum));

DELAY_LOAD_WNET(g_hmodMPR, MPR.DLL, WNetFormatNetworkNameW,
    (LPCWSTR lpProvider, LPCWSTR lpRemoteName, LPWSTR lpFormattedName,
     LPDWORD lpnLength, DWORD dwFlags, DWORD dwAveCharPerLine),
    (lpProvider, lpRemoteName, lpFormattedName, lpnLength,  dwFlags, dwAveCharPerLine));

DELAY_LOAD_WNET(g_hmodMPR, MPR.DLL, WNetRestoreConnectionW,
       (HWND hwnd, LPCWSTR psz),
       (hwnd, psz));

#else

DELAY_LOAD_WNET(g_hmodMPR, MPR.DLL, WNetEnumResourceA,
       (HANDLE  hEnum, LPDWORD lpcCount, LPVOID  lpBuffer, LPDWORD lpBufferSize),
       (hEnum, lpcCount, lpBuffer, lpBufferSize));

DELAY_LOAD_WNET(g_hmodMPR, MPR.DLL, WNetOpenEnumA,
       (DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEA lpNetResource, LPHANDLE lphEnum),
       (dwScope, dwType, dwUsage, lpNetResource, lphEnum));

DELAY_LOAD_WNET(g_hmodMPR, MPR.DLL, WNetFormatNetworkNameA,
    (LPCSTR lpProvider, LPCSTR lpRemoteName, LPSTR lpFormattedName,
     LPDWORD lpnLength, DWORD dwFlags, DWORD dwAveCharPerLine),
    (lpProvider, lpRemoteName, lpFormattedName, lpnLength,  dwFlags, dwAveCharPerLine));

DELAY_LOAD_WNET(g_hmodMPR, MPR.DLL, WNetRestoreConnectionA,
       (HWND hwnd, LPCSTR psz),
       (hwnd, psz));

#endif


// -----------ole32.dll---------------

HMODULE g_hmodOLE32 = NULL;

DELAY_LOAD_HRESULT(g_hmodOLE32, OLE32.DLL, CoCreateInstance,
    (REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, void ** ppv), (rclsid, pUnkOuter, dwClsContext, riid, ppv));

DELAY_LOAD_HRESULT(g_hmodOLE32, OLE32.DLL, CoInitialize, (void *pv), (pv));
DELAY_LOAD_HRESULT(g_hmodOLE32, OLE32.DLL, CoInitializeEx, (void *pv, DWORD dw), (pv, dw));
DELAY_LOAD_VOID(g_hmodOLE32, OLE32.DLL, CoUninitialize, (void), ());

DELAY_LOAD_HRESULT(g_hmodOLE32, OLE32.DLL, OleInitialize, (void *pv), (pv));
DELAY_LOAD_VOID(g_hmodOLE32, OLE32.DLL, OleUninitialize, (void), ());

DELAY_LOAD_HRESULT(g_hmodOLE32, OLE32.DLL, GetClassFile,
    (LPCOLESTR szFilename, CLSID FAR* pclsid),
    (szFilename, pclsid));

DELAY_LOAD_HRESULT(g_hmodOLE32, OLE32.DLL, CreateBindCtx,
    (DWORD reserved, LPBC FAR* ppbc),
    (reserved, ppbc));
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\filemru.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    filemru.cpp

Abstract:

    This module contains the functions for implementing file mru
    in file open and file save dialog boxes

Revision History:
    01/22/98                arulk                   created
 
--*/


#define MAX_MRU   10
BOOL  LoadMRU(LPTSTR szFilter, HWND hwndCombo, int nMax);
BOOL  AddToMRU(LPOPENFILENAME lpOFN);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\dlgs.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    dlgs.c

Abstract:

    This module contains the common functions for the Win32 common dialogs.

Revision History:

--*/



//
//  Include Files.
//

#include "comdlg32.h"




//
//  Global Variables.
//

extern BOOL bInitializing;

extern DWORD g_tlsiExtError;
extern CRITICAL_SECTION g_csExtError;




//
//  Function Prototypes.
//

LONG
RgbInvertRgb(
    LONG rgbOld);





////////////////////////////////////////////////////////////////////////////
//
//  HourGlass
//
//  Turn hourglass on or off.
//
//  bOn - specifies ON or OFF
//
////////////////////////////////////////////////////////////////////////////

VOID HourGlass(
    BOOL bOn)
{
    //
    //  Change cursor to hourglass.
    //
    if (!bInitializing)
    {
        if (!bMouse)
        {
            ShowCursor(bCursorLock = bOn);
        }
        SetCursor(LoadCursor(NULL, bOn ? IDC_WAIT : IDC_ARROW));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  StoreExtendedError
//
//  Stores an extended error code for the next call to
//  CommDlgExtendedError.
//
////////////////////////////////////////////////////////////////////////////

void StoreExtendedError(
    DWORD dwError)
{
    EnterCriticalSection(&g_csExtError);

    TlsSetValue(g_tlsiExtError, (LPVOID)dwError);

    LeaveCriticalSection(&g_csExtError);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetStoredExtendedError
//
//  Retieves the stored extended error code.
//
////////////////////////////////////////////////////////////////////////////

DWORD GetStoredExtendedError(void)
{
    DWORD dwError;

    EnterCriticalSection(&g_csExtError);

    dwError = PtrToUlong(TlsGetValue(g_tlsiExtError));

    LeaveCriticalSection(&g_csExtError);

    return (dwError);
}


////////////////////////////////////////////////////////////////////////////
//
//  CommDlgExtendedError
//
//  Provides additional information about dialog failure.
//  This should be called immediately after failure.
//
//  Returns:   LO word - error code
//             HI word - error specific info
//
////////////////////////////////////////////////////////////////////////////

DWORD WINAPI CommDlgExtendedError()
{
    return (GetStoredExtendedError());
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadAlterBitmap
//
//  Loads a bitmap given its name and gives all the pixels that are
//  a certain color a new color.
//
//  Returns:   NULL - failed
//             handle to the bitmap loaded - success
//
////////////////////////////////////////////////////////////////////////////

HBITMAP WINAPI LoadAlterBitmap(
    int id,
    DWORD rgbReplace,
    DWORD rgbInstead)
{
    LPBITMAPINFOHEADER qbihInfo;
    HDC hdcScreen;
    BOOL fFound;
    HANDLE hresLoad;
    HANDLE hres;
    LPLONG qlng;
    DWORD *qlngReplace;       // points to bits that are replaced
    LPBYTE qbBits;
    HANDLE hbmp;
    LPBITMAPINFOHEADER lpBitmapInfo;
    UINT cbBitmapSize;

    hresLoad = FindResource(g_hinst, MAKEINTRESOURCE(id), RT_BITMAP);
    if (hresLoad == HNULL)
    {
        return (HNULL);
    }
    hres = LoadResource(g_hinst, hresLoad);
    if (hres == HNULL)
    {
        return (HNULL);
    }

    //
    //  Lock the bitmap data and make a copy of it for the mask and the
    //  bitmap.
    //
    cbBitmapSize = SizeofResource(g_hinst, hresLoad);
    lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hres);

    qbihInfo = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, cbBitmapSize);

    if ((lpBitmapInfo == NULL) || (qbihInfo == NULL))
    {
        return (NULL);
    }

    memcpy((TCHAR *)qbihInfo, (TCHAR *)lpBitmapInfo, cbBitmapSize);

    //
    //  Get a pointer into the color table of the bitmaps, cache the
    //  number of bits per pixel.
    //
    rgbReplace = RgbInvertRgb(rgbReplace);
    rgbInstead = RgbInvertRgb(rgbInstead);

    qlng = (LPLONG)((LPSTR)(qbihInfo) + qbihInfo->biSize);

    fFound = FALSE;
    while (!fFound)
    {
        if (*qlng == (LONG)rgbReplace)
        {
            fFound = TRUE;
            qlngReplace = (DWORD *)qlng;
            *qlng = (LONG)rgbInstead;
        }
        qlng++;
    }

    //
    //  First skip over the header structure.
    //
    qbBits = (LPBYTE)(qbihInfo + 1);

    //
    //  Skip the color table entries, if any.
    //
    qbBits += (1 << (qbihInfo->biBitCount)) * sizeof(RGBQUAD);

    //
    //  Create a color bitmap compatible with the display device.
    //
    hdcScreen = GetDC(HNULL);
    if (hdcScreen != HNULL)
    {
        hbmp = CreateDIBitmap( hdcScreen,
                               qbihInfo,
                               (LONG)CBM_INIT,
                               qbBits,
                               (LPBITMAPINFO)qbihInfo,
                               DIB_RGB_COLORS );
        ReleaseDC(HNULL, hdcScreen);
    }

    //
    //  Reset color bits to original value.
    //
    *qlngReplace = (LONG)rgbReplace;

    LocalFree(qbihInfo);
    return (hbmp);
}


////////////////////////////////////////////////////////////////////////////
//
//  RgbInvertRgb
//
//  Reverses the byte order of the RGB value (for file format).
//
//  Returns the new color value (RGB to BGR).
//
////////////////////////////////////////////////////////////////////////////

LONG RgbInvertRgb(
    LONG rgbOld)
{
    LONG lRet;
    BYTE R, G, B;

    R = GetRValue(rgbOld);
    G = GetGValue(rgbOld);
    B = GetBValue(rgbOld);

    lRet = (LONG)RGB(B, G, R);

    return (lRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  HbmpLoadBmp
//
//  Loads in a bitmap.
//
//  Returns:   Bitmap handle - success
//             HNULL         - failure
//
////////////////////////////////////////////////////////////////////////////

#if 0
HBITMAP HbmpLoadBmp(
    WORD bmp)
{
    HBITMAP hbmp;
    CHAR szBitmap[cbResNameMax];

    hbmp = HNULL;
    if (LoadString(g_hinst, bmp, (LPTSTR)szBitmap, cbResNameMax - 1))
    {
        hbmp = LoadBitmap(g_hinst, (LPCTSTR)szBitmap);
    }
    return (hbmp);
}
#endif


////////////////////////////////////////////////////////////////////////////
//
//  AddNetButton
//
//  Attempts to add a network button to the open, save, or print dialogs.
//
//  hDlg           - dialog to add button to
//  hInstance      - instance handle for dlg
//  dyBottomMargin - DUs to bottom edge
//
////////////////////////////////////////////////////////////////////////////

#define xDUsToPels(DUs, lDlgBaseUnits) \
   (int)(((DUs) * (int)LOWORD((lDlgBaseUnits))) / 4)

#define yDUsToPels(DUs, lDlgBaseUnits) \
   (int)(((DUs) * (int)HIWORD((lDlgBaseUnits))) / 8)

VOID AddNetButton(
    HWND hDlg,
    HANDLE hInstance,
    int dyBottomMargin,
    BOOL bAddAccel,
    BOOL bTryLowerRight,
    BOOL bTryLowerLeft)
{
    LONG lDlgBaseUnits;
    RECT rcDlg, rcCtrl, rcTmp;
    LONG xButton, yButton;
    LONG dxButton, dyButton;
    LONG dxDlgFrame, dyDlgFrame;
    LONG yDlgHeight, xDlgWidth;
    HWND hwndButton, hCtrl, hLastCtrl, hTmp, hSave;
    HFONT hFont;
    POINT ptTopLeft, ptTopRight, ptCenter, ptBtmLeft, ptBtmRight, ptTopLeftTmp;
    TCHAR szNetwork[MAX_PATH];

    //
    //  Make sure a network button (psh14) doesn't already exist in
    //  the dialog.
    //
    if (GetDlgItem(hDlg, psh14))
    {
        return;
    }

    //
    //  Get dialog coordinate info.
    //
    lDlgBaseUnits = GetDialogBaseUnits();

    dxDlgFrame = GetSystemMetrics(SM_CXDLGFRAME);
    dyDlgFrame = GetSystemMetrics(SM_CYDLGFRAME);

    GetWindowRect(hDlg, &rcDlg);

    rcDlg.left += dxDlgFrame;
    rcDlg.right -= dxDlgFrame;
    rcDlg.top += dyDlgFrame + GetSystemMetrics(SM_CYCAPTION);
    rcDlg.bottom -= dyDlgFrame;

    //
    //  Get the OK button.
    //
    if (!(hCtrl = GetDlgItem(hDlg, IDOK)))
    {
        return;
    }

    GetWindowRect(hCtrl, &rcCtrl);

    ptTopLeft.x = rcCtrl.left;
    ptTopLeft.y = rcCtrl.top;

    //
    //  Make sure the OK button isn't outside the dialog.
    //
    if (!PtInRect(&rcDlg, ptTopLeft))
    {
        //
        //  Try the CANCEL button.
        //
        if (!(hCtrl = GetDlgItem(hDlg, IDCANCEL)))
        {
           //
           //  Both OK and CANCEL do not exist, so return.
           //
           return;
        }

        //
        //  The check for the Cancel button outside the dialog is handled
        //  below.
        //
        GetWindowRect(hCtrl, &rcCtrl);
    }
    hSave = hCtrl;

#ifdef UNICODE
    //
    //  Get the full hDlg value if coming from WOW.
    //
    if (IS_INTRESOURCE(hDlg))
    {
        HWND hNewDlg;

        if (hDlg == (HWND)LOWORD(hNewDlg = GetParent(hCtrl)))
        {
            hDlg = hNewDlg;
        }
    }
#endif

    //
    //  Save the coordinate info of the button.
    //
    dxButton = rcCtrl.right - rcCtrl.left;
    dyButton = rcCtrl.bottom - rcCtrl.top;

    xButton = rcCtrl.left;
    yButton = rcCtrl.bottom + yDUsToPels(4, lDlgBaseUnits);

    yDlgHeight = rcDlg.bottom - yDUsToPels(dyBottomMargin, lDlgBaseUnits);

    //
    //  Try to insert the network button in the lower right corner
    //  of dialog box.
    //
    if (bTryLowerRight && (hTmp = GetDlgItem(hDlg, cmb2)))
    {
        //
        //  See if the network button can be inserted in the
        //  lower right corner of the dialog box.
        //
        hLastCtrl = hCtrl;
        GetWindowRect(hTmp, &rcTmp);
        yButton = rcTmp.top;

        //
        //  Set the coordinates of the new button.
        //
        ptTopLeft.x = ptBtmLeft.x = xButton;
        ptTopLeft.y = ptTopRight.y = yButton;
        ptTopRight.x = ptBtmRight.x = xButton + dxButton;
        ptBtmLeft.y = ptBtmRight.y = yButton + dyButton;
        ptCenter.x = xButton + dxButton / 2;
        ptCenter.y = yButton + dyButton / 2;
        ScreenToClient(hDlg, (LPPOINT)&ptTopLeft);
        ScreenToClient(hDlg, (LPPOINT)&ptBtmLeft);
        ScreenToClient(hDlg, (LPPOINT)&ptTopRight);
        ScreenToClient(hDlg, (LPPOINT)&ptBtmRight);
        ScreenToClient(hDlg, (LPPOINT)&ptCenter);

        //
        //  See if the new button is over any other buttons.
        //
        if (((yButton + dyButton) < yDlgHeight) &&
            ((ChildWindowFromPoint(hDlg, ptTopLeft)  == hDlg) &&
             (ChildWindowFromPoint(hDlg, ptTopRight) == hDlg) &&
             (ChildWindowFromPoint(hDlg, ptCenter)   == hDlg) &&
             (ChildWindowFromPoint(hDlg, ptBtmLeft)  == hDlg) &&
             (ChildWindowFromPoint(hDlg, ptBtmRight) == hDlg)))
        {
            //
            //  If the last control is the OK button and there is a
            //  HELP button, then the last control should be the
            //  HELP button.
            //
            if ((hLastCtrl == GetDlgItem(hDlg, IDOK)) &&
                (hCtrl = GetDlgItem(hDlg, pshHelp)))
            {
                GetWindowRect(hCtrl, &rcCtrl);
                ptTopLeftTmp.x = rcCtrl.left;
                ptTopLeftTmp.y = rcCtrl.top;

                //
                //  Make sure the HELP button isn't outside the dialog
                //  and then set the last control to be the HELP button.
                //
                if (PtInRect(&rcDlg, ptTopLeftTmp))
                {
                    hLastCtrl = hCtrl;
                }
            }

            //
            //  If the last control is still the OK button and there is a
            //  CANCEL button, then the last control should be the
            //  CANCEL button.
            //
            if ((hLastCtrl == GetDlgItem(hDlg, IDOK)) &&
                (hCtrl = GetDlgItem(hDlg, IDCANCEL)))
            {
                GetWindowRect(hCtrl, &rcCtrl);
                ptTopLeftTmp.x = rcCtrl.left;
                ptTopLeftTmp.y = rcCtrl.top;

                //
                //  Make sure the CANCEL button isn't outside the dialog
                //  and then set the last control to be the CANCEL button.
                //
                if (PtInRect(&rcDlg, ptTopLeftTmp))
                {
                    hLastCtrl = hCtrl;
                }
            }

            goto FoundPlace;
        }

        //
        //  Reset yButton.
        //
        yButton = rcCtrl.bottom + yDUsToPels(4, lDlgBaseUnits);
    }

    //
    //  Try to insert the network button vertically below the other
    //  control buttons.
    //
    while (hCtrl != NULL)
    {
        //
        //  Move vertically down and see if there is space.
        //
        hLastCtrl = hCtrl;
        GetWindowRect(hCtrl, &rcCtrl);
        yButton = rcCtrl.bottom + yDUsToPels(4, lDlgBaseUnits);

        //
        //  Make sure there is still room in the dialog.
        //
        if ((yButton + dyButton) > yDlgHeight)
        {
            //
            //  No space.
            //
            break;
        }

        //
        //  Set the coordinates of the new button.
        //
        ptTopLeft.x = ptBtmLeft.x = xButton;
        ptTopLeft.y = ptTopRight.y = yButton;
        ptTopRight.x = ptBtmRight.x = xButton + dxButton;
        ptBtmLeft.y = ptBtmRight.y = yButton + dyButton;
        ptCenter.x = xButton + dxButton / 2;
        ptCenter.y = yButton + dyButton / 2;
        ScreenToClient(hDlg, (LPPOINT)&ptTopLeft);
        ScreenToClient(hDlg, (LPPOINT)&ptBtmLeft);
        ScreenToClient(hDlg, (LPPOINT)&ptTopRight);
        ScreenToClient(hDlg, (LPPOINT)&ptBtmRight);
        ScreenToClient(hDlg, (LPPOINT)&ptCenter);

        //
        //  See if the new button is over any other buttons.
        //
        if (((hCtrl = ChildWindowFromPoint(hDlg, ptTopLeft))  == hDlg) &&
            ((hCtrl = ChildWindowFromPoint(hDlg, ptTopRight)) == hDlg) &&
            ((hCtrl = ChildWindowFromPoint(hDlg, ptCenter))   == hDlg) &&
            ((hCtrl = ChildWindowFromPoint(hDlg, ptBtmLeft))  == hDlg) &&
            ((hCtrl = ChildWindowFromPoint(hDlg, ptBtmRight)) == hDlg))
        {
            goto FoundPlace;
        }
    }

    //
    //  Try to insert the network button in the lower left corner of
    //  the dialog box.
    //
    if (bTryLowerLeft)
    {
        //
        //  Get the width of the dialog to make sure the button doesn't
        //  go off the side of the dialog.
        //
        xDlgWidth = rcDlg.right - xDUsToPels(FILE_RIGHT_MARGIN, lDlgBaseUnits);

        //
        //  Use the OK or CANCEL button saved earlier to get the size of
        //  the buttons.
        //
        hCtrl = hSave;

        //
        //  Start at the far left of the dialog.
        //
        //  NOTE: We know that hCtrl is not NULL at this point because
        //        otherwise we would have returned earlier.
        //
        //        The print dialogs have a left margin of 8.
        //
        GetWindowRect(hCtrl, &rcCtrl);
        xButton = rcDlg.left + xDUsToPels(FILE_LEFT_MARGIN + 3, lDlgBaseUnits);
        yButton = rcCtrl.top;

        while (1)
        {
            hLastCtrl = hCtrl;

            //
            //  Make sure there is still room in the dialog.
            //
            if ((xButton + dxButton) > xDlgWidth)
            {
                //
                //  No space.
                //
                break;
            }

            //
            //  Set the coordinates of the new button.
            //
            ptTopLeft.x = ptBtmLeft.x = xButton;
            ptTopLeft.y = ptTopRight.y = yButton;
            ptTopRight.x = ptBtmRight.x = xButton + dxButton;
            ptBtmLeft.y = ptBtmRight.y = yButton + dyButton;
            ptCenter.x = xButton + dxButton / 2;
            ptCenter.y = yButton + dyButton / 2;
            ScreenToClient(hDlg, (LPPOINT)&ptTopLeft);
            ScreenToClient(hDlg, (LPPOINT)&ptBtmLeft);
            ScreenToClient(hDlg, (LPPOINT)&ptTopRight);
            ScreenToClient(hDlg, (LPPOINT)&ptBtmRight);
            ScreenToClient(hDlg, (LPPOINT)&ptCenter);

            //
            //  See if the new button is over any other buttons.
            //
            if ( ( ((hCtrl = ChildWindowFromPoint(hDlg, ptTopLeft))  == hDlg) &&
                   ((hCtrl = ChildWindowFromPoint(hDlg, ptTopRight)) == hDlg) &&
                   ((hCtrl = ChildWindowFromPoint(hDlg, ptCenter))   == hDlg) &&
                   ((hCtrl = ChildWindowFromPoint(hDlg, ptBtmLeft))  == hDlg) &&
                   ((hCtrl = ChildWindowFromPoint(hDlg, ptBtmRight)) == hDlg) ) )
            {
                //
                //  If the last control is the OK button and there is a
                //  HELP button, then the last control should be the
                //  HELP button.
                //
                if ((hLastCtrl == GetDlgItem(hDlg, IDOK)) &&
                    (hCtrl = GetDlgItem(hDlg, pshHelp)))
                {
                    GetWindowRect(hCtrl, &rcCtrl);
                    ptTopLeftTmp.x = rcCtrl.left;
                    ptTopLeftTmp.y = rcCtrl.top;

                    //
                    //  Make sure the HELP button isn't outside the dialog
                    //  and then set the last control to be the HELP button.
                    //
                    if (PtInRect(&rcDlg, ptTopLeftTmp))
                    {
                        hLastCtrl = hCtrl;
                    }
                }

                //
                //  If the last control is still the OK button and there is a
                //  CANCEL button, then the last control should be the
                //  CANCEL button.
                //
                if ((hLastCtrl == GetDlgItem(hDlg, IDOK)) &&
                    (hCtrl = GetDlgItem(hDlg, IDCANCEL)))
                {
                    GetWindowRect(hCtrl, &rcCtrl);
                    ptTopLeftTmp.x = rcCtrl.left;
                    ptTopLeftTmp.y = rcCtrl.top;

                    //
                    //  Make sure the CANCEL button isn't outside the dialog
                    //  and then set the last control to be the CANCEL button.
                    //
                    if (PtInRect(&rcDlg, ptTopLeftTmp))
                    {
                        hLastCtrl = hCtrl;
                    }
                }

                goto FoundPlace;
            }

            //
            //  Make sure we encountered another control and that we
            //  didn't go off the end of the dialog.
            //
            if (!hCtrl)
            {
                break;
            }

            //
            //  Move over to the right and see if there is space.
            //
            GetWindowRect(hCtrl, &rcCtrl);
            xButton = rcCtrl.right + xDUsToPels(4, lDlgBaseUnits);
        }
    }

    return;

FoundPlace:

    xButton = ptTopLeft.x;
    yButton = ptTopLeft.y;

#ifndef UNICODE
    //
    //  For non-localized apps that don't include the network button as part
    //  of their template, don't add a Far East one because the characters
    //  will not be displayed correctly.
    //
    {
        #define NetworkButtonText        TEXT("Network...")
        #define NetworkButtonTextAccel   TEXT("Net&work...")

        CPINFO cpinfo;

        if ((GetCPInfo(CP_ACP, &cpinfo)) && (cpinfo.MaxCharSize > 1))
        {
            TEXTMETRIC tm;
            HFONT hPrevFont;
            HWND hIDOK = GetDlgItem(hDlg, IDOK);
            HDC hDC = GetDC(hIDOK);

            hFont = (HFONT)SendMessage(hIDOK, WM_GETFONT, 0, 0L);
            if (hFont != NULL)
            {
                hPrevFont = SelectObject(hDC, hFont);
                GetTextMetrics(hDC, &tm);
                SelectObject(hDC, hPrevFont);
                ReleaseDC(hIDOK, hDC);

                if (tm.tmCharSet == ANSI_CHARSET)
                {
                    lstrcpy( szNetwork,
                             bAddAccel ? NetworkButtonTextAccel : NetworkButtonText );
                    goto CreateNetworkButton;
                }
            }
        }
    }
#endif

    if (LoadString( g_hinst,
                    (bAddAccel ? iszNetworkButtonTextAccel : iszNetworkButtonText),
                    (LPTSTR)szNetwork,
                    MAX_PATH ))
    {
#ifndef UNICODE
CreateNetworkButton:
#endif
        hwndButton = CreateWindow( TEXT("button"),
                                   szNetwork,
                                   WS_VISIBLE | WS_CHILD | WS_GROUP |
                                       WS_TABSTOP | BS_PUSHBUTTON,
                                   xButton,
                                   yButton,
                                   dxButton,
                                   dyButton,
                                   hDlg,
                                   NULL,
                                   hInstance,
                                   NULL );

        if (hwndButton != NULL)
        {
            SetWindowLong(hwndButton, GWL_ID, psh14);
            SetWindowPos( hwndButton,
                          hLastCtrl,
                          0, 0, 0, 0,
                          SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE );
            hFont = (HFONT)SendDlgItemMessage(hDlg, IDOK, WM_GETFONT, 0, 0L);
            SendMessage(hwndButton, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE,0));
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  IsNetworkInstalled
//
////////////////////////////////////////////////////////////////////////////

BOOL IsNetworkInstalled()
{
    if (GetSystemMetrics(SM_NETWORK) & RNC_NETWORKS)
    {
        return (TRUE);
    }
    else
    {
        return (FALSE);
    }
}



#ifdef WINNT

////////////////////////////////////////////////////////////////////////////
//
//  Ssync_ANSI_UNICODE_Struct_For_WOW (This is exported for WOW)
//
//  For WOW support on NT only.
//
//  When a 16-bit app calls one of the comdlg API's, WOW thunks the 16-bit
//  comdlg struct passed by the app to a 32-bit ANSI struct.  Comdlg32 code
//  then thunks the 32-bit ANSI struct into a UNICODE struct.  This scheme
//  creates a problem for WOW apps because on Win3.1, the app and comdlg16
//  share the same structure.  When either updates the struct, the other is
//  aware of the change.
//
//  This function allows us to sychronize the UNICODE struct with the app's
//  16-bit struct & vice versa from WOW.
//
////////////////////////////////////////////////////////////////////////////

VOID Ssync_ANSI_UNICODE_Struct_For_WOW(
    HWND hDlg,
    BOOL fDirection,
    DWORD dwID)
{
    switch (dwID)
    {
        case ( WOW_CHOOSECOLOR ) :
        {
            Ssync_ANSI_UNICODE_CC_For_WOW(hDlg, fDirection);
            break;
        }
        case ( WOW_CHOOSEFONT ) :
        {
            Ssync_ANSI_UNICODE_CF_For_WOW(hDlg, fDirection);
            break;
        }
        case ( WOW_OPENFILENAME ) :
        {
            Ssync_ANSI_UNICODE_OFN_For_WOW(hDlg, fDirection);
            break;
        }
        case ( WOW_PRINTDLG ) :
        {
            Ssync_ANSI_UNICODE_PD_For_WOW(hDlg, fDirection);
            break;
        }

        // case not needed for FINDREPLACE
    }
}

#endif


#ifdef WX86

////////////////////////////////////////////////////////////////////////////
//
//  Wx86GetX86Callback
//
//  Creates a RISC-callable alias for a x86 hook function pointer.
//
//  lpfnHook - x86 address of hook
//
//  Returns a function pointer which can be called from RISC.
//
////////////////////////////////////////////////////////////////////////////

PVOID Wx86GetX86Callback(
    PVOID lpfnHook)
{
    if (!lpfnHook)
    {
        return (NULL);
    }

    if (!pfnAllocCallBx86)
    {
        HMODULE hMod;

        if (!Wx86CurrentTib())
        {
            //
            //  Wx86 is not running in this thread.  Assume a RISC app has
            //  passed a bad flag value and that lpfnHook is already a RISC
            //  function pointer.
            //
            return (lpfnHook);
        }

        hMod = GetModuleHandle(TEXT("wx86.dll"));
        if (hMod == NULL)
        {
            //
            //  Wx86 is running, but wx86.dll is not loaded!  This should
            //  never happen, but if it does, assume lpfnHook is already a
            //  RISC pointer.
            //
            return (lpfnHook);
        }
        pfnAllocCallBx86 = (PALLOCCALLBX86)GetProcAddress( hMod,
                                                           "AllocCallBx86" );
        if (!pfnAllocCallBx86)
        {
            //
            //  Something has gone terribly wrong!
            //
            return (lpfnHook);
        }
    }

    //
    //  Call into Wx86.dll to create a RISC-to-x86 callback which takes
    //  4 parameters and has no logging.
    //
    return (*pfnAllocCallBx86)(lpfnHook, 4, NULL, NULL);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\filemru.cpp ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    filemru.cpp

Abstract:

    This module contains the functions for implementing file mru
    in file open and file save dialog boxes

Revision History:
    01/22/98                arulk                   created
 
--*/
#include "comdlg32.h"
#include <shellapi.h>
#include <shlobj.h>
#include <shsemip.h>
#include <shellp.h>
#include <commctrl.h>
#include <ole2.h>
#include "cdids.h"

#include <coguid.h>
#include <shlguid.h>
#include <shguidp.h>
#include <oleguid.h>

#include <commdlg.h>



extern "C" TCHAR const szMRURegPath[];


HANDLE CreateMRU(LPTSTR szExt, int nMax)
{
    TCHAR szRegPath[MAX_PATH];
    MRUINFO mi =  {
        sizeof(MRUINFO),
        nMax,
        MRU_CACHEWRITE,
        HKEY_CURRENT_USER,
        szRegPath,
        NULL        // NOTE: use default string compare
    };

    //Get the Registry path for the given file type MRU
    if (szExt != NULL)
    {
        PathCombine(szRegPath, szMRURegPath, szExt);
    }
    else
    {
        PathCombine(szRegPath, szMRURegPath, TEXT("*"));
    }
    
    //Call the comctl32 mru implementation to load the MRU from
    //the registry
    return CreateMRUList(&mi);
}

BOOL GetMRUEntry(HANDLE hMRU, int iIndex, LPTSTR lpString, UINT cbSize)
{
     //Check for valid parameters
     if(!lpString || !cbSize || !hMRU)
     { 
         return FALSE;
     }
     
    //Check for valid index
    if (iIndex < 0 || iIndex > EnumMRUList(hMRU, -1, NULL, 0))
    {
        return FALSE;
    }

    if ((EnumMRUList(hMRU, iIndex, lpString, cbSize) > 0 ))
    {
        return TRUE;
    }
    return FALSE;
}


BOOL  LoadMRU(LPTSTR szFilter, HWND hwndCombo, int nMax)
{   
    BOOL fRet = TRUE;
    int nFileTypes = 0;   
    LPTSTR szTemp = NULL;
    int j, i;
    LPTSTR lpNext = NULL;
    
    
    //Check if valid filter string is passed
    if (!szFilter || !szFilter[0] || nMax <= 0)
    {
        return FALSE;
    }

    //Copy the filter string in temp buffer for manipulation
    Str_SetPtr(&szTemp, szFilter);

    //Convert the filter string of form *.c;*.cpp;*.h into form
    // *.c\0*.cpp\0*.h\0. Also count the file types
    

    HDPA hdpaMRU = DPA_Create(4);

    if (!hdpaMRU)
        goto CleanUp;

    lpNext = szTemp;
    i = 0;    
    HANDLE hMRU;

    while (1) {
        LPTSTR lpSemi = StrChr(lpNext, CHAR_SEMICOLON);
        if (lpSemi) {
            *lpSemi = CHAR_NULL;

            hMRU = CreateMRU (PathGetExtension(lpNext, NULL, 0), nMax);

            if (!hMRU)
                goto CleanUp;

            DPA_SetPtr(hdpaMRU, nFileTypes,  (void *)hMRU);

            nFileTypes++;
            lpNext = lpSemi + 1;    
        } else
            break;
    }

    //Add the final file type
    hMRU = CreateMRU (PathGetExtension(lpNext, NULL, 0), nMax);

    if (!hMRU)
        goto CleanUp;

    DPA_SetPtr(hdpaMRU,nFileTypes, (void *)hMRU);
    
    nFileTypes++;

    //First reset the hwndCombo
    SendMessage(hwndCombo, CB_RESETCONTENT, (WPARAM)0L, (LPARAM)0L);


    //Now load the hwndcombo with file list from MRU.
    //We use a kind of round robin algorithm for filling
    //the mru. We start with first MRU and try to fill the combobox
    //with one string from each mru. Until we have filled the required
    //strings or we have exhausted all strings in the mrus

    j = 0;
    while ( nMax > 0 )
    {
        TCHAR szFile[MAX_PATH];
        //Variable used for checking whether we are able to load atlease one string
        //during the loop
        BOOL fCouldLoadAtleastOne = FALSE;

        //Set the comboboxex item values
        COMBOBOXEXITEM  cbexItem;
        memset(&cbexItem,0,sizeof(cbexItem));
        cbexItem.mask = CBEIF_TEXT; //This combobox displays only text
        cbexItem.iItem = -1; //Always insert the item at the end
        cbexItem.pszText = szFile; //This buffer contains the string
        cbexItem.cchTextMax = ARRAYSIZE(szFile); //Size of the buffer


        for (i= 0; i < nFileTypes; i++)
        {

            BOOL fSuccess;
            fSuccess = GetMRUEntry((HANDLE)DPA_FastGetPtr(hdpaMRU, i), j, szFile, ARRAYSIZE(szFile));

            if (fSuccess)
            {
                SendMessage(hwndCombo, CBEM_INSERTITEM, (WPARAM)0, (LPARAM)(LPVOID)&cbexItem);
                nMax--;
                fCouldLoadAtleastOne =TRUE;
            }
        }

        //Check for possible infinite loop
        if(!fCouldLoadAtleastOne)
        {
            //We couldn't load string from any of the MRU's so there's no point
            //in continuing this loop further. This is the max number of strings 
            // we can load for this user, for this filter type.
            break;
        }

        //Increment the index to be fetched from each MRU
        j++;
    }



CleanUp:

    //Clean up the function
    Str_SetPtr(&szTemp, NULL);

    if (hdpaMRU)
    {
        //Free each of the MRU list in the array
        for (i=0; i < nFileTypes; i++)
        {
            HANDLE hMRU = (HANDLE)DPA_FastGetPtr(hdpaMRU, i);
            if (hMRU)
                FreeMRUList(hMRU);
        }
        
        //Free the array
        DPA_Destroy(hdpaMRU);
    }
    return fRet;
}

//This function adds the selected file into the MRU of the appropriate file MRU's
//This functions also takes care of MultiFile Select case in which the file selected
//will  c:\winnt\file1.c\0file2.c\0file3.c\0. Refer GetOpenFileName documentation for 
// how the multifile is returned.

BOOL AddToMRU(LPOPENFILENAME lpOFN)
{
    
    TCHAR szDir[MAX_PATH];
    TCHAR szFile[MAX_PATH];
    LPTSTR  lpFile;
    LPTSTR  lpExt;
    BOOL fAddToStar =  TRUE;
    HANDLE hMRUStar =  CreateMRU(szStar, 10);   //File MRU For *.* file extension

    //Copy the Directory for the selected file
    lstrcpyn(szDir, lpOFN->lpstrFile, lpOFN->nFileOffset);

    //point to the first file
    lpFile = lpOFN->lpstrFile + lpOFN->nFileOffset;

    do
    {
        // ISSUE: perf, if there are multiple files  of the same extension type,
        // don't keep re-creating the mru.
        lpExt = PathGetExtension(lpFile, NULL,0);
        HANDLE hMRU = CreateMRU(lpExt, 10);
        if (hMRU)
        {
            PathCombine(szFile, szDir, lpFile);
            AddMRUString(hMRU, szFile);
            if((lstrcmpi(lpExt, szStar)) && hMRUStar)
            {
                //Add to the *.* file mru also
                AddMRUString(hMRUStar, szFile);
            }

            FreeMRUList(hMRU);
        }
        lpFile = lpFile + lstrlen(lpFile) + 1;
    } while (((lpOFN->Flags & OFN_ALLOWMULTISELECT)) && (*lpFile != CHAR_NULL));

    //Free the * file mru
    if (hMRUStar)
    {
        FreeMRUList(hMRUStar);
    }
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\find.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    find.h

Abstract:

    This module contains the header information for the Win32 find dialog.

Revision History:

--*/



//
//  Include Files.
//

#include <help.h>




//
//  Constant Declarations.
//

//
//  Length of "Close" string in chars.
//
#define CCHCLOSE        9

//
//  Dialog Box PROPERTY slots defined.
//
//  Note: If each app does indeed have a copy of the dll's global
//        variable space, then there is no reason to stick properties
//        onto the window like this.
//
#define FINDREPLACEPROP (LPCTSTR) 0xA000L

//
//  Overload Dialog Type.
//
#define DLGT_FIND       0x0
#define DLGT_REPLACE    0x1

#define cbFindMax       1024




//
//  Typedef Declarations.
//

typedef struct {
   UINT           ApiType;
   UINT           DlgType;
   LPFINDREPLACE  pFR;
} FINDREPLACEINFO;

typedef FINDREPLACEINFO *PFINDREPLACEINFO;




//
//  Global Variables.
//

static UINT wFRMessage;
static UINT wHelpMessage;
static TCHAR szClose [CCHCLOSE];

LPFRHOOKPROC glpfnFindHook = 0;




//
//  Context Help IDs.
//

const static DWORD aFindReplaceHelpIDs[] =       // Context Help IDs
{
    edt1,    IDH_FIND_SEARCHTEXT,
    edt2,    IDH_REPLACE_REPLACEWITH,
    chx1,    IDH_FIND_WHOLE,
    chx2,    IDH_FIND_CASE,
    IDOK,    IDH_FIND_NEXT_BUTTON,
    psh1,    IDH_REPLACE_REPLACE,
    psh2,    IDH_REPLACE_REPLACE_ALL,
    pshHelp, IDH_HELP,
    grp1,    IDH_FIND_DIRECTION,
    rad1,    IDH_FIND_DIRECTION,
    rad2,    IDH_FIND_DIRECTION,

    0, 0
};




//
//  Function Prototypes.
//

HWND
CreateFindReplaceDlg(
    LPFINDREPLACE pFR,
    UINT DlgType,
    UINT ApiType);

BOOL
SetupOK(
   LPFINDREPLACE pFR,
   UINT DlgType,
   UINT ApiType);

HANDLE
GetDlgTemplate(
    LPFINDREPLACE pFR,
    UINT DlgType,
    UINT ApiType);

BOOL_PTR CALLBACK
FindReplaceDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam);

VOID
EndDlgSession(
   HWND hDlg,
   LPFINDREPLACE pFR);

VOID
InitControlsWithFlags(
   HWND hDlg,
   LPFINDREPLACE pFR,
   UINT DlgType,
   UINT ApiType);

VOID
UpdateTextAndFlags(
    HWND hDlg,
    LPFINDREPLACE pFR,
    DWORD dwActionFlag,
    UINT DlgType,
    UINT ApiType);

LRESULT
NotifyUpdateTextAndFlags(
    LPFINDREPLACE pFR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\filenew.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    filenew.h

Abstract:

    This module contains the header information for the new Win32 fileopen
    dialogs.

Revision History:

--*/



#undef StrCpy
#undef StrCat



#include "tlog.h"

////////////////////////////////////////////////////////////////////////////
//
//  WAIT_CURSOR class
//
////////////////////////////////////////////////////////////////////////////

class WAIT_CURSOR
{
private:
    HCURSOR _hcurOld;

public:
    WAIT_CURSOR()
    {
        _hcurOld = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));
    }

    ~WAIT_CURSOR()
    {
        ::SetCursor(_hcurOld);
    }
};


////////////////////////////////////////////////////////////////////////////
//
//  TEMPMEM class
//
////////////////////////////////////////////////////////////////////////////

class TEMPMEM
{
public:
    TEMPMEM(UINT cb)
    {
        m_uSize = cb;
        m_pMem = cb ? LocalAlloc(LPTR, cb) : NULL;
    }

    ~TEMPMEM()
    {
        if (m_pMem)
        {
            LocalFree(m_pMem);
        }
    }

    operator LPBYTE() const
    {
        return ((LPBYTE)m_pMem);
    }

    BOOL Resize(UINT cb);

private:
    LPVOID m_pMem;

protected:
    UINT m_uSize;
};


////////////////////////////////////////////////////////////////////////////
//
//  TEMPSTR class
//
////////////////////////////////////////////////////////////////////////////

class TEMPSTR : public TEMPMEM
{
public:
    TEMPSTR(UINT cc = 0) : TEMPMEM(cc * sizeof(TCHAR))
    {
    }

    operator LPTSTR() const
    {
        return ((LPTSTR)(LPBYTE) * (TEMPMEM *)this);
    }

    BOOL StrCpy(LPCTSTR pszText);
    BOOL StrCat(LPCTSTR pszText);
    BOOL StrSize(UINT cb)
    {
        return (TEMPMEM::Resize(cb * sizeof(TCHAR)));
    }
};


////////////////////////////////////////////////////////////////////////////
//
//  MYLISTBOXITEM class
//
//  One object of this class exists for each item in the location dropdown.
//
//  Data members:
//    psfSub   - instance of IShellFolder bound to this container
//    pidlThis - IDL of this container, relative to its parent
//    pidlFull - IDL of this container, relative to the desktop
//    cIndent  - indent level (0-based)
//    dwFlags  -
//        MLBI_PERMANENT - item is an "information source" and should
//                         always remain
//    dwAttrs  - attributes of this container as reported by GetAttributesOf()
//    iImage, iSelectedImage - indices into the system image list for this
//                             object
//
//  Member functions:
//    ShouldInclude() - returns whether item belongs in the location dropdown
//    IsShared() - returns whether an item is shared or not
//    SwitchCurrentDirectory() - changes the Win32 current directory to the
//                               directory indicated by this item
//
////////////////////////////////////////////////////////////////////////////

class MYLISTBOXITEM
{
public:
    IShellFolder *psfSub;
    IShellFolder *psfParent;
    LPITEMIDLIST pidlThis;
    LPITEMIDLIST pidlFull;
    DWORD cIndent;
    DWORD dwFlags;
    DWORD dwAttrs;
    int iImage;
    int iSelectedImage;

    MYLISTBOXITEM();

    ~MYLISTBOXITEM();

    BOOL Init( MYLISTBOXITEM *pParentItem,
               IShellFolder *psf,
               LPCITEMIDLIST pidl,
               DWORD c,
               DWORD f);

    inline BOOL ShouldInclude()
    {
        return (dwAttrs & (SFGAO_FILESYSANCESTOR | SFGAO_FILESYSTEM));
    }

    inline BOOL IsShared()
    {
        return (dwAttrs & SFGAO_SHARE);
    }

    void SwitchCurrentDirectory(ICurrentWorkingDirectory * pcwd);

    IShellFolder* GetShellFolder();
};


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser class
//
////////////////////////////////////////////////////////////////////////////

typedef BOOL (*EIOCALLBACK)(class CFileOpenBrowser*that, LPCITEMIDLIST pidl, LPARAM lParam);

typedef enum
{
    ECODE_S_OK     = 0,
    ECODE_BADDRIVE = 1,
    ECODE_BADPATH  = 2,
} ECODE;

typedef enum
{
    OKBUTTON_NONE     = 0x0000,
    OKBUTTON_NODEFEXT = 0x0001,
    OKBUTTON_QUOTED   = 0x0002,
} OKBUTTON_FLAGS;
typedef UINT OKBUTTONFLAGS;

typedef struct _SHTCUTINFO
{
    BOOL            fReSolve;           //[IN]      Should we resolve the shortcut
    DWORD           dwAttr;             //[IN/OUT]  Attributes of the target pointed by shortcut
    LPTSTR          pszLinkFile;        //[OUT]     Target file name
    UINT            cchFile;            //[IN]      size of buffer pointed to by pszLinkFile
    LPITEMIDLIST *  ppidl;               //[OUT]     pidl of the  target pointed to by shortcut
}SHTCUTINFO, *PSHTCUTINFO;


class CFileOpenBrowser : public IShellBrowser, public ICommDlgBrowser2
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND *lphwnd);
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode);

    // *** IShellBrowser methods *** (same as IOleInPlaceFrame)
    STDMETHOD(InsertMenusSB) (THIS_ HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHOD(SetMenuSB) (THIS_ HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHOD(RemoveMenusSB) (THIS_ HMENU hmenuShared);
    STDMETHOD(SetStatusTextSB) (THIS_ LPCOLESTR lpszStatusText);
    STDMETHOD(EnableModelessSB) (THIS_ BOOL fEnable);
    STDMETHOD(TranslateAcceleratorSB) (THIS_ LPMSG lpmsg, WORD wID);

    // *** IShellBrowser methods ***
    STDMETHOD(BrowseObject)(THIS_ LPCITEMIDLIST pidl, UINT wFlags);
    STDMETHOD(GetViewStateStream)(THIS_ DWORD grfMode, LPSTREAM *pStrm);
    STDMETHOD(GetControlWindow)(THIS_ UINT id, HWND *lphwnd);
    STDMETHOD(SendControlMsg)(THIS_ UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret);
    STDMETHOD(QueryActiveShellView)(THIS_ struct IShellView **ppshv);
    STDMETHOD(OnViewWindowActive)(THIS_ struct IShellView *pshv);
    STDMETHOD(SetToolbarItems)(THIS_ LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags);

    // *** ICommDlgBrowser2 methods ***
    STDMETHOD(OnDefaultCommand) (THIS_ struct IShellView *ppshv);
    STDMETHOD(OnStateChange) (THIS_ struct IShellView *ppshv, ULONG uChange);
    STDMETHOD(IncludeObject) (THIS_ struct IShellView *ppshv, LPCITEMIDLIST lpItem);
    STDMETHOD(Notify) (THIS_ struct IShellView *ppshv, DWORD dwNotifyType);
    STDMETHOD(GetDefaultMenuText) (THIS_ struct IShellView *ppshv, WCHAR *pszText, INT cchMax);
    STDMETHOD(GetViewFlags)(THIS_ DWORD *pdwFlags);


    // *** Our own methods ***
    CFileOpenBrowser(HWND hDlg, BOOL fIsSaveAs);
    ~CFileOpenBrowser();
    HRESULT SwitchView(struct IShellFolder *psfNew, LPCITEMIDLIST pidlNew, FOLDERSETTINGS *pfs);
    void OnDblClick(BOOL bFromOKButton);
    LRESULT OnNotify(LPNMHDR lpnmhdr);
    void ViewCommand(UINT uIndex);
    void PaintDriveLine(DRAWITEMSTRUCT *lpdis);
    void GetFullPath(LPTSTR pszBuf);
    BOOL OnSelChange(int iItem = -1, BOOL bForceUpdate = FALSE);
    void OnDotDot();
    void RefreshFilter(HWND hwndFilter);
    BOOL JumpToPath(LPCTSTR pszDirectory, BOOL bTranslate = FALSE);
    BOOL JumpToIDList(LPCITEMIDLIST pidlNew, BOOL bTranslate = FALSE, BOOL bAddToNavStack = TRUE);
    BOOL SetDirRetry(LPTSTR pszDir, BOOL bNoValidate = FALSE);
    BOOL MultiSelectOKButton(LPCTSTR pszFiles, OKBUTTONFLAGS Flags);
    BOOL OKButtonPressed(LPCTSTR pszFile, OKBUTTONFLAGS Flags);
    UINT GetDirectoryFromLB(LPTSTR szBuffer, int *pichRoot);
    void SetCurrentFilter(LPCTSTR pszFilter, OKBUTTONFLAGS Flags = OKBUTTON_QUOTED);
    UINT GetFullEditName(LPTSTR pszBuf, UINT cLen, TEMPSTR *pTempStr = NULL, BOOL *pbNoDefExt = NULL);
    void ProcessEdit();
    LRESULT OnCommandMessage(WPARAM wParam, LPARAM lParam);
    BOOL OnCDMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    void RemoveOldPath(int *piNewSel);
    BOOL LinkMatchSpec(LPCITEMIDLIST pidl, LPCTSTR szSpec);
    BOOL GetLinkStatus(LPCITEMIDLIST pidl,PSHTCUTINFO pinfo);
    HRESULT ResolveLink(LPCITEMIDLIST pidl, PSHTCUTINFO pinfo, IShellFolder *psf = NULL);
    void SelFocusChange(BOOL bSelChange);
    void SelRename(void);
    void SetSaveButton(UINT idSaveButton);
    void RealSetSaveButton(UINT idSaveButton);
    void SetEditFile(LPTSTR pszFile, BOOL bShowExt, BOOL bSaveNullExt = TRUE);
    BOOL EnumItemObjects(UINT uItem, EIOCALLBACK pfnCallBack, LPARAM lParam);
    BOOL IsKnownExtension(LPCTSTR pszExtension);
    UINT FindNameInView(LPTSTR pszFile, OKBUTTONFLAGS Flags, LPTSTR pszPathName,
                        int nFileOffset, int nExtOffset, int *pnErrCode,
                        BOOL bTryAsDir = TRUE);
    void UpdateLevel(HWND hwndLB, int iInsert, MYLISTBOXITEM *pParentItem);
    void InitializeDropDown(HWND hwndCtl);
    BOOL FSChange(LONG lNotification, LPCITEMIDLIST *ppidl);
    int GetNodeFromIDList(LPCITEMIDLIST pidl);
    void Timer(WPARAM wID);
    BOOL CreateHookDialog(POINT *pPtSize);
    void OnGetMinMax(LPMINMAXINFO pmmi);
    void OnSize(int, int);
    void VerifyListViewPosition(void);
    HWND CreatePlacebar(HWND hDlg);    // Creates place bar
    BOOL CreateToolbar();     // Creates the file open toolbar
    void EnableFileMRU(BOOL fEnable);  // Enable/Disable File MRU based on the flag passed
    void UpdateNavigation();           // Updates the Navigation by adding the current pidl 
                                       // to the navigation stack
    void UpdateUI();                   // Updates the back navigation button

    HRESULT _GetMonikerT(IShellFolder *psf, LPCTSTR pszIn, IMoniker **ppmk, BOOL fAllowJump);
    HRESULT _GetMoniker(IShellFolder *psf, LPCOLESTR pszIn, IMoniker **ppmk, BOOL fAllowJump);
    HRESULT _MonikerOKButtonPressed(LPCTSTR pszFile, OKBUTTONFLAGS Flags);
    BOOL    CheckForRestrictedFolder(LPTSTR lpszPath, int nFileOffset); //Checks to see whether a file can be saved in the given path.
                                                        
    void ResetDialogHeight(HWND hDlg, HWND hwndExclude, HWND hwndGrip, int nCtlsBottom);
    void ReAdjustDialog();              // if help and open as read only is hidden then this function readjusts the dialog
                                        // to reclaim the space occupied by these controls

    UINT cRef;                         // compobj refcount
    int iCurrentLocation;              // index of curr selection in location dropdown
    int iVersion;                       //  Which version of dialog are we showing
    MYLISTBOXITEM *pCurrentLocation;   // ptr to object for same
    HWND hwndDlg;                      // handle of this dialog
    HWND hSubDlg;                      // handle of the hook dialog
    IShellView *psv;                   // current view object
    IShellFolder *psfCurrent;          // current shellfolder object
    TravelLog    *ptlog;               // ptr to travel log
    HWND hwndView;                     // current view window
    HWND hwndToolbar;                  // toolbar window
    HWND hwndPlacebar;                 // places bar window
    HWND hwndLastFocus;                // ctrl that had focus before OK button
    HIMAGELIST himl;                   // system imagelist (small images)
    TEMPSTR pszHideExt;                // saved file with extension
    TEMPSTR tszDefSave;                // saved file with extension
    TEMPSTR pszDefExt;                 // writable version of the DefExt
    TEMPSTR pszObjectPath;             // full object path
    TEMPSTR pszObjectCurDir;           // object current directory (folder)
    int iWaitCount;
    UINT uRegister;
    int iComboIndex;
    int iNodeDrives;                   // location of my computer in drop down

    BOOL bEnableSizing;                // if sizing is enabled
    BOOL bUseCombo;                     // Use the edit window instead of comboxex for app compatibility
    POINT ptLastSize;                  // last known size of dialog
    POINT ptMinTrack;                  // initial size of view
    SIZE sizeView;                     // last known size of view
    HWND hwndGrip;                     // window handle of sizing grip

    LPOPENFILENAME lpOFN;              // caller's OPENFILENAME struct

    BOOL bSave : 1;                    // whether this is a save-as dialog
    BOOL fShowExtensions : 1;          // whether to show extensions
    BOOL bUseHideExt : 1;              // whether pszHideExt is valid
    BOOL bDropped : 1;
    BOOL bNoInferDefExt : 1;           // don't get defext from combo
    BOOL fSelChangedPending : 1;       // we have a selchanging message pending
    BOOL bSelIsObject : 1;             // the last selected object is an object, not a file
    BOOL bUseSizeView : 1;             // only use cached size after failure to create view...
    BOOL bAppRedrawn : 1;              // Did app call RedrawWindow? - see ResetDialogHeight
    HWND hwndTips;                     // hWnd of tooltip control for this window

    LPOPENFILEINFO lpOFI;              // info for thunking (ansi callers only)
    ICurrentWorkingDirectory * pcwd;   // Interface to AutoComplete COM Object that sets CurrentWorkingDir
    UINT _CachedViewMode;              // we force Some folders into specific views.  this caches the users choice

    // Apphack for Borland JBuilder Professional - see ResetDialogHeight
    int  topOrig;                      // original window top

    // Perf: Big structures go at the end
    TCHAR szLastFilter[MAX_PATH + 1];  // last filter chosen by the user
    TCHAR szStartDir[MAX_PATH + 1];    // saved starting directory
    TCHAR szCurDir[MAX_PATH + 1];      // currently viewed dir (if FS)
    TCHAR szBuf[MAX_PATH + 4];         // scratch buffer
    TCHAR szTipBuf[MAX_PATH + 1];      // tool tip buffer

};

#define VIEW_JUMPDESKTOP    (VIEW_NEWFOLDER + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\fileopen.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    fileopen.c

Abstract:

    This module implements the Win32 fileopen dialogs.

Revision History:

--*/



//
//  Include Files.
//

#if (_WIN32_WINNT < 0x0500)
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#include "comdlg32.h"

#include <lm.h>
#include <winnetwk.h>
#include <winnetp.h>
#include <shellapi.h>
#include <shlobj.h>
#include <commctrl.h>
#include <shsemip.h>
#include "fileopen.h"




//
//  Constant Declarations.
//

#define WNTYPE_DRIVE         1

#define MIN_DEFEXT_LEN       4

#define BMPHIOFFSET          9

//
//  hbmpDirs array index values.
//  Note:  Two copies: for standard background, and hilite.
//         Relative order is important.
//
#define OPENDIRBMP           0
#define CURDIRBMP            1
#define STDDIRBMP            2
#define FLOPPYBMP            3
#define HARDDRVBMP           4
#define CDDRVBMP             5
#define NETDRVBMP            6
#define RAMDRVBMP            7
#define REMDRVBMP            8
  //
  //  If the following disktype is passed to AddDisk, then bTmp will be
  //  set to true in the DISKINFO structure (if the disk is new).
  //
#define TMPNETDRV            9

#define MAXDOSFILENAMELEN    (12 + 1)     // 8.3 filename + 1 for NULL

//
//  Maximum number of filters on one filter line.
//
#define MAXFILTERS           36

//
//  File exclusion bits (don't show files of these types).
//
#define EXCLBITS             (FILE_ATTRIBUTE_HIDDEN)




//
//  Global Variables.
//

//
//  Caching drive list.
//
extern DWORD dwNumDisks;
extern OFN_DISKINFO gaDiskInfo[MAX_DISKS];
extern TCHAR g_szInitialCurDir[MAX_PATH];
extern BOOL g_bDisableMyDocs;
extern BOOL g_bMyDocsHidden;

DWORD dwNumDlgs = 0;

//
//  Used to update the dialogs after coming back from the net dlg button.
//
BOOL bGetNetDrivesSync = FALSE;
LPTSTR lpNetDriveSync = NULL;
BOOL bNetworkInstalled = TRUE;

//
//  Following array is used to send messages to all dialog box threads
//  that have requested enumeration updating from the worker
//  thread.  The worker thread sends off a message to each slot
//  in the array that is non-NULL.
//
HWND gahDlg[MAX_THREADS];

//
//  Strings for Filter Parsing.
//
static TCHAR szSemiColonSpaceTab[] = TEXT("; \t");
static TCHAR szSemiColonTab[] = TEXT(";\t");

//
//  For WNet apis.
//
HANDLE hLNDThread = NULL;

WNDPROC lpLBProc = NULL;
WNDPROC lpOKProc = NULL;

//
//  Drive/Dir bitmap dimensions.
//
LONG dxDirDrive = 0;
LONG dyDirDrive = 0;

//
//  ISSUE: This needs to be on a per dialog basis for multi-threaded apps.
//
WORD wNoRedraw = 0;

UINT msgWOWDIRCHANGE;
UINT msgLBCHANGEA;
UINT msgSHAREVIOLATIONA;
UINT msgFILEOKA;

UINT msgLBCHANGEW;
UINT msgSHAREVIOLATIONW;
UINT msgFILEOKW;

BOOL bInChildDlg;
BOOL bFirstTime;
BOOL bInitializing;

//
//  Used by the worker thread to enumerate network disk resources.
//
extern DWORD cbNetEnumBuf;
extern LPTSTR gpcNetEnumBuf;

//
//  List Net Drives global variables.
//
extern HANDLE hLNDEvent;
BOOL bLNDExit = FALSE;

extern CRITICAL_SECTION g_csLocal;
extern CRITICAL_SECTION g_csNetThread;

extern DWORD g_tlsiCurDlg;

extern HDC hdcMemory;
extern HBITMAP hbmpOrigMemBmp;

HBITMAP hbmpDirDrive = HNULL;




//
//  Static Declarations.
//

static WORD cLock = 0;

//
//  Not valid RGB color.
//
static DWORD rgbWindowColor = 0xFF000000;
static DWORD rgbHiliteColor = 0xFF000000;
static DWORD rgbWindowText  = 0xFF000000;
static DWORD rgbHiliteText  = 0xFF000000;
static DWORD rgbGrayText    = 0xFF000000;
static DWORD rgbDDWindow    = 0xFF000000;
static DWORD rgbDDHilite    = 0xFF000000;

TCHAR szCaption[TOOLONGLIMIT + WARNINGMSGLENGTH];
TCHAR szWarning[TOOLONGLIMIT + WARNINGMSGLENGTH];

LPOFNHOOKPROC glpfnFileHook = 0;

//
//  ISSUE:
//  Of course, in the case where there is a multi-threaded process
//  that has > 1 threads simultaneously calling GetFileOpen, the
//  following globals may cause problems.
//
static LONG dyItem = 0;
static LONG dyText;
static BOOL bChangeDir = FALSE;
static BOOL bCasePreserved;

//
//  Used for formatting long unc names (ex. banyan).
//
static DWORD dwAveCharPerLine = 10;

//
//  Hard coded id lists for My Documents and My Computer.
//
#define SHID_ROOT_REGITEM    0x1f
const IDLREGITEM c_idlMyDocs =
{
    { SIZEOF(IDREGITEM), SHID_ROOT_REGITEM, 16,
    { 0x450d8fba, 0xad25, 0x11d0, 0x98,0xa8,0x08,0x00,0x36,0x1b,0x11,0x03, },},
    0,
};
const IDLREGITEM c_idlDrives =
{
    { SIZEOF(IDREGITEM), SHID_ROOT_REGITEM, 15,
    { 0x20d04fe0, 0x3aea, 0x1069, 0xa2,0xd8,0x08,0x00,0x2b,0x30,0x30,0x9d, },},
    0,
};




//
//  Context Help IDs.
//

const static DWORD aFileOpenHelpIDs[] =
{
    edt1,        IDH_OPEN_FILENAME,
    stc3,        IDH_OPEN_FILENAME,
    lst1,        IDH_OPEN_FILENAME,
    stc1,        IDH_OPEN_PATH,
    lst2,        IDH_OPEN_PATH,
    stc2,        IDH_OPEN_FILETYPE,
    cmb1,        IDH_OPEN_FILETYPE,
    stc4,        IDH_OPEN_DRIVES,
    cmb2,        IDH_OPEN_DRIVES,
    chx1,        IDH_OPEN_READONLY,
    pshHelp,     IDH_HELP,
    psh14,       IDH_PRINT_NETWORK,

    0, 0
};

const static DWORD aFileSaveHelpIDs[] =
{
    edt1,        IDH_OPEN_FILENAME,
    stc3,        IDH_OPEN_FILENAME,
    lst1,        IDH_OPEN_FILENAME,
    stc1,        IDH_OPEN_PATH,
    lst2,        IDH_OPEN_PATH,
    stc2,        IDH_SAVE_FILETYPE,
    cmb1,        IDH_SAVE_FILETYPE,
    stc4,        IDH_OPEN_DRIVES,
    cmb2,        IDH_OPEN_DRIVES,
    chx1,        IDH_OPEN_READONLY,
    pshHelp,     IDH_HELP,
    psh14,       IDH_PRINT_NETWORK,

    0, 0
};




//
//  Function Prototypes.
//

SHORT
GetFileTitleX(
    LPTSTR lpszFile,
    LPTSTR lpszTitle,
    WORD wBufSize);

BOOL
GetFileName(
    POPENFILEINFO pOFI,
    DLGPROC qfnDlgProc);

BOOL_PTR CALLBACK
FileOpenDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam);

BOOL_PTR CALLBACK
FileSaveDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam);

BOOL
InitFileDlg(
    HWND hDlg,
    WPARAM wParam,
    POPENFILEINFO pOFI);

int
InitTlsValues(
    POPENFILEINFO pOFI);

DWORD
InitFilterBox(
    HANDLE hDlg,
    LPCTSTR lpszFilter);

VOID
InitCurrentDisk(
    HWND hDlg,
    POPENFILEINFO pOFI,
    WORD cmb);

VOID
vDeleteDirDriveBitmap();

BOOL
LoadDirDriveBitmap();

void
SetRGBValues();

BOOL
FSetUpFile();

BOOL
FileOpenCmd(
    HANDLE hDlg,
    WPARAM wParam,
    LPARAM lParam,
    POPENFILEINFO pOFI,
    BOOL bSave);

BOOL
UpdateListBoxes(
    HWND hDlg,
    POPENFILEINFO pOFI,
    LPTSTR lpszFilter,
    WORD wMask);

BOOL
OKButtonPressed(
    HWND hDlg,
    POPENFILEINFO pOFI,
    BOOL bSave);

BOOL
MultiSelectOKButton(
    HWND hDlg,
    POPENFILEINFO pOFI,
    BOOL bSave);

LRESULT WINAPI
dwOKSubclass(
    HWND hOK,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam);

LRESULT WINAPI
dwLBSubclass(
    HWND hLB,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam);

int
InvalidFileWarning(
    HWND hDlg,
    LPTSTR szFile,
    DWORD wErrCode,
    UINT mbType);

VOID
MeasureItem(
    HWND hDlg,
    LPMEASUREITEMSTRUCT mis);

int
Signum(
    int nTest);

VOID
DrawItem(
    POPENFILEINFO pOFI,
    HWND hDlg,
    WPARAM wParam,
    LPDRAWITEMSTRUCT lpdis,
    BOOL bSave);

BOOL
SpacesExist(
    LPTSTR szFileName);

void
StripFileName(
    HANDLE hDlg,
    BOOL bWowApp);

LPTSTR
lstrtok(
    LPTSTR lpStr,
    LPTSTR lpDelim);

LPTSTR
ChopText(
    HWND hwndDlg,
    int idStatic,
    LPTSTR lpch);

BOOL
FillOutPath(
    HWND hList,
    POPENFILEINFO pOFI);

BOOL
ShortenThePath(
    LPTSTR pPath);

int
FListAll(
    POPENFILEINFO pOFI,
    HWND hDlg,
    LPTSTR szSpec);

int
ChangeDir(
    HWND hDlg,
    LPCTSTR lpszDir,
    BOOL bForce,
    BOOL bError);

BOOL
IsFileSystemCasePreserving(
    LPTSTR lpszDisk);

BOOL
IsLFNDriveX(
    HWND hDlg,
    LPTSTR szPath);

int
DiskAddedPreviously(
    TCHAR wcDrive,
    LPTSTR lpszName);

int
AddDisk(
    TCHAR wcDrive,
    LPTSTR lpName,
    LPTSTR lpProvider,
    DWORD dwType);

VOID
EnableDiskInfo(
    BOOL bValid,
    BOOL bDoUnc);

VOID
FlushDiskInfoToCmb2();

BOOL
CallNetDlg(
    HWND hWnd);

UINT
GetDiskType(
    LPTSTR lpszDisk);

DWORD
GetUNCDirectoryFromLB(
    HWND hDlg,
    WORD nLB,
    POPENFILEINFO pOFI);

VOID
SelDisk(
    HWND hDlg,
    LPTSTR lpszDisk);

VOID
LNDSetEvent(
    HWND hDlg);

VOID
UpdateLocalDrive(
    LPTSTR szDrive,
    BOOL bGetVolName);

VOID
GetNetDrives(
    DWORD dwScope);

VOID
ListNetDrivesHandler();

VOID
LoadDrives(
    HWND hDlg);

DWORD
GetDiskIndex(
    DWORD dwDriveType);

VOID
CleanUpFile();

VOID
FileOpenAbort();

VOID
TermFile();


#ifdef UNICODE
//VOID                                 // prototype in fileopen.h
//ThunkOpenFileNameA2WDelayed(
//    POPENFILEINFO pOFI);

//BOOL                                 // prototype in fileopen.h
//ThunkOpenFileNameA2W(
//    POPENFILEINFO pOFI);

//BOOL                                 // prototype in fileopen.h
//ThunkOpenFileNameW2A(
//    POPENFILEINFO pOFI);

BOOL
GenericGetFileNameA(
    LPOPENFILENAMEA pOFNA,
    DLGPROC qfnDlgProc);

LPWSTR
ThunkANSIStrToWIDE(
    LPWSTR pDestW,
    LPSTR pSrcA,
    int cChars);

LPWSTR
ThunkMultiANSIStrToWIDE(
    LPWSTR pDestW,
    LPSTR pSrcA,
    int cChars);

BOOL
Multi_strcpyAtoW(
    LPWSTR pDestW,
    LPCSTR pSrcA,
    int cChars);

INT
Multi_strlenA(
    LPCSTR str);

#endif



#ifndef SheChangeDirEx
#undef SheChangeDirEx
#define SheChangeDirEx SetCurrentDirectory
#endif





#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  GetFileTitleA
//
//  ANSI entry point for GetFileTitle when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

SHORT WINAPI GetFileTitleA(
    LPCSTR lpszFileA,
    LPSTR lpszTitleA,
    WORD cbBuf)
{
    LPWSTR lpszFileW;
    LPWSTR lpszTitleW;
    BOOL fResult;
    DWORD cbLen;

    //
    //  Init File string.
    //
    if (lpszFileA)
    {
        cbLen = lstrlenA(lpszFileA) + 1;
        if (!(lpszFileW = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            return (FALSE);
        }
        else
        {
            MultiByteToWideChar( CP_ACP,
                                 0,
                                 (LPSTR)lpszFileA,
                                 -1,
                                 lpszFileW,
                                 cbLen );
        }
    }
    else
    {
        lpszFileW = NULL;
    }

    if (!(lpszTitleW = (LPWSTR)LocalAlloc(LPTR, (cbBuf * sizeof(WCHAR)))))
    {
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
        if (lpszFileW)
        {
            LocalFree(lpszFileW);
        }
        return (FALSE);
    }

    if (!(fResult = GetFileTitleW(lpszFileW, lpszTitleW, cbBuf)))
    {
        WideCharToMultiByte( CP_ACP,
                             0,
                             lpszTitleW,
                             -1,
                             lpszTitleA,
                             cbBuf,
                             NULL,
                             NULL );
    }
    else if (fResult > 0)
    {
        //
        //  Buffer is too small - Ansi size needed (including null terminator).
        //  Get the offset to the filename.
        //
        SHORT nNeeded = (SHORT)(INT)LOWORD(ParseFile(lpszFileW, TRUE, FALSE, FALSE));
        LPSTR lpA = (LPSTR)lpszFileA;

        lpA += WideCharToMultiByte( CP_ACP,
                                    0,
                                    lpszFileW,
                                    nNeeded,
                                    NULL,
                                    0,
                                    NULL,
                                    NULL );

        fResult = lstrlenA(lpA) + 1;
        if (fResult <= cbBuf)
        {
            lstrcpyA(lpszTitleA, lpA);
            fResult = 0;
        }
    }

    //
    //  Clean up memory.
    //
    LocalFree(lpszTitleW);

    if (lpszFileW)
    {
        LocalFree(lpszFileW);
    }

    return ((SHORT)fResult);
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  GetFileTitleW
//
//  Stub UNICODE function for GetFileTitle when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

SHORT WINAPI GetFileTitleW(
    LPCWSTR lpszFileW,
    LPWSTR lpszTitleW,
    WORD cbBuf)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#endif


////////////////////////////////////////////////////////////////////////////
//
//  GetFileTitle
//
//  The GetFileTitle function returns the name of the file identified
//  by the lpCFile parameter.  This is useful if the file name was
//  received via some method other than GetOpenFileName
//  (e.g. command line, drag drop).
//
//  Returns:  0 on success
//            < 0, Parsing failure (invalid file name)
//            > 0, buffer too small, size needed (including NULL terminator)
//
////////////////////////////////////////////////////////////////////////////

SHORT WINAPI GetFileTitle(
    LPCTSTR lpCFile,
    LPTSTR lpTitle,
    WORD cbBuf)
{
    LPTSTR lpFile;
    DWORD cbLen;
    SHORT fResult;

    //
    //  Init File string.
    //
    if (lpCFile)
    {
        cbLen = lstrlen(lpCFile) + 1;
        if (!(lpFile = (LPTSTR)LocalAlloc(LPTR, (cbLen * sizeof(TCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            return (FALSE);
        }
        else
        {
            lstrcpy(lpFile, lpCFile);
        }
    }
    else
    {
        lpFile = NULL;
    }

    fResult = GetFileTitleX(lpFile, lpTitle, cbBuf);

    //
    //  Clean up memory.
    //
    if (lpFile)
    {
        LocalFree(lpFile);
    }

    return (fResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetFileTitleX
//
//  Worker routine for the GetFileTitle api.
//
//  Assumes:  lpszFile  points to NULL terminated DOS filename (may have path)
//            lpszTitle points to buffer to receive NULL terminated file title
//            wBufSize  is the size of buffer pointed to by lpszTitle
//
//  Returns:  0 on success
//            < 0, Parsing failure (invalid file name)
//            > 0, buffer too small, size needed (including NULL terminator)
//
////////////////////////////////////////////////////////////////////////////

SHORT GetFileTitleX(
    LPTSTR lpszFile,
    LPTSTR lpszTitle,
    WORD wBufSize)
{
    SHORT nNeeded;
    LPTSTR lpszPtr;

    //
    //  New 32 bit apps will get a title based on the user's preferences.
    //
    if (GetProcessVersion(0) >= 0x040000)
    {
        SHFILEINFO info;
        DWORD_PTR result;


        if (!lpszFile || !*lpszFile)
        {
            return (PARSE_EMPTYSTRING);
        }

        //
        //  If we have a root directory name (eg. c:\), then we need to go
        //  to the old implementation so that it will return -1.
        //  SHGetFileInfo will return the display name for the directory
        //  (which is the volume name).  This is incompatible with Win95
        //  and previous versions of NT.
        //
        if ((lstrlen(lpszFile) != 3) ||
            (lpszFile[1] != CHAR_COLON) || (!ISBACKSLASH(lpszFile, 2)))
        {
            result = SHGetFileInfo( lpszFile,
                                    FILE_ATTRIBUTE_NORMAL,
                                    &info,
                                    sizeof(info),
                                    SHGFI_DISPLAYNAME | SHGFI_USEFILEATTRIBUTES );

            if (result && (*info.szDisplayName))
            {
                UINT uDisplayLen = lstrlen(info.szDisplayName);

                //
                //  If no buffer or insufficient size, return the required chars.
                //  Original GetFileTitle API did not copy on failure.
                //
                if (!lpszTitle || (uDisplayLen >= (UINT)wBufSize))
                {
                    return ( (SHORT)(uDisplayLen + 1) );
                }

                //
                //  We already know it fits, so we don't need lstrcpyn.
                //
                lstrcpy(lpszTitle, info.szDisplayName);
                return (0);
            }
        }
    }

    //
    //  Use the old implementation.
    //
    nNeeded = (SHORT)(int)LOWORD(ParseFile(lpszFile, TRUE, FALSE, FALSE));
    if (nNeeded >= 0)
    {
        //
        //  Is the filename valid?
        //
        lpszPtr = lpszFile + nNeeded;
        if ((nNeeded = (SHORT)lstrlen(lpszPtr) + 1) <= (int)wBufSize)
        {
            //
            //  ParseFile() fails if wildcards in directory, but OK if in name.
            //  Since they arent OK here, the check is needed here.
            //
            if (StrChr(lpszPtr, CHAR_STAR) || StrChr(lpszPtr, CHAR_QMARK))
            {
                nNeeded = PARSE_WILDCARDINFILE;
            }
            else
            {
                lstrcpy(lpszTitle, lpszPtr);

                //
                //  Remove trailing spaces.
                //
                lpszPtr = lpszTitle + lstrlen(lpszTitle) - 1;
                while (*lpszPtr && *lpszPtr == CHAR_SPACE)
                {
                    *lpszPtr-- = CHAR_NULL;
                }

                nNeeded = 0;
            }
        }
    }

    return (nNeeded);
}


#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  GetOpenFileNameA
//
//  ANSI entry point for GetOpenFileName when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetOpenFileNameA(
    LPOPENFILENAMEA pOFNA)
{
    if (!pOFNA)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    return ( GenericGetFileNameA(pOFNA, FileOpenDlgProc) );
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  GetOpenFileNameW
//
//  Stub UNICODE function for GetOpenFileName when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetOpenFileNameW(
    LPOPENFILENAMEW pOFNW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#endif


////////////////////////////////////////////////////////////////////////////
//
//  GetOpenFileName
//
//  The GetOpenFileName function creates a system-defined dialog box
//  that enables the user to select a file to open.
//
//  Returns:  TRUE    if user specified name
//            FALSE   if not
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetOpenFileName(
    LPOPENFILENAME pOFN)
{
    OPENFILEINFO OFI;

    ZeroMemory(&OFI, sizeof(OPENFILEINFO));

    if (!pOFN)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    OFI.pOFN = pOFN;
    OFI.ApiType = COMDLG_WIDE;
    OFI.iVersion = OPENFILEVERSION;

    return (GetFileName(&OFI, FileOpenDlgProc));
}


#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  GetSaveFileNameA
//
//  ANSI entry point for GetSaveFileName when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetSaveFileNameA(
    LPOPENFILENAMEA pOFNA)
{
    return (GenericGetFileNameA(pOFNA, FileSaveDlgProc));
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  GetSaveFileNameW
//
//  Stub UNICODE function for GetSaveFileName when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetSaveFileNameW(
    LPOPENFILENAMEW pOFNW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#endif


////////////////////////////////////////////////////////////////////////////
//
//  GetSaveFileName
//
//  The GetSaveFileName function creates a system-defined dialog box
//  that enables the user to select a file to save.
//
//  Returns:  TRUE    if user desires to save file and gave a proper name
//            FALSE   if not
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI GetSaveFileName(
    LPOPENFILENAME pOFN)
{
    OPENFILEINFO OFI;

    ZeroMemory(&OFI, sizeof(OPENFILEINFO));

    OFI.pOFN = pOFN;
    OFI.ApiType = COMDLG_WIDE;
    OFI.iVersion = OPENFILEVERSION;

    return ( GetFileName(&OFI, FileSaveDlgProc) );
}


////////////////////////////////////////////////////////////////////////////
//
//  GetFileName
//
//  This is the meat of both GetOpenFileName and GetSaveFileName.
//
//  Returns:  TRUE    if user specified name
//            FALSE   if not
//
////////////////////////////////////////////////////////////////////////////

BOOL GetFileName(
    POPENFILEINFO pOFI,
    DLGPROC qfnDlgProc)
{
    LPOPENFILENAME pOFN = pOFI->pOFN;
    LPOPENFILENAME pofnOld = NULL;
    INT_PTR iRet;
    LPTSTR lpDlg;
    HANDLE hRes, hDlgTemplate;
    WORD wErrorMode;
    HDC hdcScreen;
    HBITMAP hbmpTemp;
    LPCURDLG lpCurDlg;
    static fFirstTime = TRUE;
#ifdef UNICODE
    UINT uiWOWFlag = 0;
#endif
    OPENFILENAME ofn = {0};

    if (!pOFN)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pOFN->lStructSize == OPENFILENAME_LSTRUCTSIZE_NT4)
    {
        //  lets go ahead and convert it over to the new stuff
        ofn  = *pOFN;
        ofn.lStructSize = SIZEOF(ofn);
        pofnOld = pOFN;
        pOFN = &ofn;
        pOFI->pOFN = pOFN;
        pOFI->iVersion = OPENFILEVERSION_NT4;
    }

    if (pOFN->lStructSize != sizeof(OPENFILENAME))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if (pOFN->Flags & OFN_USEMONIKERS)
    {
        if ( !(pOFN->Flags & OFN_EXPLORER)	||
             (!pOFN->rgpMonikers || !pOFN->cMonikers)
           )
        {
            StoreExtendedError(CDERR_INITIALIZATION);
            return (FALSE);
        }
    }
    else if (pOFN->nMaxFile == 0)
    {
        if (!IS16BITWOWAPP(pOFN))
        {
            StoreExtendedError(CDERR_INITIALIZATION);
            return (FALSE);
        }
    }


    //
    //  See if the application should get the new look.
    //
    //  Do not allow the new look if they have hooks, templates, or
    //  multi select without the OFN_EXPLORER bit.
    //
    //  Also don't allow the new look if we are in the context of
    //  a 16 bit process.
    //
    if ( ((pOFN->Flags & OFN_EXPLORER) ||
          (!(pOFN->Flags & (OFN_ENABLEHOOK |
                            OFN_ENABLETEMPLATE |
                            OFN_ENABLETEMPLATEHANDLE |
                            OFN_ALLOWMULTISELECT)))) &&
         (!IS16BITWOWAPP(pOFN)) )
    {
        BOOL fRet;
#ifdef UNICODE
        //
        //  To be used by the thunking routines for multi selection.
        //
        pOFI->bUseNewDialog = TRUE;
#endif
        //
        //  Show the new explorer look.
        //
        StoreExtendedError(0);
        bUserPressedCancel = FALSE;

        if (qfnDlgProc == FileOpenDlgProc)
        {
            fRet = (NewGetOpenFileName(pOFI));
        }
        else
        {
            fRet = (NewGetSaveFileName(pOFI));
        }

        //  copy it back to the original if necessary.
        if (pofnOld)
            CopyMemory(pofnOld, (pOFI->pOFN), pofnOld->lStructSize);

        return fRet;
    }

    if (fFirstTime)
    {
        //
        //  Create a DC that is compatible with the screen and find the
        //  handle of the null bitmap.
        //
        hdcScreen = GetDC(HNULL);
        if (!hdcScreen)
        {
            goto CantInit;
        }
        hdcMemory = CreateCompatibleDC(hdcScreen);
        if (!hdcMemory)
        {
            goto ReleaseScreenDC;
        }

        hbmpTemp = CreateCompatibleBitmap(hdcMemory, 1, 1);
        if (!hbmpTemp)
        {
            goto ReleaseMemDC;
        }
        hbmpOrigMemBmp = SelectObject(hdcMemory, hbmpTemp);
        if (!hbmpOrigMemBmp)
        {
            goto ReleaseMemDC;
        }
        SelectObject(hdcMemory, hbmpOrigMemBmp);
        DeleteObject(hbmpTemp);
        ReleaseDC(HNULL, hdcScreen);

        fFirstTime = FALSE;
    }

    if (pOFN->Flags & OFN_ENABLEHOOK)
    {
        if (!pOFN->lpfnHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pOFN->lpfnHook = NULL;
    }

    HourGlass(TRUE);
    StoreExtendedError(0);

    //
    //  Force re-compute for font changes between calls.
    //
    dyItem = dyText = 0;

    bUserPressedCancel = FALSE;

    if (!FSetUpFile())
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        goto TERMINATE;
    }

    if (pOFN->Flags & OFN_ENABLETEMPLATE)
    {
        if (!(hRes = FindResource( pOFN->hInstance,
                                   pOFN->lpTemplateName,
                                   RT_DIALOG )))
        {
            StoreExtendedError(CDERR_FINDRESFAILURE);
            goto TERMINATE;
        }
        if (!(hDlgTemplate = LoadResource(pOFN->hInstance, hRes)))
        {
            StoreExtendedError(CDERR_LOADRESFAILURE);
            goto TERMINATE;
        }
    }
    else if (pOFN->Flags & OFN_ENABLETEMPLATEHANDLE)
    {
        hDlgTemplate = pOFN->hInstance;
    }
    else
    {
        if (pOFN->Flags & OFN_ALLOWMULTISELECT)
        {
            lpDlg = MAKEINTRESOURCE(MULTIFILEOPENORD);
        }
        else
        {
            lpDlg = MAKEINTRESOURCE(FILEOPENORD);
        }

        if (!(hRes = FindResource(g_hinst, lpDlg, RT_DIALOG)))
        {
            StoreExtendedError(CDERR_FINDRESFAILURE);
            goto TERMINATE;
        }
        if (!(hDlgTemplate = LoadResource(g_hinst, hRes)))
        {
            StoreExtendedError(CDERR_LOADRESFAILURE);
            goto TERMINATE;
        }
    }

    //
    //  No kernel network error dialogs.
    //
    wErrorMode = (WORD)SetErrorMode(SEM_NOERROR);
    SetErrorMode(SEM_NOERROR | wErrorMode);

    if (LockResource(hDlgTemplate))
    {
        if (pOFN->Flags & OFN_ENABLEHOOK)
        {
            glpfnFileHook = GETHOOKFN(pOFN);
        }

#ifdef UNICODE
        if (IS16BITWOWAPP(pOFN))
        {
            uiWOWFlag = SCDLG_16BIT;
        }

        iRet = DialogBoxIndirectParamAorW( g_hinst,
                                           (LPDLGTEMPLATE)hDlgTemplate,
                                           pOFN->hwndOwner,
                                           qfnDlgProc,
                                           (DWORD_PTR)pOFI,
                                           uiWOWFlag );
#else
        iRet = DialogBoxIndirectParam( g_hinst,
                                       (LPDLGTEMPLATE)hDlgTemplate,
                                       pOFN->hwndOwner,
                                       qfnDlgProc,
                                       (DWORD)pOFI );
#endif

        if (iRet == -1 || ((iRet == 0) && (!bUserPressedCancel) && (!GetStoredExtendedError())))
        {
            StoreExtendedError(CDERR_DIALOGFAILURE);
        }
        else
        {
            FileOpenAbort();
        }

        glpfnFileHook = 0;
    }
    else
    {
        StoreExtendedError(CDERR_LOCKRESFAILURE);
        goto TERMINATE;
    }

    SetErrorMode(wErrorMode);

    if (lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg))
    {
        // restore the thread list to the previous dialog (if any)
        TlsSetValue(g_tlsiCurDlg, (LPVOID)lpCurDlg->next);
        LocalFree(lpCurDlg->lpstrCurDir);
        LocalFree(lpCurDlg);
    }

TERMINATE:
    //  make sure the original
    if (pofnOld)
        CopyMemory(pofnOld, (pOFI->pOFN), pofnOld->lStructSize);

    CleanUpFile();
    HourGlass(FALSE);
    return (iRet == IDOK);

ReleaseMemDC:
    DeleteDC(hdcMemory);

ReleaseScreenDC:
    ReleaseDC(HNULL, hdcScreen);

CantInit:
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  FileHookCmd
//
//  Called when a hook function processes a WM_COMMAND message.
//  Called by FileOpenDlgProc and FileSaveDlgProc.
//
////////////////////////////////////////////////////////////////////////////

BOOL FileHookCmd(
    HANDLE hDlg,
    WPARAM wParam,
    LPARAM lParam,
    POPENFILEINFO pOFI)
{
    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
        case ( IDCANCEL ) :
        {
            //
            //  Set global flag stating that the
            //  user pressed cancel.
            //
            bUserPressedCancel = TRUE;

            //  Fall Thru...
        }
        case ( IDOK ) :
        case ( IDABORT ) :
        {
#ifdef UNICODE
            //
            //  Apps that side-effect these messages may
            //  not have their internal unicode strings
            //  updated.  They may also forget to gracefully
            //  exit the network enum'ing worker thread.
            //
            if (pOFI->ApiType == COMDLG_ANSI)
            {
                ThunkOpenFileNameA2W(pOFI);
            }
#endif
            break;
        }
        case ( cmb1 ) :
        case ( cmb2 ) :
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
                case ( MYCBN_DRAW ) :
                case ( MYCBN_LIST ) :
                case ( MYCBN_REPAINT ) :
                case ( MYCBN_CHANGEDIR ) :
                {
                    //
                    //  In case an app has a hook, and returns
                    //  true for processing WM_COMMAND messages,
                    //  we still have to worry about our
                    //  internal message that came through via
                    //  WM_COMMAND.
                    //
                    FileOpenCmd( hDlg,
                                 wParam,
                                 lParam,
                                 pOFI,
                                 FALSE );
                    break;
                }
            }
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  FileOpenDlgProc
//
//  Gets the name of a file to open from the user.
//
//  edt1 = file name
//  lst1 = list of files in current directory matching current pattern
//  cmb1 = lists file patterns
//  stc1 = is current directory
//  lst2 = lists directories on current drive
//  cmb2 = lists drives
//  IDOK = is Open pushbutton
//  IDCANCEL = is Cancel pushbutton
//  chx1 = is for opening read only files
//
//  Returns the normal dialog proc values.
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK FileOpenDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    POPENFILEINFO pOFI;
    BOOL bRet, bHookRet;


    if (pOFI = (POPENFILEINFO)GetProp(hDlg, FILEPROP))
    {
        if (pOFI->pOFN->lpfnHook)
        {
            LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFI->pOFN);

            bHookRet = (*lpfnHook)(hDlg, wMsg, wParam, lParam);

            if (bHookRet)
            {

                if (wMsg == WM_COMMAND)
                {
                    return (FileHookCmd(hDlg, wParam, lParam, pOFI));
                }

                return (bHookRet);
            }
        }
    }
    else if (glpfnFileHook &&
             (wMsg != WM_INITDIALOG) &&
             (bHookRet = (*glpfnFileHook)(hDlg, wMsg, wParam, lParam)))
    {
        return (bHookRet);
    }

    switch (wMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            pOFI = (POPENFILEINFO)lParam;

            SetProp(hDlg, FILEPROP, (HANDLE)pOFI);
            glpfnFileHook = 0;

            //
            //  If we are being called from a Unicode app, turn off
            //  the ES_OEMCONVERT style on the filename edit control.
            //
//          if (pOFI->ApiType == COMDLG_WIDE)
            {
                LONG lStyle;
                HWND hEdit = GetDlgItem(hDlg, edt1);

                //
                //  Grab the window style.
                //
                lStyle = GetWindowLong(hEdit, GWL_STYLE);

                //
                //  If the window style bits include ES_OEMCONVERT,
                //  remove this flag and reset the style.
                //
                if (lStyle & ES_OEMCONVERT)
                {
                    lStyle &= ~ES_OEMCONVERT;
                    SetWindowLong(hEdit, GWL_STYLE, lStyle);
                }
            }

            bInitializing = TRUE;
            bRet = InitFileDlg(hDlg, wParam, pOFI);
            bInitializing = FALSE;

            HourGlass(FALSE);
            return (bRet);
            break;
        }
        case ( WM_ACTIVATE ) :
        {
            if (!bInChildDlg)
            {
                if (bFirstTime == TRUE)
                {
                    bFirstTime = FALSE;
                }
                else if (wParam)
                {
                    //
                    //  If becoming active.
                    //
                    LNDSetEvent(hDlg);
                }
            }
            return (FALSE);
            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            MeasureItem(hDlg, (LPMEASUREITEMSTRUCT)lParam);
            break;
        }
        case ( WM_DRAWITEM ) :
        {
            if (wNoRedraw < 2)
            {
                DrawItem(pOFI, hDlg, wParam, (LPDRAWITEMSTRUCT)lParam, FALSE);
            }
            break;
        }
        case ( WM_SYSCOLORCHANGE ) :
        {
            SetRGBValues();
            LoadDirDriveBitmap();
            break;
        }
        case ( WM_COMMAND ) :
        {
            return (FileOpenCmd(hDlg, wParam, lParam, pOFI, FALSE));
            break;
        }
        case ( WM_SETFOCUS ) :
        {
            //
            //  This logic used to be in CBN_SETFOCUS in fileopencmd,
            //  but CBN_SETFOCUS is called whenever there is a click on
            //  the List Drives combo.  This causes the worker thread
            //  to start up and flicker when the combo box is refreshed.
            //
            //  But, refreshes are only needed when someone focuses out of
            //  the common dialog and then back in (unless someone is logged
            //  in remote, or there is a background thread busy connecting!)
            //  so fix the flicker by moving the logic here.
            //
            if (!wNoRedraw)
            {
                LNDSetEvent(hDlg);
            }

            return (FALSE);
            break;
        }
        case ( WM_HELP ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPTSTR)aFileOpenHelpIDs );
            }
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)wParam,
                         NULL,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)aFileOpenHelpIDs );
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  FileSaveDlgProc
//
//  Obtains the name of the file that the user wants to save.
//
//  Returns the normal dialog proc values.
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK FileSaveDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    POPENFILEINFO pOFI;
    BOOL bRet, bHookRet;
    TCHAR szTitle[cbCaption];


    if (pOFI = (POPENFILEINFO)GetProp(hDlg, FILEPROP))
    {
        if (pOFI->pOFN->lpfnHook)
        {
            LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFI->pOFN);

            bHookRet = (*lpfnHook)(hDlg, wMsg, wParam, lParam);

            if (bHookRet)
            {
                if (wMsg == WM_COMMAND)
                {
                    return (FileHookCmd(hDlg, wParam, lParam, pOFI));
                }

                return (bHookRet);
            }
        }
    }
    else if (glpfnFileHook &&
             (wMsg != WM_INITDIALOG) &&
             (bHookRet = (*glpfnFileHook)(hDlg, wMsg, wParam, lParam)))
    {
        return (bHookRet);
    }

    switch (wMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            pOFI = (POPENFILEINFO)lParam;
            if (!(pOFI->pOFN->Flags &
                  (OFN_ENABLETEMPLATE | OFN_ENABLETEMPLATEHANDLE)))
            {
                LoadString(g_hinst, iszFileSaveTitle, szTitle, cbCaption);
                SetWindowText(hDlg, szTitle);
                LoadString(g_hinst, iszSaveFileAsType, szTitle, cbCaption);
                SetDlgItemText(hDlg, stc2, szTitle);
            }
            glpfnFileHook = 0;
            SetProp(hDlg, FILEPROP, (HANDLE)pOFI);

            //
            //  If we are being called from a Unicode app, turn off
            //  the ES_OEMCONVERT style on the filename edit control.
            //
//          if (pOFI->ApiType == COMDLG_WIDE)
            {
                LONG lStyle;
                HWND hEdit = GetDlgItem(hDlg, edt1);

                //
                //  Grab the window style.
                //
                lStyle = GetWindowLong(hEdit, GWL_STYLE);

                //
                //  If the window style bits include ES_OEMCONVERT,
                //  remove this flag and reset the style.
                //
                if (lStyle & ES_OEMCONVERT)
                {
                    lStyle &= ~ES_OEMCONVERT;
                    SetWindowLong (hEdit, GWL_STYLE, lStyle);
                }
            }

            bInitializing = TRUE;
            bRet = InitFileDlg(hDlg, wParam, pOFI);
            bInitializing = FALSE;

            HourGlass(FALSE);
            return (bRet);
            break;
        }
        case ( WM_ACTIVATE ) :
        {
            if (!bInChildDlg)
            {
                if (bFirstTime == TRUE)
                {
                    bFirstTime = FALSE;
                }
                else if (wParam)
                {
                    //
                    //  If becoming active.
                    //
                    if (!wNoRedraw)
                    {
                        LNDSetEvent(hDlg);
                    }
                }
            }
            return (FALSE);
            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            MeasureItem(hDlg, (LPMEASUREITEMSTRUCT)lParam);
            break;
        }
        case ( WM_DRAWITEM ) :
        {
            if (wNoRedraw < 2)
            {
                DrawItem(pOFI, hDlg, wParam, (LPDRAWITEMSTRUCT)lParam, TRUE);
            }
            break;
        }
        case ( WM_SYSCOLORCHANGE ) :
        {
            SetRGBValues();
            LoadDirDriveBitmap();
            break;
        }
        case ( WM_COMMAND ) :
        {
            return (FileOpenCmd(hDlg, wParam, lParam, pOFI, TRUE));
            break;
        }
        case ( WM_SETFOCUS ) :
        {
            //
            //  This logic used to be in CBN_SETFOCUS in fileopencmd,
            //  but CBN_SETFOCUS is called whenever there is a click on
            //  the List Drives combo.  This causes the worker thread
            //  to start up and flicker when the combo box is refreshed.
            //
            //  But, refreshes are only needed when someone focuses out of
            //  the common dialog and then back in (unless someone is logged
            //  in remote, or there is a background thread busy connecting!)
            //  so fix the flicker by moving the logic here.
            //
            if (!wNoRedraw)
            {
                LNDSetEvent(hDlg);
            }

            return (FALSE);
            break;
        }
        case ( WM_HELP ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPTSTR)aFileSaveHelpIDs );
            }
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)wParam,
                         NULL,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)aFileSaveHelpIDs );
            }
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitFileDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL InitFileDlg(
    HWND hDlg,
    WPARAM wParam,
    POPENFILEINFO pOFI)
{
    DWORD lRet, nFilterIndex;
    LPOPENFILENAME pOFN = pOFI->pOFN;
    int nFileOffset, nExtOffset;
    RECT rRect;
    RECT rLbox;
    BOOL bRet;

    if (!InitTlsValues(pOFI))
    {
        //
        //  The extended error is set inside of the above call.
        //
        EndDialog(hDlg, FALSE);
        return (FALSE);
    }

    lpLBProc = (WNDPROC)GetWindowLongPtr(GetDlgItem(hDlg, lst2), GWLP_WNDPROC);
    lpOKProc = (WNDPROC)GetWindowLongPtr(GetDlgItem(hDlg, IDOK), GWLP_WNDPROC);

    if (!lpLBProc || !lpOKProc)
    {
        StoreExtendedError(FNERR_SUBCLASSFAILURE);
        EndDialog(hDlg, FALSE);
        return (FALSE);
    }

    //
    //  Save original directory for later restoration if necessary.
    //
    *pOFI->szCurDir = 0;
    GetCurrentDirectory(MAX_FULLPATHNAME + 1, pOFI->szCurDir);

    //
    //  Check out if the filename contains a path.  If so, override whatever
    //  is contained in lpstrInitialDir.  Chop off the path and put up only
    //  the filename.
    //
    if ( pOFN->lpstrFile &&
         *pOFN->lpstrFile &&
         !(pOFN->Flags & OFN_NOVALIDATE) )
    {
        if (DBL_BSLASH(pOFN->lpstrFile + 2) &&
            ((*(pOFN->lpstrFile + 1) == CHAR_COLON)))
        {
            lstrcpy(pOFN->lpstrFile , pOFN->lpstrFile + sizeof(TCHAR));
        }

        lRet = ParseFile(pOFN->lpstrFile, TRUE, IS16BITWOWAPP(pOFN), FALSE);
        nFileOffset = (int)(SHORT)LOWORD(lRet);
        nExtOffset  = (int)(SHORT)HIWORD(lRet);

        //
        //  Is the filename invalid?
        //
        if ( (nFileOffset < 0) &&
             (nFileOffset != PARSE_EMPTYSTRING) &&
             (pOFN->lpstrFile[nExtOffset] != CHAR_SEMICOLON) )
        {
            StoreExtendedError(FNERR_INVALIDFILENAME);
            EndDialog(hDlg, FALSE);
            return (FALSE);
        }
    }

    pOFN->Flags &= ~(OFN_FILTERDOWN | OFN_DRIVEDOWN | OFN_DIRSELCHANGED);

    pOFI->idirSub = 0;

    if (!(pOFN->Flags & OFN_SHOWHELP))
    {
        HWND hHelp;

        EnableWindow(hHelp = GetDlgItem(hDlg, pshHelp), FALSE);

        //
        //  Move the window out of this spot so that no overlap will be
        //  detected.
        //
        MoveWindow(hHelp, -8000, -8000, 20, 20, FALSE);
        ShowWindow(hHelp, SW_HIDE);
    }

    if (pOFN->Flags & OFN_CREATEPROMPT)
    {
        pOFN->Flags |= (OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST);
    }
    else if (pOFN->Flags & OFN_FILEMUSTEXIST)
    {
        pOFN->Flags |= OFN_PATHMUSTEXIST;
    }

    if (pOFN->Flags & OFN_HIDEREADONLY)
    {
        HWND hReadOnly;

        EnableWindow(hReadOnly = GetDlgItem(hDlg, chx1), FALSE);

        //
        //  Move the window out of this spot so that no overlap will be
        //  detected.
        //
        MoveWindow(hReadOnly, -8000, -8000, 20, 20, FALSE);
        ShowWindow(hReadOnly, SW_HIDE);
    }
    else
    {
        CheckDlgButton(hDlg, chx1, (pOFN->Flags & OFN_READONLY) != 0);
    }

    SendDlgItemMessage(hDlg, edt1, EM_LIMITTEXT, (WPARAM)MAX_PATH, 0L);

    //
    //  Insert file specs into cmb1.
    //  Custom filter first.
    //  Must also check if filter contains anything.
    //
    if ( pOFN->lpstrFile &&
         (StrChr(pOFN->lpstrFile, CHAR_STAR) ||
          StrChr(pOFN->lpstrFile, CHAR_QMARK)) )
    {
        lstrcpy(pOFI->szLastFilter, pOFN->lpstrFile);
    }
    else
    {
        pOFI->szLastFilter[0] = CHAR_NULL;
    }

    if (pOFN->lpstrCustomFilter && *pOFN->lpstrCustomFilter)
    {
        SHORT nLength;

        SendDlgItemMessage( hDlg,
                            cmb1,
                            CB_INSERTSTRING,
                            0,
                            (LONG_PTR)pOFN->lpstrCustomFilter );

        nLength = (SHORT)(lstrlen(pOFN->lpstrCustomFilter) + 1);
        SendDlgItemMessage( hDlg,
                            cmb1,
                            CB_SETITEMDATA,
                            0,
                            (LONG)(nLength) );

        SendDlgItemMessage( hDlg,
                            cmb1,
                            CB_LIMITTEXT,
                            (WPARAM)(pOFN->nMaxCustFilter),
                            0L );

        if (pOFI->szLastFilter[0] == CHAR_NULL)
        {
            lstrcpy(pOFI->szLastFilter, pOFN->lpstrCustomFilter + nLength);
        }
    }
    else
    {
        //
        //  Given no custom filter, the index will be off by one.
        //
        if (pOFN->nFilterIndex != 0)
        {
            pOFN->nFilterIndex--;
        }
    }

    //
    //  Listed filters next.
    //
    if (pOFN->lpstrFilter && *pOFN->lpstrFilter)
    {
        if (pOFN->nFilterIndex > InitFilterBox(hDlg, pOFN->lpstrFilter))
        {
            pOFN->nFilterIndex = 0;
        }
    }
    else
    {
        pOFN->nFilterIndex = 0;
    }
    pOFI->szSpecCur[0] = CHAR_NULL;

    //
    //  If an entry exists, select the one indicated by nFilterIndex.
    //
    if ((pOFN->lpstrFilter && *pOFN->lpstrFilter) ||
        (pOFN->lpstrCustomFilter && *pOFN->lpstrCustomFilter))
    {
        LPCTSTR lpFilter;

        SendDlgItemMessage( hDlg,
                            cmb1,
                            CB_SETCURSEL,
                            (WPARAM)(pOFN->nFilterIndex),
                            0L );

        nFilterIndex = pOFN->nFilterIndex;
        SendMessage( hDlg,
                     WM_COMMAND,
                     GET_WM_COMMAND_MPS( cmb1,
                                         GetDlgItem(hDlg, cmb1),
                                         MYCBN_DRAW ) );
        pOFN->nFilterIndex = nFilterIndex;

        if (pOFN->nFilterIndex ||
            !(pOFN->lpstrCustomFilter && *pOFN->lpstrCustomFilter))
        {
            lpFilter = pOFN->lpstrFilter +
                       SendDlgItemMessage( hDlg,
                                           cmb1,
                                           CB_GETITEMDATA,
                                           (WPARAM)pOFN->nFilterIndex,
                                           0L );
        }
        else
        {
            lpFilter = pOFN->lpstrCustomFilter +
                       lstrlen(pOFN->lpstrCustomFilter) + 1;
        }
        if (*lpFilter)
        {
            TCHAR szText[MAX_FULLPATHNAME];

            // ISSUE: lpFilter can be longer than MAX_FULLPATHNAME!!!
            lstrcpy(szText, lpFilter);

            //
            //  Filtering is case-insensitive.
            //
            CharLower(szText);

            if (pOFI->szLastFilter[0] == CHAR_NULL)
            {
                lstrcpy(pOFI->szLastFilter, szText);
            }

            if (!(pOFN->lpstrFile && *pOFN->lpstrFile))
            {
                SetDlgItemText(hDlg, edt1, szText);
            }
        }
    }

    InitCurrentDisk(hDlg, pOFI, cmb2);

    bFirstTime = TRUE;
    bInChildDlg = FALSE;

    SendMessage( hDlg,
                 WM_COMMAND,
                 GET_WM_COMMAND_MPS(cmb2, GetDlgItem(hDlg, cmb2), MYCBN_DRAW) );
    SendMessage( hDlg,
                 WM_COMMAND,
                 GET_WM_COMMAND_MPS(cmb2, GetDlgItem(hDlg, cmb2), MYCBN_LIST) );

    if (pOFN->lpstrFile && *pOFN->lpstrFile)
    {
        TCHAR szText[MAX_FULLPATHNAME];

        lRet = ParseFile( pOFN->lpstrFile,
                          IsLFNDriveX(hDlg, pOFN->lpstrFile),
                          IS16BITWOWAPP(pOFN),
                          FALSE );
        nFileOffset = (int)(SHORT)LOWORD(lRet);
        nExtOffset  = (int)(SHORT)HIWORD(lRet);

        //
        //  Is the filename invalid?
        //
        if ( !(pOFN->Flags & OFN_NOVALIDATE) &&
             (nFileOffset < 0) &&
             (nFileOffset != PARSE_EMPTYSTRING) &&
             (pOFN->lpstrFile[nExtOffset] != CHAR_SEMICOLON) )
        {
            StoreExtendedError(FNERR_INVALIDFILENAME);
            EndDialog(hDlg, FALSE);
            return (FALSE);
        }
        lstrcpy(szText, pOFN->lpstrFile);
        SetDlgItemText(hDlg, edt1, szText);
    }

    SetWindowLongPtr(GetDlgItem(hDlg, lst2), GWLP_WNDPROC, (LONG_PTR)dwLBSubclass);
    SetWindowLongPtr(GetDlgItem(hDlg, IDOK), GWLP_WNDPROC, (LONG_PTR)dwOKSubclass);

    if (pOFN->lpstrTitle && *pOFN->lpstrTitle)
    {
        SetWindowText(hDlg, pOFN->lpstrTitle);
    }

    //
    //  By setting dyText to rRect.bottom/8, dyText defaults to 8 items showing
    //  in the listbox.  This only matters if the applications hook function
    //  steals all WM_MEASUREITEM messages.  Otherwise, dyText will be set in
    //  the MeasureItem() routine.  Check for !dyItem in case message ordering
    //  has already sent WM_MEASUREITEM and dyText is already initialized.
    //
    if (!dyItem)
    {
        GetClientRect(GetDlgItem(hDlg, lst1), (LPRECT) &rRect);
        if (!(dyText = (rRect.bottom / 8)))
        {
            //
            //  If no size to rectangle.
            //
            dyText = 8;
        }
    }

    //  The template has changed to make it extremely clear that
    //  this is not a combobox, but rather an edit control and a listbox.  The
    //  problem is that the new templates try to align the edit box and listbox.
    //  Unfortunately, when listboxes add borders, they expand beyond their
    //  borders.  When edit controls add borders, they stay within their
    //  borders.  This makes it impossible to align the two controls strictly
    //  within the template.  The code below will align the controls, but only
    //  if they are using the standard dialog template.
    //
    if (!(pOFN->Flags & (OFN_ENABLETEMPLATE | OFN_ENABLETEMPLATEHANDLE)))
    {
        GetWindowRect(GetDlgItem(hDlg, lst1), (LPRECT)&rLbox);
        GetWindowRect(GetDlgItem(hDlg, edt1), (LPRECT)&rRect);
        rRect.left = rLbox.left;
        rRect.right = rLbox.right;
        ScreenToClient(hDlg, (LPPOINT)&(rRect.left));
        ScreenToClient(hDlg, (LPPOINT)&(rRect.right));
        SetWindowPos( GetDlgItem(hDlg, edt1),
                      0,
                      rRect.left,
                      rRect.top,
                      rRect.right - rRect.left,
                      rRect.bottom - rRect.top,
                      SWP_NOZORDER );
    }

    if (pOFN->lpfnHook)
    {
        LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

#ifdef UNICODE
        if (pOFI->ApiType == COMDLG_ANSI)
        {
            ThunkOpenFileNameW2A(pOFI);
            bRet = ((*lpfnHook)( hDlg,
                                 WM_INITDIALOG,
                                 wParam,
                                 (LPARAM)pOFI->pOFNA ));
            //
            //  Strange win 31 example uses lCustData to
            //  hold a temporary variable that it passes back to
            //  calling function.
            //
            ThunkOpenFileNameA2W(pOFI);
        }
        else
#endif
        {
            bRet = ((*lpfnHook)( hDlg,
                                 WM_INITDIALOG,
                                 wParam,
                                 (LPARAM)pOFN ));
        }
    }
    else
    {
#ifdef UNICODE
        //
        //  Have to thunk A version even when there isn't a hook proc so it
        //  doesn't reset W version on delayed thunk back.
        //
        if (pOFI->ApiType == COMDLG_ANSI)
        {
            pOFI->pOFNA->Flags = pOFN->Flags;
        }
#endif
        bRet = TRUE;
    }

    //
    //  At first, assume there is net support !
    //
    if ((pOFN->Flags & OFN_NONETWORKBUTTON))
    {
        HWND hNet;

        if (hNet = GetDlgItem(hDlg, psh14))
        {
            EnableWindow(hNet = GetDlgItem(hDlg, psh14), FALSE);

            ShowWindow(hNet, SW_HIDE);
        }
    }
    else
    {
        AddNetButton( hDlg,
                      ((pOFN->Flags & OFN_ENABLETEMPLATE)
                          ? pOFN->hInstance
                          : g_hinst),
                      FILE_BOTTOM_MARGIN,
                      (pOFN->Flags & (OFN_ENABLETEMPLATE |
                                       OFN_ENABLETEMPLATEHANDLE))
                          ? FALSE
                          : TRUE,
                      (pOFN->Flags & OFN_NOLONGNAMES)
                          ? FALSE
                          : TRUE,
                      FALSE);
    }

    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitTlsValues
//
////////////////////////////////////////////////////////////////////////////

int InitTlsValues(
    POPENFILEINFO pOFI)
{
    //
    //  As long as we do not call TlsGetValue before this,
    //  everything should be ok.
    //
    LPCURDLG lpCurDlg, lpPrevDlg;
    DWORD    dwError;
    LPTSTR   lpCurDir;

    if (dwNumDlgs == MAX_THREADS)
    {
        dwError = CDERR_INITIALIZATION;
        goto ErrorExit0;
    }

    // alloc for the current directory
    if (lpCurDir = (LPTSTR)LocalAlloc(LPTR, CCHNETPATH * sizeof(TCHAR)))
    {
        GetCurrentDirectory(CCHNETPATH, lpCurDir);

        if ( (pOFI->pOFN->Flags & OFN_ALLOWMULTISELECT) &&
             (StrChr(lpCurDir, CHAR_SPACE)) )
        {
            GetShortPathName(lpCurDir, lpCurDir, CCHNETPATH);
        }

    }
    else
    {
        dwError = CDERR_MEMALLOCFAILURE;
        goto ErrorExit0;
    }

    // add a CurDlg struct to the list for this thread
    if (lpCurDlg = (LPCURDLG)LocalAlloc(LPTR, sizeof(CURDLG)))
    {
        // get start of CURDLG list for this thread
        // Note: lpPrevDlg will be NULL if there wasn't a previous dialog
        lpPrevDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);

        // make sure TlsGetValue() actually succeeded (a NULL return could
        // mean there wasn't a previous dialog in the list)
        if (GetLastError() != NO_ERROR)
        {
            dwError = CDERR_INITIALIZATION;
            goto ErrorExit2;
        }

        // push the new dlg to the front of the list
        lpCurDlg->next = lpPrevDlg;

        lpCurDlg->lpstrCurDir = lpCurDir;
        PathAddBackslash(lpCurDlg->lpstrCurDir);

        EnterCriticalSection(&g_csLocal);
        lpCurDlg->dwCurDlgNum = dwNumDlgs++;
        LeaveCriticalSection(&g_csLocal);

        // save the new head of the list for the thread
        if (!TlsSetValue(g_tlsiCurDlg, (LPVOID)lpCurDlg))
        {
            dwError = CDERR_INITIALIZATION;
            goto ErrorExit2;
        }
    }
    else
    {
        dwError = CDERR_MEMALLOCFAILURE;
        goto ErrorExit1;
    }

    return(TRUE);


ErrorExit2:
    LocalFree(lpCurDlg);

ErrorExit1:
    LocalFree(lpCurDir);

ErrorExit0:
    StoreExtendedError(dwError);
    return (FALSE);

}


////////////////////////////////////////////////////////////////////////////
//
//  InitFilterBox
//
//  Places the double null terminated list of filters in the combo box.
//  The list should consist of pairs of null terminated strings, with
//  an additional null terminating the list.
//
////////////////////////////////////////////////////////////////////////////

DWORD InitFilterBox(
    HANDLE hDlg,
    LPCTSTR lpszFilter)
{
    DWORD nOffset = 0;
    DWORD nIndex = 0;
    register WORD nLen;


    while (*lpszFilter)
    {
        //
        //  First string put in as string to show.
        //
        nIndex = (DWORD) SendDlgItemMessage( hDlg,
                                             cmb1,
                                             CB_ADDSTRING,
                                             0,
                                             (LPARAM)lpszFilter );
        nLen = (WORD)(lstrlen(lpszFilter) + 1);
        (LPTSTR)lpszFilter += nLen;
        nOffset += nLen;

        //
        //  Second string put in as itemdata.
        //
        SendDlgItemMessage( hDlg,
                            cmb1,
                            CB_SETITEMDATA,
                            (WPARAM)nIndex,
                            nOffset );

        //
        //  Advance to next element.
        //
        nLen = (WORD)(lstrlen(lpszFilter) + 1);
        (LPTSTR)lpszFilter += nLen;
        nOffset += nLen;
    }

    return (nIndex);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetAppOpenDir
//
////////////////////////////////////////////////////////////////////////////

LPCITEMIDLIST GetAppOpenDir(
    LPTSTR lpszBuff,
    LPTSTR lpszFilterCurrent)
{
    TCHAR szPath[MAX_FULLPATHNAME];
    TCHAR szFilter[MAX_FULLPATHNAME];
    LPTSTR lpszFilter;
    LPTSTR lpszTemp;
    LPTSTR lpszF[MAXFILTERS + 1];
    int i;
    BOOL fFoundMatches = FALSE;
    DWORD dwVolumeSerialNumber;
    DWORD dwMaximumComponentLength;
    DWORD dwFileSystemFlags;
    BOOL bLFN = FALSE;
    int nFilters;

    *lpszBuff = TEXT('\0');       // prepare to return empty string

    if (g_bDisableMyDocs)
    {
        return (NULL);
    }

    if (!lpszFilterCurrent)
    {
        return (NULL);
    }

    lstrcpy(szFilter, lpszFilterCurrent);
    lpszFilter = szFilter;

    GetCurrentDirectory(ARRAYSIZE(szPath), szPath);

    PathStripToRoot(szPath);

    //
    //  We need to find out what kind of a drive we are running
    //  on in order to determine if spaces are valid in a filename
    //  or not.
    //
    if (GetVolumeInformation( szPath,
                              NULL,
                              0,
                              &dwVolumeSerialNumber,
                              &dwMaximumComponentLength,
                              &dwFileSystemFlags,
                              NULL,
                              0 ))
    {
        if (dwMaximumComponentLength == (MAXDOSFILENAMELEN - 1))
        {
            bLFN = FALSE;
        }
        else
        {
            bLFN = TRUE;
        }
    }

    //
    //  Find the first filter in the string, and add it to the
    //  array.
    //
    if (bLFN)
    {
        lpszF[nFilters = 0] = lstrtok(lpszFilter, szSemiColonTab);
    }
    else
    {
        lpszF[nFilters = 0] = lstrtok(lpszFilter, szSemiColonSpaceTab);
    }

    //
    //  Now we are going to loop through all the filters in the string
    //  parsing the one we already have, and then finding the next one
    //  and starting the loop over again.
    //
    while (lpszF[nFilters] && (nFilters < MAXFILTERS))
    {
        //
        //  Check to see if the first character is a space.  If so, remove
        //  the spaces, and save the pointer back into the same spot.  We
        //  need to do this because the FindFirstFile/Next api will still
        //  work on filenames that begin with a space since they also
        //  look at the short names.  The short names will begin with the
        //  same first real letter as the long filename.  For example, the
        //  long filename is "  my document" the first letter of this short
        //  name is "m", so searching on "m*.*" or " m*.*" will yield the
        //  same results.
        //
        if (bLFN && (*lpszF[nFilters] == CHAR_SPACE))
        {
            lpszTemp = lpszF[nFilters];
            while ((*lpszTemp == CHAR_SPACE) && *lpszTemp)
            {
                lpszTemp = CharNext(lpszTemp);
            }
            lpszF[nFilters] = lpszTemp;
        }

        //
        //  Ready to move on to the next filter.  Find the next
        //  filter based upon the type of file system we're using.
        //
        if (bLFN)
        {
            lpszF[++nFilters] = lstrtok(NULL, szSemiColonTab);
        }
        else
        {
            lpszF[++nFilters] = lstrtok(NULL, szSemiColonSpaceTab);
        }

        //
        //  In case we found a pointer to NULL, then look for the
        //  next filter.
        //
        while (lpszF[nFilters] && !*lpszF[nFilters])
        {
            if (bLFN)
            {
                lpszF[nFilters] = lstrtok(NULL, szSemiColonTab);
            }
            else
            {
                lpszF[nFilters] = lstrtok(NULL, szSemiColonSpaceTab);
            }
        }
    }

    //
    //  Add NULL terminator only if needed.
    //
    if (nFilters >= MAXFILTERS)
    {
        lpszF[MAXFILTERS] = 0;
    }
    for (i = 0; lpszF[i] && !fFoundMatches; i++)
    {
        HANDLE hff;
        WIN32_FIND_DATA FindFileData;

        //
        //  Find First for each filter.
        //
        hff = FindFirstFile(lpszF[i], &FindFileData);

        if (hff == INVALID_HANDLE_VALUE)
        {
            continue;
        }

        do
        {
            if ((FindFileData.dwFileAttributes & EXCLBITS) ||
                (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                continue;
            }
            fFoundMatches = TRUE;
            break;

        } while (FindNextFile(hff, &FindFileData));

        FindClose(hff);
    }

    if (!fFoundMatches)
    {
        //
        //  See if the app has changed the current directory since they
        //  attached to the process...
        //
        GetCurrentDirectory(ARRAYSIZE(szPath), szPath);
        if (lstrcmpi(g_szInitialCurDir, szPath) == 0)
        {
            //
            //  If we didn't find any files, and the current directory hasn't
            //  changed, then choose the MyDocuments directory.
            //
            if (SHGetSpecialFolderPath(NULL, lpszBuff, CSIDL_PERSONAL, FALSE))
            {
                if (g_bMyDocsHidden)
                {
                    return NULL;
                }
                else
                {
                    return ((LPCITEMIDLIST)&c_idlMyDocs);
                }
            }
        }
    }

    //
    //  Otherwise, just return an empty string.
    //
    return (NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetAppOpenDir
//
////////////////////////////////////////////////////////////////////////////

void SetAppOpenDir(void)
{

}


////////////////////////////////////////////////////////////////////////////
//
//  InitCurrentDisk
//
////////////////////////////////////////////////////////////////////////////

VOID InitCurrentDisk(
    HWND hDlg,
    POPENFILEINFO pOFI,
    WORD cmb)
{
    TCHAR szPath[MAX_FULLPATHNAME];

    //
    //  Clear out stale unc stuff from disk info.
    //  Unc \\server\shares are persistent through one popup session
    //  and then we resync with the system.  This is to fix a bug
    //  where a user's startup dir is unc but the system no longer has
    //  a connection and hence the cmb2 appears blank.
    //
    EnableDiskInfo(FALSE, TRUE);

    if (pOFI->pOFN->lpstrInitialDir)
    {
        //
        //  Notice that we force ChangeDir to succeed here
        //  but that TlsGetValue(g_tlsiCurDlg)->lpstrCurDir will return "" which
        //  when fed to SheChangeDirEx means GetCurrentDir will be called.
        //  So, the default cd behavior at startup is:
        //      1. lpstrInitialDir
        //      2. GetCurrentDir
        //
        szPath[0] = 0;
        if ( (pOFI->pOFN->Flags & OFN_ALLOWMULTISELECT) &&
             (StrChr(pOFI->pOFN->lpstrInitialDir, CHAR_SPACE)) &&
             (GetShortPathName( pOFI->pOFN->lpstrInitialDir,
                                szPath,
                                MAX_FULLPATHNAME )) &&
             (szPath[0] != 0) )
        {
            ChangeDir(hDlg, szPath, TRUE, FALSE);
        }
        else
        {
            ChangeDir(hDlg, pOFI->pOFN->lpstrInitialDir, TRUE, FALSE);
        }
    }
    else
    {
        GetAppOpenDir(szPath, pOFI->szLastFilter);
        ChangeDir(hDlg, szPath, TRUE, FALSE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  vDeleteDirDriveBitmap
//
//  Gets rid of bitmaps, if they exist.
//
////////////////////////////////////////////////////////////////////////////

VOID vDeleteDirDriveBitmap()
{
    if (hbmpOrigMemBmp)
    {
        SelectObject(hdcMemory, hbmpOrigMemBmp);
        if (hbmpDirDrive != HNULL)
        {
            DeleteObject(hbmpDirDrive);
            hbmpDirDrive = HNULL;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadDirDriveBitmap
//
//  Creates the drive/directory bitmap.  If an appropriate bitmap
//  already exists, it just returns immediately.  Otherwise, it
//  loads the bitmap and creates a larger bitmap with both regular
//  and highlight colors.
//
////////////////////////////////////////////////////////////////////////////

BOOL LoadDirDriveBitmap()
{
    BITMAP bmp;
    HANDLE hbmp, hbmpOrig;
    HDC hdcTemp;
    BOOL bWorked = FALSE;

    if ( (hbmpDirDrive != HNULL) &&
         (rgbWindowColor == rgbDDWindow) &&
         (rgbHiliteColor == rgbDDHilite))
    {
        if (SelectObject(hdcMemory, hbmpDirDrive))
        {
            return (TRUE);
        }
    }

    vDeleteDirDriveBitmap();

    rgbDDWindow = rgbWindowColor;
    rgbDDHilite = rgbHiliteColor;

    if (!(hdcTemp = CreateCompatibleDC(hdcMemory)))
    {
        goto LoadExit;
    }

    if (!(hbmp = LoadAlterBitmap(bmpDirDrive, rgbSolidBlue, rgbWindowColor)))
    {
        goto DeleteTempDC;
    }

    GetObject(hbmp, sizeof(BITMAP), (LPTSTR)&bmp);
    dyDirDrive = bmp.bmHeight;
    dxDirDrive = bmp.bmWidth;

    hbmpOrig = SelectObject(hdcTemp, hbmp);

    hbmpDirDrive = CreateDiscardableBitmap(hdcTemp, dxDirDrive * 2, dyDirDrive);
    if (!hbmpDirDrive)
    {
        goto DeleteTempBmp;
    }

    if (!SelectObject(hdcMemory, hbmpDirDrive))
    {
        vDeleteDirDriveBitmap();
        goto DeleteTempBmp;
    }

    BitBlt(hdcMemory, 0, 0, dxDirDrive, dyDirDrive, hdcTemp, 0, 0, SRCCOPY);
    SelectObject(hdcTemp, hbmpOrig);

    DeleteObject(hbmp);

    if (!(hbmp = LoadAlterBitmap(bmpDirDrive, rgbSolidBlue, rgbHiliteColor)))
    {
        goto DeleteTempDC;
    }

    hbmpOrig = SelectObject(hdcTemp, hbmp);
    BitBlt(hdcMemory, dxDirDrive, 0, dxDirDrive, dyDirDrive, hdcTemp, 0, 0, SRCCOPY);
    SelectObject(hdcTemp, hbmpOrig);

    bWorked = TRUE;

DeleteTempBmp:
    DeleteObject(hbmp);

DeleteTempDC:
    DeleteDC(hdcTemp);

LoadExit:
    return (bWorked);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetRGBValues
//
//  This sets the various system colors in static variables.  It's
//  called at init time and when system colors change.
//
////////////////////////////////////////////////////////////////////////////

void SetRGBValues()
{
    rgbWindowColor = GetSysColor(COLOR_WINDOW);
    rgbHiliteColor = GetSysColor(COLOR_HIGHLIGHT);
    rgbWindowText  = GetSysColor(COLOR_WINDOWTEXT);
    rgbHiliteText  = GetSysColor(COLOR_HIGHLIGHTTEXT);
    rgbGrayText    = GetSysColor(COLOR_GRAYTEXT);
}


////////////////////////////////////////////////////////////////////////////
//
//  FSetUpFile
//
//  This loads in the resources & initializes the data used by the
//  file dialogs.
//
//  Returns:  TRUE    if successful
//            FALSE   if any bitmap fails
//
////////////////////////////////////////////////////////////////////////////

BOOL FSetUpFile()
{
    if (cLock++)
    {
        return (TRUE);
    }

    SetRGBValues();

    return (LoadDirDriveBitmap());
}


////////////////////////////////////////////////////////////////////////////
//
//  GetPathOffset
//
////////////////////////////////////////////////////////////////////////////

int GetPathOffset(
    LPTSTR lpszDir)
{
    LPTSTR lpszSkipRoot;

    if (!lpszDir || !*lpszDir)
    {
        return (-1);
    }

    lpszSkipRoot = PathSkipRoot(lpszDir);

    if (lpszSkipRoot)
    {
        return (int)((lpszSkipRoot - 1) - lpszDir);
    }
    else
    {
        //
        //  Unrecognized format.
        //
        return (-1);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  FileOpenCmd
//
//  Handles WM_COMMAND for Open & Save dlgs.
//
//  edt1 = file name
//  lst1 = list of files in current directory matching current pattern
//  cmb1 = lists file patterns
//  stc1 = is current directory
//  lst2 = lists directories on current drive
//  cmb2 = lists drives
//  IDOK = is Open pushbutton
//  IDCANCEL = is Cancel pushbutton
//  chx1 = is for opening read only files
//
//  Returns the normal dialog proc values.
//
////////////////////////////////////////////////////////////////////////////

BOOL FileOpenCmd(
    HANDLE hDlg,
    WPARAM wParam,
    LPARAM lParam,
    POPENFILEINFO pOFI,
    BOOL bSave)
{
    LPOPENFILENAME pOFN;
    LPTSTR pch, pch2;
    WORD i, sCount, len;
    LRESULT wFlag;
    BOOL bRet, bHookRet;
    TCHAR szText[MAX_FULLPATHNAME];
    HWND hwnd;
    LPCURDLG  lpCurDlg;


    if (!pOFI)
    {
        return (FALSE);
    }

    pOFN = pOFI->pOFN;
    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
        case ( IDOK ) :
        {
#ifdef UNICODE
            //
            //  Apps that side-effect this message may not have their
            //  internal unicode strings updated (eg. Corel Mosaic).
            //
            //  NOTE: Must preserve the internal flags.
            //
            if (pOFI->ApiType == COMDLG_ANSI)
            {
                DWORD InternalFlags = pOFN->Flags & OFN_ALL_INTERNAL_FLAGS;

                ThunkOpenFileNameA2W(pOFI);

                pOFN->Flags |= InternalFlags;
            }
#endif
            //
            //  If the focus is on the directory box, or if the selection
            //  within the box has changed since the last listing, give a
            //  new listing.
            //
            if (bChangeDir || ((GetFocus() == GetDlgItem(hDlg, lst2)) &&
                               (pOFN->Flags & OFN_DIRSELCHANGED)))
            {
                bChangeDir = FALSE;
                goto ChangingDir;
            }
            else if ((GetFocus() == (hwnd = GetDlgItem(hDlg, cmb2))) &&
                     (pOFN->Flags & OFN_DRIVEDOWN))
            {
                //
                //  If the focus is on the drive or filter combobox, give
                //  a new listing.
                //
                SendDlgItemMessage(hDlg, cmb2, CB_SHOWDROPDOWN, FALSE, 0L);
                break;
            }
            else if ((GetFocus() == (hwnd = GetDlgItem(hDlg, cmb1))) &&
                     (pOFN->Flags & OFN_FILTERDOWN))
            {
                SendDlgItemMessage(hDlg, cmb1, CB_SHOWDROPDOWN, FALSE, 0L);
                lParam = (LPARAM)hwnd;
                goto ChangingFilter;
            }
            else
            {
#ifdef UNICODE
                //
                //  Visual Basic passes in an uninitialized lpstrDefExt string.
                //  Since we only have to use it in OKButtonPressed, update
                //  lpstrDefExt here along with whatever else is only needed
                //  in OKButtonPressed.
                //
                if (pOFI->ApiType == COMDLG_ANSI)
                {
                    ThunkOpenFileNameA2WDelayed(pOFI);
                }
#endif
                if (OKButtonPressed(hDlg, pOFI, bSave))
                {
                    bRet = TRUE;

                    if (pOFN->lpstrFile)
                    {
                        if (!(pOFN->Flags & OFN_NOVALIDATE))
                        {
                            if (pOFN->nMaxFile >= 3)
                            {
                                if ((pOFN->lpstrFile[0] == 0) ||
                                    (pOFN->lpstrFile[1] == 0) ||
                                    (pOFN->lpstrFile[2] == 0))
                                {
                                    bRet = FALSE;
                                    StoreExtendedError(FNERR_BUFFERTOOSMALL);
                                }
                            }
                            else
                            {
                                bRet = FALSE;
                                StoreExtendedError(FNERR_BUFFERTOOSMALL);
                            }
                        }
                    }

                    goto AbortDialog;
                }
            }

            SendDlgItemMessage(hDlg, edt1, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
            return (TRUE);

            break;
        }
        case ( IDCANCEL ) :
        {
            bRet = FALSE;
            bUserPressedCancel = TRUE;
            goto AbortDialog;
        }
        case ( IDABORT ) :
        {
            bRet = (BYTE)lParam;
AbortDialog:
            //
            //  Return the most recently used filter.
            //
            pOFN->nFilterIndex = (WORD)SendDlgItemMessage( hDlg,
                                                           cmb1,
                                                           CB_GETCURSEL,
                                                           (WPARAM)0,
                                                           (LPARAM)0 );
            if (pOFN->lpstrCustomFilter)
            {
                len = (WORD)(lstrlen(pOFN->lpstrCustomFilter) + 1);
                sCount = (WORD)lstrlen(pOFI->szLastFilter);
                if (pOFN->nMaxCustFilter > (DWORD)(sCount + len))
                {
                    lstrcpy(pOFN->lpstrCustomFilter + len, pOFI->szLastFilter);
                }
            }

            if (!pOFN->lpstrCustomFilter ||
                (*pOFN->lpstrCustomFilter == CHAR_NULL))
            {
                pOFN->nFilterIndex++;
            }

            if (((GET_WM_COMMAND_ID(wParam, lParam)) == IDOK) && pOFN->lpfnHook)
            {
                LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

#ifdef UNICODE
                if (pOFI->ApiType == COMDLG_ANSI)
                {
                    ThunkOpenFileNameW2A(pOFI);
                    bHookRet = (*lpfnHook)( hDlg,
                                            msgFILEOKA,
                                            0,
                                            (LPARAM)pOFI->pOFNA );
                    //
                    //  For apps that side-effect pOFNA stuff and expect it to
                    //  be preserved through dialog exit, update internal
                    //  struct after the hook proc is called.
                    //
                    ThunkOpenFileNameA2W(pOFI);
                }
                else
#endif
                {
                    bHookRet = (*lpfnHook)( hDlg,
                                            msgFILEOKW,
                                            0,
                                            (LPARAM)pOFI->pOFN );
                }
                if (bHookRet)
                {
                    HourGlass(FALSE);
                    break;
                }
            }

            if (pOFN->Flags & OFN_ALLOWMULTISELECT)
            {
                LocalShrink((HANDLE)0, 0);
            }

            wNoRedraw = 0;

            if (pOFI->pOFN->Flags & OFN_ENABLEHOOK)
            {
                LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

                glpfnFileHook = lpfnHook;
            }

            RemoveProp(hDlg, FILEPROP);

            EndDialog(hDlg, bRet);

            SetAppOpenDir();

            if (pOFI)
            {
                if ((pOFN->Flags & OFN_NOCHANGEDIR) && *pOFI->szCurDir)
                {
                    ChangeDir(hDlg, pOFI->szCurDir, TRUE, FALSE);
                }
            }

            //
            //  ISSUE:
            //  If the app subclasses ID_ABORT, the worker thread will never
            //  get exited.  This will cause problems.  Currently, there are
            //  no apps that do this, though.
            //

            return (TRUE);
            break;
        }
        case ( edt1 ) :
        {
            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
            {
                int iIndex, iCount;
                HWND hLBox = GetDlgItem(hDlg, lst1);
                WORD wIndex = (WORD)SendMessage(hLBox, LB_GETCARETINDEX, 0, 0);

                szText[0] = CHAR_NULL;

                if (wIndex == (WORD)LB_ERR)
                {
                    break;
                }

                SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                             WM_GETTEXT,
                             (WPARAM)MAX_FULLPATHNAME,
                             (LPARAM)szText );

                if ((iIndex = (int)SendMessage( hLBox,
                                                LB_FINDSTRING,
                                                (WPARAM)(wIndex - 1),
                                                (LPARAM)szText )) != LB_ERR)
                {
                    RECT rRect;

                    iCount = (int)SendMessage(hLBox, LB_GETTOPINDEX, 0, 0L);
                    GetClientRect(hLBox, (LPRECT)&rRect);

                    if ((iIndex < iCount) ||
                        (iIndex >= (iCount + rRect.bottom / dyText)))
                    {
                        SendMessage(hLBox, LB_SETCARETINDEX, (WPARAM)iIndex, 0);
                        SendMessage(hLBox, LB_SETTOPINDEX, (WPARAM)iIndex, 0);
                    }
                }
                return (TRUE);
            }
            break;
        }
        case ( lst1 ) :
        {
            //
            //  A double click means OK.
            //
            if (GET_WM_COMMAND_CMD(wParam, lParam)== LBN_DBLCLK)
            {
                SendMessage(hDlg, WM_COMMAND, GET_WM_COMMAND_MPS(IDOK, 0, 0));
                return (TRUE);
            }
            else if (pOFN && (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE))
            {
                if (pOFN->Flags & OFN_ALLOWMULTISELECT)
                {
                    int *pSelIndex;

                    //
                    //  Muliselection allowed.
                    //
                    sCount = (SHORT)SendMessage(GET_WM_COMMAND_HWND(wParam, lParam),
                                                LB_GETSELCOUNT,
                                                0,
                                                0L );
                    if (!sCount)
                    {
                        //
                        //  If nothing selected, clear edit control.
                        //
                        SetDlgItemText(hDlg, edt1, szNull);
                    }
                    else
                    {
                        DWORD cchMemBlockSize = 2048;
                        DWORD cchTotalLength = 0;

                        pSelIndex = (int *)LocalAlloc(LPTR, sCount * sizeof(int));
                        if (!pSelIndex)
                        {
                            goto LocalFailure1;
                        }

                        sCount = (SHORT)SendMessage(
                                            GET_WM_COMMAND_HWND(wParam, lParam),
                                            LB_GETSELITEMS,
                                            (WPARAM)sCount,
                                            (LONG_PTR)(LPTSTR)pSelIndex );

                        pch2 = pch = (LPTSTR)
                             LocalAlloc(LPTR, cchMemBlockSize * sizeof(TCHAR));
                        if (!pch)
                        {
                            goto LocalFailure2;
                        }

                        for (*pch = CHAR_NULL, i = 0; i < sCount; i++)
                        {
                            len = (WORD)SendMessage(
                                            GET_WM_COMMAND_HWND(wParam, lParam),
                                            LB_GETTEXTLEN,
                                            (WPARAM)(*(pSelIndex + i)),
                                            (LPARAM)0 );

                            //
                            //  Add the length of the selected file to the
                            //  total length of selected files. + 2 for the
                            //  space that goes in between files and for the
                            //  possible dot added at the end of the filename
                            //  if the file does not have an extension.
                            //
                            cchTotalLength += (len + 2);

                            if (cchTotalLength > cchMemBlockSize)
                            {
                                LPTSTR pTemp;
                                UINT cchPrevLen = cchTotalLength - (len + 2);

                                cchMemBlockSize = cchMemBlockSize << 1;
                                pTemp = (LPTSTR)LocalReAlloc(
                                                 pch,
                                                 cchMemBlockSize * sizeof(TCHAR),
                                                 LMEM_MOVEABLE );
                                if (pTemp)
                                {
                                    pch = pTemp;
                                    pch2 = pch + cchPrevLen;
                                }
                                else
                                {
                                    LocalFree(pch);
                                    goto LocalFailure2;
                                }

                            }

                            SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                                         LB_GETTEXT,
                                         (WPARAM)(*(pSelIndex + i)),
                                         (LONG_PTR)pch2 );

                            if (!StrChr(pch2, CHAR_DOT))
                            {
                                *(pch2 + len++) = CHAR_DOT;
                            }

                            pch2 += len;
                            *pch2++ = CHAR_SPACE;
                        }
                        if (pch2 != pch)
                        {
                            *--pch2 = CHAR_NULL;
                        }

                        SetDlgItemText(hDlg, edt1, pch);
                        LocalFree((HANDLE)pch);
LocalFailure2:
                        LocalFree((HANDLE)pSelIndex);
                    }
LocalFailure1:
                    if (pOFN->lpfnHook)
                    {
                        i = (WORD)SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                                               LB_GETCARETINDEX,
                                               0,
                                               0L );
                        if (!(i & 0x8000))
                        {
                            wFlag = (SendMessage(
                                         GET_WM_COMMAND_HWND(wParam, lParam),
                                         LB_GETSEL,
                                         (WPARAM)i,
                                         0L )
                                     ? CD_LBSELADD
                                     : CD_LBSELSUB);
                        }
                        else
                        {
                            wFlag = CD_LBSELNOITEMS;
                        }
                    }
                }
                else
                {
                    //
                    //  Multiselection is not allowed.
                    //  Put the file name in the edit control.
                    //
                    szText[0] = CHAR_NULL;

                    i = (WORD)SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                                           LB_GETCURSEL,
                                           0,
                                           0L );

                    if (i != (WORD)LB_ERR)
                    {
                        i = (WORD)SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                                               LB_GETTEXT,
                                               (WPARAM)i,
                                               (LONG_PTR)szText );

                        if (!StrChr(szText, CHAR_DOT))
                        {
                            if (i < MAX_FULLPATHNAME - 1)
                            {
                                szText[i]     = CHAR_DOT;
                                szText[i + 1] = CHAR_NULL;
                            }
                        }

                        if (!bCasePreserved)
                        {
                            CharLower(szText);
                        }

                        SetDlgItemText(hDlg, edt1, szText);
                        if (pOFN->lpfnHook)
                        {
                            i = (WORD)SendMessage(
                                          GET_WM_COMMAND_HWND(wParam, lParam),
                                          LB_GETCURSEL,
                                          0,
                                          0L );
                            wFlag = CD_LBSELCHANGE;
                        }
                    }
                }

                if (pOFN->lpfnHook)
                {
                    LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

#ifdef UNICODE
                    if (pOFI->ApiType == COMDLG_ANSI)
                    {
                        (*lpfnHook)( hDlg,
                                     msgLBCHANGEA,
                                     lst1,
                                     MAKELONG(i, wFlag) );
                    }
                    else
#endif
                    {
                        (*lpfnHook)( hDlg,
                                     msgLBCHANGEW,
                                     lst1,
                                     MAKELONG(i, wFlag) );
                    }
                }

                SendDlgItemMessage(hDlg, edt1, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                return (TRUE);
            }
            break;
        }
        case ( cmb1 ) :
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
                case ( CBN_DROPDOWN ) :
                {
                    if (wWinVer >= 0x030A)
                    {
                        pOFN->Flags |= OFN_FILTERDOWN;
                    }
                    return (TRUE);
                    break;
                }
                case ( CBN_CLOSEUP ) :
                {
                    PostMessage( hDlg,
                                 WM_COMMAND,
                                 GET_WM_COMMAND_MPS(cmb1, lParam, MYCBN_DRAW) );

                    return (TRUE);
                    break;
                }
                case ( CBN_SELCHANGE ) :
                {
                    //
                    //  Need to change the file listing in lst1.
                    //
                    if (pOFN->Flags & OFN_FILTERDOWN)
                    {
                        return (TRUE);
                        break;
                    }
                }
                case ( MYCBN_DRAW ) :
                {
                    SHORT nIndex;
                    LPCTSTR lpFilter;

                    HourGlass(TRUE);

                    pOFN->Flags &= ~OFN_FILTERDOWN;
ChangingFilter:
                    nIndex = (SHORT)SendDlgItemMessage( hDlg,
                                                        cmb1,
                                                        CB_GETCURSEL,
                                                        0,
                                                        0L );
                    if (nIndex < 0)
                    {
                        //
                        //  No current selection.
                        //
                        break;
                    }

                    //
                    //  Must also check if filter contains anything.
                    //
                    if (nIndex ||
                        !(pOFN->lpstrCustomFilter && *pOFN->lpstrCustomFilter))
                    {
                        lpFilter = pOFN->lpstrFilter +
                                   SendDlgItemMessage( hDlg,
                                                       cmb1,
                                                       CB_GETITEMDATA,
                                                       (WPARAM)nIndex,
                                                       0L );
                    }
                    else
                    {
                        lpFilter = pOFN->lpstrCustomFilter +
                                   lstrlen(pOFN->lpstrCustomFilter) + 1;
                    }
                    if (*lpFilter)
                    {
                        GetDlgItemText( hDlg,
                                        edt1,
                                        szText,
                                        MAX_FULLPATHNAME - 1 );
                        bRet = (!szText[0] ||
                                (StrChr(szText, CHAR_STAR)) ||
                                (StrChr(szText, CHAR_QMARK)));
                        lstrcpy(szText, lpFilter);
                        if (bRet)
                        {
                            CharLower(szText);
                            SetDlgItemText(hDlg, edt1, szText);
                            SendDlgItemMessage( hDlg,
                                                edt1,
                                                EM_SETSEL,
                                                (WPARAM)0,
                                                (LPARAM)-1 );
                        }
                        FListAll(pOFI, hDlg, szText);
                        if (!bInitializing)
                        {
                            lstrcpy(pOFI->szLastFilter, szText);
#ifdef WINNT
                            //
                            //  Provide dynamic lpstrDefExt updating
                            //  when lpstrDefExt is user initialized.
                            //
                            if (StrChr((LPTSTR)lpFilter, CHAR_DOT) &&
                                pOFN->lpstrDefExt)
                            {
                                DWORD cbLen = MIN_DEFEXT_LEN - 1; // only 1st 3
                                LPTSTR lpTemp = (LPTSTR)(pOFN->lpstrDefExt);

                                while (*lpFilter++ != CHAR_DOT);
                                if (!(StrChr((LPTSTR)lpFilter, CHAR_STAR)) &&
                                    !(StrChr((LPTSTR)lpFilter, CHAR_QMARK)))
                                {
                                    while (cbLen--)
                                    {
                                        *lpTemp++ = *lpFilter++;
                                    }
                                    *lpTemp = CHAR_NULL;
                                }
                            }
#endif
                        }
                    }
                    if (pOFN->lpfnHook)
                    {
                        LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);
#ifdef UNICODE
                        if (pOFI->ApiType == COMDLG_ANSI)
                        {
                            (*lpfnHook)( hDlg,
                                         msgLBCHANGEA,
                                         cmb1,
                                         MAKELONG(nIndex, CD_LBSELCHANGE) );
                        }
                        else
#endif
                        {
                            (*lpfnHook)( hDlg,
                                         msgLBCHANGEW,
                                         cmb1,
                                         MAKELONG(nIndex, CD_LBSELCHANGE) );
                        }
                    }
                    HourGlass(FALSE);
                    return (TRUE);

                    break;
                }

                default :
                {
                    break;
                }
            }
            break;
        }
        case ( lst2 ) :
        {
            if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE)
            {
                if (!(pOFN->Flags & OFN_DIRSELCHANGED))
                {
                    if ((DWORD)SendDlgItemMessage( hDlg,
                                                   lst2,
                                                   LB_GETCURSEL,
                                                   0,
                                                   0L ) != pOFI->idirSub - 1)
                    {
                        StripFileName(hDlg, IS16BITWOWAPP(pOFN));
                        pOFN->Flags |= OFN_DIRSELCHANGED;
                    }
                }
                return (TRUE);
            }
            else if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SETFOCUS)
            {
                EnableWindow(GetDlgItem(hDlg, IDOK), TRUE);
                SendMessage( GetDlgItem(hDlg, IDCANCEL),
                             BM_SETSTYLE,
                             (WPARAM)BS_PUSHBUTTON,
                             (LPARAM)TRUE );
            }
            else if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_KILLFOCUS)
            {
                if (pOFN && (pOFN->Flags & OFN_DIRSELCHANGED))
                {
                    pOFN->Flags &= ~OFN_DIRSELCHANGED;
                }
                else
                {
                    bChangeDir = FALSE;
                }
            }
            else if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_DBLCLK)
            {
                TCHAR szNextDir[CCHNETPATH];
                LPTSTR lpCurDir;
                DWORD idir;
                DWORD idirNew;
                int cb;
                LPTSTR pstrPath;
ChangingDir:
                bChangeDir = FALSE;
                pOFN->Flags &= ~OFN_DIRSELCHANGED;
                idirNew = (DWORD)SendDlgItemMessage( hDlg,
                                                     lst2,
                                                     LB_GETCURSEL,
                                                     0,
                                                     0L );
                //
                //  Can use relative path name.
                //
                *pOFI->szPath = 0;
                if (idirNew >= pOFI->idirSub)
                {
                    cb = (int) SendDlgItemMessage( hDlg,
                                                   lst2,
                                                   LB_GETTEXT,
                                                   (WPARAM)idirNew,
                                                   (LPARAM)pOFI->szPath );
                    //
                    //  sanity check
                    //
                    if (!(lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg)) ||
                        !(lpCurDir = lpCurDlg->lpstrCurDir))
                    {
                        break;
                    }

                    lstrcpy(szNextDir, lpCurDir);

                    //
                    //  Fix phenom with c:\\foobar - because of inconsistency
                    //  in directory display guaranteed to have a valid
                    //  lpCurDir here, right?
                    //
                    PathAddBackslash(szNextDir);
                    lstrcat(szNextDir, pOFI->szPath);

                    pstrPath = szNextDir;

                    idirNew = pOFI->idirSub;    // for msgLBCHANGE message
                }
                else
                {
                    //
                    //  Need full path name.
                    //
                    cb = (int) SendDlgItemMessage( hDlg,
                                                   lst2,
                                                   LB_GETTEXT,
                                                   0,
                                                   (LPARAM)pOFI->szPath );

                    //
                    //  The following condition is necessary because wb displays
                    //  \\server\share (the disk resource name) for unc, but
                    //  for root paths (eg. c:\) for device conns, this in-
                    //  consistency is hacked around here and in FillOutPath.
                    //
                    if (DBL_BSLASH(pOFI->szPath))
                    {
                        lstrcat(pOFI->szPath, TEXT("\\"));
                        cb++;
                    }

                    for (idir = 1; idir <= idirNew; ++idir)
                    {
                        cb += (int) SendDlgItemMessage(
                                             hDlg,
                                             lst2,
                                             LB_GETTEXT,
                                             (WPARAM)idir,
                                             (LPARAM)&pOFI->szPath[cb] );

                        pOFI->szPath[cb++] = CHAR_BSLASH;
                    }

                    //
                    //  The root is a special case.
                    //
                    if (idirNew)
                    {
                        pOFI->szPath[cb - 1] = CHAR_NULL;
                    }

                    pstrPath = pOFI->szPath;
                }

                if (!*pstrPath ||
                    (ChangeDir(hDlg, pstrPath, FALSE, TRUE) == CHANGEDIR_FAILED))
                {
                    break;
                }

                //
                //  List all directories under this one.
                //
                UpdateListBoxes(hDlg, pOFI, NULL, mskDirectory);

                if (pOFN->lpfnHook)
                {
                    LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);
#ifdef UNICODE
                    if (pOFI->ApiType == COMDLG_ANSI)
                    {
                        (*lpfnHook)( hDlg,
                                     msgLBCHANGEA,
                                     lst2,
                                     MAKELONG(LOWORD(idirNew), CD_LBSELCHANGE) );
                    }
                    else
#endif
                    {
                        (*lpfnHook)( hDlg,
                                     msgLBCHANGEW,
                                     lst2,
                                     MAKELONG(LOWORD(idirNew), CD_LBSELCHANGE) );
                    }
                }
                return (TRUE);
            }
            break;
        }
        case ( cmb2 ) :
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
                case ( CBN_DROPDOWN ) :
                {
                    pOFN->Flags |= OFN_DRIVEDOWN;

                    return (TRUE);
                    break;
                }
                case ( CBN_CLOSEUP ) :
                {
                    //
                    //  It would seem reasonable to merely do the update
                    //  at this point, but that would rely on message
                    //  ordering, which isnt a smart move.  In fact, if
                    //  you hit ALT-DOWNARROW, DOWNARROW, ALT-DOWNARROW,
                    //  you receive CBN_DROPDOWN, CBN_SELCHANGE, and then
                    //  CBN_CLOSEUP.  But if you use the mouse to choose
                    //  the same element, the last two messages trade
                    //  places.  PostMessage allows all messages in the
                    //  sequence to be processed, and then updates are
                    //  done as needed.
                    //
                    PostMessage( hDlg,
                                 WM_COMMAND,
                                 GET_WM_COMMAND_MPS(
                                     cmb2,
                                     GET_WM_COMMAND_HWND(wParam, lParam),
                                     MYCBN_DRAW ) );
                    return (TRUE);
                    break;
                }
                case ( MYCBN_LIST ) :
                {
                    LoadDrives(hDlg);
                    break;
                }
                case ( MYCBN_REPAINT ) :
                {
                    int cchCurDir;
                    LPTSTR lpCurDir;

                    // sanity
                    if (!(lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg)) ||
                        !(lpCurDir = lpCurDlg->lpstrCurDir))
                    {
                        break;
                    }

                    cchCurDir = GetPathOffset(lpCurDir);
                    if (cchCurDir != -1)
                    {
                        TCHAR szRepaintDir[CCHNETPATH];
                        HWND hCmb2 = (HWND)lParam;

                        lstrcpy(szRepaintDir, lpCurDir);
                        szRepaintDir[cchCurDir] = CHAR_NULL;
                        SendMessage( hCmb2,
                                     CB_SELECTSTRING,
                                     (WPARAM)-1,
                                     (LPARAM)szRepaintDir );
                    }
                    break;
                }
                case ( CBN_SELCHANGE ) :
                {
                    StripFileName(hDlg, IS16BITWOWAPP(pOFN));

                    //
                    //  Version check not needed, since flag never set
                    //  for versions not supporting CBN_CLOSEUP. Putting
                    //  check at CBN_DROPDOWN is more efficient since it
                    //  is less frequent than CBN_SELCHANGE.

                    if (pOFN->Flags & OFN_DRIVEDOWN)
                    {
                        //
                        //  Don't fill lst2 while the combobox is down.
                        //
                        return (TRUE);
                        break;
                    }
                }
                case ( MYCBN_CHANGEDIR ) :
                case ( MYCBN_DRAW ) :
                {
                    TCHAR szTitle[WARNINGMSGLENGTH];
                    LPTSTR lpFilter;
                    int nDiskInd, nInd;
                    DWORD dwType;
                    LPTSTR lpszPath = NULL;
                    LPTSTR lpszDisk = NULL;
                    HWND hCmb2;
                    OFN_DISKINFO *pofndiDisk = NULL;
                    static szDrawDir[CCHNETPATH];
                    int nRet;

                    HourGlass(TRUE);

                    //
                    //  Clear Flag for future CBN_SELCHANGE messeges.
                    //
                    pOFN->Flags &= ~OFN_DRIVEDOWN;

                    //
                    //  Change the drive.
                    //
                    szText[0] = CHAR_NULL;

                    hCmb2 = (HWND)lParam;

                    if (hCmb2 != NULL)
                    {
                        nInd = (int) SendMessage(hCmb2, CB_GETCURSEL, 0, 0L);

                        if (nInd != CB_ERR)
                        {
                            SendMessage( hCmb2,
                                         CB_GETLBTEXT,
                                         nInd,
                                         (LPARAM)(LPTSTR)szDrawDir );
                        }

                        if ((nInd == CB_ERR) || ((INT_PTR)pofndiDisk == CB_ERR))
                        {
                            if (lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg))
                            {
                                if (lpCurDlg->lpstrCurDir)
                                {
                                    lstrcpy((LPTSTR)szDrawDir,
                                            lpCurDlg->lpstrCurDir);
                                }
                            }
                        }

                        CharLower((LPTSTR)szDrawDir);

                        //
                        //  Should always succeed.
                        //
                        nDiskInd = DiskAddedPreviously(0, (LPTSTR)szDrawDir);
                        if (nDiskInd != 0xFFFFFFFF)
                        {
                            pofndiDisk = &gaDiskInfo[nDiskInd];
                        }
                        else
                        {
                            //
                            //  Skip update in the case where it fails.
                            //
                            return (TRUE);
                        }

                        dwType = pofndiDisk->dwType;

                        lpszDisk = pofndiDisk->lpPath;
                    }

                    if ((GET_WM_COMMAND_CMD(wParam, lParam)) == MYCBN_CHANGEDIR)
                    {
                        if (lpNetDriveSync)
                        {
                            lpszPath = lpNetDriveSync;
                            lpNetDriveSync = NULL;
                        }
                        else
                        {
                            if (lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg))
                            {
                                if (lpCurDlg->lpstrCurDir)
                                {
                                    lstrcpy((LPTSTR)szDrawDir,
                                            lpCurDlg->lpstrCurDir);

                                    lpszPath = (LPTSTR)szDrawDir;
                                }
                            }
                        }
                    }
                    else
                    {
                        lpszPath = lpszDisk;
                    }

                    if (bInitializing)
                    {
                        lpFilter = szTitle;
                        if (pOFN->lpstrFile &&
                            (StrChr(pOFN->lpstrFile, CHAR_STAR) ||
                             StrChr(pOFN->lpstrFile, CHAR_QMARK)))
                        {
                            lstrcpy(lpFilter, pOFN->lpstrFile);
                        }
                        else
                        {
                            HWND hcmb1 = GetDlgItem(hDlg, cmb1);

                            nInd = (int) SendMessage(hcmb1, CB_GETCURSEL, 0, 0L);
                            if (nInd == CB_ERR)
                            {
                                //
                                //  No current selection.
                                //
                                goto NullSearch;
                            }

                            //
                            //  Must also check if filter contains anything.
                            //
                            if (nInd ||
                                !(pOFN->lpstrCustomFilter &&
                                  *pOFN->lpstrCustomFilter))
                            {
                                lpFilter = (LPTSTR)(pOFN->lpstrFilter);
                                lpFilter += SendMessage( hcmb1,
                                                         CB_GETITEMDATA,
                                                         (WPARAM)nInd,
                                                         0 );
                            }
                            else
                            {
                                lpFilter = pOFN->lpstrCustomFilter;
                                lpFilter += lstrlen(pOFN->lpstrCustomFilter) + 1;
                            }
                        }
                    }
                    else
                    {
NullSearch:
                        lpFilter = NULL;
                    }

                    //
                    //  UpdateListBoxes cuts up filter string in place.
                    //
                    if (lpFilter)
                    {
                        lstrcpy(szTitle, lpFilter);
                        CharLower(szTitle);
                    }

                    if (dwType == REMDRVBMP)
                    {
                        DWORD err = WNetRestoreConnection(hDlg, lpszDisk);

                        if (err != WN_SUCCESS)
                        {
                            HourGlass(FALSE);
                            return (TRUE);
                        }

                        pofndiDisk->dwType = NETDRVBMP;

                        SendMessage(
                            hCmb2,
                            CB_SETITEMDATA,
                            (WPARAM)SendMessage(
                                   hCmb2,
                                   CB_SELECTSTRING,
                                   (WPARAM)-1,
                                   (LPARAM)(LPTSTR)pofndiDisk->lpAbbrName ),
                            (LPARAM)NETDRVBMP );
                    }

                    //
                    //  Calls to ChangeDir will call SelDisk, so no need
                    //  to update cmb2 on our own here (used to be after
                    //  updatelistboxes).
                    //
                    if ((nRet = ChangeDir( hDlg,
                                           lpszPath,
                                           FALSE,
                                           FALSE )) == CHANGEDIR_FAILED)
                    {
                        int mbRet;

                        while (nRet == CHANGEDIR_FAILED)
                        {
                            if (dwType == FLOPPYBMP)
                            {
                                mbRet = InvalidFileWarning(
                                               hDlg,
                                               lpszPath,
                                               ERROR_NO_DISK_IN_DRIVE,
                                               (UINT)(MB_RETRYCANCEL |
                                                      MB_ICONEXCLAMATION) );
                            }
                            else if (dwType == CDDRVBMP)
                            {
                                mbRet = InvalidFileWarning(
                                               hDlg,
                                               lpszPath,
                                               ERROR_NO_DISK_IN_CDROM,
                                               (UINT)(MB_RETRYCANCEL |
                                                      MB_ICONEXCLAMATION) );
                            }
                            else
                            {
                                //
                                //  See if it's a RAW volume.
                                //
                                if (dwType == HARDDRVBMP &&
                                    GetLastError() == ERROR_UNRECOGNIZED_VOLUME)
                                {
                                    mbRet = InvalidFileWarning(
                                                   hDlg,
                                                   lpszPath,
                                                   ERROR_UNRECOGNIZED_VOLUME,
                                                   (UINT)(MB_OK |
                                                          MB_ICONEXCLAMATION) );
                                }
                                else
                                {
                                    mbRet = InvalidFileWarning(
                                                   hDlg,
                                                   lpszPath,
                                                   ERROR_DIR_ACCESS_DENIED,
                                                   (UINT)(MB_RETRYCANCEL |
                                                          MB_ICONEXCLAMATION) );
                                }
                            }

                            if (bFirstTime || (mbRet != IDRETRY))
                            {
                                lpszPath = NULL;
                                nRet = ChangeDir(hDlg, lpszPath, TRUE, FALSE);
                            }
                            else
                            {
                                nRet = ChangeDir(hDlg, lpszPath, FALSE, FALSE);
                            }
                        }
                    }

                    UpdateListBoxes( hDlg,
                                     pOFI,
                                     lpFilter ? szTitle : lpFilter,
                                     (WORD)(mskDrives | mskDirectory) );

                    if (pOFN->lpfnHook)
                    {
                        LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

                        nInd = (int) SendDlgItemMessage( hDlg,
                                                         cmb2,
                                                         CB_GETCURSEL,
                                                         0,
                                                         0 );
#ifdef UNICODE
                        if (pOFI->ApiType == COMDLG_ANSI)
                        {
                            (*lpfnHook)( hDlg,
                                         msgLBCHANGEA,
                                         cmb2,
                                         MAKELONG(LOWORD(nInd),
                                                  CD_LBSELCHANGE) );
                        }
                        else
#endif
                        {
                            (*lpfnHook)( hDlg,
                                         msgLBCHANGEW,
                                         cmb2,
                                         MAKELONG(LOWORD(nInd),
                                                  CD_LBSELCHANGE) );
                        }
                    }

                    HourGlass(FALSE);

                    return (TRUE);

                    break;
                }
                default :
                {
                    break;
                }
            }
            break;
        }
        case ( pshHelp ) :
        {
#ifdef UNICODE
            if (pOFI->ApiType == COMDLG_ANSI)
            {
                if (msgHELPA && pOFN->hwndOwner)
                {
                    SendMessage( pOFN->hwndOwner,
                                 msgHELPA,
                                 (WPARAM)hDlg,
                                 (DWORD_PTR)pOFN );
                }
            }
            else
#endif
            {
                if (msgHELPW && pOFN->hwndOwner)
                {
                    SendMessage( pOFN->hwndOwner,
                                 msgHELPW,
                                 (WPARAM)hDlg,
                                 (DWORD_PTR)pOFN );
                }
            }
            break;
        }
        case ( psh14 ) :
        {
            bGetNetDrivesSync = TRUE;
            if (CallNetDlg(hDlg))
            {
                LNDSetEvent(hDlg);
            }
            else
            {
                bGetNetDrivesSync = FALSE;
            }
            break;
        }
        default :
        {
            break;
        }
    }
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateListBoxes
//
//  Fills out File and Directory List Boxes in a single pass
//  given (potentially) multiple filters
//
//  It assumes the string of extensions are delimited by semicolons.
//
//  hDlg        Handle to File Open/Save dialog
//  pOFI        pointer to OPENFILEINFO structure
//  lpszFilter  pointer to filter, if NULL, use pOFI->szSpecCur
//  wMask       mskDirectory and/or mskDrives, or NULL
//
//  Returns:  TRUE   if match
//            FALSE  if not
//
////////////////////////////////////////////////////////////////////////////

BOOL UpdateListBoxes(
    HWND hDlg,
    POPENFILEINFO pOFI,
    LPTSTR lpszFilter,
    WORD wMask)
{
    LPTSTR lpszF[MAXFILTERS + 1];
    LPTSTR lpszTemp;
    SHORT i, nFilters;
    HWND hFileList = GetDlgItem(hDlg, lst1);
    HWND hDirList = GetDlgItem(hDlg, lst2);
    BOOL bRet = FALSE;
    TCHAR szSpec[MAX_FULLPATHNAME];
    BOOL bDriveChange;
    BOOL bFindAll = FALSE;
    RECT rDirLBox;
    BOOL bLFN;
    HANDLE hff;
    DWORD dwErr;
    WIN32_FIND_DATA FindFileData;
    TCHAR szBuffer[MAX_FULLPATHNAME];       // add one for CHAR_DOT
    WORD wCount;
    LPCURDLG lpCurDlg;


    //
    //  Save the drive bit and then clear it out.
    //
    bDriveChange = wMask & mskDrives;
    wMask &= ~mskDrives;

    if (!lpszFilter)
    {
        GetDlgItemText( hDlg,
                        edt1,
                        lpszFilter = szSpec,
                        MAX_FULLPATHNAME - 1 );

        //
        //  If any directory or drive characters are in there, or if there
        //  are no wildcards, use the default spec.
        //
        if ( StrChr(szSpec, CHAR_BSLASH) ||
             StrChr(szSpec, CHAR_SLASH)  ||
             StrChr(szSpec, CHAR_COLON)  ||
             (!((StrChr(szSpec, CHAR_STAR)) ||
                (StrChr(szSpec, CHAR_QMARK)))) )
        {
            lstrcpy(szSpec, pOFI->szSpecCur);
        }
        else
        {
            lstrcpy(pOFI->szLastFilter, szSpec);
        }
    }

    //
    //  We need to find out what kind of a drive we are running
    //  on in order to determine if spaces are valid in a filename
    //  or not.
    //
    bLFN = IsLFNDriveX(hDlg, TEXT("\0"));

    //
    //  Find the first filter in the string, and add it to the
    //  array.
    //
    if (bLFN)
    {
        lpszF[nFilters = 0] = lstrtok(lpszFilter, szSemiColonTab);
    }
    else
    {
        lpszF[nFilters = 0] = lstrtok(lpszFilter, szSemiColonSpaceTab);
    }

    //
    //  Now we are going to loop through all the filters in the string
    //  parsing the one we already have, and then finding the next one
    //  and starting the loop over again.
    //
    while (lpszF[nFilters] && (nFilters < MAXFILTERS))
    {
        //
        //  Check to see if the first character is a space.
        //  If so, remove the spaces, and save the pointer
        //  back into the same spot.  Why?  because the
        //  FindFirstFile/Next api will _still_ work on
        //  filenames that begin with a space because
        //  they also look at the short names.  The
        //  short names will begin with the same first
        //  real letter as the long filename.  For
        //  example, the long filename is "  my document"
        //  the first letter of this short name is "m",
        //  so searching on "m*.*" or " m*.*" will yield
        //  the same results.
        //
        if (bLFN && (*lpszF[nFilters] == CHAR_SPACE))
        {
            lpszTemp = lpszF[nFilters];
            while ((*lpszTemp == CHAR_SPACE) && *lpszTemp)
            {
                lpszTemp = CharNext(lpszTemp);
            }

            lpszF[nFilters] = lpszTemp;
        }

        //
        //  The original code used to do a CharUpper here to put the
        //  filter strings in upper case.  EG:  *.TXT  However, this
        //  is not a good thing to do for Turkish.  Capital 'i' does
        //  not equal 'I', so the CharUpper is being removed.
        //
        //  CharUpper(lpszF[nFilters]);

        //
        //  Compare the filter with *.*.  If we find *.* then
        //  set the boolean bFindAll, and this will cause the
        //  files listbox to be filled in at the same time the
        //  directories listbox is filled.  This saves time
        //  from walking the directory twice (once for the directory
        //  names and once for the filenames).
        //
        if (!lstrcmpi(lpszF[nFilters], szStarDotStar))
        {
            bFindAll = TRUE;
        }

        //
        //  Now we need to check if this filter is a duplicate
        //  of an already existing filter.
        //
        for (wCount = 0; wCount < nFilters; wCount++)
        {
            //
            //  If we find a duplicate, decrement the current
            //  index pointer by one so that the last location
            //  is written over (thus removing the duplicate),
            //  and break out of this loop.
            //
            if (!lstrcmpi(lpszF[nFilters], lpszF[wCount]))
            {
                nFilters--;
                break;
            }
        }

        //
        //  Ready to move on to the next filter.  Find the next
        //  filter based upon the type of file system we're using.
        //
        if (bLFN)
        {
            lpszF[++nFilters] = lstrtok(NULL, szSemiColonTab);
        }
        else
        {
            lpszF[++nFilters] = lstrtok(NULL, szSemiColonSpaceTab);
        }

        //
        //  In case we found a pointer to NULL, then look for the
        //  next filter.
        //
        while (lpszF[nFilters] && !*lpszF[nFilters])
        {
            if (bLFN)
            {
                lpszF[nFilters] = lstrtok(NULL, szSemiColonTab);
            }
            else
            {
                lpszF[nFilters] = lstrtok(NULL, szSemiColonSpaceTab);
            }
        }
    }

    //
    //  Add NULL terminator only if needed.
    //
    if (nFilters >= MAXFILTERS)
    {
        lpszF[MAXFILTERS] = 0;
    }

    HourGlass(TRUE);

    SendMessage(hFileList, WM_SETREDRAW, FALSE, 0L);
    SendMessage(hFileList, LB_RESETCONTENT, 0, 0L);
    if (wMask & mskDirectory)
    {
        wNoRedraw |= 2;     // HACK!!! WM_SETREDRAW isn't complete
        SendMessage(hDirList, WM_SETREDRAW, FALSE, 0L);

        //
        //  LB_RESETCONTENT causes InvalidateRect(hDirList, 0, TRUE) to be
        //  sent as well as repositioning the scrollbar thumb and drawing
        //  it immediately.  This causes flicker when the LB_SETCURSEL is
        //  made, as it clears out the listbox by erasing the background of
        //  each item.
        //
        SendMessage(hDirList, LB_RESETCONTENT, 0, 0L);
    }

    //
    //  Always open enumeration for *.*
    //
    lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);
    SetCurrentDirectory(lpCurDlg ? lpCurDlg->lpstrCurDir : NULL);
    hff = FindFirstFile(szStarDotStar, &FindFileData);

    if ( hff == INVALID_HANDLE_VALUE)
    {
        //
        //  Error.  Call GetLastError to determine what happened.
        //
        dwErr = GetLastError();

        //
        //  With the ChangeDir logic handling AccessDenied for cds,
        //  if we are not allowed to enum files, that's ok, just get out.
        //
        if (dwErr == ERROR_ACCESS_DENIED)
        {
            wMask = mskDirectory;
            goto Func4EFailure;
        }

        //
        //  For bad path of bad filename.
        //
        if (dwErr != ERROR_FILE_NOT_FOUND)
        {
            wMask = mskDrives;
            goto Func4EFailure;
        }
    }

    //
    //  A listing was made, even if empty.
    //
    bRet = TRUE;
    wMask &= mskDirectory;

    //
    //  GetLastError says no more files.
    //
    if (hff == INVALID_HANDLE_VALUE  && dwErr == ERROR_FILE_NOT_FOUND)
    {
        //
        //  Things went well, but there are no files.
        //
        goto NoMoreFilesFound;
    }

    do
    {
        if (pOFI->pOFN->Flags & OFN_NOLONGNAMES)
        {
#ifdef UNICODE
            UNICODE_STRING Name;
            BOOLEAN fSpace = FALSE;

            RtlInitUnicodeString(&Name, FindFileData.cFileName);
            if (RtlIsNameLegalDOS8Dot3(&Name, NULL, &fSpace) && !fSpace)
            {
                //
                //  Legal 8.3 name and no spaces, so use the principal
                //  file name.
                //
                lstrcpy(szBuffer, (LPTSTR)FindFileData.cFileName);
            }
            else
#endif
            {
#ifdef WINNT
                if (FindFileData.cAlternateFileName[0] == CHAR_NULL)
                {
                    continue;
                }

                //
                //  Use the alternate file name.
                //
                lstrcpy(szBuffer, (LPTSTR)FindFileData.cAlternateFileName);
#else
                if (FindFileData.cAlternateFileName[0])
                {
                    //
                    //  Use the alternate file name.
                    //
                    lstrcpy(szBuffer, (LPTSTR)FindFileData.cAlternateFileName);
                }
                else
                {
                    //
                    //  Use the main file name.
                    //
                    lstrcpy(szBuffer, (LPTSTR)FindFileData.cFileName);
                }
#endif
            }
        }
        else
        {
            lstrcpy(szBuffer, (LPTSTR)FindFileData.cFileName);
        }

        if ((FindFileData.dwFileAttributes & EXCLBITS))
        {
            continue;
        }

        if ((pOFI->pOFN->Flags & OFN_ALLOWMULTISELECT))
        {
            if (StrChr(szBuffer, CHAR_SPACE))
            {
                //
                //  HPFS does not support alternate filenames
                //  for multiselect, bump all spacey filenames.
                //
                if (FindFileData.cAlternateFileName[0] == CHAR_NULL)
                {
                    continue;
                }

                lstrcpy(szBuffer, (LPTSTR)FindFileData.cAlternateFileName);
            }
        }

        if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            if (wMask & mskDirectory)
            {
                //
                //  Don't include the subdirectories "." and "..".
                //
                if (szBuffer[0] == CHAR_DOT)
                {
                    if ((szBuffer[1] == CHAR_NULL) ||
                        ((szBuffer[1] == CHAR_DOT) && (szBuffer[2] == CHAR_NULL)))
                    {
                        continue;
                    }
                }
                if (!bCasePreserved)
                {
                    CharLower(szBuffer);
                }
                i = (WORD)SendMessage( hDirList,
                                       LB_ADDSTRING,
                                       0,
                                       (DWORD_PTR)szBuffer );
            }
        }
        else if (bFindAll)
        {
            if (!bCasePreserved)
            {
                CharLower(szBuffer);
            }

            SendMessage(hFileList, LB_ADDSTRING, 0, (DWORD_PTR)szBuffer);
        }
    } while (FindNextFile(hff, &FindFileData));

    if (hff == INVALID_HANDLE_VALUE)
    {
        goto Func4EFailure;
    }

    FindClose(hff);

    if (!bFindAll)
    {
        for (i = 0; lpszF[i]; i++)
        {
            if (!lstrcmpi(lpszF[i], szStarDotStar))
            {
                continue;
            }

            //
            //  Find First for each filter.
            //
            hff = FindFirstFile(lpszF[i], &FindFileData);

            if (hff == INVALID_HANDLE_VALUE)
            {
                DWORD dwErr = GetLastError();

                if ((dwErr == ERROR_FILE_NOT_FOUND) ||
                    (dwErr == ERROR_INVALID_NAME))
                {
                    //
                    //  Things went well, but there are no files.
                    //
                    continue;
                }
                else
                {
                    wMask = mskDrives;
                    goto Func4EFailure;
                }
            }

            do
            {
                if (pOFI->pOFN->Flags & OFN_NOLONGNAMES)
                {
#ifdef UNICODE
                    UNICODE_STRING Name;
                    BOOLEAN fSpace = FALSE;

                    RtlInitUnicodeString(&Name, FindFileData.cFileName);
                    if (RtlIsNameLegalDOS8Dot3(&Name, NULL, &fSpace) && !fSpace)
                    {
                        //
                        //  Legal 8.3 name and no spaces, so use the principal
                        //  file name.
                        //
                        lstrcpy(szBuffer, (LPTSTR)FindFileData.cFileName);
                    }
                    else
#endif
                    {
#ifdef WINNT
                        if (FindFileData.cAlternateFileName[0] == CHAR_NULL)
                        {
                            continue;
                        }

                        //
                        //  Use the alternate file name.
                        //
                        lstrcpy( szBuffer,
                                 (LPTSTR)FindFileData.cAlternateFileName );
#else
                        if (FindFileData.cAlternateFileName[0])
                        {
                            //
                            //  Use the alternate file name.
                            //
                            lstrcpy( szBuffer,
                                     (LPTSTR)FindFileData.cAlternateFileName );
                        }
                        else
                        {
                            //
                            //  Use the main file name.
                            //
                            lstrcpy(szBuffer, (LPTSTR)FindFileData.cFileName);
                        }
#endif
                    }
                }
                else
                {
                    lstrcpy(szBuffer, (LPTSTR)FindFileData.cFileName);

                    if (pOFI->pOFN->Flags & OFN_ALLOWMULTISELECT)
                    {
                        if (StrChr(szBuffer, CHAR_SPACE))
                        {
                            //
                            //  HPFS does not support alternate filenames
                            //  for multiselect, bump all spacey filenames.
                            //
                            if (FindFileData.cAlternateFileName[0] == CHAR_NULL)
                            {
                                continue;
                            }

                            lstrcpy( szBuffer,
                                     (LPTSTR)FindFileData.cAlternateFileName );
                        }
                    }
                }

                if ((FindFileData.dwFileAttributes & EXCLBITS) ||
                    (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {
                    continue;
                }

                if (!bCasePreserved)
                {
                    CharLower(szBuffer);
                }

                SendMessage(hFileList, LB_ADDSTRING, 0, (DWORD_PTR)szBuffer);
            } while (FindNextFile(hff, &FindFileData));

            if (hff != INVALID_HANDLE_VALUE)
            {
                FindClose(hff);
            }
        }
    }

NoMoreFilesFound:

Func4EFailure:
    if (wMask)
    {
        if (wMask == mskDirectory)
        {
            LPTSTR lpCurDir = NULL;

            if (lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg))
            {
                lpCurDir = lpCurDlg->lpstrCurDir;
            }

            FillOutPath(hDirList, pOFI);

            //
            //  The win31 way of chopping the text by just passing
            //  it on to user doesn't work for unc names since user
            //  doesn't see the drivelessness of them (thinks drive is
            //  a bslash char).  So, special case it here.
            //
            lstrcpy(pOFI->szPath, lpCurDir);

            if (DBL_BSLASH(pOFI->szPath))
            {
                SetDlgItemText(hDlg, stc1, ChopText(hDlg, stc1, pOFI->szPath));
            }
            else
            {
                DlgDirList(hDlg, pOFI->szPath, 0, stc1, DDL_READONLY);
            }

            SendMessage(hDirList, LB_SETCURSEL, pOFI->idirSub - 1, 0L);

            if (bDriveChange)
            {
                //
                //  The design here is to show the selected drive whenever the
                //  user changes drives, or whenever the number of
                //  subdirectories is sufficiently low to allow them to be
                //  shown along with the drive.  Otherwise, show the
                //  immediate parent and all the children that can be shown.
                //  This all was done to meet the UITF spec.
                //
                i = 0;
            }
            else
            {
                //
                //  Show as many children as possible.
                //
                if ((i = (SHORT)(pOFI->idirSub - 2)) < 0)
                {
                    i = 0;
                }
            }

            //
            //  LB_SETTOPINDEX must be after LB_SETCURSEL, as LB_SETCURSEL will
            //  alter the top index to bring the current selection into view.
            //
            SendMessage(hDirList, LB_SETTOPINDEX, (WPARAM)i, 0L);
        }
        else
        {
            SetDlgItemText(hDlg, stc1, szNull);
        }

        wNoRedraw &= ~2;
        SendMessage(hDirList, WM_SETREDRAW, TRUE, 0L);

        GetWindowRect(hDirList, (LPRECT)&rDirLBox);
        rDirLBox.left++, rDirLBox.top++;
        rDirLBox.right--, rDirLBox.bottom--;
        ScreenToClient(hDlg, (LPPOINT)&(rDirLBox.left));
        ScreenToClient(hDlg, (LPPOINT)&(rDirLBox.right));

        //
        //  If there are less than enough directories to fill the listbox,
        //  Win 3.0 doesn't clear out the bottom.  Pass TRUE as the last
        //  parameter to demand a WM_ERASEBACKGROUND message.
        //
        InvalidateRect(hDlg, (LPRECT)&rDirLBox, (BOOL)(wWinVer < 0x030A));
    }

    SendMessage(hFileList, WM_SETREDRAW, TRUE, 0L);
    InvalidateRect(hFileList, (LPRECT)0, (BOOL)TRUE);

#ifndef WIN32
   ResetDTAAddress();
#endif

   HourGlass(FALSE);
   return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  OKButtonPressed
//
//  Note:  There are 4 cases for validation of a file name:
//    1)  OFN_NOVALIDATE        allows invalid characters
//    2)  No validation flags   No invalid characters, but path need not exist
//    3)  OFN_PATHMUSTEXIST     No invalid characters, path must exist
//    4)  OFN_FILEMUSTEXIST     No invalid characters, path & file must exist
//
////////////////////////////////////////////////////////////////////////////

BOOL OKButtonPressed(
    HWND hDlg,
    POPENFILEINFO pOFI,
    BOOL bSave)
{
    DWORD nErrCode = 0;
    DWORD cch;
    DWORD cchSearchPath;
    LPOPENFILENAME pOFN = pOFI->pOFN;
    int nFileOffset, nExtOffset;
    HANDLE hFile;
    BOOL bAddExt = FALSE;
    BOOL bUNCName = FALSE;
    int nTempOffset;
    TCHAR szPathName[MAX_FULLPATHNAME];
    DWORD lRet;
    BOOL blfn;
    LPCURDLG lpCurDlg;
    TCHAR ch = 0;


    if (cch = GetUNCDirectoryFromLB(hDlg, lst2, pOFI))
    {
        nTempOffset = (WORD)(DWORD)SendDlgItemMessage( hDlg,
                                                       lst2,
                                                       LB_GETTEXTLEN,
                                                       0,
                                                       0 );
    }
    else
    {
        nTempOffset = 0;
    }

    GetDlgItemText(hDlg, edt1, pOFI->szPath + cch, MAX_FULLPATHNAME - 1);

    if (cch)
    {
        //
        //  If a drive or new UNC was specified, forget the old UNC.
        //
        if ((pOFI->szPath[cch + 1] == CHAR_COLON) ||
            (DBL_BSLASH(pOFI->szPath + cch)) )
        {
            lstrcpy(pOFI->szPath, pOFI->szPath + cch);
        }
        else if ((ISBACKSLASH(pOFI->szPath, cch)) ||
                 (pOFI->szPath[cch] == CHAR_SLASH))
        {
            //
            //  If a directory from the root is given, put it immediately
            //  after the \\server\share listing.
            //
            lstrcpy(pOFI->szPath + nTempOffset, pOFI->szPath + cch);
        }
    }

    if (pOFN->Flags & OFN_NOLONGNAMES)
    {
        blfn = FALSE;
    }
    else
    {
        blfn = IsLFNDriveX(hDlg, pOFI->szPath);
    }

    lRet = ParseFile(pOFI->szPath, blfn, IS16BITWOWAPP(pOFN), FALSE);
    nFileOffset = (int)(SHORT)LOWORD(lRet);
    nExtOffset  = (int)(SHORT)HIWORD(lRet);

    if (nFileOffset == PARSE_EMPTYSTRING)
    {
        UpdateListBoxes(hDlg, pOFI, NULL, 0);
        return (FALSE);
    }
    else if ((nFileOffset != PARSE_DIRECTORYNAME) &&
             (pOFN->Flags & OFN_NOVALIDATE))
    {
        pOFN->nFileOffset = (WORD)nFileOffset;
        pOFN->nFileExtension = (WORD)nExtOffset;
        if (pOFN->lpstrFile)
        {
            cch = lstrlen(pOFI->szPath);
            if (cch < pOFN->nMaxFile)
            {
                lstrcpy(pOFN->lpstrFile, pOFI->szPath);
            }
            else
            {
                //
                //  For single file requests, we will never go over 64K
                //  because the filesystem is limited to 256.
                //
                if (cch > 0x0000FFFF)
                {
                    pOFN->lpstrFile[0] = (TCHAR)0xFFFF;
                }
                else
                {
                    pOFN->lpstrFile[0] = (TCHAR)LOWORD(cch);
                }
                pOFN->lpstrFile[1] = CHAR_NULL;
            }
        }
        return (TRUE);
    }
    else if ((pOFN->Flags & OFN_ALLOWMULTISELECT) &&
             SpacesExist(pOFI->szPath))
    {
        return (MultiSelectOKButton(hDlg, pOFI, bSave));
    }
    else if (pOFI->szPath[nExtOffset] == CHAR_SEMICOLON)
    {
        pOFI->szPath[nExtOffset] = CHAR_NULL;
        nFileOffset = (int)(SHORT)LOWORD(ParseFile( pOFI->szPath,
                                                    blfn,
                                                    IS16BITWOWAPP(pOFN),
                                                    FALSE ));
        pOFI->szPath[nExtOffset] = CHAR_SEMICOLON;
        if ( (nFileOffset >= 0) &&
             (StrChr(pOFI->szPath + nFileOffset, CHAR_STAR) ||
              StrChr(pOFI->szPath + nFileOffset, CHAR_QMARK)) )
        {
            lstrcpy(pOFI->szLastFilter, pOFI->szPath + nFileOffset);
            if (FListAll(pOFI, hDlg, pOFI->szPath) == CHANGEDIR_FAILED)
            {
                //
                //  Conform with cchSearchPath error code settings in
                //  PathCheck.
                //
                cchSearchPath = 2;
                goto PathCheck;
            }
            return (FALSE);
        }
        else
        {
            nFileOffset = PARSE_INVALIDCHAR;
            goto Warning;
        }
    }
    else if (nFileOffset == PARSE_DIRECTORYNAME)
    {
        //
        //  End with slash?
        //
        if ((ISBACKSLASH(pOFI->szPath, nExtOffset - 1)) ||
            (pOFI->szPath[nExtOffset - 1] == CHAR_SLASH))
        {
            //
            //  ... and is not the root, get rid of the slash.
            //
            if ( (nExtOffset != 1) &&
                 (pOFI->szPath[nExtOffset - 2] != CHAR_COLON) &&
                 (nExtOffset != nTempOffset + 1) )
            {
                pOFI->szPath[nExtOffset - 1] = CHAR_NULL;
            }
        }
        else if ((pOFI->szPath[nExtOffset - 1] == CHAR_DOT) &&
                 ((pOFI->szPath[nExtOffset - 2] == CHAR_DOT) ||
                  (ISBACKSLASH(pOFI->szPath, nExtOffset - 2)) ||
                  (pOFI->szPath[nExtOffset - 2] == CHAR_SLASH)) &&
                 ((DBL_BSLASH(pOFI->szPath)) ||
                  ((*(pOFI->szPath + 1) == CHAR_COLON) &&
                   (DBL_BSLASH(pOFI->szPath + 2)))))
        {
            pOFI->szPath[nExtOffset] = CHAR_BSLASH;
            pOFI->szPath[nExtOffset + 1] = CHAR_NULL;
        }

        //
        //  Fall through to Directory Checking.
        //
    }
    else if (nFileOffset < 0)
    {
        //
        //  Put in nErrCode so that call can be used from other points.
        //
        nErrCode = (DWORD)nFileOffset;
Warning:

        //
        //  If the disk is not a floppy and they tell me there's no
        //  disk in the drive, dont believe it.  Instead, put up the error
        //  message that they should have given us.
        //  (Note that the error message is checked first since checking
        //  the drive type is slower.)
        //
        if (nErrCode == ERROR_ACCESS_DENIED)
        {
            if (bUNCName)
            {
                nErrCode = ERROR_NETWORK_ACCESS_DENIED;
            }
            else
            {
                szPathName[0] = (TCHAR)CharLower((LPTSTR)(DWORD)szPathName[0]);

                if (GetDiskType(szPathName) == DRIVE_REMOTE)
                {
                    nErrCode = ERROR_NETWORK_ACCESS_DENIED;
                }
                else if (GetDiskType(szPathName) == DRIVE_REMOVABLE)
                {
                    nErrCode = ERROR_NO_DISK_IN_DRIVE;
                }
                else if (GetDiskType(szPathName) == DRIVE_CDROM)
                {
                    nErrCode = ERROR_NO_DISK_IN_CDROM;
                }
            }
        }

        if ((nErrCode == ERROR_WRITE_PROTECT) ||
            (nErrCode == ERROR_CANNOT_MAKE) ||
            (nErrCode == ERROR_NO_DISK_IN_DRIVE) ||
            (nErrCode == ERROR_NO_DISK_IN_CDROM))
        {
            pOFI->szPath[0] = szPathName[0];
        }

        InvalidFileWarning(hDlg, pOFI->szPath, nErrCode, 0);

        //
        //  Can't cd case (don't want WM_ACTIVATE to setevent to GetNetDrives!).
        //  Reset wNoRedraw.
        //
        wNoRedraw &= ~1;
        return (FALSE);
    }

    bUNCName = ((DBL_BSLASH(pOFI->szPath)) ||
                ((*(pOFI->szPath + 1) == CHAR_COLON) &&
                (DBL_BSLASH(pOFI->szPath + 2))));

    nTempOffset = nFileOffset;

    //
    //  Get the fully-qualified path.
    //
    {
        BOOL bSlash;
        BOOL bRet;
        WORD nNullOffset;

        if (nFileOffset != PARSE_DIRECTORYNAME)
        {
            ch = *(pOFI->szPath + nFileOffset);
            *(pOFI->szPath + nFileOffset) = CHAR_NULL;
            nNullOffset = (WORD) nFileOffset;
        }

        //
        //  For files of the format c:filename where c is not the
        //  current directory, SearchPath does not return the curdir of c
        //  so, prefetch it - should searchpath be changed?
        //
        if (nFileOffset)
        {
            if (*(pOFI->szPath + nFileOffset - 1) == CHAR_COLON)
            {
                //
                //  If it fails, fall through to the error generated below.
                //
                if (ChangeDir(hDlg, pOFI->szPath, FALSE, FALSE) != CHANGEDIR_FAILED)
                {
                    //
                    //  Replace old null offset.
                    //
                    *(pOFI->szPath + nFileOffset) = ch;
                    ch = *pOFI->szPath;

                    //
                    //  Don't pass drive-colon into search path.
                    //
                    *pOFI->szPath = CHAR_NULL;
                    nNullOffset = 0;
                }
            }
        }

        if (bSlash = (*pOFI->szPath == CHAR_SLASH))
        {
            *pOFI->szPath = CHAR_BSLASH;
        }

        szPathName[0] = CHAR_NULL;

        HourGlass(TRUE);

        //
        //  ISSUE:
        //  Each wow thread can change the current directory.
        //  Since searchpath doesn't check current dirs on a per thread basis,
        //  reset it here and hope that we don't get interrupted between
        //  setting and searching...
        //
        lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);
        SetCurrentDirectory(lpCurDlg ? lpCurDlg->lpstrCurDir : NULL);

        if (pOFI->szPath[0] == TEXT('\0'))  // space for name (pretend it's valid for now)
        {
            lstrcpy(szPathName, (lpCurDlg ? lpCurDlg->lpstrCurDir : NULL));
            bRet = 1;
        }
        else
        {
            bRet = GetFullPathName( pOFI->szPath,
                                    MAX_FULLPATHNAME,
                                    szPathName,
                                    NULL );
        }

        if (!bRet && (pOFI->szPath[1] == CHAR_COLON))
        {
            int nDriveIndex = DiskAddedPreviously(pOFI->szPath[0], NULL);

            //
            //  If it's a remembered connection, try to reconnect it.
            //
            if (nDriveIndex != 0xFFFFFFFF  &&
                gaDiskInfo[nDriveIndex].dwType == REMDRVBMP)
            {
                DWORD err = WNetRestoreConnection( hDlg,
                                                   gaDiskInfo[nDriveIndex].lpPath );

                if (err == WN_SUCCESS)
                {
                    gaDiskInfo[nDriveIndex].dwType = NETDRVBMP;
                    nDriveIndex = (int) SendDlgItemMessage(
                           hDlg,
                           cmb2,
                           CB_SELECTSTRING,
                           (WPARAM)-1,
                           (LPARAM)(LPTSTR)gaDiskInfo[nDriveIndex].lpPath );
                    SendDlgItemMessage( hDlg,
                                        cmb2,
                                        CB_SETITEMDATA,
                                        (WPARAM)nDriveIndex,
                                        (LPARAM)NETDRVBMP );
                    bRet = GetFullPathName( pOFI->szPath,
                                            MAX_FULLPATHNAME,
                                            szPathName,
                                            NULL);
                }
            }
        }
        HourGlass(FALSE);

        if (nFileOffset != PARSE_DIRECTORYNAME)
        {
            *(pOFI->szPath + nNullOffset) = ch;
        }

        if (bSlash)
        {
            *pOFI->szPath = CHAR_SLASH;
        }

        if (bRet)
        {
            cchSearchPath = 0;

            if (nFileOffset != PARSE_DIRECTORYNAME)
            {
                ch = *(szPathName + lstrlen(szPathName) - 1);
                if (!ISBACKSLASH(szPathName, lstrlen(szPathName) - 1))
                {
                    lstrcat(szPathName, TEXT("\\"));
                }
                lstrcat(szPathName, (LPTSTR)(pOFI->szPath + nFileOffset));
            }
            else
            {
                //
                //  Hack to get around SearchPath inconsistencies.
                //
                //  searching for c: returns c:
                //  searching for server share dir1 .. returns  server share
                //  in these two cases bypass the regular ChangeDir call that
                //  uses szPathName and use the original pOFI->szPath instead
                //  OKButtonPressed needs to be simplified!
                //
                int cch = GetPathOffset(pOFI->szPath);

                if (cch > 0)
                {
                    if (bUNCName)
                    {
                        //
                        //  If this fails, how is szPathName used?
                        //  szPathName's disk should equal pOFI->szPath's
                        //  so the cch will be valid.
                        //
                        szPathName[cch] = CHAR_BSLASH;
                        szPathName[cch + 1] = CHAR_NULL;
                        if (ChangeDir( hDlg,
                                       pOFI->szPath,
                                       FALSE,
                                       TRUE ) != CHANGEDIR_FAILED)
                        {
                            goto ChangedDir;
                        }
                    }
                    else
                    {
                        if (!pOFI->szPath[cch])
                        {
                            if (ChangeDir( hDlg,
                                           pOFI->szPath,
                                           FALSE,
                                           TRUE ) != CHANGEDIR_FAILED)
                            {
                                goto ChangedDir;
                            }
                        }
                    }
                }
            }
        }
        else
        {
            if (!(pOFN->Flags & OFN_PATHMUSTEXIST))
            {
                lstrcpy(szPathName, pOFI->szPath);
            }
            if (((nErrCode = GetLastError()) == ERROR_INVALID_DRIVE) ||
                (pOFI->szPath[1] == CHAR_COLON))
            {
                cchSearchPath = 1;
            }
            else
            {
                cchSearchPath = 2;
            }
        }
    }

    //
    //  Full pattern?
    //
    if ( !cchSearchPath &&
         ((StrChr(pOFI->szPath + nFileOffset, CHAR_STAR)) ||
          (StrChr(pOFI->szPath + nFileOffset, CHAR_QMARK))) )
    {
        TCHAR szSameDirFile[MAX_FULLPATHNAME];

        if (nTempOffset)
        {
            //
            //  Must restore character in case it is part of the filename,
            //  e.g. nTempOffset is 1 for "\foo.txt".
            //
            ch = pOFI->szPath[nTempOffset];
            pOFI->szPath[nTempOffset] = 0;
            ChangeDir(hDlg, pOFI->szPath, FALSE, TRUE);
            pOFI->szPath[nTempOffset] = ch;
        }
        if (!nExtOffset)
        {
            lstrcat(pOFI->szPath + nFileOffset, TEXT("."));
        }
        lstrcpy(szSameDirFile, pOFI->szPath + nFileOffset);
        lstrcpy(pOFI->szLastFilter, pOFI->szPath + nFileOffset);

        if (FListAll(pOFI, hDlg, szSameDirFile) < 0)
        {
            MessageBeep(0);
        }
        return (FALSE);
    }

    //
    //  We either have a file pattern or a real file.
    //  If its a directory
    //       (1) Add on default pattern
    //       (2) Act like its a pattern (goto pattern (1))
    //  Else if its a pattern
    //       (1) Update everything
    //       (2) display files in whatever dir were now in
    //  Else if its a file name!
    //       (1) Check out the syntax
    //       (2) End the dialog given OK
    //       (3) Beep/message otherwise
    //

    //
    //  Drive-letter:\dirpath ??
    //
    if (!cchSearchPath)
    {
        DWORD dwFileAttr;

        if ((dwFileAttr = GetFileAttributes(szPathName)) != 0xFFFFFFFF)
        {
            if (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY)
            {
                if (ChangeDir(hDlg, szPathName, FALSE, TRUE) != CHANGEDIR_FAILED)
                {
ChangedDir:
                    SendDlgItemMessage(hDlg, edt1, WM_SETREDRAW, FALSE, 0L);
                    if (*pOFI->szLastFilter)
                    {
                        SetDlgItemText(hDlg, edt1, pOFI->szLastFilter);
                    }
                    else
                    {
                        SetDlgItemText(hDlg, edt1, szStarDotStar);
                    }

                    SendMessage( hDlg,
                                 WM_COMMAND,
                                 GET_WM_COMMAND_MPS( cmb1,
                                                     GetDlgItem(hDlg, cmb1),
                                                     CBN_CLOSEUP ) );
                    SendMessage( hDlg,
                                 WM_COMMAND,
                                 GET_WM_COMMAND_MPS( cmb2,
                                                     GetDlgItem(hDlg, cmb2),
                                                     MYCBN_CHANGEDIR ) );

                    SendDlgItemMessage(hDlg, edt1, WM_SETREDRAW, TRUE, 0L);
                    InvalidateRect(GetDlgItem(hDlg, edt1), NULL, FALSE);
                }
                return (FALSE);
            }
        }
    }

    //
    //  Was there a path and did it fail?
    //
    if (nFileOffset && cchSearchPath && (pOFN->Flags & OFN_PATHMUSTEXIST))
    {
PathCheck:
        if (cchSearchPath == 2)
        {
            nErrCode = ERROR_PATH_NOT_FOUND;
        }
        else if (cchSearchPath == 1)
        {
            int nDriveIndex;

            //
            //  Lowercase drive letters since DiskAddedPreviously is case
            //  sensitive.
            //
            CharLower(pOFI->szPath);

            //  We can get here without performing an OpenFile call.  As such
            //  the szPathName can be filled with random garbage.  Since we
            //  only need one character for the error message, set
            //  szPathName[0] to the drive letter.
            //
            if (pOFI->szPath[1] == CHAR_COLON)
            {
                nDriveIndex = DiskAddedPreviously(pOFI->szPath[0], NULL);
            }
            else
            {
                nDriveIndex = DiskAddedPreviously(0, pOFI->szPath);
            }

            if (nDriveIndex == 0xFFFFFFFF)
            {
                nErrCode = ERROR_NO_DRIVE;
            }
            else
            {
                if (bUNCName)
                {
                    nErrCode = ERROR_NO_DRIVE;
                }
                else
                {
                    switch (GetDiskType(pOFI->szPath))
                    {
                        case ( DRIVE_REMOVABLE ) :
                        {
                            szPathName[0] = pOFI->szPath[0];
                            nErrCode = ERROR_NO_DISK_IN_DRIVE;
                            break;
                        }
                        case ( DRIVE_CDROM ) :
                        {
                           szPathName[0] = pOFI->szPath[0];
                           nErrCode = ERROR_NO_DISK_IN_CDROM;
                           break;
                        }
                        default :
                        {
                           nErrCode = ERROR_PATH_NOT_FOUND;
                        }
                    }
                }
            }
        }
        else
        {
            nErrCode = ERROR_FILE_NOT_FOUND;
        }

        //
        //  If we don't set wNoRedraw here, then WM_ACTIVATE will set the
        //  GetNetDrives event.
        //
        wNoRedraw |= 1;

        goto Warning;
    }

    if (PortName(pOFI->szPath + nFileOffset))
    {
        nErrCode = ERROR_PORTNAME;
        goto Warning;
    }

#if 0
    //
    //  Check if we've received a string in the form "C:filename.ext".
    //  If we have, convert it to the form "C:.\filename.ext".  This is done
    //  because the kernel will search the entire path, ignoring the drive
    //  specification after the initial search.  Making it include a slash
    //  causes kernel to only search at that location.
    //  Note:  Only increment nExtOffset, not nFileOffset.  This is done
    //  because only nExtOffset is used later, and nFileOffset can then be
    //  used at the Warning: label to determine if this hack has occurred,
    //  and thus it can strip out the ".\" when putting out the error.
    //
    if ((nFileOffset == 2) && (pOFI->szPath[1] == CHAR_COLON))
    {
        lstrcpy(szWarning, pOFI->szPath + 2);
        lstrcpy(pOFI->szPath + 4, szWarning);
        pOFI->szPath[2] = CHAR_DOT;
        pOFI->szPath[3] = CHAR_BSLASH;
        nExtOffset += 2;
    }
#endif

    //
    //  Add the default extension unless filename ends with period or no
    //  default extension exists.  If the file exists, consider asking
    //  permission to overwrite the file.
    //
    //  NOTE:  When no extension given, default extension is tried 1st.
    //
    if ( (nFileOffset != PARSE_DIRECTORYNAME) &&
         nExtOffset &&
         !pOFI->szPath[nExtOffset] &&
         pOFN->lpstrDefExt &&
         *pOFN->lpstrDefExt &&
         (((DWORD)nExtOffset + lstrlen(pOFN->lpstrDefExt)) < pOFN->nMaxFile) )
    {
        DWORD dwFileAttr;
        int nExtOffset2 = lstrlen(szPathName);

        bAddExt = TRUE;

        AppendExt(pOFI->szPath, pOFN->lpstrDefExt, FALSE);
        AppendExt(szPathName, pOFN->lpstrDefExt, FALSE);

        //
        //  Directory may match default extension.  Change to it as if it had
        //  been typed in.  A dir w/o the extension would have been switched
        //  to in the logic above.
        //
        if ((dwFileAttr = GetFileAttributes(pOFI->szPath)) != 0xFFFFFFFF)
        {
            if (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY)
            {
                if (ChangeDir(hDlg, szPathName, FALSE, TRUE) != CHANGEDIR_FAILED)
                {
                    goto ChangedDir;
                }
            }
        }

        hFile = CreateFile( szPathName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );
        if (hFile == INVALID_HANDLE_VALUE)
        {
            nErrCode = GetLastError();

            //
            //  Fix bug where progman cannot OK a file being browsed for new
            //  item because it has Execute only permission.
            //
            if (nErrCode == ERROR_ACCESS_DENIED)
            {
                hFile = CreateFile( szPathName,
                                    GENERIC_EXECUTE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL );
                if (hFile == INVALID_HANDLE_VALUE)
                {
                    nErrCode = GetLastError();
                }
            }
        }

        if (nErrCode == ERROR_SHARING_VIOLATION)
        {
            goto SharingViolationInquiry;
        }

        if (hFile != INVALID_HANDLE_VALUE)
        {
            if (!CloseHandle(hFile))
            {
                nErrCode = GetLastError();
                goto Warning;
            }

AskPermission:
            //
            //  Is the file read-only?
            //
            if (pOFN->Flags & OFN_NOREADONLYRETURN)
            {
                int nRet;
                if ((nRet = GetFileAttributes(szPathName)) != -1)
                {
                    if (nRet & ATTR_READONLY)
                    {
                        nErrCode = ERROR_LAZY_READONLY;
                        goto Warning;
                    }
                }
                else
                {
                    nErrCode = GetLastError();
                    goto Warning;
                }
            }

            if ((bSave || (pOFN->Flags & OFN_NOREADONLYRETURN)) &&
                (nErrCode == ERROR_ACCESS_DENIED))
            {
                goto Warning;
            }

            if (pOFN->Flags & OFN_OVERWRITEPROMPT)
            {
                if (bSave && !FOkToWriteOver(hDlg, szPathName))
                {
                    PostMessage( hDlg,
                                 WM_NEXTDLGCTL,
                                 (WPARAM)GetDlgItem(hDlg, edt1),
                                 (LPARAM)1L );
                    return (FALSE);
                }
            }

            if (nErrCode == ERROR_SHARING_VIOLATION)
            {
                goto SharingViolationInquiry;
            }
            goto FileNameAccepted;
        }
        else
        {
            *(pOFI->szPath + nExtOffset) = CHAR_NULL;
            szPathName[nExtOffset2] = CHAR_NULL;
        }
    }
    else
    {
        //
        //  Extension should not be added.
        //
        bAddExt = FALSE;
    }

    hFile = CreateFile( szPathName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );
    if (hFile == INVALID_HANDLE_VALUE)
    {
        nErrCode = GetLastError();

        //
        //  Fix bug where progman cannot OK a file being browsed for new item
        //  because it has Execute only permission.
        //
        if (nErrCode == ERROR_ACCESS_DENIED)
        {
            hFile = CreateFile( szPathName,
                                GENERIC_EXECUTE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );
            if (hFile == INVALID_HANDLE_VALUE)
            {
                nErrCode = GetLastError();
            }
        }
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        if (!CloseHandle(hFile))
        {
            nErrCode = GetLastError();
            goto Warning;
        }
        goto AskPermission;
    }
    else
    {
        if ((nErrCode == ERROR_FILE_NOT_FOUND) ||
            (nErrCode == ERROR_PATH_NOT_FOUND))
        {
            //
            //  Figure out if the default extension should be tacked on.
            //
            if (bAddExt)
            {
                AppendExt(pOFI->szPath, pOFN->lpstrDefExt, FALSE);
                AppendExt(szPathName, pOFN->lpstrDefExt, FALSE);
            }
        }
        else if (nErrCode == ERROR_SHARING_VIOLATION)
        {

SharingViolationInquiry:
            //
            //  If the app is "share aware", fall through.
            //  Otherwise, ask the hook function.
            //
            if (!(pOFN->Flags & OFN_SHAREAWARE))
            {
                if (pOFN->lpfnHook)
                {
                    LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

#ifdef UNICODE
                    if (pOFI->ApiType == COMDLG_ANSI)
                    {
                        CHAR szPathNameA[MAX_FULLPATHNAME];

                        RtlUnicodeToMultiByteSize(
                              &cch,
                              szPathName,
                              lstrlenW(szPathName) * sizeof(TCHAR) );

                        WideCharToMultiByte( CP_ACP,
                                             0,
                                             szPathName,
                                             -1,
                                             (LPSTR)&szPathNameA[0],
                                             cch + 1,
                                             NULL,
                                             NULL );

                        cch = (*lpfnHook)( hDlg,
                                           msgSHAREVIOLATIONA,
                                           0,
                                           (LONG_PTR)(LPSTR)szPathNameA );
                    }
                    else
#endif
                    {
                        cch = (*lpfnHook)( hDlg,
                                           msgSHAREVIOLATIONW,
                                           0,
                                           (LONG_PTR)szPathName );
                    }
                    if (cch == OFN_SHARENOWARN)
                    {
                        return (FALSE);
                    }
                    else if (cch != OFN_SHAREFALLTHROUGH)
                    {
                        goto Warning;
                    }
                }
                else
                {
                    goto Warning;
                }
            }
            goto FileNameAccepted;
        }

        if (!bSave)
        {
            if ((nErrCode == ERROR_FILE_NOT_FOUND) ||
                (nErrCode == ERROR_PATH_NOT_FOUND))
            {
                if (pOFN->Flags & OFN_FILEMUSTEXIST)
                {
                    if (pOFN->Flags & OFN_CREATEPROMPT)
                    {
                        //
                        //  Don't alter pOFI->szPath.
                        //
                        bInChildDlg = TRUE;
                        cch = (DWORD)CreateFileDlg(hDlg, pOFI->szPath);
                        bInChildDlg = FALSE;
                        if (cch == IDYES)
                        {
                            goto TestCreation;
                        }
                        else
                        {
                            return (FALSE);
                        }
                    }
                    goto Warning;
                }
            }
            else
            {
                goto Warning;
            }
        }

        //
        //  The file doesn't exist.  Can it be created?  This is needed because
        //  there are many extended characters which are invalid that won't be
        //  caught by ParseFile.
        //  Two more good reasons:  Write-protected disks & full disks.
        //
        //  BUT, if they dont want the test creation, they can request that we
        //  not do it using the OFN_NOTESTFILECREATE flag.  If they want to
        //  create files on a share that has create-but-no-modify privileges,
        //  they should set this flag but be ready for failures that couldn't
        //  be caught, such as no create privileges, invalid extended
        //  characters, a full disk, etc.
        //

TestCreation:
        if ((pOFN->Flags & OFN_PATHMUSTEXIST) &&
            (!(pOFN->Flags & OFN_NOTESTFILECREATE)))
        {
            //
            //  Must use the FILE_FLAG_DELETE_ON_CLOSE flag so that the
            //  file is automatically deleted when the handle is closed
            //  (no need to call DeleteFile).  This is necessary in the
            //  event that the directory only has Add & Read access.
            //  The CreateFile call will succeed, but the DeleteFile call
            //  will fail.  By adding the above flag to the CreateFile
            //  call, it overrides the access rights and deletes the file
            //  during the call to CloseHandle.
            //
#ifdef WINNT
            hFile = CreateFile( szPathName,
                                FILE_ADD_FILE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                                NULL );
#else

            // Win95/Memphis don't support FILE_ADD_FILE flag, use GENERIC_READ instead.

            hFile = CreateFile( szPathName,
                                GENERIC_READ,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE,
                                NULL );
#endif
            if (hFile == INVALID_HANDLE_VALUE)
            {
                nErrCode = GetLastError();
            }

            if (hFile != INVALID_HANDLE_VALUE)
            {
                if (!CloseHandle(hFile))
                {
                    nErrCode = GetLastError();
                    goto Warning;
                }
            }
            else
            {
                //
                //  Unable to create it.
                //
                //  If it's not write-protection, a full disk,
                //  network protection, or the user popping the drive door
                //  open, assume that the filename is invalid.
                //
                if ( (nErrCode != ERROR_WRITE_PROTECT) &&
                     (nErrCode != ERROR_CANNOT_MAKE) &&
                     (nErrCode != ERROR_NETWORK_ACCESS_DENIED) &&
                     (nErrCode != ERROR_ACCESS_DENIED) )
                {
                    nErrCode = 0;
                }
                goto Warning;
            }
        }
    }

FileNameAccepted:

    HourGlass(TRUE);

    lRet = ParseFile(szPathName, blfn, IS16BITWOWAPP(pOFN), FALSE);
    nFileOffset = (int)(SHORT)LOWORD(lRet);
    cch = (DWORD)HIWORD(lRet);

    pOFN->nFileOffset = (WORD)nFileOffset;
    if (nExtOffset || bAddExt)
    {
        pOFN->nFileExtension = LOWORD(cch);
    }
    else
    {
        pOFN->nFileExtension = 0;
    }

    pOFN->Flags &= ~OFN_EXTENSIONDIFFERENT;
    if (pOFN->lpstrDefExt && pOFN->nFileExtension)
    {
        TCHAR szPrivateExt[4];
        SHORT i;

        for (i = 0; i < 3; i++)
        {
            szPrivateExt[i] = *(pOFN->lpstrDefExt + i);
        }
        szPrivateExt[3] = CHAR_NULL;

        if (lstrcmpi(szPrivateExt, szPathName + cch))
        {
            pOFN->Flags |= OFN_EXTENSIONDIFFERENT;
        }
    }

    //
    //  If we're called from wow, and the user hasn't changed
    //  directories, shorten the path to abbreviated 8.3 format.
    //
    if (pOFN->Flags & OFN_NOLONGNAMES)
    {
        ShortenThePath(szPathName);

        //
        //  If the path was shortened, the offset might have changed so
        //  we must parse the file again.
        //
        lRet = ParseFile(szPathName, blfn, IS16BITWOWAPP(pOFN), FALSE);
        nFileOffset = (int)(SHORT)LOWORD(lRet);
        cch  = (DWORD)HIWORD(lRet);

        //
        //  When in Save dialog, the file may not exist yet, so the file
        //  name cannot be shortened.  So, we need to test if it's an
        //  8.3 filename and popup an error message if not.
        //
        if (bSave)
        {
            LPTSTR lptmp;
            LPTSTR lpExt = NULL;

            for (lptmp = szPathName + nFileOffset; *lptmp; lptmp++)
            {
                if (*lptmp == CHAR_DOT)
                {
                    if (lpExt)
                    {
                        //
                        //  There's more than one dot in the file, so it is
                        //  invalid.
                        //
                        nErrCode = FNERR_INVALIDFILENAME;
                        goto Warning;
                    }
                    lpExt = lptmp;
                }
                if (*lptmp == CHAR_SPACE)
                {
                    nErrCode = FNERR_INVALIDFILENAME;
                    goto Warning;
                }
            }

            if (lpExt)
            {
                //
                //  There's an extension.
                //
                *lpExt = 0;
            }

            if ((lstrlen(szPathName + nFileOffset) > 8) ||
                (lpExt && lstrlen(lpExt + 1) > 3))
            {
                if (lpExt)
                {
                    *lpExt = CHAR_DOT;
                }

                nErrCode = FNERR_INVALIDFILENAME;
                goto Warning;
            }
            if (lpExt)
            {
                *lpExt = CHAR_DOT;
            }
        }
    }

    if (pOFN->lpstrFile)
    {
        DWORD cchLen = lstrlen(szPathName);

        if (cchLen < pOFN->nMaxFile)
        {
            lstrcpy(pOFN->lpstrFile, szPathName);
        }
        else
        {
            //
            //  Buffer is too small, so return the size of the buffer
            //  required to hold the string.
            //
            //  For single file requests, we will never go over 64K
            //  because the filesystem is limited to 256.
            //
#ifdef UNICODE
            pOFN->lpstrFile[0] = (TCHAR)LOWORD(cchLen);
            if (pOFN->nMaxFile >= 2)
            {
                pOFN->lpstrFile[1] = CHAR_NULL;
            }
#else
            pOFN->lpstrFile[0] = LOBYTE(cchLen);
            pOFN->lpstrFile[1] = HIBYTE(cchLen);
            pOFN->lpstrFile[2] = CHAR_NULL;
#endif
        }
    }

    //
    //  File Title.  Note that it's cut off at whatever the buffer length
    //               is, so if the buffer is too small, no notice is given.
    //
    if (pOFN->lpstrFileTitle && pOFN->nMaxFileTitle)
    {
        cch = lstrlen(szPathName + nFileOffset);
        if (cch > pOFN->nMaxFileTitle)
        {
            szPathName[nFileOffset + pOFN->nMaxFileTitle - 1] = CHAR_NULL;
        }
        lstrcpy(pOFN->lpstrFileTitle, szPathName + nFileOffset);
    }


    if (pOFN->Flags | OFN_READONLY)
    {
        if (IsDlgButtonChecked(hDlg, chx1))
        {
            pOFN->Flags |= OFN_READONLY;
        }
        else
        {
            pOFN->Flags &= ~OFN_READONLY;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MultiSelectOKButton
//
////////////////////////////////////////////////////////////////////////////

BOOL MultiSelectOKButton(
    HWND hDlg,
    POPENFILEINFO pOFI,
    BOOL bSave)
{
    DWORD nErrCode;
    LPTSTR lpCurDir;
    LPTSTR lpchStart;                  // start of an individual filename
    LPTSTR lpchEnd;                    // end of an individual filename
    DWORD cch;
    HANDLE hFile;
    LPOPENFILENAME pOFN;
    BOOL EOS = FALSE;                  // end of string flag
    BOOL bRet;
    TCHAR szPathName[MAX_FULLPATHNAME - 1];
    LPCURDLG lpCurDlg;


    pOFN = pOFI->pOFN;

    //
    //  Check for space for first full path element.
    //
    if(!(lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg)) ||
       !(lpCurDir = lpCurDlg->lpstrCurDir))
    {
        return (FALSE);
    }

    lstrcpy(pOFI->szPath, lpCurDir);
    if (StrChr(pOFI->szPath, CHAR_SPACE))
    {
        GetShortPathName(pOFI->szPath, pOFI->szPath, MAX_FULLPATHNAME);
    }

    if (!bCasePreserved)
    {
        CharLower(pOFI->szPath);
    }

    cch = (DWORD) ( lstrlen(pOFI->szPath) +
            sizeof(TCHAR) +
            SendDlgItemMessage(hDlg, edt1, WM_GETTEXTLENGTH, 0, 0L) );
    if (pOFN->lpstrFile)
    {
        if (cch > pOFN->nMaxFile)
        {
            //
            //  Buffer is too small, so return the size of the buffer
            //  required to hold the string (if possible).
            //
            if (pOFN->nMaxFile >= 3)
            {
#ifdef UNICODE
                pOFN->lpstrFile[0] = (TCHAR)LOWORD(cch);
                pOFN->lpstrFile[1] = (TCHAR)HIWORD(cch);
#else
                pOFN->lpstrFile[0] = (TCHAR)LOBYTE(cch);
                pOFN->lpstrFile[1] = (TCHAR)HIBYTE(cch);
#endif
                pOFN->lpstrFile[2] = CHAR_NULL;
            }
            else
            {
#ifdef UNICODE
                pOFN->lpstrFile[0] = (TCHAR)LOWORD(cch);
                if (pOFN->nMaxFile == 2)
                {
                    pOFN->lpstrFile[1] = (TCHAR)HIWORD(cch);
                }
#else
                pOFN->lpstrFile[0] = LOBYTE(cch);
                pOFN->lpstrFile[1] = HIBYTE(cch);
                pOFN->lpstrFile[2] = CHAR_NULL;
#endif
            }
        }
        else
        {
            //
            //  Copy in the full path as the first element.
            //
            lstrcpy(pOFN->lpstrFile, pOFI->szPath);
            lstrcat(pOFN->lpstrFile, TEXT(" "));

            //
            //  Get the other files here.
            //
            cch = lstrlen(pOFN->lpstrFile);

            //
            //  The path is guaranteed to be less than 64K (actually, < 260).
            //
            pOFN->nFileOffset = LOWORD(cch);
            lpchStart = pOFN->lpstrFile + cch;

            GetDlgItemText( hDlg,
                            edt1,
                            lpchStart,
                            (int)(pOFN->nMaxFile - cch - 1) );

            while (*lpchStart == CHAR_SPACE)
            {
                lpchStart = CharNext(lpchStart);
            }
            if (*lpchStart == CHAR_NULL)
            {
                return (FALSE);
            }

            //
            //  Go along file path looking for multiple filenames delimited by
            //  spaces.  For each filename found, try to open it to make sure
            //  it's a valid file.
            //
            while (!EOS)
            {
                //
                //  Find the end of the filename.
                //
                lpchEnd = lpchStart;
                while (*lpchEnd && *lpchEnd != CHAR_SPACE)
                {
                    lpchEnd = CharNext(lpchEnd);
                }

                //
                //  Mark the end of the filename with a NULL.
                //
                if (*lpchEnd == CHAR_SPACE)
                {
                    *lpchEnd = CHAR_NULL;
                }
                else
                {
                    //
                    //  Already NULL, found the end of the string.
                    //
                    EOS = TRUE;
                }

                //
                //  Check that the filename is valid.
                //
                bRet = GetFullPathName( lpchStart,
                                        MAX_FULLPATHNAME,
                                        szPathName,
                                        NULL);

                if (!bRet)
                {
                    nErrCode = ERROR_FILE_NOT_FOUND;
                    goto MultiFileNotFound;
                }

                hFile = CreateFile( szPathName,
                                    GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL );

                //
                //  Fix bug where progman cannot OK a file being browsed for
                //  new item because it has Execute only permission.
                //
                if (hFile == INVALID_HANDLE_VALUE)
                {
                    nErrCode = GetLastError();
                    if (nErrCode == ERROR_ACCESS_DENIED)
                    {
                        hFile = CreateFile( szPathName,
                                            GENERIC_EXECUTE,
                                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                                            NULL,
                                            OPEN_EXISTING,
                                            FILE_ATTRIBUTE_NORMAL,
                                            NULL );
                    }
                    else
                    {
                        goto MultiFileNotFound;
                    }
                }
                if (hFile == INVALID_HANDLE_VALUE)
                {
                    nErrCode = GetLastError();
MultiFileNotFound:
                    if ( ((pOFN->Flags & OFN_FILEMUSTEXIST) ||
                          (nErrCode != ERROR_FILE_NOT_FOUND)) &&
                         ((pOFN->Flags & OFN_PATHMUSTEXIST) ||
                          (nErrCode != ERROR_PATH_NOT_FOUND)) &&
                         (!(pOFN->Flags & OFN_SHAREAWARE) ||
                          (nErrCode != ERROR_SHARING_VIOLATION)) )
                    {
                        if ( (nErrCode == ERROR_SHARING_VIOLATION) &&
                             pOFN->lpfnHook )
                        {
                            LPOFNHOOKPROC lpfnHook = GETHOOKFN(pOFN);

#ifdef UNICODE
                            if (pOFI->ApiType == COMDLG_ANSI)
                            {
                                CHAR szPathNameA[MAX_FULLPATHNAME];

                                RtlUnicodeToMultiByteSize(
                                     &cch,
                                     szPathName,
                                     lstrlenW(szPathName) * sizeof(TCHAR) );

                                WideCharToMultiByte( CP_ACP,
                                                     0,
                                                     szPathName,
                                                     -1,
                                                     (LPSTR)&szPathNameA[0],
                                                     cch + 1,
                                                     NULL,
                                                     NULL );

                                cch = (*lpfnHook)( hDlg,
                                                   msgSHAREVIOLATIONA,
                                                   0,
                                                   (LONG_PTR)(LPSTR)szPathNameA );
                            }
                            else
#endif
                            {
                                cch = (*lpfnHook)( hDlg,
                                                   msgSHAREVIOLATIONW,
                                                   0,
                                                   (LONG_PTR)szPathName );
                            }
                            if (cch == OFN_SHARENOWARN)
                            {
                                return (FALSE);
                            }
                            else if (cch == OFN_SHAREFALLTHROUGH)
                            {
                                goto EscapedThroughShare;
                            }
                        }
                        else if (nErrCode == ERROR_ACCESS_DENIED)
                        {
                            szPathName[0] =
                               (TCHAR)CharLower((LPTSTR)(DWORD)szPathName[0]);

                            if (GetDiskType(szPathName) != DRIVE_REMOVABLE)
                            {
                                nErrCode = ERROR_NETWORK_ACCESS_DENIED;
                            }
                        }
                        if ((nErrCode == ERROR_WRITE_PROTECT) ||
                            (nErrCode == ERROR_CANNOT_MAKE)   ||
                            (nErrCode == ERROR_ACCESS_DENIED))
                        {
                            *lpchStart = szPathName[0];
                        }
MultiWarning:
                        InvalidFileWarning(hDlg, lpchStart, nErrCode, 0);
                        return (FALSE);
                    }
                }
EscapedThroughShare:
                if (hFile != INVALID_HANDLE_VALUE)
                {
                    if (!CloseHandle(hFile))
                    {
                        nErrCode = GetLastError();
                        goto MultiWarning;
                    }
                    if ((pOFN->Flags & OFN_NOREADONLYRETURN) &&
                        (GetFileAttributes(szPathName) & FILE_ATTRIBUTE_READONLY))
                    {
                        nErrCode = ERROR_LAZY_READONLY;
                        goto MultiWarning;
                    }

                    if ((bSave || (pOFN->Flags & OFN_NOREADONLYRETURN)) &&
                        (nErrCode == ERROR_ACCESS_DENIED))
                    {
                        goto MultiWarning;
                    }

                    if (pOFN->Flags & OFN_OVERWRITEPROMPT)
                    {
                        if (bSave && !FOkToWriteOver(hDlg, szPathName))
                        {
                            PostMessage( hDlg,
                                         WM_NEXTDLGCTL,
                                         (WPARAM)GetDlgItem(hDlg, edt1),
                                         (LPARAM)1L );
                            return (FALSE);
                        }
                    }
                }

                //
                //  This file is valid, so check the next one.
                //
                if (!EOS)
                {
                    lpchStart = lpchEnd + 1;
                    while (*lpchStart == CHAR_SPACE)
                    {
                        lpchStart = CharNext(lpchStart);
                    }
                    if (*lpchStart == CHAR_NULL)
                    {
                        EOS = TRUE;
                    }
                    else
                    {
                        //
                        //  Not at end, replace NULL with SPACE.
                        //
                        *lpchEnd = CHAR_SPACE;
                    }
                }
            }

            //
            //  Limit String.
            //
            *lpchEnd = CHAR_NULL;
        }
    }

    //
    //  This doesn't really mean anything for multiselection.
    //
    pOFN->nFileExtension = 0;

    pOFN->nFilterIndex = (int) SendDlgItemMessage(hDlg, cmb1, CB_GETCURSEL, 0, 0L);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  dwOKSubclass
//
//  Simulates a double click if the user presses OK with the mouse
//  and the focus was on the directory listbox.
//
//  The problem is that the UITF demands that when the directory
//  listbox loses the focus, the selected directory should return
//  to the current directory.  But when the user changes the item
//  selected with a single click, and then clicks the OK button to
//  have the change take effect, the focus is lost before the OK button
//  knows it was pressed.  By setting the global flag bChangeDir
//  when the directory listbox loses the focus and clearing it when
//  the OK button loses the focus, we can check whether a mouse
//  click should update the directory.
//
//  Returns:  Return value from default listbox proceedure.
//
////////////////////////////////////////////////////////////////////////////

LRESULT WINAPI dwOKSubclass(
    HWND hOK,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    HANDLE hDlg;
    POPENFILEINFO pOFI;

    if (msg == WM_KILLFOCUS)
    {
        if (bChangeDir)
        {
            if (pOFI = (POPENFILEINFO)GetProp(hDlg = GetParent(hOK), FILEPROP))
            {
                SendDlgItemMessage( hDlg,
                                    lst2,
                                    LB_SETCURSEL,
                                    (WPARAM)(pOFI->idirSub - 1),
                                    0L );
            }
            bChangeDir = FALSE;
        }
    }
    return (CallWindowProc(lpOKProc, hOK, msg, wParam, lParam));
}


////////////////////////////////////////////////////////////////////////////
//
//  dwLBSubclass
//
//  Simulates a double click if the user presses OK with the mouse.
//
//  The problem is that the UITF demands that when the directory
//  listbox loses the focus, the selected directory should return
//  to the current directory.  But when the user changes the item
//  selected with a single click, and then clicks the OK button to
//  have the change take effect, the focus is lost before the OK button
//  knows it was pressed.  By simulating a double click, the change
//  takes place.
//
//  Returns:  Return value from default listbox proceedure.
//
////////////////////////////////////////////////////////////////////////////

LRESULT WINAPI dwLBSubclass(
    HWND hLB,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    HANDLE hDlg;
    POPENFILEINFO pOFI;

    if (msg == WM_KILLFOCUS)
    {
        hDlg = GetParent(hLB);
        bChangeDir = (GetDlgItem(hDlg, IDOK) == (HWND)wParam) ? TRUE : FALSE;
        if (!bChangeDir)
        {
            if (pOFI = (POPENFILEINFO)GetProp(hDlg, FILEPROP))
            {
                SendMessage( hLB,
                             LB_SETCURSEL,
                             (WPARAM)(pOFI->idirSub - 1),
                             0L );
            }
        }
    }
    return (CallWindowProc(lpLBProc, hLB, msg, wParam, lParam));
}


////////////////////////////////////////////////////////////////////////////
//
//  InvalidFileWarning
//
////////////////////////////////////////////////////////////////////////////

int InvalidFileWarning(
    HWND hDlg,
    LPTSTR szFile,
    DWORD wErrCode,
    UINT mbType)
{
    SHORT isz;
    BOOL bDriveLetter = FALSE;
    int nRet = 0;

    if (lstrlen(szFile) > TOOLONGLIMIT)
    {
        *(szFile + TOOLONGLIMIT) = CHAR_NULL;
    }

    switch (wErrCode)
    {
        case ( ERROR_NO_DISK_IN_DRIVE ) :
        {
            isz = iszNoDiskInDrive;
            bDriveLetter = TRUE;
            break;
        }
        case ( ERROR_NO_DISK_IN_CDROM ) :
        {
            isz = iszNoDiskInCDRom;
            bDriveLetter = TRUE;
            break;
        }
        case ( ERROR_NO_DRIVE ) :
        {
            isz = iszDriveDoesNotExist;
            bDriveLetter = TRUE;
            break;
        }
        case ( ERROR_TOO_MANY_OPEN_FILES ) :
        {
            isz = iszNoFileHandles;
            break;
        }
        case ( ERROR_PATH_NOT_FOUND ) :
        {
            isz = iszPathNotFound;
            break;
        }
        case ( ERROR_FILE_NOT_FOUND ) :
        {
            isz = iszFileNotFound;
            break;
        }
        case ( ERROR_CANNOT_MAKE ) :
        case ( ERROR_DISK_FULL ) :
        {
            isz = iszDiskFull;
            bDriveLetter = TRUE;
            break;
        }
        case ( ERROR_WRITE_PROTECT ) :
        {
            isz = iszWriteProtection;
            bDriveLetter = TRUE;
            break;
        }
        case ( ERROR_SHARING_VIOLATION ) :
        {
            isz = iszSharingViolation;
            break;
        }
        case ( ERROR_CREATE_NO_MODIFY ) :
        {
            isz = iszCreateNoModify;
            break;
        }
        case ( ERROR_NETWORK_ACCESS_DENIED ) :
        {
            isz = iszNetworkAccessDenied;
            break;
        }
        case ( ERROR_PORTNAME ) :
        {
            isz = iszPortName;
            break;
        }
        case ( ERROR_LAZY_READONLY ) :
        {
            isz = iszReadOnly;
            break;
        }
        case ( ERROR_DIR_ACCESS_DENIED ) :
        {
            isz = iszDirAccessDenied;
            break;
        }
        case ( ERROR_FILE_ACCESS_DENIED ) :
        case ( ERROR_ACCESS_DENIED ) :
        {
            isz = iszFileAccessDenied;
            break;
        }
        case ( ERROR_UNRECOGNIZED_VOLUME ) :
        {
            FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM |
                               FORMAT_MESSAGE_IGNORE_INSERTS |
                               FORMAT_MESSAGE_MAX_WIDTH_MASK,
                           NULL,
                           wErrCode,
                           GetUserDefaultLCID(),
                           szWarning,
                           WARNINGMSGLENGTH,
                           NULL );
            goto DisplayError;
        }
        default :
        {
            isz = iszInvalidFileName;
            break;
        }
    }
    if (!LoadString( g_hinst,
                     isz,
                     szCaption,
                     WARNINGMSGLENGTH ))
    {
        wsprintf( szWarning,
                  TEXT("Error occurred, but error resource cannot be loaded.") );
    }
    else
    {
        wsprintf( szWarning,
                  szCaption,
                  bDriveLetter ? (LPTSTR)(CHAR)*szFile : szFile );

DisplayError:
        GetWindowText(hDlg, szCaption, WARNINGMSGLENGTH);

        if (!mbType)
        {
            mbType = MB_OK | MB_ICONEXCLAMATION;
        }

        nRet = MessageBox(hDlg, szWarning, szCaption, mbType);
    }

    if (isz == iszInvalidFileName)
    {
        PostMessage( hDlg,
                     WM_NEXTDLGCTL,
                     (WPARAM)GetDlgItem(hDlg, edt1),
                     (LPARAM)1L );
    }

    return (nRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  MeasureItem
//
////////////////////////////////////////////////////////////////////////////

VOID MeasureItem(
    HWND hDlg,
    LPMEASUREITEMSTRUCT mis)
{
    if (!dyItem)
    {
        HDC hDC = GetDC(hDlg);
        TEXTMETRIC TM;
        HANDLE hFont;

        hFont = (HANDLE)SendMessage(hDlg, WM_GETFONT, 0, 0L);
        if (!hFont)
        {
            hFont = GetStockObject(SYSTEM_FONT);
        }
        hFont = SelectObject(hDC, hFont);
        GetTextMetrics(hDC, &TM);
        SelectObject(hDC, hFont);
        ReleaseDC(hDlg, hDC);
        dyText = TM.tmHeight;
        dyItem = max(dyDirDrive, dyText);
    }

    if (mis->CtlID == lst1)
    {
        mis->itemHeight = dyText;
    }
    else
    {
        mis->itemHeight = dyItem;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Signum
//
//  Returns the sign of an integer:
//           -1 if integer < 0
//            0 if integer = 0
//            1 if integer > 0
//
//  Note:  Signum *could* be defined as an inline macro, but that causes
//         the C compiler to disable Loop optimization, Global register
//         optimization, and Global optimizations for common subexpressions
//         in any function that the macro would appear.  The cost of a call
//         to the function seemed worth the optimizations.
//
////////////////////////////////////////////////////////////////////////////

int Signum(
    int nTest)
{
    return ((nTest == 0) ? 0 : (nTest > 0) ? 1 : -1);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawItem
//
//  Draws the drive/directory pictures in the respective combo list boxes.
//
//  lst1 is listbox for files
//  lst2 is listbox for directories
//  cmb1 is combobox for filters
//  cmb2 is combobox for drives
//
////////////////////////////////////////////////////////////////////////////

VOID DrawItem(
    POPENFILEINFO pOFI,
    HWND hDlg,
    WPARAM wParam,
    LPDRAWITEMSTRUCT lpdis,
    BOOL bSave)
{
    HDC hdcList;
    RECT rc;
//  RECT rcCmb2;
    TCHAR szText[MAX_FULLPATHNAME + 1];
    int dxAcross;
    LONG nHeight;
    LONG rgbBack, rgbText, rgbOldBack, rgbOldText;
    SHORT nShift = 1;             // to shift directories right in lst2
    BOOL bSel;
    int BltItem;
    int nBackMode;

    if ((int)lpdis->itemID < 0)
    {
        DefWindowProc(hDlg, WM_DRAWITEM, wParam, (LPARAM)lpdis);
        return;
    }

    *szText = CHAR_NULL;

    if (lpdis->CtlID != lst1 && lpdis->CtlID != lst2 && lpdis->CtlID != cmb2)
    {
        return;
    }

    if (!pOFI)
    {
        return;
    }

    hdcList = lpdis->hDC;

    if (lpdis->CtlID != cmb2)
    {
        SendDlgItemMessage( hDlg,
                            (int)lpdis->CtlID,
                            LB_GETTEXT ,
                            (WPARAM)lpdis->itemID,
                            (LONG_PTR)szText );

        if (*szText == 0)
        {
            //
            //  If empty listing.
            //
            DefWindowProc(hDlg, WM_DRAWITEM, wParam, (LONG_PTR)lpdis);
            return;
        }

        if (!bCasePreserved)
        {
            CharLower(szText);
        }
    }

    nHeight = (lpdis->CtlID == lst1) ? dyText : dyItem;

    CopyRect((LPRECT)&rc, (LPRECT)&lpdis->rcItem);

    rc.bottom = rc.top + nHeight;

    if (bSave && (lpdis->CtlID == lst1))
    {
        rgbBack = rgbWindowColor;
        rgbText = rgbGrayText;
    }
    else
    {
        //
        //  Careful checking of bSel is needed here.  Since the file
        //  listbox (lst1) can allow multiselect, only ODS_SELECTED needs
        //  to be set.  But for the directory listbox (lst2), ODS_FOCUS
        //  also needs to be set.
        //
        bSel = (lpdis->itemState & (ODS_SELECTED | ODS_FOCUS));
        if ((bSel & ODS_SELECTED) &&
            ((lpdis->CtlID != lst2) || (bSel & ODS_FOCUS)))
        {
            rgbBack = rgbHiliteColor;
            rgbText = rgbHiliteText;
        }
        else
        {
            rgbBack = rgbWindowColor;
            rgbText = rgbWindowText;
        }
    }

    rgbOldBack = SetBkColor(hdcList, rgbBack);
    rgbOldText = SetTextColor(hdcList, rgbText);

    //
    //  Drives -- text is now in UI style, c: VolumeName/Server-Sharename.
    //
    if (lpdis->CtlID == cmb2)
    {
        HANDLE hCmb2 = GetDlgItem(hDlg, cmb2);

        dxAcross = dxDirDrive / BMPHIOFFSET;

        BltItem = (int) SendMessage(hCmb2, CB_GETITEMDATA, lpdis->itemID, 0);

        SendMessage(hCmb2, CB_GETLBTEXT, lpdis->itemID, (LPARAM)szText);

        if (bSel & ODS_SELECTED)
        {
            BltItem += BMPHIOFFSET;
        }
    }
    else if (lpdis->CtlID == lst2)
    {
        //
        //  Directories.
        //
        dxAcross = dxDirDrive / BMPHIOFFSET;

        if (lpdis->itemID > pOFI->idirSub)
        {
            nShift = (SHORT)pOFI->idirSub;
        }
        else
        {
            nShift = (SHORT)lpdis->itemID;
        }

        //
        //  Must be at least 1.
        //
        nShift++;

        BltItem = 1 + Signum(lpdis->itemID + 1 - pOFI->idirSub);
        if (bSel & ODS_FOCUS)
        {
            BltItem += BMPHIOFFSET;
        }
    }
    else if (lpdis->CtlID == lst1)
    {
        //
        //  Prep for TextOut below.
        //
        dxAcross = -dxSpace;
    }

    if (bSave && (lpdis->CtlID == lst1) && !rgbText)
    {
        HBRUSH hBrush = CreateSolidBrush(rgbBack);
        HBRUSH hOldBrush;

        nBackMode = SetBkMode(hdcList, TRANSPARENT);
        hOldBrush = SelectObject( lpdis->hDC,
                                  hBrush
                                      ? hBrush
                                      : GetStockObject(WHITE_BRUSH) );

        FillRect(lpdis->hDC, (LPRECT)(&(lpdis->rcItem)), hBrush);
        SelectObject(lpdis->hDC, hOldBrush);
        if (hBrush)
        {
            DeleteObject(hBrush);
        }

        GrayString( lpdis->hDC,
                    GetStockObject(BLACK_BRUSH),
                    NULL,
                    (LPARAM)szText,
                    0,
                    lpdis->rcItem.left + dxSpace,
                    lpdis->rcItem.top,
                    0,
                    0 );
        SetBkMode(hdcList, nBackMode);
    }

#if 0
    else if (lpdis->CtlID == cmb2)
    {
        rcCmb2.right = rc.right;
        rcCmb2.left = rc.left + (WORD)(dxSpace + dxAcross) + (dxSpace * nShift);
        rcCmb2.top = rc.top + (dyItem - dyText) / 2;
        rcCmb2.bottom = rc.top + nHeight;

        DrawText( hdcList,
                  szText,
                  -1,
                  &rcCmb2,
                  DT_LEFT | DT_EXPANDTABS | DT_NOPREFIX );
    }
#endif

    else
    {
        //
        //  Draw the name.
        //
        ExtTextOut( hdcList,
                    rc.left + (WORD)(dxSpace + dxAcross) + dxSpace * nShift,
                    rc.top + (nHeight - dyText) / 2,
                    ETO_OPAQUE | ETO_CLIPPED,
                    (LPRECT)&rc,
                    szText,
                    lstrlen(szText),
                    NULL );
    }

    //
    //  Draw the picture.
    //
    if (lpdis->CtlID != lst1)
    {
        BitBlt( hdcList,
                rc.left + dxSpace * nShift,
                rc.top + (dyItem - dyDirDrive) / 2,
                dxAcross,
                dyDirDrive,
                hdcMemory,
                BltItem * dxAcross,
                0,
                SRCCOPY );
    }

    SetTextColor(hdcList, rgbOldText);
    SetBkColor(hdcList, rgbBack);

    if (lpdis->itemState & ODS_FOCUS)
    {
        DrawFocusRect(hdcList, (LPRECT)&lpdis->rcItem);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SpacesExist
//
////////////////////////////////////////////////////////////////////////////

BOOL SpacesExist(
    LPTSTR szFileName)
{
    while (*szFileName)
    {
        if (*szFileName == CHAR_SPACE)
        {
            return (TRUE);
        }
        else
        {
            szFileName++;
        }
    }
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  StripFileName
//
//  Removes all but the filename from editbox contents.
//  This is to be called before the user makes directory or drive
//  changes by selecting them instead of typing them.
//
////////////////////////////////////////////////////////////////////////////

void StripFileName(
    HANDLE hDlg,
    BOOL bWowApp)
{
    TCHAR szText[MAX_FULLPATHNAME];
    SHORT nFileOffset, cb;

    if (GetDlgItemText(hDlg, edt1, szText, MAX_FULLPATHNAME - 1))
    {
        DWORD lRet;

        lRet = ParseFile(szText, IsLFNDriveX(hDlg, szText), bWowApp, FALSE);
        nFileOffset = LOWORD(lRet);
        cb = HIWORD(lRet);
        if (nFileOffset < 0)
        {
            //
            //  If there was a parsing error, check for CHAR_SEMICOLON
            //  delimeter.
            //
            if (szText[cb] == CHAR_SEMICOLON)
            {
                szText[cb] = CHAR_NULL;
                nFileOffset = (WORD)ParseFile( szText,
                                               IsLFNDriveX(hDlg, szText),
                                               bWowApp,
                                               FALSE );
                szText[cb] = CHAR_SEMICOLON;
                if (nFileOffset < 0)
                {
                    //
                    //  Still trouble, so Exit.
                    //
                    szText[0] = CHAR_NULL;
                }
            }
            else
            {
                szText[0] = CHAR_NULL;
            }
        }
        if (nFileOffset > 0)
        {
            lstrcpy(szText, (LPTSTR)(szText + nFileOffset));
        }
        if (nFileOffset)
        {
            SetDlgItemText(hDlg, edt1, szText);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  lstrtok
//
////////////////////////////////////////////////////////////////////////////

LPTSTR lstrtok(
    LPTSTR lpStr,
    LPTSTR lpDelim)
{
    static LPTSTR lpString;
    LPTSTR lpRetVal, lpTemp;

    //
    //  If we are passed new string skip leading delimiters.
    //
    if (lpStr)
    {
        lpString = lpStr;

        while (*lpString && StrChr(lpDelim, *lpString))
        {
            lpString = CharNext(lpString);
        }
    }

    //
    //  If there are no more tokens, return NULL.
    //
    if (!*lpString)
    {
        return (CHAR_NULL);
    }

    //
    //  Save head of token.
    //
    lpRetVal = lpString;

    //
    //  Find delimiter or end of string.
    //
    while (*lpString && !StrChr(lpDelim, *lpString))
    {
        lpString = CharNext(lpString);
    }

    //
    //  If we found a delimiter insert string terminator and skip.
    //
    if (*lpString)
    {
        lpTemp = CharNext(lpString);
        *lpString = CHAR_NULL;
        lpString = lpTemp;
    }

    //
    //  Return token.
    //
    return (lpRetVal);
}


////////////////////////////////////////////////////////////////////////////
//
//  ChopText
//
////////////////////////////////////////////////////////////////////////////

LPTSTR ChopText(
    HWND hwndDlg,
    int idStatic,
    LPTSTR lpch)
{
    RECT rc;
    register int cxField;
    BOOL fChop = FALSE;
    HWND hwndStatic;
    HDC hdc;
    TCHAR chDrv;
    HANDLE hOldFont;
    LPTSTR lpstrStart = lpch;
    SIZE Size;
    BOOL bRet;

    //
    //  Get length of static field.
    //
    hwndStatic = GetDlgItem(hwndDlg, idStatic);
    GetClientRect(hwndStatic, (LPRECT)&rc);
    cxField = rc.right - rc.left;

    //
    //  Chop characters off front end of text until short enough.
    //
    hdc = GetDC(hwndStatic);

    hOldFont = NULL;

    while ((bRet = GetTextExtentPoint(hdc, lpch, lstrlen(lpch), &Size)) &&
           (cxField < Size.cx))
    {
        if (!fChop)
        {
            chDrv = *lpch;

            //
            //  Proportional font support.
            //
            if (bRet = GetTextExtentPoint(hdc, lpch, 7, &Size))
            {
                cxField -= Size.cx;
            }
            else
            {
                break;
            }

            if (cxField <= 0)
            {
               break;
            }

            lpch += 7;
        }
        while (*lpch && (!ISBACKSLASH_P(lpstrStart, lpch)))
        {
            lpch++;
        }
        //Skip the backslash 
        lpch++;

        fChop = TRUE;
    }

    ReleaseDC(hwndStatic, hdc);

    //
    //  If any characters chopped off, replace first three characters in
    //  remaining text string with ellipsis.
    //
    if (fChop)
    {
        //Skip back to include the backslash
        lpch--;
        *--lpch = CHAR_DOT;
        *--lpch = CHAR_DOT;
        *--lpch = CHAR_DOT;
        *--lpch = *(lpstrStart + 2);
        *--lpch = *(lpstrStart + 1);
        *--lpch = *lpstrStart;
    }

    return (lpch);
}


////////////////////////////////////////////////////////////////////////////
//
//  FillOutPath
//
//  Fills out lst2 given that the current directory has been set.
//
//  Returns:  TRUE    if they DO NOT match
//            FALSE   if match
//
////////////////////////////////////////////////////////////////////////////

BOOL FillOutPath(
    HWND hList,
    POPENFILEINFO pOFI)
{
    TCHAR szPath[CCHNETPATH];
    LPTSTR lpCurDir;
    LPTSTR lpB, lpF;
    TCHAR wc;
    int cchPathOffset;
    LPCURDLG lpCurDlg;

    if(!(lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg)) ||
       !(lpCurDir = lpCurDlg->lpstrCurDir))
    {
        return (FALSE);
    }

    lpF = szPath;    
    lstrcpy(lpF, lpCurDir);

    //
    //  Wow apps started from lfn dirs will set the current directory to an
    //  lfn, but only in the case where it is less than 8 chars.
    //
    if (pOFI->pOFN->Flags & OFN_NOLONGNAMES)
    {
        ShortenThePath(lpF);
    }

    *lpF = (TCHAR)CharLower((LPTSTR)*lpF);
    cchPathOffset = GetPathOffset(lpF);
    if (cchPathOffset == -1)
    {
        cchPathOffset = 0;
    }
    lpB = (lpF + cchPathOffset);

    //
    //  Hack to retain Winball display functionality.
    //  Drived disks are displayed as C:\ (the root dir).
    //  whereas unc disks are displayed as \\server\share (the disk).
    //  Hence, extend display of drived disks by one char.
    //
    if (*(lpF + 1) == CHAR_COLON)
    {
        wc = *(++lpB);
        *lpB = CHAR_NULL;
    }
    else
    {
        //
        //  Since we use lpF over and over again to speed things
        //  up, and since GetCurrentDirectory returns the disk name
        //  for unc, but the root path for drives, we have the following hack
        //  for when we are at the root of the unc directory, and lpF
        //  contains old stuff out past cchPathOffset.
        //
        PathAddBackslash(lpF);

        wc = 0;
        *lpB++ = CHAR_NULL;
    }

    //
    //  Insert the items for the path to the current dir
    //  Insert the root...
    //
    pOFI->idirSub = 0;

    SendMessage(hList, LB_INSERTSTRING, pOFI->idirSub++, (LPARAM)lpF);

    if (wc)
    {
        *lpB = wc;
    }

    for (lpF = lpB; *lpB; lpB++)
    {
        if ((ISBACKSLASH_P(szPath, lpB)) || (*lpB == CHAR_SLASH))
        {
            *lpB = CHAR_NULL;

            SendMessage(hList, LB_INSERTSTRING, pOFI->idirSub++, (LPARAM)lpF);

            lpF = lpB + 1;

            *lpB = CHAR_BSLASH;
        }
    }

    //
    //  Assumes that a path always ends with one last un-delimited dir name.
    //  Check to make sure we have at least one.
    //
    if (lpF != lpB)
    {
        SendMessage(hList, LB_INSERTSTRING, pOFI->idirSub++, (LPARAM)lpF);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ShortenThePath
//
//  Takes a pathname and converts all dirs to shortnames if they are
//  not valid DOS 8.3 names.
//
//  Returns:  TRUE    if pathname converted
//            FALSE   if ran out of space, buffer left alone
//
////////////////////////////////////////////////////////////////////////////

BOOL ShortenThePath(
    LPTSTR pPath)
{
    TCHAR szDest[MAX_PATH];
    LPTSTR pSrcNextSpec, pReplaceSpec;
    LPTSTR pDest, p;
    LPTSTR pSrc;
    int cchPathOffset;
    HANDLE hFind;
    WIN32_FIND_DATA FindData;
    UINT i;
    int nSpaceLeft = MAX_PATH - 1;

#ifdef UNICODE
    UNICODE_STRING Name;
    BOOLEAN fSpace = FALSE;
#endif


    //
    //  Save pointer to beginning of buffer.
    //
    pSrc = pPath;

    //
    //  Eliminate double quotes.
    //
    for (p = pDest = pSrc; *p; p++, pDest++)
    {
        if (*p == CHAR_QUOTE)
        {
            p++;
        }
        *pDest = *p;
    }

    *pDest = CHAR_NULL;

    //
    //  Strip out leading spaces.
    //
    while (*pSrc == CHAR_SPACE)
    {
        pSrc++;
    }

    //
    //  Skip past \\foo\bar or <drive>:
    //
    pDest = szDest;
    pSrcNextSpec = pSrc;

    //
    //  Reuse shell32 internal api that calculates path offset.
    //  The cchPathOffset variable will be the offset that when added to
    //  the pointer will result in a pointer to the backslash before the
    //  first part of the path.
    //
    //  NOTE:  UNICODE only call.
    //
    cchPathOffset = GetPathOffset(pSrc);

    //
    //  Check to see if it's valid.  If pSrc is not of the \\foo\bar
    //  or <drive>: form we just do nothing.
    //
    if (cchPathOffset == -1)
    {
        return (TRUE);
    }

    //
    //  cchPathOffset will always be at least 1 and is the number of
    //  characters - 1 that we want to copy (that is, if 0 was
    //  permissible, it would denote 1 character).
    //
    do
    {
        *pDest++ = *pSrcNextSpec++;

        if (!--nSpaceLeft)
        {
            return (FALSE);
        }
    } while (cchPathOffset--);

    //
    //  At this point, we have just the filenames that we can shorten:
    //  \\foo\bar\it\is\here ->  it\is\here
    //  c:\angry\lions       ->  angry\lions
    //
    while (pSrcNextSpec)
    {
        //
        //  pReplaceSpec holds the current spec we need to replace.
        //  By default, if we can't find the altname, then just use this.
        //
        pReplaceSpec = pSrcNextSpec;

        //
        //  Search for trailing "\"
        //  pSrcNextSpec will point to the next spec to fix.
        //  (*pSrcNextSpec = NULL if done)
        //
        while (*pSrcNextSpec && (!ISBACKSLASH_P(pReplaceSpec, pSrcNextSpec)))
        {
            pSrcNextSpec++;
        }

        if (*pSrcNextSpec)
        {
            //
            //  If there is more, then pSrcNextSpec should point to it.
            //  Also delimit this spec.
            //
            *pSrcNextSpec = CHAR_NULL;
        }
        else
        {
            pSrcNextSpec = NULL;
        }

        hFind = FindFirstFile(pSrc, &FindData);

        //
        //  We could exit as soon as this FindFirstFileFails,
        //  but there's the special case of having execute
        //  without read permission.  This would fail since the lfn
        //  is valid for lfn apps.
        //
        if (hFind != INVALID_HANDLE_VALUE)
        {
            FindClose(hFind);

#ifdef UNICODE
            //
            //  See if it's not a legal 8.3 name or if there are spaces
            //  in the name.  If either is true, use the alternate name.
            //
            RtlInitUnicodeString(&Name, FindData.cFileName);
            if (!RtlIsNameLegalDOS8Dot3(&Name, NULL, &fSpace) || fSpace)
#endif
            {
                if (FindData.cAlternateFileName[0])
                {
                    pReplaceSpec = FindData.cAlternateFileName;
                }
            }
        }

        i = lstrlen(pReplaceSpec);
        nSpaceLeft -= i;

        if (nSpaceLeft <= 0)
        {
            return (FALSE);
        }

        lstrcpy(pDest, pReplaceSpec);
        pDest += i;

        //
        //  Now replace the CHAR_NULL with a slash if necessary.
        //
        if (pSrcNextSpec)
        {
            *pSrcNextSpec++ = CHAR_BSLASH;

            //
            //  Also add backslash to destination.
            //
            *pDest++ = CHAR_BSLASH;
            nSpaceLeft--;
        }
    }

    lstrcpy(pPath, szDest);

    return (TRUE);
}



////////////////////////////////////////////////////////////////////////////
//
//  FListAll
//
//  Given a file pattern, it changes the directory to that of the spec,
//  and updates the display.
//
////////////////////////////////////////////////////////////////////////////

int FListAll(
    POPENFILEINFO pOFI,
    HWND hDlg,
    LPTSTR szSpec)
{
    LPTSTR szPattern;
    TCHAR chSave;
    DWORD nRet = 0;
    TCHAR szDirBuf[MAX_FULLPATHNAME + 1];

    if (!bCasePreserved)
    {
        CharLower(szSpec);
    }

    //
    //  No directory.
    //
    if (!(szPattern = StrRChr( szSpec,
                               szSpec + lstrlen(szSpec),
                               CHAR_BSLASH )) &&
        !StrChr(szSpec, CHAR_COLON))
    {
        lstrcpy(pOFI->szSpecCur, szSpec);
        if (!bInitializing)
        {
            UpdateListBoxes(hDlg, pOFI, szSpec, mskDirectory);
        }
    }
    else
    {
        *szDirBuf = CHAR_NULL;

        //
        //  Just root + pattern.
        //
        if (szPattern == StrChr(szSpec, CHAR_BSLASH))
        {
            if (!szPattern)
            {
                //
                //  Didn't find a slash, must have drive.
                //
                szPattern = CharNext(CharNext(szSpec));
            }
            else if ((szPattern == szSpec) ||
                     ((szPattern - 2 == szSpec) &&
                      (*(szSpec + 1) == CHAR_COLON)))
            {
                szPattern = CharNext(szPattern);
            }
            else
            {
                goto KillSlash;
            }
            chSave = *szPattern;
            if (chSave != CHAR_DOT)
            {
                //
                //  If not c:.. or c:.
                //
                *szPattern = CHAR_NULL;
            }
            lstrcpy(szDirBuf, szSpec);
            if (chSave == CHAR_DOT)
            {
                szPattern = szSpec + lstrlen(szSpec);
                AppendExt(szPattern, pOFI->pOFN->lpstrDefExt, TRUE);
            }
            else
            {
                *szPattern = chSave;
            }
        }
        else
        {
KillSlash:
            *szPattern++ = 0;
            lstrcpy(szDirBuf, szSpec);
        }

        if ((nRet = ChangeDir(hDlg, szDirBuf, TRUE, FALSE)) < 0)
        {
            return (nRet);
        }

        lstrcpy(pOFI->szSpecCur, szPattern);
        SetDlgItemText(hDlg, edt1, pOFI->szSpecCur);

        SelDisk(hDlg, NULL);

        if (!bInitializing)
        {
            SendMessage( hDlg,
                         WM_COMMAND,
                         GET_WM_COMMAND_MPS( cmb2,
                                             GetDlgItem(hDlg, cmb2),
                                             MYCBN_DRAW ) );
        }
    }

    return (nRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  ChangeDir
//
//  Changes the current directory and/or resource.
//
//  lpszDir - Fully qualified, or partially qualified names.
//            To change to another disk and cd automatically to the
//            last directory as set in the shell's environment, specify
//            only a disk name (i.e. c: or \\triskal\scratch - must not end
//            in backslash).
//  bForce  - If True, then caller requires that ChangeDir successfully cd
//            somewhere.  Order of cding is as follows:
//                1. lpszDir
//                2. current dir for the current thread
//                3. root of current dir for the current thread
//                4. c:
//  bError - if TRUE, then pop up an AccessDenied dialog at every step
//           in the force.
//
//  Returns an index into gaDiskInfo for new disk chosen or,
//  the ADDDISK_error code.
//  Returns ADDDISK_NOCHANGE in the event that it cannot cd to the root
//  directory of the specific file.
//
////////////////////////////////////////////////////////////////////////////

int ChangeDir(
    HWND hDlg,
    LPCTSTR lpszDir,
    BOOL bForce,
    BOOL bError)
{
    TCHAR szCurDir[CCHNETPATH];
    LPTSTR lpCurDir;
    int cchDirLen;
    TCHAR wcDrive = 0;
    int nIndex;
    BOOL nRet;
    LPCURDLG lpCurDlg;


    //
    //  SheChangeDirEx will call GetCurrentDir, but will use what it
    //  gets only in the case where the path passed in was no good.
    //

    //
    //  1st, try request.
    //
    if (lpszDir && *lpszDir)
    {
        lstrcpyn(szCurDir, lpszDir, CCHNETPATH);

        //
        //  Remove trailing spaces.
        //
        lpCurDir = szCurDir + lstrlen(szCurDir) - 1;
        while (*lpCurDir && (*lpCurDir == CHAR_SPACE))
        {
            *lpCurDir-- = CHAR_NULL;
        }

        nRet = SheChangeDirEx(szCurDir);

        if (nRet == ERROR_ACCESS_DENIED)
        {
            if (bError)
            {
                //
                //  Casting to LPTSTR is ok below - InvalidFileWarning will
                //  not change this string because the path is always
                //  guaranteed to be <= MAX_FULLPATHNAME.
                //
                InvalidFileWarning( hDlg,
                                    (LPTSTR)lpszDir,
                                    ERROR_DIR_ACCESS_DENIED,
                                    0 );
            }

            if (!bForce)
            {
                return (CHANGEDIR_FAILED);
            }
        }
        else
        {
            goto ChangeDir_OK;
        }
    }

    //
    //  2nd, try lpCurDlg->lpstrCurDir value (which we got above).
    //
    //  !!! need to check for a null return value ???
    //
    lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);
    lpCurDir = (lpCurDlg ? lpCurDlg->lpstrCurDir : NULL);

    nRet = SheChangeDirEx(lpCurDir);

    if (nRet == ERROR_ACCESS_DENIED)
    {
        if (bError)
        {
            InvalidFileWarning( hDlg,
                                lpCurDir,
                                ERROR_DIR_ACCESS_DENIED,
                                0 );
        }
    }
    else
    {
        goto ChangeDir_OK;
    }

    //
    //  3rd, try root of lpCurDlg->lpstrCurDir or GetCurrentDir (sanity).
    //
    lstrcpy(szCurDir, lpCurDir);
    cchDirLen = GetPathOffset(szCurDir);

    //
    //  Sanity check - it's guaranteed not to fail ...
    //
    if (cchDirLen != -1)
    {
        szCurDir[cchDirLen] = CHAR_BSLASH;
        szCurDir[cchDirLen + 1] = CHAR_NULL;

        nRet = SheChangeDirEx(szCurDir);
        if (nRet == ERROR_ACCESS_DENIED)
        {
            if (bError)
            {
                InvalidFileWarning( hDlg,
                                    (LPTSTR)lpszDir,
                                    ERROR_DIR_ACCESS_DENIED,
                                    0 );
            }
        }
        else
        {
            goto ChangeDir_OK;
        }
    }

    //
    //  4th, try c:
    //
    lstrcpy(szCurDir, TEXT("c:"));
    nRet = SheChangeDirEx(szCurDir);
    if (nRet == ERROR_ACCESS_DENIED)
    {
        if (bError)
        {
            InvalidFileWarning( hDlg,
                                (LPTSTR)lpszDir,
                                ERROR_DIR_ACCESS_DENIED,
                                0 );
        }
    }
    else
    {
        goto ChangeDir_OK;
    }

    return (CHANGEDIR_FAILED);

ChangeDir_OK:

    GetCurrentDirectory(CCHNETPATH, szCurDir);

    nIndex = DiskAddedPreviously(0, szCurDir);

    //
    //  If the disk doesn't exist, add it.
    //
    if (nIndex == -1)
    {
        HWND hCmb2 = GetDlgItem(hDlg, cmb2);
        LPTSTR lpszDisk = NULL;
        DWORD dwType;
        TCHAR wc1, wc2;

        if (szCurDir[1] == CHAR_COLON)
        {
            wcDrive = szCurDir[0];
        }
        else
        {
            lpszDisk = &szCurDir[0];
        }

        cchDirLen = GetPathOffset(szCurDir);
        if (cchDirLen != -1)
        {
            wc1 = szCurDir[cchDirLen];
            wc2 = szCurDir[cchDirLen + 1];

            szCurDir[cchDirLen] = CHAR_BSLASH;
            szCurDir[cchDirLen + 1] = CHAR_NULL;
        }

        dwType = GetDiskIndex(GetDiskType(szCurDir));

        if (cchDirLen != -1)
        {
            szCurDir[cchDirLen] = CHAR_NULL;
        }

        nIndex = AddDisk(wcDrive, lpszDisk, NULL, dwType);

        SendMessage(hCmb2, WM_SETREDRAW, FALSE, 0L);

        wNoRedraw |= 1;

        SendMessage( hCmb2,
                     CB_SETITEMDATA,
                     (WPARAM)SendMessage(
                                 hCmb2,
                                 CB_ADDSTRING,
                                 (WPARAM)0,
                                 (LPARAM)(LPTSTR)gaDiskInfo[nIndex].lpAbbrName ),
                     (LPARAM)gaDiskInfo[nIndex].dwType );

        if ((dwType != NETDRVBMP) && (dwType != REMDRVBMP))
        {
            gaDiskInfo[nIndex].bCasePreserved =
                IsFileSystemCasePreserving(gaDiskInfo[nIndex].lpPath);
        }

        wNoRedraw &= ~1;

        SendMessage(hCmb2, WM_SETREDRAW, TRUE, 0L);

        if (cchDirLen != -1)
        {
            szCurDir[cchDirLen] = wc1;
            szCurDir[cchDirLen + 1] = wc2;
        }
    }
    else
    {
        //
        //  Validate the disk if it has been seen before.
        //
        //  For unc names that fade away, refresh the cmb2 box.
        //
        if (!gaDiskInfo[nIndex].bValid)
        {
            gaDiskInfo[nIndex].bValid = TRUE;

            SendDlgItemMessage(
                   hDlg,
                   cmb2,
                   CB_SETITEMDATA,
                   (WPARAM)SendDlgItemMessage(
                               hDlg,
                               cmb2,
                               CB_ADDSTRING,
                               (WPARAM)0,
                               (LPARAM)(LPTSTR)gaDiskInfo[nIndex].lpAbbrName ),
                   (LPARAM)gaDiskInfo[nIndex].dwType );
        }
    }

    //
    //  Update our global concept of Case.
    //
    if (nIndex >= 0)
    {
        //
        //  Send special WOW message to indicate the directory has
        //  changed.
        //
        SendMessage(hDlg, msgWOWDIRCHANGE, 0, 0);

        //
        //  Get pointer to current directory.
        //
        lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);
        lpCurDir = (lpCurDlg ? lpCurDlg->lpstrCurDir : NULL);
        if (!lpCurDlg || !lpCurDir)
        {
            return (CHANGEDIR_FAILED);
        }

        bCasePreserved = gaDiskInfo[nIndex].bCasePreserved;

        //
        //  In case the unc name already has a drive letter, correct
        //  lst2 display.
        //
        cchDirLen = 0;

        //
        //  Compare with szCurDir since it's been lowercased.
        //
        if (DBL_BSLASH(szCurDir) &&
            (*gaDiskInfo[nIndex].lpAbbrName != szCurDir[0]))
        {
            if ((cchDirLen = GetPathOffset(szCurDir)) != -1)
            {
                szCurDir[--cchDirLen] = CHAR_COLON;
                szCurDir[--cchDirLen] = *gaDiskInfo[nIndex].lpAbbrName;
            }
        }

        if ((gaDiskInfo[nIndex].dwType == CDDRVBMP) ||
            (gaDiskInfo[nIndex].dwType == FLOPPYBMP))
        {
            if (*lpCurDir != gaDiskInfo[nIndex].wcDrive)
            {
                TCHAR szDrive[5];

                //
                //  Get new volume info - should always succeed.
                //
                szDrive[0] = gaDiskInfo[nIndex].wcDrive;
                szDrive[1] = CHAR_COLON;
                szDrive[2] = CHAR_BSLASH;
                szDrive[3] = CHAR_NULL;
                UpdateLocalDrive(szDrive, TRUE);

                //
                //  Flush to the cmb before selecting the disk.
                //
                if ( lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg) )
                {
                    gahDlg[lpCurDlg->dwCurDlgNum] = hDlg;
                    FlushDiskInfoToCmb2();
                }
            }
        }
        
        lstrcpy(lpCurDir, (LPTSTR)&szCurDir[cchDirLen]);
        PathAddBackslash(lpCurDir);

        //
        //  If the worker thread is running, then trying to select here
        //  will just render the cmb2 blank, which is what we want;
        //  otherwise, it should successfully select it.
        //
        SelDisk(hDlg, gaDiskInfo[nIndex].lpPath);
    }
//  else
//  {
//      print out error message returned from AddDisk ...
//  }

    return (nIndex);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsFileSystemCasePreserving
//
////////////////////////////////////////////////////////////////////////////

BOOL IsFileSystemCasePreserving(
    LPTSTR lpszDisk)
{
    TCHAR szPath[MAX_FULLPATHNAME];
    DWORD dwFlags;

    if (!lpszDisk)
    {
        return (FALSE);
    }

    lstrcpy(szPath, lpszDisk);
    lstrcat(szPath, TEXT("\\"));

    if (GetVolumeInformation( szPath,
                              NULL,
                              0,
                              NULL,
                              NULL,
                              &dwFlags,
                              NULL,
                              0 ))
    {
        return ((dwFlags & FS_CASE_IS_PRESERVED));
    }

    //
    //  Default to FALSE if there is an error.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsLFNDriveX
//
////////////////////////////////////////////////////////////////////////////

BOOL IsLFNDriveX(
    HWND hDlg,
    LPTSTR szPath)
{
    TCHAR szRootPath[MAX_FULLPATHNAME];
    DWORD dwVolumeSerialNumber;
    DWORD dwMaximumComponentLength;
    DWORD dwFileSystemFlags;
    LPTSTR lpCurDir;
    LPCURDLG lpCurDlg;


    if (!szPath[0] || !szPath[1] ||
        (szPath[1] != CHAR_COLON && !(DBL_BSLASH(szPath))))
    {
        //
        //  If the path is not a full path then get the directory path
        //  from the TLS current directory.
        //
        lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);
        lpCurDir = (lpCurDlg ? lpCurDlg->lpstrCurDir : NULL);
        lstrcpy(szRootPath, lpCurDir);
    }
    else
    {
        lstrcpy(szRootPath, szPath);
    }

    if (szRootPath[1] == CHAR_COLON)
    {
        szRootPath[2] = CHAR_BSLASH;
        szRootPath[3] = 0;
    }
    else if (DBL_BSLASH(szRootPath))
    {
        int i;
        LPTSTR p;

        //
        //  Stop at "\\foo\bar".
        //
        for (i = 0, p = szRootPath + 2; *p && i < 2; p++)
        {
            if (ISBACKSLASH_P(szRootPath, p))
            {
                i++;
            }
        }

        switch (i)
        {
            case ( 0 ) :
            {
                return (FALSE);
            }
            case ( 1 ) :
            {
                if (lstrlen(szRootPath) < MAX_FULLPATHNAME - 2)
                {
                    *p = CHAR_BSLASH;
                    *(p + 1) = CHAR_NULL;
                }
                else
                {
                    return (FALSE);
                }
                break;
            }

            case ( 2 ) :
            {
                *p = CHAR_NULL;
                break;
            }
        }
    }

    if (GetVolumeInformation( szRootPath,
                              NULL,
                              0,
                              &dwVolumeSerialNumber,
                              &dwMaximumComponentLength,
                              &dwFileSystemFlags,
                              NULL,
                              0 ))
    {
        if (dwMaximumComponentLength == (MAXDOSFILENAMELEN - 1))
        {
            return (FALSE);
        }
        else
        {
            return (TRUE);
        }
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DiskAddedPreviously
//
//  This routine checks to see if a disk resource has been previously
//  added to the global structure.
//
//  wcDrive  - if this is set, then there is no lpszName comparison
//  lpszName - if wcDrive is not set, but the lpszName is of the form
//               "c:\" then set wcDrive = *lpszName and index by drive letter
//             else assume lpszName is a unc name
//
//  Returns:   0xFFFFFFFF   failure (disk doesn't exist in list)
//             0 - 128      number of disk in list
//
////////////////////////////////////////////////////////////////////////////

int DiskAddedPreviously(
    TCHAR wcDrive,
    LPTSTR lpszName)
{
    WORD i;

    //
    //  There are two index schemes (by drive or by unc \\server\share).
    //  If it doesn't have a drive letter, assume unc.
    //
    if (wcDrive || (*(lpszName + 1) == CHAR_COLON))
    {
        if (!wcDrive)
        {
            wcDrive = *lpszName;
            wcDrive = (TCHAR)CharLower((LPTSTR)wcDrive);
        }

        for (i = 0; i < dwNumDisks; i++)
        {
            //
            //  See if the drive letters are the same.
            //
            if (wcDrive)
            {
                if (wcDrive == (TCHAR)CharLower((LPTSTR)gaDiskInfo[i].wcDrive))
                {
                    return (i);
                }
            }
        }
    }
    else
    {
        DWORD cchDirLen;
        TCHAR wc;

        //
        //  Check remote name (\\server\share).
        //
        cchDirLen = GetPathOffset(lpszName);

        //
        //  If we're given a unc path, get the disk name.
        //  Otherwise, assume the whole thing is a disk name.
        //
        if (cchDirLen != -1)
        {
            wc = *(lpszName + cchDirLen);
            *(lpszName + cchDirLen) = CHAR_NULL;
        }

        for (i = 0; i < dwNumDisks; i++)
        {
            if (!lstrcmpi(gaDiskInfo[i].lpName, lpszName))
            {
                if (cchDirLen != -1)
                {
                    *(lpszName + cchDirLen) = wc;
                }
                return (i);
            }
        }

        if (cchDirLen != -1)
        {
            *(lpszName + cchDirLen) = wc;
        }
    }

    return (0xFFFFFFFF);
}


////////////////////////////////////////////////////////////////////////////
//
//  AddDisk
//
//  Adds a disk to one of the global structures:
//      gaNetDiskInfo
//      gaLocalDiskInfo
//
//  wcDrive    - the drive to attach to (this parm should be 0 for unc)
//  lpName     - \\server\share name for remote disks
//               volume name for local disks
//  lpProvider - used for remote disks only, the name of the provider
//               used with WNetFormatNetworkName api
//  dwType     - type of the bitmap to display
//               except when we are adding a drive letter temporarily
//               at startup this parameter can equal TMPNETDRV in which
//               case we set the bitmap to NETDRVBMP
//
//  Returns:  -2    Cannot Add Disk
//            -1    DiskInfo did not change
//             0    dwNumDisks - DiskInfo changed
//
////////////////////////////////////////////////////////////////////////////

int AddDisk(
    TCHAR wcDrive,
    LPTSTR lpName,
    LPTSTR lpProvider,
    DWORD dwType)
{
    int nIndex, nRet;
    DWORD cchMultiLen = 0;
    DWORD cchAbbrLen = 0;
    DWORD cchLen;
    DWORD dwRet = 0;
    LPTSTR lpBuff;
    OFN_DISKINFO *pofndiDisk = NULL, *pgDI;


    //
    //  Sanity check - wcDrive and/or lpName must be set.
    //
    if (!wcDrive && (!lpName || !*lpName))
    {
        return (ADDDISK_INVALIDPARMS);
    }

    nIndex = DiskAddedPreviously(wcDrive, lpName);

    if (nIndex != 0xFFFFFFFF)
    {
        //
        //  Do not add a temporary drive letter if we already
        //  have something better (added, for example, in a previous call).
        //
        if (dwType == TMPNETDRV)
        {
            gaDiskInfo[nIndex].bValid = TRUE;
            return (ADDDISK_NOCHANGE);
        }

        //  Using a floating profile, there can be collisions between
        //  local and network drives in which case we take the former.
        //
        //  Note: If the drive is remembered, we assume that getdrivetype
        //        will return false and that the drive is not added.
        //        But if it was added, then we overwrite anyway,
        //        since it's the desired behavior.
        //
        if ((dwType == REMDRVBMP) &&
            (dwType != gaDiskInfo[nIndex].dwType))
        {
            return (ADDDISK_NOCHANGE);
        }

        //
        //  Update previous connections.
        //
        if (!lstrcmpi(lpName, gaDiskInfo[nIndex].lpName))
        {
            //
            //  Don't update a connection as remembered, unless it's been
            //  invalidated.
            //
            if (dwType != REMDRVBMP)
            {
                gaDiskInfo[nIndex].dwType = dwType;
            }
            gaDiskInfo[nIndex].bValid = TRUE;

            return (ADDDISK_NOCHANGE);
        }
        else if (!*lpName && ((dwType == CDDRVBMP) || (dwType == FLOPPYBMP)))
        {
            //
            //  Guard against lazy calls to updatelocaldrive erasing current
            //  changed dir volume name (set via changedir).
            //
            return (ADDDISK_NOCHANGE);
        }
    }

    if (dwNumDisks >= MAX_DISKS)
    {
        return (ADDDISK_MAXNUMDISKS);
    }

    //
    //  If there is a drive, then lpPath needs only 4.
    //  If it's unc, then lpPath just equals lpName.
    //
    if (wcDrive)
    {
        cchLen = 4;
    }
    else
    {
        cchLen = 0;
    }

    if (lpName && *lpName)
    {
        //
        //  Get the length of the standard (Remote/Local) name.
        //
        cchLen += (lstrlen(lpName) + 1);

        if (lpProvider && *lpProvider &&
            ((dwType == NETDRVBMP) || (dwType == REMDRVBMP)))
        {
            //
            //  Get the length for the multiline name.
            //
            dwRet = WNetFormatNetworkName( lpProvider,
                                           lpName,
                                           NULL,
                                           &cchMultiLen,
                                           WNFMT_MULTILINE,
                                           dwAveCharPerLine );
            if (dwRet != ERROR_MORE_DATA)
            {
                return (ADDDISK_NETFORMATFAILED);
            }

            //
            //  Add 4 for <drive-letter>:\ and NULL (safeguard)
            //
            if (wcDrive)
            {
                cchMultiLen += 4;
            }

            dwRet = WNetFormatNetworkName( lpProvider,
                                           lpName,
                                           NULL,
                                           &cchAbbrLen,
                                           WNFMT_ABBREVIATED,
                                           dwAveCharPerLine );
            if (dwRet != ERROR_MORE_DATA)
            {
                return (ADDDISK_NETFORMATFAILED);
            }

            //
            //  Add 4 for <drive-letter>:\ and NULL (safeguard).
            //
            if (wcDrive)
            {
                cchAbbrLen += 4;
            }
        }
        else
        {
            //
            //  Make enough room so that lpMulti and lpAbbr can point to
            //  4 characters (drive letter + : + space + null) ahead of
            //  lpremote.
            //
            if (wcDrive)
            {
                cchLen += 4;
            }
        }
    }
    else
    {
        //
        //  Make enough room so that lpMulti and lpAbbr can point to
        //  4 characters (drive letter + : + space + null) ahead of
        //  lpremote.
        //
        if (wcDrive)
        {
            cchLen += 4;
        }
    }

    //
    //  Allocate a temp OFN_DISKINFO object to work with.
    //  When we are finished, we'll request the critical section
    //  and update the global array.
    //
    pofndiDisk = (OFN_DISKINFO *)LocalAlloc(LPTR, sizeof(OFN_DISKINFO));
    if (!pofndiDisk)
    {
        //
        //  Can't alloc or realloc memory, return error.
        //
        nRet = ADDDISK_ALLOCFAILED;
        goto AddDisk_Error;
    }

    lpBuff = (LPTSTR)LocalAlloc( LPTR,
                                 (cchLen + cchMultiLen + cchAbbrLen) * sizeof(TCHAR));
    if (!lpBuff)
    {
        //
        //  Can't alloc or realloc memory, return error.
        //
        nRet = ADDDISK_ALLOCFAILED;
        goto AddDisk_Error;
    }

    if (dwType == TMPNETDRV)
    {
        pofndiDisk->dwType = NETDRVBMP;
    }
    else
    {
        pofndiDisk->dwType = dwType;
    }

    //
    //  Always set these slots, even though wcDrive can equal 0.
    //
    pofndiDisk->wcDrive = wcDrive;
    pofndiDisk->bValid = TRUE;

    pofndiDisk->cchLen = cchLen + cchAbbrLen + cchMultiLen;

    //
    //  NOTE: lpAbbrName must always point to the head of lpBuff
    //        so that we can free the block later at DLL_PROCESS_DETACH
    //
    if (lpName && *lpName && lpProvider && *lpProvider &&
        ((dwType == NETDRVBMP) || (dwType == REMDRVBMP)))
    {
        //
        //  Create an entry for a network disk.
        //
        pofndiDisk->lpAbbrName = lpBuff;

        if (wcDrive)
        {
            *lpBuff++ = wcDrive;
            *lpBuff++ = CHAR_COLON;
            *lpBuff++ = CHAR_SPACE;

            cchAbbrLen -= 3;
        }

        dwRet = WNetFormatNetworkName( lpProvider,
                                       lpName,
                                       lpBuff,
                                       &cchAbbrLen,
                                       WNFMT_ABBREVIATED,
                                       dwAveCharPerLine );
        if (dwRet != WN_SUCCESS)
        {
            nRet = ADDDISK_NETFORMATFAILED;
            LocalFree(lpBuff);
            goto AddDisk_Error;
        }

        lpBuff += cchAbbrLen;

        pofndiDisk->lpMultiName = lpBuff;

        if (wcDrive)
        {
            *lpBuff++ = wcDrive;
            *lpBuff++ = CHAR_COLON;
            *lpBuff++ = CHAR_SPACE;

            cchMultiLen -= 3;
        }

        dwRet = WNetFormatNetworkName(lpProvider, lpName,
                                      lpBuff, &cchMultiLen, WNFMT_MULTILINE, dwAveCharPerLine);
        if (dwRet != WN_SUCCESS)
        {
            nRet = ADDDISK_NETFORMATFAILED;
            LocalFree(lpBuff);
            goto AddDisk_Error;
        }

        //
        //  Note: this assumes that the lpRemoteName
        //        returned by WNetEnumResources is always in
        //        the form \\server\share (without a trailing bslash).
        //
        pofndiDisk->lpPath = lpBuff;

        //
        //  if it's not unc.
        //
        if (wcDrive)
        {
            *lpBuff++ = wcDrive;
            *lpBuff++ = CHAR_COLON;
            *lpBuff++ = CHAR_NULL;
        }

        lstrcpy(lpBuff, lpName);
        pofndiDisk->lpName = lpBuff;

        pofndiDisk->bCasePreserved =
            IsFileSystemCasePreserving(pofndiDisk->lpPath);
    }
    else
    {
        //
        //  Create entry for a local name, or a network one with
        //  no name yet.
        //
        pofndiDisk->lpAbbrName = pofndiDisk->lpMultiName = lpBuff;

        if (wcDrive)
        {
            *lpBuff++ = wcDrive;
            *lpBuff++ = CHAR_COLON;
            *lpBuff++ = CHAR_SPACE;
        }

        if (lpName)
        {
            lstrcpy(lpBuff, lpName);
        }
        else
        {
            *lpBuff = CHAR_NULL;
        }

        pofndiDisk->lpName = lpBuff;

        if (wcDrive)
        {
            lpBuff += lstrlen(lpBuff) + 1;
            *lpBuff = wcDrive;
            *(lpBuff + 1) = CHAR_COLON;
            *(lpBuff + 2) = CHAR_NULL;
        }

        pofndiDisk->lpPath = lpBuff;

        if ((dwType == NETDRVBMP) || (dwType == REMDRVBMP))
        {
            pofndiDisk->bCasePreserved =
                IsFileSystemCasePreserving(pofndiDisk->lpPath);
        }
        else
        {
            pofndiDisk->bCasePreserved = FALSE;
        }
    }

    //
    //  Now we need to update the global array.
    //
    if (nIndex == 0xFFFFFFFF)
    {
        nIndex = dwNumDisks;
    }

    pgDI = &gaDiskInfo[nIndex];

    //
    //  Enter critical section and update data.
    //
    EnterCriticalSection(&g_csLocal);

    pgDI->cchLen = pofndiDisk->cchLen;
    pgDI->lpAbbrName = pofndiDisk->lpAbbrName;
    pgDI->lpMultiName = pofndiDisk->lpMultiName;
    pgDI->lpName = pofndiDisk->lpName;
    pgDI->lpPath = pofndiDisk->lpPath;
    pgDI->wcDrive = pofndiDisk->wcDrive;
    pgDI->bCasePreserved = pofndiDisk->bCasePreserved;
    pgDI->dwType = pofndiDisk->dwType;
    pgDI->bValid = pofndiDisk->bValid;

    LeaveCriticalSection(&g_csLocal);

    if ((DWORD)nIndex == dwNumDisks)
    {
        dwNumDisks++;
    }

    nRet = nIndex;

AddDisk_Error:

    if (pofndiDisk)
    {
        LocalFree(pofndiDisk);
    }

    return (nRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  EnableDiskInfo
//
////////////////////////////////////////////////////////////////////////////

VOID EnableDiskInfo(
    BOOL bValid,
    BOOL bDoUnc)
{
    DWORD dwCnt = dwNumDisks;

    EnterCriticalSection(&g_csLocal);
    while (dwCnt--)
    {
        if (gaDiskInfo[dwCnt].dwType == NETDRVBMP)
        {
            if (!(DBL_BSLASH(gaDiskInfo[dwCnt].lpAbbrName)) || bDoUnc)
            {
                gaDiskInfo[dwCnt].bValid = bValid;
            }

            //
            //  Always re-invalidate remembered just in case someone
            //  escapes from fileopen, removes a connection
            //  overriding a remembered and comes back expecting to see
            //  the original remembered.
            //
        }
    }
    LeaveCriticalSection(&g_csLocal);
}


////////////////////////////////////////////////////////////////////////////
//
//  FlushDiskInfoToCmb2
//
////////////////////////////////////////////////////////////////////////////

VOID FlushDiskInfoToCmb2()
{
    DWORD dwDisk;
    DWORD dwDlg;

    for (dwDlg = 0; dwDlg < dwNumDlgs; dwDlg++)
    {
        if (gahDlg[dwDlg])
        {
            HWND hCmb2;

            if (hCmb2 = GetDlgItem(gahDlg[dwDlg], cmb2))
            {
                wNoRedraw |= 1;

                SendMessage(hCmb2, WM_SETREDRAW, FALSE, 0L);

                SendMessage(hCmb2, CB_RESETCONTENT, 0, 0);

                dwDisk = dwNumDisks;
                while (dwDisk--)
                {
                    if (gaDiskInfo[dwDisk].bValid)
                    {
                        SendMessage(
                            hCmb2,
                            CB_SETITEMDATA,
                            (WPARAM)SendMessage(
                                hCmb2,
                                CB_ADDSTRING,
                                (WPARAM)0,
                                (LPARAM)(LPTSTR)gaDiskInfo[dwDisk].lpAbbrName ),
                            (LPARAM)gaDiskInfo[dwDisk].dwType );
                    }
                }

                wNoRedraw &= ~1;

                SendMessage(hCmb2, WM_SETREDRAW, TRUE, 0L);
                InvalidateRect(hCmb2, NULL, FALSE);

                SendMessage( gahDlg[dwDlg],
                             WM_COMMAND,
                             GET_WM_COMMAND_MPS(cmb2, hCmb2, MYCBN_REPAINT) );
            }

            gahDlg[dwDlg] = NULL;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CallNetDlg
//
//  Calls the appropriate network dialog in winnet driver.
//
//  hwndParent - parent window of network dialog
//
//  Returns:  TRUE     there are new drives to display
//            FALSE    there are no new drives to display
//
////////////////////////////////////////////////////////////////////////////

BOOL CallNetDlg(
    HWND hWnd)
{
    DWORD wRet;

    HourGlass(TRUE);

    wRet = WNetConnectionDialog(hWnd, WNTYPE_DRIVE);

    if ((wRet != WN_SUCCESS) && (wRet != WN_CANCEL) && (wRet != 0xFFFFFFFF))
    {
        if (!LoadString( g_hinst,
                         iszNoNetButtonResponse,
                         szCaption,
                         WARNINGMSGLENGTH ))
        {
            //
            //  !!!!! CAUTION
            //  The following is not portable between code pages.
            //
            wsprintf( szWarning,
                      TEXT("Error occurred, but error resource cannot be loaded.") );
        }
        else
        {
            wsprintf(szWarning, szCaption);

            GetWindowText(hWnd, szCaption, WARNINGMSGLENGTH);
            MessageBox( hWnd,
                        szWarning,
                        szCaption,
                        MB_OK | MB_ICONEXCLAMATION );
        }
    }

    HourGlass(FALSE);

    return (wRet == WN_SUCCESS);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDiskType
//
////////////////////////////////////////////////////////////////////////////

UINT GetDiskType(
    LPTSTR lpszDisk)
{
    //
    //  Unfortunately GetDriveType is not for deviceless connections.
    //  So assume all unc stuff is just "remote" - no way of telling
    //  if it's a cdrom or not.
    //
    if (DBL_BSLASH(lpszDisk))
    {
        return (DRIVE_REMOTE);
    }
    else
    {
        return (GetDriveType(lpszDisk));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetUNCDirectoryFromLB
//
//  If lb contains a UNC listing, the function returns the full UNC path.
//
//  Returns:   0 if no UNC listing in lb
//             length of UNC listing string
//
////////////////////////////////////////////////////////////////////////////

DWORD GetUNCDirectoryFromLB(
    HWND hDlg,
    WORD nLB,
    POPENFILEINFO pOFI)
{
    DWORD cch;
    DWORD idir;
    DWORD idirCurrent;

    cch = (DWORD)SendDlgItemMessage( hDlg,
                                     nLB,
                                     LB_GETTEXT,
                                     0,
                                     (LPARAM)(LPTSTR)pOFI->szPath );
    //
    //  If not UNC listing, return 0.
    //
    if (pOFI->szPath[0] != CHAR_BSLASH)
    {
        return (0);
    }

    idirCurrent = (WORD)(DWORD)SendDlgItemMessage( hDlg,
                                                   nLB,
                                                   LB_GETCURSEL,
                                                   0,
                                                   0L );
    if (idirCurrent < (pOFI->idirSub - 1))
    {
        pOFI->idirSub = idirCurrent;
    }
    pOFI->szPath[cch++] = CHAR_BSLASH;
    for (idir = 1; idir < pOFI->idirSub; ++idir)
    {
        cch += (DWORD)SendDlgItemMessage( hDlg,
                                          nLB,
                                          LB_GETTEXT,
                                          (WPARAM)idir,
                                          (LPARAM)(LPTSTR)&pOFI->szPath[cch] );
        pOFI->szPath[cch++] = CHAR_BSLASH;
    }

    //
    //  Only add the subdirectory if it's not the \\server\share point.
    //
    if (idirCurrent && (idirCurrent >= pOFI->idirSub))
    {
        cch += (DWORD)SendDlgItemMessage( hDlg,
                                          nLB,
                                          LB_GETTEXT,
                                          (WPARAM)idirCurrent,
                                          (LPARAM)(LPTSTR)&pOFI->szPath[cch] );
        pOFI->szPath[cch++] = CHAR_BSLASH;
    }

    pOFI->szPath[cch] = CHAR_NULL;

    return (cch);
}


////////////////////////////////////////////////////////////////////////////
//
//  SelDisk
//
//  Selects the given disk in the combo drive list.  Works for unc names,
//  too.
//
////////////////////////////////////////////////////////////////////////////

VOID SelDisk(
    HWND hDlg,
    LPTSTR lpszDisk)
{
    HWND hCmb = GetDlgItem(hDlg, cmb2);

    if (lpszDisk)
    {
        CharLower(lpszDisk);

        SendMessage( hCmb,
                     CB_SETCURSEL,
                     (WPARAM)SendMessage( hCmb,
                                          CB_FINDSTRING,
                                          (WPARAM)-1,
                                          (LPARAM)lpszDisk ),
                     0L );
    }
    else
    {
        TCHAR szChangeSel[CCHNETPATH];
        LPTSTR lpCurDir;
        LPCURDLG lpCurDlg;
        int cch = CCHNETPATH;

        if ((lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg)) &&
            (lpCurDir = lpCurDlg->lpstrCurDir))
        {
            lstrcpy(szChangeSel, lpCurDir);
            GetCurrentDirectory(ARRAYSIZE(szChangeSel), szChangeSel);

            if ((cch = GetPathOffset(szChangeSel)) != -1)
            {
                szChangeSel[cch] = CHAR_NULL;
            }

            SendMessage( hCmb,
                         CB_SETCURSEL,
                         (WPARAM)SendMessage( hCmb,
                                              CB_FINDSTRING,
                                              (WPARAM)-1,
                                              (LPARAM)szChangeSel ),
                         0L );
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  LNDSetEvent
//
////////////////////////////////////////////////////////////////////////////

VOID LNDSetEvent(
    HWND hDlg)
{
    LPCURDLG lpCurDlg;

    lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);

    if ( lpCurDlg &&
         hLNDEvent &&
         !wNoRedraw &&
         hLNDThread &&
         bNetworkInstalled)
    {
        gahDlg[lpCurDlg->dwCurDlgNum] = hDlg;

        SetEvent(hLNDEvent);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateLocalDrive
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateLocalDrive(
    LPTSTR szDrive,
    BOOL bGetVolName)
{
    DWORD dwFlags = 0;
    DWORD dwDriveType;
    TCHAR szVolLabel[MAX_PATH];

    //
    //  No unc here - so bypass extra call to GetDiskType and call
    //  GetDriveType directly.
    //
    dwDriveType = GetDriveType(szDrive);
    if ((dwDriveType != 0) && (dwDriveType != 1))
    {
        BOOL bRet = TRUE;

        szVolLabel[0] = CHAR_NULL;
        szDrive[1] = CHAR_COLON;
        szDrive[2] = CHAR_NULL;

        if ( bGetVolName ||
             ((dwDriveType != DRIVE_REMOVABLE) &&
              (dwDriveType != DRIVE_CDROM) &&
              (dwDriveType != DRIVE_REMOTE)) )
        {
            //
            //  Removing call to CharUpper since it causes trouble on
            //  turkish machines.
            //
            //  CharUpper(szDrive);

            if (GetFileAttributes(szDrive) != (DWORD)0xffffffff)
            {
                if (dwDriveType != DRIVE_REMOTE)
                {
                    szDrive[2] = CHAR_BSLASH;

                    bRet = GetVolumeInformation( szDrive,
                                                 szVolLabel,
                                                 MAX_PATH,
                                                 NULL,
                                                 NULL,
                                                 &dwFlags,
                                                 NULL,
                                                 (DWORD)0 );

                    //
                    //  The adddisk hack to prevent lazy loading from
                    //  overwriting the current removable media's label
                    //  with "" (because it never calls getvolumeinfo)
                    //  is to not allow null lpnames to overwrite, so when
                    //  the volume label really is null, we make it a space.
                    //
                    if (!szVolLabel[0])
                    {
                        szVolLabel[0] = CHAR_SPACE;
                        szVolLabel[1] = CHAR_NULL;
                    }
                }
            }
        }

        if (bRet)
        {
            int nIndex;

            CharLower(szDrive);

            if (dwDriveType == DRIVE_REMOTE)
            {
                nIndex = AddDisk( szDrive[0],
                                  szVolLabel,
                                  NULL,
                                  TMPNETDRV );
            }
            else
            {
                nIndex = AddDisk( szDrive[0],
                                  szVolLabel,
                                  NULL,
                                  GetDiskIndex(dwDriveType) );
            }

            if (nIndex != ADDDISK_NOCHANGE)
            {
                gaDiskInfo[nIndex].bCasePreserved =
                    (dwFlags & FS_CASE_IS_PRESERVED);
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetNetDrives
//
//  Enumerates network disk resources and updates the global disk info
//  structure.
//
//  dwScope   RESOURCE_CONNECTED or RESOURCE_REMEMBERED
//
//  Returns the last connection that did not previously exist.
//
////////////////////////////////////////////////////////////////////////////

VOID GetNetDrives(
    DWORD dwScope)
{
    DWORD dwRet;
    HANDLE hEnum = NULL;

    //
    //  Guard against termination with the enum handle open.
    //
    dwRet = WNetOpenEnum( dwScope,
                          RESOURCETYPE_DISK,
                          RESOURCEUSAGE_CONNECTABLE,
                          NULL,
                          &hEnum );
    if (dwRet == WN_SUCCESS)
    {
        while (dwRet == WN_SUCCESS)
        {
            DWORD dwCount = 0xffffffff;
            DWORD cbSize = cbNetEnumBuf;

            if (bLNDExit)
            {
                WNetCloseEnum(hEnum);
                return;
            }

            dwRet = WNetEnumResource(hEnum, &dwCount, gpcNetEnumBuf, &cbSize);
            switch (dwRet)
            {
                case ( WN_SUCCESS ) :
                {
                    //
                    //  Add the Entries to the listbox.
                    //
                    TCHAR wcDrive = 0;
                    NETRESOURCE *pNetRes;
                    WORD i;

                    pNetRes = (LPNETRESOURCE)gpcNetEnumBuf;

                    for (i = 0; dwCount; dwCount--, i++)
                    {
                        if (pNetRes[i].lpLocalName)
                        {
                            CharLower(pNetRes[i].lpLocalName);
                            wcDrive = *pNetRes[i].lpLocalName;
                        }
                        else
                        {
                            //
                            //  Skip deviceless names that are not
                            //  LanMan provided (or, in the case where there
                            //  is no LanMan provider name, skip deviceless
                            //  always).
                            //
                            wcDrive = 0;
                        }

                        if (!DBL_BSLASH(pNetRes[i].lpRemoteName))
                        {
                            continue;
                        }

                        //
                        //  When bGetNetDrivesSync is TRUE, we are coming back
                        //  from the Network button, so we want to cd to the
                        //  last connected drive.
                        //      (see last command in this routine)
                        //
                        if (bGetNetDrivesSync)
                        {
                            int nIndex;
                            WORD k;

                            nIndex = AddDisk( wcDrive,
                                              pNetRes[i].lpRemoteName,
                                              pNetRes[i].lpProvider,
                                              (dwScope == RESOURCE_REMEMBERED)
                                                  ? REMDRVBMP
                                                  : NETDRVBMP );

                            //
                            //  If it's a new connection, update global state.
                            //
                            if (nIndex >= 0)
                            {
                                //
                                //  Since flushdiskinfotocmb2 will clear out
                                //  the array below, remember it's state here.
                                //  It's a hack, but a nice way to find out
                                //  exactly which of the many threads
                                //  completed a net dlg operation.
                                //
                                for (k = 0; k < dwNumDlgs; k++)
                                {
                                    if (gahDlg[k])
                                    {
                                        //  Could encounter small problems with
                                        //  preemption here, but assume that
                                        //  user cannot simultaneously return
                                        //  from two different net dlg calls.
                                        //
                                        lpNetDriveSync = gaDiskInfo[nIndex].lpPath;

                                        SendMessage(
                                            gahDlg[k],
                                            WM_COMMAND,
                                            GET_WM_COMMAND_MPS(
                                                   cmb2,
                                                   GetDlgItem(gahDlg[k], cmb2),
                                                   MYCBN_CHANGEDIR ) );
                                    }
                                }
                            }
                        }
                        else
                        {
                            AddDisk( wcDrive,
                                     pNetRes[i].lpRemoteName,
                                     pNetRes[i].lpProvider,
                                     (dwScope == RESOURCE_REMEMBERED)
                                         ? REMDRVBMP
                                         : NETDRVBMP );
                        }
                    }
                    break;
                }
                case ( WN_MORE_DATA ) :
                {
                    LPTSTR pcTemp;

                    pcTemp = (LPTSTR)LocalReAlloc( gpcNetEnumBuf,
                                                   cbSize,
                                                   LMEM_MOVEABLE );
                    if (!pcTemp)
                    {
                        cbNetEnumBuf = 0;
                    }
                    else
                    {
                        gpcNetEnumBuf = pcTemp;
                        cbNetEnumBuf = cbSize;
                        dwRet = WN_SUCCESS;
                        break;
                    }
                }
                case ( WN_NO_MORE_ENTRIES ) :
                case ( WN_EXTENDED_ERROR ) :
                case ( WN_NO_NETWORK ) :
                {
                    //
                    //  WN_NO_MORE_ENTRIES is a success error code.
                    //  It is special cased when we fall out of the loop.
                    //
                    break;
                }
                case ( WN_BAD_HANDLE ) :
                default :
                {
                    break;
                }
            }
        }

        WNetCloseEnum(hEnum);

        //
        //  Flush once per event - there will always be a call with
        //  dwscope = connected.
        //
        if (dwScope == RESOURCE_CONNECTED)
        {
            FlushDiskInfoToCmb2();
        }

        if (bGetNetDrivesSync)
        {
            bGetNetDrivesSync = FALSE;
        }
    }
}


#if 0
// See comments in ListNetDrivesHandler

////////////////////////////////////////////////////////////////////////////
//
//  HideNetButton
//
////////////////////////////////////////////////////////////////////////////

VOID HideNetButton()
{
    DWORD dwDlg;
    HWND hNet;

    for (dwDlg = 0; dwDlg < dwNumDlgs; dwDlg++)
    {
        hNet = GetDlgItem(gahDlg[dwDlg], psh14);

        EnableWindow(hNet, FALSE);
        ShowWindow(hNet, SW_HIDE);
    }
}
#endif


////////////////////////////////////////////////////////////////////////////
//
//  ListNetDrivesHandler
//
////////////////////////////////////////////////////////////////////////////

VOID ListNetDrivesHandler()
{
    BOOL bInit = TRUE;
    HANDLE hEnum = NULL;
    WORD wCurDrive;
    TCHAR szDrive[5];

    if (!gpcNetEnumBuf &&
        !(gpcNetEnumBuf = (LPTSTR)LocalAlloc(LPTR, cbNetEnumBuf)))
    {
        hLNDThread = NULL;
        return;
    }

    if (bLNDExit)
    {
        goto LNDExitThread1;
    }

    EnterCriticalSection(&g_csNetThread);

    while (1)
    {
        if (bLNDExit)
        {
            goto LNDExitThread;
        }

        //
        //  hLNDEvent will always be valid since we have loaded ourself
        //  and FreeLibrary will not produce a DLL_PROCESS_DETACH.
        //
        WaitForSingleObject(hLNDEvent, INFINITE);

        //
        //  In case this is the exit event.
        //
        if (bLNDExit)
        {
            goto LNDExitThread;
        }

        EnableDiskInfo(FALSE, FALSE);

        //
        //  Get the drive information for all drives.
        //
        //  NOTE: If we don't redo all volume info, then a change in a volume
        //        label will never be caught by wow apps unless wowexec is
        //        killed and restarted.  Therefore, information for all drives
        //        should be retrieved here.
        //
        for (wCurDrive = 0; wCurDrive <= 25; wCurDrive++)
        {
            szDrive[0] = (CHAR_A + (TCHAR)wCurDrive);
            szDrive[1] = CHAR_COLON;
            szDrive[2] = CHAR_BSLASH;
            szDrive[3] = CHAR_NULL;

            UpdateLocalDrive(szDrive, FALSE);
        }

        if (bInit)
        {
            GetNetDrives(RESOURCE_REMEMBERED);

            //
            //  In case this is the exit event.
            //
            if (bLNDExit)
            {
                goto LNDExitThread;
            }

            GetNetDrives(RESOURCE_CONNECTED);

            //
            //  In case this is the exit event.
            //
            if (bLNDExit)
            {
                goto LNDExitThread;
            }

            bInit = FALSE;
        }
        else
        {
            //
            //  In case this is the exit event.
            //
            if (bLNDExit)
            {
                goto LNDExitThread;
            }

            GetNetDrives(RESOURCE_CONNECTED);

            //
            //  In case this is the exit event.
            //
            if (bLNDExit)
            {
                goto LNDExitThread;
            }
        }

        ResetEvent(hLNDEvent);
    }

LNDExitThread:

    bLNDExit = FALSE;
    LeaveCriticalSection(&g_csNetThread);

LNDExitThread1:

    FreeLibraryAndExitThread(g_hinst, 1);

    //
    //  The ExitThread is implicit in this return.
    //
    return;
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadDrives
//
//  Lists the current drives (connected) in the combo box.
//
////////////////////////////////////////////////////////////////////////////

VOID LoadDrives(
    HWND hDlg)
{
    //
    //  Hard-code this - It's internal && always cmb2/psh14.
    //
    HWND hCmb = GetDlgItem(hDlg, cmb2);
    DWORD dwThreadID;
    LPCURDLG lpCurDlg;

    if (!hLNDEvent)
    {
        //
        //  Don't check if this succeeds since we can run without the net.
        //
        hLNDEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    }
    else
    {
        //
        //  Assume all previous connections (except unc) are valid
        //  for first display - but only when they exist.
        //
        EnableDiskInfo(TRUE, FALSE);
    }

    //
    //  Set the hDlg into the refresh array before initially
    //  creating the thread so that the worker thread can hide/disable
    //  the net button in the event that there is no network.
    //
    lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);

    // sanity check
    if (!lpCurDlg)
    {
        return;
    }

    gahDlg[lpCurDlg->dwCurDlgNum] = hDlg;

    //
    //  If there is no worker thread for network disk enumeration,
    //  start up here rather than in the dll, since it's only
    //  for the fileopen dlg.
    //
    //  Always start a thread if the number of active fileopen dialogs
    //  goes from 0 to 1
    //
    if ((lpCurDlg->dwCurDlgNum == 0) && (!hLNDThread))
    {
        if (hLNDEvent && (bNetworkInstalled = IsNetworkInstalled()))
        {
            TCHAR szModule[MAX_PATH];

            //
            //  Do this once when dialog thread count goes from 0 to 1.
            //
            GetModuleFileName(g_hinst, szModule, ARRAYSIZE(szModule));
            if (LoadLibrary(szModule))
            {
                hLNDThread = CreateThread(
                                   NULL,
                                   (DWORD)0,
                                   (LPTHREAD_START_ROUTINE)ListNetDrivesHandler,
                                   (LPVOID)NULL,
                                   (DWORD_PTR)NULL,
                                   &dwThreadID );
            }
        }
        else
        {
            HWND hNet = GetDlgItem(hDlg, psh14);

            EnableWindow(hNet, FALSE);
            ShowWindow(hNet, SW_HIDE);
        }
    }

    LNDSetEvent(hDlg);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDiskIndex
//
////////////////////////////////////////////////////////////////////////////

DWORD GetDiskIndex(
    DWORD dwDriveType)
{
    if (dwDriveType == 1)
    {
        //
        //  Drive doesn't exist!
        //
        return (0);
    }
    else if (dwDriveType == DRIVE_CDROM)
    {
        return (CDDRVBMP);
    }
    else if (dwDriveType == DRIVE_REMOVABLE)
    {
        return (FLOPPYBMP);
    }
    else if (dwDriveType == DRIVE_REMOTE)
    {
        return (NETDRVBMP);
    }
    else if (dwDriveType == DRIVE_RAMDISK)
    {
        return (RAMDRVBMP);
    }

    return (HARDDRVBMP);
}


////////////////////////////////////////////////////////////////////////////
//
//  CleanUpFile
//
//  This releases the memory used by the system dialog bitmaps.
//
////////////////////////////////////////////////////////////////////////////

VOID CleanUpFile()
{
    //
    //  Check if anyone else is around.
    //
    if (--cLock)
    {
        return;
    }

    //
    //  Select the null bitmap into our memory DC so that the
    //  DirDrive bitmap can be discarded.
    //
    SelectObject(hdcMemory, hbmpOrigMemBmp);
}


////////////////////////////////////////////////////////////////////////////
//
//  FileOpenAbort
//
////////////////////////////////////////////////////////////////////////////

VOID FileOpenAbort()
{
    LPCURDLG lpCurDlg;


    lpCurDlg = (LPCURDLG)TlsGetValue(g_tlsiCurDlg);

    if (lpCurDlg)
    {
        EnterCriticalSection(&g_csLocal);

        if (dwNumDlgs > 0)
        {
            dwNumDlgs--;
        }

        if (dwNumDlgs == 0)
        {
            //
            //  If there are no more fileopen dialogs for this process,
            //  then signal the worker thread it's all over.
            //
            if (hLNDEvent && hLNDThread)
            {
                bLNDExit = TRUE;
                SetEvent(hLNDEvent);

                CloseHandle(hLNDThread);
                hLNDThread = NULL;
            }
        }

        LeaveCriticalSection(&g_csLocal);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  TermFile
//
////////////////////////////////////////////////////////////////////////////

VOID TermFile()
{
    vDeleteDirDriveBitmap();
    if (hdcMemory)
    {
        DeleteDC(hdcMemory);
    }

    if (hLNDEvent)
    {
        CloseHandle(hLNDEvent);
        hLNDEvent = NULL;
    }

    if (gpcNetEnumBuf)
    {
        LocalFree(gpcNetEnumBuf);
    }

    while (dwNumDisks)
    {
        dwNumDisks--;
        if (gaDiskInfo[dwNumDisks].lpAbbrName)
        {
            LocalFree(gaDiskInfo[dwNumDisks].lpAbbrName);
        }
    }
}






/*========================================================================*/
/*                 Ansi->Unicode Thunk routines                           */
/*========================================================================*/

#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  ThunkOpenFileNameA2WDelayed
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkOpenFileNameA2WDelayed(
    POPENFILEINFO pOFI)
{
    LPOPENFILENAMEA pOFNA = pOFI->pOFNA;
    LPOPENFILENAMEW pOFNW = pOFI->pOFN;

    if (pOFNA->lpstrDefExt)
    {
        //
        //  Make sure the default extension buffer is at least 4 characters
        //  in length.
        //
        DWORD cbLen = max(lstrlenA(pOFNA->lpstrDefExt) + 1, 4);

        if (pOFNW->lpstrDefExt)
        {
            LocalFree((HLOCAL)pOFNW->lpstrDefExt);
        }
        if (!(pOFNW->lpstrDefExt = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            return;
        }
        else
        {
            if (pOFNA->lpstrDefExt)
            {
                MultiByteToWideChar( CP_ACP,
                                     0,
                                     pOFNA->lpstrDefExt,
                                     -1,
                                     (LPWSTR)pOFNW->lpstrDefExt,
                                     cbLen );
            }
        }
    }

    //
    //  Need to thunk back to A value since Claris Filemaker side effects
    //  this in an ID_OK subclass without hooking at the very last moment.
    //  Do an |= instead of an = to preserve internal flags.
    //
    pOFNW->Flags &= OFN_ALL_INTERNAL_FLAGS;
    pOFNW->Flags |= pOFNA->Flags;
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkOpenFileNameA2W
//
////////////////////////////////////////////////////////////////////////////

BOOL ThunkOpenFileNameA2W(
    POPENFILEINFO pOFI)
{
    int    nRet;


    LPOPENFILENAMEA pOFNA = pOFI->pOFNA;
    LPOPENFILENAMEW pOFNW = pOFI->pOFN;

    pOFNW->Flags = pOFNA->Flags;
    pOFNW->lCustData = pOFNA->lCustData;

    //  we actually can have the original ver1 structure passed in here
    //  so we need to check and make sure to only copy over the valid data
    if (pOFNA->lStructSize == SIZEOF(OPENFILENAMEA) && pOFNW->lStructSize == SIZEOF(OPENFILENAMEW))
    {
        pOFNW->rgpMonikers = pOFNA->rgpMonikers;
        pOFNW->cMonikers = pOFNA->cMonikers;
    }

    //
    //  Various WOW apps change the strings and *ptrs* to the strings in the
    //  OPENFILENAME struct while processing messages with their hook procs.
    //  Handle that silliness here.  (We probably don't want to promote this
    //  beyond WOW).
    //
    if (pOFNA->Flags & CD_WOWAPP)
    {
        pOFNW->lpstrFilter = (LPCWSTR)
                       ThunkMultiANSIStrToWIDE( (LPWSTR)pOFNW->lpstrFilter,
                                                (LPSTR)pOFNA->lpstrFilter,
                                                0 );

        pOFNW->lpstrCustomFilter =
                       ThunkMultiANSIStrToWIDE( pOFNW->lpstrCustomFilter,
                                                pOFNA->lpstrCustomFilter,
                                                pOFNA->nMaxCustFilter );

        pOFNW->lpstrFile =
                       ThunkANSIStrToWIDE( pOFNW->lpstrFile,
                                           pOFNA->lpstrFile,
                                           pOFNA->nMaxFile );

        pOFNW->lpstrFileTitle =
                       ThunkANSIStrToWIDE( pOFNW->lpstrFileTitle,
                                           pOFNA->lpstrFileTitle,
                                           pOFNA->nMaxFileTitle );

        pOFNW->lpstrInitialDir = (LPCWSTR)
                       ThunkANSIStrToWIDE( (LPWSTR)pOFNW->lpstrInitialDir,
                                           (LPSTR)pOFNA->lpstrInitialDir,
                                           0 );

        pOFNW->lpstrTitle = (LPCWSTR)
                       ThunkANSIStrToWIDE( (LPWSTR)pOFNW->lpstrTitle,
                                           (LPSTR)pOFNA->lpstrTitle,
                                           0 );

        pOFNW->lpstrDefExt = (LPCWSTR)
                       ThunkANSIStrToWIDE( (LPWSTR)pOFNW->lpstrDefExt,
                                           (LPSTR)pOFNA->lpstrDefExt,
                                           0 );

        pOFNW->nMaxCustFilter = pOFNA->nMaxCustFilter;
        pOFNW->nMaxFile       = pOFNA->nMaxFile;
        pOFNW->nMaxFileTitle  = pOFNA->nMaxFileTitle;
        pOFNW->nFileOffset    = pOFNA->nFileOffset;
        pOFNW->nFileExtension = pOFNA->nFileExtension;
    }
    else
    {
        if (pOFNW->lpstrFile)
        {
            if (pOFNA->lpstrFile)
            {
                nRet = MultiByteToWideChar( CP_ACP,
                                            0,
                                            pOFNA->lpstrFile,
                                            -1,
                                            pOFNW->lpstrFile,
                                            pOFNW->nMaxFile );
                if (nRet == 0)
                {
                    return (FALSE);
                }
            }
        }

        if (pOFNW->lpstrFileTitle && pOFNW->nMaxFileTitle)
        {
            if (pOFNA->lpstrFileTitle)
            {
                nRet = MultiByteToWideChar( CP_ACP,
                                            0,
                                            pOFNA->lpstrFileTitle,
                                            pOFNA->nMaxFileTitle,
                                            pOFNW->lpstrFileTitle,
                                            pOFNW->nMaxFileTitle );
                if (nRet == 0)
                {
                    return (FALSE);
                }
            }
        }

        if (pOFNW->lpstrCustomFilter)
        {
            if (pOFI->pasCustomFilter)
            {
                LPSTR psz = pOFI->pasCustomFilter->Buffer;
                DWORD cch = 0;

                if (*psz || *(psz + 1))
                {
                    cch = 2;
                    while (*psz || *(psz + 1))
                    {
                        psz++;
                        cch++;
                    }
                }

                if (cch)
                {
                    pOFI->pasCustomFilter->Length = cch;

                    nRet = MultiByteToWideChar( CP_ACP,
                                                0,
                                                pOFI->pasCustomFilter->Buffer,
                                                pOFI->pasCustomFilter->Length,
                                                pOFI->pusCustomFilter->Buffer,
                                                pOFI->pusCustomFilter->MaximumLength );
                    if (nRet == 0)
                    {
                        return (FALSE);
                    }
                }
            }
        }
    }

    pOFNW->nFilterIndex = pOFNA->nFilterIndex;

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkOpenFileNameW2A
//
////////////////////////////////////////////////////////////////////////////

BOOL ThunkOpenFileNameW2A(
    POPENFILEINFO pOFI)
{
    int nRet;

    LPOPENFILENAMEW pOFNW = pOFI->pOFN;
    LPOPENFILENAMEA pOFNA = pOFI->pOFNA;
    LPWSTR pszW;
    USHORT cch;

    //
    //  Supposedly invariant, but not necessarily.
    //    Definition: invariant - changed by 16-bit apps frequently
    //
    pOFNA->Flags = pOFNW->Flags;
    pOFNA->lCustData = pOFNW->lCustData;
    
    // this way we can assert that we have covered ourselves.
    DEBUG_CODE(pOFNA->nFileOffset = 0 );

    //  we actually can have the original ver1 structure passed in here
    //  so we need to check and make sure to only copy over the valid data
    if (pOFNA->lStructSize == SIZEOF(OPENFILENAMEA) && pOFNW->lStructSize == SIZEOF(OPENFILENAMEW))
    {
        pOFNA->rgpMonikers = pOFNW->rgpMonikers;
        pOFNA->cMonikers = pOFNW->cMonikers;
    }


    if (pOFNA->lpstrFileTitle && pOFNA->nMaxFileTitle)
    {
        nRet = WideCharToMultiByte( CP_ACP,
                                    0,
                                    pOFNW->lpstrFileTitle,
                                    -1,
                                    pOFNA->lpstrFileTitle,
                                    pOFNA->nMaxFileTitle,
                                    NULL,
                                    NULL );
        if (nRet == 0)
        {
            return (FALSE);
        }
    }

    if (pOFNA->lpstrCustomFilter)
    {
        pszW = pOFI->pusCustomFilter->Buffer;

        cch = 0;
        if (*pszW || *(pszW + 1))
        {
            cch = 2;
            while (*pszW || *(pszW + 1))
            {
                pszW++;
                cch++;
            }
        }

        if (cch)
        {
            pOFI->pusCustomFilter->Length = cch;
            nRet = WideCharToMultiByte( CP_ACP,
                                        0,
                                        pOFI->pusCustomFilter->Buffer,
                                        pOFI->pusCustomFilter->Length,
                                        pOFI->pasCustomFilter->Buffer,
                                        pOFI->pasCustomFilter->MaximumLength,
                                        NULL,
                                        NULL );
            if (nRet == 0)
            {
                return (FALSE);
            }
        }
    }

    pOFNA->nFilterIndex   = pOFNW->nFilterIndex;

    if (pOFNA->lpstrFile)
    {
        if (GetStoredExtendedError() == FNERR_BUFFERTOOSMALL)
        {
            //
            //  In the case where the lpstrFile buffer is too small,
            //  lpstrFile contains the size of the buffer needed for
            //  the string rather than the string itself.
            //
            pszW = pOFNW->lpstrFile;
            switch (pOFNA->nMaxFile)
            {
                case ( 3 ) :
                default :
                {
                    pOFNA->lpstrFile[2] = CHAR_NULL;

                    // fall thru...
                }
                case ( 2 ) :
                {
                    pOFNA->lpstrFile[1] = HIBYTE(*pszW);

                    // fall thru...
                }
                case ( 1 ) :
                {
                    pOFNA->lpstrFile[0] = LOBYTE(*pszW);

                    // fall thru...
                }
                case ( 0 ) :
                {
                    break;
                }
            }
        }
        else
        {
            LPWSTR pFileW = pOFNW->lpstrFile;
            DWORD cchFile = 0;

            // Find the length of string to be converted. This takes care of both single select (there will be only string)
            // and multiselect case (there will multiple strings with double null termination)
            while (*pFileW)
            {
                DWORD cch = lstrlenW(pFileW) +1;
                cchFile +=cch;
                pFileW += cch;
            }

            if (pOFNW->Flags & OFN_ALLOWMULTISELECT)
            {
                // for the double null terminator
                cchFile++;
            }
              
            // need to copy the whole buffer after the initial directory
            nRet =WideCharToMultiByte(CP_ACP, 0,
                    pOFNW->lpstrFile, cchFile,
                    pOFNA->lpstrFile, pOFNA->nMaxFile,
                    NULL, NULL);

            if (nRet == 0)
            {
                return (FALSE);
            }

            if ((SHORT)pOFNW->nFileOffset > 0)
            {
                pOFNA->nFileOffset = (WORD) WideCharToMultiByte( CP_ACP,
                                                                 0,
                                                                 pOFNW->lpstrFile,
                                                                 pOFNW->nFileOffset,
                                                                 NULL,
                                                                 0,
                                                                 NULL,
                                                                 NULL );
            }
            else
            {
                pOFNA->nFileOffset = pOFNW->nFileOffset;
            }

            if ((SHORT)pOFNW->nFileExtension > 0)
            {
                pOFNA->nFileExtension = (WORD) WideCharToMultiByte( CP_ACP,
                                                                    0,
                                                                    pOFNW->lpstrFile,
                                                                    pOFNW->nFileExtension,
                                                                    NULL,
                                                                    0,
                                                                    NULL,
                                                                    NULL );
            }
            else
            {
                pOFNA->nFileExtension = pOFNW->nFileExtension;    
            }
        }
    }
    else
    {
        pOFNA->nFileOffset    = pOFNW->nFileOffset;
        pOFNA->nFileExtension = pOFNW->nFileExtension;

    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GenericGetFileNameA
//
////////////////////////////////////////////////////////////////////////////

BOOL GenericGetFileNameA(
    LPOPENFILENAMEA pOFNA,
    DLGPROC qfnDlgProc)
{
    LPOPENFILENAMEW pOFNW;
    BOOL bRet = FALSE;
    OFN_UNICODE_STRING usCustomFilter;
    OFN_ANSI_STRING asCustomFilter;
    DWORD cbLen;
    LPSTR pszA;
    DWORD cch;
    LPBYTE pStrMem = NULL;
    OPENFILEINFO OFI = {0};
	
    if (!pOFNA)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    //  we allow both sizes because we allocate a full size one anyway
    //  and we want to preserve the original structure for notifies
    if ((pOFNA->lStructSize != OPENFILENAME_LSTRUCTSIZE_NT4) &&
        (pOFNA->lStructSize != sizeof(OPENFILENAMEA))
       )
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if (!(pOFNW = (LPOPENFILENAMEW)LocalAlloc(LPTR, sizeof(OPENFILENAMEW))))
    {
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
        return (FALSE);
    }

    //
    //  Constant stuff.
    //
    pOFNW->lStructSize = sizeof(OPENFILENAMEW);
    pOFNW->hwndOwner = pOFNA->hwndOwner;
    pOFNW->hInstance = pOFNA->hInstance;
    pOFNW->lpfnHook = pOFNA->lpfnHook;

    //  it will always be a valid structsize at this point
    if (pOFNA->lStructSize != OPENFILENAME_LSTRUCTSIZE_NT4)
    {
        pOFNW->rgpMonikers = pOFNA->rgpMonikers;
        pOFNW->cMonikers = pOFNA->cMonikers;
    }

    //
    //  Init TemplateName constant.
    //
    if (pOFNA->Flags & OFN_ENABLETEMPLATE)
    {
        if (!IS_INTRESOURCE(pOFNA->lpTemplateName))
        {
            cbLen = lstrlenA(pOFNA->lpTemplateName) + 1;
            if (!(pOFNW->lpTemplateName = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
            {
                StoreExtendedError(CDERR_MEMALLOCFAILURE);
                goto GenericExit;
            }
            else
            {
                MultiByteToWideChar( CP_ACP,
                                     0,
                                     pOFNA->lpTemplateName,
                                     -1,
                                     (LPWSTR)pOFNW->lpTemplateName,
                                     cbLen );
            }
        }
        else
        {
            (DWORD_PTR)pOFNW->lpTemplateName = (DWORD_PTR)pOFNA->lpTemplateName;
        }
    }
    else
    {
        pOFNW->lpTemplateName = NULL;
    }

    //
    //  Initialize Initial Dir constant.
    //
    if (pOFNA->lpstrInitialDir)
    {
        cbLen = lstrlenA(pOFNA->lpstrInitialDir) + 1;
        if (!(pOFNW->lpstrInitialDir = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
        else
        {
            MultiByteToWideChar( CP_ACP,
                                 0,
                                 pOFNA->lpstrInitialDir,
                                 -1,
                                 (LPWSTR)pOFNW->lpstrInitialDir,
                                 cbLen );
        }
    }
    else
    {
        pOFNW->lpstrInitialDir = NULL;
    }

    //
    //  Initialize Title constant.
    //
    if (pOFNA->lpstrTitle)
    {
        cbLen = lstrlenA(pOFNA->lpstrTitle) + 1;
        if (!(pOFNW->lpstrTitle = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
        else
        {
            MultiByteToWideChar( CP_ACP,
                                 0,
                                 pOFNA->lpstrTitle,
                                 -1,
                                 (LPWSTR)pOFNW->lpstrTitle,
                                 cbLen );
        }
    }
    else
    {
        pOFNW->lpstrTitle = NULL;
    }

    //
    //  Initialize Def Ext constant.
    //
    if (pOFNA->lpstrDefExt)
    {
        //
        //  Make sure the default extension buffer is at least 4 characters
        //  in length.
        //
        cbLen = max(lstrlenA(pOFNA->lpstrDefExt) + 1, 4);
        if (!(pOFNW->lpstrDefExt = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
        else
        {
            MultiByteToWideChar( CP_ACP,
                                 0,
                                 pOFNA->lpstrDefExt,
                                 -1,
                                 (LPWSTR)pOFNW->lpstrDefExt,
                                 cbLen );
        }
    }
    else
    {
        pOFNW->lpstrDefExt = NULL;
    }

    //
    //  Initialize Filter constant.  Note: 16-bit apps change this.
    //
    if (pOFNA->lpstrFilter)
    {
        pszA = (LPSTR)pOFNA->lpstrFilter;

        cch = 0;
        if (*pszA || *(pszA + 1))
        {
            //
            //  Pick up trailing nulls.
            //
            cch = 2;
            try
            {
                while (*pszA || *(pszA + 1))
                {
                    pszA++;
                    cch++;
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto GenericExit;
            }
        }

        //
        //  Need to do cch + 1 in the Local Alloc rather than just cch.
        //  This is to make sure there is at least one extra null in the
        //  string so that if a filter does not have the second part of
        //  the pair, three nulls will be placed in the wide string.
        //
        //  Example:  "Print File (*.prn)\0\0\0"
        //
        if (!(pOFNW->lpstrFilter = (LPWSTR)LocalAlloc(LPTR, ((cch + 1) * sizeof(WCHAR)))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
        else
        {
            MultiByteToWideChar( CP_ACP,
                                 0,
                                 pOFNA->lpstrFilter,
                                 cch,
                                 (LPWSTR)pOFNW->lpstrFilter,
                                 cch );
        }
    }
    else
    {
        pOFNW->lpstrFilter = NULL;
    }

    //
    //  Initialize File strings.
    //
    if (pOFNA->lpstrFile)
    {
        if (pOFNA->nMaxFile <= (DWORD)lstrlenA(pOFNA->lpstrFile))
        {
            StoreExtendedError(CDERR_INITIALIZATION);
            goto GenericExit;
        }
        pOFNW->nMaxFile = pOFNA->nMaxFile;

        if (!(pOFNW->lpstrFile = (LPWSTR)LocalAlloc(LPTR, pOFNW->nMaxFile * sizeof(WCHAR))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
    }
    else
    {
        //
        //  Conversion done in thunkofna2w.
        //
        pOFNW->nMaxFile = 0;
        pOFNW->lpstrFile = NULL;
    }

    //
    //  Initialize File Title strings.
    //
    if (pOFNA->lpstrFileTitle && pOFNA->nMaxFileTitle)
    {
        //
        //  Calculate length of lpstrFileTitle.
        //
        pszA = pOFNA->lpstrFileTitle;
        cch = 0;
        try
        {
            while (*pszA++)
            {
                cch++;
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            if (cch)
            {
                cch--;
            }
            (pOFNA->lpstrFileTitle)[cch] = CHAR_NULL;
        }

        if (pOFNA->nMaxFileTitle < cch)
        {
            //
            //  Override the incorrect length from the app.
            //  Make room for the null.
            //
            pOFNW->nMaxFileTitle = cch + 1;
        }
        else
        {
            pOFNW->nMaxFileTitle = pOFNA->nMaxFileTitle;
        }

        if (!(pOFNW->lpstrFileTitle = (LPWSTR)LocalAlloc(LPTR, pOFNW->nMaxFileTitle * sizeof(WCHAR))))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
    }
    else
    {
        //
        //  Conversion done in thunkofna2w.
        //
        pOFNW->nMaxFileTitle = 0;
        pOFNW->lpstrFileTitle = NULL;
    }

    //
    //  Initialize custom filter strings.
    //
    if ((asCustomFilter.Buffer = pOFNA->lpstrCustomFilter))
    {
        pszA = pOFNA->lpstrCustomFilter;

        cch = 0;
        if (*pszA || *(pszA + 1))
        {
            cch = 2;
            try
            {
                while (*pszA || *(pszA + 1))
                {
                    pszA++;
                    cch++;
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto GenericExit;
            }
        }

        //
        //  JVert-inspired-wow-compatibility-hack-to-make-vbasic2.0-makeexe
        //  save-as-dialog-box-work-even-though-they-didn't-fill-in-
        //  the-whole-structure(nMaxCustFilter)-according-to-winhelp-spec fix
        //
        if (!(pOFNA->Flags & OFN_NOLONGNAMES))
        {
            if (((DWORD)cch >= pOFNA->nMaxCustFilter) ||
                (pOFNA->nMaxCustFilter < 40))
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto GenericExit;
            }
            asCustomFilter.Length = cch;
            asCustomFilter.MaximumLength = pOFNA->nMaxCustFilter;
            pOFNW->nMaxCustFilter = pOFNA->nMaxCustFilter;
        }
        else
        {
            asCustomFilter.Length = cch;
            if (pOFNA->nMaxCustFilter < cch)
            {
                asCustomFilter.MaximumLength = cch;
                pOFNW->nMaxCustFilter = cch;
            }
            else
            {
                asCustomFilter.MaximumLength = pOFNA->nMaxCustFilter;
                pOFNW->nMaxCustFilter = pOFNA->nMaxCustFilter;
            }
        }
        usCustomFilter.MaximumLength = (asCustomFilter.MaximumLength + 1) * sizeof(WCHAR);
        usCustomFilter.Length = asCustomFilter.Length * sizeof(WCHAR);
    }
    else
    {
        pOFNW->nMaxCustFilter = usCustomFilter.MaximumLength = 0;
        pOFNW->lpstrCustomFilter = NULL;
    }

    if (usCustomFilter.MaximumLength > 0)
    {
        if (!(pStrMem = (LPBYTE)LocalAlloc(LPTR, usCustomFilter.MaximumLength)))
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            goto GenericExit;
        }
        else
        {
            pOFNW->lpstrCustomFilter = usCustomFilter.Buffer = (LPWSTR)pStrMem;
        }
    }
    else
    {
        pStrMem = NULL;
    }

    OFI.pOFN = pOFNW;
    OFI.pOFNA = pOFNA;
    OFI.pasCustomFilter = &asCustomFilter;
    OFI.pusCustomFilter = &usCustomFilter;
    OFI.ApiType = COMDLG_ANSI;

    //
    //  The following should always succeed.
    //
    if (!ThunkOpenFileNameA2W(&OFI))
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        goto GenericExit;
    }

    bRet = GetFileName(&OFI, qfnDlgProc);
    if (bUserPressedCancel == FALSE)
    {
        ThunkOpenFileNameW2A(&OFI);
    }

GenericExit:

    if (pStrMem)
    {
        LocalFree(pStrMem);
    }

    if (!IS_INTRESOURCE(pOFNW->lpstrFile))
    {
        LocalFree((HLOCAL)pOFNW->lpstrFile);
    }

    if (!IS_INTRESOURCE(pOFNW->lpstrFileTitle))
    {
        LocalFree((HLOCAL)pOFNW->lpstrFileTitle);
    }

    if (!IS_INTRESOURCE(pOFNW->lpstrFilter))
    {
        LocalFree((HLOCAL)pOFNW->lpstrFilter);
    }

    if (!IS_INTRESOURCE(pOFNW->lpstrDefExt))
    {
        LocalFree((HLOCAL)pOFNW->lpstrDefExt);
    }

    if (!IS_INTRESOURCE(pOFNW->lpstrTitle))
    {
        LocalFree((HLOCAL)pOFNW->lpstrTitle);
    }

    if (!IS_INTRESOURCE(pOFNW->lpstrInitialDir))
    {
        LocalFree((HLOCAL)pOFNW->lpstrInitialDir);
    }

    if (!IS_INTRESOURCE(pOFNW->lpTemplateName))
    {
        LocalFree((HLOCAL)pOFNW->lpTemplateName);
    }

    LocalFree(pOFNW);

    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  Multi_strlenA
//
//  This is a strlen for ANSI string lists that have several strings that
//  are *separated* by a NULL char and are *terminated* by two NULL chars.
//
//  Returns length of string including all NULL *separators* but not the
//  2nd NULL *terminator*.  (ie. cat0dog00 would return length = 8)
//
////////////////////////////////////////////////////////////////////////////

int Multi_strlenA(
    LPCSTR str)
{
    int ctr = 0;

    if (str)
    {
        while (*str)
        {
            while (*str++)
            {
                ctr++;
            }
            ctr++;                // count the NULL separator
        }
    }

    return (ctr);
}


////////////////////////////////////////////////////////////////////////////
//
//  Multi_strcpyAtoW
//
//  This is a strcpy for string lists that have several strings that are
//  *separated* by a NULL char and are *terminated* by two NULL chars.
//  Returns FALSE if:
//    1. the wide buffer is determined to be too small
//    2. the ptr to either buffer is NULL
//  Returns TRUE if the copy was successful.
//
////////////////////////////////////////////////////////////////////////////

BOOL Multi_strcpyAtoW(
    LPWSTR pDestW,
    LPCSTR pSrcA,
    int cChars)
{
    int off = 0;
    int cb;

    if (!pSrcA || !pDestW)
    {
        return (FALSE);
    }

    cChars = max(cChars, (Multi_strlenA(pSrcA) + 1));

    if (LocalSize((HLOCAL)pDestW) < (cChars * sizeof(WCHAR)))
    {
        return (FALSE);
    }

    while (*pSrcA)
    {
        cb = lstrlenA(pSrcA) + 1;

        off += MultiByteToWideChar(CP_ACP, 0, pSrcA, cb, pDestW + off, cb);
        pSrcA += cb;
    }

    pDestW[off] = L'\0';

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkMultiANSIStrToWIDE
//
//  Thunks an ANSI multi-string (a list of NULL *separated* strings with
//  two NULLs *terminating* the list) to the equivalent WIDE multi-string.
//
//  Note: If the original wide buffer is too small to contain the new list,
//        it will be free'd and a new wide buffer will be allocated.  If a
//        new wide buffer can't be allocated, the ptr to the original wide
//        buffer is returned with no changes to the contents.
//
//  Returns: ptr to the original WIDE buffer
//           OR ptr to a new wide buffer if original buffer was too small
//           OR NULL if pSrcA is NULL.
//
////////////////////////////////////////////////////////////////////////////

LPWSTR ThunkMultiANSIStrToWIDE(
    LPWSTR pDestW,
    LPSTR pSrcA,
    int cChars)
{
    int size;
    HLOCAL hBufW;

    if (!pSrcA)
    {
        //
        //  The app doesn't want a buffer for this anymore.
        //
        if (pDestW)
        {
            LocalFree((HLOCAL)pDestW);
        }
        return (NULL);
    }

    //
    //  First try to copy to the existing wide buffer since most of the time
    //  there will be no change to the buffer ptr anyway.
    //
    if (!(Multi_strcpyAtoW(pDestW, pSrcA, cChars)))
    {
        //
        //  If the wide buffer is too small (or NULL or invalid), allocate
        //  a bigger buffer.
        //
        size = max(cChars, (Multi_strlenA(pSrcA) + 1));
        cChars = size;

        if (hBufW = LocalAlloc(LPTR, (size * sizeof(WCHAR))))
        {
            //
            //  Try to copy to the new wide buffer.
            //
            if ((Multi_strcpyAtoW((LPWSTR)hBufW, pSrcA, cChars)))
            {
                if (pDestW)
                {
                    LocalFree((HLOCAL)pDestW);
                }
                pDestW = (LPWSTR)hBufW;
            }
            else
            {
                //
                //  Don't change anything.
                //
                LocalFree(hBufW);
            }
        }
    }

    return (pDestW);
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkANSIStrToWIDE
//
//  Thunks an ANSI string to WIDE.
//
//  Note: If the original wide buffer is too small to contain the new
//        string, it will be free'd and a new wide buffer will be allocated.
//        If a new wide buffer can't be allocated, the ptr to the original
//        wide buffer is returned with no changes to the contents.
//
//  Returns: ptr to the original WIDE buffer
//           OR ptr to a new wide buffer if original buffer was too small
//           OR NULL if pSrcA is NULL.
//
////////////////////////////////////////////////////////////////////////////

LPWSTR ThunkANSIStrToWIDE(
    LPWSTR pDestW,
    LPSTR pSrcA,
    int cChars)
{
    HLOCAL hBufW;
    int size;

    if (!pSrcA)
    {
        //
        //  The app doesn't want a buffer for this anymore.
        //
        if (pDestW)
        {
            LocalFree((HLOCAL)pDestW);
        }
        return (NULL);
    }

    size = max(cChars, (lstrlenA(pSrcA) + 1));
    cChars = size;

    //
    //  If the wide buffer is too small (or NULL or invalid), allocate a
    //  bigger buffer.
    //
    if (LocalSize((HLOCAL)pDestW) < (size * sizeof(WCHAR)))
    {
        if (hBufW = LocalAlloc(LPTR, (size * sizeof(WCHAR))))
        {
            //
            //  Try to copy to the new wide buffer.
            //
            if (MultiByteToWideChar( CP_ACP,
                                     0,
                                     pSrcA,
                                     -1,
                                     (LPWSTR)hBufW,
                                     cChars ))
            {
                if (pDestW)
                {
                    LocalFree((HLOCAL)pDestW);
                }
                pDestW = (LPWSTR)hBufW;
            }
            else
            {
                //
                //  Don't change anything.
                //
                LocalFree(hBufW);
            }
        }
    }
    else
    {
        //
        //  Just use the original wide buffer.
        //
        MultiByteToWideChar(CP_ACP, 0, pSrcA, -1, pDestW, cChars);
    }

    return (pDestW);
}


#ifdef WINNT

////////////////////////////////////////////////////////////////////////////
//
//  Ssync_ANSI_UNICODE_OFN_For_WOW
//
//  Function to allow NT WOW to keep the ANSI & UNICODE versions of
//  the OPENFILENAME structure in ssync as required by many 16-bit apps.
//  See notes for Ssync_ANSI_UNICODE_Struct_For_WOW() in dlgs.c.
//
////////////////////////////////////////////////////////////////////////////

VOID Ssync_ANSI_UNICODE_OFN_For_WOW(
    HWND hDlg,
    BOOL f_ANSI_to_UNICODE)
{
    POPENFILEINFO pOFI;

    if (pOFI = (POPENFILEINFO)GetProp(hDlg, FILEPROP))
    {
        if (pOFI->pOFN && pOFI->pOFNA)
        {
            if (f_ANSI_to_UNICODE)
            {
                ThunkOpenFileNameA2W(pOFI);
            }
            else
            {
                ThunkOpenFileNameW2A(pOFI);
            }
        }
    }
}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\fileopen.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    fileopen.h

Abstract:

    This module contains the header information for the Win32 fileopen
    dialogs.

Revision History:

--*/



#ifdef __cplusplus
extern "C" {
#endif



//
//  Include Files.
//

#include <help.h>




//
//  Constant Declarations.
//

#define MAX_DISKNAME                   260
#define TOOLONGLIMIT                   MAX_PATH
#define MAX_FULLPATHNAME               520                 // 260 + 260
#define WARNINGMSGLENGTH               MAX_FULLPATHNAME

#define ERROR_NO_DISK_IN_CDROM         92L
#define ERROR_NO_DISK_IN_DRIVE         93L
#define ERROR_DIR_ACCESS_DENIED        94L
#define ERROR_FILE_ACCESS_DENIED       95L
#define ERROR_CREATE_NO_MODIFY         96L
#define ERROR_NO_DRIVE                 97L
#define ERROR_PORTNAME                 98L
#define ERROR_LAZY_READONLY            99L

//
//  Internal Flags.
//
//  Be sure to update OFN_ALL_INTERNAL_FLAGS if more internal flags are
//  added.
//
#define OFN_ALL_INTERNAL_FLAGS         0xf8000000     // Keep this in sync
#define OFN_PREFIXMATCH                0x80000000     // Internal
#define OFN_DIRSELCHANGED              0x40000000     // Internal
#define OFN_DRIVEDOWN                  0x20000000     // Internal
#define OFN_FILTERDOWN                 0x10000000     // Internal
// CD_WX86APP is                       0x08000000     // Internal

//
//  Used with OFN_COMBODOWN.
//
#define MYCBN_DRAW                     0x8000
#define MYCBN_LIST                     0x8001
#define MYCBN_REPAINT                  0x8002
#define MYCBN_CHANGEDIR                0x8003

#define OFN_OFFSETTAG                  0x0001

#define FILEPROP (LPCTSTR)             0xA000L

#define CHANGEDIR_FAILED               -1

#define ADDDISK_NOCHANGE               -1
#define ADDDISK_INVALIDPARMS           -2
#define ADDDISK_MAXNUMDISKS            -3
#define ADDDISK_NETFORMATFAILED        -4
#define ADDDISK_ALLOCFAILED            -5

#define ATTR_READONLY                  0x0000001      // GetFileAttributes flag

#define mskFile                        0x0000         // List files
#define mskDirectory                   0x0010         // List directories
#define mskUNCName                     0x0020         // Note UNC directory

#define mskDrives                      0xC000         // List drives ONLY

#define rgbSolidGreen                  0x0000FF00
#define rgbSolidBlue                   0x00FF0000

#define dxSpace                        4

#define cbCaption                      64

#define SUCCESS                        0x0
#define FAILURE                        0x1

#define DBL_BSLASH(sz) \
   (*(TCHAR *)(sz)       == CHAR_BSLASH) && \
   (*(TCHAR *)((sz) + 1) == CHAR_BSLASH)

#ifdef UNICODE
  #define ISBACKSLASH(szPath, nOffset) (szPath[nOffset] == CHAR_BSLASH)
  #define ISBACKSLASH_P(szPath, pPos)  (*pPos == CHAR_BSLASH)
#else
  #define ISBACKSLASH(szPath, nOffset) (IsBackSlash(szPath, szPath + nOffset))
  #define ISBACKSLASH_P(szPath, pPos)  (IsBackSlash(szPath, pPos))
#endif


//
//  Constant used in FILEOPENINFO to specify the version of
//  the structure passed by the application.
//
#define OPENFILENAME_LSTRUCTSIZE_NT4          0x004c
#define OPENFILEVERSION_NT4                   0x0004
#define OPENFILEVERSION_NT5                   0x0005
#define OPENFILEVERSION                       0x0005  //Current Version if NT5




//
//  Typedef Declarations.
//

typedef struct _OFN_ANSI_STRING {
    ULONG Length;
    ULONG MaximumLength;
    LPSTR Buffer;
} OFN_ANSI_STRING;

typedef OFN_ANSI_STRING *POFN_ANSI_STRING;

typedef struct _OFN_UNICODE_STRING {
    ULONG  Length;
    ULONG  MaximumLength;
    LPWSTR Buffer;
} OFN_UNICODE_STRING;

typedef OFN_UNICODE_STRING *POFN_UNICODE_STRING;

typedef struct {
    UINT                ApiType;
    LPOPENFILENAME      pOFN;
    TCHAR               szCurDir[MAX_FULLPATHNAME + 1];
    TCHAR               szPath[MAX_FULLPATHNAME];
    TCHAR               szSpecCur[MAX_FULLPATHNAME];
    TCHAR               szLastFilter[MAX_FULLPATHNAME + 1];
    DWORD               idirSub;
	//Version of structure.
    DWORD               iVersion;
#ifdef UNICODE
    LPOPENFILENAMEA     pOFNA;
    POFN_UNICODE_STRING pusCustomFilter;
    POFN_ANSI_STRING    pasCustomFilter;
    BOOL                bUseNewDialog;
#endif

} OPENFILEINFO;

typedef OPENFILEINFO * POPENFILEINFO;
typedef OPENFILEINFO * LPOPENFILEINFO;


//
//  This is for the hard coded id lists for My Documents and My Computer.
//
#pragma pack(1)
typedef struct _IDREGITEM
{
    WORD  cb;
    BYTE  bFlags;
    BYTE  bOrder;
    CLSID clsid;
} IDREGITEM, *LPIDREGITEM;
typedef const IDREGITEM *LPCIDREGITEM;

typedef struct _IDLREGITEM
{
    IDREGITEM idri;
    USHORT    cbNext;
} IDLREGITEM;
#pragma pack()

extern const IDLREGITEM c_idlMyDocs;
extern const IDLREGITEM c_idlDrives;




//
//  Function Prototypes.
//

BOOL
NewGetOpenFileName(
    LPOPENFILEINFO lpOFI);

BOOL
NewGetSaveFileName(
    LPOPENFILEINFO lpOFI);

LPCITEMIDLIST
GetAppOpenDir(
    LPTSTR lpszPath,
    LPTSTR lpszFilterCurrent);

void
SetAppOpenDir(void);

#ifdef UNICODE
  VOID
  ThunkOpenFileNameA2WDelayed(
      POPENFILEINFO pOFI);

  BOOL
  ThunkOpenFileNameA2W(
      POPENFILEINFO pOFI);

  BOOL
  ThunkOpenFileNameW2A(
      POPENFILEINFO pOFI);
#else
  VOID
  EliminateString(
      LPSTR lpStr,
      int nLen);

  BOOL
  IsBackSlash(
      LPSTR lpStart,
      LPSTR lpChar);
#endif


#ifdef __cplusplus
};  // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\find.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    find.c

Abstract:

    This module implements the Win32 find dialog.

Revision History:

--*/



//
//  Include Files.
//

#include "comdlg32.h"
#include "find.h"





#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  FindTextA
//
//  ANSI entry point for FindText when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

HWND WINAPI FindTextA(
    LPFINDREPLACEA pFRA)
{
    return (CreateFindReplaceDlg((LPFINDREPLACEW)pFRA, DLGT_FIND, COMDLG_ANSI));
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  FindTextW
//
//  Stub UNICODE function for FindText when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

HWND WINAPI FindTextW(
    LPFINDREPLACEW pFRW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#endif



////////////////////////////////////////////////////////////////////////////
//
//  FindText
//
//  The FindText function creates a system-defined modeless dialog box
//  that enables the user to find text within a document.
//
////////////////////////////////////////////////////////////////////////////

HWND WINAPI FindText(
    LPFINDREPLACE pFR)
{
    return ( CreateFindReplaceDlg(pFR, DLGT_FIND, COMDLG_WIDE) );
}


#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  ReplaceTextA
//
//  ANSI entry point for ReplaceText when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

HWND WINAPI ReplaceTextA(
    LPFINDREPLACEA pFRA)
{
    return (CreateFindReplaceDlg((LPFINDREPLACEW)pFRA, DLGT_REPLACE, COMDLG_ANSI));
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  ReplaceTextW
//
//  Stub UNICODE function for ReplaceText when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

HWND WINAPI ReplaceTextW(
    LPFINDREPLACEW pFRW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#endif


////////////////////////////////////////////////////////////////////////////
//
//  ReplaceText
//
//  The ReplaceText function creates a system-defined modeless dialog box
//  that enables the user to find and replace text within a document.
//
////////////////////////////////////////////////////////////////////////////

HWND WINAPI ReplaceText(
    LPFINDREPLACE pFR)
{
    return ( CreateFindReplaceDlg(pFR, DLGT_REPLACE, COMDLG_WIDE) );
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateFindReplaceDlg
//
//  Creates FindText modeless dialog.
//
//  pFR     - ptr to FINDREPLACE structure set up by user
//  DlgType - type of dialog to create (DLGT_FIND, DLGT_REPLACE)
//  ApiType - type of FINDREPLACE ptr (COMDLG_ANSI or COMDLG_WIDE)
//
//  Returns   success => HANDLE to created dlg
//            failure => HNULL = ((HANDLE) 0)
//
////////////////////////////////////////////////////////////////////////////

HWND CreateFindReplaceDlg(
    LPFINDREPLACE pFR,
    UINT DlgType,
    UINT ApiType)
{
    HWND hWndDlg;                      // handle to created modeless dialog
    HANDLE hDlgTemplate;               // handle to loaded dialog resource
    LPCDLGTEMPLATE lpDlgTemplate;      // pointer to loaded resource block
#ifdef UNICODE
    UINT uiWOWFlag = 0;
#endif

    if (!pFR)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (!SetupOK(pFR, DlgType, ApiType))
    {
        return (HNULL);
    }

    if (!(hDlgTemplate = GetDlgTemplate(pFR, DlgType, ApiType)))
    {
        return (FALSE);
    }

    if (lpDlgTemplate = (LPCDLGTEMPLATE)LockResource(hDlgTemplate))
    {
        PFINDREPLACEINFO pFRI;

        if (pFRI = (PFINDREPLACEINFO)LocalAlloc(LPTR, sizeof(FINDREPLACEINFO)))
        {
            //
            //  CLEAR extended error on new instantiation.
            //
            StoreExtendedError(0);

            if (pFR->Flags & FR_ENABLEHOOK)
            {
                glpfnFindHook = GETHOOKFN(pFR);
            }

            pFRI->pFR = pFR;
            pFRI->ApiType = ApiType;
            pFRI->DlgType = DlgType;

#ifdef UNICODE
            if (IS16BITWOWAPP(pFR))
            {
                uiWOWFlag = SCDLG_16BIT;
            }

            hWndDlg = CreateDialogIndirectParamAorW( g_hinst,
                                                     lpDlgTemplate,
                                                     pFR->hwndOwner,
                                                     FindReplaceDlgProc,
                                                     (LPARAM)pFRI,
                                                     uiWOWFlag );
#else
            hWndDlg = CreateDialogIndirectParam( g_hinst,
                                                 lpDlgTemplate,
                                                 pFR->hwndOwner,
                                                 FindReplaceDlgProc,
                                                 (LPARAM)pFRI );
#endif
            if (!hWndDlg)
            {
                glpfnFindHook = 0;
                LocalFree(pFRI);
            }
        }
        else
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            return (NULL);
        }
    }
    else
    {
        StoreExtendedError(CDERR_LOCKRESFAILURE);
        return (HNULL);
    }

    return (hWndDlg);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetupOK
//
//  Checks setup for unmet preconditions.
//
//  pFR       ptr to FINDREPLACE structure
//  DlgType   dialog type (either FIND or REPLACE)
//  ApiType   findreplace type (either COMDLG_ANSI or COMDLG_UNICODE)
//
//  Returns   TRUE   - success
//            FALSE  - failure
//
////////////////////////////////////////////////////////////////////////////

BOOL SetupOK(
   LPFINDREPLACE pFR,
   UINT DlgType,
   UINT ApiType)
{
    //
    //  Sanity
    //
    if (!pFR)
    {
        return (FALSE);
    }

    if (pFR->lStructSize != sizeof(FINDREPLACE))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    //
    //  Verify window handle and text pointers.
    //
    if (!IsWindow(pFR->hwndOwner))
    {
        StoreExtendedError(CDERR_DIALOGFAILURE);
        return (FALSE);
    }

    if (!pFR->lpstrFindWhat ||
        ((DlgType == DLGT_REPLACE) && !pFR->lpstrReplaceWith) ||
        !pFR->wFindWhatLen)
    {
        StoreExtendedError(FRERR_BUFFERLENGTHZERO);
        return (FALSE);
    }

    //
    //  Verify lpfnHook has a ptr if ENABLED.
    //
    if (pFR->Flags & FR_ENABLEHOOK)
    {
        if (!pFR->lpfnHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pFR->lpfnHook = 0;
    }

    //
    //  Load "CLOSE" text for Replace.
    //
    if ((DlgType == DLGT_REPLACE) &&
        !LoadString(g_hinst, iszClose, (LPTSTR)szClose, CCHCLOSE))
    {
        StoreExtendedError(CDERR_LOADSTRFAILURE);
        return (FALSE);
    }


    //
    //  Setup unique msg# for talking to hwndOwner.
    //
#ifdef UNICODE
    if (ApiType == COMDLG_ANSI)
    {
        if (!(wFRMessage = RegisterWindowMessageA((LPCSTR)FINDMSGSTRINGA)))
        {
            StoreExtendedError(CDERR_REGISTERMSGFAIL);
            return (FALSE);
        }
    }
    else
#endif
    {
        if (!(wFRMessage = RegisterWindowMessage((LPCTSTR)FINDMSGSTRING)))
        {
            StoreExtendedError(CDERR_REGISTERMSGFAIL);
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDlgTemplate
//
//  Finds and loads the dialog template.
//
//  pFR       ptr to FINDREPLACE structure
//  ApiType   findreplace type (either COMDLG_ANSI or COMDLG_UNICODE)
//
//  Returns   handle to dialog template   - success
//            HNULL = ((HANDLE) 0)        - failure
//
////////////////////////////////////////////////////////////////////////////

HANDLE GetDlgTemplate(
    LPFINDREPLACE pFR,
    UINT DlgType,
    UINT ApiType)
{
    HANDLE hRes;                 // handle of res. block with dialog
    HANDLE hDlgTemplate;         // handle to loaded dialog resource

    if (pFR->Flags & FR_ENABLETEMPLATE)
    {
        //
        //  Find/Load TEMP NAME and INSTANCE from pFR.
        //
#ifdef UNICODE
        if (ApiType == COMDLG_ANSI)
        {
            hRes = FindResourceA( (HMODULE)pFR->hInstance,
                                  (LPCSTR)pFR->lpTemplateName,
                                  (LPCSTR)RT_DIALOG );
        }
        else
#endif
        {
            hRes = FindResource( pFR->hInstance,
                                 (LPCTSTR)pFR->lpTemplateName,
                                 (LPCTSTR)RT_DIALOG );
        }
        if (!hRes)
        {
            StoreExtendedError(CDERR_FINDRESFAILURE);
            return (HNULL);
        }
        if (!(hDlgTemplate = LoadResource(pFR->hInstance, hRes)))
        {
            StoreExtendedError(CDERR_LOADRESFAILURE);
            return (HNULL);
        }
    }
    else if (pFR->Flags & FR_ENABLETEMPLATEHANDLE)
    {
        //
        //  Get whole PRELOADED resource handle from user.
        //
        if (!(hDlgTemplate = pFR->hInstance))
        {
            StoreExtendedError(CDERR_NOHINSTANCE);
            return (HNULL);
        }
    }
    else
    {
        //
        //  Get STANDARD dialog from DLL instance block.
        //
        if (DlgType == DLGT_FIND)
        {
            hRes = FindResource( g_hinst,
                                 (LPCTSTR)MAKELONG(FINDDLGORD, 0),
                                 RT_DIALOG );
        }
        else
        {
            hRes = FindResource( g_hinst,
                                 (LPCTSTR)MAKELONG(REPLACEDLGORD, 0),
                                 RT_DIALOG );
        }

        //
        //  !!!!!  definitely ORD here?
        //
        if (!hRes)
        {
            StoreExtendedError(CDERR_FINDRESFAILURE);
            return (HNULL);
        }
        if (!(hDlgTemplate = LoadResource(g_hinst, hRes)))
        {
            StoreExtendedError(CDERR_LOADRESFAILURE);
            return (HNULL);
        }
    }

    return (hDlgTemplate);
}


////////////////////////////////////////////////////////////////////////////
//
//  FindReplaceDlgProc
//
//  Handles messages to FindText/ReplaceText dialogs.
//
//  hDlg   -  handle to dialog
//  wMsg   -  window message
//  wParam -  w parameter of message
//  lParam -  l parameter of message
//
//  Note: lparam contains ptr to FINDREPLACEINITPROC upon
//        initialization from CreateDialogIndirectParam...
//
//  Returns:   TRUE (or dlg fcn return vals) - success
//             FALSE                         - failure
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK FindReplaceDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PFINDREPLACEINFO pFRI;
    LPFINDREPLACE pFR;
    BOOL bRet;

    //
    //  If a hook exists, let hook function do procing.
    //
    if (pFRI = (PFINDREPLACEINFO)GetProp(hDlg, FINDREPLACEPROP))
    {
        if ((pFR = (LPFINDREPLACE)pFRI->pFR) &&
            (pFR->Flags & FR_ENABLEHOOK))
        {
            LPFRHOOKPROC lpfnHook = GETHOOKFN(pFR);

            if ((bRet = (*lpfnHook)(hDlg, wMsg, wParam, lParam)))
            {
                return (bRet);
            }
        }
    }
    else if (glpfnFindHook &&
             (wMsg != WM_INITDIALOG) &&
             (bRet = (* glpfnFindHook)(hDlg, wMsg, wParam, lParam)))
    {
        return (bRet);
    }

    //
    //  Dispatch MSG to appropriate HANDLER.
    //
    switch (wMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            //
            //  Set Up P-Slot.
            //
            pFRI = (PFINDREPLACEINFO)lParam;
            SetProp(hDlg, FINDREPLACEPROP, (HANDLE)pFRI);

            glpfnFindHook = 0;

            //
            //  Init dlg controls accordingly.
            //
            pFR = pFRI->pFR;
            InitControlsWithFlags(hDlg, pFR, pFRI->DlgType, pFRI->ApiType);

            //
            //  If Hook function, do extra processing.
            //
            if (pFR->Flags & FR_ENABLEHOOK)
            {
                LPFRHOOKPROC lpfnHook = GETHOOKFN(pFR);

                bRet = (*lpfnHook)(hDlg, wMsg, wParam, (LPARAM)pFR);
            }
            else
            {
                bRet = TRUE;
            }

            if (bRet)
            {
                //
                //  If the hook function returns FALSE, then we must call
                //  these functions here.
                //
                ShowWindow(hDlg, SW_SHOWNORMAL);
                UpdateWindow(hDlg);
            }

            return (bRet);
            break;
        }
        case ( WM_COMMAND ) :
        {
            if (!pFRI || !pFR)
            {
                return (FALSE);
            }

            switch (GET_WM_COMMAND_ID (wParam, lParam))
            {
                //
                //  FIND NEXT button clicked.
                //
                case ( IDOK ) :
                {
                    UpdateTextAndFlags( hDlg,
                                        pFR,
                                        FR_FINDNEXT,
                                        pFRI->DlgType,
                                        pFRI->ApiType );
                    NotifyUpdateTextAndFlags(pFR);
                    break;
                }
                case ( IDCANCEL ) :
                case ( IDABORT ) :
                {
                    EndDlgSession(hDlg, pFR);
                    LocalFree(pFRI);
                    break;
                }
                case ( psh1 ) :
                case ( psh2 ) :
                {
                    UpdateTextAndFlags( hDlg,
                                        pFR,
                                        (wParam == psh1)
                                            ? FR_REPLACE
                                            : FR_REPLACEALL,
                                        pFRI->DlgType,
                                        pFRI->ApiType );
                    if (NotifyUpdateTextAndFlags(pFR) == TRUE)
                    {
                        //
                        //  Change <Cancel> button to <Close> if function
                        //  returns TRUE.
                        //  IDCANCEL instead of psh1.
                        SetWindowText( GetDlgItem(hDlg, IDCANCEL),
                                       (LPTSTR)szClose );
                    }
                    break;
                }
                case ( pshHelp ) :
                {
                    //
                    //  Call HELP app.
                    //
#ifdef UNICODE
                    if (pFRI->ApiType == COMDLG_ANSI)
                    {
                        if (msgHELPA && pFR->hwndOwner)
                        {
                            SendMessage( pFR->hwndOwner,
                                         msgHELPA,
                                         (WPARAM)hDlg,
                                         (LPARAM)pFR );
                        }
                    }
                    else
#endif
                    {
                        if (msgHELPW && pFR->hwndOwner)
                        {
                            SendMessage( pFR->hwndOwner,
                                         msgHELPW,
                                         (WPARAM)hDlg,
                                         (LPARAM)pFR );
                        }
                    }
                    break;
                }
                case ( edt1 ) :
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        BOOL fAnythingToFind =
                            (BOOL)SendDlgItemMessage( hDlg,
                                                      edt1,
                                                      WM_GETTEXTLENGTH,
                                                      0,
                                                      0L );
                        EnableWindow(GetDlgItem(hDlg, IDOK), fAnythingToFind);
                        if (pFRI->DlgType == DLGT_REPLACE)
                        {
                            EnableWindow(GetDlgItem(hDlg, psh1), fAnythingToFind);
                            EnableWindow(GetDlgItem(hDlg, psh2), fAnythingToFind);
                        }
                    }

                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        EnableWindow( GetDlgItem(hDlg, IDOK),
                                      (BOOL)SendDlgItemMessage(
                                                   hDlg,
                                                   edt1,
                                                   WM_GETTEXTLENGTH,
                                                   0,
                                                   0L ));
                    }
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_HELP ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPTSTR)aFindReplaceHelpIDs );
            }
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)wParam,
                         NULL,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)aFindReplaceHelpIDs );
            }
            break;
        }
        case ( WM_CLOSE ) :
        {
            SendMessage(hDlg, WM_COMMAND, GET_WM_COMMAND_MPS(IDCANCEL, 0, 0));
            return (TRUE);
            break;
        }
        default:
        {
            return (FALSE);
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  EndDlgSession
//
//  Cleans up upon destroying the dialog.
//
////////////////////////////////////////////////////////////////////////////

VOID EndDlgSession(
   HWND hDlg,
   LPFINDREPLACE pFR)
{
    //
    //  Need to terminate regardless of app testing order ... so:
    //

    //
    //  No SUCCESS on termination.
    //
    pFR->Flags &= ~((DWORD)(FR_REPLACE | FR_FINDNEXT | FR_REPLACEALL));

    //
    //  Tell caller dialog is about to terminate.
    //
    pFR->Flags |= FR_DIALOGTERM;
    NotifyUpdateTextAndFlags(pFR);

    if (IS16BITWOWAPP(pFR))
    {
        if ((pFR->Flags & FR_ENABLEHOOK) && (pFR->lpfnHook))
        {
            (*pFR->lpfnHook)(hDlg, WM_DESTROY, 0, 0);
        }
    }

    //
    //  Free property slots.
    //
    RemoveProp(hDlg, FINDREPLACEPROP);
    DestroyWindow(hDlg);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitControlsWithFlags
//
////////////////////////////////////////////////////////////////////////////

VOID InitControlsWithFlags(
   HWND hDlg,
   LPFINDREPLACE pFR,
   UINT DlgType,
   UINT ApiType)
{
    HWND hCtl;

    //
    //  Set EDIT control to FindText.
    //
#ifdef UNICODE
    if (ApiType == COMDLG_ANSI)
    {
        SetDlgItemTextA(hDlg, edt1, (LPSTR)pFR->lpstrFindWhat);
    }
    else
#endif
    {
        SetDlgItemText(hDlg, edt1, (LPTSTR)pFR->lpstrFindWhat);
    }
    SendMessage(hDlg, WM_COMMAND, GET_WM_COMMAND_MPS(edt1, 0, EN_CHANGE));

    //
    //  Set HELP push button state.
    //
    if (!(pFR->Flags & FR_SHOWHELP))
    {
        ShowWindow(hCtl = GetDlgItem(hDlg, pshHelp), SW_HIDE);
        EnableWindow(hCtl, FALSE);
    }

    //
    //  Dis/Enable check state of WHOLE WORD control.
    //
    if (pFR->Flags & FR_HIDEWHOLEWORD)
    {
        ShowWindow(hCtl = GetDlgItem(hDlg, chx1), SW_HIDE);
        EnableWindow(hCtl, FALSE);
    }
    else if (pFR->Flags & FR_NOWHOLEWORD)
    {
        EnableWindow(GetDlgItem(hDlg, chx1), FALSE);
    }
    CheckDlgButton(hDlg, chx1, (pFR->Flags & FR_WHOLEWORD) ? TRUE: FALSE);

    //
    //  Dis/Enable check state of MATCH CASE control.
    //
    if (pFR->Flags & FR_HIDEMATCHCASE)
    {
        ShowWindow(hCtl = GetDlgItem(hDlg, chx2), SW_HIDE);
        EnableWindow(hCtl, FALSE);
    }
    else if (pFR->Flags & FR_NOMATCHCASE)
    {
        EnableWindow(GetDlgItem(hDlg, chx2), FALSE);
    }
    CheckDlgButton(hDlg, chx2, (pFR->Flags & FR_MATCHCASE) ? TRUE: FALSE);

    //
    //  Dis/Enable check state of UP/DOWN buttons.
    //
    if (pFR->Flags & FR_HIDEUPDOWN)
    {
        ShowWindow(GetDlgItem(hDlg, grp1), SW_HIDE);
        ShowWindow(hCtl = GetDlgItem(hDlg, rad1), SW_HIDE);
        EnableWindow(hCtl, FALSE);
        ShowWindow(hCtl = GetDlgItem(hDlg, rad2), SW_HIDE);
        EnableWindow(hCtl, FALSE);
    }
    else if (pFR->Flags & FR_NOUPDOWN)
    {
        EnableWindow(GetDlgItem(hDlg, rad1), FALSE);
        EnableWindow(GetDlgItem(hDlg, rad2), FALSE);
    }

    if (DlgType == DLGT_FIND)
    {
        //
        //  Find Text only search direction setup.
        //
        CheckRadioButton( hDlg,
                          rad1,
                          rad2,
                          (pFR->Flags & FR_DOWN ? rad2 : rad1) );
    }
    else
    {
        //
        //  Replace Text only operations.
        //
#ifdef UNICODE
        if (ApiType == COMDLG_ANSI)
        {
             SetDlgItemTextA(hDlg, edt2, (LPSTR)pFR->lpstrReplaceWith);
        }
        else
#endif
        {
             SetDlgItemText(hDlg, edt2, pFR->lpstrReplaceWith);
        }
        SendMessage( hDlg,
                     WM_COMMAND,
                     GET_WM_COMMAND_MPS(edt2, 0, EN_CHANGE) );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateTextAndFlags
//
//  chx1 is whether or not to match entire words
//  chx2 is whether or not case is relevant
//  chx3 is whether or not to wrap scans
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateTextAndFlags(
    HWND hDlg,
    LPFINDREPLACE pFR,
    DWORD dwActionFlag,
    UINT DlgType,
    UINT ApiType)
{
    //
    //  Only clear flags that this routine sets.  The hook and template
    //  flags should not be anded off here.
    //
    pFR->Flags &= ~((DWORD)(FR_WHOLEWORD | FR_MATCHCASE | FR_REPLACE |
                            FR_FINDNEXT | FR_REPLACEALL | FR_DOWN));
    if (IsDlgButtonChecked(hDlg, chx1))
    {
        pFR->Flags |= FR_WHOLEWORD;
    }

    if (IsDlgButtonChecked(hDlg, chx2))
    {
        pFR->Flags |= FR_MATCHCASE;
    }

    //
    //  Set ACTION flag FR_{REPLACE,FINDNEXT,REPLACEALL}.
    //
    pFR->Flags |= dwActionFlag;

#ifdef UNICODE
    if (ApiType == COMDLG_ANSI)
    {
        GetDlgItemTextA(hDlg, edt1, (LPSTR)pFR->lpstrFindWhat, pFR->wFindWhatLen);
    }
    else
#endif
    {
        GetDlgItemText(hDlg, edt1, pFR->lpstrFindWhat, pFR->wFindWhatLen);
    }

    if (DlgType == DLGT_FIND)
    {
        //
        //  Assume searching down.  Check if UP button is NOT pressed, rather
        //  than if DOWN button IS.  So, if buttons have been hidden or
        //  disabled, FR_DOWN flag will be set correctly.
        //
        if (!IsDlgButtonChecked(hDlg, rad1))
        {
            pFR->Flags |= FR_DOWN;
        }
    }
    else
    {
#ifdef UNICODE
        if (ApiType == COMDLG_ANSI)
        {
            GetDlgItemTextA( hDlg,
                             edt2,
                             (LPSTR)pFR->lpstrReplaceWith,
                             pFR->wReplaceWithLen );
        }
        else
#endif
        {
            GetDlgItemText( hDlg,
                            edt2,
                            pFR->lpstrReplaceWith,
                            pFR->wReplaceWithLen );
        }
        pFR->Flags |= FR_DOWN;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  NotifyUpdateTextAndFlags
//
////////////////////////////////////////////////////////////////////////////

LRESULT NotifyUpdateTextAndFlags(
    LPFINDREPLACE pFR)
{
    if (IS16BITWOWAPP(pFR))
    {
        return ( SendMessage( pFR->hwndOwner,
                              WM_NOTIFYWOW,
                              WMNW_UPDATEFINDREPLACE,
                              (DWORD_PTR)pFR ) );
    }
    return ( SendMessage(pFR->hwndOwner, wFRMessage, 0, (DWORD_PTR)pFR) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\filenew.cpp ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    filenew.cpp

Abstract:

    This module implements the Win32 explorer fileopen dialogs.

--*/
//
//  Include Files.
//

#undef WINVER
#define WINVER 0x0500       // Needed to get new GUID constant.

#if (_WIN32_WINNT < 0x0500)
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#define _OLE32_

#include "comdlg32.h"
#include <shellapi.h>
#include <shlobj.h>
#include <shsemip.h>
#include <shellp.h>
#include <commctrl.h>
#include <ole2.h>
#include "cdids.h"
#include "fileopen.h"
#include "tlog.h"
#include "filenew.h"
#include "filemru.h"

#include <coguid.h>
#include <shlguid.h>
#include <shguidp.h>
#include <oleguid.h>

#include <commdlg.h>
#include "util.h"

#ifndef ASSERT
#define ASSERT Assert
#endif

//
//  Constant Declarations.
//

#define IDOI_SHARE           1

#define IDC_TOOLBAR          1              // toolbar control ID

#define CDM_SETSAVEBUTTON    (CDM_LAST + 100)
#define CDM_FSNOTIFY         (CDM_LAST + 101)
#define CDM_SELCHANGE        (CDM_LAST + 102)

#define TIMER_FSCHANGE       100

#define NODE_DESKTOP         0
#define NODE_DRIVES          1

#define DEREFMACRO(x)        x

#define FILE_PADDING         10

//
//  IShellView::MenuHelp flags.
//
#define MH_DONE              0x0001
//      MH_LONGHELP
#define MH_MERGEITEM         0x0004
#define MH_SYSITEM           0x0008
#define MH_POPUP             0x0010
#define MH_TOOLBAR           0x0020
#define MH_TOOLTIP           0x0040

//
//  IShellView::MenuHelp return values.
//
#define MH_NOTHANDLED        0
#define MH_STRINGFILLED      1
#define MH_ALLHANDLED        2

#define MYCBN_DRAW           0x8000
#define MIN_DEFEXT_LEN       4

#define MAX_DRIVELIST_STRING_LEN  (64 + 4)




//
//  Macro Definitions.
//

#define IsServer(psz)        (IsUNC(psz) && !StrChr((psz) + 2, CHAR_BSLASH))

#define LPIDL_GetIDList(_pida,n) \
    (LPCITEMIDLIST)(((LPBYTE)(_pida)) + (_pida)->aoffset[n])

#define RECTWIDTH(_rc)       ((_rc).right - (_rc).left)
#define RECTHEIGHT(_rc)      ((_rc).bottom - (_rc).top)

#define IsVisible(_hwnd)     (GetWindowLong(_hwnd, GWL_STYLE) & WS_VISIBLE)

#define HwndToBrowser(_hwnd) (CFileOpenBrowser *)GetWindowLongPtr(_hwnd, DWLP_USER)
#define StoreBrowser(_hwnd, _pbrs) \
    SetWindowLongPtr(_hwnd, DWLP_USER, (LONG_PTR)_pbrs);




//
//  Typedef Declarations.
//

typedef struct _OFNINITINFO
{
    LPOPENFILEINFO  lpOFI;
    BOOL            bSave;
    BOOL            bEnableSizing;
} OFNINITINFO, *LPOFNINITINFO;


#define VC_NEWFOLDER    0
#define VC_VIEWLIST     1
#define VC_VIEWDETAILS  2


//
//  Global Variables.
//

WNDPROC lpOKProc = NULL;

HWND gp_hwndActiveOpen = NULL;
HACCEL gp_haccOpen = NULL;
HACCEL gp_haccOpenView = NULL;
HHOOK gp_hHook = NULL;
int gp_nHookRef = -1;


static int g_cxSmIcon;
static int g_cySmIcon;
static int g_cxGrip;
static int g_cyGrip;

const LPCSTR c_szCommandsA[] =
{
    CMDSTR_NEWFOLDERA,
    CMDSTR_VIEWLISTA,
    CMDSTR_VIEWDETAILSA,
};

const LPCWSTR c_szCommandsW[] =
{
    CMDSTR_NEWFOLDERW,
    CMDSTR_VIEWLISTW,
    CMDSTR_VIEWDETAILSW,
};


extern "C" { extern SIZE g_sizeDlg; }
extern "C" { extern BOOL g_bMyDocsHidden; }
POINT g_posDlg;




//
//  Function Prototypes.
//

LRESULT CALLBACK
OKSubclass(
    HWND hOK,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam);

void
GetControlsArea(
    HWND hDlg,
    HWND hwndExclude,
    HWND hwndGrip,
    POINT *pPtSize,
    LPINT pTop);

BOOL_PTR CALLBACK
OpenDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

void
CleanupDialog(
    HWND hDlg,
    BOOL fRet);

void
StoreLengthInString(
    LPTSTR lpStr,
    UINT cchLen,
    UINT cchStore);



//
//  Context Help IDs.
//

DWORD aFileOpenHelpIDs[] =
{
    stc2,    IDH_OPEN_FILETYPE,   // The positions of these array elements
    cmb1,    IDH_OPEN_FILETYPE,   // shouldn't be changed without updating
    stc4,    IDH_OPEN_LOCATION,   // InitSaveAsControls().
    cmb2,    IDH_OPEN_LOCATION,
    stc1,    IDH_OPEN_FILES32,
    lst2,    IDH_OPEN_FILES32,    // defview
    stc3,    IDH_OPEN_FILENAME,
    edt1,    IDH_OPEN_FILENAME,
    cmb13,   IDH_OPEN_FILENAME,
    chx1,    IDH_OPEN_READONLY,
    IDOK,    IDH_OPEN_BUTTON,

    0, 0
};

DWORD aFileSaveHelpIDs[] =
{
    stc2,    IDH_SAVE_FILETYPE,   // The positions of these array elements
    cmb1,    IDH_SAVE_FILETYPE,   // shouldn't be changed without updating
    stc4,    IDH_OPEN_LOCATION,   // InitSaveAsControls().
    cmb2,    IDH_OPEN_LOCATION,
    stc1,    IDH_OPEN_FILES32,
    lst2,    IDH_OPEN_FILES32,    // defview
    stc3,    IDH_OPEN_FILENAME,
    edt1,    IDH_OPEN_FILENAME,
    cmb13,   IDH_OPEN_FILENAME,
    chx1,    IDH_OPEN_READONLY,
    IDOK,    IDH_SAVE_BUTTON,
    0, 0
};





////////////////////////////////////////////////////////////////////////////
//
//  CD_SendShareMsg
//
////////////////////////////////////////////////////////////////////////////

WORD CD_SendShareMsg(
    HWND hwnd,
    LPTSTR szFile,
    UINT ApiType)
{
#ifdef UNICODE
    if (ApiType == COMDLG_ANSI)
    {
        CHAR szFileA[MAX_PATH + 1];

        WideCharToMultiByte( CP_ACP,
                             0,
                             szFile,
                             -1,
                             szFileA,
                             MAX_PATH + 1,
                             NULL,
                             NULL );

        return ( (WORD)SendMessage( hwnd,
                                    msgSHAREVIOLATIONA,
                                    0,
                                    (LONG_PTR)(LPSTR)(szFileA) ) );
    }
    else
#endif
    {
        return ( (WORD)SendMessage( hwnd,
                                    msgSHAREVIOLATIONW,
                                    0,
                                    (LONG_PTR)(LPTSTR)(szFile) ) );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CD_SendHelpMsg
//
////////////////////////////////////////////////////////////////////////////

VOID CD_SendHelpMsg(
    LPOPENFILENAME pOFN,
    HWND hwndDlg,
    UINT ApiType)
{
#ifdef UNICODE
    if (ApiType == COMDLG_ANSI)
    {
        if (msgHELPA && pOFN->hwndOwner)
        {
            SendMessage( pOFN->hwndOwner,
                         msgHELPA,
                         (WPARAM)hwndDlg,
                         (LPARAM)pOFN );
        }
    }
    else
#endif
    {
        if (msgHELPW && pOFN->hwndOwner)
        {
            SendMessage( pOFN->hwndOwner,
                         msgHELPW,
                         (WPARAM)hwndDlg,
                         (LPARAM)pOFN );
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CD_SendOKMsg
//
////////////////////////////////////////////////////////////////////////////

LRESULT CD_SendOKMsg(
    HWND hwnd,
    LPOPENFILENAME pOFN,
    LPOPENFILEINFO pOFI)
{
    LRESULT Result;

#ifdef UNICODE
    if (pOFI->ApiType == COMDLG_ANSI)
    {
        ThunkOpenFileNameW2A(pOFI);
        Result = SendMessage(hwnd, msgFILEOKA, 0, (LPARAM)(pOFI->pOFNA));

        //
        //  For apps that side-effect pOFNA stuff and expect it to
        //  be preserved through dialog exit, update internal
        //  struct after the hook proc is called.
        //
        ThunkOpenFileNameA2W(pOFI);
    }
    else
#endif
    {
        Result = SendMessage(hwnd, msgFILEOKW, 0, (LPARAM)(pOFN));
    }

    return (Result);
}


////////////////////////////////////////////////////////////////////////////
//
//  CD_SendLBChangeMsg
//
////////////////////////////////////////////////////////////////////////////

LRESULT CD_SendLBChangeMsg(
    HWND hwnd,
    int Id,
    short Index,
    short Code,
    UINT ApiType)
{
#ifdef UNICODE
    if (ApiType == COMDLG_ANSI)
    {
        return (SendMessage(hwnd, msgLBCHANGEA, Id, MAKELONG(Index, Code)));
    }
    else
#endif
    {
        return (SendMessage(hwnd, msgLBCHANGEW, Id, MAKELONG(Index, Code)));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Macro calls to SendOFNotify
//
////////////////////////////////////////////////////////////////////////////

#define CD_SendShareNotify(_hwndTo, _hwndFrom, _szFile, _pofn, _pofi) \
    (WORD)SendOFNotify(_hwndTo, _hwndFrom, CDN_SHAREVIOLATION, _szFile, _pofn, _pofi)

#define CD_SendHelpNotify(_hwndTo, _hwndFrom, _pofn, _pofi) \
    SendOFNotify(_hwndTo, _hwndFrom, CDN_HELP, NULL, _pofn, _pofi)

#define CD_SendOKNotify(_hwndTo, _hwndFrom, _pofn, _pofi) \
    SendOFNotify(_hwndTo, _hwndFrom, CDN_FILEOK, NULL, _pofn, _pofi)

#define CD_SendTypeChangeNotify(_hwndTo, _hwndFrom, _pofn, _pofi) \
    SendOFNotify(_hwndTo, _hwndFrom, CDN_TYPECHANGE, NULL, _pofn, _pofi)

#define CD_SendInitDoneNotify(_hwndTo, _hwndFrom, _pofn, _pofi) \
    SendOFNotify(_hwndTo, _hwndFrom, CDN_INITDONE, NULL, _pofn, _pofi)

#define CD_SendSelChangeNotify(_hwndTo, _hwndFrom, _pofn, _pofi) \
    SendOFNotify(_hwndTo, _hwndFrom, CDN_SELCHANGE, NULL, _pofn, _pofi)

#define CD_SendFolderChangeNotify(_hwndTo, _hwndFrom, _pofn, _pofi) \
    SendOFNotify(_hwndTo, _hwndFrom, CDN_FOLDERCHANGE, NULL, _pofn, _pofi)

#define CD_SendIncludeItemNotify(_hwndTo, _hwndFrom, _psf, _pidl, _pofn, _pofi) \
    SendOFNotifyEx(_hwndTo, _hwndFrom, CDN_INCLUDEITEM, (LPVOID)_psf, (LPVOID)_pidl, _pofn, _pofi)



////////////////////////////////////////////////////////////////////////////
//
//  SendOFNotifyEx
//
////////////////////////////////////////////////////////////////////////////

LRESULT SendOFNotifyEx(
    HWND hwndTo,
    HWND hwndFrom,
    UINT code,
    LPVOID psf,
    LPVOID pidl,
    LPOPENFILENAME pOFN,
    LPOPENFILEINFO pOFI)
{
    OFNOTIFYEX ofnex;

#ifdef UNICODE
    if (pOFI->ApiType == COMDLG_ANSI)
    {
        OFNOTIFYEXA ofnexA;
        LRESULT Result;

        ofnexA.psf  = psf;
        ofnexA.pidl = pidl;

        //
        //  Convert the OFN from Unicode to Ansi.
        //
        ThunkOpenFileNameW2A(pOFI);

        ofnexA.lpOFN = pOFI->pOFNA;

        Result = SendNotify(hwndTo, hwndFrom, code, &ofnexA.hdr);

        //
        //  For apps that side-effect pOFNA stuff and expect it to
        //  be preserved through dialog exit, update internal
        //  struct after the hook proc is called.
        //
        ThunkOpenFileNameA2W(pOFI);

        return (Result);
    }
    else
#endif
    {
        ofnex.psf   = psf;
        ofnex.pidl  = pidl;
        ofnex.lpOFN = pOFN;

        return (SendNotify(hwndTo, hwndFrom, code, &ofnex.hdr));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SendOFNotify
//
////////////////////////////////////////////////////////////////////////////

LRESULT SendOFNotify(
    HWND hwndTo,
    HWND hwndFrom,
    UINT code,
    LPTSTR szFile,
    LPOPENFILENAME pOFN,
    LPOPENFILEINFO pOFI)
{
    OFNOTIFY ofn;

#ifdef UNICODE
    if (pOFI->ApiType == COMDLG_ANSI)
    {
        OFNOTIFYA ofnA;
        LRESULT Result;

        //
        //  Convert the file name from Unicode to Ansi.
        //
        if (szFile)
        {
            CHAR szFileA[MAX_PATH + 1];

            WideCharToMultiByte( CP_ACP,
                                 0,
                                 szFile,
                                 -1,
                                 szFileA,
                                 MAX_PATH + 1,
                                 NULL,
                                 NULL );

            ofnA.pszFile = szFileA;
        }
        else
        {
            ofnA.pszFile = NULL;
        }

        //
        //  Convert the OFN from Unicode to Ansi.
        //
        ThunkOpenFileNameW2A(pOFI);

        ofnA.lpOFN = pOFI->pOFNA;

        Result = SendNotify(hwndTo, hwndFrom, code, &ofnA.hdr);

        //
        //  For apps that side-effect pOFNA stuff and expect it to
        //  be preserved through dialog exit, update internal
        //  struct after the hook proc is called.
        //
        ThunkOpenFileNameA2W(pOFI);

        return (Result);
    }
    else
#endif
    {
        ofn.pszFile = szFile;
        ofn.lpOFN   = pOFN;

        return (SendNotify(hwndTo, hwndFrom, code, &ofn.hdr));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  TEMPMEM::Resize
//
////////////////////////////////////////////////////////////////////////////

BOOL TEMPMEM::Resize(
    UINT cb)
{
    UINT uOldSize = m_uSize;

    m_uSize = cb;

    if (!cb)
    {
        if (m_pMem)
        {
            LocalFree(m_pMem);
            m_pMem = NULL;
        }

        return (TRUE);
    }

    if (!m_pMem)
    {
        m_pMem = LocalAlloc(LPTR, cb);
        return (m_pMem != NULL);
    }

    LPVOID pTemp = LocalReAlloc(m_pMem, cb, LHND);

    if (pTemp)
    {
        m_pMem = pTemp;
        return (TRUE);
    }

    m_uSize = uOldSize;
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  TEMPSTR::StrCpy
//
////////////////////////////////////////////////////////////////////////////

BOOL TEMPSTR::StrCpy(
    LPCTSTR pszText)
{
    if (!pszText)
    {
        StrSize(0);
        return (TRUE);
    }

    UINT uNewSize = lstrlen(pszText) + 1;

    if (!StrSize(uNewSize))
    {
        return (FALSE);
    }

    lstrcpy(*this, pszText);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  TEMPSTR::StrCat
//
////////////////////////////////////////////////////////////////////////////

BOOL TEMPSTR::StrCat(
    LPCTSTR pszText)
{
    if (!(LPTSTR)*this)
    {
        //
        //  This should 0 init.
        //
        if (!StrSize(MAX_PATH))
        {
            return (FALSE);
        }
    }

    UINT uNewSize = lstrlen(*this) + lstrlen(pszText) + 1;

    if (m_uSize < uNewSize * sizeof(TCHAR))
    {
        //
        //  Add on some more so we do not ReAlloc too often.
        //
        uNewSize += MAX_PATH;

        if (!StrSize(uNewSize))
        {
            return (FALSE);
        }
    }

    lstrcat(*this, pszText);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CDMessageBox
//
////////////////////////////////////////////////////////////////////////////

int _cdecl CDMessageBox(
    HWND hwndParent,
    UINT idText,
    UINT uFlags,
    ...)
{
    TCHAR szText[MAX_PATH + WARNINGMSGLENGTH];
    TCHAR szTitle[WARNINGMSGLENGTH];
    va_list ArgList;

    LoadString(g_hinst, idText, szTitle, ARRAYSIZE(szTitle));
    va_start(ArgList, uFlags);
    wvsprintf(szText, szTitle, ArgList);
    va_end(ArgList);

    GetWindowText(hwndParent, szTitle, ARRAYSIZE(szTitle));

    return (MessageBox(hwndParent, szText, szTitle, uFlags));
}


int OFErrFromHresult(HRESULT hr)
{
    switch (hr)
    {
    case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
        return OF_FILENOTFOUND;

    case E_ACCESSDENIED:
        return OF_ACCESSDENIED;

    default:
        return -1;
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  InvalidFileWarningNew
//
////////////////////////////////////////////////////////////////////////////

VOID InvalidFileWarningNew(
    HWND hWnd,
    LPTSTR szFile,
    int wErrCode)
{
    LPTSTR lpszContent = szFile;
    int isz;
    BOOL bDriveLetter = FALSE;

    if (lstrlen(szFile) > MAX_PATH)
    {
#ifdef UNICODE
        *(szFile + MAX_PATH) = CHAR_NULL;
#else
        EliminateString(szFile, MAX_PATH);
#endif
    }

    switch (wErrCode)
    {
        case ( OF_ACCESSDENIED ) :
        {
            isz = iszFileAccessDenied;
            break;
        }
        case ( ERROR_NOT_READY ) :
        {
            isz = iszNoDiskInDrive;
            bDriveLetter = TRUE;
            break;
        }
        case ( OF_NODRIVE ) :
        {
            isz = iszDriveDoesNotExist;
            bDriveLetter = TRUE;
            break;
        }
        case ( OF_NOFILEHANDLES ) :
        {
            isz = iszNoFileHandles;
            break;
        }
        case ( OF_PATHNOTFOUND ) :
        {
            isz = iszPathNotFound;
            break;
        }
        case ( OF_FILENOTFOUND ) :
        {
            isz = iszFileNotFound;
            break;
        }
        case ( OF_DISKFULL ) :
        case ( OF_DISKFULL2 ) :
        {
            isz = iszDiskFull;
            bDriveLetter = TRUE;
            break;
        }
        case ( OF_WRITEPROTECTION ) :
        {
            isz = iszWriteProtection;
            bDriveLetter = TRUE;
            break;
        }
        case ( OF_SHARINGVIOLATION ) :
        {
            isz = iszSharingViolation;
            break;
        }
        case ( OF_CREATENOMODIFY ) :
        {
            isz = iszCreateNoModify;
            break;
        }
        case ( OF_NETACCESSDENIED ) :
        {
            isz = iszNetworkAccessDenied;
            break;
        }
        case ( OF_PORTNAME ) :
        {
            isz = iszPortName;
            break;
        }
        case ( OF_LAZYREADONLY ) :
        {
            isz = iszReadOnly;
            break;
        }
        case ( OF_INT24FAILURE ) :
        {
            isz = iszInt24Error;
            break;
        }
        default :
        {
            isz = iszInvalidFileName;
            break;
        }
    }

    if (bDriveLetter)
    {
        CDMessageBox(hWnd, isz, MB_OK | MB_ICONEXCLAMATION, (TCHAR)*szFile);
    }
    else
    {
        CDMessageBox(hWnd, isz, MB_OK | MB_ICONEXCLAMATION, (LPTSTR)szFile);
    }

    if (isz == iszInvalidFileName)
    {
        CFileOpenBrowser *pDlgStruct = HwndToBrowser(hWnd);

        if (pDlgStruct && pDlgStruct->bUseCombo)
        {
            PostMessage(hWnd, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hWnd, cmb13), 1);
        }
        else
        {
            PostMessage(hWnd, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hWnd, edt1), 1);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetControlRect
//
////////////////////////////////////////////////////////////////////////////

void GetControlRect(
    HWND hwndDlg,
    UINT idOldCtrl,
    LPRECT lprc)
{
    HWND hwndOldCtrl = GetDlgItem(hwndDlg, idOldCtrl);

    GetWindowRect(hwndOldCtrl, lprc);
    MapWindowRect(HWND_DESKTOP, hwndDlg, lprc);
}


////////////////////////////////////////////////////////////////////////////
//
//  HideControl
//
//  Subroutine to hide a dialog control.
//
//  WARNING WARNING WARNING:  Some code in the new look depends on hidden
//  controls remaining where they originally were, even when disabled,
//  because they're templates for where to create new controls (the toolbar,
//  or the main list).  Therefore, HideControl() must not MOVE the control
//  being hidden - it may only hide and disable it.  If this needs to change,
//  there must be a separate hiding subroutine used for template controls.
//
////////////////////////////////////////////////////////////////////////////

void HideControl(
    HWND hwndDlg,
    UINT idControl)
{
    HWND hCtrl = ::GetDlgItem(hwndDlg, idControl);

    ::ShowWindow(hCtrl, SW_HIDE);
    ::EnableWindow(hCtrl, FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SelectEditText
//
////////////////////////////////////////////////////////////////////////////

void SelectEditText(
    HWND hwndDlg)
{
    CFileOpenBrowser *pDlgStruct = HwndToBrowser(hwndDlg);

    if (pDlgStruct && pDlgStruct->bUseCombo)
    {
        HWND hwndEdit = (HWND)SendMessage(GetDlgItem(hwndDlg, cmb13), CBEM_GETEDITCONTROL, 0, 0L);
        Edit_SetSel(hwndEdit, 0, -1);
    }
    else
    {
        Edit_SetSel(GetDlgItem(hwndDlg, edt1), 0, -1);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetPathFromLocation
//
////////////////////////////////////////////////////////////////////////////

BOOL GetPathFromLocation(
    MYLISTBOXITEM *pLocation,
    LPTSTR pszBuf)
{
    BOOL fRet = FALSE;

    //
    //  Zero out the return buffer in case of error.
    //
    *pszBuf = 0;

    //
    //  Try normal channels first.
    //
    fRet = SHGetPathFromIDList(pLocation->pidlFull, pszBuf);
    if (!fRet)
    {
        //
        //  Call GetDisplayNameOf with empty pidl.
        //
        if (pLocation->psfSub)
        {
            STRRET Path;
            ITEMIDLIST Id;

            Id.mkid.cb = 0;

            if (SUCCEEDED(pLocation->psfSub->GetDisplayNameOf( &Id,
                                                               SHGDN_FORPARSING,
                                                               &Path )))
            {
                fRet = TRUE;
                StrRetToStrN(pszBuf, MAX_PATH, &Path, &Id);
                if (Path.uType == STRRET_OLESTR)
                {
                    LocalFree(Path.pOleStr);
                }
            }
        }
    }

    //
    //  Return the result.
    //
    return (fRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  MYLISTBOXITEM::MYLISTBOXITEM
//
////////////////////////////////////////////////////////////////////////////

#define MLBI_PERMANENT        0x0001
#define MLBI_PSFFROMPARENT    0x0002

MYLISTBOXITEM::MYLISTBOXITEM()
{
}


BOOL MYLISTBOXITEM::Init(
        MYLISTBOXITEM *pParentItem,
        IShellFolder *psf,
        LPCITEMIDLIST pidl,
        DWORD c,
        DWORD f)
{

    if (psf == NULL )
    {
        // Invalid parameter passed.
        return FALSE;
    }

    cIndent = c;
    dwFlags = f;

    pidlThis = ILClone(pidl);
    if (pParentItem == NULL)
    {
        pidlFull = ILClone(pidl);
    }
    else
    {
        pidlFull = ILCombine(pParentItem->pidlFull, pidl);
    }

    if (pidlThis == NULL || pidlFull == NULL)
    {
        psfSub = NULL;
    }

    if (dwFlags & MLBI_PSFFROMPARENT)
    {
        psfParent = psf;
    }
    else
    {
        psfSub = psf;
    }
    psf->AddRef();


    dwAttrs = SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_FILESYSANCESTOR | SFGAO_SHARE | SFGAO_CANMONIKER;

    psf->GetAttributesOf(1, &pidl, &dwAttrs);

    iImage = SHMapPIDLToSystemImageListIndex(psf, pidl, &iSelectedImage);

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  MYLISTBOXITEM::~MYLISTBOXITEM
//
////////////////////////////////////////////////////////////////////////////

MYLISTBOXITEM::~MYLISTBOXITEM()
{
    if (psfSub != NULL)
    {
        psfSub->Release();
    }

    if (psfParent != NULL)
    {
        psfParent->Release();
    }

    if (pidlThis != NULL)
    {
        SHFree(pidlThis);
    }

    if (pidlFull != NULL)
    {
        SHFree(pidlFull);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  IsContainer
//
////////////////////////////////////////////////////////////////////////////

BOOL IsContainer(
    IShellFolder *psf,
    LPCITEMIDLIST pidl)
{
    DWORD dwAttrs = SFGAO_FOLDER;

    return (SUCCEEDED(psf->GetAttributesOf(1, &pidl, &dwAttrs)) &&
            (dwAttrs & SFGAO_FOLDER));
}


////////////////////////////////////////////////////////////////////////////
//
//  IsLink
//
////////////////////////////////////////////////////////////////////////////

BOOL IsLink(
    IShellFolder *psf,
    LPCITEMIDLIST pidl)
{
    DWORD dwAttrs = SFGAO_LINK;

    return (SUCCEEDED(psf->GetAttributesOf(1, &pidl, &dwAttrs)) &&
            (dwAttrs & SFGAO_LINK));
}


////////////////////////////////////////////////////////////////////////////
//
//  MYLISTBOXITEM::GetShellFolder
//
////////////////////////////////////////////////////////////////////////////

IShellFolder *MYLISTBOXITEM::GetShellFolder()
{
    if (!psfSub)
    {
        if (FAILED(psfParent->BindToObject( pidlThis,
                                            NULL,
                                            IID_IShellFolder,
                                            (LPVOID *)&psfSub )))
        {
            psfSub = NULL;
        }
        else
        {
            psfParent->Release();
            psfParent = NULL;
        }
    }

    return (psfSub);
}


////////////////////////////////////////////////////////////////////////////
//
//  MYLISTBOXITEM::SwitchCurrentDirectory
//
////////////////////////////////////////////////////////////////////////////

void MYLISTBOXITEM::SwitchCurrentDirectory(
    ICurrentWorkingDirectory * pcwd)
{
    TCHAR szDir[MAX_PATH + 1];

    if (!pidlFull)
    {
        SHGetSpecialFolderPath(NULL, szDir, CSIDL_DESKTOPDIRECTORY, FALSE);
    }
    else
    {
        GetPathFromLocation(this, szDir);
    }

    if (szDir[0])
    {
        SetCurrentDirectory(szDir);

        //
        //  Let AutoComplete know our Current Working Directory.
        //
        SetAutoCompleteCWD(szDir, pcwd);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ShouldIncludeObject
//
////////////////////////////////////////////////////////////////////////////

BOOL ShouldIncludeObject(
    CFileOpenBrowser *that,
    LPSHELLFOLDER psfParent,
    LPCITEMIDLIST pidl,
    DWORD dwFlags)
{
    BOOL fInclude = FALSE;
    DWORD dwAttrs = (dwFlags & OFN_USEMONIKERS) ? SFGAO_CANMONIKER | SFGAO_FOLDER:
        SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_FILESYSANCESTOR;

    if (SUCCEEDED(psfParent->GetAttributesOf(1, &pidl, &dwAttrs)))
    {
        if ((dwFlags & OFN_ENABLEINCLUDENOTIFY) && that)
        {
            fInclude = BOOLFROMPTR(CD_SendIncludeItemNotify( that->hSubDlg,
                                                        that->hwndDlg,
                                                        psfParent,
                                                        pidl,
                                                        that->lpOFN,
                                                        that->lpOFI ));
        }

        if (!fInclude)
        {
            if (dwAttrs & (SFGAO_FILESYSTEM | SFGAO_FILESYSANCESTOR | SFGAO_CANMONIKER))
            {
                fInclude = TRUE;
            }
        }
    }
    return (fInclude);
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::EnableFileMRU
//
//
////////////////////////////////////////////////////////////////////////////
void CFileOpenBrowser::EnableFileMRU(BOOL fEnable)
{

    HWND hwnd = NULL; 
    if (fEnable)
    {
        // if we are using the combobox then remove the edit box
        bUseCombo = TRUE;
        SetFocus(GetDlgItem(hwndDlg, cmb13));

        hwnd = GetDlgItem(hwndDlg,edt1);


    }
    else
    {
        //We are not going to use  combobox.
        bUseCombo  = FALSE;
    
        //SetFocus to the edit window
        SetFocus(GetDlgItem(hwndDlg,edt1));
  
        //Destroy the combo box
        hwnd = GetDlgItem(hwndDlg, cmb13);

    }
    
    if (hwnd)
    {
        DestroyWindow(hwnd);
    }

}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::CreateToolbar
//
//  CreateToolbar member function.
//      creates and initializes the places bar  in the dialog
//
//
////////////////////////////////////////////////////////////////////////////
BOOL CFileOpenBrowser::CreateToolbar()
{
    TBBUTTON atbButtons[] =
    {
     // NT4 specified seperators between some of the buttons. We need the seperator for app compatability
     /* 0 */   { 0, 0, 0, TBSTYLE_SEP, { 0, 0 }, 0, 0 },
        
     /* 1 */   { VIEW_PARENTFOLDER, IDC_PARENT,        TBSTATE_ENABLED,                    TBSTYLE_BUTTON,     { 0, 0 }, 0, -1 },
     /* 2 */   { VIEW_NEWFOLDER,    IDC_NEWFOLDER,     TBSTATE_ENABLED,                    TBSTYLE_BUTTON,     { 0, 0 }, 0, -1 },

                // The following two buttons are added if we are showing NT4 style dialog
     /* 3 */   { VIEW_LIST,         IDC_VIEWLIST,      TBSTATE_ENABLED | TBSTATE_CHECKED,  TBSTYLE_CHECKGROUP, { 0, 0 }, 0, -1 },
     /* 4 */   { VIEW_DETAILS,      IDC_VIEWDETAILS,   TBSTATE_ENABLED,                    TBSTYLE_CHECKGROUP, { 0, 0 }, 0, -1 },

               //We  replace  the above two buttons with this button in NT5 and above
     /* 5 */   { VIEW_LIST,         IDC_VIEWMENU,      TBSTATE_ENABLED,                    TBSTYLE_DROPDOWN,   { 0, 0 }, 0, -1 },

                //This is new to NT5 and above
     /* 6 */   { 0,                 IDC_BACK,                        0,                    TBSTYLE_BUTTON,     { 0, 0 }, 0, -1 },
    };


    RECT rcToolbar;
    GetControlRect(hwndDlg, stc1, &rcToolbar);

    DWORD dwStyle = 0;

    // TBSTYLE_FLAT changes the behavior of toolbar like drawing SEPERATOR even if TBSTATE value is 0.
    // Not specifying TBSTYLE_FLAT doesn't draw the seperator. NT4 version of Toolbar adds seperator to 
    // create space between buttons
    if ( iVersion >= OPENFILEVERSION_NT5)
    {
        dwStyle = TBSTYLE_FLAT;
    }

    hwndToolbar = CreateWindowEx(0,
                                 TOOLBARCLASSNAME,
                                 NULL,
                                 dwStyle | TBSTYLE_TOOLTIPS |  WS_CHILD | CCS_NORESIZE |
                                 WS_GROUP | CCS_NODIVIDER,
                                 0,
                                 0,
                                 0,
                                 0,
                                 hwndDlg,
                                 (HMENU)IDC_TOOLBAR,
                                 g_hinst,
                                 NULL);

    if (hwndToolbar)
    {

        //Documentation says that we need to send TB_BUTTONSTRUCTSIZE before we add bitmaps
        SendMessage(hwndToolbar, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), (LPARAM)0);
        
        if (iVersion >= OPENFILEVERSION_NT5)
        {
            //Set the toolbar extended styel
            SendMessage(hwndToolbar, TB_SETEXTENDEDSTYLE, TBSTYLE_EX_DRAWDDARROWS, TBSTYLE_EX_DRAWDDARROWS);
        }

       TBADDBITMAP ab;
       LPTBBUTTON lptb;

       if (iVersion >= OPENFILEVERSION_NT4)
       {
            //Add the view bitmaps to the toolbar
            ab.hInst = HINST_COMMCTRL;
            ab.nID   = IDB_VIEW_SMALL_COLOR;

            SendMessage(hwndToolbar, TB_ADDBITMAP, (WPARAM)12, (LPARAM)&ab);
        }


        //Do we need to add back button
        if ( (iVersion >= OPENFILEVERSION_NT5)  && !IsRestricted(REST_NOBACKBUTTON))
        {
            //First add the image for the back button
            //Add the back/forward navigation buttons
            ab.hInst = HINST_COMMCTRL;
            ab.nID   = IDB_HIST_SMALL_COLOR;

            int iIndex = (int) SendMessage(hwndToolbar, TB_ADDBITMAP, 5, (LPARAM)&ab);

            //Add the back button
            lptb = &atbButtons[6];
            lptb->iBitmap = iIndex + HIST_BACK;

            SendMessage(hwndToolbar, TB_ADDBUTTONS, (WPARAM)1, (LPARAM)lptb);
        }

        //NT4 Added this seperator to the toolbar
        if (iVersion == OPENFILEVERSION_NT4)
        {
            lptb = &atbButtons[0];
            SendMessage(hwndToolbar, TB_ADDBUTTONS, (WPARAM)1, (LPARAM)lptb);
        }

        //Add PARENT button
        if (iVersion >= OPENFILEVERSION_NT4)
        {
            lptb = &atbButtons[1];
            SendMessage(hwndToolbar, TB_ADDBUTTONS, (WPARAM)1, (LPARAM)lptb);
        }

        //NT4 Added this seperator to the toolbar
        if (iVersion == OPENFILEVERSION_NT4)
        {
            lptb = &atbButtons[0];
            SendMessage(hwndToolbar, TB_ADDBUTTONS, (WPARAM)1, (LPARAM)lptb);
        }

        //Add NEWFOLDER  button
        if (iVersion >= OPENFILEVERSION_NT4)
        {
            lptb = &atbButtons[2];
            SendMessage(hwndToolbar, TB_ADDBUTTONS, (WPARAM)1, (LPARAM)lptb);
        }

        //NT4 Added this seperator to the toolbar
        if (iVersion == OPENFILEVERSION_NT4)
        {
            lptb = &atbButtons[0];
            SendMessage(hwndToolbar, TB_ADDBUTTONS, (WPARAM)1, (LPARAM)lptb);

        }


        if (iVersion >= OPENFILEVERSION_NT5)
        {
            //In NT5 and above add only the dropdown View button
            lptb = &atbButtons[5];
            SendMessage(hwndToolbar, TB_ADDBUTTONS, (WPARAM)1, (LPARAM)lptb);
        }
        else if (iVersion >= OPENFILEVERSION_NT4)
        {
            // In NT4  add both the View List and View Details button
            lptb = &atbButtons[3];
            SendMessage(hwndToolbar, TB_ADDBUTTONS, (WPARAM)2, (LPARAM)lptb);
        }


        //Now set the window position
        ::SetWindowPos( hwndToolbar,
                        NULL,
                        rcToolbar.left,
                        rcToolbar.top,
                        rcToolbar.right - rcToolbar.left,
                        rcToolbar.bottom - rcToolbar.top,
                        SWP_NOACTIVATE | SWP_NOZORDER | SWP_SHOWWINDOW );

    
        return TRUE;
    }

    return FALSE;

}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::CreatePlaceBar
//
//  CreatePlaceBar member function.
//      creates and initializes the places bar  in the dialog
//
//
////////////////////////////////////////////////////////////////////////////
HWND CFileOpenBrowser::CreatePlacebar(HWND  hwndDlg)
{
   HWND hwndTB = GetDlgItem(hwndDlg, ctl1);
   if (hwndTB)
   {
        // Sets the size of the TBBUTTON structure.
        SendMessage(hwndTB, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);

        // Set the maximum  bitmap size.
        SendMessage(hwndTB, TB_SETBITMAPSIZE,
                   0, (LPARAM)MAKELONG(32,32));

        RECT rc;
        GetClientRect(hwndTB, &rc);
        SendMessage(hwndTB, TB_SETBUTTONWIDTH, 0, (LPARAM)MAKELONG(RECTWIDTH(rc), RECTWIDTH(rc)));

        //Set the color scheme for the toolbar so that button highlight
        // is correct
        COLORSCHEME cs;

        cs.dwSize = SIZEOF(cs);
        cs.clrBtnHighlight  = GetSysColor(COLOR_WINDOW);
        cs.clrBtnShadow     = GetSysColor(COLOR_BTNTEXT);
        SendMessage(hwndTB, TB_SETCOLORSCHEME, 0, (LPARAM) &cs);

        // Create, fill, and assign the image list for  buttons.
        HIMAGELIST himl = ImageList_Create(32,32,ILC_COLOR24,0,1);

        //Set the background color for the image list
        ImageList_SetBkColor(himl, GetSysColor(COLOR_BTNSHADOW));

        const int aPlaces[] =
        {
            CSIDL_RECENT,
            CSIDL_PERSONAL,
            CSIDL_DESKTOP,
            CSIDL_FAVORITES,
            CSIDL_NETWORK,
        };

        TBBUTTON atbPlacesButtons[] =
        {
            {0, IDC_RECENTFILES, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 0},
            {1, IDC_MYDOCUMENTS, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 1},
            {2, IDC_DESKTOP,     TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 2},
            {3, IDC_FAVORITES,   TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 3},
            {4, IDC_MYNETPLACES, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 4},
        };


        for (int i =0; i < ARRAYSIZE(aPlaces); i++)
        {
            LPITEMIDLIST pidl;
            HRESULT  hres;
            if (aPlaces[i] != CSIDL_PERSONAL)
            {

                hres = SHGetSpecialFolderLocation(NULL, aPlaces[i], &pidl);
            }
            else
            {
                IShellFolder *psf;

                //Special Case My Documents
                hres =  SHGetDesktopFolder(&psf);

                if (SUCCEEDED(hres))
                {
                    hres = psf->ParseDisplayName(NULL, 0, L"::{450D8FBA-AD25-11D0-98A8-0800361B1103}",
                                                        NULL, &pidl, NULL);
                    psf->Release();
                }

            }


            if (SUCCEEDED(hres))
            {
                SHFILEINFO sfi;
                SHGetFileInfo((LPCTSTR)pidl, 0, &sfi ,sizeof(sfi), SHGFI_ICON|SHGFI_LARGEICON |SHGFI_PIDL | SHGFI_DISPLAYNAME);
                //Add the image to the image list
                ImageList_AddIcon(himl, sfi.hIcon);

                DestroyIcon(sfi.hIcon);

                ILFree(pidl);

                //Add the button to the toolbar
                atbPlacesButtons[i].iString = (INT_PTR)&sfi.szDisplayName;
                SendMessage(hwndTB, TB_ADDBUTTONS, (UINT)1, (LPARAM)&atbPlacesButtons[i]);
            }
        }

        HIMAGELIST himlOld = (HIMAGELIST) SendMessage(hwndTB, TB_SETIMAGELIST, 0, (LPARAM)himl);
        if (himlOld)
            ImageList_Destroy(himlOld);

        // Add the buttons
        SendMessage(hwndTB, TB_AUTOSIZE, (WPARAM)0, (LPARAM)0);
   }

   return hwndTB;
}



////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::CFileOpenBrowser
//
//  CFileOpenBrowser constructor.
//  Minimal construction of the object.  Much more construction in
//  InitLocation.
//
////////////////////////////////////////////////////////////////////////////

CFileOpenBrowser::CFileOpenBrowser(
    HWND hDlg,
    BOOL fIsSaveAs)
    : cRef(1),
      iCurrentLocation(-1),
      iVersion(OPENFILEVERSION),
      pCurrentLocation(NULL),
      psv(NULL),
      hwndDlg(hDlg),
      hwndView(NULL),
      hwndToolbar(NULL),
      psfCurrent(NULL),
      bSave(fIsSaveAs),
      iComboIndex(-1),
      hwndTips(NULL),
      ptlog(NULL)
{
    iNodeDrives = NODE_DRIVES;

    szLastFilter[0] = CHAR_NULL;

    bEnableSizing = FALSE;
    bUseCombo     = TRUE;
    hwndGrip = NULL;
    ptLastSize.x = 0;
    ptLastSize.y = 0;
    sizeView.cx = 0;
    bUseSizeView = FALSE;
    bAppRedrawn = FALSE;

    HMENU hMenu;
    hMenu = GetSystemMenu(hDlg, FALSE);
    DeleteMenu(hMenu, SC_MINIMIZE, MF_BYCOMMAND);
    DeleteMenu(hMenu, SC_MAXIMIZE, MF_BYCOMMAND);
    DeleteMenu(hMenu, SC_RESTORE,  MF_BYCOMMAND);

    Shell_GetImageLists(NULL, &himl);

    //
    //  This setting could change on the fly, but I really don't care
    //  about that rare case.
    //
    SHELLSTATE ss;

    SHGetSetSettings(&ss, SSF_SHOWEXTENSIONS, FALSE);
    fShowExtensions = ss.fShowExtensions;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::~CFileOpenBrowser
//
//  CFileOpenBrowser destructor.
//
////////////////////////////////////////////////////////////////////////////

CFileOpenBrowser::~CFileOpenBrowser()
{
    if (uRegister)
    {
        SHChangeNotifyDeregister(uRegister);
        uRegister = 0;
    }

    //
    //  Ensure that we discard the tooltip window.
    //
    if (hwndTips)
    {
        DestroyWindow(hwndTips);
        hwndTips = NULL;                // handle is no longer valid
    }

    if (hwndGrip)
    {
        DestroyWindow(hwndGrip);
        hwndGrip = NULL;
    }


    //Free the image list set in the place bar
    if (hwndPlacebar)
    {
        HIMAGELIST himlOld;
        himlOld = (HIMAGELIST) SendMessage(hwndPlacebar, TB_SETIMAGELIST, 0, (LPARAM)0);

        if (himlOld)
        {
            ImageList_Destroy(himlOld);
        }
    }

    if (pcwd)
    {
        pcwd->Release();
    }

    if (ptlog)
    {
       ptlog->Release();
    }

}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::QueryInterface
//
//  Standard OLE2 style methods for this object.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CFileOpenBrowser::QueryInterface(
    REFIID riid,
    LPVOID *ppvObj)
{
    if (IsEqualIID(riid, IID_IShellBrowser) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IShellBrowser *)this;
        ++cRef;
        return (S_OK);
    }
    else if (IsEqualIID(riid, IID_ICommDlgBrowser))
    {
        *ppvObj = (ICommDlgBrowser2 *)this;
        ++cRef;
        return (S_OK);
    }
    else if (IsEqualIID(riid, IID_ICommDlgBrowser2))
    {
        *ppvObj = (ICommDlgBrowser2 *)this;
        ++cRef;
        return (S_OK);
    }
    *ppvObj = NULL;
    return (E_NOINTERFACE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::AddRef
//
////////////////////////////////////////////////////////////////////////////

ULONG STDMETHODCALLTYPE CFileOpenBrowser::AddRef()
{
    return (++cRef);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::Release
//
////////////////////////////////////////////////////////////////////////////

ULONG STDMETHODCALLTYPE CFileOpenBrowser::Release()
{
    cRef--;
    if (cRef > 0)
    {
        return (cRef);
    }

    delete this;

    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::GetWindow
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::GetWindow(
    HWND *phwnd)
{
    *phwnd = hwndDlg;
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::ContextSensitiveHelp
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::ContextSensitiveHelp(
    BOOL fEnable)
{
    //
    //  Shouldn't need in a common dialog.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SetStatusTextSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::SetStatusTextSB(
    LPCOLESTR pwch)
{
    //
    //  We don't have any status bar.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::EnableModelessSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::EnableModelessSB(
    BOOL fEnable)
{
    //
    //  We don't have any modeless window to be enabled/disabled.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::TranslateAcceleratorSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::TranslateAcceleratorSB(
    LPMSG pmsg,
    WORD wID)
{
    //
    //  We don't support EXE embedding.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::BrowseObject
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::BrowseObject(
    LPCITEMIDLIST pidl,
    UINT wFlags)
{
    //
    //  We don't support browsing, or more precisely, CDefView doesn't.
    //
    return (S_OK);
}




BOOL _IsRecentFolder(LPCITEMIDLIST pidl)
{
    ASSERT(pidl);
    BOOL fRet = FALSE;
    LPITEMIDLIST pidlRecent = SHCloneSpecialIDList(NULL, CSIDL_RECENT, TRUE);
    if (pidlRecent)
    {
        fRet = ILIsEqual(pidlRecent, pidl);
        ILFree(pidlRecent);
    }

    return fRet;
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::GetViewStateStream
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::GetViewStateStream(
    DWORD grfMode,
    LPSTREAM *pStrm)
{
    //
    //  ISSUE: We should implement this so there is some persistence
    //  for the file open dailog.
    //
    ASSERT(pCurrentLocation);
    ASSERT(pStrm);
    
    *pStrm = NULL;

    if ((grfMode == STGM_READ) && _IsRecentFolder(pCurrentLocation->pidlFull))
    {
        //  we want to open the stream from the registry...
        *pStrm = SHOpenRegStream(HKEY_LOCAL_MACHINE, TEXT("Software\\microsoft\\windows\\currentversion\\explorer\\recentdocs"), 
            TEXT("ViewStream"), grfMode);
    }
                
    return (*pStrm ? S_OK : E_FAIL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::GetControlWindow
//
//  Get the handles of the various windows in the File Cabinet.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::GetControlWindow(
    UINT id,
    HWND *lphwnd)
{
    if (id == FCW_TOOLBAR)
    {
        *lphwnd = hwndToolbar;
        return (S_OK);
    }

    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SendControlMsg
//
////////////////////////////////////////////////////////////////////////////

//
//  ISSUE:  Hard coding private id's from defview...
//
#define SFVIDM_VIEW_FIRST         (SFVIDM_FIRST      + 0x0028)
#define SFVIDM_VIEW_LIST          (SFVIDM_VIEW_FIRST + 0x0003)
#define SFVIDM_VIEW_DETAILS       (SFVIDM_VIEW_FIRST + 0x0004)
#define SFVIDM_VIEW_VIEWMENU      (SFVIDM_VIEW_FIRST + 0x0006)

STDMETHODIMP CFileOpenBrowser::SendControlMsg(
    UINT id,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *pret)
{
    LRESULT lres = 0;

    if (id == FCW_TOOLBAR)
    {
        //
        //  We need to translate messages from defview intended for these
        //  buttons to our own.
        //
        switch (uMsg)
        {
            case ( TB_CHECKBUTTON ) :
            {
#if 0 // we don't do this anymore because we use the viewmenu dropdown
                switch (wParam)
                {
                    case ( SFVIDM_VIEW_DETAILS ) :
                    {
                        wParam = IDC_VIEWDETAILS;
                        break;
                    }
                    case ( SFVIDM_VIEW_LIST ) :
                    {
                        wParam = IDC_VIEWLIST;
                        break;
                    }
                    default :
                    {
                        goto Bail;
                    }
                }
                break;
#endif
            }
            default :
            {
                goto Bail;
                break;
            }
        }

        lres = SendMessage(hwndToolbar, uMsg, wParam, lParam);
    }

Bail:
    if (pret)
    {
        *pret = lres;
    }

    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::QueryActiveShellView
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::QueryActiveShellView(
    LPSHELLVIEW *ppsv)
{
    if (psv)
    {
        *ppsv = psv;
        psv->AddRef();
        return (S_OK);
    }
    *ppsv = NULL;
    return (E_NOINTERFACE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnViewWindowActive
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::OnViewWindowActive(
    LPSHELLVIEW psv)
{
    //
    //  No need to process this. We don't do menus.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::InsertMenusSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::InsertMenusSB(
    HMENU hmenuShared,
    LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SetMenuSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::SetMenuSB(
    HMENU hmenuShared,
    HOLEMENU holemenu,
    HWND hwndActiveObject)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::RemoveMenusSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::RemoveMenusSB(
    HMENU hmenuShared)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SetToolbarItems
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::SetToolbarItems(
    LPTBBUTTON lpButtons,
    UINT nButtons,
    UINT uFlags)
{
    //
    //  We don't let containers customize our toolbar.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnDefaultCommand
//
//  Process a double-click or Enter keystroke in the view control.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::OnDefaultCommand(
    struct IShellView *ppshv)
{
    if (ppshv != psv)
    {
        return (E_INVALIDARG);
    }

    OnDblClick(FALSE);

    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SetCurrentFilter
//
////////////////////////////////////////////////////////////////////////////

#ifndef WINNT
#undef RtlMoveMemory
extern "C" void RtlMoveMemory(LPVOID, LPVOID, UINT);
#endif

void CFileOpenBrowser::SetCurrentFilter(
    LPCTSTR pszFilter,
    OKBUTTONFLAGS Flags)
{
    LPTSTR lpNext;

    //
    //  Don't do anything if it's the same filter.
    //
    if (lstrcmp(szLastFilter, pszFilter) == 0)
    {
        return;
    }

    lstrcpyn(szLastFilter, pszFilter, ARRAYSIZE(szLastFilter));
    int nLeft = ARRAYSIZE(szLastFilter) - lstrlen(szLastFilter) - 1;

    //
    //  Do nothing if quoted.
    //
    if (Flags & OKBUTTON_QUOTED)
    {
        return;
    }

    //
    //  If pszFilter matches a filter spec, select that spec.
    //
    HWND hCmb = GetDlgItem(hwndDlg, cmb1);
    if (hCmb)
    {
        int nMax = ComboBox_GetCount(hCmb);
        int n;

        BOOL bCustomFilter = lpOFN->lpstrCustomFilter && *lpOFN->lpstrCustomFilter;

        for (n = 0; n < nMax; n++)
        {
            LPTSTR pFilter = (LPTSTR)ComboBox_GetItemData(hCmb, n);
            if (pFilter && pFilter != (LPTSTR)CB_ERR)
            {
                if (!lstrcmpi(pFilter, pszFilter))
                {
                    if (n != ComboBox_GetCurSel(hCmb))
                    {
                        ComboBox_SetCurSel(hCmb, n);
                    }
                    break;
                }
            }
        }
    }

    //
    //  For LFNs, tack on a '*' after non-wild extensions.
    //
    for (lpNext = szLastFilter; nLeft > 0; )
    {
        LPTSTR lpSemiColon = StrChr(lpNext, CHAR_SEMICOLON);

        if (!lpSemiColon)
        {
            lpSemiColon = lpNext + lstrlen(lpNext);
        }

        TCHAR cTemp = *lpSemiColon;
        *lpSemiColon = CHAR_NULL;

        LPTSTR lpDot = StrChr(lpNext, CHAR_DOT);

        //
        //  See if there is an extension that is not wild.
        //
        if (lpDot && *(lpDot + 1) && !IsWild(lpDot))
        {
            //
            //  Tack on a star.
            //  We know there is still enough room because nLeft > 0.
            //
            if (cTemp != CHAR_NULL)
            {
                MoveMemory( lpSemiColon + 2,
                            lpSemiColon + 1,
                            lstrlen(lpSemiColon + 1) * sizeof(TCHAR) );
            }
            *lpSemiColon = CHAR_STAR;

            ++lpSemiColon;
            --nLeft;
        }

        *lpSemiColon = cTemp;
        if (cTemp == CHAR_NULL)
        {
            break;
        }
        else
        {
            lpNext = lpSemiColon + 1;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetFocusedChild
//
////////////////////////////////////////////////////////////////////////////

HWND GetFocusedChild(
    HWND hwndDlg,
    HWND hwndFocus)
{
    HWND hwndParent;

    if (!hwndDlg)
    {
        return (NULL);
    }

    if (!hwndFocus)
    {
        hwndFocus = ::GetFocus();
    }

    //
    //  Go up the parent chain until the parent is the main dialog.
    //
    while ((hwndParent = ::GetParent(hwndFocus)) != hwndDlg)
    {
        if (!hwndParent)
        {
            return (NULL);
        }

        hwndFocus = hwndParent;
    }

    return (hwndFocus);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SwitchView
//
//  Switch the view control to a new container.
//
////////////////////////////////////////////////////////////////////////////

HRESULT CFileOpenBrowser::SwitchView(
    IShellFolder *psfNew,
    LPCITEMIDLIST pidlNew,
    FOLDERSETTINGS *pfs)
{
    IShellView *psvNew;
    RECT rc;

    if (!psfNew)
    {
        return (E_INVALIDARG);
    }

    GetControlRect(hwndDlg, lst1, &rc);

    if (bEnableSizing)
    {
        if (hwndView)
        {
            //
            //  Don't directly use the rect but instead use the size as
            //  applications like VB may move the window off the screen.
            //
            RECT rcView;

            GetWindowRect(hwndView, &rcView);
            sizeView.cx = rcView.right - rcView.left;
            sizeView.cy = rcView.bottom - rcView.top;
            rc.right = rc.left + sizeView.cx;
            rc.bottom = rc.top + sizeView.cy;
        }
        else if (bUseSizeView && sizeView.cx)
        {
            //
            //  If we previously failed then use cached size.
            //
            rc.right = rc.left + sizeView.cx;
            rc.bottom = rc.top + sizeView.cy;
        }
    }

    HRESULT hres = psfNew->CreateViewObject( hwndDlg,
                                             IID_IShellView,
                                             (LPVOID *)&psvNew );

    if (!SUCCEEDED(hres))
    {
        return (hres);
    }

    IShellView *psvOld;
    HWND hwndNew;

    iWaitCount++;
    SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  The view window itself won't take the focus.  But we can set
    //  focus there and see if it bounces to the same place it is
    //  currently.  If that's the case, we want the new view window
    //  to get the focus;  otherwise, we put it back where it was.
    //
    BOOL bViewFocus = (GetFocusedChild(hwndDlg, NULL) == hwndView);

    psvOld = psv;

    //
    //  We attempt to blow off drawing on the main dialog.  Note that
    //  we should leave in SETREDRAW stuff to minimize flicker in case
    //  this fails.
    //

    BOOL bLocked = LockWindowUpdate(hwndDlg);

    //
    //  We need to kill the current psv before creating the new one in case
    //  the current one has a background thread going that is trying to
    //  call us back (IncludeObject).
    //
    if (psvOld)
    {
        SendMessage(hwndView, WM_SETREDRAW, FALSE, 0);
        psvOld->DestroyViewWindow();
        hwndView = NULL;
        psv = NULL;

        //
        //  Don't release yet.  We will pass this to CreateViewWindow().
        //
    }

    //
    //  At this point, there should be no background processing happening.
    //
    psfCurrent = psfNew;
    SHGetPathFromIDList(pidlNew, szCurDir);

    //
    //  New windows (like the view window about to be created) show up at
    //  the bottom of the Z order, so I need to disable drawing of the
    //  subdialog while creating the view window; drawing will be enabled
    //  after the Z-order has been set properly.
    //
    if (hSubDlg)
    {
        SendMessage(hSubDlg, WM_SETREDRAW, FALSE, 0);
    }

    //
    //  psv must be set before creating the view window since we
    //  validate it on the IncludeObject callback.
    //
    psv = psvNew;

    hres = psvNew->CreateViewWindow(psvOld, pfs, this, &rc, &hwndNew);

    bUseSizeView = FAILED(hres);

    if (psvOld)
    {
        psvOld->Release();
    }

    if (hSubDlg)
    {
        //
        //  Turn REDRAW back on before changing the focus in case the
        //  SubDlg has the focus.
        //
        SendMessage(hSubDlg, WM_SETREDRAW, TRUE, 0);
    }

    if (SUCCEEDED(hres))
    {
        BOOL bNewFolder;
        DWORD dwAttr = SFGAO_FILESYSTEM;

        hwndView = hwndNew;

        //Enable / Disable New Folder button
        CDGetAttributesOf(pidlNew, &dwAttr);

        if (dwAttr & SFGAO_FILESYSTEM)
        {
            bNewFolder = TRUE;
        }
        else
        {
            bNewFolder = FALSE;
        }

        ::SendMessage(hwndToolbar, TB_ENABLEBUTTON, IDC_NEWFOLDER,   bNewFolder);
    
        //
        //  Move the view window to the right spot in the Z (tab) order.
        //
        SetWindowPos( hwndNew,
                      GetDlgItem(hwndDlg, lst1),
                      0,
                      0,
                      0,
                      0,
                      SWP_NOMOVE | SWP_NOSIZE );


        //
        //  Give it the right window ID for WinHelp.
        //
        SetWindowLong(hwndNew, GWL_ID, lst2);

        ::RedrawWindow( hwndView,
                        NULL,
                        NULL,
                        RDW_INVALIDATE | RDW_ERASE |
                        RDW_ALLCHILDREN | RDW_UPDATENOW );

        if (bViewFocus)
        {
            ::SetFocus(hwndView);
        }
    }
    else
    {
        psv = NULL;
        psvNew->Release();
    }

    //
    //  Let's draw again!
    //

    if (bLocked)
    {
        LockWindowUpdate(NULL);
    }

    iWaitCount--;
    SetCursor(LoadCursor(NULL, IDC_ARROW));

    return (hres);
}


////////////////////////////////////////////////////////////////////////////
//
//  JustGetToolTipText
//
////////////////////////////////////////////////////////////////////////////

void JustGetToolTipText(
    UINT idCommand,
    LPTOOLTIPTEXT pTtt)
{
    if (!LoadString( ::g_hinst,
                     idCommand + MH_TOOLTIPBASE,
                     pTtt->szText,
                     ARRAYSIZE(pTtt->szText) ))
    {
        *pTtt->lpszText = 0;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnNotify
//
//  Process notify messages from the view -- for tooltips.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CFileOpenBrowser::OnNotify(
    LPNMHDR pnm)
{
    LRESULT lres = 0;

    switch (pnm->code)
    {
        case ( TTN_NEEDTEXT ) :
        {
            HWND hCtrl = GetDlgItem(hwndDlg, cmb2);
            LPTOOLTIPTEXT lptt = (LPTOOLTIPTEXT)pnm;
            int iTemp;

            //
            //  If this is the combo control which shows the current drive,
            //  then convert this into a suitable tool-tip message giving
            //  the 'full' path to this object.
            //
            if (pnm->idFrom == (UINT_PTR)hCtrl)
            {
                //
                //  iTemp will contain index of first path element.
                //
                GetDirectoryFromLB(szTipBuf, &iTemp);

                lptt->lpszText = szTipBuf;
                lptt->szText[0] = CHAR_NULL;
                lptt->hinst = NULL;              // no instance needed
            }
            else if (IsInRange(pnm->idFrom, FCIDM_SHVIEWFIRST, FCIDM_SHVIEWLAST))
            {
                if (hwndView)
                {
                    lres = ::SendMessage(hwndView, WM_NOTIFY, 0, (LPARAM)pnm);
                }
            }
            else
            {
                JustGetToolTipText((UINT) pnm->idFrom, lptt);
            }
            lres = TRUE;
            break;
        }
        case ( NM_STARTWAIT ) :
        case ( NM_ENDWAIT ) :
        {
            iWaitCount += (pnm->code == NM_STARTWAIT ? 1 : -1);

            //
            //  What we really want is for the user to simulate a mouse
            //  move/setcursor.
            //
            SetCursor(LoadCursor(NULL, iWaitCount ? IDC_WAIT : IDC_ARROW));
            break;
        }
        case ( TBN_DROPDOWN ) :
        {
            RECT r;
            VARIANT v = {VT_INT_PTR};
            TBNOTIFY *ptbn = (TBNOTIFY*)pnm;
            DFVCMDDATA cd;

        //  v.vt = VT_I4;
            v.byref = &r;

            SendMessage(hwndToolbar, TB_GETRECT, ptbn->iItem, (LPARAM)&r);
            MapWindowRect(hwndToolbar, HWND_DESKTOP, &r);

            cd.pva = &v;
            cd.hwnd = hwndToolbar;
            cd.nCmdIDTranslated = 0;
            SendMessage(hwndView, WM_COMMAND, SFVIDM_VIEW_VIEWMENU, (LONG_PTR)&cd);

            break;
        }

        case ( NM_CUSTOMDRAW ) :
        {
            LPNMTBCUSTOMDRAW lpcust = (LPNMTBCUSTOMDRAW)pnm;

            //Make sure its from places bar
            if (lpcust->nmcd.hdr.hwndFrom == hwndPlacebar )
            {
                switch (lpcust->nmcd.dwDrawStage)
                {
                    case  ( CDDS_PREERASE ) :
                    {
                        HDC hdc = (HDC)lpcust->nmcd.hdc;
                        RECT rc;
                        GetClientRect(hwndPlacebar, &rc);
                        SHFillRectClr(hdc, &rc, GetSysColor(COLOR_BTNSHADOW));
                        lres = CDRF_SKIPDEFAULT;
                        SetDlgMsgResult(hwndDlg, WM_NOTIFY, lres);
                        break;
                    }

                    case  ( CDDS_PREPAINT ) :
                    {
                        lres = CDRF_NOTIFYITEMDRAW;
                        SetDlgMsgResult(hwndDlg, WM_NOTIFY, lres);
                        break;
                    }

                    case ( CDDS_ITEMPREPAINT ) :
                    {
                        //Set the text color to window
                        lpcust->clrText    = GetSysColor(COLOR_WINDOW);
                        lpcust->clrBtnFace = GetSysColor(COLOR_BTNSHADOW);
                        lpcust->nStringBkMode = TRANSPARENT;
                        lres = CDRF_DODEFAULT;
                        SetDlgMsgResult(hwndDlg, WM_NOTIFY, lres);
                        break;
                    }

                }
            }
        }
    }

    return (lres);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetViewItemText
//
//  Get the display name of a shell object.
//
////////////////////////////////////////////////////////////////////////////

void GetViewItemText(
    IShellFolder *psf,
    LPCITEMIDLIST pidl,
    LPTSTR pBuf,
    UINT cchBuf,
    DWORD flags = SHGDN_INFOLDER | SHGDN_FORPARSING)
{
    STRRET sr;

    if (SUCCEEDED(psf->GetDisplayNameOf(pidl, flags, &sr)))
    {
        if (FAILED(StrRetToBuf(&sr, pidl, pBuf, cchBuf)))
        {
            *pBuf = CHAR_NULL;
        }
    }
    else
    {
        *pBuf = CHAR_NULL;
    }

}


////////////////////////////////////////////////////////////////////////////
//
//  GetListboxItem
//
//  Get a MYLISTBOXITEM object out of the location dropdown.
//
////////////////////////////////////////////////////////////////////////////

MYLISTBOXITEM *GetListboxItem(
    HWND hCtrl,
    WPARAM iItem)
{
    MYLISTBOXITEM *p = (MYLISTBOXITEM *)SendMessage( hCtrl,
                                                     CB_GETITEMDATA,
                                                     iItem,
                                                     NULL );
    if (p == (MYLISTBOXITEM *)CB_ERR)
    {
        return (NULL);
    }
    else
    {
        return (p);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  _ReleaseStgMedium
//
////////////////////////////////////////////////////////////////////////////

HRESULT _ReleaseStgMedium(
    LPSTGMEDIUM pmedium)
{
    if (pmedium->pUnkForRelease)
    {
        pmedium->pUnkForRelease->Release();
    }
    else
    {
        switch (pmedium->tymed)
        {
            case ( TYMED_HGLOBAL ) :
            {
                GlobalFree(pmedium->hGlobal);
                break;
            }
            default :
            {
                //
                //  Not fully implemented.
                //
                MessageBeep(0);
                break;
            }
        }
    }

    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SetSaveButton
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::SetSaveButton(
    UINT idSaveButton)
{
    PostMessage(hwndDlg, CDM_SETSAVEBUTTON, idSaveButton, 0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::RealSetSaveButton
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::RealSetSaveButton(
    UINT idSaveButton)
{
    MSG msg;

    if (PeekMessage( &msg,
                     hwndDlg,
                     CDM_SETSAVEBUTTON,
                     CDM_SETSAVEBUTTON,
                     PM_NOREMOVE ))
    {
        //
        //  There is another SETSAVEBUTTON message in the queue, so blow off
        //  this one.
        //
        return;
    }

    if (bSave)
    {
        TCHAR szTemp[40];
        LPTSTR pszTemp = tszDefSave;

        //
        //  Load the string if not the "Save" string or there is no
        //  app-specified default.
        //
        if ((idSaveButton != iszFileSaveButton) || !pszTemp)
        {
            LoadString(g_hinst, idSaveButton, szTemp, ARRAYSIZE(szTemp));
            pszTemp = szTemp;
        }

        GetDlgItemText(hwndDlg, IDOK, szBuf, ARRAYSIZE(szBuf));
        if (lstrcmp(szBuf, pszTemp))
        {
            //
            //  Avoid some flicker.
            //
            SetDlgItemText(hwndDlg, IDOK, pszTemp);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SetEditFile
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::SetEditFile(
    LPTSTR pszFile,
    BOOL bShowExt,
    BOOL bSaveNullExt)
{
    BOOL bHasHiddenExt = FALSE;

    //
    //  Save the whole file name.
    //
    if (!pszHideExt.StrCpy(pszFile))
    {
        pszHideExt.StrCpy(NULL);
        bShowExt = TRUE;
    }

    //
    //  ISSUE: This is bogus -- we only want to hide KNOWN extensions,
    //          not all extensions.
    //
    if (!bShowExt && !IsWild(pszFile))
    {
        LPTSTR pszExt = PathFindExtension(pszFile);
        if (*pszExt)
        {
            //
            //  If there was an extension, hide it.
            //
            *pszExt = 0;

            bHasHiddenExt = TRUE;
        }
    }

    if (bUseCombo)
    {
        HWND hwndEdit = (HWND)SendMessage(GetDlgItem(hwndDlg, cmb13), CBEM_GETEDITCONTROL, 0, 0L);
        SetWindowText(hwndEdit, pszFile);
    }
    else
    {
        SetDlgItemText(hwndDlg, edt1, pszFile);
    }

    //
    //  If the initial file name has no extension, we want to do our normal
    //  extension finding stuff.  Any other time we get a file with no
    //  extension, we should not do this.
    //
    bUseHideExt = (LPTSTR)pszHideExt
                      ? (bSaveNullExt ? TRUE : bHasHiddenExt)
                      : FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  FindEOF
//
////////////////////////////////////////////////////////////////////////////

LPTSTR FindEOF(
    LPTSTR pszFiles)
{
    BOOL bQuoted;
    LPTSTR pszBegin = pszFiles;

    while (*pszBegin == CHAR_SPACE)
    {
        ++pszBegin;
    }

    //
    //  Note that we always assume a quoted string, even if no quotes exist,
    //  so the only file delimiters are '"' and '\0'.  This allows somebody to
    //  type <Start Menu> or <My Document> in the edit control and the right
    //  thing happens.
    //
    bQuoted = TRUE;

    if (*pszBegin == CHAR_QUOTE)
    {
        ++pszBegin;
    }

    //Remove the quote from the file list if one exist
    lstrcpy(pszFiles, pszBegin);

    //
    //  Find the end of the filename (first quote or unquoted space).
    //
    for ( ; ; pszFiles = CharNext(pszFiles))
    {
        switch (*pszFiles)
        {
            case ( CHAR_NULL ) :
            {
                return (pszFiles);
            }
            case ( CHAR_SPACE ) :
            {
                if (!bQuoted)
                {
                    return (pszFiles);
                }
                break;
            }
            case ( CHAR_QUOTE ) :
            {
                //
                //  Note we only support '"' at the very beginning and very
                //  end of a file name.
                //
                return (pszFiles);
            }
            default :
            {
                break;
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ConvertToNULLTerm
//
////////////////////////////////////////////////////////////////////////////

DWORD ConvertToNULLTerm(
    LPTSTR pchRead)
{
    LPTSTR pchWrite = pchRead;
    DWORD cFiles = 0;

    //  The input string is of  the form "file1.ext" "file2.ext" ... "filen.ext"
    //  convert this string of this form into doubly null terminated string
    //  ie file1.ext\0file2.ext\0....filen.ext\0\0
    for ( ; ; )
    {
    	// Finds the end of the first file name in the list of
    	// remaining file names.Also this function removes the initial
    	// quote character
        LPTSTR pchEnd = FindEOF(pchRead);

        //
        //  Mark the end of the filename with a NULL.
        //
        if (*pchEnd)
        {
            *pchEnd = NULL;
            cFiles++;

            lstrcpy(pchWrite, pchRead);
            pchWrite += pchEnd - pchRead + 1;
        }
        else
        {
            //
            //  Found EOL.  Make sure we did not end with spaces.
            //
            if (*pchRead)
            {
                lstrcpy(pchWrite, pchRead);
                pchWrite += pchEnd - pchRead + 1;
                cFiles++;
            }

            break;
        }

        pchRead = pchEnd + 1;
    }

    //
    //  Double-NULL terminate.
    //
    *pchWrite = CHAR_NULL;

    return (cFiles);
}


////////////////////////////////////////////////////////////////////////////
//
//  SelFocusEnumCB
//
////////////////////////////////////////////////////////////////////////////

typedef struct _SELFOCUS
{
    BOOL    bSelChange;
    UINT    idSaveButton;
    int     nSel;
    TEMPSTR sHidden;
    TEMPSTR sDisplayed;
} SELFOCUS;

BOOL SelFocusEnumCB(
    CFileOpenBrowser *that,
    LPCITEMIDLIST pidl,
    LPARAM lParam)
{
    SELFOCUS *psf = (SELFOCUS *)lParam;

    //  if we USEMONIKERS then we only accept folders that can use monikers.
    DWORD dwAttrs = (that->lpOFN->Flags & OFN_USEMONIKERS) ? SFGAO_CANMONIKER | SFGAO_FOLDER:
        SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_FILESYSANCESTOR;

    TCHAR szBuf[MAX_PATH + 1];

    if (!pidl)
    {
        return (TRUE);
    }

    if (SUCCEEDED(that->psfCurrent->GetAttributesOf(1, &pidl, &dwAttrs)))
    {
        if (dwAttrs & SFGAO_FOLDER)
        {
            psf->idSaveButton = iszFileOpenButton;
        }
        else
        {
            if (psf->bSelChange && (((that->lpOFN->Flags & OFN_ENABLEINCLUDENOTIFY) &&
                                     (that->bSelIsObject =
                                      CD_SendIncludeItemNotify( that->hSubDlg,
                                                                that->hwndDlg,
                                                                that->psfCurrent,
                                                                pidl,
                                                                that->lpOFN,
                                                                that->lpOFI ))) ||
                                    (dwAttrs & (SFGAO_FILESYSTEM | SFGAO_CANMONIKER))))
            {
                ++psf->nSel;

                if (that->lpOFN->Flags & OFN_ALLOWMULTISELECT)
                {
                    //
                    //  Mark if this is an OBJECT we just selected.
                    //
                    if (that->bSelIsObject)
                    {
                        ITEMIDLIST idl;

                        idl.mkid.cb = 0;

                        //
                        //  Get full path to this folder.
                        //
                        GetViewItemText( that->psfCurrent,
                                         &idl,
                                         szBuf,
                                         ARRAYSIZE(szBuf),
                                         SHGDN_FORPARSING);
                        if (szBuf[0])
                        {
                            that->pszObjectCurDir.StrCpy(szBuf);
                        }

                        //
                        //  Get full path to this item (in case we only get one
                        //  selection).
                        //
                        GetViewItemText( that->psfCurrent,
                                         pidl,
                                         szBuf,
                                         ARRAYSIZE(szBuf),
                                         SHGDN_FORPARSING);
                        that->pszObjectPath.StrCpy(szBuf);
                    }

                    *szBuf = CHAR_QUOTE;
                    GetViewItemText( that->psfCurrent,
                                     pidl,
                                     szBuf + 1,
                                     ARRAYSIZE(szBuf) - 3 );
                    lstrcat(szBuf, TEXT("\" "));

                    if (!psf->sHidden.StrCat(szBuf))
                    {
                        psf->nSel = -1;
                        return (FALSE);
                    }

                    if (!that->fShowExtensions)
                    {
                        LPTSTR pszExt = PathFindExtension(szBuf + 1);
                        if (*pszExt)
                        {
                            *pszExt = 0;
                            lstrcat(szBuf, TEXT("\" "));
                        }
                    }

                    if (!psf->sDisplayed.StrCat(szBuf))
                    {
                        psf->nSel = -1;
                        return (FALSE);
                    }
                }
                else
                {
                    SHTCUTINFO  info;

                    info.dwAttr      = SFGAO_FOLDER | SFGAO_BROWSABLE;
                    info.fReSolve    = FALSE;
                    info.pszLinkFile = NULL;
                    info.cchFile     = 0;
                    info.ppidl        = NULL; 

                    if ( (that->GetLinkStatus(pidl,&info)) &&
                         ((info.dwAttr & (SFGAO_FOLDER | SFGAO_BROWSABLE)) == SFGAO_FOLDER))
                    {
                        // This means that the pidl is a link and the link points to a folder
                        // in this case  We Should not update the edit box and treat the link like 
                        // a directory
                       
                        
                        //Empty body
                    }
                    else
                    {

                        GetViewItemText(that->psfCurrent,pidl, szBuf, ARRAYSIZE(szBuf));
                        that->SetEditFile(szBuf, that->fShowExtensions);
                        if (that->bSelIsObject)
                        {
                            GetViewItemText( that->psfCurrent,
                                             pidl,
                                             szBuf,
                                             ARRAYSIZE(szBuf),
                                             SHGDN_FORPARSING);
                            that->pszObjectPath.StrCpy(szBuf);
                        }
                    }
                }
            }
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SelFocusChange
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::SelFocusChange(
    BOOL bSelChange)
{
    SELFOCUS sf;

    sf.bSelChange = bSelChange;
    sf.idSaveButton = iszFileSaveButton;
    sf.nSel = 0;

    bSelIsObject = FALSE;
    EnumItemObjects(SVGIO_SELECTION, SelFocusEnumCB, (LPARAM)&sf);

    if (lpOFN->Flags & OFN_ALLOWMULTISELECT)
    {
        switch (sf.nSel)
        {
            case ( -1 ) :
            {
                //
                //  Oops! We ran out of memory.
                //
                MessageBeep(0);
                return;
            }
            case ( 0 ) :
            {
                //
                //  No files selected; do not change edit control.
                //
                break;
            }
            case ( 1 ) :
            {
                //
                //  Strip off quotes so the single file case looks OK.
                //
                ConvertToNULLTerm(sf.sHidden);
                SetEditFile(sf.sHidden, fShowExtensions);

                sf.idSaveButton = iszFileSaveButton;
                break;
            }
            default :
            {
                SetEditFile(sf.sDisplayed, TRUE);
                pszHideExt.StrCpy(sf.sHidden);

                sf.idSaveButton = iszFileSaveButton;
                break;
            }
        }
    }

    SetSaveButton(sf.idSaveButton);
}


////////////////////////////////////////////////////////////////////////////
//
//  SelRenameCB
//
////////////////////////////////////////////////////////////////////////////

BOOL SelRenameCB(
    CFileOpenBrowser *that,
    LPCITEMIDLIST pidl,
    LPARAM lParam)
{
    DWORD dwAttrs = SFGAO_FOLDER;

    if (!pidl)
    {
        return (TRUE);
    }

    if (SUCCEEDED(that->psfCurrent->GetAttributesOf(1, &pidl, &dwAttrs)))
    {
        if (!(dwAttrs & SFGAO_FOLDER))
        {
            //
            //  If it is not a folder then set the selection to nothing
            //  so that whatever is in the edit box will be used.
            //
            that->psv->SelectItem(NULL, SVSI_DESELECTOTHERS);
        }
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SelRename
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::SelRename(void)
{
    EnumItemObjects(SVGIO_SELECTION, SelRenameCB, NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnStateChange
//
//  Process selection change in the view control.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::OnStateChange(
    struct IShellView *ppshv,
    ULONG uChange)
{
    if (ppshv != psv)
    {
        return (E_INVALIDARG);
    }

    switch (uChange)
    {
        case ( CDBOSC_SETFOCUS ) :
        {
            if (bSave)
            {
                SelFocusChange(FALSE);
            }
            break;
        }
        case ( CDBOSC_KILLFOCUS ) :
        {
            SetSaveButton(iszFileSaveButton);
            break;
        }
        case ( CDBOSC_SELCHANGE ) :
        {
            //
            //  Post one of these messages, since we seem to get a whole bunch
            //  of them.
            //
            if (!fSelChangedPending)
            {
                fSelChangedPending = TRUE;
                PostMessage(hwndDlg, CDM_SELCHANGE, 0, 0);
            }
            break;
        }
        case ( CDBOSC_RENAME ) :
        {
            SelRename();
            break;
        }
        default :
        {
            return (E_NOTIMPL);
        }
    }

    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::IncludeObject
//
//  Tell the view control which objects to include in its enumerations.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::IncludeObject(
    struct IShellView *ppshv,
    LPCITEMIDLIST pidl)
{
    if (ppshv != psv)
    {
        return (E_INVALIDARG);
    }

    DWORD dwAttrs = (lpOFN->Flags & OFN_USEMONIKERS) ? SFGAO_CANMONIKER | SFGAO_FOLDER:
        SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_FILESYSANCESTOR;

    BOOL bIncludeItem = FALSE;

    //
    //  See if the callback is enabled.
    //
    if (lpOFN->Flags & OFN_ENABLEINCLUDENOTIFY)
    {
        //
        //  See what the callback says.
        //
        bIncludeItem = BOOLFROMPTR(CD_SendIncludeItemNotify( hSubDlg,
                                                        hwndDlg,
                                                        psfCurrent,
                                                        pidl,
                                                        lpOFN,
                                                        lpOFI ));
    }

    if (!bIncludeItem &&
        SUCCEEDED(psfCurrent->GetAttributesOf(1, &pidl, &dwAttrs)))
    {
        if (!(dwAttrs & (SFGAO_FILESYSTEM | SFGAO_FILESYSANCESTOR | SFGAO_CANMONIKER)))
        {
            return (S_FALSE);
        }

        bIncludeItem = TRUE;
    }

    dwAttrs &= SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_FILESYSANCESTOR;
    if (bIncludeItem && *szLastFilter && (dwAttrs == SFGAO_FILESYSTEM))
    {
        GetViewItemText(psfCurrent, (LPITEMIDLIST)pidl, szBuf, ARRAYSIZE(szBuf));

        if (!LinkMatchSpec(pidl,szLastFilter) &&
            !PathMatchSpec(szBuf, szLastFilter))
        {
            return (S_FALSE);
        }
    }

    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::Notify
//
//  Notification to decide whether or not a printer should be selected.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::Notify(
    struct IShellView *ppshv,
    DWORD dwNotify)
{
    return S_FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::GetDefaultMenuText
//
//  Returns the default menu text.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::GetDefaultMenuText(
    struct IShellView *ppshv,
    WCHAR *pszText,
    INT cchMax)
{
    return S_FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::GetViewFlags
//
//  Returns Flags to customize the view .
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CFileOpenBrowser::GetViewFlags(DWORD *pdwFlags)
{
    DWORD dwFlags = 0;
    if (pdwFlags)
    {
        if (lpOFN->Flags & OFN_FORCESHOWHIDDEN)
        {
            dwFlags |= CDB2GVF_SHOWALLFILES;
        }
        
        *pdwFlags = dwFlags;
    }
    return S_OK;
}




////////////////////////////////////////////////////////////////////////////
//
//  InsertItem
//
//  Insert a single item into the location dropdown.
//
////////////////////////////////////////////////////////////////////////////

BOOL InsertItem(
    HWND hCtrl,
    int iItem,
    MYLISTBOXITEM *pItem,
    TCHAR *pszName)
{
    LPTSTR pszChar;

    for (pszChar = pszName; *pszChar != CHAR_NULL; pszChar = CharNext(pszChar))
    {
        if (pszChar - pszName >= MAX_DRIVELIST_STRING_LEN - 1)
        {
            *pszChar = CHAR_NULL;
            break;
        }
    }

    if (SendMessage( hCtrl,
                     CB_INSERTSTRING,
                     iItem,
                     (LPARAM)(LPCTSTR)pszName ) == CB_ERR)
    {
        return (FALSE);
    }

    SendMessage(hCtrl, CB_SETITEMDATA, iItem, (LPARAM)pItem);
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  LBItemCompareProc
//
////////////////////////////////////////////////////////////////////////////

int CALLBACK LBItemCompareProc(
    LPVOID p1,
    LPVOID p2,
    LPARAM lParam)
{
    IShellFolder *psfParent = (IShellFolder *)lParam;
    MYLISTBOXITEM *pItem1 = (MYLISTBOXITEM *)p1;
    MYLISTBOXITEM *pItem2 = (MYLISTBOXITEM *)p2;
    int iRes;

    //
    //  Put "My Documents" at the top of it's containing folder (the desktop).
    //
    if (ILIsEqual(pItem1->pidlThis, (LPCITEMIDLIST)&c_idlMyDocs))
    {
        if (ILIsEqual(pItem2->pidlThis, (LPCITEMIDLIST)&c_idlMyDocs))
        {
            iRes = 0;
        }
        else
        {
            iRes = -1;
        }
    }
    else if (ILIsEqual(pItem2->pidlThis, (LPCITEMIDLIST)&c_idlMyDocs))
    {
        iRes = 1;
    }
    else
    {
        //
        //  Do default sorting (by name).
        //
        HRESULT hres = psfParent->CompareIDs(0, pItem1->pidlThis, pItem2->pidlThis);
        iRes = (short)SCODE_CODE(GetScode(hres));
    }

    return (iRes);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::UpdateLevel
//
//  Insert the contents of a shell container into the location dropdown.
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::UpdateLevel(
    HWND hwndLB,
    int iInsert,
    MYLISTBOXITEM *pParentItem)
{
    if (!pParentItem)
    {
        return;
    }

    LPENUMIDLIST penum;
    HDPA hdpa;
    DWORD cIndent = pParentItem->cIndent + 1;
    IShellFolder *psfParent = pParentItem->GetShellFolder();

    hdpa = DPA_Create(4);
    if (!hdpa)
    {
        //
        //  No memory: Cannot enum this level.
        //
        return;
    }

    if (SUCCEEDED(psfParent->EnumObjects(hwndLB, SHCONTF_FOLDERS, &penum)))
    {
        ULONG celt;
        LPITEMIDLIST pidl;

        while (penum->Next(1, &pidl, &celt) == S_OK && celt == 1)
        {
            //
            //  Note: We need to avoid creation of pItem if this is not
            //  a file system object (or ancestor) to avoid extra
            //  bindings.
            //
            if (ShouldIncludeObject(this, psfParent, pidl, lpOFN->Flags))
            {
                MYLISTBOXITEM *pItem = new MYLISTBOXITEM();

                if (pItem != NULL)
                {
                    if ( pItem->Init(pParentItem,psfParent,pidl,cIndent,MLBI_PERMANENT | MLBI_PSFFROMPARENT )  &&
                         (DPA_AppendPtr(hdpa, pItem) >= 0 ))
                    {
                        //empty body
                    }
                    else
                    {
                        delete pItem;
                    }
                }
            }
            SHFree(pidl);

        }
        penum->Release();
    }

    DPA_Sort(hdpa, LBItemCompareProc, (LPARAM)psfParent);

    int nLBIndex, nDPAIndex, nDPAItems;
    BOOL bCurItemGone;

    nDPAItems = DPA_GetPtrCount(hdpa);
    nLBIndex = iInsert;

    bCurItemGone = FALSE;

    //
    //  Make sure the user is not playing with the selection right now.
    //
    ComboBox_ShowDropdown(hwndLB, FALSE);

    //
    //  We're all sorted, so now we can do a merge.
    //
    for (nDPAIndex = 0; ; ++nDPAIndex)
    {
        MYLISTBOXITEM *pNewItem;
        TCHAR szBuf[MAX_DRIVELIST_STRING_LEN];
        MYLISTBOXITEM *pOldItem;

        if (nDPAIndex < nDPAItems)
        {
            pNewItem = (MYLISTBOXITEM *)DPA_FastGetPtr(hdpa, nDPAIndex);
        }
        else
        {
            //
            //  Signal that we got to the end of the list.
            //
            pNewItem = NULL;
        }

        for (pOldItem = GetListboxItem(hwndLB, nLBIndex);
             pOldItem != NULL;
             pOldItem = GetListboxItem(hwndLB, ++nLBIndex))
        {
            int nCmp;

            if (pOldItem->cIndent < cIndent)
            {
                //
                //  We went up a level, so insert here.
                //
                break;
            }
            else if (pOldItem->cIndent > cIndent)
            {
                //
                //  We went down a level so ignore this.
                //
                continue;
            }

            //
            //  Set this to 1 at the end of the DPA to clear out deleted items
            //  at the end.
            //
            nCmp = !pNewItem
                       ? 1
                       : LBItemCompareProc( pNewItem,
                                            pOldItem,
                                            (LPARAM)psfParent );
            if (nCmp < 0)
            {
                //
                //  We found the first item greater than the new item, so
                //  add it in.
                //
                break;
            }
            else if (nCmp > 0)
            {
                //
                //  Oops! It looks like this item no longer exists, so
                //  delete it.
                //
                for ( ; ; )
                {
                    if (pOldItem == pCurrentLocation)
                    {
                        bCurItemGone = TRUE;
                        pCurrentLocation = NULL;
                    }

                    delete pOldItem;
                    SendMessage(hwndLB, CB_DELETESTRING, nLBIndex, NULL);

                    pOldItem = GetListboxItem(hwndLB, nLBIndex);

                    if (!pOldItem || pOldItem->cIndent <= cIndent)
                    {
                        break;
                    }
                }

                //
                //  We need to continue from the current position, not the
                //  next.
                //
                --nLBIndex;
            }
            else
            {
                //
                //  This item already exists, so no need to add it.
                //  Make sure we do not check this LB item again.
                //
                pOldItem->dwFlags |= MLBI_PERMANENT;
                ++nLBIndex;
                goto NotThisItem;
            }
        }

        if (!pNewItem)
        {
            //
            //  Got to the end of the list.
            //
            break;
        }

        GetViewItemText( psfParent,
                         pNewItem->pidlThis,
                         szBuf,
                         ARRAYSIZE(szBuf),
                         SHGDN_NORMAL);
        if (szBuf[0] && InsertItem(hwndLB, nLBIndex, pNewItem, szBuf))
        {
            ++nLBIndex;
        }
        else
        {
NotThisItem:
            delete pNewItem;
        }
    }

    DPA_Destroy(hdpa);

    if (bCurItemGone)
    {
        //
        //  If we deleted the current selection, go back to the desktop.
        //
        ComboBox_SetCurSel(hwndLB, 0);
        OnSelChange(-1, TRUE);
    }

    iCurrentLocation = ComboBox_GetCurSel(hwndLB);
}


////////////////////////////////////////////////////////////////////////////
//
//  ClearListbox
//
//  Clear the location dropdown and delete all entries.
//
////////////////////////////////////////////////////////////////////////////

void ClearListbox(
    HWND hwndList)
{
    SendMessage(hwndList, WM_SETREDRAW, FALSE, NULL);
    int cItems = (int) SendMessage(hwndList, CB_GETCOUNT, NULL, NULL);
    while (cItems--)
    {
        MYLISTBOXITEM *pItem = GetListboxItem(hwndList, 0);
        delete pItem;
        SendMessage(hwndList, CB_DELETESTRING, 0, NULL);
    }
    SendMessage(hwndList, WM_SETREDRAW, TRUE, NULL);
    InvalidateRect(hwndList, NULL, FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitFilterBox
//
//  Places the double null terminated list of filters in the combo box.
//
//  The list consists of pairs of null terminated strings, with an
//  additional null terminating the list.
//
////////////////////////////////////////////////////////////////////////////

DWORD InitFilterBox(
    HWND hDlg,
    LPCTSTR lpszFilter)
{
    DWORD nIndex = 0;
    UINT nLen;
    HWND hCmb = GetDlgItem(hDlg, cmb1);

    if (hCmb)
    {
        while (*lpszFilter)
        {
            //
            //  First string put in as string to show.
            //
            nIndex = ComboBox_AddString(hCmb, lpszFilter);

            nLen = lstrlen(lpszFilter) + 1;
            lpszFilter += nLen;

            //
            //  Second string put in as itemdata.
            //
            ComboBox_SetItemData(hCmb, nIndex, lpszFilter);

            //
            //  Advance to next element.
            //
            nLen = lstrlen(lpszFilter) + 1;
            lpszFilter += nLen;
        }
    }

    //
    //  ISSUE: nIndex could be CB_ERR.
    //
    return (nIndex);
}


////////////////////////////////////////////////////////////////////////////
//
//  MoveControls
//
////////////////////////////////////////////////////////////////////////////

void MoveControls(
    HWND hDlg,
    BOOL bBelow,
    int nStart,
    int nXMove,
    int nYMove)
{
    HWND hwnd;
    RECT rcWnd;

    if (nXMove == 0 && nYMove == 0)
    {
        //
        //  Quick out if nothing to do.
        //
        return;
    }

    for (hwnd = GetWindow(hDlg, GW_CHILD);
         hwnd;
         hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        GetWindowRect(hwnd, &rcWnd);
        MapWindowRect(HWND_DESKTOP, hDlg, &rcWnd);

        if (bBelow)
        {
            if (rcWnd.top < nStart)
            {
                continue;
            }
        }
        else
        {
            if (rcWnd.left < nStart)
            {
                continue;
            }
        }

        SetWindowPos( hwnd,
                      NULL,
                      rcWnd.left + nXMove,
                      rcWnd.top + nYMove,
                      0,
                      0,
                      SWP_NOZORDER | SWP_NOSIZE );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  DummyDlgProc
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK DummyDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}

/*
                  --------
                 | Cancel |
                  --------    --
                                |
                  --------      |
x Open As Read   | Help   |     |  Height by which all controls below view needs to be moved
                  --------      |  and also height by which View window height should be increased.
                              --

*/

void CFileOpenBrowser::ReAdjustDialog()
{
    int iDelta = 0;
    RECT rc1,rc2;
    

    //Make sure all our assumptions  are valid    
    if ((iVersion < OPENFILEVERSION_NT5) || //if this dialog version is less than NT5  or
        IsWindowEnabled(GetDlgItem(hwndDlg, chx1))  || // if Open As Read Only is still enabled or
        IsWindowEnabled(GetDlgItem(hwndDlg, pshHelp))) // If the Help button is still enabled  then
    {
        //Dont do anything
        return ;
    }

    GetWindowRect(GetDlgItem(hwndDlg, pshHelp), &rc1);
    GetWindowRect(GetDlgItem(hwndDlg, IDCANCEL), &rc2);

    //Add the height of the button
    iDelta +=  RECTHEIGHT(rc1);

    //Add the gap between buttons
    iDelta +=  rc1.top - rc2.bottom;

    RECT rcView;
    GetWindowRect(GetDlgItem(hwndDlg, lst1), &rcView);
    MapWindowRect(HWND_DESKTOP, hwndDlg, &rcView);

    HDWP hdwp;
    hdwp = BeginDeferWindowPos(10);

    HWND hwnd;
    RECT rc;

    hwnd = ::GetWindow(hwndDlg, GW_CHILD);
    
    while (hwnd && hdwp)
    {
        GetWindowRect(hwnd, &rc);
        MapWindowRect(HWND_DESKTOP, hwndDlg, &rc);

        switch (GetDlgCtrlID(hwnd))
        {
            case pshHelp:
            case chx1:
                break;

            default :
                //
                //  See if the control needs to be adjusted.
                //
                if (rc.top > rcView.bottom)
                {
                    //Move Y position of these controls
                    hdwp = DeferWindowPos( hdwp,
                                           hwnd,
                                           NULL,
                                           rc.left,
                                           rc.top + iDelta,
                                           RECTWIDTH(rc),
                                           RECTHEIGHT(rc),
                                           SWP_NOZORDER );
                }
        }
        hwnd = ::GetWindow(hwnd, GW_HWNDNEXT);
   }

    //Adjust the size of the view window
    if (hdwp)
    {
            hdwp = DeferWindowPos( hdwp,
                                   GetDlgItem(hwndDlg, lst1),
                                   NULL,
                                   rcView.left,
                                   rcView.top,
                                   RECTWIDTH(rcView),
                                   RECTHEIGHT(rcView) + iDelta,
                                   SWP_NOZORDER );

    }

    EndDeferWindowPos(hdwp);

}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::ResetDialogHeight
//
//  Hack for Borland JBuilder Professional (pah!)
//
//  These guys relied on a bug in Win95/NT4's Comdlg32 that we fixed in IE4.
//  So instead of reintroducing the bug, we detect that they are relying
//  on the bug and hack around them.
//
//  These guys do a SetWindowLong(GWL_STYLE) on the dialog box and
//  then reparent it!  Unfortunately, they didn't quite get their
//  bookkeeping right:  They forgot to do a RedrawWindow after removing
//  the WS_CAPTION style.  You see, just editing the style doesn't do
//  anything - the style changes don't take effect until the next
//  RedrawWindow.  When they scratched their heads ("Hey, why is
//  the caption still there?"), they decided to brute-force the
//  solution:  They slide the window so the caption goes "off the screen".
//
//  Problem:  We fixed a bug for IE4 where ResetDialogHeight would screw
//  up and not resize the dialog when it should've, if the app did a
//  SetWindowPos on the window to change its vertical position downward
//  by more than the amount we needed to grow.
//
//  So now when we resize it properly, this generates an internal
//  RedrawWindow, which means that Borland's brute-force hack tries
//  to fix a problem that no longer exists!
//
//  Therefore, ResetDialogHeight now checks if the app has
//
//      1. Changed the dialog window style,
//      2. Moved the dialog downward by more than we needed to grow,
//      3. Forgotten to call RedrawWindow.
//
//  If so, then we temporarily restore the original dialog window style,
//  do the (correct) resize, then restore the window style.  Reverting
//  the window style means that all the non-client stuff retains its old
//  (incorrect, but what the app is expecting) size.
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::ResetDialogHeight(
    HWND hDlg,
    HWND hwndExclude,
    HWND hwndGrip,
    int nCtlsBottom)
{
    POINT ptCurrent;
    int topNew;
    GetControlsArea(hDlg, hwndExclude, hwndGrip, &ptCurrent, &topNew);

    int nDiffBottom = nCtlsBottom - ptCurrent.y;

    if (nDiffBottom > 0)
    {
        RECT rcFull;
        int Height;

        GetWindowRect(hDlg, &rcFull);
        Height = RECTHEIGHT(rcFull) - nDiffBottom;
        if (Height >= ptCurrent.y)
        {
            // Borland JBuilder hack!  This SetWindowPos will generate
            // a RedrawWindow which the app might not be expecting.
            // Detect this case and create a set of temporary styles
            // which will neutralize the frame recalc implicit in the
            // RedrawWindow.
            //
            LONG lStylePrev;
            BOOL bBorlandHack = FALSE;
            if (!bAppRedrawn &&            // App didn't call RedrawWindow
                topOrig + nCtlsBottom <= topNew + ptCurrent.y) // Win95 didn't resize
            {
                // Since the app didn't call RedrawWindow, it still
                // thinks that there is a WS_CAPTION.  So put the caption
                // back while we do frame recalcs.
                bBorlandHack = TRUE;
                lStylePrev = GetWindowLong(hDlg, GWL_STYLE);
                SetWindowLong(hDlg, GWL_STYLE, lStylePrev | WS_CAPTION);
            }

            SetWindowPos( hDlg,
                          NULL,
                          0,
                          0,
                          RECTWIDTH(rcFull),
                          Height,
                          SWP_NOZORDER | SWP_NOMOVE );

            if (bBorlandHack)
            {
                // Restore the original style after we temporarily
                // messed with it.
                SetWindowLong(hDlg, GWL_STYLE, lStylePrev);
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::CreateHookDialog
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::CreateHookDialog(
    POINT *pPtSize)
{
    DWORD Flags = lpOFN->Flags;
    BOOL bRet = FALSE;
    HANDLE hTemplate;
    HINSTANCE hinst;
    LPCTSTR lpDlg;
    HWND hCtlCmn;
    RECT rcReal, rcSub, rcToolbar, rcAppToolbar;
    int nXMove, nXRoom, nYMove, nYRoom, nXStart, nYStart;
    DWORD dwStyle;
    DLGPROC lpfnHookProc;

    if (!(Flags & (OFN_ENABLEHOOK | OFN_ENABLETEMPLATE | OFN_ENABLETEMPLATEHANDLE)))
    {
        //
        //  No hook or template; nothing to do.
        //
        ResetDialogHeight(hwndDlg, NULL, hwndGrip, pPtSize->y);
        GetWindowRect(hwndDlg, &rcReal);
        ptLastSize.x = rcReal.right - rcReal.left;
        ptLastSize.y = rcReal.bottom - rcReal.top;
        return (TRUE);
    }

    if (Flags & OFN_ENABLETEMPLATEHANDLE)
    {
        hTemplate = lpOFN->hInstance;
        hinst = ::g_hinst;
    }
    else
    {
        if (Flags & OFN_ENABLETEMPLATE)
        {
            if (!lpOFN->lpTemplateName)
            {
                StoreExtendedError(CDERR_NOTEMPLATE);
                return (FALSE);
            }
            if (!lpOFN->hInstance)
            {
                StoreExtendedError(CDERR_NOHINSTANCE);
                return (FALSE);
            }

            lpDlg = lpOFN->lpTemplateName;
            hinst = lpOFN->hInstance;
        }
        else
        {
            hinst = ::g_hinst;
            lpDlg = MAKEINTRESOURCE(DUMMYFILEOPENORD);
        }

        HRSRC hRes = FindResource(hinst, lpDlg, RT_DIALOG);
        if (hRes == NULL)
        {
            StoreExtendedError(CDERR_FINDRESFAILURE);
            return (FALSE);
        }
        if ((hTemplate = LoadResource(hinst, hRes)) == NULL)
        {
            StoreExtendedError(CDERR_LOADRESFAILURE);
            return (FALSE);
        }
    }

    if (!LockResource(hTemplate))
    {
        StoreExtendedError(CDERR_LOADRESFAILURE);
        return (FALSE);
    }

    dwStyle = ((LPDLGTEMPLATE)hTemplate)->style;
    if (!(dwStyle & WS_CHILD))
    {
        //
        //  I don't want to go poking in their template, and I don't want to
        //  make a copy, so I will just fail.  This also helps us weed out
        //  "old-style" templates that were accidentally used.
        //
        StoreExtendedError(CDERR_DIALOGFAILURE);
        return (FALSE);
    }

    if (Flags & OFN_ENABLEHOOK)
    {
        lpfnHookProc = (DLGPROC)GETHOOKFN(lpOFN);
    }
    else
    {
        lpfnHookProc = DummyDlgProc;
    }

    //
    //  WOW apps are not allowed to get the new explorer look, so there
    //  is no need to do any special WOW checking before calling the create
    //  dialog function.
    //

#ifdef UNICODE
    if (lpOFI->ApiType == COMDLG_ANSI)
    {
        ThunkOpenFileNameW2A(lpOFI);
        hSubDlg = CreateDialogIndirectParamA( hinst,
                                              (LPDLGTEMPLATE)hTemplate,
                                              hwndDlg,
                                              lpfnHookProc,
                                              (LPARAM)(lpOFI->pOFNA) );
        ThunkOpenFileNameA2W(lpOFI);
    }
    else
#endif
    {
        hSubDlg = CreateDialogIndirectParam( hinst,
                                             (LPDLGTEMPLATE)hTemplate,
                                             hwndDlg,
                                             lpfnHookProc,
                                             (LPARAM)lpOFN );
    }

    if (!hSubDlg)
    {
        StoreExtendedError(CDERR_DIALOGFAILURE);
        return (FALSE);
    }

    //
    //  We reset the height of the dialog after creating the hook dialog so
    //  the hook can hide controls in its WM_INITDIALOG message.
    //
    ResetDialogHeight(hwndDlg, hSubDlg, hwndGrip, pPtSize->y);

    //
    //  Now move all of the controls around.
    //
    GetClientRect(hwndDlg, &rcReal);
    GetClientRect(hSubDlg, &rcSub);

    hCtlCmn = GetDlgItem(hSubDlg, stc32);
    if (hCtlCmn)
    {
        RECT rcCmn;

        GetWindowRect(hCtlCmn, &rcCmn);
        MapWindowRect(HWND_DESKTOP, hSubDlg, &rcCmn);


        //
        //  Move the controls in our dialog to make room for the hook's
        //  controls above and to the left.
        //
        MoveControls(hwndDlg, FALSE, 0, rcCmn.left, rcCmn.top);

        //
        //  Calculate how far sub dialog controls need to move, and how much
        //  more room our dialog needs.
        //
        nXStart = rcCmn.right;
        nYStart = rcCmn.bottom;

        //See how far part the cotrols are in the template
        nXMove = (rcReal.right - rcReal.left) - (rcCmn.right - rcCmn.left);
        nYMove = (rcReal.bottom - rcReal.top) - (rcCmn.bottom - rcCmn.top);

        //See how much room we need to leave at the bottom and right
        // for the sub dialog controls at the botton and right
        nXRoom = rcSub.right - (rcCmn.right - rcCmn.left);
        nYRoom = rcSub.bottom - (rcCmn.bottom - rcCmn.top);

        if (nXMove < 0)
        {
            //
            //  If the template size is too big, we need more room in the
            //  dialog.
            //
            nXRoom -= nXMove;
            nXMove = 0;
        }
        if (nYMove < 0)
        {
            //
            //  If the template size is too big, we need more room in the
            //  dialog.
            //
            nYRoom -= nYMove;
            nYMove = 0;
        }

        //
        //  Resize the "template" control so the hook knows the size of our
        //  stuff.
        //
        SetWindowPos( hCtlCmn,
                      NULL,
                      0,
                      0,
                      rcReal.right - rcReal.left,
                      rcReal.bottom - rcReal.top,
                      SWP_NOMOVE | SWP_NOZORDER );
    }
    else
    {
        //
        //  Extra controls go on the bottom by default.
        //
        nXStart = nYStart = nXMove = nXRoom = 0;

        nYMove = rcReal.bottom;
        nYRoom = rcSub.bottom;
    }

    MoveControls(hSubDlg, FALSE, nXStart, nXMove, 0);
    MoveControls(hSubDlg, TRUE, nYStart, 0, nYMove);

    //
    //  Resize our dialog and the sub dialog.
    //  ISSUE: We need to check whether part of the dialog is off screen.
    //
    GetWindowRect(hwndDlg, &rcReal);

    ptLastSize.x = (rcReal.right - rcReal.left) + nXRoom;
    ptLastSize.y = (rcReal.bottom - rcReal.top) + nYRoom;

    SetWindowPos( hwndDlg,
                  NULL,
                  0,
                  0,
                  ptLastSize.x,
                  ptLastSize.y,
                  SWP_NOZORDER | SWP_NOMOVE );

    //
    //  Note that we are moving this to (0,0) and the bottom of the Z order.
    //
    GetWindowRect(hSubDlg, &rcReal);
    SetWindowPos( hSubDlg,
                  HWND_BOTTOM,
                  0,
                  0,
                  (rcReal.right - rcReal.left) + nXMove,
                  (rcReal.bottom - rcReal.top) + nYMove,
                  0 );

    ShowWindow(hSubDlg, SW_SHOW);

    CD_SendInitDoneNotify(hSubDlg, hwndDlg, lpOFN, lpOFI);

    //
    //  Make sure the toolbar is still large enough.  Apps like Visio move
    //  the toolbar control and may make it too small now that we added the
    //  View Desktop toolbar button.
    //
    if (hwndToolbar && IsVisible(hwndToolbar))
    {
        LONG Width;

        //
        //  Get the default toolbar coordinates.
        //
        GetControlRect(hwndDlg, stc1, &rcToolbar);

        //
        //  Get the app adjusted toolbar coordinates.
        //
        GetWindowRect(hwndToolbar, &rcAppToolbar);
        MapWindowRect(HWND_DESKTOP, hwndDlg, &rcAppToolbar);

        //
        //  See if the default toolbar size is greater than the current
        //  toolbar size.
        //
        Width = rcToolbar.right - rcToolbar.left;
        if (Width > (rcAppToolbar.right - rcAppToolbar.left))
        {
            //
            //  Set rcToolbar to be the new toolbar rectangle.
            //
            rcToolbar.left   = rcAppToolbar.left;
            rcToolbar.top    = rcAppToolbar.top;
            rcToolbar.right  = rcAppToolbar.left + Width;
            rcToolbar.bottom = rcAppToolbar.bottom;

            //
            //  Get the dialog coordinates.
            //
            GetWindowRect(hwndDlg, &rcReal);
            MapWindowRect(HWND_DESKTOP, hwndDlg, &rcReal);

            //
            //  Make sure the new toolbar doesn't go off the end of
            //  the dialog.
            //
            if (rcToolbar.right < rcReal.right)
            {
                //
                //  Make sure there are no controls to the right of the
                //  toolbar that overlap the new toolbar.
                //
                for (hCtlCmn = ::GetWindow(hwndDlg, GW_CHILD);
                     hCtlCmn;
                     hCtlCmn = ::GetWindow(hCtlCmn, GW_HWNDNEXT))
                {
                    if ((hCtlCmn != hwndToolbar) && IsVisible(hCtlCmn))
                    {
                        RECT rcTemp;

                        //
                        //  Get the coordinates of the window.
                        //
                        GetWindowRect(hCtlCmn, &rcSub);
                        MapWindowRect(HWND_DESKTOP, hwndDlg, &rcSub);

                        //
                        //  If the App's toolbar rectangle does not
                        //  intersect the window and the the new toolbar
                        //  does intersect the window, then we cannot
                        //  increase the size of the toolbar.
                        //
                        if (!IntersectRect(&rcTemp, &rcAppToolbar, &rcSub) &&
                            IntersectRect(&rcTemp, &rcToolbar, &rcSub))
                        {
                            break;
                        }
                    }
                }

                //
                //  Reset the size of the toolbar if there were no conflicts.
                //
                if (!hCtlCmn)
                {
                    ::SetWindowPos( hwndToolbar,
                                    NULL,
                                    rcToolbar.left,
                                    rcToolbar.top,
                                    Width,
                                    rcToolbar.bottom - rcToolbar.top,
                                    SWP_NOACTIVATE | SWP_NOZORDER |
                                      SWP_SHOWWINDOW );
                }
            }
        }
    }

    bRet = TRUE;

    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitSaveAsControls
//
//  Change the captions of a bunch of controls to say saveas-like things.
//
////////////////////////////////////////////////////////////////////////////

const struct
{
    UINT idControl;
    UINT idString;
} aSaveAsControls[] =
{
    { (UINT)-1, iszFileSaveTitle },         // -1 means the dialog itself
    { stc2,     iszSaveAsType },
    { IDOK,     iszFileSaveButton },
    { stc4,     iszFileSaveIn }
};

void InitSaveAsControls(
    HWND hDlg)
{
    for (UINT iControl = 0; iControl < ARRAYSIZE(aSaveAsControls); iControl++)
    {
        HWND hwnd = hDlg;
        TCHAR szText[80];

        if (aSaveAsControls[iControl].idControl != -1)
        {
            hwnd = GetDlgItem(hDlg, aSaveAsControls[iControl].idControl);
        }

        LoadString( g_hinst,
                    aSaveAsControls[iControl].idString,
                    szText,
                    ARRAYSIZE(szText) );
        SetWindowText(hwnd, szText);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetControlsArea
//
//  Returns the leftmost edge and bottom-most edge of the
//  controls farthest right and down (in screen coordinates).
//
////////////////////////////////////////////////////////////////////////////

void
GetControlsArea(
    HWND hDlg,
    HWND hwndExclude,
    HWND hwndGrip,
    POINT *pPtSize,
    LPINT pTop)
{
    RECT rc;
    HWND hwnd;
    int uBottom;
    int uRight;

    uBottom = 0x80000000;
    uRight  = 0x80000000;

    for (hwnd = GetWindow(hDlg, GW_CHILD);
         hwnd;
         hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        //
        //  Note we cannot use IsWindowVisible, since the parent is not visible.
        //  We do not want the magic static to be included.
        //
        if (!IsVisible(hwnd) || (hwnd == hwndExclude) || (hwnd == hwndGrip))
        {
            continue;
        }

        GetWindowRect(hwnd, &rc);
        if (uRight < rc.right)
        {
            uRight = rc.right;
        }
        if (uBottom < rc.bottom)
        {
            uBottom = rc.bottom;
        }
    }

    GetWindowRect(hDlg, &rc);

    pPtSize->x = uRight - rc.left;
    pPtSize->y = uBottom - rc.top;

    if (pTop)
        *pTop = rc.top;
}


////////////////////////////////////////////////////////////////////////////
//
//  InitLocation
//
//  Main initialization (WM_INITDIALOG phase).
//
////////////////////////////////////////////////////////////////////////////

BOOL InitLocation(
    HWND hDlg,
    LPOFNINITINFO poii)
{
    HWND hCtrl = GetDlgItem(hDlg, cmb2);
    LPOPENFILENAME lpOFN = poii->lpOFI->pOFN;
    BOOL fIsSaveAs = poii->bSave;
    POINT ptSize;

    GetControlsArea(hDlg, NULL, NULL, &ptSize, NULL);

    CFileOpenBrowser *pDlgStruct = new CFileOpenBrowser(hDlg, FALSE);
    if (pDlgStruct == NULL)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }
    StoreBrowser(hDlg, pDlgStruct);

    // Create Place bar only if we are using new template.
    if ( (poii->lpOFI->iVersion < OPENFILEVERSION_NT5) &&
         (poii->lpOFI->pOFN->Flags & (OFN_ENABLEHOOK | OFN_ENABLETEMPLATE | OFN_ENABLETEMPLATEHANDLE)))
    {
        pDlgStruct->iVersion = OPENFILEVERSION_NT4;
    }
 
    
    if (pDlgStruct->iVersion >= OPENFILEVERSION_NT5 )
    {
        pDlgStruct->hwndPlacebar = pDlgStruct->CreatePlacebar(pDlgStruct->hwndDlg);
        pDlgStruct->EnableFileMRU(!IsRestricted(REST_NOFILEMRU));
    }
    else
    {
        pDlgStruct->hwndPlacebar = NULL;
        pDlgStruct->EnableFileMRU(FALSE);
    }

    pDlgStruct->CreateToolbar();

    GetControlsArea(hDlg, NULL, NULL, &ptSize, &pDlgStruct->topOrig);

    //
    //  Now that pDlgStruct is stored in the hDlg, it will get freed on the
    //  WM_DESTROY.
    //

    IShellFolder *psfRoot;
    if (FAILED(SHCoCreateInstance( NULL,
                                   &CLSID_ShellDesktop,
                                   NULL,
                                   IID_IShellFolder,
                                   (LPVOID *)&psfRoot)))
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    LPITEMIDLIST pidlRoot = SHCloneSpecialIDList(hDlg, CSIDL_DESKTOP, FALSE);
    if (!pidlRoot)
    {
        psfRoot->Release();
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    //
    //  Add the desktop item itself.
    //
    MYLISTBOXITEM *pRootItem = new MYLISTBOXITEM();
        
        
    if (pRootItem)
    {
         if (!pRootItem->Init( NULL,
                               psfRoot,
                               pidlRoot,
                               0,
                               MLBI_PERMANENT ))
         {
             delete pRootItem;
             pRootItem = NULL;
         }
    }


    SHFree(pidlRoot);

    if (pRootItem == NULL)
    {
        psfRoot->Release();
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    //
    //  Now that psfRoot is stored in the pRootItem, it will get freed on the
    //  delete.
    //

    TCHAR szScratch[MAX_PATH + 1];

    GetViewItemText(psfRoot, NULL, szScratch, ARRAYSIZE(szScratch));
    if (!InsertItem(hCtrl, 0, pRootItem, szScratch))
    {
        delete pRootItem;
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    //
    //  Now that pRootItem is stored in the combo, it will get freed on the
    //  WM_DESTROY.
    //


    pDlgStruct->pCurrentLocation = pRootItem;
    pDlgStruct->lpOFN = lpOFN;
    pDlgStruct->bSave = fIsSaveAs;

    pDlgStruct->lpOFI = poii->lpOFI;

    pDlgStruct->pszDefExt.StrCpy(lpOFN->lpstrDefExt);

    //
    //  Here follows all the caller-parameter-based initialization.
    //
    ::lpOKProc = (WNDPROC)::SetWindowLongPtr( ::GetDlgItem(hDlg, IDOK),
                                           GWLP_WNDPROC,
                                           (LONG_PTR)OKSubclass );

    if (lpOFN->Flags & OFN_CREATEPROMPT)
    {
        lpOFN->Flags |= (OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST);
    }
    else if (lpOFN->Flags & OFN_FILEMUSTEXIST)
    {
        lpOFN->Flags |= OFN_PATHMUSTEXIST;
    }

#ifdef UNICODE
    //
    //  We need to make sure the Ansi flags are up to date.
    //
    if (poii->lpOFI->ApiType == COMDLG_ANSI)
    {
        poii->lpOFI->pOFNA->Flags = lpOFN->Flags;
    }
#endif

    //
    //  Limit the text to the maximum path length instead of limiting it to
    //  the buffer length.  This allows users to type ..\..\.. and move
    //  around when the app gives an extremely small buffer.
    //
    if (pDlgStruct->bUseCombo)
    {
        SendDlgItemMessage(hDlg, cmb13, CB_LIMITTEXT, MAX_PATH -1, 0);
    }
    else
    {
        SendDlgItemMessage(hDlg, edt1, EM_LIMITTEXT, MAX_PATH - 1, 0);
    }

    SendDlgItemMessage(hDlg, cmb2, CB_SETEXTENDEDUI, 1, 0);
    SendDlgItemMessage(hDlg, cmb1, CB_SETEXTENDEDUI, 1, 0);

    //
    //  Save original directory for later restoration, if necessary.
    //
    pDlgStruct->szStartDir[0] = TEXT('\0');
    GetCurrentDirectory( ARRAYSIZE(pDlgStruct->szStartDir),
                         pDlgStruct->szStartDir );

    //
    //  Initialize all provided filters.
    //
    if (lpOFN->lpstrCustomFilter && *lpOFN->lpstrCustomFilter)
    {
        SendDlgItemMessage( hDlg,
                            cmb1,
                            CB_INSERTSTRING,
                            0,
                            (LONG_PTR)lpOFN->lpstrCustomFilter );
        SendDlgItemMessage( hDlg,
                            cmb1,
                            CB_SETITEMDATA,
                            0,
                            (LPARAM)(lpOFN->lpstrCustomFilter +
                                     lstrlen(lpOFN->lpstrCustomFilter) + 1) );
        SendDlgItemMessage( hDlg,
                            cmb1,
                            CB_LIMITTEXT,
                            (WPARAM)(lpOFN->nMaxCustFilter),
                            0L );
    }
    else
    {
        //
        //  Given no custom filter, the index will be off by one.
        //
        if (lpOFN->nFilterIndex != 0)
        {
            lpOFN->nFilterIndex--;
        }
    }

    //
    //  Listed filters next.
    //
    if (lpOFN->lpstrFilter)
    {
        if (lpOFN->nFilterIndex > InitFilterBox(hDlg, lpOFN->lpstrFilter))
        {
            lpOFN->nFilterIndex = 0;
        }
    }
    else
    {
        lpOFN->nFilterIndex = 0;
    }

    //
    //  If an entry exists, select the one indicated by nFilterIndex.
    //
    if ((lpOFN->lpstrFilter) ||
        (lpOFN->lpstrCustomFilter && *lpOFN->lpstrCustomFilter))
    {
        HWND hCmb1 = GetDlgItem(hDlg, cmb1);

        ComboBox_SetCurSel(hCmb1, lpOFN->nFilterIndex);

        pDlgStruct->RefreshFilter(hCmb1);
    }

    //Check if this Object Open Dialog
    if (lpOFN->Flags & OFN_ENABLEINCLUDENOTIFY)
    {
        //Yes, change the text so that it looks like a object open
        TCHAR szTemp[256];

        //Change the File &Name:  to Object &Name:
        LoadString((HINSTANCE)g_hinst, iszObjectName, (LPTSTR)szTemp, sizeof(szTemp));
        SetWindowText(GetDlgItem(hDlg, stc3), szTemp);

        //Change the Files of &type:  to  Objects of &type:
        LoadString((HINSTANCE)g_hinst, iszObjectType, (LPTSTR)szTemp, sizeof(szTemp));
        SetWindowText(GetDlgItem(hDlg, stc2), szTemp);

    }


    //
    //  Make sure to do this before checking if there is a title specified.
    //
    if (fIsSaveAs)
    {
        //
        //  Note we can do this even if there is a hook/template.
        //
        InitSaveAsControls(hDlg);

        // In Save As Dialog there is no need for Open As Read Only. 
        HideControl(hDlg, chx1);
    }

    if (lpOFN->lpstrTitle && *lpOFN->lpstrTitle)
    {
        SetWindowText(hDlg, lpOFN->lpstrTitle);
    }

    // BOOL Variables to check whether both the Hide Read only and Help button 
    // are being hidden. if so we need to readjust the dialog to reclaim the space 
    // occupied by these two controls
    BOOL  fNoReadOnly = FALSE;
    BOOL  fNoHelp = FALSE;

    if (lpOFN->Flags & OFN_HIDEREADONLY)
    {
        HideControl(hDlg, chx1);
        fNoReadOnly = TRUE;
    }
    else
    {
        CheckDlgButton(hDlg, chx1, (lpOFN->Flags & OFN_READONLY) ? 1 : 0);        
    }

    if (!(lpOFN->Flags & OFN_SHOWHELP))
    {
        HideControl(hDlg, pshHelp);
        fNoHelp = TRUE;
    }

    if (fNoReadOnly && fNoHelp)
    {
        //Readjust the dialog to reclaim space occupied by the Open as Read Only and Help Button controls
        pDlgStruct->ReAdjustDialog();
    }
    RECT rc;

    ::GetClientRect(hDlg, &rc);

    //
    //  If sizing is enabled, then we need to create the sizing grip.
    //
    if (pDlgStruct->bEnableSizing = poii->bEnableSizing)
    {
        pDlgStruct->hwndGrip =
            CreateWindow( TEXT("Scrollbar"),
                          NULL,
                          WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS | WS_GROUP |
                            WS_CLIPCHILDREN | SBS_BOTTOMALIGN | SBS_SIZEGRIP |
                            SBS_SIZEBOXBOTTOMRIGHTALIGN,
                          rc.right - g_cxGrip,
                          rc.bottom - g_cyGrip,
                          g_cxGrip,
                          g_cyGrip,
                          hDlg,
                          (HMENU)-1,
                          g_hinst,
                          NULL );
    }

    if (!pDlgStruct->CreateHookDialog(&ptSize))
    {
        return (FALSE);
    }


    GetWindowRect(pDlgStruct->hwndDlg, &rc);
    pDlgStruct->ptMinTrack.x = rc.right - rc.left;
    pDlgStruct->ptMinTrack.y = rc.bottom - rc.top;

    if (pDlgStruct->bUseCombo)
    {
        HWND hwndComboBox = GetDlgItem(hDlg, cmb13);
        if (hwndComboBox)
        {
            HWND hwndEdit = (HWND)SendMessage(hwndComboBox, CBEM_GETEDITCONTROL, 0, 0L);
            AutoComplete(hwndEdit, &(pDlgStruct->pcwd), 0);

            //
            //  Explicitly set the focus since this is no longer the first item
            //  in the dialog template and it will start AutoComplete.
            //
            SetFocus(hwndComboBox);
        }

    }
    else
    {
        HWND hwndEdit = GetDlgItem(hDlg, edt1);
        if (hwndEdit)
        {
            AutoComplete(hwndEdit, &(pDlgStruct->pcwd), 0);

            //
            //  Explicitly set the focus since this is no longer the first item
            //  in the dialog template and it will start AutoComplete.
            //
            SetFocus(hwndEdit);
        }
    }

    // Before jumping to a particular directory, Create the travel log
    Create_TravelLog(&pDlgStruct->ptlog);


    //
    //  Check out if the filename contains a path.  If so, override whatever
    //  is contained in lpstrInitialDir.  Chop off the path and put up only
    //  the filename.
    //
    LPCTSTR lpstrInitialDir = lpOFN->lpstrInitialDir;
    LPTSTR lpInitialText = lpOFN->lpstrFile;

    if (lpInitialText && *lpInitialText)
    {
        if ( DBL_BSLASH(lpInitialText + 2) &&
             (*(lpInitialText + 1) == CHAR_COLON) )
        {
            lstrcpy(lpInitialText, lpInitialText + 2);
        }

        int nFileOffset;

        lstrcpyn(szScratch, lpInitialText, ARRAYSIZE(szScratch));

        nFileOffset = ParseFileNew(szScratch, NULL, FALSE, TRUE);

        //
        //  Is the filename invalid?
        //
        if ( !(lpOFN->Flags & OFN_NOVALIDATE) &&
             (nFileOffset < 0) &&
             (nFileOffset != PARSE_EMPTYSTRING) )
        {
            StoreExtendedError(FNERR_INVALIDFILENAME);
            return (FALSE);
        }

        //
        //  It all looks valid.  I need to use to the original text because
        //  ParseFile does too much modifying.
        //
        PathRemoveBlanks(lpInitialText);
        LPTSTR pszFileName = PathFindFileName(lpInitialText);

        if (nFileOffset >= 0 && IsWild(pszFileName))
        {
            pDlgStruct->SetCurrentFilter(pszFileName);
        }

        nFileOffset = (int)(pszFileName - lpInitialText);
        if (nFileOffset > 0)
        {
            CopyMemory(szScratch, lpInitialText, nFileOffset * sizeof(TCHAR));
            szScratch[nFileOffset] = CHAR_NULL;
            PathRemoveBslash(szScratch);

            //
            //  If there is no specified initial dir or it is the same as the
            //  dir of the file, use the dir of the file and strip the path
            //  off the file.
            //
            if (!lpstrInitialDir || !lpstrInitialDir[0]
                || lstrcmpi(lpstrInitialDir, szScratch) == 0)
            {
                lpstrInitialDir = szScratch;
                lpInitialText = lpInitialText + nFileOffset;
            }
        }
    }

    if (lpstrInitialDir && *lpstrInitialDir)
    {
        BOOL fJump = FALSE;
        TCHAR szPersonal[MAX_PATH];

        if ((!g_bMyDocsHidden) &&
            SHGetSpecialFolderPath(NULL, szPersonal, CSIDL_PERSONAL, FALSE))
        {
            if (lstrcmpi(lpstrInitialDir, szPersonal) == 0)
            {
                //
                //  We've been told to start in the personal directory,
                //  so try to start in "My Documents".
                //
                fJump = pDlgStruct->JumpToIDList((LPCITEMIDLIST)&c_idlMyDocs,
                                                 FALSE);
            }
        }

        if (!fJump)
        {
            //
            //  It's better to come up somewhere rather than just tell the app
            //  they have a bogus directory set.
            //
            pDlgStruct->JumpToPath(lpstrInitialDir, TRUE);
        }
    }

    //
    //  This checks if the previous jump failed.
    //
    if (!pDlgStruct->psv)
    {
        //
        //  If we tried to set the dir above and it failed, we should
        //  probably always show the full path of the file.  If we didn't try
        //  above, then we are already showing the full path, so no problem.
        //
        lpInitialText = lpOFN->lpstrFile;

        //
        //  Try jumping to the AppOpenDir first.
        //
        TCHAR szPath[MAX_PATH];
        LPCITEMIDLIST pidl = GetAppOpenDir(szPath, pDlgStruct->szLastFilter);

        //
        //  If we got back a pidl, we should try to jump to it directly,
        //  instead of doing the path...
        //
        if (pidl)
        {
            if (!pDlgStruct->JumpToIDList(pidl, FALSE))
            {
                goto DoPath;
            }
        }
        else
        {
DoPath:
            if (szPath[0] == TEXT('\0'))
            {
                pDlgStruct->JumpToPath(TEXT("."), TRUE);
            }
            else
            {
                pDlgStruct->JumpToPath(szPath, TRUE);
            }
        }
    }

    if (!pDlgStruct->psv)
    {
        //
        //  Maybe the curdir has been deleted; try the desktop.
        //
        ITEMIDLIST idl = { 0 };

        //
        //  Do not try to translate this.
        //
        pDlgStruct->JumpToIDList(&idl, FALSE);
    }

    if (!pDlgStruct->psv)
    {
        //
        //  This would be very bad.
        //
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    //
    //  Read the cabinet state.  If the full title is enabled, then add
    //  the tooltip.  Otherwise, don't bother as they obviously don't care.
    //
    CABINETSTATE cCabState;

    //
    //  Will set defaults if cannot read registry.
    //
    ReadCabinetState(&cCabState, SIZEOF(cCabState));

    if (cCabState.fFullPathTitle)
    {
        pDlgStruct->hwndTips = CreateWindow( TOOLTIPS_CLASS,
                                             NULL,
                                             WS_POPUP | WS_GROUP | TTS_NOPREFIX,
                                             CW_USEDEFAULT,
                                             CW_USEDEFAULT,
                                             CW_USEDEFAULT,
                                             CW_USEDEFAULT,
                                             hDlg,
                                             NULL,
                                             ::g_hinst,
                                             NULL );
        if (pDlgStruct->hwndTips)
        {
            TOOLINFO ti;

            ti.cbSize = sizeof(ti);
            ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
            ti.hwnd = hDlg;
            ti.uId = (UINT_PTR)hCtrl;
            ti.hinst = NULL;
            ti.lpszText = LPSTR_TEXTCALLBACK;

            SendMessage( pDlgStruct->hwndTips,
                         TTM_ADDTOOL,
                         0,
                         (LPARAM)&ti );
        }
    }

    //
    //  Show the window after creating the ShellView so we do not get a
    //  big ugly gray spot.
    //  if we have cached in the size of previously opened  dialog then use
    //  the size and position of that window.

    if (pDlgStruct->bEnableSizing && (g_sizeDlg.cx != 0))
    {
        ::SetWindowPos( hDlg,
                        NULL,
                        g_posDlg.x,
                        g_posDlg.y,
                        g_sizeDlg.cx,
                        g_sizeDlg.cy,
                        SWP_SHOWWINDOW );
    }
    else
    {
        ::ShowWindow(hDlg, SW_SHOW);
        ::UpdateWindow(hDlg);
    }

    if (lpInitialText)
    {
        //
        //  This is the one time I will show a file spec, since it would be
        //  too strange to have "All Files" showing in the Type box, while
        //  only text files are in the view.
        //
        pDlgStruct->SetEditFile(lpInitialText, pDlgStruct->fShowExtensions, FALSE);
        SelectEditText(hDlg);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CleanupDialog
//
//  Dialog cleanup, memory deallocation.
//
////////////////////////////////////////////////////////////////////////////

void CleanupDialog(
    HWND hDlg,
    BOOL fRet)
{
    CFileOpenBrowser *pDlgStruct = HwndToBrowser(hDlg);

    if (!pDlgStruct)
    {
        return;
    }

    //
    //  Return the most recently used filter.
    //
    LPOPENFILENAME lpOFN = pDlgStruct->lpOFN;

    if (lpOFN->lpstrCustomFilter)
    {
        UINT len = lstrlen(lpOFN->lpstrCustomFilter) + 1;
        UINT sCount = lstrlen(pDlgStruct->szLastFilter);
        if (lpOFN->nMaxCustFilter > sCount + len)
        {
            lstrcpy(lpOFN->lpstrCustomFilter + len, pDlgStruct->szLastFilter);
        }
    }

    if ( (fRet == TRUE) &&
         pDlgStruct->hSubDlg &&
         ( CD_SendOKNotify(pDlgStruct->hSubDlg, hDlg, lpOFN, pDlgStruct->lpOFI) ||
           CD_SendOKMsg(pDlgStruct->hSubDlg, lpOFN, pDlgStruct->lpOFI) ) )
    {
        //
        //  Give the hook a chance to validate the file name.
        //
        return;
    }

    //
    //  We need to make sure the IShellBrowser is still around during
    //  destruction.
    //
    if (pDlgStruct->psv != NULL)
    {
        pDlgStruct->psv->DestroyViewWindow();
        pDlgStruct->psv->Release();

        pDlgStruct->psv = NULL;
    }

    SetAppOpenDir();

    if (((lpOFN->Flags & OFN_NOCHANGEDIR) || bUserPressedCancel) &&
        (*pDlgStruct->szStartDir))
    {
        SetCurrentDirectory(pDlgStruct->szStartDir);
    }

    ::EndDialog(hDlg, fRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetParentItem
//
//  Given an item index in the location dropdown, get its parent item.
//
////////////////////////////////////////////////////////////////////////////

MYLISTBOXITEM *GetParentItem(HWND hwndCombo, int *piItem)
{
    int iItem = *piItem;
    MYLISTBOXITEM *pItem = GetListboxItem(hwndCombo, iItem);

    for (--iItem; iItem >= 0; iItem--)
    {
        MYLISTBOXITEM *pPrev = GetListboxItem(hwndCombo, iItem);
        if (pPrev->cIndent < pItem->cIndent)
        {
            *piItem = iItem;
            return (pPrev);
        }
    }

    return (NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetFullPathEnumCB
//
////////////////////////////////////////////////////////////////////////////

BOOL GetFullPathEnumCB(
    CFileOpenBrowser *that,
    LPCITEMIDLIST pidl,
    LPARAM lParam)
{
    DWORD dwAttrs = SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_FILESYSANCESTOR;
    MYLISTBOXITEM *pLoc = that->pCurrentLocation;

    if (!pidl)
    {
        return (TRUE);
    }

    if ((SUCCEEDED(that->psfCurrent->GetAttributesOf(1, &pidl, &dwAttrs))) &&
        (dwAttrs & SFGAO_FILESYSTEM))
    {
        LPITEMIDLIST pidlFull;

        if (pLoc->pidlFull == NULL)
        {
            pidlFull = ILClone(pidl);
        }
        else
        {
            pidlFull = ILCombine(pLoc->pidlFull, pidl);
        }

        if (pidlFull != NULL)
        {
            SHGetPathFromIDList(pidlFull, (LPTSTR)lParam);
            SHFree(pidlFull);
        }
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::GetFullPath
//
//  Calculate the full path to the selected object in the view.
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::GetFullPath(
    LPTSTR pszBuf)
{
    *pszBuf = CHAR_NULL;

    EnumItemObjects(SVGIO_SELECTION, GetFullPathEnumCB, (LPARAM)pszBuf);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::RemoveOldPath
//
//  Removes old path elements from the location dropdown.  *piNewSel is the
//  listbox index of the leaf item which the caller wants to save.  All non-
//  permanent items that are not ancestors of that item are deleted.  The
//  index is updated appropriately if any items before it are deleted.
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::RemoveOldPath(
    int *piNewSel)
{
    HWND hwndCombo = ::GetDlgItem(hwndDlg, cmb2);
    int iStart = *piNewSel;
    int iItem;
    UINT cIndent = 0;
    int iSubOnDel = 0;

    //
    //  Flush all non-permanent non-ancestor items before this one.
    //
    for (iItem = ComboBox_GetCount(hwndCombo) - 1; iItem >= 0; --iItem)
    {
        MYLISTBOXITEM *pItem = GetListboxItem(hwndCombo, iItem);

        if (iItem == iStart)
        {
            //
            //  Begin looking for ancestors and adjusting the sel position.
            //
            iSubOnDel = 1;
            cIndent = pItem->cIndent;
            continue;
        }

        if (pItem->cIndent < cIndent)
        {
            //
            //  We went back a level, so this must be an ancestor of the
            //  selected item.
            //
            cIndent = pItem->cIndent;
            continue;
        }

        //
        //  Make sure to check this after adjusting cIndent.
        //
        if (pItem->dwFlags & MLBI_PERMANENT)
        {
            continue;
        }

        SendMessage(hwndCombo, CB_DELETESTRING, iItem, NULL);
        delete pItem;
        *piNewSel -= iSubOnDel;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  FindLocation
//
//  Given a listbox item, find the index.
//  Just a linear search, but we shouldn't have more than ~10-20 items.
//
////////////////////////////////////////////////////////////////////////////

int FindLocation(
    HWND hwndCombo,
    MYLISTBOXITEM *pFindItem)
{
    int iItem;

    for (iItem = ComboBox_GetCount(hwndCombo) - 1; iItem >= 0; --iItem)
    {
        MYLISTBOXITEM *pItem = GetListboxItem(hwndCombo, iItem);

        if (pItem == pFindItem)
        {
            break;
        }
    }

    return (iItem);
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnSelChange
//
//  Process the selection change in the location dropdown.
//
//  Chief useful feature is that it removes the items for the old path.
//  Returns TRUE only if it was possible to switch to the specified item.
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::OnSelChange(
    int iItem,
    BOOL bForceUpdate)
{
    HWND hwndCombo = GetDlgItem(hwndDlg, cmb2);
    BOOL bRet = TRUE;

    if (iItem == -1)
    {
        iItem = (int) SendMessage(hwndCombo, CB_GETCURSEL, NULL, NULL);
    }

    MYLISTBOXITEM *pNewLocation = GetListboxItem(hwndCombo, iItem);
    MYLISTBOXITEM *pOldLocation = pCurrentLocation;
    BOOL bFirstTry = TRUE;
    BOOL bSwitchedBack = FALSE;

    if (bForceUpdate || (pNewLocation != pOldLocation))
    {
        FOLDERSETTINGS fs;

        if (psv)
        {
            psv->GetCurrentInfo(&fs);
        }
        else
        {
            fs.ViewMode = FVM_LIST;
            fs.fFlags = lpOFN->Flags & OFN_ALLOWMULTISELECT ? 0 : FWF_SINGLESEL;
        }

        //  we always want the recent folder to come up
        //  in details mode
        if (_IsRecentFolder(pNewLocation->pidlFull))
        {
            _CachedViewMode = fs.ViewMode;
            fs.ViewMode = FVM_DETAILS;
        }
        //  we dont want to use the existing settings
        else if (_IsRecentFolder(pCurrentLocation->pidlFull))
        {
            fs.ViewMode = _CachedViewMode;
        }
        
        iCurrentLocation = iItem;
        pCurrentLocation = pNewLocation;

OnSelChange_TryAgain:
        if (FAILED(SwitchView( pCurrentLocation->GetShellFolder(),
                               pCurrentLocation->pidlFull,
                               &fs )))
        {
            //
            //  We could not create the view for this location.
            //
            bRet = FALSE;

            //
            //  Try the previous folder.
            //
            if (bFirstTry)
            {
                bFirstTry = FALSE;
                pCurrentLocation = pOldLocation;
                int iOldItem = FindLocation(hwndCombo, pOldLocation);
                if (iOldItem >= 0)
                {
                    iCurrentLocation = iOldItem;
                    ComboBox_SetCurSel(hwndCombo, iCurrentLocation);

                    if (psv)
                    {
                        bSwitchedBack = TRUE;
                        goto SwitchedBack;
                    }
                    else
                    {
                        goto OnSelChange_TryAgain;
                    }
                }
            }

            //
            //  Try the parent of the old item.
            //
            if (iCurrentLocation)
            {
                pCurrentLocation = GetParentItem(hwndCombo, &iCurrentLocation);
                ComboBox_SetCurSel(hwndCombo, iCurrentLocation);
                goto OnSelChange_TryAgain;
            }

            //
            //  We cannot create the Desktop view.  I think we are in
            //  real trouble.  We had better bail out.
            //
            StoreExtendedError(CDERR_DIALOGFAILURE);
            CleanupDialog(hwndDlg, FALSE);
            return (FALSE);
        }

        ::SendMessage( hwndToolbar,
                       TB_SETSTATE,
                       IDC_PARENT,
                       iCurrentLocation ? TBSTATE_ENABLED : 0 );

        if (!iCurrentLocation || (pCurrentLocation->dwAttrs & SFGAO_FILESYSTEM))
        {
            pCurrentLocation->SwitchCurrentDirectory(pcwd);
        }


        TCHAR szFile[MAX_PATH + 1];
        int nFileOffset;

        //
        //  We've changed folders; we'd better strip whatever is in the edit
        //  box down to the file name.
        //
        if (bUseCombo)
        {
            HWND hwndEdit = (HWND)SendMessage(GetDlgItem(hwndDlg, cmb13), CBEM_GETEDITCONTROL, 0, 0L);
            GetWindowText(hwndEdit, szFile, ARRAYSIZE(szFile));
        }
        else
        {
            GetDlgItemText(hwndDlg, edt1, szFile, ARRAYSIZE(szFile));
        }

        nFileOffset = ParseFileNew(szFile, NULL, FALSE, TRUE);

        if (nFileOffset > 0 && !IsDirectory(szFile))
        {
            //
            //  The user may have typed an extension, so make sure to show it.
            //
            SetEditFile(szFile + nFileOffset, TRUE);
        }

        SetSaveButton(iszFileSaveButton);

SwitchedBack:
        RemoveOldPath(&iCurrentLocation);
    }

    if (!bSwitchedBack && hSubDlg)
    {
        CD_SendFolderChangeNotify(hSubDlg, hwndDlg, lpOFN, lpOFI);
    }

    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnDotDot
//
//  Process the open-parent-folder button on the toolbar.
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::OnDotDot()
{
    HWND hwndCombo = GetDlgItem(hwndDlg, cmb2);

    int iItem = ComboBox_GetCurSel(hwndCombo);

    MYLISTBOXITEM *pItem = GetParentItem(hwndCombo, &iItem);

    SendMessage(hwndCombo, CB_SETCURSEL, iItem, NULL);

    //
    //  Delete old path from combo.
    //
    OnSelChange();
    UpdateNavigation();
}

////////////////////////////////////////////////////////////////////////////
//
//  DblClkEnumCB
//
////////////////////////////////////////////////////////////////////////////

#define PIDL_NOTHINGSEL      (LPCITEMIDLIST)0
#define PIDL_MULTIPLESEL     (LPCITEMIDLIST)-1
#define PIDL_FOLDERSEL       (LPCITEMIDLIST)-2

BOOL DblClkEnumCB(
    CFileOpenBrowser *that,
    LPCITEMIDLIST pidl,
    LPARAM lParam)
{
    MYLISTBOXITEM *pLoc = that->pCurrentLocation;
    LPCITEMIDLIST *ppidl = (LPCITEMIDLIST *)lParam;

    if (!pidl)
    {
        pidl = *ppidl;

        if (pidl == PIDL_NOTHINGSEL)
        {
            //
            //  Nothing selected.
            //
            return (FALSE);
        }

        if (pidl == PIDL_MULTIPLESEL)
        {
            //
            //  More than one thing selected.
            //
            return (FALSE);
        }

        if (IsContainer(that->psfCurrent, pidl))
        {
            LPITEMIDLIST pidlFull = ILCombine(pLoc->pidlFull, pidl);

            if (pidlFull)
            {
                that->JumpToIDList(pidlFull);
                SHFree(pidlFull);
            }

            *ppidl = PIDL_FOLDERSEL;
        }

        // This pidl might be a link pointing to folder in which case we want to 
        // treat it like a  directory. if the link points to file then that is taken
        // care of in the  Process Edit command.
        if (pidl)
        {
            SHTCUTINFO  info;
            LPITEMIDLIST  pidlLink = NULL;

            info.dwAttr      = SFGAO_FOLDER | SFGAO_BROWSABLE;
            info.fReSolve    = TRUE;
            info.pszLinkFile = NULL;
            info.cchFile     = NULL;
            info.ppidl       = &pidlLink; 

            //see if the given pidl is a link and whether  the link points to a directory
            if ((that->GetLinkStatus(pidl,&info)) &&
                ((info.dwAttr & (SFGAO_FOLDER | SFGAO_BROWSABLE)) == SFGAO_FOLDER))
            {
                if (pidlLink)
                {
                    // Got the pidl . Jump to that pidl
                    that->JumpToIDList(pidlLink);
                }
                *ppidl = PIDL_FOLDERSEL;
            }

            if (pidlLink)
            {
                ILFree(pidlLink);
            }
        }
        return (FALSE);
    }

    if (*ppidl)
    {
        //
        //  More than one thing selected.
        //
        *ppidl = PIDL_MULTIPLESEL;
        return (FALSE);
    }

    *ppidl = pidl;

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnDblClick
//
//  Process a double-click in the view control, either by choosing the
//  selected non-container object or by opening the selected container.
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::OnDblClick(
    BOOL bFromOKButton)
{
    LPCITEMIDLIST pidlFirst = PIDL_NOTHINGSEL;

    if (psv)
    {
        EnumItemObjects(SVGIO_SELECTION, DblClkEnumCB, (LPARAM)&pidlFirst);
    }

    if (pidlFirst == PIDL_NOTHINGSEL)
    {
        //
        //  Nothing selected.
        //
        if (bFromOKButton)
        {
            //
            //  This means we got an IDOK when the focus was in the view,
            //  but nothing was selected.  Let's get the edit text and go
            //  from there.
            //
            ProcessEdit();
        }
    }
    else if (pidlFirst != PIDL_FOLDERSEL)
    {
        //
        //  This will change the edit box, but that's OK, since it probably
        //  already has.  This should take care of files with no extension.
        //
        SelFocusChange(TRUE);

        //
        //  This part will take care of resolving links.
        //
        ProcessEdit();
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::JumpToPath
//
//  Refocus the entire dialog on a different directory.
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::JumpToPath(
    LPCTSTR pszDirectory,
    BOOL bTranslate)
{
    BOOL bRet;
    TCHAR szTemp[MAX_PATH + 1];
    TCHAR szCurDir[MAX_PATH + 1];

    //
    //  This should do the whole job of canonicalizing the directory.
    //
    GetCurrentDirectory(ARRAYSIZE(szCurDir), szCurDir);
    PathCombine(szTemp, szCurDir, pszDirectory);

    LPITEMIDLIST pidlNew = ILCreateFromPath(szTemp);

    if (pidlNew == NULL)
    {
        return (FALSE);
    }

    //
    //  Need to make sure the pidl points to a folder. If not, then remove
    //  items from the end until we find one that is.
    //  This must be done before the translation.
    //    
    DWORD dwAttrib;
    do
    {
        dwAttrib = SFGAO_FOLDER;

        CDGetAttributesOf(pidlNew, &dwAttrib);

        if (!(dwAttrib & SFGAO_FOLDER))
        {
           ILRemoveLastID(pidlNew);
        }

    } while( !(dwAttrib & SFGAO_FOLDER) && !ILIsEmpty(pidlNew));

    if (!(dwAttrib & SFGAO_FOLDER))
    {
        SHFree(pidlNew);
        return (FALSE);
    }

    bRet = JumpToIDList(pidlNew, bTranslate);

    SHFree(pidlNew);

    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::JumpTOIDList
//
//  Refocus the entire dialog on a different IDList.
//
//  Parameter:
//    bTranslate        specifies whether the given pidl should be translated to
//                      logical pidl
//    bAddToNavStack    specifies whether the pidl given for jumping should be
//                      added to the back/forward navigation stack
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::JumpToIDList(
    LPCITEMIDLIST pidlNew,
    BOOL bTranslate,
    BOOL bAddToNavStack)
{
    LPITEMIDLIST pidlLog = NULL;

    if (bTranslate)
    {
        //
        //  Translate IDList's on the Desktop into the appropriate
        //  logical IDList.
        //
        pidlLog = SHLogILFromFSIL(pidlNew);
        if (pidlLog)
        {
            pidlNew = pidlLog;
        }
    }

    //
    //  Find the entry in the location dropdown that is the closest parent
    //  to the new location.
    //
    HWND hwndCombo = ::GetDlgItem(hwndDlg, cmb2);
    MYLISTBOXITEM *pBestParent = GetListboxItem(hwndCombo, 0);
    int iBestParent = 0;
    LPCITEMIDLIST pidlRelative = pidlNew;

    UINT cIndent = 0;
    BOOL fExact = FALSE;

    for (UINT iItem = 0; ; iItem++)
    {
        MYLISTBOXITEM *pNextItem = GetListboxItem(hwndCombo, iItem);
        if (pNextItem == NULL)
        {
            break;
        }
        if (pNextItem->cIndent != cIndent)
        {
            //
            //  Not the depth we want.
            //
            continue;
        }
        if (ILIsEqual(pNextItem->pidlFull, pidlNew))
        {
            fExact = TRUE;
            break;
        }
        LPCITEMIDLIST pidlChild = ILFindChild(pNextItem->pidlFull, pidlNew);
        if (pidlChild != NULL)
        {
            pBestParent = pNextItem;
            iBestParent = iItem;
            cIndent++;
            pidlRelative = pidlChild;
        }
    }

    //
    //  The path provided might have matched an existing item exactly.  In
    //  that case, just select the item.
    //
    if (fExact)
    {
        goto FoundIDList;
    }

    //
    //  Now, pBestParent is the closest parent to the item, iBestParent is
    //  its index, and cIndent is the next appropriate indent level.  Begin
    //  creating new items for the rest of the path.
    //
    iBestParent++;                // begin inserting after parent item
    for ( ; ; )
    {
        LPITEMIDLIST pidlFirst = ILCloneFirst(pidlRelative);
        if (pidlFirst == NULL)
        {
            break;
        }
        MYLISTBOXITEM *pNewItem = new MYLISTBOXITEM();

        if (pNewItem)
        {
            if (!pNewItem->Init(pBestParent,
                                pBestParent->GetShellFolder(),
                                pidlFirst,
                                cIndent,
                                MLBI_PSFFROMPARENT ))
            {
                delete pNewItem;
                pNewItem = NULL;
                //iBestParent is off by 1 in error case . Correct it
                iBestParent--;
                break;
            }
        }
        else
        {
            //iBestParent is off by 1 in error case . Correct it
            iBestParent--;
            break;
        }

        GetViewItemText( pBestParent->psfSub,
                         pidlFirst,
                         szBuf,
                         ARRAYSIZE(szBuf),
                         SHGDN_NORMAL);
        InsertItem(hwndCombo, iBestParent, pNewItem, szBuf);
        SHFree(pidlFirst);
        pidlRelative = ILGetNext(pidlRelative);
        if (ILIsEmpty(pidlRelative))
        {
            break;
        }
        cIndent++;                // next one is indented one more level
        iBestParent++;            // and inserted after this one
        pBestParent = pNewItem;   // and is a child of the one we just inserted
    }

    iItem = iBestParent;

FoundIDList:
    if (pidlLog)
    {
        SHFree(pidlLog);
    }

    SendMessage(hwndCombo, CB_SETCURSEL, iItem, NULL);
    BOOL bRet = OnSelChange(iItem, TRUE);

    //Update our Navigation stack
    if (bRet && bAddToNavStack)
    {
        UpdateNavigation();
    }

    return bRet;

}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::ViewCommand
//
//  Process the new-folder button on the toolbar.
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::ViewCommand(
    UINT uIndex)
{
    IContextMenu *pcm;

    if (SUCCEEDED(psv->GetItemObject( SVGIO_BACKGROUND,
                                      IID_IContextMenu,
                                      (LPVOID *)&pcm )))
    {
        CMINVOKECOMMANDINFOEX ici = {0};

        ici.cbSize = sizeof(ici);
        ici.fMask = 0L;
        ici.hwnd = hwndDlg;
        ici.lpVerb = ::c_szCommandsA[uIndex];
        ici.lpParameters = NULL;
        ici.lpDirectory = NULL;
        ici.nShow = SW_NORMAL;
        ici.lpParametersW = NULL;
        ici.lpDirectoryW = NULL;

#ifdef UNICODE
        ici.lpVerbW = ::c_szCommandsW[uIndex];
        ici.fMask |= CMIC_MASK_UNICODE;
#endif

        IObjectWithSite *pObjSite = NULL;

        if (SUCCEEDED(pcm->QueryInterface(IID_IObjectWithSite, (void**)&pObjSite)))
        {
            pObjSite->SetSite(SAFECAST(psv,IShellView*));
        }


        HMENU hmContext = CreatePopupMenu();
        pcm->QueryContextMenu(hmContext, 0, 1, 256, 0);
        pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)(&ici));

        if (pObjSite)
        {
            pObjSite->SetSite(NULL);
            pObjSite->Release();
        }

        DestroyMenu(hmContext);
        pcm->Release();

    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::ResolveLink
//
////////////////////////////////////////////////////////////////////////////

HRESULT CFileOpenBrowser::ResolveLink(
    LPCITEMIDLIST pidl,
    PSHTCUTINFO pinfo,
    IShellFolder *psf)
{
    IShellLink *psl;
    BOOL fSetPidl = TRUE;

    //Do we have IShellFolder passed to us ?
    if (!psf)
    {
        //No use our current shell folder.
        psf =  psfCurrent;
    }

    //Get the IShellLink interface pointer corresponding to given file
    HRESULT hres = psf->GetUIObjectOf(hwndDlg, 1, &pidl, IID_IShellLink, 0, (LPVOID *)&psl);

    if (SUCCEEDED(hres))
    {
        ASSERT(psl);

        //Resolve the link
        if (pinfo->fReSolve)
        {
            hres = psl->Resolve(hwndDlg, 0);

            //If the resolve failed then we can't get correct pidl
            if (hres == S_FALSE)
            {
                fSetPidl = FALSE;
            }
        }
        
        if (SUCCEEDED(hres))
        {
            //Get the path of the file pointed by link
            if (pinfo->pszLinkFile && pinfo->cchFile)
            {
                hres = psl->GetPath(pinfo->pszLinkFile, pinfo->cchFile, 0, 0);
            }

            if (SUCCEEDED(hres))
            {
                LPITEMIDLIST pidl;
                hres = psl->GetIDList(&pidl);

                if (SUCCEEDED(hres))
                {
                    if (pinfo->dwAttr)
                    {
                        hres = CDGetAttributesOf(pidl, &pinfo->dwAttr);
                    }

                    if (pinfo->ppidl && fSetPidl)
                    {
                        *(pinfo->ppidl) = pidl;
                    }
                    else
                    {
                        ILFree(pidl);
                    }
                }
            }
        }
        psl->Release();
    }

    return (hres);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::GetLinkStatus
//      This function checks to see if the pidl given is a link and if so resolves the 
//      link 
//  PARAMETERS :
// 
//      LPCITEMIDLIST pidl -  the pidl which we want to check for link
//      LPTSTR   pszLinkFile - if the pidl points to a link then this contains the  resolved file 
//                             name
//      UINT     cchFile -  size of the buffer pointed by the  pszLinkFile
//
//  RETURN VALUE :
//      returns  TRUE    if the pidl is link  and was able to resolve the link successfully
//      returns  FALSE   if the pidl is not link  or if the link was not able to resolve successfully.
//                       In this case pszLinkFile  and pfd are not valid.
////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CFileOpenBrowser::GetLinkStatus(
    LPCITEMIDLIST pidl, 
    PSHTCUTINFO pinfo)
{
    if (!IsLink(psfCurrent,pidl))
    {
        return (FALSE);
    }

    if (ResolveLink(pidl,pinfo) != S_OK)
    {
        return (FALSE);
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::LinkMatchSpec
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::LinkMatchSpec(
    LPCITEMIDLIST pidl,
    LPCTSTR pszSpec)
{
    TCHAR szFile[MAX_PATH];
    SHTCUTINFO  info;

    info.dwAttr       = SFGAO_FOLDER | SFGAO_BROWSABLE;
    info.fReSolve     = FALSE;
    info.pszLinkFile  = szFile;
    info.cchFile      = ARRAYSIZE(szFile);
    info.ppidl        = NULL; 

    if (GetLinkStatus(pidl,&info))
    {
        if (((info.dwAttr & (SFGAO_FOLDER | SFGAO_BROWSABLE)) == SFGAO_FOLDER) ||
            (szFile[0] && PathMatchSpec(szFile, pszSpec)))
        {
            return (TRUE);
        }
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MeasureDriveItems
//
//  Standard owner-draw code for the location dropdown.
//
////////////////////////////////////////////////////////////////////////////

#define MINIDRIVE_MARGIN     4
#define MINIDRIVE_WIDTH      (g_cxSmIcon)
#define MINIDRIVE_HEIGHT     (g_cySmIcon)
#define DRIVELIST_BORDER     3

void MeasureDriveItems(
    HWND hwndDlg,
    MEASUREITEMSTRUCT *lpmi)
{
    HDC hdc;
    HFONT hfontOld;
    int dyDriveItem;
    SIZE siz;

    hdc = GetDC(NULL);
    hfontOld = (HFONT)SelectObject( hdc,
                                    (HFONT)SendMessage( hwndDlg,
                                                        WM_GETFONT,
                                                        0,
                                                        0 ) );

    GetTextExtentPoint(hdc, TEXT("W"), 1, &siz);
    dyDriveItem = siz.cy;

    if (hfontOld)
    {
        SelectObject(hdc, hfontOld);
    }
    ReleaseDC(NULL, hdc);

    dyDriveItem += DRIVELIST_BORDER;
    if (dyDriveItem < MINIDRIVE_HEIGHT)
    {
        dyDriveItem = MINIDRIVE_HEIGHT;
    }

    lpmi->itemHeight = dyDriveItem;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::PaintDriveLine
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::PaintDriveLine(
    DRAWITEMSTRUCT *lpdis)
{
    HDC hdc = lpdis->hDC;
    RECT rc = lpdis->rcItem;
    TCHAR szText[MAX_DRIVELIST_STRING_LEN];
    int offset = 0;
    int xString, yString, xMiniDrive, dyString;
    SIZE siz;

    if ((int)lpdis->itemID < 0)
    {
        return;
    }

    MYLISTBOXITEM *pItem = GetListboxItem(lpdis->hwndItem, lpdis->itemID);
    ::SendDlgItemMessage( hwndDlg,
                          cmb2,
                          CB_GETLBTEXT,
                          lpdis->itemID,
                          (LPARAM)szText );

    //
    //  Before doing anything, calculate the actual rectangle for the text.
    //
    if (!(lpdis->itemState & ODS_COMBOBOXEDIT))
    {
        offset = 10 * pItem->cIndent;
    }

    xMiniDrive = rc.left + DRIVELIST_BORDER + offset;
    rc.left = xString = xMiniDrive + MINIDRIVE_WIDTH + MINIDRIVE_MARGIN;
    GetTextExtentPoint(hdc, szText, lstrlen(szText), &siz);

    dyString = siz.cy;
    rc.right = rc.left + siz.cx;
    rc.left--;
    rc.right++;

    if (lpdis->itemAction != ODA_FOCUS)
    {
        FillRect(hdc, &lpdis->rcItem, GetSysColorBrush(COLOR_WINDOW));

        yString = rc.top + (rc.bottom - rc.top - dyString) / 2;

        SetBkColor( hdc,
                    GetSysColor( (lpdis->itemState & ODS_SELECTED)
                                     ? COLOR_HIGHLIGHT
                                     : COLOR_WINDOW ) );
        SetTextColor( hdc,
                      GetSysColor( (lpdis->itemState & ODS_SELECTED)
                                       ? COLOR_HIGHLIGHTTEXT
                                       : COLOR_WINDOWTEXT ) );

        if ((lpdis->itemState & ODS_COMBOBOXEDIT) &&
            (rc.right > lpdis->rcItem.right))
        {
            //
            //  Need to clip as user does not!
            //
            rc.right = lpdis->rcItem.right;
            ExtTextOut( hdc,
                        xString,
                        yString,
                        ETO_OPAQUE | ETO_CLIPPED,
                        &rc,
                        szText,
                        lstrlen(szText),
                        NULL );
        }
        else
        {
            ExtTextOut( hdc,
                        xString,
                        yString,
                        ETO_OPAQUE,
                        &rc,
                        szText,
                        lstrlen(szText),
                        NULL );
        }

        ImageList_Draw( himl,
                        (lpdis->itemID == (UINT)iCurrentLocation)
                            ? pItem->iSelectedImage
                            : pItem->iImage,
                        hdc,
                        xMiniDrive,
                        rc.top + (rc.bottom - rc.top - MINIDRIVE_HEIGHT) / 2,
                        (pItem->IsShared()
                            ? INDEXTOOVERLAYMASK(IDOI_SHARE)
                            : 0) |
                        ((lpdis->itemState & ODS_SELECTED)
                            ? (ILD_SELECTED | ILD_FOCUS | ILD_TRANSPARENT)
                            : ILD_TRANSPARENT) );
    }

    if (lpdis->itemAction == ODA_FOCUS ||
        (lpdis->itemState & ODS_FOCUS))
    {
        DrawFocusRect(hdc, &rc);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::RefreshFilter
//
//  Refresh the view given any change in the user's choice of wildcard
//  filter.
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::RefreshFilter(
    HWND hwndFilter)
{
    WAIT_CURSOR w;

    lpOFN->Flags &= ~OFN_FILTERDOWN;

    short nIndex = (short) SendMessage(hwndFilter, CB_GETCURSEL, 0, 0L);
    if (nIndex < 0)
    {
        //
        //  No current selection.
        //
        return;
    }

    BOOL bCustomFilter = lpOFN->lpstrCustomFilter && *lpOFN->lpstrCustomFilter;

    lpOFN->nFilterIndex = nIndex;
    if (!bCustomFilter)
    {
        lpOFN->nFilterIndex++;
    }

    LPTSTR lpFilter;

    //
    //  Must also check if filter contains anything.
    //
    lpFilter = (LPTSTR)ComboBox_GetItemData(hwndFilter, nIndex);

    if (*lpFilter)
    {
        SetCurrentFilter(lpFilter);

        //
        //  Provide dynamic pszDefExt updating when lpstrDefExt is app
        //  initialized.
        //
        if (!bNoInferDefExt && lpOFN->lpstrDefExt)
        {
            //
            //  We are looking for "foo*.ext[;...]".  We will grab ext as the
            //  default extension.  If not of this form, use the default
            //  extension passed in.
            //
            LPTSTR lpDot = StrChr(lpFilter, CHAR_DOT);

            //
            //  Skip past the CHAR_DOT.
            //
            if (lpDot && pszDefExt.StrCpy(lpDot + 1))
            {
                LPTSTR lpSemiColon = StrChr(pszDefExt, CHAR_SEMICOLON);
                if (lpSemiColon)
                {
                    *lpSemiColon = CHAR_NULL;
                }

                if (IsWild(pszDefExt))
                {
                    pszDefExt.StrCpy(lpOFN->lpstrDefExt);
                }
            }
            else
            {
                pszDefExt.StrCpy(lpOFN->lpstrDefExt);
            }
        }

        if (bUseCombo)
        {
            HWND hwndEdit = (HWND)SendMessage(GetDlgItem(hwndDlg, cmb13), CBEM_GETEDITCONTROL, 0, 0L);
            GetWindowText(hwndEdit, szBuf, ARRAYSIZE(szBuf));
        }
        else
        {
            GetDlgItemText(hwndDlg, edt1, szBuf, ARRAYSIZE(szBuf));
        }

        if (IsWild(szBuf))
        {
            //
            //  We should not show a filter that we are not using.
            //
            *szBuf = CHAR_NULL;
            SetEditFile(szBuf, TRUE);
        }

        if (psv)
        {
            psv->Refresh();
        }
    }

    if (hSubDlg)
    {
        if (!CD_SendTypeChangeNotify(hSubDlg, hwndDlg, lpOFN, lpOFI))
        {
            CD_SendLBChangeMsg(hSubDlg, cmb1, nIndex, CD_LBSELCHANGE, lpOFI->ApiType);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::GetDirectoryFromLB
//
//  Return the dropdown's directory and its length.
//  Set *pichRoot to the start of the path (C:\ or \\server\share\).
//
////////////////////////////////////////////////////////////////////////////

UINT CFileOpenBrowser::GetDirectoryFromLB(
    LPTSTR pszBuf,
    int *pichRoot)
{
    *pszBuf = 0;
    if (pCurrentLocation->pidlFull != NULL)
    {
        GetPathFromLocation(pCurrentLocation, pszBuf);
    }

    if (*pszBuf)
    {
        PathAddBackslash(pszBuf);
        LPTSTR pszBackslash = StrChr(pszBuf + 2, CHAR_BSLASH);
        if (pszBackslash != NULL)
        {
            //
            //  For UNC paths, the "root" is on the next backslash.
            //
            if (DBL_BSLASH(pszBuf))
            {
                pszBackslash = StrChr(pszBackslash + 1, CHAR_BSLASH);
            }
            UINT cchRet = lstrlen(pszBuf);
            *pichRoot = (pszBackslash != NULL) ? (int)(pszBackslash - pszBuf) : cchRet;
            return (cchRet);
        }
    }
    *pichRoot = 0;

    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::EnumItemObjects
//
////////////////////////////////////////////////////////////////////////////

typedef BOOL (*EIOCALLBACK)(
    CFileOpenBrowser *that,
    LPCITEMIDLIST pidl,
    LPARAM lParam);

BOOL CFileOpenBrowser::EnumItemObjects(
    UINT uItem,
    EIOCALLBACK pfnCallBack,
    LPARAM lParam)
{
    FORMATETC fmte = { (CLIPFORMAT) g_cfCIDA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    BOOL bRet = FALSE;
    LPCITEMIDLIST pidl;
    LPIDA pida;
    int cItems, i;
    IDataObject *pdtobj;
    STGMEDIUM medium;

    if (!psv || FAILED(psv->GetItemObject( uItem,
                                           IID_IDataObject,
                                           (LPVOID *)&pdtobj )))
    {
        goto Error0;
    }

    if (FAILED(pdtobj->GetData(&fmte, &medium)))
    {
        goto Error1;
    }

    pida = (LPIDA)GlobalLock(medium.hGlobal);
    cItems = pida->cidl;

    for (i = 1; ; ++i)
    {
        if (i > cItems)
        {
            //
            //  We got to the end of the list without a failure.
            //  Call back one last time with NULL.
            //
            bRet = pfnCallBack(this, NULL, lParam);
            break;
        }

        pidl = LPIDL_GetIDList(pida, i);

        if (!pfnCallBack(this, pidl, lParam))
        {
            break;
        }
    }

    GlobalUnlock(medium.hGlobal);

    _ReleaseStgMedium(&medium);

Error1:
    pdtobj->Release();
Error0:
    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  FindNameEnumCB
//
////////////////////////////////////////////////////////////////////////////

#define FE_INVALID_VALUE     0x0000
#define FE_OUTOFMEM          0x0001
#define FE_TOOMANY           0x0002
#define FE_CHANGEDDIR        0x0003
#define FE_FILEERR           0x0004
#define FE_FOUNDNAME         0x0005

typedef struct _FINDNAMESTRUCT
{
    LPTSTR        pszFile;
    UINT          uRet;
    LPCITEMIDLIST pidlFound;
} FINDNAMESTRUCT;


BOOL FindNameEnumCB(
    CFileOpenBrowser *that,
    LPCITEMIDLIST pidl,
    LPARAM lParam)
{
    SHFILEINFO sfi;
    FINDNAMESTRUCT *pfns = (FINDNAMESTRUCT *)lParam;

    if (!pidl)
    {
        if (!pfns->pidlFound)
        {
            return (FALSE);
        }

        GetViewItemText( that->psfCurrent,
                         pfns->pidlFound,
                         pfns->pszFile,
                         MAX_PATH );

        if (IsContainer(that->psfCurrent, pfns->pidlFound))
        {
            LPITEMIDLIST pidlFull = ILCombine( that->pCurrentLocation->pidlFull,
                                               pfns->pidlFound );

            if (pidlFull)
            {
                if (that->JumpToIDList(pidlFull))
                {
                    pfns->uRet = FE_CHANGEDDIR;
                }
                else if (!that->psv)
                {
                    pfns->uRet = FE_OUTOFMEM;
                }
                SHFree(pidlFull);

                if (pfns->uRet != FE_INVALID_VALUE)
                {
                    return (TRUE);
                }
            }
        }

        pfns->uRet = FE_FOUNDNAME;
        return (TRUE);
    }

    if (!SHGetFileInfo( (LPCTSTR)pidl,
                        0,
                        &sfi,
                        sizeof(sfi),
                        SHGFI_DISPLAYNAME | SHGFI_PIDL ))
    {
        //
        //  This will never happen, right?
        //
        return (TRUE);
    }

    if (lstrcmpi(sfi.szDisplayName, pfns->pszFile) != 0)
    {
        //
        //  Continue the enumeration.
        //
        return (TRUE);
    }

    if (!pfns->pidlFound)
    {
        pfns->pidlFound = pidl;

        //
        //  Continue looking for more matches.
        //
        return (TRUE);
    }

    //
    //  We already found a match, so select the first one and stop the search.
    //
    //  ISSUE: The focus must be set to hwndView before changing selection or
    //  the GetItemObject may not work.
    //
    FORWARD_WM_NEXTDLGCTL(that->hwndDlg, that->hwndView, 1, SendMessage);
    that->psv->SelectItem( pfns->pidlFound,
                           SVSI_SELECT | SVSI_DESELECTOTHERS |
                               SVSI_ENSUREVISIBLE | SVSI_FOCUSED );

    pfns->pidlFound = NULL;
    pfns->uRet = FE_TOOMANY;

    //
    //  Stop enumerating.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CDPathQualify
//
////////////////////////////////////////////////////////////////////////////

void CDPathQualify(
    LPCTSTR lpFile,
    LPTSTR pszPathName)
{
    TCHAR szCurDir[MAX_PATH + 1];

    lstrcpy(pszPathName, lpFile);

    //
    //  This should do the whole job of canonicalizing the directory.
    //
    GetCurrentDirectory(ARRAYSIZE(szCurDir), szCurDir);
    PathCombine(pszPathName, szCurDir, pszPathName);
}


////////////////////////////////////////////////////////////////////////////
//
//  VerifyOpen
//
//  Returns:   0    success
//             !0   dos error code
//
////////////////////////////////////////////////////////////////////////////

int VerifyOpen(
    LPCTSTR lpFile,
    LPTSTR pszPathName)
{
    HANDLE hf;

    CDPathQualify(lpFile, pszPathName);

    hf = CreateFile( pszPathName,
                     GENERIC_READ,
                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL );
    if (hf == INVALID_HANDLE_VALUE)
    {
        return GetLastError();
    }
    else
    {
        CloseHandle(hf);
        return (0);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::IsKnownExtension
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::IsKnownExtension(
    LPCTSTR pszExtension)
{
    if ((LPTSTR)pszDefExt && lstrcmpi(pszExtension + 1, pszDefExt) == 0)
    {
        //
        //  It's the default extension, so no need to add it again.
        //
        return (TRUE);
    }

    if (RegQueryValue(HKEY_CLASSES_ROOT, pszExtension, NULL, 0) == ERROR_SUCCESS)
    {
        //
        //  It's a registered extension, so the user is trying to force
        //  the type.
        //
        return (TRUE);
    }

    if (lpOFN->lpstrFilter)
    {
        LPCTSTR pFilter = lpOFN->lpstrFilter;

        while (*pFilter)
        {
            //
            //  Skip visual.
            //
            pFilter = pFilter + lstrlen(pFilter) + 1;

            //
            //  Search extension list.
            //
            while (*pFilter)
            {
                //
                //  Check extensions of the form '*.ext' only.
                //
                if (*pFilter == CHAR_STAR && *(++pFilter) == CHAR_DOT)
                {
                    LPCTSTR pExt = pszExtension + 1;

                    pFilter++;

                    while (*pExt && *pExt == *pFilter)
                    {
#ifndef UNICODE
                        if (IsDBCSLeadByte(*pExt))
                        {
                            if (*(pExt + 1) != *(pFilter + 1))
                            {
                                break;
                            }
                            pExt++;
                            pFilter++;
                        }
#endif
                        pExt++;
                        pFilter++;
                    }

                    if (!*pExt && (*pFilter == CHAR_SEMICOLON || !*pFilter))
                    {
                        //
                        //  We have a match.
                        //
                        return (TRUE);
                    }
                }

                //
                //  Skip to next extension.
                //
                while (*pFilter)
                {
                    TCHAR ch = *pFilter;
                    pFilter = CharNext(pFilter);
                    if (ch == CHAR_SEMICOLON)
                    {
                        break;
                    }
                }
            }

            //
            //  Skip extension string's terminator.
            //
            pFilter++;
        }
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::FindNameInView
//
//  We will only resolve a link once.  If you have a link to a link, then
//  we will return the second link.
//
//  If nExtOffset is non-zero, it is the offset to the character following
//  the dot.
//
////////////////////////////////////////////////////////////////////////////

#define NUM_LINKLOOPS 1

UINT CFileOpenBrowser::FindNameInView(
    LPTSTR pszFile,
    OKBUTTONFLAGS Flags,
    LPTSTR pszPathName,
    int nFileOffset,
    int nExtOffset,
    int *pnErrCode,
    BOOL bTryAsDir)
{
    UINT uRet;
    FINDNAMESTRUCT fns =
    {
        pszFile,
        FE_INVALID_VALUE,
        NULL,
    };
    BOOL bGetOut = TRUE;
    BOOL bAddExt = FALSE;
    BOOL bHasExt = nExtOffset;
    TCHAR szTemp[MAX_PATH + 1];

    int nNewExt = lstrlen(pszFile);

    //
    //  If no extension, point at the end of the file name.
    //
    if (!nExtOffset)
    {
        nExtOffset = nNewExt;
    }

    //
    //  HACK: We could have a link that points to another link that points to
    //  another link, ..., that points back to the original file.  We will not
    //  loop more than NUM_LINKLOOPS times before giving up.

    int nLoop = NUM_LINKLOOPS;

    if (Flags & (OKBUTTON_NODEFEXT | OKBUTTON_QUOTED))
    {
        goto VerifyTheName;
    }

    if (bHasExt)
    {
        if (IsKnownExtension(pszFile + nExtOffset))
        {
            goto VerifyTheName;
        }

        //
        //  Don't attempt 2 extensions on SFN volume.
        //
        CDPathQualify(pszFile, pszPathName);
        if (!IsLFNDrive(pszPathName))
        {
            goto VerifyTheName;
        }
    }

    bGetOut = FALSE;

    if ((LPTSTR)pszDefExt &&
        ((DWORD)nNewExt + lstrlen(pszDefExt) < lpOFN->nMaxFile))
    {
        bAddExt = TRUE;

        //
        //  Note that we check lpstrDefExt to see if they want an automatic
        //  extension, but actually copy pszDefExt.
        //
        AppendExt(pszFile, pszDefExt, FALSE);

        //
        //  So we've added the default extension.  If there's a directory
        //  that matches this name, all attempts to open/create the file
        //  will fail, so simply change to the directory as if they had
        //  typed it in.  Note that by putting this test here, if there
        //  was a directory without the extension, we would have already
        //  switched to it.
        //

VerifyTheName:
        //
        //  Note that this also works for a UNC name, even on a net that
        //  does not support using UNC's directly.  It will also do the
        //  right thing for links to things.  We do not validate if we
        //  have not dereferenced any links, since that should have
        //  already been done.
        //
        if (bTryAsDir && SetDirRetry(pszFile, nLoop == NUM_LINKLOOPS))
        {
            return (FE_CHANGEDDIR);
        }

        *pnErrCode = VerifyOpen(pszFile, pszPathName);

        if (*pnErrCode == 0 || *pnErrCode == OF_SHARINGVIOLATION)
        {
            //
            //  This may be a link to something, so we should try to
            //  resolve it.
            //
            if (!(lpOFN->Flags & OFN_NODEREFERENCELINKS) && nLoop > 0)
            {
                --nLoop;

                LPITEMIDLIST pidl;
                IShellFolder *psf = NULL;
                DWORD dwAttr = SFGAO_LINK;
                HRESULT hRes;

                //
                //  ILCreateFromPath is slow (especially on a Net path),
                //  so just try to parse the name in the current folder if
                //  possible.
                //
                if (nFileOffset || nLoop < NUM_LINKLOOPS - 1)
                {
                    LPITEMIDLIST pidlTemp;
                    hRes = SHILCreateFromPath(pszPathName, &pidlTemp, &dwAttr);
                    
                    //We are getting a pidl corresponding to a path. Get the IShellFolder corresponding to this pidl
                    // to pass it to ResolveLink
                    if (SUCCEEDED(hRes))
                    {
                        LPCITEMIDLIST pidlLast;
                        if (SUCCEEDED(hRes = CDBindToIDListParent(pidlTemp, IID_IShellFolder, (void **)&psf, (LPCITEMIDLIST *)&pidlLast)))
                        {
                            //Get the child pidl relative to the IShellFolder
                            pidl = ILClone(pidlLast);
                        }
                        ILFree(pidlTemp);
                    }
                }
                else
                {
                    WCHAR wszDisplayName[MAX_PATH + 1];
                    ULONG chEaten;

                    SHTCharToUnicode(pszFile, wszDisplayName , ARRAYSIZE(wszDisplayName));

                    hRes = psfCurrent->ParseDisplayName( NULL,
                                                         NULL,
                                                         wszDisplayName,
                                                         &chEaten,
                                                         &pidl,
                                                         &dwAttr );
                }

                if (SUCCEEDED(hRes))
                {

                    if (dwAttr & SFGAO_LINK)
                    {
                        SHTCUTINFO  info;

                        info.dwAttr      = 0;
                        info.fReSolve    = FALSE;
                        info.pszLinkFile = szTemp;
                        info.cchFile     = ARRAYSIZE(szTemp);
                        info.ppidl       = NULL; 
                        
                        //psf can be NULL in which case ResolveLink uses psfCurrent IShellFolder
                        if (ResolveLink(pidl,&info, psf) == S_OK)
                        {
                            //
                            //  It was a link, and it "dereferenced" to something,
                            //  so we should try again with that new file.
                            //
                            lstrcpy(pszFile, szTemp);

                            if (pidl)
                            {
                                SHFree(pidl);
                            }

                            if (psf)
                            {
                                psf->Release();
                                psf = NULL;
                            }

                            goto VerifyTheName;
                        }
                    }

                    if (pidl)
                    {
                        SHFree(pidl);
                    }

                    if (psf)
                    {
                        psf->Release();
                        psf = NULL;
                    }
                }
            }

            return (FE_FOUNDNAME);
        }

        if (bGetOut ||
            (*pnErrCode != OF_FILENOTFOUND && *pnErrCode != OF_PATHNOTFOUND))
        {
            return (FE_FILEERR);
        }

        if (bSave)
        {
            //
            //  Do no more work if creating a new file.
            //
            return (FE_FOUNDNAME);
        }
    }

    //
    //  Make sure we do not loop forever.
    //
    bGetOut = TRUE;

    if (bSave)
    {
        //
        //  Do no more work if creating a new file.
        //
        goto VerifyTheName;
    }

    pszFile[nNewExt] = CHAR_NULL;

    if (bTryAsDir && nFileOffset)
    {
        TCHAR cSave = *(pszFile + nFileOffset);
        *(pszFile + nFileOffset) = CHAR_NULL;

        //
        //  We need to have the view on the dir with the file to do the
        //  next steps.
        //
        BOOL bOK = JumpToPath(pszFile);
        *(pszFile + nFileOffset) = cSave;

        if (!psv)
        {
            //
            //  We're dead.
            //
            return (FE_OUTOFMEM);
        }

        if (bOK)
        {
            lstrcpy(pszFile, pszFile + nFileOffset);
            nNewExt -= nFileOffset;
            SetEditFile(pszFile, TRUE);
        }
        else
        {
            *pnErrCode = OF_PATHNOTFOUND;
            return (FE_FILEERR);
        }
    }

    EnumItemObjects(SVGIO_ALLVIEW, FindNameEnumCB, (LPARAM)&fns);
    switch (fns.uRet)
    {
        case ( FE_INVALID_VALUE ) :
        {
            break;
        }
        case ( FE_FOUNDNAME ) :
        {
            goto VerifyTheName;
        }
        default :
        {
            uRet = fns.uRet;
            goto VerifyAndRet;
        }
    }

#ifdef FIND_FILES_NOT_IN_VIEW
    //
    //  We still have not found a match, so try enumerating files we cannot
    //  see.
    //
    int nFilterLen;

    nFilterLen = lstrlen(szLastFilter);
    if (nFilterLen + nNewExt + ARRAYSIZE(szDotStar) < ARRAYSIZE(szLastFilter))
    {
        TCHAR szSaveFilter[ARRAYSIZE(szLastFilter)];

        lstrcpy(szSaveFilter, szLastFilter);

        //
        //  Add "Joe.*" to the current filter and refresh.
        //
        szLastFilter[nFilterLen] = CHAR_SEMICOLON;
        lstrcpy(szLastFilter + nFilterLen + 1, pszFile);
        lstrcat(szLastFilter, szDotStar);

        HANDLE hf;
        WIN32_FIND_DATA fd;

        //
        //  Make sure we are in a FileSystem folder, and then see if at least
        //  one file named "Joe.*" exists.
        //
        //  Note we always set the current directory.
        //
        if ((pCurrentLocation->dwAttrs & SFGAO_FILESYSTEM) &&
            (hf = FindFirstFile( szLastFilter + nFilterLen + 1,
                                 &fd)) != INVALID_HANDLE_VALUE)
        {
            psv->Refresh();

            fns.pidlFound = NULL;
            EnumItemObjects(SVGIO_ALLVIEW, FindNameEnumCB, (LPARAM)&fns);

            FindClose(hf);
        }

        //
        //  We must not restore the filter until AFTER getting the
        //  EnumItemObjects in case there is a background thread doing the
        //  enumeration.  ALLVIEW should cause the threads to sync up before
        //  returning.
        //
        lstrcpy(szLastFilter, szSaveFilter);

        switch (fns.uRet)
        {
            case ( FE_INVALID_VALUE ) :
            {
                break;
            }
            case ( FE_FOUNDNAME ) :
            {
                goto VerifyTheName;
            }
            default :
            {
                uRet = fns.uRet;
                goto VerifyAndRet;
            }
        }
    }
#endif

    if (bAddExt)
    {
        //
        //  Before we fail, check to see if the file typed sans default
        //  extension exists.
        //
        *pnErrCode = VerifyOpen(pszFile, pszPathName);
        if (*pnErrCode == 0 || *pnErrCode == OF_SHARINGVIOLATION)
        {
            //
            //  We will never hit this case for links (because they
            //  have registered extensions), so we don't need
            //  to goto VerifyTheName (which also calls VerifyOpen again).
            //
            return (FE_FOUNDNAME);
        }

        //
        //  I still can't find it?  Try adding the default extension and
        //  return failure.
        //
        AppendExt(pszFile, pszDefExt, FALSE);
    }

    uRet = FE_FILEERR;

VerifyAndRet:
    *pnErrCode = VerifyOpen(pszFile, pszPathName);
    return (uRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::SetDirRetry
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::SetDirRetry(
    LPTSTR pszDir,
    BOOL bNoValidate)
{
    if (SetCurrentDirectory(pszDir))
    {
JumpThere:
        JumpToPath(TEXT("."));
        return (TRUE);
    }

    if (bNoValidate || !IsUNC(pszDir))
    {
        return (FALSE);
    }


    //
    //  It may have been a password problem, so try to add the connection.
    //  Note that if we are on a net that does not support CD'ing to UNC's
    //  directly, this call will connect it to a drive letter.
    //
    if (!SHValidateUNC(hwndDlg, pszDir, 0))
    {
        switch (GetLastError())
        {
            case ERROR_CANCELLED:
            {
                //
                //  We don't want to put up an error message if they
                //  canceled the password dialog.
                //
                return (TRUE);
            }

            case ERROR_NETWORK_UNREACHABLE:
            {
                LPTSTR lpMsgBuf;
                TCHAR szTitle[MAX_PATH];
                FormatMessage(     
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                    FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_IGNORE_INSERTS,    
                    NULL,
                    GetLastError(),
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                    (LPTSTR) &lpMsgBuf,    
                    0,    
                    NULL );
                    
                GetWindowText(hwndDlg, szTitle, ARRAYSIZE(szTitle));
                MessageBox(NULL, lpMsgBuf, szTitle, MB_OK | MB_ICONINFORMATION );
                // Free the buffer.
                LocalFree( lpMsgBuf );
                return (TRUE);
            }

            default:
            {
                //
                //  Some other error we don't know about.
                //
                return (FALSE);
            }
        }
    }

    //
    //  We connected to it, so try to switch to it again.
    //
    if (SetCurrentDirectory(pszDir))
    {
        goto JumpThere;
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::MultiSelectOKButton
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::MultiSelectOKButton(
    LPCTSTR pszFiles,
    OKBUTTONFLAGS Flags)
{
    TCHAR szPathName[MAX_PATH];
    int nErrCode;
    LPTSTR pchRead, pchWrite, lpCurDir;
    UINT cch, cchCurDir, cchFiles;

    //
    //  This doesn't really mean anything for multiselection.
    //
    lpOFN->nFileExtension = 0;

    if (!lpOFN->lpstrFile)
    {
        return (TRUE);
    }

    SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  Check for space for first full path element.
    //
    if ((lpOFN->Flags & OFN_ENABLEINCLUDENOTIFY) && lstrlen(pszObjectCurDir))
    {
        lpCurDir = pszObjectCurDir;
    }
    else
    {
        lpCurDir = szCurDir;
    }
    cchCurDir = lstrlen(lpCurDir) + 1;
    cchFiles = lstrlen(pszFiles) + 1;
    cch = cchCurDir + cchFiles;

    if (cch > (UINT)lpOFN->nMaxFile)
    {
        //
        //  Buffer is too small, so return the size of the buffer
        //  required to hold the string.
        //
        //  cch is not really the number of characters needed, but it
        //  should be close.
        //
        StoreLengthInString((LPTSTR)lpOFN->lpstrFile, (UINT)lpOFN->nMaxFile, (UINT)cch);
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        return (TRUE);
    }

    TEMPSTR psFiles(cchFiles + FILE_PADDING);
    pchRead = psFiles;
    if (!pchRead)
    {
        //
        //  Out of memory.
        //  ISSUE: There should be some sort of error message here.
        //
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        return (FALSE);
    }

    //
    //  Copy in the full path as the first element.
    //
    lstrcpy(lpOFN->lpstrFile, lpCurDir);

    //
    //  Set nFileOffset to 1st file.
    //
    lpOFN->nFileOffset = (WORD) cchCurDir;
    pchWrite = lpOFN->lpstrFile + cchCurDir;

    //
    //  We know there is enough room for the whole string.
    //
    lstrcpy(pchRead, pszFiles);

    //
    //  This should only compact the string.
    //
    if (!ConvertToNULLTerm(pchRead))
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        return (FALSE);
    }

    for ( ; *pchRead; pchRead += lstrlen(pchRead) + 1)
    {
        int nFileOffset, nExtOffset;
        TCHAR szBasicPath[MAX_PATH];

        lstrcpy(szBasicPath, pchRead);

        nFileOffset = ParseFileNew(szBasicPath, &nExtOffset, FALSE, TRUE);

        if (nFileOffset < 0)
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            InvalidFileWarningNew(hwndDlg, pchRead, nFileOffset);
            return (FALSE);
        }

        //
        //  Pass in 0 for the file offset to make sure we do not switch
        //  to another folder.
        //
        switch (FindNameInView( szBasicPath,
                                Flags,
                                szPathName,
                                nFileOffset,
                                nExtOffset,
                                &nErrCode,
                                FALSE ))
        {
            case ( FE_OUTOFMEM ) :
            case ( FE_CHANGEDDIR ) :
            {
                SetCursor(LoadCursor(NULL, IDC_ARROW));
                return (FALSE);
            }
            case ( FE_TOOMANY ) :
            {
                SetCursor(LoadCursor(NULL, IDC_ARROW));
                CDMessageBox( hwndDlg,
                              iszTooManyFiles,
                              MB_OK | MB_ICONEXCLAMATION,
                              pchRead );
                return (FALSE);
            }
            default :
            {
                break;
            }
        }

        if ( nErrCode &&
             ( (lpOFN->Flags & OFN_FILEMUSTEXIST) ||
               (nErrCode != OF_FILENOTFOUND) ) &&
             ( (lpOFN->Flags & OFN_PATHMUSTEXIST) ||
               (nErrCode != OF_PATHNOTFOUND) ) &&
             ( !(lpOFN->Flags & OFN_SHAREAWARE) ||
               (nErrCode != OF_SHARINGVIOLATION) ) )
        {
            if ((nErrCode == OF_SHARINGVIOLATION) && hSubDlg)
            {
                int nShareCode = CD_SendShareNotify( hSubDlg,
                                                     hwndDlg,
                                                     szPathName,
                                                     lpOFN,
                                                     lpOFI );

                if (nShareCode == OFN_SHARENOWARN)
                {
                    SetCursor(LoadCursor(NULL, IDC_ARROW));
                    return (FALSE);
                }
                else if (nShareCode == OFN_SHAREFALLTHROUGH)
                {
                    goto EscapedThroughShare;
                }
                else
                {
                    //
                    //  They might not have handled the notification, so try
                    //  the registered message.
                    //
                    nShareCode = CD_SendShareMsg(hSubDlg, szPathName, lpOFI->ApiType);

                    if (nShareCode == OFN_SHARENOWARN)
                    {
                        SetCursor(LoadCursor(NULL, IDC_ARROW));
                        return (FALSE);
                    }
                    else if (nShareCode == OFN_SHAREFALLTHROUGH)
                    {
                        goto EscapedThroughShare;
                    }
                }
            }
            else if (nErrCode == OF_ACCESSDENIED)
            {
                szPathName[0] |= 0x60;
                if (GetDriveType(szPathName) != DRIVE_REMOVABLE)
                {
                    nErrCode = OF_NETACCESSDENIED;
                }
            }

            //
            //  ISSUE: These will never be set.
            //
            if ((nErrCode == OF_WRITEPROTECTION) ||
                (nErrCode == OF_DISKFULL)        ||
                (nErrCode == OF_DISKFULL2)       ||
                (nErrCode == OF_ACCESSDENIED))
            {
                *pchRead = szPathName[0];
            }

MultiWarning:
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            InvalidFileWarningNew(hwndDlg, pchRead, nErrCode);
            return (FALSE);
        }

EscapedThroughShare:
        if (nErrCode == 0)
        {
            //
            //  Successfully opened.
            //
            if ((lpOFN->Flags & OFN_NOREADONLYRETURN) &&
                (GetFileAttributes(szPathName) & FILE_ATTRIBUTE_READONLY))
            {
                nErrCode = OF_LAZYREADONLY;
                goto MultiWarning;
            }

            if ((bSave || (lpOFN->Flags & OFN_NOREADONLYRETURN)) &&
                (nErrCode = WriteProtectedDirCheck(szPathName)))
            {
                goto MultiWarning;
            }

            if (lpOFN->Flags & OFN_OVERWRITEPROMPT)
            {
                if (bSave && !FOkToWriteOver(hwndDlg, szPathName))
                {
                    if (bUseCombo)
                    {
                         PostMessage( hwndDlg,
                                     WM_NEXTDLGCTL,
                                     (WPARAM)GetDlgItem(hwndDlg, cmb13),
                                     1 );
                    }
                    else
                    {

                          PostMessage( hwndDlg,
                                     WM_NEXTDLGCTL,
                                     (WPARAM)GetDlgItem(hwndDlg, edt1),
                                     1 );
                    }
                    SetCursor(LoadCursor(NULL, IDC_ARROW));
                    return (FALSE);
                }
            }
        }

        //
        //  Add some more in case the file name got larger.
        //
        cch += lstrlen(szBasicPath) - lstrlen(pchRead);
        if (cch > (UINT)lpOFN->nMaxFile)
        {
            //
            //  Buffer is too small, so return the size of the buffer
            //  required to hold the string.
            //
            if (lpOFN->nMaxFile >= 3)
            {
#ifdef UNICODE
                lpOFN->lpstrFile[0] = (TCHAR)LOWORD(cch);
                lpOFN->lpstrFile[1] = (TCHAR)HIWORD(cch);
#else
                lpOFN->lpstrFile[0] = (TCHAR)LOBYTE(cch);
                lpOFN->lpstrFile[1] = (TCHAR)HIBYTE(cch);
#endif
                lpOFN->lpstrFile[2] = CHAR_NULL;
            }
            else
            {
#ifdef UNICODE
                lpOFN->lpstrFile[0] = (TCHAR)LOWORD(cch);
                if (lpOFN->nMaxFile == 2)
                {
                    lpOFN->lpstrFile[1] = (TCHAR)HIWORD(cch);
                }
#else
                lpOFN->lpstrFile[0] = LOBYTE(cch);
                if (lpOFN->nMaxFile == 2)
                {
                    lpOFN->lpstrFile[1] = HIBYTE(cch);
                }
#endif
            }

            SetCursor(LoadCursor(NULL, IDC_ARROW));
            return (TRUE);
        }

        //
        //  We already know we have anough room.
        //
        lstrcpy(pchWrite, szBasicPath);
        pchWrite += lstrlen(pchWrite) + 1;
    }

    //
    //  double-NULL terminate.
    //
    *pchWrite = CHAR_NULL;

    SetCursor(LoadCursor(NULL, IDC_ARROW));
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  StoreLengthInString
//
////////////////////////////////////////////////////////////////////////////

void StoreLengthInString(
    LPTSTR lpStr,
    UINT cchLen,
    UINT cchStore)
{
    if (cchLen >= 3)
    {
        //
        //  For single file requests, we will never go over 64K
        //  because the filesystem is limited to 256.
        //
#ifdef UNICODE
        lpStr[0] = (TCHAR)LOWORD(cchStore);
        lpStr[1] = CHAR_NULL;
#else
        lpStr[0] = LOBYTE(cchStore);
        lpStr[1] = HIBYTE(cchStore);
        lpStr[2] = 0;
#endif
    }
    else
    {
#ifdef UNICODE
        lpStr[0] = (TCHAR)LOWORD(cchStore);
        if (cchLen == 2)
        {
            lpStr[1] = (TCHAR)HIWORD(cchStore);
        }
#else
        lpStr[0] = LOBYTE(cchStore);
        if (cchLen == 2)
        {
            lpStr[1] = HIBYTE(cchStore);
        }
#endif
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::CheckForRestrictedFolder
//
////////////////////////////////////////////////////////////////////////////
BOOL CFileOpenBrowser::CheckForRestrictedFolder(LPTSTR lpszPath, int nFileOffset)
{  
    TCHAR szPath[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    LPITEMIDLIST pidl;
    BOOL bPidlAllocated = FALSE;
    BOOL bRet = FALSE;
    DWORD dwAttrib = SFGAO_FILESYSTEM;
    HRESULT hr = S_OK;

    if (nFileOffset > 0)
    {
        //There's a path in the given filename. Get the directory part of the filename.
        lstrcpy(szTemp, lpszPath);                
        szTemp[nFileOffset] = 0;

        //The directory path might be a relative path. Resolve it to get fully qualified path.
        CDPathQualify(szTemp, szPath);

        //Create the pidl for this path as well as get the attributes.
        hr = SHILCreateFromPath(szPath, &pidl, &dwAttrib);
        if (SUCCEEDED(hr))
        {
            bPidlAllocated = TRUE;
        }
        else
        {
            // WE are failing b'cos the user might have typed some path which doesn't exist.
            // if the path doesn't exist then it can't be one of the directory we are trying restrict.
            // let's bail out and let the code that checks for valid path take care of it
            return bRet;
        }
    }
    else
    {
        pidl = pCurrentLocation->pidlFull;  
        CDGetAttributesOf(pidl, &dwAttrib);
    }

    
    // 1. We cannot save to the non file system folders.
    // 2. We should not allow user to save in recent files folder as the file might get deleted.
    if (!(dwAttrib & SFGAO_FILESYSTEM) || _IsRecentFolder(pidl) )
    {        
        HCURSOR hcurOld = SetCursor(LoadCursor(NULL, IDC_ARROW));
        CDMessageBox(hwndDlg, iszSaveRestricted, MB_OK | MB_ICONEXCLAMATION, (LPTSTR)lpszPath);
        SetCursor(hcurOld);
        bRet = TRUE;
     }

    if (bPidlAllocated)
    {
        ILFree(pidl);
    }
    
    return bRet;
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OKButtonPressed
//
//  Process the OK button being pressed.  This may involve jumping to a path,
//  changing the filter, actually choosing a file to open or save as, or who
//  knows what else.
//
//  Note:  There are 4 cases for validation of a file name:
//    1) OFN_NOVALIDATE        Allows invalid characters
//    2) No validation flags   No invalid characters, but path need not exist
//    3) OFN_PATHMUSTEXIST     No invalid characters, path must exist
//    4) OFN_FILEMUSTEXIST     No invalid characters, path & file must exist
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::OKButtonPressed(
    LPCTSTR pszFile,
    OKBUTTONFLAGS Flags)
{
    TCHAR szExpFile[MAX_PATH];
    TCHAR szPathName[MAX_PATH];
    TCHAR szBasicPath[MAX_PATH];
    LPTSTR pExpFile = NULL;
    int nErrCode;
    ECODE eCode = ECODE_S_OK;
    int cch;
    int nFileOffset, nExtOffset, nOldExt;
    TCHAR ch;
    BOOL bAddExt = FALSE;
    BOOL bUNCName = FALSE;
    int nTempOffset;
    BOOL bIsDir;
    BOOL bRet = FALSE;
    WAIT_CURSOR w;

    if (bSelIsObject)
    {
        if ((INT)(lstrlen(pszObjectPath) + 1) <= (INT)lpOFN->nMaxFile)
        {
            lstrcpy((LPTSTR)lpOFN->lpstrFile, (LPTSTR)pszObjectPath);
        }
        else
        {
            StoreLengthInString( lpOFN->lpstrFile,
                                 lpOFN->nMaxFile,
                                 lstrlen(pszObjectPath) + 1 );
        }
    }

    //
    //  Expand any environment variables.
    //
    if ((cch = LOWORD(lpOFN->nMaxFile)) > MAX_PATH)
    {
        pExpFile = (LPTSTR)LocalAlloc(LPTR, (cch * sizeof(TCHAR)));
    }
    if (!pExpFile)
    {
        pExpFile = szExpFile;
        cch = MAX_PATH;
    }
    ExpandEnvironmentStrings(pszFile, pExpFile, cch);
    pExpFile[cch - 1] = 0;

    //
    //  See if we're in Multi Select mode.
    //
    if (StrChr(pExpFile, CHAR_QUOTE) && (lpOFN->Flags & OFN_ALLOWMULTISELECT))
    {
        bRet = MultiSelectOKButton(pExpFile, Flags);
        goto ReturnFromOKButtonPressed;
    }

    //
    //  We've only got a single selection...if we're in
    //  multi-select mode & it's an object, we need to do a little
    //  work before continuing...
    //
    if ((lpOFN->Flags & OFN_ALLOWMULTISELECT) && bSelIsObject)
    {
        LocalFree(pExpFile);
        pExpFile = pszObjectPath;
    }

#ifdef UNICODE
    if ((pExpFile[1] == CHAR_COLON) || DBL_BSLASH(pExpFile))
#else
    if ((!IsDBCSLeadByte(pExpFile[0]) && (pExpFile[1] == CHAR_COLON)) ||
        DBL_BSLASH(pExpFile))
#endif
    {
        //
        //  If a drive or UNC was specified, use it.
        //
        lstrcpyn(szBasicPath, pExpFile, ARRAYSIZE(szBasicPath) - 1);
        nTempOffset = 0;
    }
    else
    {
        //
        //  Grab the directory from the listbox.
        //
        cch = GetDirectoryFromLB(szBasicPath, &nTempOffset);

        if (pExpFile[0] == CHAR_BSLASH)
        {
            //
            //  If a directory from the root was given, put it
            //  immediately off the root (\\server\share or a:).
            //
            lstrcpyn( szBasicPath + nTempOffset,
                      pExpFile,
                      ARRAYSIZE(szBasicPath) - nTempOffset - 1 );
        }
        else
        {
            //
            //  Tack the file to the end of the path.
            //
            lstrcpyn(szBasicPath + cch, pExpFile, ARRAYSIZE(szBasicPath) - cch - 1);
        }
    }

    nFileOffset = ParseFileOld(szBasicPath, &nExtOffset, &nOldExt, FALSE, TRUE);

    if (nFileOffset == PARSE_EMPTYSTRING)
    {
        if (psv)
        {
            psv->Refresh();
        }
        goto ReturnFromOKButtonPressed;
    }
    else if ((nFileOffset != PARSE_DIRECTORYNAME) &&
             (lpOFN->Flags & OFN_NOVALIDATE))
    {
        if (bSelIsObject)
        {
            lpOFN->nFileOffset = lpOFN->nFileExtension = 0;
        }
        else
        {
            lpOFN->nFileOffset = (WORD) nFileOffset;
            lpOFN->nFileExtension = (WORD) nOldExt;
        }

        if (lpOFN->lpstrFile)
        {
            cch = lstrlen(szBasicPath);
            if (cch <= LOWORD(lpOFN->nMaxFile))
            {
                lstrcpy(lpOFN->lpstrFile, szBasicPath);
            }
            else
            {
                //
                //  Buffer is too small, so return the size of the buffer
                //  required to hold the string.
                //
                StoreLengthInString(lpOFN->lpstrFile, lpOFN->nMaxFile, cch);
            }
        }
        bRet = TRUE;
        goto ReturnFromOKButtonPressed;
    }
    else if (nFileOffset == PARSE_DIRECTORYNAME)
    {
        //
        //  See if it ends in slash.
        //
        if (nExtOffset > 0)
        {
            if (ISBACKSLASH(szBasicPath, nExtOffset - 1))
            {
                //
                //  "\\server\share\" and "c:\" keep the trailing backslash,
                //  all other paths remove the trailing backslash. Note that
                //  we don't remove the slash if the user typed the path directly
                //  (nTempOffset is 0 in that case).
                //
                if ((nExtOffset != 1) &&
                    (szBasicPath[nExtOffset - 2] != CHAR_COLON) &&
                    (nExtOffset != nTempOffset + 1))
                {
                    szBasicPath[nExtOffset - 1] = CHAR_NULL;
                }
            }
            else if ( (szBasicPath[nExtOffset - 1] == CHAR_DOT) &&
                      ( (szBasicPath[nExtOffset - 2] == CHAR_DOT) ||
                        ISBACKSLASH(szBasicPath, nExtOffset - 2) ) &&
                      IsUNC(szBasicPath) )
            {
                //
                //  Add a trailing slash to UNC paths ending with ".." or "\."
                //
                szBasicPath[nExtOffset] = CHAR_BSLASH;
                szBasicPath[nExtOffset + 1] = CHAR_NULL;
            }
        }

        //
        //  Fall through to Directory Checking.
        //
    }
    else if (nFileOffset < 0)
    {
        nErrCode = nFileOffset;

        //
        //  I don't recognize this, so try to jump there.
        //  This is where servers get processed.
        //
        if (JumpToPath(szBasicPath))
        {
            goto ReturnFromOKButtonPressed;
        }

        //
        //  Fall through to the rest of the processing to warn the user.
        //

Warning:
        if (bUNCName)
        {
            cch = lstrlen(szBasicPath) - 1;
            if ((szBasicPath[cch] == CHAR_BSLASH) &&
                (szBasicPath[cch - 1] == CHAR_DOT) &&
                (ISBACKSLASH(szBasicPath, cch - 2)))
            {
                szBasicPath[cch - 2] = CHAR_NULL;
            }
        }

        // For file names of form c:filename.txt , we hacked and changed it to c:.\filename.txt
        // check for that hack and if so change the file name back as it was given by user.        
        else if ((nFileOffset == 2) && (szBasicPath[2] == CHAR_DOT))
        {
            lstrcpy(szBasicPath + 2, szBasicPath + 4);
        }

        //  If the disk is not a floppy and they tell me there's no
        //  disk in the drive, don't believe them.  Instead, put up the
        //  error message that they should have given us.  (Note that the
        //  error message is checked first since checking the drive type
        //  is slower.)
        //

        //
        //  I will assume that if we get error 0 or 1 or removable
        //  that we will assume removable.
        //
        if (nErrCode == OF_ACCESSDENIED)
        {
            TCHAR szD[4];

            szPathName[0] |= 0x60;
            szD[0] = *szBasicPath;
            szD[1] = CHAR_COLON;
            szD[2] = CHAR_BSLASH;
            szD[3] = 0;
            if (bUNCName || GetDriveType(szD) <= DRIVE_REMOVABLE)
            {
                nErrCode = OF_NETACCESSDENIED;
            }
        }

        if ((nErrCode == OF_WRITEPROTECTION) ||
            (nErrCode == OF_DISKFULL)        ||
            (nErrCode == OF_DISKFULL2)       ||
            (nErrCode == OF_ACCESSDENIED))
        {
            szBasicPath[0] = szPathName[0];
        }
        SetCursor(LoadCursor(NULL, IDC_ARROW));
         InvalidFileWarningNew(hwndDlg, szBasicPath, nErrCode);
        goto ReturnFromOKButtonPressed;
    }

    //
    //  We either have a file pattern or a real file.
    //    If it's a UNC name
    //        (1) Fall through to file name testing
    //    Else if it's a directory
    //        (1) Add on default pattern
    //        (2) Act like it's a pattern (goto pattern (1))
    //    Else if it's a pattern
    //        (1) Update everything
    //        (2) display files in whatever dir we're now in
    //    Else if it's a file name!
    //        (1) Check out the syntax
    //        (2) End the dialog given OK
    //        (3) Beep/message otherwise
    //

    //
    //  Directory ?? this must succeed for relative paths.
    //  NOTE: It won't succeed for relative paths that walk off the root.
    //
    bIsDir = SetDirRetry(szBasicPath);

    //
    //  We need to parse again in case SetDirRetry changed a UNC path to use
    //  a drive letter.
    //
    nFileOffset = ParseFileOld(szBasicPath, &nExtOffset, &nOldExt, FALSE, TRUE);

    nTempOffset = nFileOffset;

    if (bIsDir)
    {
        goto ReturnFromOKButtonPressed;
    }
    else if (IsUNC(szBasicPath))
    {
        //
        //  UNC Name.
        //
        bUNCName = TRUE;
    }
    else if (nFileOffset > 0)
    {
        //
        //  There is a path in the string.
        //
        if ((nFileOffset > 1) &&
            (szBasicPath[nFileOffset - 1] != CHAR_COLON) &&
            (szBasicPath[nFileOffset - 2] != CHAR_COLON))
        {
            nTempOffset--;
        }
        GetCurrentDirectory(ARRAYSIZE(szBuf), szBuf);
        ch = szBasicPath[nTempOffset];
        szBasicPath[nTempOffset] = 0;


        if (SetCurrentDirectory(szBasicPath))
        {
            SetCurrentDirectory(szBuf);
        }
        else
        {
            switch (GetLastError())
            {
                case ( ERROR_NOT_READY ) :
                {
                    eCode = ECODE_BADDRIVE;
                    break;
                }
                default :
                {
                    eCode = ECODE_BADPATH;
                    break;
                }
            }
        }
        szBasicPath[nTempOffset] = ch;
    }
    else if (nFileOffset == PARSE_DIRECTORYNAME)
    {
        TCHAR szD[4];

        szD[0] = *szBasicPath;
        szD[1] = CHAR_COLON;
        szD[2] = CHAR_BSLASH;
        szD[3] = 0;
        if (PathFileExists(szD))
        {
            eCode = ECODE_BADPATH;
        }
        else
        {
            eCode = ECODE_BADDRIVE;
        }
    }

    //
    //  Was there a path and did it fail?
    //
    if ( !bUNCName &&
         nFileOffset &&
         eCode != ECODE_S_OK &&
         (lpOFN->Flags & OFN_PATHMUSTEXIST) )
    {
        if (eCode == ECODE_BADPATH)
        {
            nErrCode = OF_PATHNOTFOUND;
        }
        else if (eCode == ECODE_BADDRIVE)
        {
            TCHAR szD[4];

            //
            //  We can get here without performing an OpenFile call.  As
            //  such the szPathName can be filled with random garbage.
            //  Since we only need one character for the error message,
            //  set szPathName[0] to the drive letter.
            //
            szPathName[0] = szD[0] = *szBasicPath;
            szD[1] = CHAR_COLON;
            szD[2] = CHAR_BSLASH;
            szD[3] = 0;
            switch (GetDriveType(szD))
            {
                case ( DRIVE_REMOVABLE ) :
                {
                    nErrCode = ERROR_NOT_READY;
                    break;
                }
                case ( 1 ) :
                {
                    //
                    //  Drive does not exist.
                    //
                    nErrCode = OF_NODRIVE;
                    break;
                }
                default :
                {
                    nErrCode = OF_PATHNOTFOUND;
                }
            }
        }
        else
        {
            nErrCode = OF_FILENOTFOUND;
        }
        goto Warning;
    }

    //
    //  Full pattern?
    //
    if (IsWild(szBasicPath + nFileOffset))
    {
        if (!bUNCName)
        {
            SetCurrentFilter(szBasicPath + nFileOffset, Flags);
            if (nTempOffset)
            {
                szBasicPath[nTempOffset] = 0;
                JumpToPath(szBasicPath);
            }
            else if (psv)
            {
                psv->Refresh();
            }
            goto ReturnFromOKButtonPressed;
        }
        else
        {
            SetCurrentFilter(szBasicPath + nFileOffset, Flags);

            szBasicPath[nFileOffset] = CHAR_NULL;
            JumpToPath(szBasicPath);

            goto ReturnFromOKButtonPressed;
        }
    }

    if (PortName(szBasicPath + nFileOffset))
    {
        nErrCode = OF_PORTNAME;
        goto Warning;
    }

    // In save as dialog check to see if the folder user trying to save a file is 
    // a restricted folder (Network Folder). if so bail out
    if (bSave && CheckForRestrictedFolder(szBasicPath, nFileOffset))
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        goto ReturnFromOKButtonPressed;
    }


    //
    //  Check if we've received a string in the form "C:filename.ext".
    //  If we have, convert it to the form "C:.\filename.ext".  This is done
    //  because the kernel will search the entire path, ignoring the drive
    //  specification after the initial search.  Making it include a slash
    //  causes kernel to only search at that location.
    //
    //  Note:  Only increment nExtOffset, not nFileOffset.  This is done
    //  because only nExtOffset is used later, and nFileOffset can then be
    //  used at the Warning: label to determine if this hack has occurred,
    //  and thus it can strip out the ".\" when putting up the error.
    //
    if ((nFileOffset == 2) && (szBasicPath[1] == CHAR_COLON))
    {
        lstrcpy(szBuf, szBasicPath + 2);
        lstrcpy(szBasicPath + 4, szBuf);
        szBasicPath[2] = CHAR_DOT;
        szBasicPath[3] = CHAR_BSLASH;
        nExtOffset += 2;
    }

    //
    //  Add the default extension unless filename ends with period or no
    //  default extension exists.  If the file exists, consider asking
    //  permission to overwrite the file.
    //
    //  NOTE: When no extension given, default extension is tried 1st.
    //  FindNameInView calls VerifyOpen before returning.
    //
    szPathName[0] = 0;
    switch (FindNameInView( szBasicPath,
                            Flags,
                            szPathName,
                            nFileOffset,
                            nExtOffset,
                            &nErrCode ))
    {
        case ( FE_OUTOFMEM ) :
        case ( FE_CHANGEDDIR ) :
        {
            goto ReturnFromOKButtonPressed;
        }
        case ( FE_TOOMANY ) :
        {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            CDMessageBox( hwndDlg,
                          iszTooManyFiles,
                          MB_OK | MB_ICONEXCLAMATION,
                          szBasicPath );
            goto ReturnFromOKButtonPressed;
        }
        default :
        {
            break;
        }
    }

    switch (nErrCode)
    {
        case ( 0 ) :
        {
            //
            //  Is the file read-only?
            //
            if ((lpOFN->Flags & OFN_NOREADONLYRETURN) &&
                (GetFileAttributes(szPathName) & FILE_ATTRIBUTE_READONLY))
            {
                nErrCode = OF_LAZYREADONLY;
                goto Warning;
            }


            if ((bSave || (lpOFN->Flags & OFN_NOREADONLYRETURN)) &&
                (nTempOffset = WriteProtectedDirCheck(szPathName)))
            {
                nErrCode = nTempOffset;
                goto Warning;
            }

            if (lpOFN->Flags & OFN_OVERWRITEPROMPT)
            {
                if (bSave && !FOkToWriteOver(hwndDlg, szPathName))
                {
                    if (bUseCombo)
                    {
                        PostMessage( hwndDlg,
                                     WM_NEXTDLGCTL,
                                     (WPARAM)GetDlgItem(hwndDlg, cmb13),
                                     1 );
                    }
                    else
                    {

                        PostMessage( hwndDlg,
                                     WM_NEXTDLGCTL,
                                     (WPARAM)GetDlgItem(hwndDlg, edt1),
                                     1 );
                    }
                    goto ReturnFromOKButtonPressed;
                }
            }
            if (nErrCode == OF_SHARINGVIOLATION)
            {
                goto SharingViolationInquiry;
            }
            break;
        }
        case ( OF_SHARINGVIOLATION ) :
        {
SharingViolationInquiry:
            //
            //  If the app is "share aware", fall through.
            //  Otherwise, ask the hook function.
            //
            if (!(lpOFN->Flags & OFN_SHAREAWARE))
            {
                if (hSubDlg)
                {
                    int nShareCode = CD_SendShareNotify( hSubDlg,
                                                         hwndDlg,
                                                         szPathName,
                                                         lpOFN,
                                                         lpOFI );
                    if (nShareCode == OFN_SHARENOWARN)
                    {
                        goto ReturnFromOKButtonPressed;
                    }
                    else if (nShareCode != OFN_SHAREFALLTHROUGH)
                    {
                        //
                        //  They might not have handled the notification,
                        //  so try the registered message.
                        //
                        nShareCode = CD_SendShareMsg(hSubDlg, szPathName, lpOFI->ApiType);
                        if (nShareCode == OFN_SHARENOWARN)
                        {
                            goto ReturnFromOKButtonPressed;
                        }
                        else if (nShareCode != OFN_SHAREFALLTHROUGH)
                        {
                            goto Warning;
                        }
                    }
                }
                else
                {
                    goto Warning;
                }
            }
            break;
        }
        case ( OF_FILENOTFOUND ) :
        case ( OF_PATHNOTFOUND ) :
        {
            if (!bSave)
            {
                //
                //  The file or path wasn't found.
                //  If this is a save dialog, we're ok, but if it's not,
                //  we're toast.
                //
                if (lpOFN->Flags & OFN_FILEMUSTEXIST)
                {
                    if (lpOFN->Flags & OFN_CREATEPROMPT)
                    {
                        int nCreateCode = CreateFileDlg(hwndDlg, szBasicPath);
                        if (nCreateCode != IDYES)
                        {
                            goto ReturnFromOKButtonPressed;
                        }
                    }
                    else
                    {
                        goto Warning;
                    }
                }
            }
            goto VerifyPath;
        }
        default :
        {
            if (!bSave)
            {
                goto Warning;
            }


            //
            //  The file doesn't exist.  Can it be created?  This is needed
            //  because there are many extended characters which are invalid
            //  which won't be caught by ParseFile.
            //
            //  Two more good reasons:  Write-protected disks & full disks.
            //
            //  BUT, if they don't want the test creation, they can request
            //  that we not do it using the OFN_NOTESTFILECREATE flag.  If
            //  they want to create files on a share that has
            //  create-but-no-modify privileges, they should set this flag
            //  but be ready for failures that couldn't be caught, such as
            //  no create privileges, invalid extended characters, a full
            //  disk, etc.
            //

VerifyPath:
            //
            //  Verify the path.
            //
            if (lpOFN->Flags & OFN_PATHMUSTEXIST)
            {
                if (!(lpOFN->Flags & OFN_NOTESTFILECREATE))
                {
                    HANDLE hf = CreateFile( szBasicPath,
                                            GENERIC_WRITE,
                                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                                            NULL,
                                            CREATE_ALWAYS,
                                            FILE_ATTRIBUTE_NORMAL,
                                            NULL );
                    if (hf != INVALID_HANDLE_VALUE)
                    {
                        CloseHandle(hf);

                        //
                        //  This test is here to see if we were able to
                        //  create it, but couldn't delete it.  If so,
                        //  warn the user that the network admin has given
                        //  him create-but-no-modify privileges.  As such,
                        //  the file has just been created, but we can't
                        //  do anything with it, it's of 0 size.
                        //
                        if (!DeleteFile(szBasicPath))
                        {
                            nErrCode = OF_CREATENOMODIFY;
                            goto Warning;
                        }
                    }
                    else
                    {
                        //
                        //  Unable to create it.
                        //
                        //  If it's not write-protection, a full disk,
                        //  network protection, or the user popping the
                        //  drive door open, assume that the filename is
                        //  invalid.
                        //
                        nErrCode = GetLastError();
                        switch (nErrCode)
                        {
                            case ( OF_WRITEPROTECTION ) :
                            case ( OF_DISKFULL ) :
                            case ( OF_DISKFULL2 ) :
                            case ( OF_NETACCESSDENIED ) :
                            case ( OF_ACCESSDENIED ) :
                            {
                                break;
                            }
                            default :
                            {
                                nErrCode = 0;
                                break;
                            }
                        }

                        goto Warning;
                    }
                }
            }
        }
    }

    nFileOffset = ParseFileOld(szPathName, &nExtOffset, &nOldExt, FALSE, TRUE);

    lpOFN->nFileOffset = (WORD) nFileOffset;
    lpOFN->nFileExtension = (WORD) nOldExt;

    lpOFN->Flags &= ~OFN_EXTENSIONDIFFERENT;
    if (lpOFN->lpstrDefExt && lpOFN->nFileExtension)
    {
        TCHAR szPrivateExt[MIN_DEFEXT_LEN];

        //
        //  Check against lpOFN->lpstrDefExt, not pszDefExt.
        //
        lstrcpyn(szPrivateExt, lpOFN->lpstrDefExt, MIN_DEFEXT_LEN);
        if (lstrcmpi(szPrivateExt, szPathName + nOldExt))
        {
            lpOFN->Flags |= OFN_EXTENSIONDIFFERENT;
        }
    }

    if (lpOFN->lpstrFile)
    {
        cch = lstrlen(szPathName) + 1;
        if (lpOFN->Flags & OFN_ALLOWMULTISELECT)
        {
            //
            //  Extra room for double-NULL.
            //
            ++cch;
        }

        if (cch <= LOWORD(lpOFN->nMaxFile))
        {
            lstrcpy(lpOFN->lpstrFile, szPathName);
            if (lpOFN->Flags & OFN_ALLOWMULTISELECT)
            {
                //
                //  Double-NULL terminate.
                //
                *(lpOFN->lpstrFile + cch - 1) = CHAR_NULL;
            }

            if (!(lpOFN->Flags & OFN_NOCHANGEDIR) && !bUNCName && nFileOffset)
            {
                TCHAR ch = lpOFN->lpstrFile[nFileOffset];
                lpOFN->lpstrFile[nFileOffset] = CHAR_NULL;
                SetCurrentDirectory(lpOFN->lpstrFile);
                lpOFN->lpstrFile[nFileOffset] = ch;
            }
        }
        else
        {
            //
            //  Buffer is too small, so return the size of the buffer
            //  required to hold the string.
            //
            if (lpOFN->nMaxFile >= 3)
            {
#ifdef UNICODE
                lpOFN->lpstrFile[0] = (TCHAR)LOWORD(cch);
                lpOFN->lpstrFile[1] = CHAR_NULL;
#else
                lpOFN->lpstrFile[0] = LOBYTE(cch);
                lpOFN->lpstrFile[1] = HIBYTE(cch);
                lpOFN->lpstrFile[2] = 0;
#endif
            }
            else
            {
#ifdef UNICODE
                lpOFN->lpstrFile[0] = (TCHAR)LOWORD(cch);
                if (lpOFN->nMaxFile == 2)
                {
                    lpOFN->lpstrFile[1] = (TCHAR)HIWORD(cch);
                }
#else
                lpOFN->lpstrFile[0] = LOBYTE(cch);
                if (lpOFN->nMaxFile == 2)
                {
                    lpOFN->lpstrFile[1] = HIBYTE(cch);
                }
#endif
            }
        }
    }


    if (!(lpOFN->Flags & OFN_DONTADDTORECENT) && !PathIsExe(szPathName))
    {
        SHAddToRecentDocs(SHARD_PATH, szPathName);
    }

    //
    //  File Title.
    //  Note that it's cut off at whatever the buffer length
    //    is, so if the buffer's too small, no notice is given.
    //
    if (lpOFN->lpstrFileTitle)
    {
        cch = lstrlen(szPathName + nFileOffset);
        if ((DWORD)cch >= lpOFN->nMaxFileTitle)
        {
#ifdef UNICODE
            szPathName[nFileOffset + lpOFN->nMaxFileTitle - 1] = CHAR_NULL;
#else
            EliminateString( szPathName + nFileOffset,
                             lpOFN->nMaxFileTitle - 1 );
#endif
        }
        lstrcpy(lpOFN->lpstrFileTitle, szPathName + nFileOffset);
    }

    if (!(lpOFN->Flags & OFN_HIDEREADONLY))
    {
        //
        //  Read-only checkbox visible?
        //
        if (IsDlgButtonChecked(hwndDlg, chx1))
        {
            lpOFN->Flags |=  OFN_READONLY;
        }
        else
        {
            lpOFN->Flags &= ~OFN_READONLY;
        }
    }

    bRet = TRUE;

ReturnFromOKButtonPressed:

    if ((pExpFile != szExpFile) && (pExpFile != pszObjectPath))
    {
        LocalFree(pExpFile);
    }
    return (bRet);
}

STDAPI_(LPITEMIDLIST) GetIDListFromFolder(IShellFolder *psf)
{
    LPITEMIDLIST pidl = NULL;

    IPersistFolder2 *ppf;
    if (psf && SUCCEEDED(psf->QueryInterface(IID_IPersistFolder2, (void **)&ppf)))
    {
        ppf->GetCurFolder(&pidl);
        ppf->Release();
    }
    return pidl;
}

//
//  _GetMoniker()
//  psf  =  the shell folder to bind/parse with  if NULL, use desktop
//  pszIn=  the string that should parsed into a ppmk
//  ppmk =  the IMoniker * that is returned with S_OK
//
//  WARNING:  this will jumpto a folder if that was what was passed in...
//
//  returns S_OK     if it got an IMoniker for the item with the specified folder
//          S_FALSE  if it was the wrong shellfolder; try again with a different one
//          ERROR    for any problems
//

HRESULT CFileOpenBrowser::_GetMoniker(IShellFolder *psf, LPCOLESTR pszIn, IMoniker **ppmk, BOOL fAllowJump)
{
    HRESULT hr = E_OUTOFMEMORY;

    IShellFolder *psfDesktop = NULL;
    if (!psf)
    {
        SHGetDesktopFolder(&psfDesktop);
        psf = psfDesktop;
    }

    *ppmk= NULL;

    if (psf)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

        IBindCtx *pbc = NULL;
        DWORD dwAttribs = (SFGAO_CANMONIKER | SFGAO_FOLDER | SFGAO_BROWSABLE | SFGAO_LINK);
        LPITEMIDLIST pidl;
        ULONG cch;

        if (bSave)
        {

            if (SUCCEEDED(CreateBindCtx(0, &pbc)))
            {
                BIND_OPTS bo = {0};
                bo.cbStruct = SIZEOF(bo);
                bo.grfMode = STGM_CREATE;
                pbc->SetBindOptions(&bo);
            }
        }

        if (S_OK == psf->ParseDisplayName(NULL, pbc, (LPOLESTR) pszIn, &cch, &pidl, &dwAttribs))
        {
            hr = E_ACCESSDENIED;

            ASSERT(pidl);
            if (dwAttribs & SFGAO_LINK)
            {
                TCHAR szReal[MAX_PATH];
                SHTCUTINFO  info;

                info.dwAttr      = 0;
                info.fReSolve    = FALSE;
                info.pszLinkFile = szReal;
                info.cchFile     = ARRAYSIZE(szReal);
                info.ppidl       = NULL; 

                if (S_OK == ResolveLink(pidl,&info))
                {
                    hr = _GetMonikerT(NULL, szReal, ppmk, fAllowJump);
                }
            }
            else if ((dwAttribs & (SFGAO_CANMONIKER | SFGAO_FOLDER | SFGAO_BROWSABLE))
                            == (SFGAO_CANMONIKER | SFGAO_FOLDER))
            {
                //  if we dont have browsable but are a folder then jumpto it
                //  we have a subfolder that has been selected.
                //  jumpto it instead
                if (fAllowJump)
                {
                    if (!psfDesktop && SUCCEEDED(SHGetDesktopFolder(&psfDesktop)) &&
                        !(psf == psfDesktop)
                       )
                    {
                        //  we need to get a fully qualified
                        LPITEMIDLIST pidlParent = GetIDListFromFolder(psf);

                        if (pidlParent)
                        {
                            LPITEMIDLIST pidlFull = ILCombine(pidlParent, pidl);
                            if (pidlFull)
                            {
                                JumpToIDList(pidlFull);
                                ILFree(pidlFull);
                            }
                            ILFree(pidlParent);
                        }
                    }
                    else
                        JumpToIDList(pidl);
                }

                hr = S_FALSE;
            }
            else
            {
                //  we have the right folder already, and we are going to use it
                if (S_OK == psf->BindToObject(pidl, NULL, IID_IMoniker, (LPVOID *)ppmk))
                    hr = S_OK;

            }

            ILFree(pidl);

        }
        else if (!psfDesktop)
            hr = _GetMoniker(NULL, pszIn, ppmk, fAllowJump);

        if (psfDesktop)
            psfDesktop->Release();

        if (pbc)
            pbc->Release();
    }

    return hr;

}


HRESULT CFileOpenBrowser::_GetMonikerT(IShellFolder *psf, LPCTSTR pszIn, IMoniker **ppmk, BOOL fAllowJump)
{
    HRESULT hr = E_OUTOFMEMORY;
    TCHAR szPath[MAX_PATH];

    ASSERT(ppmk);
    ASSERT(pszIn);

    //  ISSUE - file: urls are not properly parsed by the desktop
    //  in shdocvw, they are picked of in IEParseDisplayName().  however
    //  i didnt want to link to shdocvw if i could help it, so i put this little
    //  check to work around.
    if (UrlIs(pszIn, URLIS_FILEURL))
    {
        DWORD cch = ARRAYSIZE(szPath);
        if (SUCCEEDED(PathCreateFromUrl(pszIn, szPath, &cch, 0)))
            pszIn = szPath;
    }


#ifdef UNICODE
    LPCOLESTR osz = pszIn;
#else
    OLECHAR osz[MAX_PATH];

    StrToOleStrN( osz,
        ARRAYSIZE(osz),
        pszIn,
        -1 );
#endif

    if (osz && *osz)
        hr = _GetMoniker(psf, osz, ppmk, fAllowJump);

    return (hr);
}

HRESULT CFileOpenBrowser::_MonikerOKButtonPressed(LPCTSTR pszFile, OKBUTTONFLAGS Flags)
{
    // to make it easier to read...
    HRESULT hr;

    HCURSOR hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    if (StrChr(pszFile, CHAR_QUOTE) && (lpOFN->Flags & OFN_ALLOWMULTISELECT))
    {
        //  need to handle MULTISEL here...
        //  pszFile points to a bunch of quoted strings.
        //  alloc enough for the strings and an extra NULL terminator
        LPTSTR pszCopy = (LPTSTR) LocalAlloc(LPTR, sizeof(TCHAR) * (lstrlen(pszFile) + 2));

        if (pszCopy)
        {
            lstrcpy(pszCopy, pszFile);
            DWORD cFiles = ConvertToNULLTerm(pszCopy);

            if (lpOFN->cMonikers >= cFiles)
            {
                LPTSTR pch = pszCopy;
                //  we have enough room
                for (DWORD i = 0; cFiles; cFiles--)
                {
                    hr = _GetMonikerT(psfCurrent, pch, &lpOFN->rgpMonikers[i], FALSE);
                    //  go to the next item
                    if (FAILED(hr))
                    {
                        InvalidFileWarningNew(hwndDlg, pch, OFErrFromHresult(hr));
                        break;
                    }
                    if (S_OK == hr)
                        i++;

                    pch += lstrlen(pch) + 1;
                }

                if (hr == S_OK)
                    lpOFN->cMonikers = i;
            }
            else
            {
                hr = E_POINTER;
                lpOFN->cMonikers = cFiles;
            }



            LocalFree(pszCopy);
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = _GetMonikerT(psfCurrent, pszFile, &lpOFN->rgpMonikers[0], TRUE);
        if (hr == S_OK)
            lpOFN->cMonikers = 1;
        else if (FAILED(hr))
        {
            //  the warning needs to be able to thrash the incoming buffer
            TCHAR sz[MAX_PATH];
            lstrcpyn(sz, pszFile, ARRAYSIZE(sz));
            InvalidFileWarningNew(hwndDlg, sz, OFErrFromHresult(hr));
        }

    }

    //  should possibly StoreError()
    SetCursor(hCursor);


    return hr;
}

////////////////////////////////////////////////////////////////////////////
//
//  DriveList_OpenClose
//
//  Change the state of a drive list.
//
////////////////////////////////////////////////////////////////////////////

#define OCDL_TOGGLE     0x0000
#define OCDL_OPEN       0x0001
#define OCDL_CLOSE      0x0002

void DriveList_OpenClose(
    UINT uAction,
    HWND hwndDriveList)
{
    if (!hwndDriveList || !IsWindowVisible(hwndDriveList))
    {
        return;
    }

OpenClose_TryAgain:
    switch (uAction)
    {
        case ( OCDL_TOGGLE ) :
        {
            uAction = SendMessage(hwndDriveList, CB_GETDROPPEDSTATE, 0, 0L)
                          ? OCDL_CLOSE
                          : OCDL_OPEN;
            goto OpenClose_TryAgain;
            break;
        }
        case ( OCDL_OPEN ) :
        {
            SetFocus(hwndDriveList);
            SendMessage(hwndDriveList, CB_SHOWDROPDOWN, TRUE, 0);
            break;
        }
        case ( OCDL_CLOSE ) :
        {
            if (GetFocus() == hwndDriveList)
            {
                SendMessage(hwndDriveList, CB_SHOWDROPDOWN, FALSE, 0);
            }
            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::GetFullEditName
//
//  Returns the number of characters needed to get the full path, including
//  the NULL.
//
////////////////////////////////////////////////////////////////////////////

UINT CFileOpenBrowser::GetFullEditName(
    LPTSTR pszBuf,
    UINT cLen,
    TEMPSTR *pTempStr,
    BOOL *pbNoDefExt)
{
    UINT cTotalLen;
    HWND hwndEdit;

    if (bUseHideExt)
    {
        cTotalLen = lstrlen(pszHideExt) + 1;
    }
    else
    {
        if (bUseCombo)
        {
            hwndEdit = (HWND)SendMessage(GetDlgItem(hwndDlg, cmb13), CBEM_GETEDITCONTROL, 0, 0L);
        }
        else
        {

            hwndEdit = GetDlgItem(hwndDlg, edt1);
        }

        cTotalLen = GetWindowTextLength(hwndEdit) + 1;
    }

    if (pTempStr)
    {
        if (!pTempStr->StrSize(cTotalLen))
        {
            return ((UINT)-1);
        }

        pszBuf = *pTempStr;
        cLen = cTotalLen;
    }

    if (bUseHideExt)
    {
        lstrcpyn(pszBuf, pszHideExt, cLen);
    }
    else
    {
        GetWindowText(hwndEdit, pszBuf, cLen);
    }

    if (pbNoDefExt)
    {
        *pbNoDefExt = bUseHideExt;
    }

    return (cTotalLen);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::ProcessEdit
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::ProcessEdit()
{
    TEMPSTR pMultiSel;
    LPTSTR pszFile;
    BOOL bNoDefExt = TRUE;
    OKBUTTONFLAGS Flags = OKBUTTON_NONE;

    if (lpOFN->Flags & OFN_ALLOWMULTISELECT)
    {
        if (GetFullEditName( szBuf,
                             ARRAYSIZE(szBuf),
                             &pMultiSel,
                             &bNoDefExt ) == (UINT)-1)
        {
            //
            //  ISSUE: There should be some error message here.
            //
            return;
        }
        pszFile = pMultiSel;
    }
    else
    {
        if (bSelIsObject)
        {
            pszFile = pszObjectPath;
        }
        else
        {
            GetFullEditName(szBuf, ARRAYSIZE(szBuf), NULL, &bNoDefExt);
            pszFile = szBuf;

            PathRemoveBlanks(pszFile);

            int nLen = lstrlen(pszFile);

            if (*pszFile == CHAR_QUOTE)
            {
                LPTSTR pPrev = CharPrev(pszFile, pszFile + nLen);
                if (*pPrev == CHAR_QUOTE && pszFile != pPrev)
                {
                    Flags |= OKBUTTON_QUOTED;

                    //
                    //  Strip the quotes.
                    //
                    *pPrev = CHAR_NULL;
                    lstrcpy(pszFile, pszFile + 1);
                }
            }
        }
    }

    if (bNoDefExt)
    {
        Flags |= OKBUTTON_NODEFEXT;
    }

#ifdef UNICODE
    //
    //  Visual Basic passes in an uninitialized lpDefExts string.
    //  Since we only have to use it in OKButtonPressed, update
    //  lpstrDefExts here along with whatever else is only needed
    //  in OKButtonPressed.
    //
    if (lpOFI->ApiType == COMDLG_ANSI)
    {
        ThunkOpenFileNameA2WDelayed(lpOFI);
    }
#endif

    if (lpOFN->Flags & OFN_USEMONIKERS)
    {
        BOOL fRet = TRUE;
        HRESULT hr = _MonikerOKButtonPressed(pszFile, Flags);



        switch (hr)
        {
        case E_POINTER:
            fRet = FALSE;
            StoreExtendedError(FNERR_BUFFERTOOSMALL);
            //  fall through to exit the dialog.
        case S_OK:
             CleanupDialog(hwndDlg, fRet);
             break;

        default:
             //  we ignore all other errors
             //  where ever it happened, some UI should have come up.


             break;
        }

    }
    else if (OKButtonPressed(pszFile, Flags))
    {
        BOOL bReturn = TRUE;

        if (lpOFN->lpstrFile)
        {
            if (!(lpOFN->Flags & OFN_NOVALIDATE))
            {
                if (lpOFN->nMaxFile >= 3)
                {
                    if ((lpOFN->lpstrFile[0] == 0) ||
                        (lpOFN->lpstrFile[1] == 0) ||
                        (lpOFN->lpstrFile[2] == 0))
                    {
                        bReturn = FALSE;
                        StoreExtendedError(FNERR_BUFFERTOOSMALL);
                    }
                }
                else
                {
                    bReturn = FALSE;
                    StoreExtendedError(FNERR_BUFFERTOOSMALL);
                }
            }
        }

        if (bReturn)
        {
            AddToMRU(lpOFN);
        }

        CleanupDialog(hwndDlg, bReturn);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::InitializeDropDown
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::InitializeDropDown(
    HWND hwndCtl)
{
    if (!bDropped)
    {
        MYLISTBOXITEM *pParentItem;
        SHChangeNotifyEntry fsne[2];
        int ctr;

        //
        //  Expand the Desktop item.
        //
        pParentItem = GetListboxItem(hwndCtl, NODE_DESKTOP);
        UpdateLevel(hwndCtl, NODE_DESKTOP + 1, pParentItem);

        fsne[0].pidl = pParentItem->pidlFull;
        fsne[0].fRecursive = FALSE;

        //
        //  Look for the My Computer item, since it may not necessarily
        //  be the next one after the Desktop.
        //
        ctr = 0;
        while (pParentItem = GetListboxItem(hwndCtl, NODE_DRIVES + ctr))
        {
            if (ILIsEqual(pParentItem->pidlFull, (LPCITEMIDLIST)&c_idlDrives))
            {
                iNodeDrives = NODE_DRIVES + ctr;
                break;
            }
            ctr++;
        }

        //
        //  Make sure My Computer was found.  If not, then just assume it's
        //  in the first spot after the desktop (this shouldn't happen).
        //
        ASSERT(pParentItem);
        if (pParentItem == NULL)
        {
            pParentItem = GetListboxItem(hwndCtl, NODE_DRIVES);
            iNodeDrives = NODE_DRIVES;
        }

        //
        //  Expand the My Computer item.
        //
        UpdateLevel(hwndCtl, iNodeDrives + 1, pParentItem);

        bDropped = TRUE;

        fsne[1].pidl = pParentItem->pidlFull;
        fsne[1].fRecursive = FALSE;

        uRegister = SHChangeNotifyRegister(
                        hwndDlg,
                        SHCNRF_ShellLevel | SHCNRF_InterruptLevel,
                        SHCNE_ALLEVENTS &
                            ~(SHCNE_CREATE | SHCNE_DELETE | SHCNE_RENAMEITEM),
                        CDM_FSNOTIFY,
                        2,
                        fsne );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnCommandMessage
//
//  Process a WM_COMMAND message for the dialog.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CFileOpenBrowser::OnCommandMessage(
    WPARAM wParam,
    LPARAM lParam)
{
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);

    switch (idCmd)
    {
        case ( edt1 ) :
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
                case ( EN_CHANGE ) :
                {
                    bUseHideExt = FALSE;
                    break;
                }
            }
            break;
        }

        case ( cmb13 ) :
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
                case ( CBN_EDITCHANGE ) :
                {
                    bUseHideExt = FALSE;
                    break;
                }

                case ( CBN_DROPDOWN ) :
                {
                    LoadMRU( szLastFilter,
                             GET_WM_COMMAND_HWND(wParam, lParam),
                             MAX_MRU );
                    break;

                }

            }
            break;
        }

        case ( cmb2 ) :
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
                case ( CBN_CLOSEUP ) :
                {
                    OnSelChange();
                    UpdateNavigation();
                    SelectEditText(hwndDlg);
                    return (TRUE);
                }
                case ( CBN_DROPDOWN ) :
                {
                    InitializeDropDown(GET_WM_COMMAND_HWND(wParam, lParam));
                    break;
                }
            }
            break;
        }

        case ( cmb1 ) :
        {
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
                case ( CBN_DROPDOWN ) :
                {
                    iComboIndex = (int) SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                                                     CB_GETCURSEL,
                                                     NULL,
                                                     NULL );
                    break;
                }
                //
                //  We're trying to see if anything changed after
                //  (and only after) the user is done scrolling through the
                //  drop down. When the user tabs away from the combobox, we
                //  do not get a CBN_SELENDOK.
                //  Why not just use CBN_SELCHANGE? Because then we'd refresh
                //  the view (very slow) as the user scrolls through the
                //  combobox.
                //
                case ( CBN_CLOSEUP ) :
                case ( CBN_SELENDOK ) :
                {
                    //
                    //  Did anything change?
                    //
                    if (iComboIndex >= 0 &&
                        iComboIndex == SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                                                    CB_GETCURSEL,
                                                    NULL,
                                                    NULL ))
                    {
                        break;
                    }
                }
                case ( MYCBN_DRAW ) :
                {
                    RefreshFilter(GET_WM_COMMAND_HWND(wParam, lParam));
                    iComboIndex = -1;
                    return (TRUE);
                }
                default :
                {
                    break;
                }
            }
            break;
        }
        case ( IDC_PARENT ) :
        {
            OnDotDot();
            SelectEditText(hwndDlg);
            break;
        }
        case ( IDC_NEWFOLDER ) :
        {
            ViewCommand(VC_NEWFOLDER);
            break;
        }

        case ( IDC_VIEWLIST) :
        {
            
            SendMessage(hwndView, WM_COMMAND,  (WPARAM)SFVIDM_VIEW_LIST, 0);
            break;
        }

        case (IDC_VIEWDETAILS) :
        {

            SendMessage(hwndView, WM_COMMAND, (WPARAM)SFVIDM_VIEW_DETAILS,0);
            break;
        }


        case ( IDC_VIEWMENU ) :
        {
            //
            //  Pass off the nCmdID to the view for processing / translation.
            //
            DFVCMDDATA cd;

            cd.pva = NULL;
            cd.hwnd = hwndDlg;
            cd.nCmdIDTranslated = 0;
            SendMessage(hwndView, WM_COMMAND, SFVIDM_VIEW_VIEWMENU, (LONG_PTR)&cd);

            break;
        }
        
        case ( IDOK ) :
        {
            HWND hwndFocus = ::GetFocus();

            if (hwndFocus == ::GetDlgItem(hwndDlg, IDOK))
            {
                hwndFocus = hwndLastFocus;
            }

            hwndFocus = GetFocusedChild(hwndDlg, hwndFocus);

            if (hwndFocus == hwndView)
            {
                OnDblClick(TRUE);
            }
            else
            {
                ProcessEdit();
            }

            SelectEditText(hwndDlg);

            break;
        }
        case ( IDCANCEL ) :
        {
            bUserPressedCancel = TRUE;
            CleanupDialog(hwndDlg, FALSE);
            return (TRUE);
        }
        case ( pshHelp ) :
        {
            if (hSubDlg)
            {
                CD_SendHelpNotify(hSubDlg, hwndDlg, lpOFN, lpOFI);
            }

            if (lpOFN->hwndOwner)
            {
                CD_SendHelpMsg(lpOFN, hwndDlg, lpOFI->ApiType);
            }
            break;
        }
        case ( IDC_DROPDRIVLIST ) :         // VK_F4
        {
            //
            //  If focus is on the "File of type" combobox,
            //  then F4 should open that combobox, not the "Look in" one.
            //
            HWND hwnd = GetFocus();
            if (hwnd != GetDlgItem(hwndDlg, cmb1))
            {
                //
                //  We shipped Win95 where F4 *always* opens the "Look in"
                //  combobox, so keep F4 opening that even when it shouldn't.
                //
                hwnd = GetDlgItem(hwndDlg, cmb2);
            }
            DriveList_OpenClose(OCDL_TOGGLE, hwnd);
            break;
        }
        case ( IDC_REFRESH ) :
        {
            if (psv)
            {
                psv->Refresh();
            }
            break;
        }
        case ( IDC_PREVIOUSFOLDER ) :
        {
            OnDotDot();
            break;
        }

        case ( IDC_MYDOCUMENTS ) :
       {
            IShellFolder *psf;
            LPITEMIDLIST pidl;

            //Special Case My Documents
            HRESULT hres =  SHGetDesktopFolder(&psf);

            if (SUCCEEDED(hres))
            {
                hres = psf->ParseDisplayName(NULL, 0, L"::{450D8FBA-AD25-11D0-98A8-0800361B1103}",
                                                     NULL, &pidl, NULL);
                psf->Release();
            }

            if (SUCCEEDED(hres))
            {
                JumpToIDList(pidl);
                ILFree(pidl);
            }
            break;
       }

        int csidl;
        //Places bar commands
        case ( IDC_RECENTFILES ) :
            csidl = CSIDL_RECENT;
            goto JumpToIDList;


        case ( IDC_DESKTOP ) :
            csidl = CSIDL_DESKTOP;
            goto JumpToIDList;

        case ( IDC_FAVORITES ) :
            csidl = CSIDL_FAVORITES;
            goto JumpToIDList;

        case ( IDC_MYNETPLACES ) :
            csidl = CSIDL_NETWORK;

JumpToIDList:
           LPITEMIDLIST pidl;
           SHGetSpecialFolderLocation(NULL, csidl, &pidl);
           JumpToIDList(pidl);
           ILFree(pidl);

           break;

         //Back Navigation
        case ( IDC_BACK ) :
            // Try to travel in the directtion
            if (ptlog && SUCCEEDED(ptlog->Travel(TRAVEL_BACK)))
            {
                LPITEMIDLIST pidl;
                //Able to travel in the given direction.
                //Now Get the new pidl
                ptlog->GetCurrent(&pidl);
                //Update the UI to reflect the current state
                UpdateUI();

                //Jump to the new location
                // second paremeter is whether to translate to logical pidl
                // and third parameter is whether to add to the navigation stack
                // since this pidl comes from the stack , we should not add this to
                // the navigation stack
                JumpToIDList(pidl, FALSE, FALSE);
                ILFree(pidl);
            }
            break;


    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnCDMessage
//
//  Process a special CommDlg message for the dialog.
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::OnCDMessage(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    LONG lResult;
    LPCITEMIDLIST pidl;
    LPTSTR pBuf = (LPTSTR)lParam;
#ifdef UNICODE
    LPWSTR pBufW = NULL;
    int cbLen;
#endif

    switch (uMsg)
    {
        case ( CDM_GETSPEC ) :
        case ( CDM_GETFILEPATH ) :
        case ( CDM_GETFOLDERPATH ) :
        {
#ifdef UNICODE
            if (lpOFI->ApiType == COMDLG_ANSI)
            {
                if (pBufW = (LPWSTR)LocalAlloc( LPTR,
                                                (int)wParam * sizeof(WCHAR) ))
                {
                    pBuf = pBufW;
                }
                else
                {
                    break;
                }
            }
#endif
            if (uMsg == CDM_GETSPEC)
            {
                lResult = GetFullEditName(pBuf, (UINT) wParam, NULL, NULL);
                break;
            }

            // else, fall thru...
        }
        case ( CDM_GETFOLDERIDLIST ) :
        {
            pidl = pCurrentLocation->pidlFull;

            lResult = ILGetSize(pidl);

            if (uMsg == CDM_GETFOLDERIDLIST)
            {
                if ((LONG)wParam < lResult)
                {
                    break;
                }

                CopyMemory((LPBYTE)pBuf, (LPBYTE)pidl, lResult);
                break;
            }

            TCHAR szDir[MAX_PATH];

            //
            //  Check for MyDocuments first.
            //
            if (ILIsEqual(pidl, (LPCITEMIDLIST)&c_idlMyDocs))
            {
                if (!SHGetSpecialFolderPath(NULL, szDir, CSIDL_PERSONAL, FALSE))
                {
                    *szDir = 0;
                }
            }
            else if (!SHGetPathFromIDList(pidl, szDir))
            {
                *szDir = 0;
            }

            if (!*szDir)
            {
                lResult = -1;
                break;
            }


            if (uMsg == CDM_GETFOLDERPATH)
            {
CopyAndReturn:
                lResult = lstrlen(szDir) + 1;
                if ((LONG)wParam >= lResult)
                {
                    lstrcpyn(pBuf, szDir, lResult);
                }
#ifdef UNICODE
                if (lpOFI->ApiType == COMDLG_ANSI)
                {
                    lResult = WideCharToMultiByte( CP_ACP,
                                                   0,
                                                   szDir,
                                                   -1,
                                                   NULL,
                                                   0,
                                                   NULL,
                                                   NULL );
                }
#endif
                if ((int)wParam > lResult)
                {
                    wParam = lResult;
                }
                break;
            }

            //
            //  We'll just fall through to the error case for now, since
            //  doing the full combine is not an easy thing.
            //
            TCHAR szFile[MAX_PATH];

            if ( GetFullEditName(szFile, ARRAYSIZE(szFile), NULL, NULL) >
                 ARRAYSIZE(szFile) - 5 )
            {
                //
                //  Oops!  It looks like we filled our buffer!
                //
                lResult = -1;
                break;
            }

            PathCombine(szDir, szDir, szFile);
            goto CopyAndReturn;
        }
        case ( CDM_SETCONTROLTEXT ) :
        {
#ifdef UNICODE
            if (lpOFI->ApiType == COMDLG_ANSI)
            {
                //
                //  Need to convert pBuf (lParam) to Unicode.
                //
                cbLen = lstrlenA((LPSTR)pBuf) + 1;
                if (pBufW = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR))))
                {
                    MultiByteToWideChar( CP_ACP,
                                         0,
                                         (LPSTR)pBuf,
                                         -1,
                                         pBufW,
                                         cbLen );
                    pBuf = pBufW;
                }
            }
#endif
            //Are we using combobox and the control they are setting is edit box?
            if (bUseCombo && wParam == edt1)
            {
                //Change it to combo box.
                wParam = cmb13;
            }

            if (bSave && wParam == IDOK)
            {
                tszDefSave.StrCpy(pBuf);

                //
                //  Do this to set the OK button correctly.
                //
                SelFocusChange(TRUE);
            }
            else
            {
                SetDlgItemText(hwndDlg, (int) wParam, pBuf);
            }

            break;
        }
        case ( CDM_HIDECONTROL ) :
        {
            ShowWindow(GetDlgItem(hwndDlg, (int) wParam), SW_HIDE);
            break;
        }
        case ( CDM_SETDEFEXT ) :
        {
#ifdef UNICODE
            if (lpOFI->ApiType == COMDLG_ANSI)
            {
                //
                //  Need to convert pBuf (lParam) to Unicode.
                //
                cbLen = lstrlenA((LPSTR)pBuf) + 1;
                if (pBufW = (LPWSTR)LocalAlloc(LPTR, (cbLen * sizeof(WCHAR))))
                {
                    MultiByteToWideChar( CP_ACP,
                                         0,
                                         (LPSTR)pBuf,
                                         -1,
                                         pBufW,
                                         cbLen );
                    pBuf = pBufW;
                }
            }
#endif
            pszDefExt.StrCpy(pBuf);
            bNoInferDefExt = TRUE;

            break;
        }
        default:
        {
            lResult = -1;
            break;
        }
    }

    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, lResult);

#ifdef UNICODE
    if (lpOFI->ApiType == COMDLG_ANSI)
    {
        switch (uMsg)
        {
            case ( CDM_GETSPEC ) :
            case ( CDM_GETFILEPATH ) :
            case ( CDM_GETFOLDERPATH ) :
            {
                //
                //  Need to convert pBuf (pBufW) to Ansi and store in lParam.
                //
                if (wParam && lParam)
                {
                    WideCharToMultiByte( CP_ACP,
                                         0,
                                         pBuf,
                                         -1,
                                         (LPSTR)lParam,
                                         (int) wParam,
                                         NULL,
                                         NULL );
                }
                break;
            }
        }

        if (pBufW)
        {
            LocalFree(pBufW);
        }
    }
#endif

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  OKSubclass
//
//  Subclass window proc for the OK button.
//
//  The OK button is subclassed so we know which control had focus before
//  the user clicked OK.  This in turn lets us know whether to process OK
//  based on the current selection in the listview, or the current text
//  in the edit control.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK OKSubclass(
    HWND hOK,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (msg)
    {
        case ( WM_SETFOCUS ) :
        {
            HWND hwndDlg = ::GetParent(hOK);
            CFileOpenBrowser *pDlgStruct = HwndToBrowser(hwndDlg);
            if (pDlgStruct)
            {
                pDlgStruct->hwndLastFocus = (HWND)wParam;
            }
        }
        break;
    }
    return (::CallWindowProc(::lpOKProc, hOK, msg, wParam, lParam));
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::GetNodeFromIDList
//
////////////////////////////////////////////////////////////////////////////

int CFileOpenBrowser::GetNodeFromIDList(
    LPCITEMIDLIST pidl)
{
    int i;
    HWND hwndCB = GetDlgItem(hwndDlg, cmb2);

    Assert(this->bDropped);

    //
    //  Just check DRIVES and DESKTOP.
    //
    for (i = iNodeDrives; i >= NODE_DESKTOP; --i)
    {
        MYLISTBOXITEM *pItem = GetListboxItem(hwndCB, i);

        if (pItem && ILIsEqual(pidl, pItem->pidlFull))
        {
            break;
        }
    }

    return (i);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::FSChange
//
////////////////////////////////////////////////////////////////////////////

BOOL CFileOpenBrowser::FSChange(
    LONG lNotification,
    LPCITEMIDLIST *ppidl)
{
    int iNode = -1;
    LPCITEMIDLIST pidl = ppidl[0];

    switch (lNotification)
    {
        case ( SHCNE_RENAMEFOLDER ) :
        {
            LPCITEMIDLIST pidlExtra = ppidl[1];

            //
            //  Rename is special.  We need to invalidate both
            //  the pidl and the pidlExtra, so we call ourselves.
            //
            FSChange(0, &pidlExtra);
        }
        case ( 0 ) :
        case ( SHCNE_MKDIR ) :
        case ( SHCNE_RMDIR ) :
        {
            LPITEMIDLIST pidlClone = ILClone(pidl);

            if (!pidlClone)
            {
                break;
            }
            ILRemoveLastID(pidlClone);

            iNode = GetNodeFromIDList(pidlClone);
            ILFree(pidlClone);
            break;
        }
        case ( SHCNE_UPDATEITEM ) :
        case ( SHCNE_NETSHARE ) :
        case ( SHCNE_NETUNSHARE ) :
        case ( SHCNE_UPDATEDIR ) :
        {
            iNode = GetNodeFromIDList(pidl);
            break;
        }
        case ( SHCNE_DRIVEREMOVED ) :
        case ( SHCNE_DRIVEADD ) :
        case ( SHCNE_MEDIAINSERTED ) :
        case ( SHCNE_MEDIAREMOVED ) :
        {
            iNode = iNodeDrives;
            break;
        }
#if 0
        case ( SHCNE_SERVERDISCONNECT ) :
        {
            //
            //  Nuke all our kids and mark ourselves invalid.
            //
            lpNode = GetNodeFromIDList(pidl, 0);
            if (lpNode && NodeHasKids(lpNode))
            {
                int i;

                for (i = GetKidCount(lpNode) - 1; i >= 0; i--)
                {
                    OTRelease(GetNthKid(lpNode, i));
                }
                DPA_Destroy(lpNode->hdpaKids);
                lpNode->hdpaKids = KIDSUNKNOWN;
                OTInvalidateNode(lpNode);
                SFCFreeNode(lpNode);
            }
            else
            {
                lpNode = NULL;
            }
        }
#endif
    }

    if (iNode >= 0)
    {
        //
        //  We want to delay the processing a little because we always do
        //  a full update, so we should accumulate.
        //
        SetTimer(hwndDlg, TIMER_FSCHANGE + iNode, 100, NULL);
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::Timer
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::Timer(
    WPARAM wID)
{
    KillTimer(hwndDlg, (UINT) wID);

    wID -= TIMER_FSCHANGE;

    Assert(this->bDropped);
    switch (wID)
    {
        case ( NODE_DESKTOP ) :
        case ( NODE_DRIVES ) :
        {
            HWND hwndCB;
            MYLISTBOXITEM *pParentItem;

            hwndCB = GetDlgItem(hwndDlg, cmb2);

            pParentItem = GetListboxItem(hwndCB, wID);

            UpdateLevel(hwndCB, (int) wID + 1, pParentItem);
            break;
        }
        default :
        {
            return;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnGetMinMax
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::OnGetMinMax(
    LPMINMAXINFO pmmi)
{
    if ((ptMinTrack.x != 0) || (ptMinTrack.y != 0))
    {
        pmmi->ptMinTrackSize = ptMinTrack;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::OnSize
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::OnSize(
    int width,
    int height)
{
    RECT rcMaster;
    RECT rcView;
    RECT rc;
    HWND hwnd;
    HDWP hdwp;
    int dx;
    int dy;

    //
    //  Set the sizing grip to the correct location.
    //
    SetWindowPos( hwndGrip,
                  NULL,
                  width - g_cxGrip,
                  height - g_cyGrip,
                  g_cxGrip,
                  g_cyGrip,
                  SWP_NOZORDER | SWP_NOACTIVATE );

    //
    //  Ignore sizing until we are initialized.
    //
    if ((ptLastSize.x == 0) && (ptLastSize.y == 0))
    {
        return;
    }

    GetWindowRect(hwndDlg, &rcMaster);

    //
    //  Calculate the deltas in the x and y positions that we need to move
    //  each of the child controls.
    //
    dx = (rcMaster.right - rcMaster.left) - ptLastSize.x;
    dy = (rcMaster.bottom - rcMaster.top) - ptLastSize.y;


    //Dont do anything if the size remains the same
    if ((dx == 0) && (dy == 0))
    {
        return;
    }

    //
    //  Update the new size.
    //
    ptLastSize.x = rcMaster.right - rcMaster.left;
    ptLastSize.y = rcMaster.bottom - rcMaster.top;

    //
    //  Size the view.
    //
    GetWindowRect(hwndView, &rcView);
    MapWindowRect(HWND_DESKTOP, hwndDlg, &rcView);

    hdwp = BeginDeferWindowPos(10);
    if (hdwp)
    {
        hdwp = DeferWindowPos( hdwp,
                               hwndGrip,
                               NULL,
                               width - g_cxGrip,
                               height - g_cyGrip,
                               g_cxGrip,
                               g_cyGrip,
                               SWP_NOZORDER | SWP_NOACTIVATE );

        if (hdwp)
        {
            hdwp = DeferWindowPos( hdwp,
                                   hwndView,
                                   NULL,
                                   0,
                                   0,
                                   rcView.right - rcView.left + dx,  // resize x
                                   rcView.bottom - rcView.top + dy,  // resize y
                                   SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE );
        }
#if 0
        //
        //  Can't do this because some sub-dialogs are dependent on the
        //  original size of this control.  Instead we just try to rely on
        //  the size of the hwndView above.
        //
        hwnd = GetDlgItem(hwndDlg, lst1);
        if (hdwp)
        {
            hdwp = DeferWindowPos( hdwp,
                                   hwnd,
                                   NULL,
                                   0,
                                   0,
                                   rcView.right - rcView.left + dx,  // resize x
                                   rcView.bottom - rcView.top + dy,  // resize y
                                   SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE );
        }
#endif
    }

    //
    //  Move the controls.
    //
    hwnd = ::GetWindow(hwndDlg, GW_CHILD);
    while (hwnd && hdwp)
    {
        if ((hwnd != hSubDlg) && (hwnd != hwndGrip) && (hdwp))
        {
            GetWindowRect(hwnd, &rc);
            MapWindowRect(HWND_DESKTOP, hwndDlg, &rc);

            //
            //  See if the control needs to be adjusted.
            //
            if (rc.top > rcView.bottom)
            {
                switch (GetDlgCtrlID(hwnd))
                {
                    case ( edt1 ) :
                    case ( cmb13 ) :
                    case ( cmb1 ) :
                    {
                        //Increase the width of these controls
                        hdwp = DeferWindowPos( hdwp,
                                               hwnd,
                                               NULL,
                                               rc.left,
                                               rc.top + dy,
                                               RECTWIDTH(rc) + dx,
                                               RECTHEIGHT(rc),
                                               SWP_NOZORDER );
                        break;

                    }

                    case ( IDOK ):
                    case ( IDCANCEL ):
                    case ( pshHelp ):
                    {
                        //Move these controls to  the right
                        hdwp = DeferWindowPos( hdwp,
                                               hwnd,
                                               NULL,
                                               rc.left + dx,
                                               rc.top  + dy,
                                               0,
                                               0,
                                               SWP_NOZORDER | SWP_NOSIZE );
                        break;

                    }

                    default :
                    {
                        //
                        //  The control is below the view, so adjust the y
                        //  coordinate appropriately.
                        //
                        hdwp = DeferWindowPos( hdwp,
                                               hwnd,
                                               NULL,
                                               rc.left,
                                               rc.top + dy,
                                               0,
                                               0,
                                               SWP_NOZORDER | SWP_NOSIZE );

                    }
                }
            }
            else if (rc.left > rcView.right)
            {
                //
                //  The control is to the right of the view, so adjust the
                //  x coordinate appropriately.
                //
                hdwp = DeferWindowPos( hdwp,
                                       hwnd,
                                       NULL,
                                       rc.left + dx,
                                       rc.top,
                                       0,
                                       0,
                                       SWP_NOZORDER | SWP_NOSIZE );
            }
            else
            {
                int id = GetDlgCtrlID(hwnd);

                switch (id)
                {
                    case ( cmb2 ) :
                    {
                        //
                        //  Size this one larger.
                        //
                        hdwp = DeferWindowPos( hdwp,
                                               hwnd,
                                               NULL,
                                               0,
                                               0,
                                               RECTWIDTH(rc) + dx,
                                               RECTHEIGHT(rc),
                                               SWP_NOZORDER | SWP_NOMOVE );
                        break;
                    }
                    case ( IDC_TOOLBAR ) :
                    case ( stc1 ) :
                    {
                        //
                        //  Move the toolbar right by dx.
                        //
                        hdwp = DeferWindowPos( hdwp,
                                               hwnd,
                                               NULL,
                                               rc.left + dx,
                                               rc.top,
                                               0,
                                               0,
                                               SWP_NOZORDER | SWP_NOSIZE );
                        break;
                    }

                    case ( ctl1 ) :
                    {
                        // Size the place bar vertically
                        hdwp = DeferWindowPos(hdwp,
                                              hwnd,
                                              NULL,
                                              0,
                                              0,
                                              RECTWIDTH(rc),
                                              RECTHEIGHT(rc) + dy,
                                              SWP_NOZORDER | SWP_NOMOVE);
                        break;
                    }
                }
            }
        }
        hwnd = ::GetWindow(hwnd, GW_HWNDNEXT);
    }

    if (!hdwp)
    {
        return;
    }
    EndDeferWindowPos(hdwp);

    if (hSubDlg)
    {
        hdwp = NULL;

        hwnd = ::GetWindow(hSubDlg, GW_CHILD);

        while (hwnd)
        {
            GetWindowRect(hwnd, &rc);
            MapWindowRect(HWND_DESKTOP, hSubDlg, &rc);

            //
            //  See if the control needs to be adjusted.
            //
            if (rc.top > rcView.bottom)
            {
                //
                //  The control is below the view, so adjust the y
                //  coordinate appropriately.
                //

                if (hdwp == NULL)
                {
                    hdwp = BeginDeferWindowPos(10);
                }
                if (hdwp)
                {
                    hdwp = DeferWindowPos( hdwp,
                                           hwnd,
                                           NULL,
                                           rc.left,
                                           rc.top + dy,
                                           0,
                                           0,
                                           SWP_NOZORDER | SWP_NOSIZE );
                }
            }
            else if (rc.left > rcView.right)
            {
                //
                //  The control is to the right of the view, so adjust the
                //  x coordinate appropriately.
                //

                if (hdwp == NULL)
                {
                    hdwp = BeginDeferWindowPos(10);
                }
                if (hdwp)
                {
                    hdwp = DeferWindowPos( hdwp,
                                           hwnd,
                                           NULL,
                                           rc.left + dx,
                                           rc.top,
                                           0,
                                           0,
                                           SWP_NOZORDER | SWP_NOSIZE );
                }
            }
            hwnd = ::GetWindow(hwnd, GW_HWNDNEXT);
        }
        if (hdwp)
        {
            EndDeferWindowPos(hdwp);

            //
            //  Size the sub dialog.
            //
            SetWindowPos( hSubDlg,
                          NULL,
                          0,
                          0,
                          ptLastSize.x,         // make it the same
                          ptLastSize.y,         // make it the same
                          SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE );
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::VerifyListViewPosition
//
////////////////////////////////////////////////////////////////////////////

void CFileOpenBrowser::VerifyListViewPosition()
{
    RECT rcList, rcView;
    FOLDERSETTINGS fs;

    //
    //  Get the rectangle for both the list view and the hidden list box.
    //
    GetControlRect(hwndDlg, lst1, &rcList);
    rcView.left = 0;
    if ((!GetWindowRect(hwndView, &rcView)) ||
        (!MapWindowRect(HWND_DESKTOP, hwndDlg, &rcView)))
    {
        return;
    }

    //
    //  See if the list view is off the screen and the list box is not.
    //
    if ((rcView.left < 0) && (rcList.left >= 0))
    {
        //
        //  Reset the list view to the list box position.
        //
        if (pCurrentLocation)
        {
            if (psv)
            {
                psv->GetCurrentInfo(&fs);
            }
            else
            {
                fs.ViewMode = FVM_LIST;
                fs.fFlags = lpOFN->Flags & OFN_ALLOWMULTISELECT ? 0 : FWF_SINGLESEL;
            }

            SwitchView( pCurrentLocation->GetShellFolder(),
                        pCurrentLocation->pidlFull,
                        &fs );
        }
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::UpdateNavigation
//      This function updates the navigation stack by adding the current
//       pidl to the stack
////////////////////////////////////////////////////////////////////////////
void CFileOpenBrowser::UpdateNavigation()
{
    WPARAM iItem;
    HWND hwndCombo  = GetDlgItem(hwndDlg, cmb2);
    iItem = SendMessage(hwndCombo, CB_GETCURSEL, NULL, NULL);
    MYLISTBOXITEM *pNewLocation = GetListboxItem(hwndCombo, iItem);

    if (ptlog && pNewLocation && pNewLocation->pidlFull)
    {
        ptlog->AddEntry(pNewLocation->pidlFull);
    }

    //Update the UI
    UpdateUI();

}

////////////////////////////////////////////////////////////////////////////
//
//  CFileOpenBrowser::UpdateUI
//
////////////////////////////////////////////////////////////////////////////
void CFileOpenBrowser::UpdateUI()
{
    ::SendMessage(hwndToolbar, TB_ENABLEBUTTON, IDC_BACK,    ptlog ? ptlog->CanTravel(TRAVEL_BACK)    : 0 );
}




////////////////////////////////////////////////////////////////////////////
//
//  OpenDlgProc
//
//  Main dialog procedure for file open dialogs.
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK OpenDlgProc(
    HWND hDlg,               // window handle of the dialog box
    UINT message,            // type of message
    WPARAM wParam,           // message-specific information
    LPARAM lParam)
{
    CFileOpenBrowser *pDlgStruct = HwndToBrowser(hDlg);

    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            //
            //  Initialize dialog box.
            //
            LPOFNINITINFO poii = (LPOFNINITINFO)lParam;


           if (!InitLocation(hDlg, poii))
            {
                ::EndDialog(hDlg, FALSE);
            }


            //
            //  Always return FALSE to indicate we have already set the focus.
            //
            return (FALSE);
        }
        case ( WM_DESTROY ) :
        {
            RECT r;

            //Cache in this dialogs size and position so that new
            //dialog are created at this location and size

            GetWindowRect(hDlg, &r);

            if (pDlgStruct && (pDlgStruct->bEnableSizing))
            {
                g_sizeDlg.cx = r.right - r.left;
                g_sizeDlg.cy = r.bottom - r.top;

                g_posDlg.x = r.left;
                g_posDlg.y = r.top;
            }

            //
            //  Make sure we do not respond to any more messages.
            //
            StoreBrowser(hDlg, NULL);
            ClearListbox(GetDlgItem(hDlg, cmb2));

            if (pDlgStruct)
            {
                pDlgStruct->Release();
            }

            break;
        }
        case ( WM_ACTIVATE ) :
        {
            if (wParam == WA_INACTIVE)
            {
                //
                //  Make sure some other Open dialog has not already grabbed
                //  the focus.  This is a process global, so it should not
                //  need to be protected.
                //
                if (gp_hwndActiveOpen == hDlg)
                {
                    gp_hwndActiveOpen = NULL;
                }
            }
            else
            {
                gp_hwndActiveOpen = hDlg;
            }
            break;
        }
        case ( WM_COMMAND ) :
        {
            //
            //  Received a command.
            //
            if (pDlgStruct)
            {
                return ((BOOL_PTR) pDlgStruct->OnCommandMessage(wParam, lParam));
            }
            break;
        }
        case ( WM_DRAWITEM ):
        {
            if (pDlgStruct)
            {
                pDlgStruct->PaintDriveLine((DRAWITEMSTRUCT *)lParam);

                //
                //  Make sure the list view is in the same place as the
                //  list box.  Apps like VB move the list box off of the
                //  dialog.  If the list view is placed on the list box
                //  before the list box gets moved back to the dialog, we
                //  end up with an ugly gray spot.
                //
                pDlgStruct->VerifyListViewPosition();
            }
            return (TRUE);
        }
        case ( WM_MEASUREITEM ) :
        {
            MeasureDriveItems(hDlg, (MEASUREITEMSTRUCT *)lParam);
            return (TRUE);
        }
        case ( WM_NOTIFY ) :
        {
            if (pDlgStruct)
            {
                return (BOOL_PTR)( pDlgStruct->OnNotify((LPNMHDR)lParam));
            }
            break;
        }
        case ( WM_SETCURSOR ) :
        {
            if (pDlgStruct && pDlgStruct->iWaitCount)
            {
                SetCursor(LoadCursor(NULL, IDC_WAIT));
                SetDlgMsgResult(hDlg, message, (LRESULT)TRUE);
                return (TRUE);
            }
            break;
        }
        case ( WM_HELP ) :
        {
            HWND hwndItem = (HWND)((LPHELPINFO)lParam)->hItemHandle;
            if (pDlgStruct && (hwndItem != pDlgStruct->hwndToolbar) &&
                              (hwndItem != pDlgStruct->hwndPlacebar))
            {
                HWND hwndItem = (HWND)((LPHELPINFO)lParam)->hItemHandle;

                //
                //  We assume that the defview has one child window that
                //  covers the entire defview window.
                //
                HWND hwndDefView = GetDlgItem(hDlg, lst2);
                if (GetParent(hwndItem) == hwndDefView)
                {
                    hwndItem = hwndDefView;
                }

                WinHelp( hwndItem,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPTSTR)(pDlgStruct->bSave
                                             ? aFileSaveHelpIDs
                                             : aFileOpenHelpIDs) );
            }
            return (TRUE);
        }
        case ( WM_CONTEXTMENU ) :
        {
            if (pDlgStruct && (((HWND)wParam) != pDlgStruct->hwndToolbar) &&
                              (((HWND)wParam) != pDlgStruct->hwndPlacebar))
            {
                WinHelp( (HWND)wParam,
                         NULL,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)(pDlgStruct->bSave
                                             ? aFileSaveHelpIDs
                                             : aFileOpenHelpIDs) );
            }
            return (TRUE);
        }
        case ( CWM_GETISHELLBROWSER ) :
        {
            ::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LRESULT)pDlgStruct);
            return (TRUE);
        }
        case ( CDM_SETSAVEBUTTON ) :
        {
            if (pDlgStruct)
            {
                pDlgStruct->RealSetSaveButton((UINT)wParam);
            }
            break;
        }
        case ( CDM_FSNOTIFY ) :
        {
            LPITEMIDLIST *ppidl;
            LONG lEvent;
            BOOL bRet;
            LPSHChangeNotificationLock pLock;

            if (!pDlgStruct)
            {
                return (FALSE);
            }

            //
            //  Get the change notification info from the shared memory
            //  block identified by the handle passed in the wParam.
            //
            pLock = SHChangeNotification_Lock( (HANDLE)wParam,
                                               (DWORD)lParam,
                                               &ppidl,
                                               &lEvent );
            if (pLock == NULL)
            {
                pDlgStruct->bDropped = FALSE;
                return (FALSE);
            }

            bRet = pDlgStruct->FSChange(lEvent, (LPCITEMIDLIST *)ppidl);

            //
            //  Release the shared block.
            //
            SHChangeNotification_Unlock(pLock);

            return (bRet);
        }
        case ( CDM_SELCHANGE ) :
        {
            if (pDlgStruct)
            {
                pDlgStruct->fSelChangedPending = FALSE;
                pDlgStruct->SelFocusChange(TRUE);
                if (pDlgStruct->hSubDlg)
                {
                    CD_SendSelChangeNotify( pDlgStruct->hSubDlg,
                                            hDlg,
                                            pDlgStruct->lpOFN,
                                            pDlgStruct->lpOFI );
                }
            }
            break;
        }
        case ( WM_TIMER ) :
        {
            if (pDlgStruct)
            {
                pDlgStruct->Timer(wParam);
            }
            break;
        }
        case ( WM_GETMINMAXINFO ) :
        {
            if (pDlgStruct && (pDlgStruct->bEnableSizing))
            {
                pDlgStruct->OnGetMinMax((LPMINMAXINFO)lParam);
                return (FALSE);
            }
            break;
        }
        case ( WM_SIZE ) :
        {
            if (pDlgStruct && (pDlgStruct->bEnableSizing))
            {
                pDlgStruct->OnSize(LOWORD(lParam), HIWORD(lParam));
                return (TRUE);
            }
            break;
        }

        //
        // AppHack for Borland JBuilder:  Need to keep track of whether
        // any redraw requests have come in.
        //
        case ( WM_NCCALCSIZE ) :
            pDlgStruct->bAppRedrawn = TRUE;
            break;


        default:
        {
            if (IsInRange(message, CDM_FIRST, CDM_LAST) && pDlgStruct)
            {
                return (pDlgStruct->OnCDMessage(message, wParam, lParam));
            }
            break;
        }
    }

    //
    //  Did not process the message.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  OpenFileHookProc
//
////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK OpenFileHookProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam)
{
    MSG *lpMsg;

    if (nCode < 0)
    {
        return (DefHookProc(nCode, wParam, lParam, &gp_hHook));
    }

    if (nCode != MSGF_DIALOGBOX)
    {
        return (0);
    }

    lpMsg = (MSG *)lParam;

    //
    //  Check if this message is for the last active OpenDialog in this
    //  process.
    //
    //  Note: This is only done for WM_KEY* messages so that we do not slow
    //        down this window too much.
    //
    if (IsInRange(lpMsg->message, WM_KEYFIRST, WM_KEYLAST))
    {
        HWND hwndActiveOpen = gp_hwndActiveOpen;
        HWND hwndFocus = GetFocusedChild(hwndActiveOpen, lpMsg->hwnd);
        CFileOpenBrowser *pDlgStruct;

        if (hwndFocus &&
            (pDlgStruct = HwndToBrowser(hwndActiveOpen)) != NULL)
        {
            if (pDlgStruct->psv && (hwndFocus == pDlgStruct->hwndView))
            {
                if (pDlgStruct->psv->TranslateAccelerator(lpMsg) == S_OK)
                {
                    return (1);
                }

                if (gp_haccOpenView &&
                    TranslateAccelerator(hwndActiveOpen, gp_haccOpenView, lpMsg))
                {
                    return (1);
                }
            }
            else
            {
                if (gp_haccOpen &&
                    TranslateAccelerator(hwndActiveOpen, gp_haccOpen, lpMsg))
                {
                    return (1);
                }

                //
                //  Note that the view won't be allowed to translate when the
                //  focus is not there.
                //
            }
        }
    }

    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  NewGetFileName
//
////////////////////////////////////////////////////////////////////////////

BOOL NewGetFileName(
    LPOPENFILEINFO lpOFI,
    BOOL bSave)
{
    OFNINITINFO oii = { lpOFI, bSave, FALSE };
    LPOPENFILENAME lpOFN = lpOFI->pOFN;
    BOOL bHooked = FALSE;
    WORD wErrorMode;
    HRSRC hResInfo;
    HGLOBAL hDlgTemplate;
    LPDLGTEMPLATE pDlgTemplate;
    int nRet;

    //Initialize the common controls
    INITCOMMONCONTROLSEX icc;
    icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icc.dwICC = ICC_USEREX_CLASSES;  //ComboBoxEx class
    InitCommonControlsEx(&icc);

    if (lpOFN->lStructSize != sizeof(OPENFILENAME))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    //
    //  OFN_ENABLEINCLUDENOTIFY requires OFN_EXPLORER and OFN_ENABLEHOOK.
    //
    if (lpOFN->Flags & OFN_ENABLEINCLUDENOTIFY)
    {
        if ((!(lpOFN->Flags & OFN_EXPLORER)) ||
            (!(lpOFN->Flags & OFN_ENABLEHOOK)))
        {
            StoreExtendedError(CDERR_INITIALIZATION);
            return (FALSE);
        }
    }

    wErrorMode = (WORD)SetErrorMode(SEM_NOERROR);
    SetErrorMode(SEM_NOERROR | wErrorMode);

    //
    //  These hooks are REALLY poor.  I am compelled to keep the hHook in a
    //  global because my callback needs it, but I have no lData where I could
    //  possibly store it.
    //  Note that we initialize nHookRef to -1 so we know when the first
    //  increment is.
    //
    if (InterlockedIncrement((LPLONG)&gp_nHookRef) == 0)
    {
        gp_hHook = SetWindowsHookEx( WH_MSGFILTER,
                                     OpenFileHookProc,
                                     0,
                                     GetCurrentThreadId() );
        if (gp_hHook)
        {
            bHooked = TRUE;
        }
        else
        {
            --gp_nHookRef;
        }
    }
    else
    {
        bHooked = TRUE;
    }

    if (!gp_haccOpen)
    {
        gp_haccOpen = LoadAccelerators( g_hinst,
                                        MAKEINTRESOURCE(IDA_OPENFILE) );
    }
    if (!gp_haccOpenView)
    {
        gp_haccOpenView = LoadAccelerators( g_hinst,
                                            MAKEINTRESOURCE(IDA_OPENFILEVIEW) );
    }

    g_cxGrip = GetSystemMetrics(SM_CXVSCROLL);
    g_cyGrip = GetSystemMetrics(SM_CYHSCROLL);

    HIMAGELIST himl;
    Shell_GetImageLists(NULL, &himl);
    ImageList_GetIconSize(himl, &g_cxSmIcon, &g_cySmIcon);

    //
    //  Get the dialog resource and load it.
    //
    nRet = FALSE;
    WORD wResID;

    // if the version of the structure passed is older than the current version and the application 
    // has specified hook or template or template handle then use template corresponding to that version
    // else use the new file open template
    if ((lpOFI->iVersion < OPENFILEVERSION) &&
         (lpOFI->pOFN->Flags & (OFN_ENABLEHOOK | OFN_ENABLETEMPLATE | OFN_ENABLETEMPLATEHANDLE)))
    {
        wResID = NEWFILEOPENORD;
    }
    else
    {
        wResID = NEWFILEOPENV2ORD;
    }

    if ((hResInfo = FindResource( ::g_hinst,
                                  MAKEINTRESOURCE(wResID),
                                  RT_DIALOG )) &&
        (hDlgTemplate = LoadResource(::g_hinst, hResInfo)) &&
        (pDlgTemplate = (LPDLGTEMPLATE)LockResource(hDlgTemplate)))
    {
        ULONG cbTemplate = SizeofResource(::g_hinst, hResInfo);
        LPDLGTEMPLATE pDTCopy = (LPDLGTEMPLATE)LocalAlloc(LPTR, cbTemplate);

        if (pDTCopy)
        {
            CopyMemory(pDTCopy, pDlgTemplate, cbTemplate);
            UnlockResource(hDlgTemplate);
            FreeResource(hDlgTemplate);

            if ( (lpOFN->Flags & OFN_ENABLESIZING) ||
                 (!(lpOFN->Flags & (OFN_ENABLEHOOK |
                                    OFN_ENABLETEMPLATE |

                                    OFN_ENABLETEMPLATEHANDLE))) )
            {
                pDTCopy->style |= WS_SIZEBOX;
                oii.bEnableSizing = TRUE;
            }

            
            if (SHGetAppCompatFlags()  & ACF_MATHCAD)
            {
                CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE);
            }
            

            HRESULT hrOleInit = SHOleInitialize(0);

            nRet = (BOOL)DialogBoxIndirectParam( ::g_hinst,
                                           pDTCopy,
                                           lpOFN->hwndOwner,
                                           OpenDlgProc,
                                           (LPARAM)(LPOFNINITINFO)&oii );

            SHOleUninitialize(hrOleInit);

            if (SHGetAppCompatFlags()  & ACF_MATHCAD)
            {
               CoUninitialize();
            }



            LocalFree(pDTCopy);
        }
    }

    if (bHooked)
    {
        //
        //  Put this in a local so we don't need a critical section.
        //
        HHOOK hHook = gp_hHook;

        if (InterlockedDecrement((LPLONG)&gp_nHookRef) < 0)
        {
            UnhookWindowsHookEx(hHook);
        }
    }

    switch (nRet)
    {
        case ( TRUE ) :
        {
            break;
        }
        case ( FALSE ) :
        {
            if ((!bUserPressedCancel) && (!GetStoredExtendedError()))
            {
                StoreExtendedError(CDERR_DIALOGFAILURE);
            }
            break;
        }
        default :
        {
            StoreExtendedError(CDERR_DIALOGFAILURE);
            nRet = FALSE;
            break;
        }
    }

    //
    //  ISSUE
    //  There is a race condition here where we free dlls but a thread
    //  using this stuff still hasn't terminated so we page fault.
    //
//  FreeImports();

    SetErrorMode(wErrorMode);

    return (nRet);
}


extern "C" {

////////////////////////////////////////////////////////////////////////////
//
//  NewGetOpenFileName
//
////////////////////////////////////////////////////////////////////////////

BOOL NewGetOpenFileName(
    LPOPENFILEINFO lpOFI)
{
    return (NewGetFileName(lpOFI, FALSE));
}


////////////////////////////////////////////////////////////////////////////
//
//  NewGetSaveFileName
//
////////////////////////////////////////////////////////////////////////////

BOOL NewGetSaveFileName(
    LPOPENFILEINFO lpOFI)
{
    return (NewGetFileName(lpOFI, TRUE));
}

}   // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\isz.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    isz.h

Abstract:

    This module contains the string resource IDs for the common dialogs.

Revision History:

--*/



//
//  0x0000 - 0x00ff Error codes.
//


//
//  MESSAGES:  0x0100 to 0x01ff.
//
#define iszOverwriteCaption       0x0100
#define iszOverwriteQuestion      0x0101
#define iszDefExitCaption         0x0102
#define iszDefExitText            0x0103

#define iszDefaultPitch           0x0104
#define iszFixedPitch             0x0105
#define iszVariablePitch          0x0106
#define iszAnsiCharset            0x0107
#define iszOemCharset             0x0108
#define iszSymbolCharset          0x0109
#define iszDecorativeFamily       0x010a
#define iszUnknownFamily          0x010b
#define iszModernFamily           0x010c
#define iszRomanFamily            0x010d
#define iszScriptFamily           0x010e
#define iszSwissFamily            0x010f

#define iszSystemFont             0x0110
#define iszHelvFont               0x0111
#define iszCourierFont            0x0112
#define iszTmsRmnFont             0x0113
#define iszSymbolFont             0x0114
#define iszRomanFont              0x0115
#define iszScriptFont             0x0116
#define iszModernFont             0x0117
#define iszLastFont               iszModernFont

#define iszFileSaveIn             0x0170
#define iszFileSaveButton         0x0171
#define iszFileOpenButton         0x0172
#define iszPrintButton            0x0173

#define iszFileOpenTitle          0x0180
#define iszFileSaveTitle          0x0181
#define iszSaveFileAsType         0x0182
#define iszDriveDoesNotExist      0x0183
#define iszNoDiskInDrive          0x0184
#define iszWrongDiskInDrive       0x0185
#define iszUnformatedDisk         0x0186
#define iszFileNotFound           0x0187
#define iszPathNotFound           0x0188
#define iszInvalidFileName        0x0189
#define iszSharingViolation       0x018A
#define iszNetworkAccessDenied    0x018B
#define iszReadOnly               0x018C
#define iszInt24Error             0x018D
#define iszPortName               0x018E
#define iszWriteProtection        0x018F
#define iszDiskFull               0x0190
#define iszNoFileHandles          0x0191
#define iszCreatePrompt           0x0192
#define iszCreateNoModify         0x0193
#define iszSelectDriveTrouble     0x0194
#define iszNoNetButtonResponse    0x0195
#define iszFileAccessDenied       0x0196
#define iszDirAccessDenied        0x0197
#define iszNoDiskInCDRom          0x0198
#define iszNetworkButtonText      0x0199
#define iszNetworkButtonTextAccel 0x019A
#define iszTooManyFiles           0x019B
#define iszSaveAsType             0x019C
#define iszHistory                0x019D
#define iszMyDocs                 0x019E
#define iszDesktop                0x019F
#define iszFavorites              0x01A0
#define iszMyNetPlaces            0x01A1
#define iszObjectName             0x01A2
#define iszObjectType             0x01A3
#define iszSaveRestricted         0x01A4

//
//  RESOURCES:  0x0200 to 0x020f.
//
//     Menus:           0x0200 to 0x020f
//     Icons:           0x0210 to 0x021f
//     Cursors:         0x0220 to 0x022f
//     Accelerators:    0x0230 to 0x023f
//     Bitmaps:         0x0240 to 0x024f
//     Private:         0x0250 to 0x025f
//
#define ICO_PORTRAIT              0x0210
#define ICO_LANDSCAPE             0x0211
#define ICO_P_NONE                0x0212
#define ICO_L_NONE                0x0213
#define ICO_P_HORIZ               0x0214
#define ICO_L_HORIZ               0x0215
#define ICO_P_VERT                0x0216
#define ICO_L_VERT                0x0217
#define ICO_COLLATE               0x0218
#define ICO_NO_COLLATE            0x0219
#define ICO_P_PSSTAMP             0x021a
#define ICO_L_PSSTAMP             0x021b
#define ICO_PRINTER               0x021c

#define bmpDirDrive               576


//
//  DIALOGS:  0x0300 to 0x03ff.
//
#define dlgFileOpen               0x0300
#define dlgFileSave               0x0301
#define dlgExitChanges            0x0302
#define dlgChooseColor            0x0303
#define dlgFindText               0x0304
#define dlgReplaceText            0x0305
#define dlgFormatChar             0x0306
#define dlgFontInfo               0x0307
#define dlgPrintDlg               0x0308
#define dlgPrintSetupDlg          0x0309
#define dlgMultiFileOpen          0x030a


//
//  MISC:  0x0400 to 0x06ff.
//
#define BMFONT                    38

#define iszClose                  0x040d   // "Close" text for find/replace


#define iszBlack                  0x0410
#define iszDkRed                  0x0411
#define iszDkGreen                0x0412
#define iszDkYellow               0x0413
#define iszDkBlue                 0x0414
#define iszDkPurple               0x0415
#define iszDkAqua                 0x0416
#define iszDkGrey                 0x0417
#define iszLtGrey                 0x0418
#define iszLtRed                  0x0419
#define iszLtGreen                0x041a
#define iszLtYellow               0x041b
#define iszLtBlue                 0x041c
#define iszLtPurple               0x041d
#define iszLtAqua                 0x041e
#define iszWhite                  0x041f

#define iszHighPrnQ               0x0430
#define iszMedPrnQ                0x0431
#define iszLowPrnQ                0x0432
#define iszDraftPrnQ              0x0433

#define iszPrinter                0x0440
#define iszSysPrn                 0x0441
#define iszPrnOnPort              0x0442
#define iszDefCurOn               0x0443

#define iszSizeNumber             0x044A
#define iszSizeRange              0x044B
#define iszSynth                  0x044C
#define iszTrueType               0x044D
#define iszPrinterFont            0x044E
#define iszGDIFont                0x044F

#ifdef WINNT
#define iszTTOpenType             0x0470
#define iszPSOpenType             0x0471
#define iszType1                  0x0472
#endif

#define iszPageRangeError         0x0450
#define iszFromToError            0x0451
#define iszPageFromError          0x0452
#define iszPageToError            0x0453
#define iszBadMarginError         0x0454
#define iszCopiesZero             0x0455
#define iszTooManyCopies          0x0456
#define iszWarningTitle           0x0457
#define iszNoPrnsInstalled        0x0458
#define iszPrnNotFound            0x0459
#define iszMemoryError            0x045A
#define iszGeneralWarning         0x045B
#define iszUnknownDriver          0x045C
#define iszBadPageRange           0x045D
#define iszTooManyPageRanges      0x045E
#define iszBadPageRangeSyntaxOld  0x045F
#define iszBadPageRangeSyntaxNew  0x0460
#define iszNoPrinters             0x0461
#define iszNoLongerInList         0x0462
#define iszNoPrinterSelected      0x0463
#define iszDefaultMenuText        0x0464
#define iszNoPrinterAccess        0x0465

#define iszNoFontsTitle           0x0500
#define iszNoFontsMsg             0x0501
#define iszNoFaceSel              0x0502
#define iszNoStyleSel             0x0503
#define iszRegular                0x0504
#define iszBold                   0x0505
#define iszItalic                 0x0506
#define iszBoldItalic             0x0507
#define iszNoScript               0x0508

//
//  CCHSTYLE is the max allowed length of iszRegular to iszBoldItalic strings
//
#define CCHSTYLE                  32


#define iszStatusReady            0x0600

#define iszStatusPaused           0x0601
#define iszStatusError            0x0602
#define iszStatusPendingDeletion  0x0603
#define iszStatusPaperJam         0x0604
#define iszStatusPaperOut         0x0605
#define iszStatusManualFeed       0x0606
#define iszStatusPaperProblem     0x0607
#define iszStatusOffline          0x0608
#define iszStatusIOActive         0x0609
#define iszStatusBusy             0x060A
#define iszStatusPrinting         0x060B
#define iszStatusOutputBinFull    0x060C
#define iszStatusNotAvailable     0x060D
#define iszStatusWaiting          0x060E
#define iszStatusProcessing       0x060F
#define iszStatusInitializing     0x0610
#define iszStatusWarmingUp        0x0611
#define iszStatusTonerLow         0x0612
#define iszStatusNoToner          0x0613
#define iszStatusPagePunt         0x0614
#define iszStatusUserIntervention 0x0615
#define iszStatusOutOfMemory      0x0616
#define iszStatusDoorOpen         0x0617

#define iszStatusDocumentsWaiting 0x062F
#define iszStatusDefaultPrinter   0x062E

#define iszPrintRangeAll          0x0630

#define iszMarginsInches          0x0631
#define iszMarginsMillimeters     0x0632
#define iszInches                 0x0633
#define iszMillimeters            0x0634
#define iszDefaultSource          0x0635

#define iszGeneralPage            0x0640
#define iszPrintCaption           0x0641


//
//  FONT SAMPLES:  0x0700 to 0x07ff.
//
#define iszFontSample               0x0700

//Unicode Font Samples
#define iszUnicode                  0x0800
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\font.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    font.c

Abstract:

    This module implements the Win32 font dialog.

Revision History:

--*/

// ClaudeBe 10/12/98, to enable Multiple Master Axis selection in the
// font selection dialog, uncomment the following three lines and make sure
// you use the new font.dlg (from \nt\private\ntos\w32\ntgdi\test\fonttest.nt\comdlg32mm)
// as of 10/12/98, this is not a NT 5.0/IE 5.0 feature
// 
#ifdef WINNT
#define  MM_DESIGNVECTOR_DEFINED
#endif


//
//  Include Files.
//


#include "comdlg32.h"

#ifdef WINNT
  #include <nt.h>
  #include <ntrtl.h>
  #include <nturtl.h>
#endif

#include "font.h"
#include <wingdip.h>              // for IS_ANY_DBCS_CHARSET macro

#ifdef MM_DESIGNVECTOR_DEFINED
#define MAX_NUM_AXES  6

VOID GetCannonicalNameW(
    WCHAR        *pwsz,  // in foo_XX_YY, out Cannonical and capitalized name FOO
    DESIGNVECTOR *pdv      // [XX,YY] on out
);

VOID AddDesignVectorToNameW(
    WCHAR        *pFaceName,  // in Cannonical name foo, out foo_XX_YY
    DESIGNVECTOR *pdv      // [XX,YY] in
);

VOID GetCannonicalNameA(
    char        *pasz,  // in foo_XX_YY, out Cannonical and capitalized name FOO
    DESIGNVECTOR *pdv      // [XX,YY] on out
);

VOID AddDesignVectorToNameA(
    char        *pFaceName,  // in Cannonical name foo, out foo_XX_YY
    DESIGNVECTOR *pdv      // [XX,YY] in
);

#ifdef UNICODE
#define GetCannonicalName(A,B) GetCannonicalNameW(A,B);
#define AddDesignVectorToName(A,B) AddDesignVectorToNameW(A,B);
#else
#define GetCannonicalName(A,B) GetCannonicalNameA(A,B);
#define AddDesignVectorToName(A,B) AddDesignVectorToNameA(A,B);
#endif // UNICODE

#ifdef UNICODE

#define IS_DIGITW(x)   (((x) >= L'0') && ((x) <= L'9'))
#define GET_DIGITW(X)  ((X) - L'0')
#define WC_UNDERSCORE L'_'

VOID GetCannonicalNameW(
    WCHAR        *pwsz,  // in foo_XX_YY, out Cannonical and capitalized name FOO
    DESIGNVECTOR *pdv      // [XX,YY] on out
)
{
// modified from GreGetCannonicalName
//
// The input is the zero terminated name of the form
//
// foo_XXaaaYYbbb...ZZccc
//
// where  XX,  YY,  ZZ are numerals (arbitrary number of them) and
//       aaa, bbb, ccc are not numerals, i.e. spaces, or another '_' signs or
// letters with abbreviated axes names.
//
// This face name will be considered equivalent to face name foo
// with DESIGNVECTOR [XX,YY, ...ZZ], number of axes being determined
// by number of numeral sequences.
//

    WCHAR *pwc;
    ULONG cAxes = 0;
    ULONG cwc;

    /* if we already have a DESIGNVECTOR information, we don't want to erase it */
    if (pdv->dvNumAxes != 0)
        return;

    for
    (
        pwc = pwsz ;
        (*pwc) && !((*pwc == WC_UNDERSCORE) && IS_DIGITW(pwc[1]));
        pwc++
    )
    {
        // do nothing;
    }

// copy out, zero terminate

// Sundown safe truncation
    cwc = (ULONG)(pwc - pwsz);

// If we found at least one WC_UNDERSCORE followed by the DIGIT
// we have to compute DV. Underscore followed by the DIGIT is Adobe's rule

    if ((*pwc == WC_UNDERSCORE) && IS_DIGITW(pwc[1]))
    {
    // step to the next character behind undescore

        pwc++;

        while (*pwc)
        {
        // go until you hit the first digit

            for ( ; *pwc && !IS_DIGITW(*pwc) ; pwc++)
            {
                // do nothing
            }


            if (*pwc)
            {
            // we have just hit the digit

                ULONG dvValue = GET_DIGITW(*pwc);

            // go until you hit first nondigit or the terminator

                pwc++;

                for ( ; *pwc && IS_DIGITW(*pwc); pwc++)
                {
                    dvValue = dvValue * 10 + GET_DIGITW(*pwc);
                }

                pdv->dvValues[cAxes] = (LONG)dvValue;

            // we have just parsed a string of numerals

                cAxes++;
            }
        }
    }

// record the findings

    pdv->dvNumAxes = cAxes;
    pdv->dvReserved = STAMP_DESIGNVECTOR;

    /* we do that at the end allowing to pass the same buffer as in and out */
    pwsz[cwc] = L'\0';

}

VOID AddDesignVectorToNameW(
    WCHAR        *pFaceName,  // in Cannonical name foo, out foo_XX_YY
    DESIGNVECTOR *pdv      // [XX,YY] in
)
{
    if (pdv->dvNumAxes != 0)
    {
        UINT i;
        PWCHAR endOfBaseName;
        WCHAR pszValue[20]; // temp buffer used to convert long to string

        for (i=0; i<pdv->dvNumAxes; i++)
        {
		    _itow(pdv->dvValues[i], pszValue, 10);

		    if ((wcslen(pFaceName) + wcslen(pszValue) + 1) >= (UINT)LF_FACESIZE)
			    return;

            endOfBaseName = pFaceName + wcslen(pFaceName);
			*endOfBaseName = WC_UNDERSCORE;
		    endOfBaseName++;
		    *endOfBaseName = 0;	
		    wcscat(endOfBaseName, pszValue);
        }

    }

}
#else
#define IS_DIGITA(x)   (((x) >= '0') && ((x) <= '9'))
#define GET_DIGITA(X)  ((X) - '0')
#define AC_UNDERSCORE '_'

VOID GetCannonicalNameA(
    char        *pasz,  // in foo_XX_YY, out Cannonical and capitalized name FOO
    DESIGNVECTOR *pdv      // [XX,YY] on out
)
{
// modified from GreGetCannonicalName
//
// The input is the zero terminated name of the form
//
// foo_XXaaaYYbbb...ZZccc
//
// where  XX,  YY,  ZZ are numerals (arbitrary number of them) and
//       aaa, bbb, ccc are not numerals, i.e. spaces, or another '_' signs or
// letters with abbreviated axes names.
//
// This face name will be considered equivalent to face name foo
// with DESIGNVECTOR [XX,YY, ...ZZ], number of axes being determined
// by number of numeral sequences.
//

    char *pac;
    ULONG cAxes = 0;
    ULONG cac;

    /* if we already have a DESIGNVECTOR information, we don't want to erase it */
    if (pdv->dvNumAxes != 0)
        return;

    for
    (
        pac = pasz ;
        (*pac) && !((*pac == AC_UNDERSCORE) && IS_DIGITA(pac[1]));
        pac++
    )
    {
        // do nothing;
    }

// copy out, zero terminate

// Sundown safe truncation
    cac = (ULONG)(pac - pasz);

// If we found at least one AC_UNDERSCORE followed by the DIGIT
// we have to compute DV. Underscore followed by the DIGIT is Adobe's rule

    if ((*pac == AC_UNDERSCORE) && IS_DIGITA(pac[1]))
    {
    // step to the next character behind undescore

        pac++;

        while (*pac)
        {
        // go until you hit the first digit

            for ( ; *pac && !IS_DIGITA(*pac) ; pac++)
            {
                // do nothing
            }


            if (*pac)
            {
            // we have just hit the digit

                ULONG dvValue = GET_DIGITA(*pac);

            // go until you hit first nondigit or the terminator

                pac++;

                for ( ; *pac && IS_DIGITA(*pac); pac++)
                {
                    dvValue = dvValue * 10 + GET_DIGITA(*pac);
                }

                pdv->dvValues[cAxes] = (LONG)dvValue;

            // we have just parsed a string of numerals

                cAxes++;
            }
        }
    }

// record the findings

    pdv->dvNumAxes = cAxes;
    pdv->dvReserved = STAMP_DESIGNVECTOR;

    /* we do that at the end allowing to pass the same buffer as in and out */
    pasz[cac] = L'\0';

}

VOID AddDesignVectorToNameA(
    char        *pFaceName,  // in Cannonical name foo, out foo_XX_YY
    DESIGNVECTOR *pdv      // [XX,YY] in
)
{
    if (pdv->dvNumAxes != 0)
    {
        UINT i;
        char *endOfBaseName;
        char pszValue[20]; // temp buffer used to convert long to string

        for (i=0; i<pdv->dvNumAxes; i++)
        {
		    _itoa(pdv->dvValues[i], pszValue, 10);

		    if ((strlen(pFaceName) + strlen(pszValue) + 1) >= (UINT)LF_FACESIZE)
			    return;

            endOfBaseName = pFaceName + strlen(pFaceName);
			*endOfBaseName = AC_UNDERSCORE;
		    endOfBaseName++;
		    *endOfBaseName = 0;	
		    strcat(endOfBaseName, pszValue);
        }

    }

}
#endif // UNICODE

#endif // MM_DESIGNVECTOR_DEFINED

#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  ChooseFontA
//
//  ANSI entry point for ChooseFont when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

#ifdef MM_DESIGNVECTOR_DEFINED
BOOL WINAPI ChooseFontA(
    LPCHOOSEFONTA pCFA)
{
    BOOL result;

    ENUMLOGFONTEXDVA LogFontDV;
    LPLOGFONTA lpLogFont;

    /* we ned space in lpLogFont for the DESIGNVECTOR */
    lpLogFont = pCFA->lpLogFont;

    pCFA->lpLogFont = (LPLOGFONTA)&LogFontDV; 

    *pCFA->lpLogFont = *lpLogFont;

    ((LPENUMLOGFONTEXDVA)pCFA->lpLogFont)->elfDesignVector.dvNumAxes = 0;  // set number of axis to zero
    ((LPENUMLOGFONTEXDVA)pCFA->lpLogFont)->elfDesignVector.dvReserved = STAMP_DESIGNVECTOR;  

    result = ChooseFontExA(pCFA, 0);

    /* copy back lpLogFont */

    *lpLogFont = *pCFA->lpLogFont;

    pCFA->lpLogFont = lpLogFont;

    return result;
}
#endif // MM_DESIGNVECTOR_DEFINED

#ifdef MM_DESIGNVECTOR_DEFINED
BOOL WINAPI ChooseFontExA(
    LPCHOOSEFONTA pCFA, DWORD fl)
#else
BOOL WINAPI ChooseFontA(
    LPCHOOSEFONTA pCFA)
#endif // MM_DESIGNVECTOR_DEFINED
{
    LPCHOOSEFONTW pCFW;
    BOOL result;
    LPBYTE pStrMem;
    UNICODE_STRING usStyle;
    ANSI_STRING asStyle;
    int cchTemplateName = 0;
    FONTINFO FI;

    ZeroMemory(&FI, sizeof(FONTINFO));

    if (!pCFA)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pCFA->lStructSize != sizeof(CHOOSEFONTA))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    //
    //  Setup and allocate CHOOSEFONTW structure.
    //
    if (!pCFA->lpLogFont && (pCFA->Flags & CF_INITTOLOGFONTSTRUCT))
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (!(pCFW = (LPCHOOSEFONTW)LocalAlloc(
                                LPTR,
#ifdef MM_DESIGNVECTOR_DEFINED
                                sizeof(CHOOSEFONTW) + sizeof(ENUMLOGFONTEXDVW) )))
#else
                                sizeof(CHOOSEFONTW) + sizeof(LOGFONTW) )))
#endif // MM_DESIGNVECTOR_DEFINED

    {
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
        return (FALSE);
    }

    pCFW->lStructSize = sizeof(CHOOSEFONTW);

    pCFW->lpLogFont = (LPLOGFONTW)((LPCHOOSEFONTW)pCFW + 1);

    if (pCFA->Flags & CF_ENABLETEMPLATE)
    {
        if (!IS_INTRESOURCE(pCFA->lpTemplateName))
        {
            cchTemplateName = (lstrlenA(pCFA->lpTemplateName) + 1) *
                              sizeof(WCHAR);
            if (!(pCFW->lpTemplateName = (LPWSTR)LocalAlloc( LPTR,
                                                             cchTemplateName)))
            {
                LocalFree(pCFW);
                StoreExtendedError(CDERR_MEMALLOCFAILURE);
                return (FALSE);
            }
            else
            {
                SHAnsiToUnicode(pCFA->lpTemplateName,(LPWSTR)pCFW->lpTemplateName,cchTemplateName);
            }
        }
        else
        {
            (DWORD_PTR)pCFW->lpTemplateName = (DWORD_PTR)pCFA->lpTemplateName;
        }
    }
    else
    {
        pCFW->lpTemplateName = NULL;
    }

    if ((pCFA->Flags & CF_USESTYLE) && (!IS_INTRESOURCE(pCFA->lpszStyle)))
    {
        asStyle.MaximumLength = LF_FACESIZE;
        asStyle.Length = (USHORT) (lstrlenA(pCFA->lpszStyle));
        if (asStyle.Length >= asStyle.MaximumLength)
        {
            asStyle.MaximumLength = asStyle.Length;
        }
    }
    else
    {
        asStyle.Length = usStyle.Length = 0;
        asStyle.MaximumLength = LF_FACESIZE;
    }
    usStyle.MaximumLength = asStyle.MaximumLength * sizeof(WCHAR);
    usStyle.Length = asStyle.Length * sizeof(WCHAR);

    if (!(pStrMem = (LPBYTE)LocalAlloc( LPTR,
                                        asStyle.MaximumLength +
                                            usStyle.MaximumLength )))
    {
        if (cchTemplateName)
        {
            LocalFree((LPWSTR)(pCFW->lpTemplateName));
        }
        LocalFree(pCFW);
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
        return (FALSE);
    }

    asStyle.Buffer = pStrMem;
    pCFW->lpszStyle = usStyle.Buffer =
        (LPWSTR)(asStyle.Buffer + asStyle.MaximumLength);

    if ((pCFA->Flags & CF_USESTYLE) && (!IS_INTRESOURCE(pCFA->lpszStyle)))
    {
        lstrcpyA(asStyle.Buffer, pCFA->lpszStyle);
    }

    FI.pCF = pCFW;
    FI.pCFA = pCFA;
    FI.ApiType = COMDLG_ANSI;
    FI.pasStyle = &asStyle;
    FI.pusStyle = &usStyle;

    ThunkChooseFontA2W(&FI);

#ifdef MM_DESIGNVECTOR_DEFINED
    if (result = ChooseFontX(&FI, fl))
#else
    if (result = ChooseFontX(&FI))
#endif // MM_DESIGNVECTOR_DEFINED
    {
        ThunkChooseFontW2A(&FI);

        //
        //  Doesn't say how many characters there are here.
        //
        if ((pCFA->Flags & CF_USESTYLE) && (!IS_INTRESOURCE(pCFA->lpszStyle)))
        {
            LPSTR psz = pCFA->lpszStyle;
            LPSTR pszT = asStyle.Buffer;

            try
            {
                while (*psz++ = *pszT++);
            }
            except (EXCEPTION_ACCESS_VIOLATION)
            {
                //
                //  Not enough space in the passed in string.
                //
                *--psz = '\0';
            }
        }
    }

    if (cchTemplateName)
    {
        LocalFree((LPWSTR)(pCFW->lpTemplateName));
    }
    LocalFree(pCFW);
    LocalFree(pStrMem);

    return (result);
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  ChooseFontW
//
//  Stub UNICODE function for ChooseFont when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI ChooseFontW(
   LPCHOOSEFONTW lpCFW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#ifdef MM_DESIGNVECTOR_DEFINED
BOOL WINAPI ChooseFontExW(
   LPCHOOSEFONTW lpCFW, DWORD fl)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}
#endif // MM_DESIGNVECTOR_DEFINED

#endif


////////////////////////////////////////////////////////////////////////////
//
//  ChooseFont
//
//  The ChooseFont function creates a system-defined dialog box from which
//  the user can select a font, a font style (such as bold or italic), a
//  point size, an effect (such as strikeout or underline), and a text
//  color.
//
////////////////////////////////////////////////////////////////////////////

#ifdef MM_DESIGNVECTOR_DEFINED
BOOL WINAPI ChooseFont(
   LPCHOOSEFONT lpCF)
{
    BOOL result;

    ENUMLOGFONTEXDV LogFontDV;
    LPLOGFONT lpLogFont;

    /* we ned space in lpLogFont for the DESIGNVECTOR */
    lpLogFont = lpCF->lpLogFont;

    lpCF->lpLogFont = (LPLOGFONT)&LogFontDV; 

    *lpCF->lpLogFont = *lpLogFont;

    ((LPENUMLOGFONTEXDV)lpCF->lpLogFont)->elfDesignVector.dvNumAxes = 0;  // set number of axis to zero
    ((LPENUMLOGFONTEXDV)lpCF->lpLogFont)->elfDesignVector.dvReserved = STAMP_DESIGNVECTOR;  

    result = ChooseFontEx(lpCF, 0);

    /* copy back lpLogFont */

    *lpLogFont = *lpCF->lpLogFont;

    lpCF->lpLogFont = lpLogFont;

    return result;
}
#endif // MM_DESIGNVECTOR_DEFINED

#ifdef MM_DESIGNVECTOR_DEFINED
BOOL WINAPI ChooseFontEx(
   LPCHOOSEFONT lpCF, DWORD fl)
#else
BOOL WINAPI ChooseFont(
   LPCHOOSEFONT lpCF)
#endif // MM_DESIGNVECTOR_DEFINED
{
    FONTINFO FI;

    ZeroMemory(&FI, sizeof(FONTINFO));

    FI.pCF = lpCF;
    FI.ApiType = COMDLG_WIDE;

#ifdef MM_DESIGNVECTOR_DEFINED
    return ( ChooseFontX(&FI, fl) );
#else
    return ( ChooseFontX(&FI) );
#endif // MM_DESIGNVECTOR_DEFINED
}


////////////////////////////////////////////////////////////////////////////
//
//  ChooseFontX
//
//  Invokes the font picker dialog, which lets the user specify common
//  character format attributes: facename, point size, text color and
//  attributes (bold, italic, strikeout or underline).
//
//  lpCF    - ptr to structure that will hold character attributes
//  ApiType - api type (COMDLG_WIDE or COMDLG_ANSI) so that the dialog
//            can remember which message to send to the user.
//
//  Returns:   TRUE  - user pressed IDOK
//             FALSE - user pressed IDCANCEL
//
////////////////////////////////////////////////////////////////////////////

BOOL ChooseFontX(
#ifdef MM_DESIGNVECTOR_DEFINED
    PFONTINFO pFI, DWORD fl)
#else
    PFONTINFO pFI)
#endif // MM_DESIGNVECTOR_DEFINED
{
    INT_PTR iRet;                // font picker dialog return value
    HANDLE hDlgTemplate;         // handle to loaded dialog resource
    HANDLE hRes;                 // handle of res. block with dialog
    int id;
    LPCHOOSEFONT lpCF = pFI->pCF;
    BOOL fAllocLogFont = FALSE;
#ifdef UNICODE
    UINT uiWOWFlag = 0;
#endif

    SetCursor(LoadCursor(NULL, IDC_WAIT));

    StoreExtendedError(0);
    bUserPressedCancel = FALSE;

    if (!lpCF)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (lpCF->lStructSize != sizeof(CHOOSEFONT))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if (!lpCF->lpLogFont)
    {
#ifdef MM_DESIGNVECTOR_DEFINED
        if (!(lpCF->lpLogFont = (LPLOGFONT)LocalAlloc(LPTR, sizeof(ENUMLOGFONTEXDV))))
#else
        if (!(lpCF->lpLogFont = (LPLOGFONT)LocalAlloc(LPTR, sizeof(LOGFONT))))
#endif // MM_DESIGNVECTOR_DEFINED
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
            return (FALSE);
        }

        fAllocLogFont = TRUE;
    } 
#ifdef MM_DESIGNVECTOR_DEFINED
    else 
    {
        GetCannonicalName(lpCF->lpLogFont->lfFaceName, 
            &((LPENUMLOGFONTEXDVW)lpCF->lpLogFont)->elfDesignVector);
    }

    // GetProcAddress for CreateFontIndirectEx, if this function exist, it's safe
    // to access DESIGNVECTOR information

    
    pFI->pfnCreateFontIndirectEx = NULL;

    if ( (lpCF->Flags & CF_MM_DESIGNVECTOR) &&  
         !(lpCF->Flags & CF_ENABLETEMPLATE) && !(lpCF->Flags & CF_ENABLETEMPLATEHANDLE))
    {
        HINSTANCE hinst = GetModuleHandleA("GDI32.DLL");

        if (hinst)
        {
#ifdef UNICODE
            pFI->pfnCreateFontIndirectEx = (PFNCREATEFONTINDIRECTEX)GetProcAddress(hinst, "CreateFontIndirectExW");
#else
            pFI->pfnCreateFontIndirectEx = (PFNCREATEFONTINDIRECTEX)GetProcAddress(hinst, "CreateFontIndirectExA");
#endif
        }
    }
#endif // MM_DESIGNVECTOR_DEFINED
    //
    //  Get the process version of the app for later use.
    //
    pFI->ProcessVersion = GetProcessVersion(0);

    //
    //  Get the default user language id for later use.
    //
    UserLangID = GetUserDefaultLangID();


    //
    //  Verify that lpfnHook is not null if CF_ENABLEHOOK is specified.
    //
    if (lpCF->Flags & CF_ENABLEHOOK)
    {
        if (!lpCF->lpfnHook)
        {
            if (fAllocLogFont)
            {
                LocalFree(lpCF->lpLogFont);
                lpCF->lpLogFont = NULL;
            }
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        lpCF->lpfnHook = NULL;
    }

    if (lpCF->Flags & CF_ENABLETEMPLATE)
    {
        //
        //  Both custom instance handle and the dialog template name are
        //  user specified. Locate the dialog resource in the specified
        //  instance block and load it.
        //
        if (!(hRes = FindResource(lpCF->hInstance, lpCF->lpTemplateName, RT_DIALOG)))
        {
            if (fAllocLogFont)
            {
                LocalFree(lpCF->lpLogFont);
                lpCF->lpLogFont = NULL;
            }
            StoreExtendedError(CDERR_FINDRESFAILURE);
            return (FALSE);
        }
        if (!(hDlgTemplate = LoadResource(lpCF->hInstance, hRes)))
        {
            if (fAllocLogFont)
            {
                LocalFree(lpCF->lpLogFont);
                lpCF->lpLogFont = NULL;
            }
            StoreExtendedError(CDERR_LOADRESFAILURE);
            return (FALSE);
        }
    }
    else if (lpCF->Flags & CF_ENABLETEMPLATEHANDLE)
    {
        //
        //  A handle to the pre-loaded resource has been specified.
        //
        hDlgTemplate = lpCF->hInstance;
    }
    else
    {
        id = FORMATDLGORD31;

        if (!(hRes = FindResource(g_hinst, MAKEINTRESOURCE(id), RT_DIALOG)))
        {
            if (fAllocLogFont)
            {
                LocalFree(lpCF->lpLogFont);
                lpCF->lpLogFont = NULL;
            }
            StoreExtendedError(CDERR_FINDRESFAILURE);
            return (FALSE);
        }
        if (!(hDlgTemplate = LoadResource(g_hinst, hRes)))
        {
            if (fAllocLogFont)
            {
                LocalFree(lpCF->lpLogFont);
                lpCF->lpLogFont = NULL;
            }
            StoreExtendedError(CDERR_LOADRESFAILURE);
            return (FALSE);
        }
    }

    if (LockResource(hDlgTemplate))
    {
        if (lpCF->Flags & CF_ENABLEHOOK)
        {
            glpfnFontHook = GETHOOKFN(lpCF);
        }

#ifdef UNICODE
        if (IS16BITWOWAPP(lpCF))
        {
            uiWOWFlag = SCDLG_16BIT;
        }

        iRet = DialogBoxIndirectParamAorW( g_hinst,
                                           (LPDLGTEMPLATE)hDlgTemplate,
                                           lpCF->hwndOwner,
                                           FormatCharDlgProc,
                                           (LPARAM)pFI,
                                           uiWOWFlag );
#else
        iRet = DialogBoxIndirectParam( g_hinst,
                                       (LPDLGTEMPLATE)hDlgTemplate,
                                       lpCF->hwndOwner,
                                       FormatCharDlgProc,
                                       (LPARAM)pFI );
#endif

        glpfnFontHook = 0;

        if (iRet == -1 || ((iRet == 0) && (!bUserPressedCancel) && (!GetStoredExtendedError())))
        {
            StoreExtendedError(CDERR_DIALOGFAILURE);
        }
    }
    else
    {
        StoreExtendedError(CDERR_LOCKRESFAILURE);
    }

    if (fAllocLogFont)
    {
        LocalFree(lpCF->lpLogFont);
        lpCF->lpLogFont = NULL;
    } 
#ifdef MM_DESIGNVECTOR_DEFINED
    else
    {
        if (!(fl & CHF_DESIGNVECTOR))
        {
            UINT i;
            BOOL bDefaultAxis = TRUE;
            if (pFI->DefaultDesignVector.dvNumAxes != ((LPENUMLOGFONTEXDVW)lpCF->lpLogFont)->elfDesignVector.dvNumAxes)
            {
                bDefaultAxis = FALSE;
            }
            else
            {
                for (i=0; i<pFI->DefaultDesignVector.dvNumAxes; i++)
                {
                    if (pFI->DefaultDesignVector.dvValues[i] != ((LPENUMLOGFONTEXDVW)lpCF->lpLogFont)->elfDesignVector.dvValues[i])
                    {
                        bDefaultAxis = FALSE;
                    }
                }
            }

            if (!bDefaultAxis)
            {
                AddDesignVectorToName(lpCF->lpLogFont->lfFaceName, 
                    &((LPENUMLOGFONTEXDVW)lpCF->lpLogFont)->elfDesignVector);
            }
        }
    }
#endif // MM_DESIGNVECTOR_DEFINED

    return (iRet == IDOK);
}

#ifdef MM_DESIGNVECTOR_DEFINED
////////////////////////////////////////////////////////////////////////////
//
//  SetMMAxesSelection
//
////////////////////////////////////////////////////////////////////////////

VOID SetMMAxesSelection(
    HWND hDlg,
    LPCHOOSEFONT lpcf)
{
    UINT i;
    SCROLLINFO scri;

    if (MAX_NUM_AXES < ((LPENUMLOGFONTEXDV)lpcf->lpLogFont)->elfDesignVector.dvNumAxes)
    {
        ((LPENUMLOGFONTEXDV)lpcf->lpLogFont)->elfDesignVector.dvNumAxes = 0; // for safety, set NumAxis to zero
//        MessageBox (hDlg, TEXT("Cannot support so many axes"), TEXT("Error"), MB_OK | MB_ICONEXCLAMATION);
        return;
    }

    for (i=0; i<((LPENUMLOGFONTEXDV)lpcf->lpLogFont)->elfDesignVector.dvNumAxes; i++)
    {
            // setting the positions of scroll bars according to MM Axes values
            scri.nPos   = ((LPENUMLOGFONTEXDV)lpcf->lpLogFont)->elfDesignVector.dvValues[i];
            scri.fMask  = SIF_POS;
            SetScrollInfo(GetDlgItem(hDlg, scr1 + i), SB_CTL, &scri, TRUE);
            SetDlgItemInt ( hDlg, edt1 + i, scri.nPos, TRUE);
    }

}
#endif // MM_DESIGNVECTOR_DEFINED

////////////////////////////////////////////////////////////////////////////
//
//  SetStyleSelection
//
////////////////////////////////////////////////////////////////////////////

VOID SetStyleSelection(
    HWND hDlg,
    LPCHOOSEFONT lpcf,
    BOOL bInit)
{
    if (!(lpcf->Flags & CF_NOSTYLESEL))
    {
        if (bInit && (lpcf->Flags & CF_USESTYLE))
        {
            PLOGFONT plf;
            int iSel;

            iSel = CBSetSelFromText(GetDlgItem(hDlg, cmb2), lpcf->lpszStyle);
            if (iSel >= 0)
            {
                LPITEMDATA lpItemData =
                     (LPITEMDATA)SendDlgItemMessage( hDlg,
                                                     cmb2,
                                                     CB_GETITEMDATA,
                                                     iSel,
                                                     0L );
                if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
                {
                    plf = lpItemData->pLogFont;

                    lpcf->lpLogFont->lfWeight = plf->lfWeight;
                    lpcf->lpLogFont->lfItalic = plf->lfItalic;
                }
                else
                {
                    lpcf->lpLogFont->lfWeight = FW_NORMAL;
                    lpcf->lpLogFont->lfItalic = 0;
                }
            }
            else
            {
                lpcf->lpLogFont->lfWeight = FW_NORMAL;
                lpcf->lpLogFont->lfItalic = 0;
            }
        }
        else
        {
            SelectStyleFromLF(GetDlgItem(hDlg, cmb2), lpcf->lpLogFont);
        }

        CBSetTextFromSel(GetDlgItem(hDlg, cmb2));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  HideDlgItem
//
////////////////////////////////////////////////////////////////////////////

VOID HideDlgItem(
    HWND hDlg,
    int id)
{
    EnableWindow(GetDlgItem(hDlg, id), FALSE);
    ShowWindow(GetDlgItem(hDlg, id), SW_HIDE);
}


////////////////////////////////////////////////////////////////////////////
//
//  FixComboHeights
//
//  Fixes the ownerdraw combo boxes to match the height of the non
//  ownerdraw combo boxes.
//
////////////////////////////////////////////////////////////////////////////

VOID FixComboHeights(
    HWND hDlg)
{
    LPARAM height;

    height = SendDlgItemMessage(hDlg, cmb2, CB_GETITEMHEIGHT, (WPARAM)-1, 0L);
    SendDlgItemMessage(hDlg, cmb1, CB_SETITEMHEIGHT, (WPARAM)-1, height);
    SendDlgItemMessage(hDlg, cmb3, CB_SETITEMHEIGHT, (WPARAM)-1, height);
}


////////////////////////////////////////////////////////////////////////////
//
//  FormatCharDlgProc
//
//  Message handler for font dlg
//
//  chx1 - "underline" checkbox
//  chx2 - "strikeout" checkbox
//  psh4 - "help" pushbutton
//
//  On WM_INITDIALOG message, the choosefont is accessed via lParam,
//  and stored in the window's prop list.  If a hook function has been
//  specified, it is invoked AFTER the current function has processed
//  WM_INITDIALOG.
//
//  For all other messages, control is passed directly to the hook
//  function first.  Depending on the latter's return value, the message
//  is processed by this function.
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK FormatCharDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PFONTINFO pFI;
    PAINTSTRUCT ps;
    TEXTMETRIC tm;
    HDC hDC;                      // handle to screen DC
    LPCHOOSEFONT pCF = NULL;      // ptr to struct passed to ChooseFont()
    HWND hWndHelp;                // handle to Help... pushbutton
    short nIndex;                 // at init, see if color matches
    TCHAR szPoints[20];
    HDC hdc;
    HFONT hFont;
    DWORD dw;
    BOOL bRet;
    LPTSTR lpRealFontName, lpSubFontName;
    int iResult;
    BOOL bContinueChecking;

#ifdef MM_DESIGNVECTOR_DEFINED
    int i, nCode, nPos, oldPos;
    HWND hwndScr;
#endif // MM_DESIGNVECTOR_DEFINED

    //
    //  If CHOOSEFONT struct has already been accessed and if a hook
    //  function is specified, let it do the processing first.
    //
    if (pFI = (PFONTINFO)GetProp(hDlg, FONTPROP))
    {
        if ((pCF = (LPCHOOSEFONT)pFI->pCF) &&
            (pCF->lpfnHook))
        {
            LPCFHOOKPROC lpfnHook = GETHOOKFN(pCF);

            if ((bRet = (*lpfnHook)(hDlg, wMsg, wParam, lParam)))
            {
                if ((wMsg == WM_COMMAND) &&
                    (GET_WM_COMMAND_ID(wParam, lParam) == IDCANCEL))
                {
                    //
                    //  Set global flag stating that the user pressed cancel.
                    //
                    bUserPressedCancel = TRUE;
                }
                return (bRet);
            }
        }
    }
    else
    {
        if (glpfnFontHook &&
            (wMsg != WM_INITDIALOG) &&
            (bRet = (* glpfnFontHook)(hDlg, wMsg, wParam, lParam)))
        {
            return (bRet);
        }
    }

    switch (wMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            if (!LoadString(g_hinst, iszRegular, (LPTSTR)szRegular, CCHSTYLE) ||
                !LoadString(g_hinst, iszBold, (LPTSTR)szBold, CCHSTYLE)       ||
                !LoadString(g_hinst, iszItalic, (LPTSTR)szItalic, CCHSTYLE)   ||
                !LoadString(g_hinst, iszBoldItalic, (LPTSTR)szBoldItalic, CCHSTYLE))
            {
                StoreExtendedError(CDERR_LOADSTRFAILURE);
                EndDialog(hDlg, FALSE);
                return (FALSE);
            }

            pFI = (PFONTINFO)lParam;
            pCF = pFI->pCF;
            if ((pCF->Flags & CF_LIMITSIZE) &&
                (pCF->nSizeMax < pCF->nSizeMin))
            {
                StoreExtendedError(CFERR_MAXLESSTHANMIN);
                EndDialog(hDlg, FALSE);
                return (FALSE);
            }

            //
            //  Save ptr to CHOOSEFONT struct in the dialog's prop list.
            //  Alloc a temp LOGFONT struct to be used for the length of
            //  the dialog session, the contents of which will be copied
            //  over to the final LOGFONT (pointed to by CHOOSEFONT)
            //  only if <OK> is selected.
            //
            SetProp(hDlg, FONTPROP, (HANDLE)pFI);
            glpfnFontHook = 0;

            hDlgFont = (HFONT)SendMessage(hDlg, WM_GETFONT, 0, 0L);

            if (!hbmFont)
            {
                hbmFont = LoadBitmaps(BMFONT);
            }

            if (!(pCF->Flags & CF_APPLY))
            {
                HideDlgItem(hDlg, psh3);
            }

            if (!(pCF->Flags & CF_EFFECTS))
            {
                HideDlgItem(hDlg, stc4);
                HideDlgItem(hDlg, cmb4);
            }
            else
            {
                //
                //  Fill color list.
                //
                FillColorCombo(hDlg);
                for (nIndex = CCHCOLORS - 1; nIndex > 0; nIndex--)
                {
                    dw = (DWORD) SendDlgItemMessage( hDlg,
                                                     cmb4,
                                                     CB_GETITEMDATA,
                                                     nIndex,
                                                     0L );
                    if (pCF->rgbColors == dw)
                    {
                        break;
                    }
                }
                SendDlgItemMessage(hDlg, cmb4, CB_SETCURSEL, nIndex, 0L);
            }

            GetWindowRect(GetDlgItem (hDlg, stc5), &pFI->rcText);
            MapWindowPoints(NULL, hDlg, (POINT *)(&pFI->rcText), 2);
            FixComboHeights(hDlg);

            //
            //  Init our LOGFONT.
            //
            if (!(pCF->Flags & CF_INITTOLOGFONTSTRUCT))
            {
                InitLF(pCF->lpLogFont);
            }

            //
            //  Init effects.
            //
            if (!(pCF->Flags & CF_EFFECTS))
            {
                HideDlgItem(hDlg, grp1);
                HideDlgItem(hDlg, chx1);
                HideDlgItem(hDlg, chx2);
            }
            else
            {
                CheckDlgButton(hDlg, chx1, pCF->lpLogFont->lfStrikeOut);
                CheckDlgButton(hDlg, chx2, pCF->lpLogFont->lfUnderline);
            }

            pFI->nLastFontType = 0;

            if (!GetFontFamily( hDlg,
                                pCF->hDC,
                                pCF->Flags,
                                pCF->lpLogFont->lfCharSet ))
            {
                StoreExtendedError(CFERR_NOFONTS);
                if (pCF->Flags & CF_ENABLEHOOK)
                {
                    glpfnFontHook = GETHOOKFN(pCF);
                }
                EndDialog(hDlg, FALSE);
                return (FALSE);
            }

            if (!(pCF->Flags & CF_NOFACESEL) && *pCF->lpLogFont->lfFaceName)
            {
                //
                //  We want to select the font the user has requested.
                //
                iResult = CBSetSelFromText( GetDlgItem(hDlg, cmb1),
                                            pCF->lpLogFont->lfFaceName );

                //
                //  If iResult == CB_ERR, then we could be working with a
                //  font subsitution name (eg: MS Shell Dlg).
                //
                if (iResult == CB_ERR)
                {
                    lpSubFontName = pCF->lpLogFont->lfFaceName;
                }

                //
                //  Allocate a buffer to store the real font name in.
                //
                lpRealFontName = GlobalAlloc(GPTR, MAX_PATH * sizeof(TCHAR));

                if (!lpRealFontName)
                {
                    StoreExtendedError(CDERR_MEMALLOCFAILURE);
                    EndDialog(hDlg, FALSE);
                    return (FALSE);
                }

                //
                //  The while loop is necessary in order to resolve
                //  substitions pointing to subsitutions.
                //     eg:  Helv->MS Shell Dlg->MS Sans Serif
                //
                bContinueChecking = TRUE;
                while ((iResult == CB_ERR) && bContinueChecking)
                {
                    bContinueChecking = LookUpFontSubs( lpSubFontName,
                                                        lpRealFontName );

                    //
                    //  If bContinueChecking is TRUE, then we have a font
                    //  name.  Try to select that in the list.
                    //
                    if (bContinueChecking)
                    {
                        iResult = CBSetSelFromText( GetDlgItem(hDlg, cmb1),
                                                    lpRealFontName );
                    }

                    lpSubFontName = lpRealFontName;
                }

                //
                //  Free our buffer.
                //
                GlobalFree(lpRealFontName);

                //
                //  Set the edit control text if appropriate.
                //
                if (iResult != CB_ERR)
                {
                    CBSetTextFromSel(GetDlgItem(hDlg, cmb1));
                }
            }

            hdc = GetDC(NULL);

            if (pCF->Flags & CF_NOSCRIPTSEL)
            {
                hWndHelp = GetDlgItem(hDlg, cmb5);
                if (hWndHelp)
                {
                    LoadString( g_hinst,
                                iszNoScript,
                                szPoints,
                                sizeof(szPoints) / sizeof(TCHAR));
                    CBAddScript(hWndHelp, szPoints, DEFAULT_CHARSET);
                    EnableWindow(hWndHelp, FALSE);
                }
                DefaultCharset = DEFAULT_CHARSET;
                pFI->iCharset = DEFAULT_CHARSET;
            }
            else if (pCF->Flags & (CF_SELECTSCRIPT | CF_INITTOLOGFONTSTRUCT))
            {
                //
                //  We could come in here with a bogus value, if the app is
                //  NOT 4.0, that would result in the bogus charset not
                //  being found for the facename, and the default would be
                //  put back again anyway.
                //
                pFI->iCharset = pCF->lpLogFont->lfCharSet;
            }
            else
            {
                DefaultCharset = GetTextCharset(hdc);
                pFI->iCharset = DefaultCharset;
            }

            GetFontStylesAndSizes(hDlg, pFI, pCF, TRUE);

            if (!(pCF->Flags & CF_NOSTYLESEL))
            {
                SetStyleSelection(hDlg, pCF, TRUE);
            }

            if (!(pCF->Flags & CF_NOSIZESEL) && pCF->lpLogFont->lfHeight)
            {
                GetPointString(szPoints, hdc, pCF->lpLogFont->lfHeight);
                CBSetSelFromText(GetDlgItem(hDlg, cmb3), szPoints);
                SetDlgItemText(hDlg, cmb3, szPoints);
            }

#ifdef MM_DESIGNVECTOR_DEFINED
            SetMMAxesSelection(hDlg, pCF);
#endif // MM_DESIGNVECTOR_DEFINED

            ReleaseDC(NULL, hdc);

            //
            //  Hide the help button if it isn't needed.
            //
            if (!(pCF->Flags & CF_SHOWHELP))
            {
                ShowWindow(hWndHelp = GetDlgItem(hDlg, pshHelp), SW_HIDE);
                EnableWindow(hWndHelp, FALSE);
            }

            SendDlgItemMessage(hDlg, cmb1, CB_LIMITTEXT, LF_FACESIZE - 1, 0L);
            SendDlgItemMessage(hDlg, cmb2, CB_LIMITTEXT, LF_FACESIZE - 1, 0L);
            SendDlgItemMessage(hDlg, cmb3, CB_LIMITTEXT, 5, 0L);

            //
            //  If hook function has been specified, let it do any additional
            //  processing of this message.
            //
            if (pCF->lpfnHook)
            {
                LPCFHOOKPROC lpfnHook = GETHOOKFN(pCF);
#ifdef UNICODE
                if (pFI->ApiType == COMDLG_ANSI)
                {
                    ThunkChooseFontW2A(pFI);
                    bRet = (*lpfnHook)( hDlg,
                                        wMsg,
                                        wParam,
                                        (LPARAM)pFI->pCFA );
                    ThunkChooseFontA2W(pFI);
                }
                else
#endif
                {
                    bRet = (*lpfnHook)( hDlg,
                                        wMsg,
                                        wParam,
                                        (LPARAM)pCF );
                }
                return (bRet);
            }

            SetCursor(LoadCursor(NULL, IDC_ARROW));

            break;
        }
        case ( WM_DESTROY ) :
        {
            if (pCF)
            {
                RemoveProp(hDlg, FONTPROP);
            }
            break;
        }
        case ( WM_PAINT ) :
        {
            if (!pFI)
            {
                return (FALSE);
            }

            if (BeginPaint(hDlg, &ps))
            {
                DrawSampleText(hDlg, pFI, pCF, ps.hdc);
                EndPaint(hDlg, &ps);
            }
            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            hDC = GetDC(hDlg);
            hFont = (HFONT)SendMessage(hDlg, WM_GETFONT, 0, 0L);
            if (hFont)
            {
                hFont = SelectObject(hDC, hFont);
            }
            GetTextMetrics(hDC, &tm);
            if (hFont)
            {
                SelectObject(hDC, hFont);
            }
            ReleaseDC(hDlg, hDC);

            if (((LPMEASUREITEMSTRUCT)lParam)->itemID != -1)
            {
                ((LPMEASUREITEMSTRUCT)lParam)->itemHeight =
                       max(tm.tmHeight, DY_BITMAP);
            }
            else
            {
                //
                //  This is for 3.0 only.  In 3.1, the CB_SETITEMHEIGHT
                //  will fix this.  Note, this is off by one on 8514.
                //
                ((LPMEASUREITEMSTRUCT)lParam)->itemHeight = tm.tmHeight + 1;
            }

            break;
        }
        case ( WM_DRAWITEM ) :
        {
#define lpdis ((LPDRAWITEMSTRUCT)lParam)

            if (lpdis->itemID == (UINT)-1)
            {
                break;
            }

            if (lpdis->CtlID == cmb4)
            {
                DrawColorComboItem(lpdis);
            }
            else if (lpdis->CtlID == cmb1)
            {
                DrawFamilyComboItem(lpdis);
            }
            else
            {
                DrawSizeComboItem(lpdis);
            }
            break;

#undef lpdis
        }
        case ( WM_SYSCOLORCHANGE ) :
        {
            DeleteObject(hbmFont);
            hbmFont = LoadBitmaps(BMFONT);
            break;
        }
        case ( WM_COMMAND ) :
        {
            if (!pFI)
            {
                return (FALSE);
            }

            return (ProcessDlgCtrlCommand(hDlg, pFI, wParam, lParam));
            break;
        }
        case ( WM_HELP ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPVOID)aFontHelpIDs );
            }
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)wParam,
                         NULL,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)aFontHelpIDs );
            }
            break;
        }
        case ( WM_CHOOSEFONT_GETLOGFONT ) :
        {
Handle_WM_CHOOSEFONT_GETLOGFONT:
            if (!pFI)
            {
                return (FALSE);
            }

#ifdef UNICODE
            if (pFI->ApiType == COMDLG_ANSI)
            {
                BOOL bRet;
#ifdef MM_DESIGNVECTOR_DEFINED
                if (pFI->pfnCreateFontIndirectEx != NULL)
                {
                    ENUMLOGFONTEXDV elfdv;

                    bRet = FillInFontEx(hDlg, pFI, pCF, &elfdv, TRUE);

                    ThunkEnumLogFontExDvW2A(&elfdv, (LPENUMLOGFONTEXDVA)lParam);
                } 
                else
                {
                    LOGFONT lf;

                    bRet = FillInFont(hDlg, pFI, pCF, &lf, TRUE);

                    ThunkLogFontW2A(&lf, (LPLOGFONTA)lParam);
                }
#else
                LOGFONT lf;

                bRet = FillInFont(hDlg, pFI, pCF, &lf, TRUE);

                ThunkLogFontW2A(&lf, (LPLOGFONTA)lParam);
#endif // MM_DESIGNVECTOR_DEFINED

                return (bRet);
            }
            else
#endif
            {
#ifdef MM_DESIGNVECTOR_DEFINED
                return (FillInFontEx(hDlg, pFI, pCF, (LPENUMLOGFONTEXDV)lParam, TRUE));
#else
                return (FillInFont(hDlg, pFI, pCF, (LPLOGFONT)lParam, TRUE));
#endif // MM_DESIGNVECTOR_DEFINED
            }
        }
        case ( WM_CHOOSEFONT_SETLOGFONT ) :
        {
            if (!pFI)
            {
                return (FALSE);
            }

#ifdef UNICODE
            if (pFI->ApiType == COMDLG_ANSI)
            {
#ifdef MM_DESIGNVECTOR_DEFINED
                if (pFI->pfnCreateFontIndirectEx != NULL)
                {
                    ENUMLOGFONTEXDV elfdv;

                    ThunkEnumLogFontExDvA2W((LPENUMLOGFONTEXDVA)lParam, &elfdv);

                    return (SetLogFontEx(hDlg, pCF, &elfdv));
                }
                else
                {
                   LOGFONT lf;

                    ThunkLogFontA2W((LPLOGFONTA)lParam, &lf);

                    return (SetLogFont(hDlg, pCF, &lf));
                }
#else
                LOGFONT lf;

                ThunkLogFontA2W((LPLOGFONTA)lParam, &lf);

                return (SetLogFont(hDlg, pCF, &lf));
#endif // MM_DESIGNVECTOR_DEFINED
            }
            else
#endif
            {
#ifdef MM_DESIGNVECTOR_DEFINED
                if (pFI->pfnCreateFontIndirectEx != NULL)
                {
                    return (SetLogFontEx(hDlg, pCF, (LPENUMLOGFONTEXDV)lParam));
                }
                else
                {
                    return (SetLogFont(hDlg, pCF, (LPLOGFONT)lParam));
                }
#else
                return (SetLogFont(hDlg, pCF, (LPLOGFONT)lParam));
#endif // MM_DESIGNVECTOR_DEFINED
            }
            break;
        }
        case ( WM_CHOOSEFONT_SETFLAGS ) :
        {
            DWORD dwFlags = pCF->Flags;

            pCF->Flags = (DWORD) lParam;
            SetDlgMsgResult(hDlg, WM_CHOOSEFONT_SETFLAGS, dwFlags);
            return (TRUE);
        }
#ifdef MM_DESIGNVECTOR_DEFINED
        case ( WM_HSCROLL ) :
        {
             nCode = (int) LOWORD(wParam);  // scroll bar value 
             nPos = (short int) HIWORD(wParam);   // scroll box position 
             hwndScr = (HWND) lParam;       // handle to scroll bar               

             i = 0;
             while ((GetDlgItem(hDlg, scr1 + i) != hwndScr) && (i < MAX_NUM_AXES))
                 i++;
             if (i >= MAX_NUM_AXES)
                 return (FALSE);

             if (nCode == SB_THUMBPOSITION)
             {
                 SetDlgItemInt ( hDlg, edt1 + i, nPos,  TRUE );
                 SendMessage(hwndScr, SBM_SETPOS, nPos, (LPARAM)TRUE);

                 // redraw sample text
                 GetWindowRect(GetDlgItem (hDlg, stc5), &pFI->rcText);
                 MapWindowPoints(NULL, hDlg, (POINT *)(&pFI->rcText), 2);
                 InvalidateRect(hDlg, &pFI->rcText, FALSE);
                 UpdateWindow(hDlg);

                 return (TRUE);
             }

             if (nCode == SB_THUMBTRACK)
             {
                 SetDlgItemInt ( hDlg, edt1 + i, nPos,  TRUE );
                 SendMessage(hwndScr, SBM_SETPOS, nPos, (LPARAM)TRUE);

                 // redraw sample text
                 GetWindowRect(GetDlgItem (hDlg, stc5), &pFI->rcText);
                 MapWindowPoints(NULL, hDlg, (POINT *)(&pFI->rcText), 2);
                 InvalidateRect(hDlg, &pFI->rcText, FALSE);
                 UpdateWindow(hDlg);

                 return (TRUE);
             }

             oldPos = (int)SendMessage(hwndScr, SBM_GETPOS, 0, 0);
             if (nCode == SB_LINELEFT)
                 oldPos -= 1;
             if (nCode == SB_LINERIGHT)
                 oldPos += 1;
             if (nCode == SB_PAGELEFT)
                 oldPos -= 10;
             if (nCode == SB_PAGERIGHT)
                 oldPos += 10;
             if (nCode == SB_LINELEFT || nCode == SB_LINERIGHT || nCode == SB_PAGELEFT || nCode == SB_PAGERIGHT)
             {
                 SetDlgItemInt ( hDlg, edt1 + i, oldPos,  TRUE );
                 SendMessage(hwndScr, SBM_SETPOS, oldPos, (LPARAM)TRUE);

                 // redraw the sample text
                 GetWindowRect(GetDlgItem (hDlg, stc5), &pFI->rcText);
                 MapWindowPoints(NULL, hDlg, (POINT *)(&pFI->rcText), 2);
                 InvalidateRect(hDlg, &pFI->rcText, FALSE);
                 UpdateWindow(hDlg);

                 return (TRUE);
             }
             return (TRUE);
        }
#endif // MM_DESIGNVECTOR_DEFINED
        default :
        {
            if (wMsg == msgWOWCHOOSEFONT_GETLOGFONT)
            {
                goto Handle_WM_CHOOSEFONT_GETLOGFONT;
            }
            return (FALSE);
        }
    }
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SelectStyleFromLF
//
//  Given a logfont, selects the closest match in the style list.
//
////////////////////////////////////////////////////////////////////////////

void SelectStyleFromLF(
    HWND hwnd,
    LPLOGFONT lplf)
{
    int ctr, count, iSel;
    PLOGFONT plf;
    int weight_delta, best_weight_delta = 1000;
    BOOL bIgnoreItalic;
    LPITEMDATA lpItemData;


    count = (int)SendMessage(hwnd, CB_GETCOUNT, 0, 0L);
    iSel = 0;
    bIgnoreItalic = FALSE;

TryAgain:
    for (ctr = 0; ctr < count; ctr++)
    {
        lpItemData = (LPITEMDATA)SendMessage(hwnd, CB_GETITEMDATA, ctr, 0L);

        if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
        {
            plf = lpItemData->pLogFont;

            if (bIgnoreItalic ||
                (plf->lfItalic && lplf->lfItalic) ||
                (!plf->lfItalic && !lplf->lfItalic))
            {
                weight_delta = lplf->lfWeight - plf->lfWeight;
                if (weight_delta < 0)
                {
                    weight_delta = -weight_delta;
                }

                if (weight_delta < best_weight_delta)
                {
                    best_weight_delta = weight_delta;
                    iSel = ctr;
                }
            }
        }
    }
    if (!bIgnoreItalic && iSel == 0)
    {
        bIgnoreItalic = TRUE;
        goto TryAgain;
    }

    SendMessage(hwnd, CB_SETCURSEL, iSel, 0L);
}


////////////////////////////////////////////////////////////////////////////
//
//  CBSetTextFromSel
//
//  Makes the currently selected item the edit text for a combo box.
//
////////////////////////////////////////////////////////////////////////////

int CBSetTextFromSel(
    HWND hwnd)
{
    int iSel;
    TCHAR szFace[LF_FACESIZE];

    iSel = (int)SendMessage(hwnd, CB_GETCURSEL, 0, 0L);
    if (iSel >= 0)
    {
        SendMessage(hwnd, CB_GETLBTEXT, iSel, (LONG_PTR)(LPTSTR)szFace);
        SetWindowText(hwnd, szFace);
    }
    return (iSel);
}


////////////////////////////////////////////////////////////////////////////
//
//  CBSetSelFromText
//
//  Sets the selection based on lpszString.  Sends notification messages
//  if bNotify is TRUE.
//
////////////////////////////////////////////////////////////////////////////

int CBSetSelFromText(
    HWND hwnd,
    LPTSTR lpszString)
{
    int iInd;

    iInd = CBFindString(hwnd, lpszString);

    if (iInd >= 0)
    {
        SendMessage(hwnd, CB_SETCURSEL, iInd, 0L);
    }
    return (iInd);
}


////////////////////////////////////////////////////////////////////////////
//
//  CBGetTextAndData
//
//  Returns the text and item data for a combo box based on the current
//  edit text.  If the current edit text does not match anything in the
//  listbox, then CB_ERR is returned.
//
////////////////////////////////////////////////////////////////////////////

int CBGetTextAndData(
    HWND hwnd,
    LPTSTR lpszString,
    int iSize,
    PULONG_PTR lpdw)
{
    LRESULT Result;
    int iSel;

    if (lpszString == NULL)
    {
        if ((Result = SendMessage(hwnd, CB_GETITEMDATA, 0, 0L)) < 0)
        {
            return ((int) Result);
        }
        else
        {
            *lpdw = Result;
            return (0);
        }
    }

    GetWindowText(hwnd, lpszString, iSize);
    iSel = CBFindString(hwnd, lpszString);
    if (iSel < 0)
    {
        return (iSel);
    }

    *lpdw = SendMessage(hwnd, CB_GETITEMDATA, iSel, 0L);
    return (iSel);
}


////////////////////////////////////////////////////////////////////////////
//
//  CBFindString
//
//  Does an exact string find and returns the index.
//
////////////////////////////////////////////////////////////////////////////

int CBFindString(
    HWND hwnd,
    LPTSTR lpszString)
{
    return ((int)SendMessage( hwnd,
                              CB_FINDSTRINGEXACT,
                              (WPARAM)-1,
                              (LPARAM)(LPCSTR)lpszString ));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetPointSizeInRange
//
//  Ensures that the point size edit field is in range.
//
//  Returns:  Point Size - of the edit field limitted by MIN/MAX size
//            0          - if the field is empty
//
////////////////////////////////////////////////////////////////////////////

#define GPS_COMPLAIN    0x0001
#define GPS_SETDEFSIZE  0x0002

BOOL GetPointSizeInRange(
    HWND hDlg,
    LPCHOOSEFONT lpcf,
    LPINT pts,
    WORD wFlags)
{
    TCHAR szBuffer[90];
    TCHAR szTitle[90];
    int nTmp;
    int nTmpFr = 0;
    BOOL bOK;

    *pts = 0;

    if (GetDlgItemText(hDlg, cmb3, szBuffer, sizeof(szBuffer) / sizeof(TCHAR)))
    {
        nTmp = GetDlgItemInt(hDlg, cmb3, &bOK, TRUE);

        if (!bOK && (IS_SIMPLIFIED_CHINESE(UserLangID)))
        {
            int ctr;
            LPTSTR lpsz = szBuffer;

            //
            //  Skip leading white space.
            //
            while (*lpsz == TEXT(' '))
            {
                lpsz++;
            }
            for (ctr = 0; ctr < NUM_ZIHAO; ctr++)
            {
                if (!lstrcmpi(lpsz, stZihao[ctr].name))
                {
                    bOK = TRUE;
                    nTmp = stZihao[ctr].size;
                    nTmpFr = stZihao[ctr].sizeFr;
                    break;
                }
            }
        }

        if (!bOK)
        {
            nTmp = 0;
        }
    }
    else if (wFlags & GPS_SETDEFSIZE)
    {
        nTmp = DEF_POINT_SIZE;
        bOK = TRUE;
    }
    else
    {
        //
        //  We're just returning with 0 in *pts.
        //
        return (FALSE);
    }

    //
    //  Check that we got a number in range.
    //
    if (wFlags & GPS_COMPLAIN)
    {
        if ((lpcf->Flags & CF_LIMITSIZE) &&
            (!bOK || (nTmp > lpcf->nSizeMax) || (nTmp < lpcf->nSizeMin)))
        {
            bOK = FALSE;
            LoadString( g_hinst,
                        iszSizeRange,
                        szTitle,
                        sizeof(szTitle) / sizeof(TCHAR) );

            wsprintf( (LPTSTR)szBuffer,
                      (LPTSTR)szTitle,
                      lpcf->nSizeMin,
                      lpcf->nSizeMax );
        }
        else if (!bOK)
        {
            LoadString( g_hinst,
                        iszSizeNumber,
                        szBuffer,
                        sizeof(szBuffer) / sizeof(TCHAR) );
        }

        if (!bOK)
        {
            GetWindowText(hDlg, szTitle, sizeof(szTitle) / sizeof(TCHAR));
            MessageBox(hDlg, szBuffer, szTitle, MB_OK | MB_ICONINFORMATION);
            return (FALSE);
        }
    }

    *pts = nTmp * 10 + nTmpFr;
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ResetSampleFromScript
//
////////////////////////////////////////////////////////////////////////////

BOOL ResetSampleFromScript(
    HWND hDlg,
    HWND hwndScript,
    PFONTINFO pFI)
{
    int iSel;
    TCHAR szScript[LF_FACESIZE];
    LPITEMDATA lpItemData;

    if (IsWindow(hwndScript) && IsWindowEnabled(hwndScript))
    {
        iSel = (int)SendMessage(hwndScript, CB_GETCURSEL, 0, 0L);
        if (iSel >= 0)
        {
            lpItemData = (LPITEMDATA)SendMessage( hwndScript,
                                                  CB_GETITEMDATA,
                                                  iSel,
                                                  0L );
            if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
            {
                pFI->iCharset = lpItemData->nFontType;
            }
        }
    }

    if (!LoadString( g_hinst,
                     pFI->iCharset + iszFontSample,
                     szScript,
                     LF_FACESIZE ))
    {
        return (FALSE);
    }

    SetDlgItemText(hDlg, stc5, szScript);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ProcessDlgCtrlCommand
//
//  Handles all WM_COMMAND messages for the font dialog.
//
//  cmb1 - ID of font facename combobox
//  cmb2 - style
//  cmb3 - size
//  chx1 - "Underline" checkbox
//  chx2 - "Strikeout" checkbox
//  stc5 - frame around text preview area
//  psh4 - button that invokes the Help application
//  IDOK - OK button to end dialog, retaining information
//  IDCANCEL - button to cancel dialog, not doing anything
//
//  Returns:   TRUE    - if message is processed successfully
//             FALSE   - otherwise
//
////////////////////////////////////////////////////////////////////////////

BOOL ProcessDlgCtrlCommand(
    HWND hDlg,
    PFONTINFO pFI,
    WPARAM wParam,
    LPARAM lParam)
{
    int iSel;
    LPCHOOSEFONT pCF = (pFI ? pFI->pCF : NULL);
    TCHAR szPoints[10];
    TCHAR szStyle[LF_FACESIZE];
    LPITEMDATA lpItemData;
    WORD wCmbId;
    TCHAR szMsg[160], szTitle[160];


    if (pCF)
    {
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case ( IDABORT ) :
            {
                //
                //  This is how a hook can cause the dialog to go away.
                //
                FreeAllItemData(hDlg, pFI);
                if (pCF->Flags & CF_ENABLEHOOK)
                {
                    glpfnFontHook = GETHOOKFN(pCF);
                }
                
                // ISSUE ARULK Why are we returning an HWND anyway?  
                // The caller (ChooseFontX) expects us to return a BOOL

                EndDialog(hDlg, BOOLFROMPTR(GET_WM_COMMAND_HWND(wParam, lParam)));
                break;
            }
            case ( IDOK ) :
            {
                //
                //  Make sure the focus is set to the OK button.  Must do
                //  this so that when the user presses Enter from one of
                //  the combo boxes, the kill focus processing is done
                //  before the data is captured.
                //
                SetFocus(GetDlgItem(hDlg, IDOK));

                if (!GetPointSizeInRange( hDlg,
                                          pCF,
                                          &iSel,
                                          GPS_COMPLAIN | GPS_SETDEFSIZE))
                {
                    PostMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, cmb3), 1L);
                    break;
                }
                pCF->iPointSize = iSel;

#ifdef MM_DESIGNVECTOR_DEFINED
                FillInFontEx(hDlg, pFI, pCF, (LPENUMLOGFONTEXDV)pCF->lpLogFont, TRUE);
#else
                FillInFont(hDlg, pFI, pCF, pCF->lpLogFont, TRUE);
#endif // MM_DESIGNVECTOR_DEFINED

                if (pCF->Flags & CF_FORCEFONTEXIST)
                {
                    if (pCF->Flags & CF_NOFACESEL)
                    {
                        wCmbId = cmb1;
                    }
                    else if (pCF->Flags & CF_NOSTYLESEL)
                    {
                        wCmbId = cmb2;
                    }
                    else
                    {
                        wCmbId = 0;
                    }

                    if (wCmbId)
                    {
                        //
                        //  Error found.
                        //
                        LoadString( g_hinst,
                                    (wCmbId == cmb1)
                                        ? iszNoFaceSel
                                        : iszNoStyleSel,
                                    szMsg,
                                    sizeof(szMsg) / sizeof(TCHAR) );
                        GetWindowText( hDlg,
                                       szTitle,
                                       sizeof(szTitle) / sizeof(TCHAR) );
                        MessageBox( hDlg,
                                    szMsg,
                                    szTitle,
                                    MB_OK | MB_ICONINFORMATION );
                        PostMessage( hDlg,
                                     WM_NEXTDLGCTL,
                                     (WPARAM)GetDlgItem(hDlg, wCmbId),
                                     1L );
                        break;
                    }
                }

                if (pCF->Flags & CF_EFFECTS)
                {
                    //
                    //  Get currently selected item in color combo box and
                    //  the 32 bit color rgb value associated with it.
                    //
                    iSel = (int)SendDlgItemMessage( hDlg,
                                                    cmb4,
                                                    CB_GETCURSEL,
                                                    0,
                                                    0L );
                    pCF->rgbColors = (DWORD) SendDlgItemMessage( hDlg,
                                                                 cmb4,
                                                                 CB_GETITEMDATA,
                                                                 iSel,
                                                                 0L );
                }

                //
                //  Get a valid nFontType.
                //
                iSel = CBGetTextAndData( GetDlgItem(hDlg, cmb2),
                                         szStyle,
                                         sizeof(szStyle) / sizeof(TCHAR),
                                         (PULONG_PTR)&lpItemData );
                if (iSel < 0)
                {
                    lpItemData = 0;
                    iSel = CBGetTextAndData( GetDlgItem(hDlg, cmb2),
                                             (LPTSTR)NULL,
                                             0,
                                             (PULONG_PTR)&lpItemData);
                }

                if (iSel >= 0 && lpItemData)
                {
                    pCF->nFontType = (WORD)lpItemData->nFontType;
                }
                else
                {
                    pCF->nFontType = 0;
                }

                if (pCF->Flags & CF_USESTYLE)
                {
                    lstrcpy(pCF->lpszStyle, szStyle);
                }

                goto LeaveDialog;
            }
            case ( IDCANCEL ) :
            {
                bUserPressedCancel = TRUE;

LeaveDialog:
                FreeAllItemData(hDlg, pFI);
                if (pCF->Flags & CF_ENABLEHOOK)
                {
                    glpfnFontHook = GETHOOKFN(pCF);
                }
                EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam) == IDOK);
                break;
            }
            case ( cmb1 ) :                 // facenames combobox
            {
                switch (GET_WM_COMMAND_CMD(wParam, lParam))
                {
                    case ( CBN_SELCHANGE ) :
                    {
                        CBSetTextFromSel(GET_WM_COMMAND_HWND(wParam, lParam));
FillStyles:
                        //
                        //  Try to maintain the current point size and style.
                        //
                        GetDlgItemText( hDlg,
                                        cmb3,
                                        szPoints,
                                        sizeof(szPoints) / sizeof(TCHAR) );
                        GetFontStylesAndSizes(hDlg, pFI, pCF, FALSE);
                        SetStyleSelection(hDlg, pCF, FALSE);

                        //
                        //  Preserve the point size selection or put it in
                        //  the edit control if it is not in the list for
                        //  this font.
                        //
                        iSel = CBFindString(GetDlgItem(hDlg, cmb3), szPoints);
                        if (iSel < 0)
                        {
                            SetDlgItemText(hDlg, cmb3, szPoints);
                        }
                        else
                        {
                            SendDlgItemMessage( hDlg,
                                                cmb3,
                                                CB_SETCURSEL,
                                                iSel,
                                                0L );
                        }

                        goto DrawSample;
                        break;
                    }
                    case ( CBN_EDITUPDATE ) :
                    {
                        PostMessage( hDlg,
                                     WM_COMMAND,
                                     GET_WM_COMMAND_MPS(
                                         GET_WM_COMMAND_ID(wParam, lParam),
                                         GET_WM_COMMAND_HWND(wParam, lParam),
                                         CBN_MYEDITUPDATE ) );
                        break;
                    }
                    case ( CBN_MYEDITUPDATE ) :
                    {
                        GetWindowText( GET_WM_COMMAND_HWND(wParam, lParam),
                                       szStyle,
                                       sizeof(szStyle) / sizeof(TCHAR) );
                        iSel = CBFindString( GET_WM_COMMAND_HWND(wParam, lParam),
                                             szStyle );
                        if (iSel >= 0)
                        {
                            SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                                         CB_SETCURSEL,
                                         (WPARAM)iSel,
                                         0L );
                            SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                                         CB_SETEDITSEL,
                                         0,
                                         0x0000FFFF );
                            goto FillStyles;
                        }
                        break;
                    }
                }
                break;
            }
            case ( cmb2 ) :                 // styles combobox
            case ( cmb3 ) :                 // point sizes combobox
            {
                switch (GET_WM_COMMAND_CMD(wParam, lParam))
                {
                    case ( CBN_EDITUPDATE ) :
                    {
                        PostMessage( hDlg,
                                     WM_COMMAND,
                                     GET_WM_COMMAND_MPS(
                                         GET_WM_COMMAND_ID(wParam, lParam),
                                         GET_WM_COMMAND_HWND(wParam, lParam),
                                         CBN_MYEDITUPDATE ) );
                        break;
                    }
                    case ( CBN_MYEDITUPDATE ) :
                    {
                        GetWindowText( GET_WM_COMMAND_HWND(wParam, lParam),
                                       szStyle,
                                       sizeof(szStyle) / sizeof(TCHAR) );
                        iSel = CBFindString( GET_WM_COMMAND_HWND(wParam, lParam),
                                             szStyle );
                        if (iSel >= 0)
                        {
                            SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                                         CB_SETCURSEL,
                                         iSel,
                                         0L );
                            SendMessage( GET_WM_COMMAND_HWND(wParam, lParam),
                                         CB_SETEDITSEL,
                                         0,
                                         0x0000FFFF );
                            goto DrawSample;
                        }
                        break;
                    }
                    case ( CBN_SELCHANGE ) :
                    {
                        iSel = CBSetTextFromSel(GET_WM_COMMAND_HWND(wParam, lParam));

                        //
                        //  Make the style selection stick.
                        //
                        if ((iSel >= 0) &&
                            (GET_WM_COMMAND_ID(wParam, lParam) == cmb2))
                        {
                            LPITEMDATA lpItemData;
                            PLOGFONT plf;

                            lpItemData = (LPITEMDATA)SendMessage(
                                            GET_WM_COMMAND_HWND(wParam, lParam),
                                            CB_GETITEMDATA,
                                            iSel,
                                            0L );

                            if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
                            {
                                plf = lpItemData->pLogFont;
                                pCF->lpLogFont->lfWeight = plf->lfWeight;
                                pCF->lpLogFont->lfItalic = plf->lfItalic;
                            }
                            else
                            {
                                pCF->lpLogFont->lfWeight = FW_NORMAL;
                                pCF->lpLogFont->lfItalic = 0;
                            }
                        }

                        goto DrawSample;
                    }
                    case ( CBN_KILLFOCUS ) :
                    {
DrawSample:
#ifdef UNICODE
                        if (pFI->ApiType == COMDLG_ANSI)
                        {
                            //
                            //  Send special WOW message to indicate the
                            //  font style has changed.
                            //
                            LOGFONT lf;

                            if (FillInFont(hDlg, pFI, pCF, &lf, TRUE))
                            {
                                memcpy(pCF->lpLogFont, &lf, sizeof(LOGFONT));
                                ThunkLogFontW2A( pCF->lpLogFont,
                                                 pFI->pCFA->lpLogFont );
                                SendMessage( hDlg,
                                             msgWOWLFCHANGE,
                                             0,
                                             (LPARAM)(LPLOGFONT)pFI->pCFA->lpLogFont );
                            }
                        }
#endif

                        //
                        //  Force redraw of preview text for any size change.
                        //
                        InvalidateRect(hDlg, &pFI->rcText, FALSE);
                        UpdateWindow(hDlg);
                    }
                }
                break;
            }
            case ( cmb5 ) :                 // script combobox
            {
                //
                //  Need to change the sample text to reflect the new script.
                //
                if (GET_WM_COMMAND_CMD(wParam, lParam) != CBN_SELCHANGE)
                {
                    break;
                }
                if (pFI->ProcessVersion < 0x40000)
                {
                    //
                    //  Enabled template also has a cmb5!
                    //
                    return (FALSE);
                }
                if (ResetSampleFromScript( hDlg,
                                           GET_WM_COMMAND_HWND(wParam, lParam),
                                           pFI ))
                {
                    goto FillStyles;
                }
                else
                {
                    break;
                }
            }
            case ( cmb4 ) :
            {
                if (GET_WM_COMMAND_CMD(wParam, lParam) != CBN_SELCHANGE)
                {
                    break;
                }

                // fall thru...
            }
            case ( chx1 ) :                 // bold
            case ( chx2 ) :                 // italic
            {
                goto DrawSample;
            }
            case ( pshHelp ) :              // help
            {
#ifdef UNICODE
                if (pFI->ApiType == COMDLG_ANSI)
                {
                    if (msgHELPA && pCF->hwndOwner)
                    {
                        SendMessage( pCF->hwndOwner,
                                     msgHELPA,
                                     (WPARAM)hDlg,
                                     (LPARAM)pCF );
                    }
                }
                else
#endif
                {
                    if (msgHELPW && pCF->hwndOwner)
                    {
                        SendMessage( pCF->hwndOwner,
                                     msgHELPW,
                                     (WPARAM)hDlg,
                                     (LPARAM)pCF );
                    }
                }
                break;
            }
            default :
            {
                return (FALSE);
            }
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CmpFontType
//
//  Compares two font types.  The values of the font type bits are
//  monotonic except the low bit (RASTER_FONTTYPE).  After flipping
//  that bit the words can be compared directly.
//
//  Returns the best of the two.
//
////////////////////////////////////////////////////////////////////////////

int CmpFontType(
    DWORD ft1,
    DWORD ft2)
{
    ft1 &= ~(SCREEN_FONTTYPE | PRINTER_FONTTYPE);
    ft2 &= ~(SCREEN_FONTTYPE | PRINTER_FONTTYPE);

    //
    //  Flip the RASTER_FONTTYPE bit so we can compare.
    //
    ft1 ^= RASTER_FONTTYPE;
    ft2 ^= RASTER_FONTTYPE;

    return ( (int)ft1 - (int)ft2 );
}


////////////////////////////////////////////////////////////////////////////
//
//  FontFamilyEnumProc
//
//  nFontType bits
//
//  SCALABLE DEVICE RASTER
//     (TT)  (not GDI) (not scalable)
//      0       0       0       vector, ATM screen
//      0       0       1       GDI raster font
//      0       1       0       PS/LJ III, ATM printer, ATI/LaserMaster
//      0       1       1       non scalable device font
//      1       0       x       TT screen font
//      1       1       x       TT dev font
//
////////////////////////////////////////////////////////////////////////////

int FontFamilyEnumProc(
    LPENUMLOGFONTEX lplf,
    LPNEWTEXTMETRIC lptm,
    DWORD nFontType,
    LPENUM_FONT_DATA lpData)
{
    int iItem;
    DWORD nOldType, nNewType;
    LPITEMDATA lpItemData;
    LPITEMDATA lpOldItemData = NULL;

    //
    //  Bounce non TT fonts.
    //
    if ((lpData->dwFlags & CF_TTONLY) &&
        !(nFontType & TRUETYPE_FONTTYPE))
    {
        return (TRUE);
    }

    //
    //  Bounce non scalable fonts.
    //
    if ((lpData->dwFlags & CF_SCALABLEONLY) &&
        (nFontType & RASTER_FONTTYPE))
    {
        return (TRUE);
    }

    //
    //  Bounce non ANSI fonts.
    //
    if ((lpData->dwFlags & CF_SCRIPTSONLY) &&
        ((lplf->elfLogFont.lfCharSet == OEM_CHARSET) ||
         (lplf->elfLogFont.lfCharSet == SYMBOL_CHARSET)))
    {
        return (TRUE);
    }

    //
    //  Bounce vertical fonts.
    //
    if ((lpData->dwFlags & CF_NOVERTFONTS) &&
        (lplf->elfLogFont.lfFaceName[0] == TEXT('@')) &&
        IS_ANY_DBCS_CHARSET(lplf->elfLogFont.lfCharSet))
    {
        return (TRUE);
    }

    //
    //  Bounce proportional fonts.
    //
    if ((lpData->dwFlags & CF_FIXEDPITCHONLY) &&
        (lplf->elfLogFont.lfPitchAndFamily & VARIABLE_PITCH))
    {
        return (TRUE);
    }

    //
    //  Bounce vector fonts.
    //
    if ((lpData->dwFlags & CF_NOVECTORFONTS) &&
        (lplf->elfLogFont.lfCharSet == OEM_CHARSET))
    {
        return (TRUE);
    }

    if (lpData->bPrinterFont)
    {
        nFontType |= PRINTER_FONTTYPE;
    }
    else
    {
        nFontType |= SCREEN_FONTTYPE;
    }

    //
    //  Test for a name collision.
    //
    iItem = CBFindString(lpData->hwndFamily, lplf->elfLogFont.lfFaceName);
    if (iItem >= 0)
    {
        lpItemData = (LPITEMDATA)SendMessage( lpData->hwndFamily,
                                              CB_GETITEMDATA,
                                              iItem,
                                              0L );
        if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
        {
            nOldType = lpItemData->nFontType;
            lpOldItemData = lpItemData;
        }
        else
        {
            nOldType = 0;
        }

        //
        //  If we don't want screen fonts, but do want printer fonts,
        //  the old font is a screen font and the new font is a
        //  printer font, take the new font regardless of other flags.
        //  Note that this means if a printer wants TRUETYPE fonts, it
        //  should enumerate them.
        //
        if (!(lpData->dwFlags & CF_SCREENFONTS)  &&
             (lpData->dwFlags & CF_PRINTERFONTS) &&
             (nFontType & PRINTER_FONTTYPE)      &&
             (nOldType & SCREEN_FONTTYPE))
        {
            nOldType = 0;                   // for setting nNewType below
            goto SetNewType;
        }

        if (CmpFontType(nFontType, nOldType) > 0)
        {
SetNewType:
            nNewType = nFontType;
            SendMessage( lpData->hwndFamily,
                         CB_INSERTSTRING,
                         iItem,
                         (LONG_PTR)(LPTSTR)lplf->elfLogFont.lfFaceName );
            SendMessage( lpData->hwndFamily,
                         CB_DELETESTRING,
                         iItem + 1,
                         0L );
        }
        else
        {
            nNewType = nOldType;
        }

        //
        //  Accumulate the printer/screen ness of these fonts.
        //
        nNewType |= (nFontType | nOldType) &
                    (SCREEN_FONTTYPE | PRINTER_FONTTYPE);

        lpItemData = (LPITEMDATA)LocalAlloc(LMEM_FIXED, sizeof(ITEMDATA));
        if (!lpItemData)
        {
            return (FALSE);
        }
        lpItemData->pLogFont = 0L;

        lpItemData->nFontType = nNewType;
        SendMessage( lpData->hwndFamily,
                     CB_SETITEMDATA,
                     iItem,
                     (LONG_PTR)lpItemData );

        if (lpOldItemData)
        {
            LocalFree(lpOldItemData);
        }

        return (TRUE);
    }

    iItem = (int)SendMessage( lpData->hwndFamily,
                              CB_ADDSTRING,
                              0,
                              (LONG_PTR)(LPTSTR)lplf->elfLogFont.lfFaceName );
    if (iItem < 0)
    {
        return (FALSE);
    }

    lpItemData = (LPITEMDATA)LocalAlloc(LMEM_FIXED, sizeof(ITEMDATA));
    if (!lpItemData)
    {
        return (FALSE);
    }
    lpItemData->pLogFont = 0L;

#ifdef WINNT
    if (lptm->ntmFlags & NTM_PS_OPENTYPE)
        nFontType |= PS_OPENTYPE_FONTTYPE;
    if (lptm->ntmFlags & NTM_TYPE1)
        nFontType |= TYPE1_FONTTYPE;
    if (lptm->ntmFlags & NTM_TT_OPENTYPE)
        nFontType |= TT_OPENTYPE_FONTTYPE;
#endif // WINNT

    lpItemData->nFontType = nFontType;

    SendMessage(lpData->hwndFamily, CB_SETITEMDATA, iItem, (LONG_PTR)lpItemData);

    lptm;
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetFontFamily
//
//  Fills the screen and/or printer font facenames into the font facenames
//  combobox depending on the CF_?? flags passed in.
//
//  cmb1 is the ID for the font facename combobox
//
//  Both screen and printer fonts are listed into the same combobox
//
//  Returns:   TRUE    if successful
//             FALSE   otherwise.
//
////////////////////////////////////////////////////////////////////////////

BOOL GetFontFamily(
    HWND hDlg,
    HDC hDC,
    DWORD dwEnumCode,
    UINT iCharset)
{
    ENUM_FONT_DATA data;
    int iItem, iCount;
    DWORD nFontType;
    TCHAR szMsg[120], szTitle[40];
    LPITEMDATA lpItemData;
    LOGFONT lf;

    data.hwndFamily = GetDlgItem(hDlg, cmb1);
    data.dwFlags = dwEnumCode;

    //
    //  This is a bit strange.  We have to get all the screen fonts
    //  so if they ask for the printer fonts we can tell which
    //  are really printer fonts.  This is so we don't list the
    //  vector and raster fonts as printer device fonts.
    //
    data.hDC = GetDC(NULL);
    data.bPrinterFont = FALSE;
    lf.lfFaceName[0] = CHAR_NULL;
    lf.lfCharSet = (dwEnumCode & CF_SELECTSCRIPT) ? iCharset : DEFAULT_CHARSET;
    EnumFontFamiliesEx( data.hDC,
                        &lf,
                        (FONTENUMPROC)FontFamilyEnumProc,
                        (LPARAM)&data,
                        0L );
    ReleaseDC(NULL, data.hDC);

    //
    //  List out printer font facenames.
    //
    if (dwEnumCode & CF_PRINTERFONTS)
    {
        data.hDC = hDC;
        data.bPrinterFont = TRUE;
        EnumFontFamiliesEx( hDC,
                            &lf,
                            (FONTENUMPROC)FontFamilyEnumProc,
                            (LPARAM)&data,
                            0L );
    }

    //
    //  Now we have to remove those screen fonts if they didn't
    //  ask for them.
    //
    if (!(dwEnumCode & CF_SCREENFONTS))
    {
        iCount = (int)SendMessage(data.hwndFamily, CB_GETCOUNT, 0, 0L);

        for (iItem = iCount - 1; iItem >= 0; iItem--)
        {
            lpItemData = (LPITEMDATA)SendMessage( data.hwndFamily,
                                                  CB_GETITEMDATA,
                                                  iItem,
                                                  0L );
            if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
            {
                nFontType = lpItemData->nFontType;
            }
            else
            {
                nFontType = 0;
            }

            if ((nFontType & (SCREEN_FONTTYPE |
                              PRINTER_FONTTYPE)) == SCREEN_FONTTYPE)
            {
                SendMessage(data.hwndFamily, CB_DELETESTRING, iItem, 0L);
            }
        }
    }

    //
    //  For WYSIWYG mode we delete all the fonts that don't exist
    //  on the screen and the printer.
    //
    if (dwEnumCode & CF_WYSIWYG)
    {
        iCount = (int)SendMessage(data.hwndFamily, CB_GETCOUNT, 0, 0L);

        for (iItem = iCount - 1; iItem >= 0; iItem--)
        {
            nFontType = ((LPITEMDATA)SendMessage( data.hwndFamily,
                                                  CB_GETITEMDATA,
                                                  iItem,
                                                  0L ))->nFontType;

            if ((nFontType & (SCREEN_FONTTYPE | PRINTER_FONTTYPE)) !=
                (SCREEN_FONTTYPE | PRINTER_FONTTYPE))
            {
                SendMessage(data.hwndFamily, CB_DELETESTRING, iItem, 0L);
            }
        }
    }

    if ((int)SendMessage(data.hwndFamily, CB_GETCOUNT, 0, 0L) <= 0)
    {
        LoadString( g_hinst,
                    iszNoFontsTitle,
                    szTitle,
                    sizeof(szTitle) / sizeof(TCHAR) );
        LoadString( g_hinst,
                    iszNoFontsMsg,
                    szMsg,
                    sizeof(szMsg) / sizeof(TCHAR) );
        MessageBox(hDlg, szMsg, szTitle, MB_OK | MB_ICONINFORMATION);

        return (FALSE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CBAddSize
//
////////////////////////////////////////////////////////////////////////////

VOID CBAddSize(
    HWND hwnd,
    int pts,
    LPCHOOSEFONT lpcf)
{
    int iInd;
    TCHAR szSize[10];
    int count, test_size;
    LPITEMDATA lpItemData;

    //
    //  See if the size is limited.
    //
    if ((lpcf->Flags & CF_LIMITSIZE) &&
        ((pts > lpcf->nSizeMax) || (pts < lpcf->nSizeMin)))
    {
        return;
    }

    //
    //  Convert the point size to a string.
    //
    wsprintf(szSize, szPtFormat, pts);

    //
    //  Figure out where in the list the item should be added.
    //  All values should be in increasing order in the list box.
    //
    count = (int)SendMessage(hwnd, CB_GETCOUNT, 0, 0L);
    test_size = -1;
    for (iInd = 0; iInd < count; iInd++)
    {
        lpItemData = (LPITEMDATA)SendMessage(hwnd, CB_GETITEMDATA, iInd, 0L);
        if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
        {
            test_size = (int)lpItemData->nFontType;
        }
        else
        {
            test_size = 0;
        }

        if (pts <= test_size)
        {
            break;
        }
    }

    //
    //  Don't add duplicates.
    //
    if (pts == test_size)
    {
        return;
    }

    //
    //  Add the string and the associated item data to the list box.
    //
    iInd = (int) SendMessage(hwnd, CB_INSERTSTRING, iInd, (LPARAM)szSize);
    if (iInd >= 0)
    {
        lpItemData = (LPITEMDATA)LocalAlloc(LMEM_FIXED, sizeof(ITEMDATA));
        if (!lpItemData)
        {
            return;
        }

        lpItemData->pLogFont = 0L;
        lpItemData->nFontType = (DWORD)pts;
        SendMessage(hwnd, CB_SETITEMDATA, iInd, (LONG_PTR)lpItemData);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CBAddChineseSize
//
////////////////////////////////////////////////////////////////////////////

VOID CBAddChineseSize(
    HWND hwnd,
    LPCHOOSEFONT lpcf)
{
    int ctr, iInd = 0;
    TCHAR szSize[10];
    LPITEMDATA lpItemData;

    //
    //  Look at each item in the Zihao structure to see if it should be
    //  added.
    //
    for (ctr = 0; ctr < NUM_ZIHAO; ctr++)
    {
        //
        //  See if the size is limited.
        //
        if ((lpcf->Flags & CF_LIMITSIZE) &&
            ((stZihao[ctr].size > lpcf->nSizeMax) ||
             (stZihao[ctr].size < lpcf->nSizeMin)))
        {
            continue;
        }

        //
        //  Convert the point size to a string.
        //
        wsprintf(szSize, TEXT("%s"), stZihao[ctr].name);

        //
        //  Add the string and the associated item data to the list box.
        //
        iInd = (int) SendMessage(hwnd, CB_INSERTSTRING, iInd, (LPARAM)szSize);
        if (iInd >= 0)
        {
            lpItemData = (LPITEMDATA)LocalAlloc(LMEM_FIXED, sizeof(ITEMDATA));
            if (!lpItemData)
            {
                return;
            }

            lpItemData->pLogFont = 0L;
            lpItemData->nFontType = (DWORD)(stZihao[ctr].size * 10 +
                                            stZihao[ctr].sizeFr);
            SendMessage(hwnd, CB_SETITEMDATA, iInd, (LONG_PTR)lpItemData);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  InsertStyleSorted
//
//  Sort styles by weight first, then by italics.
//
//  Returns the index of the place this was inserted.
//
////////////////////////////////////////////////////////////////////////////

int InsertStyleSorted(
    HWND hwnd,
    LPTSTR lpszStyle,
    LPLOGFONT lplf)
{
    int count, ctr;
    PLOGFONT plf;
    LPITEMDATA lpItemData;

    count = (int) SendMessage(hwnd, CB_GETCOUNT, 0, 0L);

    for (ctr = 0; ctr < count; ctr++)
    {
        lpItemData = (LPITEMDATA)SendMessage(hwnd, CB_GETITEMDATA, ctr, 0L);
        if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
        {
            plf = lpItemData->pLogFont;

            if (lplf->lfWeight < plf->lfWeight)
            {
                break;
            }
            else if (lplf->lfWeight == plf->lfWeight)
            {
                if (lplf->lfItalic && !plf->lfItalic)
                {
                    ctr++;
                }
                break;
            }
        }
    }

    return ((int)SendMessage(hwnd, CB_INSERTSTRING, ctr, (LONG_PTR)lpszStyle));
}


////////////////////////////////////////////////////////////////////////////
//
//  CBAddStyle
//
////////////////////////////////////////////////////////////////////////////

PLOGFONT CBAddStyle(
    HWND hwnd,
    LPTSTR lpszStyle,
    DWORD nFontType,
    LPLOGFONT lplf)
{
    int iItem;
    PLOGFONT plf;
    LPITEMDATA lpItemData;

    //
    //  Don't add duplicates.
    //
    if (CBFindString(hwnd, lpszStyle) >= 0)
    {
        return (NULL);
    }

    iItem = (int)InsertStyleSorted(hwnd, lpszStyle, lplf);
    if (iItem < 0)
    {
        return (NULL);
    }

    plf = (PLOGFONT)LocalAlloc(LMEM_FIXED, sizeof(LOGFONT));
    if (!plf)
    {
        SendMessage(hwnd, CB_DELETESTRING, iItem, 0L);
        return (NULL);
    }

    *plf = *lplf;

    lpItemData = (LPITEMDATA)LocalAlloc(LMEM_FIXED, sizeof(ITEMDATA));
    if (!lpItemData)
    {
        LocalFree(plf);
        SendMessage(hwnd, CB_DELETESTRING, iItem, 0L);
        return (NULL);
    }

    lpItemData->pLogFont = plf;
    lpItemData->nFontType = nFontType;
    SendMessage(hwnd, CB_SETITEMDATA, iItem, (LONG_PTR)lpItemData);

    return (plf);
}


////////////////////////////////////////////////////////////////////////////
//
//  CBAddScript
//
////////////////////////////////////////////////////////////////////////////

int CBAddScript(
    HWND hwnd,
    LPTSTR lpszScript,
    UINT iCharset)
{
    int iItem;
    LPITEMDATA lpItemData;

    //
    //  Don't add duplicates or empty strings.
    //
    if (!IsWindow(hwnd) || !IsWindowEnabled(hwnd) || (!*lpszScript) ||
        (CBFindString(hwnd, lpszScript) >= 0))
    {
        return (-1);
    }

    iItem = (int)SendMessage(hwnd, CB_ADDSTRING, 0, (LONG_PTR)(LPTSTR)lpszScript);
    if (iItem < 0)
    {
        return (-1);
    }

    lpItemData = (LPITEMDATA)LocalAlloc(LMEM_FIXED, sizeof(ITEMDATA));
    if (!lpItemData)
    {
        SendMessage(hwnd, CB_DELETESTRING, iItem, 0L);
        return (-1);
    }

    lpItemData->pLogFont = 0L;
    lpItemData->nFontType = (DWORD)iCharset;
    SendMessage(hwnd, CB_SETITEMDATA, iItem, (LONG_PTR)lpItemData);

    return (iItem);
}


////////////////////////////////////////////////////////////////////////////
//
//  FillInMissingStyles
//
//  Generates simulated forms from those that we have.
//
//  reg -> bold
//  reg -> italic
//  bold || italic || reg -> bold italic
//
////////////////////////////////////////////////////////////////////////////

VOID FillInMissingStyles(
    HWND hwnd)
{
    PLOGFONT plf, plf_reg, plf_bold, plf_italic;
    DWORD nFontType;
    int ctr, count;
    BOOL bBold, bItalic, bBoldItalic;
    LPITEMDATA lpItemData;
    LOGFONT lf;

    bBold = bItalic = bBoldItalic = FALSE;
    plf_reg = plf_bold = plf_italic = NULL;

    count = (int)SendMessage(hwnd, CB_GETCOUNT, 0, 0L);
    for (ctr = 0; ctr < count; ctr++)
    {
        lpItemData = (LPITEMDATA)SendMessage(hwnd, CB_GETITEMDATA, ctr, 0L);
        if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
        {
            plf = lpItemData->pLogFont;
            nFontType = lpItemData->nFontType;
        }
        else
        {
            plf = NULL;
            nFontType = 0;
        }

        if ((nFontType & BOLD_FONTTYPE) && (nFontType & ITALIC_FONTTYPE))
        {
            bBoldItalic = TRUE;
        }
        else if (nFontType & BOLD_FONTTYPE)
        {
            bBold = TRUE;
            plf_bold = plf;
        }
        else if (nFontType & ITALIC_FONTTYPE)
        {
            bItalic = TRUE;
            plf_italic = plf;
        }
        else
        {
            plf_reg = plf;
        }
    }

    nFontType |= SIMULATED_FONTTYPE;

    if (!bBold && plf_reg)
    {
        lf = *plf_reg;
        lf.lfWeight = FW_BOLD;
        CBAddStyle(hwnd, szBold, (nFontType | BOLD_FONTTYPE), &lf);
    }

    if (!bItalic && plf_reg)
    {
        lf = *plf_reg;
        lf.lfItalic = TRUE;
        CBAddStyle(hwnd, szItalic, (nFontType | ITALIC_FONTTYPE), &lf);
    }
    if (!bBoldItalic && (plf_bold || plf_italic || plf_reg))
    {
        if (plf_italic)
        {
            plf = plf_italic;
        }
        else if (plf_bold)
        {
            plf = plf_bold;
        }
        else
        {
            plf = plf_reg;
        }

        lf = *plf;
        lf.lfItalic = (BYTE)TRUE;
        lf.lfWeight = FW_BOLD;
        CBAddStyle(hwnd, szBoldItalic, (nFontType | BOLD_FONTTYPE | ITALIC_FONTTYPE), &lf);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  FillScalableSizes
//
////////////////////////////////////////////////////////////////////////////

VOID FillScalableSizes(
    HWND hwnd,
    LPCHOOSEFONT lpcf)
{
    if (IS_SIMPLIFIED_CHINESE(UserLangID))
    {
        CBAddChineseSize(hwnd, lpcf);
    }

    CBAddSize(hwnd, 8,  lpcf);
    CBAddSize(hwnd, 9,  lpcf);
    CBAddSize(hwnd, 10, lpcf);
    CBAddSize(hwnd, 11, lpcf);
    CBAddSize(hwnd, 12, lpcf);
    CBAddSize(hwnd, 14, lpcf);
    CBAddSize(hwnd, 16, lpcf);
    CBAddSize(hwnd, 18, lpcf);
    CBAddSize(hwnd, 20, lpcf);
    CBAddSize(hwnd, 22, lpcf);
    CBAddSize(hwnd, 24, lpcf);
    CBAddSize(hwnd, 26, lpcf);
    CBAddSize(hwnd, 28, lpcf);
    CBAddSize(hwnd, 36, lpcf);
    CBAddSize(hwnd, 48, lpcf);
    CBAddSize(hwnd, 72, lpcf);
}


////////////////////////////////////////////////////////////////////////////
//
//  FontStyleEnumProc
//
////////////////////////////////////////////////////////////////////////////

#define GDI_FONTTYPE_STUFF (RASTER_FONTTYPE | DEVICE_FONTTYPE | TRUETYPE_FONTTYPE)

int FontStyleEnumProc(
    LPENUMLOGFONTEX lplf,
    LPNEWTEXTMETRIC lptm,
    DWORD nFontType,
    LPENUM_FONT_DATA lpData)
{
    int height, pts;
    TCHAR buf[10];

    //
    //  Filter for a font type match (the font type of the selected face
    //  must be the same as that enumerated).
    //
    if (nFontType != (DWORD)(GDI_FONTTYPE_STUFF & lpData->nFontType))
    {
        return (TRUE);
    }

    if (!(nFontType & RASTER_FONTTYPE))
    {
        //
        //  Vector or TT font.
        //
        if (lpData->bFillSize &&
            (int)SendMessage(lpData->hwndSizes, CB_GETCOUNT, 0, 0L) == 0)
        {
            FillScalableSizes(lpData->hwndSizes, lpData->lpcf);
        }
    }
    else
    {
        height = lptm->tmHeight - lptm->tmInternalLeading;
        pts = GetPointString(buf, lpData->hDC, height);

        //
        //  Filter devices same size of multiple styles.
        //
        if (CBFindString(lpData->hwndSizes, buf) < 0)
        {
            CBAddSize(lpData->hwndSizes, pts, lpData->lpcf);
        }
    }

    //
    //  Keep the printer/screen bits from the family list here too.
    //
    nFontType |= (lpData->nFontType & (SCREEN_FONTTYPE | PRINTER_FONTTYPE));

#ifdef WINNT
    if (lptm->ntmFlags & NTM_PS_OPENTYPE)
        nFontType |= PS_OPENTYPE_FONTTYPE;
    if (lptm->ntmFlags & NTM_TYPE1)
        nFontType |= TYPE1_FONTTYPE;
    if (lptm->ntmFlags & NTM_TT_OPENTYPE)
        nFontType |= TT_OPENTYPE_FONTTYPE;
#endif // WINNT

    if (nFontType & TRUETYPE_FONTTYPE)
    {
        //
        //  If (lptm->ntmFlags & NTM_REGULAR)
        //
        if (!(lptm->ntmFlags & (NTM_BOLD | NTM_ITALIC)))
        {
            nFontType |= REGULAR_FONTTYPE;
        }

        if (lptm->ntmFlags & NTM_ITALIC)
        {
            nFontType |= ITALIC_FONTTYPE;
        }

        if (lptm->ntmFlags & NTM_BOLD)
        {
            nFontType |= BOLD_FONTTYPE;
        }

        //
        //  After the LOGFONT.lfFaceName there are 2 more names
        //     lfFullName[LF_FACESIZE * 2]
        //     lfStyle[LF_FACESIZE]
        //
        //  If the font has one of the standard style strings in English,
        //  use the localized string instead.
        //
        if (!lstrcmp(c_szRegular, lplf->elfStyle))
        {
            CBAddStyle( lpData->hwndStyle,
                        szRegular,
                        nFontType,
                        &lplf->elfLogFont );
        }
        else if (!lstrcmp(c_szBold, lplf->elfStyle))
        {
            CBAddStyle( lpData->hwndStyle,
                        szBold,
                        nFontType,
                        &lplf->elfLogFont );
        }
        else if (!lstrcmp(c_szItalic, lplf->elfStyle))
        {
            CBAddStyle( lpData->hwndStyle,
                        szItalic,
                        nFontType,
                        &lplf->elfLogFont );
        }
        else if (!lstrcmp(c_szBoldItalic, lplf->elfStyle))
        {
            CBAddStyle( lpData->hwndStyle,
                        szBoldItalic,
                        nFontType,
                        &lplf->elfLogFont);
        }
        else
        {
            CBAddStyle( lpData->hwndStyle,
                        lplf->elfStyle,
                        nFontType,
                        &lplf->elfLogFont );
        }
    }
    else
    {
        if ((lplf->elfLogFont.lfWeight >= FW_BOLD) && lplf->elfLogFont.lfItalic)
        {
            CBAddStyle( lpData->hwndStyle,
                        szBoldItalic,
                        (nFontType | BOLD_FONTTYPE | ITALIC_FONTTYPE),
                        &lplf->elfLogFont );
        }
        else if (lplf->elfLogFont.lfWeight >= FW_BOLD)
        {
            CBAddStyle( lpData->hwndStyle,
                        szBold,
                        (nFontType | BOLD_FONTTYPE),
                        &lplf->elfLogFont );
        }
        else if (lplf->elfLogFont.lfItalic)
        {
            CBAddStyle( lpData->hwndStyle,
                        szItalic,
                        (nFontType | ITALIC_FONTTYPE),
                        &lplf->elfLogFont );
        }
        else
        {
            CBAddStyle( lpData->hwndStyle,
                        szRegular,
                        (nFontType | REGULAR_FONTTYPE),
                        &lplf->elfLogFont );
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeFonts
//
////////////////////////////////////////////////////////////////////////////

VOID FreeFonts(
    HWND hwnd)
{
    int ctr, count;
    LPITEMDATA lpItemData;

    count = (int)SendMessage(hwnd, CB_GETCOUNT, 0, 0L);

    for (ctr = 0; ctr < count; ctr++)
    {
        lpItemData = (LPITEMDATA)SendMessage(hwnd, CB_GETITEMDATA, ctr, 0L);
        if (!IS_INTRESOURCE(lpItemData) && (lpItemData != (LPITEMDATA)CB_ERR))
        {
            if (!IS_INTRESOURCE(lpItemData->pLogFont))
            {
                LocalFree((HANDLE)lpItemData->pLogFont);
            }
            LocalFree((HANDLE)lpItemData);
        }
        SendMessage(hwnd, CB_SETITEMDATA, ctr, 0L);
    }

    SendMessage(hwnd, CB_RESETCONTENT, 0, 0L);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeAllItemData
//
////////////////////////////////////////////////////////////////////////////

VOID FreeAllItemData(
    HWND hDlg,
    PFONTINFO pFI)
{
    HWND hwndTemp;

    if (hwndTemp = GetDlgItem(hDlg, cmb1))
    {
        FreeFonts(hwndTemp);
    }
    if (hwndTemp = GetDlgItem(hDlg, cmb2))
    {
        FreeFonts(hwndTemp);
    }
    if (hwndTemp = GetDlgItem(hDlg, cmb3))
    {
        FreeFonts(hwndTemp);
    }
    if (((pFI->ProcessVersion >= 0x40000) ||
         (pFI->pCF->Flags & CF_NOSCRIPTSEL)) &&
        (hwndTemp = GetDlgItem(hDlg, cmb5)))
    {
        FreeFonts(hwndTemp);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  InitLF
//
//  Initalize a LOGFONT structure to some base generic regular type font.
//
////////////////////////////////////////////////////////////////////////////

VOID InitLF(
    LPLOGFONT lplf)
{
    HDC hdc;

    hdc = GetDC(NULL);
    lplf->lfEscapement = 0;
    lplf->lfOrientation = 0;
    lplf->lfCharSet = (BYTE) GetTextCharset(hdc);
    lplf->lfOutPrecision = OUT_DEFAULT_PRECIS;
    lplf->lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lplf->lfQuality = DEFAULT_QUALITY;
    lplf->lfPitchAndFamily = DEFAULT_PITCH;
    lplf->lfItalic = 0;
    lplf->lfWeight = FW_NORMAL;
    lplf->lfStrikeOut = 0;
    lplf->lfUnderline = 0;
    lplf->lfWidth = 0;            // otherwise we get independant x-y scaling
    lplf->lfFaceName[0] = 0;
    lplf->lfHeight = -MulDiv( DEF_POINT_SIZE,
                              GetDeviceCaps(hdc, LOGPIXELSY),
                              POINTS_PER_INCH );
    ReleaseDC(NULL, hdc);
}

#ifdef MM_DESIGNVECTOR_DEFINED
////////////////////////////////////////////////////////////////////////////
//
//  FontMMAxesEnumProc
//
//  Gets all of the lower and upper bounds and default values of MM axes 
//  for the face we are enumerating. Sets the scrollbar parameters as well as
//  static controls and edit boxes accordingly.
//
////////////////////////////////////////////////////////////////////////////

int FontMMAxesEnumProc(
    LPENUMLOGFONTEXDV lplf,
    LPENUMTEXTMETRIC lpetm,
    DWORD nFontType,
    LPENUM_FONT_DATA lpData)
{
    UINT i;
    SCROLLINFO scri;
    RECT rcCtl;

	lpData->pDefaultDesignVector->dvNumAxes = (lpetm)->etmAxesList.axlNumAxes;
	lpData->pDefaultDesignVector->dvReserved = STAMP_DESIGNVECTOR;

    if (MAX_NUM_AXES < lpData->pDefaultDesignVector->dvNumAxes)
    {
//        MessageBox(lpData->hwndParent, TEXT("Cannot support so many axes"), TEXT("Error"), MB_OK | MB_ICONEXCLAMATION);
        lpData->pDefaultDesignVector->dvNumAxes = 0;  // this will get rid of all scroll bars
    }


    scri.cbSize = sizeof(SCROLLINFO);
    scri.fMask  = SIF_RANGE | SIF_POS | SIF_PAGE;
    scri.nTrackPos = 0;

    rcCtl.left   = 0;
    rcCtl.top    = 0;
    rcCtl.right  = 287;
    rcCtl.bottom = (lpData->pDefaultDesignVector->dvNumAxes == 0)? 216 : 225+20+20*lpData->pDefaultDesignVector->dvNumAxes;
    MapDialogRect( lpData->hwndParent, &rcCtl);
    SetWindowPos ( lpData->hwndParent, NULL, 
                   0, 0, 
                   rcCtl.right, rcCtl.bottom,
                   SWP_NOMOVE | SWP_NOZORDER );

    rcCtl.left   = 0;
    rcCtl.top    = 0;
    rcCtl.right  = 205;
    rcCtl.bottom = 15+20*(lpetm)->etmAxesList.axlNumAxes;
    MapDialogRect( lpData->hwndParent, &rcCtl);
    SetWindowPos ( GetDlgItem(lpData->hwndParent, grp3), NULL, 
                   0, 0, 
                   rcCtl.right, rcCtl.bottom,
                   SWP_NOMOVE | SWP_NOZORDER );

    for (i=0; i<lpData->pDefaultDesignVector->dvNumAxes; i++)
    {
            ShowWindow      ( GetDlgItem(lpData->hwndParent, stc11 + i), SW_SHOW); // axName
            ShowWindow      ( GetDlgItem(lpData->hwndParent, stc18 + i), SW_SHOW); // axMin
            ShowWindow      ( GetDlgItem(lpData->hwndParent, stc25 + i), SW_SHOW); // axMax
            ShowWindow      ( GetDlgItem(lpData->hwndParent,  edt1 + i), SW_SHOW); // dvVal
            ShowWindow      ( GetDlgItem(lpData->hwndParent,  scr1 + i), SW_SHOW); // scrollbar
            //EnableScrollBar ( GetDlgItem(lpData->hwndParent,  scr1 + i), SB_CTL, ESB_ENABLE_BOTH);

            lpData->pDefaultDesignVector->dvValues[i] = (lplf)->elfDesignVector.dvValues[i];

            scri.nMin   = (lpetm)->etmAxesList.axlAxisInfo[i].axMinValue;
            scri.nPage  = 10;
            scri.nMax   = (lpetm)->etmAxesList.axlAxisInfo[i].axMaxValue + scri.nPage - 1;
            scri.nPos   = (lplf)->elfDesignVector.dvValues[i];
            SetScrollInfo(GetDlgItem(lpData->hwndParent, scr1 + i), SB_CTL, &scri, TRUE);

            SetDlgItemText( lpData->hwndParent, 
                            stc11 + i, 
                            (lpetm)->etmAxesList.axlAxisInfo[i].axAxisName);
            SetDlgItemInt ( lpData->hwndParent, 
                            stc18 + i, 
                            (lpetm)->etmAxesList.axlAxisInfo[i].axMinValue, 
                            TRUE);
            SetDlgItemInt ( lpData->hwndParent, 
                            stc25 + i, 
                            (lpetm)->etmAxesList.axlAxisInfo[i].axMaxValue, 
                            TRUE);
            SetDlgItemInt ( lpData->hwndParent, 
                            edt1 + i, 
                            (lplf)->elfDesignVector.dvValues[i], 
                            TRUE);
    }

    for (i=lpData->pDefaultDesignVector->dvNumAxes; i<MAX_NUM_AXES; i++)
    {
            ShowWindow      ( GetDlgItem(lpData->hwndParent, stc11 + i), SW_HIDE); // axName
            ShowWindow      ( GetDlgItem(lpData->hwndParent, stc18 + i), SW_HIDE); // axMin
            ShowWindow      ( GetDlgItem(lpData->hwndParent, stc25 + i), SW_HIDE); // axMax
            ShowWindow      ( GetDlgItem(lpData->hwndParent,  edt1 + i), SW_HIDE); // dvVal
            ShowWindow      ( GetDlgItem(lpData->hwndParent,  scr1 + i), SW_HIDE); // scrollbar
            // EnableScrollBar ( GetDlgItem(lpData->hwndParent, scr1 + i), SB_CTL, ESB_DISABLE_BOTH);
    }       

    return TRUE;
}
#endif // MM_DESIGNVECTOR_DEFINED

////////////////////////////////////////////////////////////////////////////
//
//  FontScriptEnumProc
//
//  Gets all of the charsets for the face we are enumerating.
//
//  Fills in the script window if any, and sets the script property to
//  the correct charset.  If there is no window, then the first value
//  enumerated is set into the script, and contol returned.  If there is a
//  window, then the scripts will all be filled in.  If the correct value
//  is found, then that will be filled in. If its not found, such as when
//  the user changes from TimesNewRoman to WingDings, then the caller will
//  fill in the property to be the first one.
//
////////////////////////////////////////////////////////////////////////////

int FontScriptEnumProc(
    LPENUMLOGFONTEX lplf,
    LPNEWTEXTMETRIC lptm,
    DWORD nFontType,
    LPENUM_FONT_DATA lpData)
{
    int script = -1;

    //
    //  Need to check the charsets again as we have a face and are checking
    //  the family.
    //
    //  Bounce non WANSI fonts.
    //
    if ( (lpData->dwFlags & CF_SCRIPTSONLY) &&
         ((lplf->elfLogFont.lfCharSet == OEM_CHARSET) ||
          (lplf->elfLogFont.lfCharSet == SYMBOL_CHARSET)) )
    {
        return (TRUE);
    }

    if (lpData->hwndScript)
    {
        script = CBAddScript( lpData->hwndScript,
                              lplf->elfScript,
                              lplf->elfLogFont.lfCharSet );
    }
    else if (lpData->iCharset == FONT_INVALID_CHARSET)
    {
        lpData->iCharset = lplf->elfLogFont.lfCharSet;
    }

    if (lplf->elfLogFont.lfCharSet == lpData->cfdCharset)
    {
        lpData->iCharset = lplf->elfLogFont.lfCharSet;
        if (script >= 0)
        {
            SendMessage(lpData->hwndScript, CB_SETCURSEL, script, 0L);
        }
        else if (!(lpData->hwndScript))
        {
            return (FALSE);
        }
    }

    if (lpData->lpcf->Flags & CF_SELECTSCRIPT)
    {
        //
        //  We just wanted the first one to fill in the script box, now stop.
        //
        return (FALSE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetFontStylesAndSizes
//
//  Fills the point sizes combo box with the point sizes for the current
//  selection in the facenames combobox.
//
//  cmb1 is the ID for the font facename combobox.
//
//  Returns:   TRUE    if successful
//             FALSE   otherwise.
//
////////////////////////////////////////////////////////////////////////////

BOOL GetFontStylesAndSizes(
    HWND hDlg,
    PFONTINFO pFI,
    LPCHOOSEFONT lpcf,
    BOOL bForceSizeFill)
{
    ENUM_FONT_DATA data;
    TCHAR szFace[LF_FACESIZE];
    int iSel;
    int iMapMode;
    SIZE ViewportExt, WindowExt;
    LOGFONT lf;
    LPITEMDATA lpItemData;

    FreeFonts(GetDlgItem(hDlg, cmb2));

    data.hwndStyle  = GetDlgItem(hDlg, cmb2);
    data.hwndSizes  = GetDlgItem(hDlg, cmb3);
    data.hwndScript = (pFI->ProcessVersion >= 0x40000)
                          ? GetDlgItem(hDlg, cmb5)
                          : NULL;
    data.dwFlags    = lpcf->Flags;
    data.lpcf       = lpcf;

    if (!IsWindow(data.hwndScript) || !IsWindowEnabled(data.hwndScript))
    {
        data.hwndScript = NULL;
    }

    iSel = (int)SendDlgItemMessage(hDlg, cmb1, CB_GETCURSEL, 0, 0L);
    if (iSel < 0)
    {
        //
        //  If we don't have a face name selected we will synthisize
        //  the standard font styles...
        //
        InitLF(&lf);
        CBAddStyle(data.hwndStyle, szRegular, REGULAR_FONTTYPE, &lf);
        lf.lfWeight = FW_BOLD;
        CBAddStyle(data.hwndStyle, szBold, BOLD_FONTTYPE, &lf);
        lf.lfWeight = FW_NORMAL;
        lf.lfItalic = TRUE;
        CBAddStyle(data.hwndStyle, szItalic, ITALIC_FONTTYPE, &lf);
        lf.lfWeight = FW_BOLD;
        CBAddStyle(data.hwndStyle, szBoldItalic, BOLD_FONTTYPE | ITALIC_FONTTYPE, &lf);
        FillScalableSizes(data.hwndSizes, lpcf);

        return (TRUE);
    }

    lpItemData = (LPITEMDATA)SendDlgItemMessage( hDlg,
                                                 cmb1,
                                                 CB_GETITEMDATA,
                                                 iSel,
                                                 0L );
    if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
    {
        data.nFontType  = lpItemData->nFontType;
    }
    else
    {
        data.nFontType  = 0;
    }

    data.bFillSize = TRUE;

    //
    // Free existing contents of font size combo box.
    // Also sends CB_RESETCONTENT to control.
    //
    FreeFonts(data.hwndSizes);

    SendMessage(data.hwndStyle, WM_SETREDRAW, FALSE, 0L);

    GetDlgItemText(hDlg, cmb1, szFace, sizeof(szFace) / sizeof(TCHAR));
    lstrcpy(lf.lfFaceName, szFace);

    //
    //  Fill in the script box FIRST. That way we have something to play with.
    //
    if (data.hwndScript)
    {
        SendMessage(data.hwndScript, CB_RESETCONTENT, 0, 0L);
    }
    data.iCharset   = FONT_INVALID_CHARSET;      // impossible charset value.
    data.cfdCharset = pFI->iCharset;             // pass into enum procs

    //
    //  If no script box exists, then we must get the appropriate charset
    //  based on the default ansi code page.
    //
    if (!data.hwndScript)
    {
        CHARSETINFO csi;
        DWORD dwCodePage = GetACP();

        if (TranslateCharsetInfo((DWORD*)dwCodePage, &csi, TCI_SRCCODEPAGE))
        {
            data.cfdCharset = csi.ciCharset;
        }
    }

    lf.lfCharSet = (lpcf->Flags & CF_SELECTSCRIPT)
                       ? pFI->iCharset
                       : DEFAULT_CHARSET;

    if (lpcf->Flags & CF_SCREENFONTS)
    {
        data.hDC = GetDC(NULL);
        data.bPrinterFont = FALSE;
        EnumFontFamiliesEx( data.hDC,
                            &lf,
                            (FONTENUMPROC)FontScriptEnumProc,
                            (LPARAM)&data,
                            0L );
        ReleaseDC(NULL, data.hDC);
    }

    if (lpcf->Flags & CF_PRINTERFONTS)
    {
        data.hDC = lpcf->hDC;
        data.bPrinterFont = TRUE;
        EnumFontFamiliesEx( lpcf->hDC,
                            &lf,
                            (FONTENUMPROC)FontScriptEnumProc,
                            (LPARAM)&data,
                            0L );
    }

    //
    //  Put it back into the main structure.
    //
    if ((data.iCharset == FONT_INVALID_CHARSET) && (data.hwndScript))
    {
        //
        //  There MUST be a script window, and we didn't find the charset
        //  we were looking for.
        //
        SendMessage(data.hwndScript, CB_SETCURSEL, 0, 0L);
        lpItemData = (LPITEMDATA)SendMessage( data.hwndScript,
                                              CB_GETITEMDATA,
                                              0,
                                              0L );
        if (lpItemData && (lpItemData != (LPITEMDATA)CB_ERR))
        {
            data.iCharset = lpItemData->nFontType;
        }
        else
        {
            data.iCharset = DEFAULT_CHARSET;
        }
    }
    lf.lfCharSet = pFI->iCharset = data.iCharset;

    if (lpcf->Flags & CF_SCREENFONTS)
    {
        data.hDC = GetDC(NULL);
        data.bPrinterFont = FALSE;
        EnumFontFamiliesEx( data.hDC,
                            &lf,
                            (FONTENUMPROC)FontStyleEnumProc,
                            (LPARAM)&data,
                            0L );
        ReleaseDC(NULL, data.hDC);
    }

    if (lpcf->Flags & CF_PRINTERFONTS)
    {
        //
        //  Save and restore the DC's mapping mode (and extents if needed)
        //  if it's been set by the app to something other than MM_TEXT.
        //
        if ((iMapMode = GetMapMode(lpcf->hDC)) != MM_TEXT)
        {
            if ((iMapMode == MM_ISOTROPIC) || (iMapMode == MM_ANISOTROPIC))
            {
                GetViewportExtEx(lpcf->hDC, &ViewportExt);
                GetWindowExtEx(lpcf->hDC, &WindowExt);
            }
            SetMapMode(lpcf->hDC, MM_TEXT);
        }

        data.hDC = lpcf->hDC;
        data.bPrinterFont = TRUE;
        EnumFontFamiliesEx( lpcf->hDC,
                            &lf,
                            (FONTENUMPROC)FontStyleEnumProc,
                            (LPARAM)&data,
                            0L );

        if (iMapMode != MM_TEXT)
        {
            SetMapMode(lpcf->hDC, iMapMode);
            if ((iMapMode == MM_ISOTROPIC) || (iMapMode == MM_ANISOTROPIC))
            {
                SetWindowExtEx( lpcf->hDC,
                                WindowExt.cx,
                                WindowExt.cy,
                                &WindowExt );
                SetViewportExtEx( lpcf->hDC,
                                  ViewportExt.cx,
                                  ViewportExt.cy,
                                  &ViewportExt );
            }
        }
    }

    if (!(lpcf->Flags & CF_NOSIMULATIONS))
    {
        FillInMissingStyles(data.hwndStyle);
    }

    SendMessage(data.hwndStyle, WM_SETREDRAW, TRUE, 0L);
    if (wWinVer < 0x030A)
    {
        InvalidateRect(data.hwndStyle, NULL, TRUE);
    }

    if (data.bFillSize)
    {
        SendMessage(data.hwndSizes, WM_SETREDRAW, TRUE, 0L);
        if (wWinVer < 0x030A)
        {
            InvalidateRect(data.hwndSizes, NULL, TRUE);
        }
    }

#ifdef MM_DESIGNVECTOR_DEFINED
    if (pFI->pfnCreateFontIndirectEx !=NULL)
    /* it's not safe to access the MM Axis information on a system where CreateFontIndirectEx is not defined */
    {
        if (lpcf->Flags & CF_SCREENFONTS)
        {
            data.hDC = GetDC(NULL);
            data.bPrinterFont = FALSE;
            data.hwndParent = hDlg;
            data.pDefaultDesignVector = &pFI->DefaultDesignVector;
            EnumFontFamiliesEx( data.hDC,
                                &lf,
                                (FONTENUMPROC)FontMMAxesEnumProc,
                                (LPARAM)&data,
                                0L );
            ReleaseDC(NULL, data.hDC);
        }

        if (lpcf->Flags & CF_PRINTERFONTS)
        {
            data.hDC = lpcf->hDC;
            data.bPrinterFont = TRUE;
            EnumFontFamiliesEx( lpcf->hDC,
                                &lf,
                                (FONTENUMPROC)FontMMAxesEnumProc,
                                (LPARAM)&data,
                                0L );
        }
    }
#endif // MM_DESIGNVECTOR_DEFINED

    ResetSampleFromScript(hDlg, data.hwndScript, pFI);

    if (lpcf->Flags & CF_NOSCRIPTSEL)
    {
        pFI->iCharset = DEFAULT_CHARSET;
    }

    bForceSizeFill;
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  FillColorCombo
//
//  Adds the color name strings to the colors combobox.
//
//  cmb4 is the ID for the color combobox.
//
//  The color rectangles are drawn later in response to a WM_DRAWITEM msg.
//
////////////////////////////////////////////////////////////////////////////

VOID FillColorCombo(
    HWND hDlg)
{
    int iT, item;
    TCHAR szT[CCHCOLORNAMEMAX];

    for (iT = 0; iT < CCHCOLORS; ++iT)
    {
        *szT = 0;
        LoadString(g_hinst, iszBlack + iT, szT, sizeof(szT) / sizeof(TCHAR));
        item = (int) SendDlgItemMessage( hDlg,
                                         cmb4,
                                         CB_INSERTSTRING,
                                         iT,
                                         (LPARAM)szT );
        if (item >= 0)
        {
            SendDlgItemMessage(hDlg, cmb4, CB_SETITEMDATA, item, rgbColors[iT]);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawSizeComboItem
//
////////////////////////////////////////////////////////////////////////////

BOOL DrawSizeComboItem(
    LPDRAWITEMSTRUCT lpdis)
{
    HDC hDC;
    DWORD rgbBack, rgbText;
    TCHAR szFace[LF_FACESIZE + 10];
    HFONT hFont;

    hDC = lpdis->hDC;

    //
    //  We must first select the dialog control font.
    //
    if (hDlgFont)
    {
        hFont = SelectObject(hDC, hDlgFont);
    }

    if (lpdis->itemState & ODS_SELECTED)
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    }
    else
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    }

    SendMessage( lpdis->hwndItem,
                 CB_GETLBTEXT,
                 lpdis->itemID,
                 (LONG_PTR)(LPTSTR)szFace );

    ExtTextOut( hDC,
                lpdis->rcItem.left + GetSystemMetrics(SM_CXBORDER),
                lpdis->rcItem.top,
                ETO_OPAQUE,
                &lpdis->rcItem,
                szFace,
                lstrlen(szFace),
                NULL );
    //
    //  Reset font.
    //
    if (hFont)
    {
        SelectObject(hDC, hFont);
    }

    SetTextColor(hDC, rgbText);
    SetBkColor(hDC, rgbBack);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawFamilyComboItem
//
////////////////////////////////////////////////////////////////////////////

BOOL DrawFamilyComboItem(
    LPDRAWITEMSTRUCT lpdis)
{
    HDC hDC, hdcMem;
    DWORD rgbBack, rgbText;
    TCHAR szFace[LF_FACESIZE + 10];
    HBITMAP hOld;
    int dy, x;
    HFONT hFont;

    hDC = lpdis->hDC;

    //
    //  We must first select the dialog control font.
    //
    if (hDlgFont)
    {
        hFont = SelectObject(hDC, hDlgFont);
    }

    if (lpdis->itemState & ODS_SELECTED)
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    }
    else
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    }

    // wsprintf(szFace, "%4.4X", LOWORD(lpdis->itemData));

    SendMessage( lpdis->hwndItem,
                 CB_GETLBTEXT,
                 lpdis->itemID,
                 (LONG_PTR)(LPTSTR)szFace );
    ExtTextOut( hDC,
                lpdis->rcItem.left + DX_BITMAP,
                lpdis->rcItem.top,
                ETO_OPAQUE,
                &lpdis->rcItem,
                szFace,
                lstrlen(szFace),
                NULL );
    //
    //  Reset font.
    //
    if (hFont)
    {
        SelectObject(hDC, hFont);
    }

    hdcMem = CreateCompatibleDC(hDC);
    if (hdcMem)
    {
        if (hbmFont)
        {
            LPITEMDATA lpItemData = (LPITEMDATA)lpdis->itemData;

            hOld = SelectObject(hdcMem, hbmFont);

            if (!lpItemData)
            {
                goto SkipBlt;
            }

            if (lpItemData->nFontType & TRUETYPE_FONTTYPE)
            {
#ifdef WINNT
                if (lpItemData->nFontType & TT_OPENTYPE_FONTTYPE)
                    x = 2 * DX_BITMAP;
                else
#endif
                    x = 0;
            }
#ifdef WINNT
            else if (lpItemData->nFontType & PS_OPENTYPE_FONTTYPE)
            {
                x = 3 * DX_BITMAP;
            }
            else if (lpItemData->nFontType & TYPE1_FONTTYPE)
            {
                x = 4 * DX_BITMAP;
            }
#endif
            else
            {
                if ((lpItemData->nFontType & (PRINTER_FONTTYPE |
                                              DEVICE_FONTTYPE))
                  == (PRINTER_FONTTYPE | DEVICE_FONTTYPE))
                {
                    //
                    //  This may be a screen and printer font but
                    //  we will call it a printer font here.
                    //
                    x = DX_BITMAP;
                }
                else
                {
                    goto SkipBlt;
                }
            }

            dy = ((lpdis->rcItem.bottom - lpdis->rcItem.top) - DY_BITMAP) / 2;

            BitBlt( hDC,
                    lpdis->rcItem.left,
                    lpdis->rcItem.top + dy,
                    DX_BITMAP,
                    DY_BITMAP,
                    hdcMem,
                    x,
                    lpdis->itemState & ODS_SELECTED ? DY_BITMAP : 0,
                    SRCCOPY );

SkipBlt:
            SelectObject(hdcMem, hOld);
        }
        DeleteDC(hdcMem);
    }

    SetTextColor(hDC, rgbText);
    SetBkColor(hDC, rgbBack);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawColorComboItem
//
//  Computes and draws the color combo items.
//  Called by main dialog function in response to a WM_DRAWITEM msg.
//
//  All color name strings have already been loaded and filled into
//  the combobox.
//
//  Returns:   TRUE    if succesful
//             FALSE   otherwise.
//
////////////////////////////////////////////////////////////////////////////

BOOL DrawColorComboItem(
    LPDRAWITEMSTRUCT lpdis)
{
    HDC hDC;
    HBRUSH hbr;
    int dx, dy;
    RECT rc;
    TCHAR szColor[CCHCOLORNAMEMAX];
    DWORD rgbBack, rgbText, dw;
    HFONT hFont;

    hDC = lpdis->hDC;

    if (lpdis->itemState & ODS_SELECTED)
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    }
    else
    {
        rgbBack = SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    }
    ExtTextOut( hDC,
                lpdis->rcItem.left,
                lpdis->rcItem.top,
                ETO_OPAQUE,
                &lpdis->rcItem,
                NULL,
                0,
                NULL );

    //
    //  Compute coordinates of color rectangle and draw it.
    //
    dx = GetSystemMetrics(SM_CXBORDER);
    dy = GetSystemMetrics(SM_CYBORDER);
    rc.top    = lpdis->rcItem.top + dy;
    rc.bottom = lpdis->rcItem.bottom - dy;
    rc.left   = lpdis->rcItem.left + dx;
    rc.right  = rc.left + 2 * (rc.bottom - rc.top);

    dw = (DWORD) SendMessage(lpdis->hwndItem, CB_GETITEMDATA, lpdis->itemID, 0L);

    hbr = CreateSolidBrush(dw);
    if (!hbr)
    {
        return (FALSE);
    }

    hbr = SelectObject(hDC, hbr);
    Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom);
    DeleteObject(SelectObject(hDC, hbr));

    //
    //  Shift the color text right by the width of the color rectangle.
    //
    *szColor = 0;
    SendMessage( lpdis->hwndItem,
                 CB_GETLBTEXT,
                 lpdis->itemID,
                 (LONG_PTR)(LPTSTR)szColor );

    //
    //  We must first select the dialog control font.
    //
    if (hDlgFont)
    {
        hFont = SelectObject(hDC, hDlgFont);
    }

    TextOut( hDC,
             2 * dx + rc.right,
             lpdis->rcItem.top,
             szColor,
             lstrlen(szColor) );

    //
    //  Reset font.
    //
    if (hFont)
    {
        SelectObject(hDC, hFont);
    }

    SetTextColor(hDC, rgbText);
    SetBkColor(hDC, rgbBack);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawSampleText
//
//  Displays sample text with given attributes.  Assumes rcText holds the
//  coordinates of the area within the frame (relative to dialog client)
//  which text should be drawn in.
//
////////////////////////////////////////////////////////////////////////////

VOID DrawSampleText(
    HWND hDlg,
    PFONTINFO pFI,
    LPCHOOSEFONT lpcf,
    HDC hDC)
{
    DWORD rgbText;
    DWORD rgbBack;
    int iItem;
    HFONT hFont, hTemp;
    TCHAR szSample[50];
#ifdef MM_DESIGNVECTOR_DEFINED
    ENUMLOGFONTEXDV elfdv;
#else
    LOGFONT lf;
#endif // MM_DESIGNVECTOR_DEFINED
    SIZE TextExtent;
    int len, x, y;
    TEXTMETRIC tm;
    BOOL bCompleteFont;
    RECT rcText;

#ifdef MM_DESIGNVECTOR_DEFINED
    bCompleteFont = FillInFontEx(hDlg, pFI, lpcf, &elfdv, FALSE);
    elfdv.elfEnumLogfontEx.elfLogFont.lfEscapement = 0;
    elfdv.elfEnumLogfontEx.elfLogFont.lfOrientation = 0;

    if (pFI->pfnCreateFontIndirectEx != NULL)
    {
        hFont = pFI->pfnCreateFontIndirectEx(&elfdv);
    }
    else
    {
        hFont = CreateFontIndirect((LPLOGFONT)&elfdv);
    }
#else
    bCompleteFont = FillInFont(hDlg, pFI, lpcf, &lf, FALSE);
    lf.lfEscapement = 0;
    lf.lfOrientation = 0;

    hFont = CreateFontIndirect(&lf);
#endif // MM_DESIGNVECTOR_DEFINED
    if (!hFont)
    {
        return;
    }

    hTemp = SelectObject(hDC, hFont);

    rgbBack = SetBkColor(hDC, GetSysColor((pFI->ProcessVersion < 0x40000)
                                          ? COLOR_WINDOW
                                          : COLOR_3DFACE));

    if (lpcf->Flags & CF_EFFECTS)
    {
        iItem = (int)SendDlgItemMessage(hDlg, cmb4, CB_GETCURSEL, 0, 0L);
        if (iItem != CB_ERR)
        {
            rgbText = (DWORD) SendDlgItemMessage(hDlg, cmb4, CB_GETITEMDATA, iItem, 0L);
        }
        else
        {
            goto GetWindowTextColor;
        }
    }
    else
    {
GetWindowTextColor:
        rgbText = GetSysColor(COLOR_WINDOWTEXT);
    }

    rgbText = SetTextColor(hDC, rgbText);
 
    if (bCompleteFont)
    {
        if (GetUnicodeSampleText(hDC,szSample, sizeof(szSample) / sizeof(TCHAR)))           
        {
            //Empty Body
        }
        else
        {
            GetDlgItemText(hDlg, stc5, szSample, sizeof(szSample) / sizeof(TCHAR));
        }
    }
    else
    {
        szSample[0] = 0;
    }

    GetTextMetrics(hDC, &tm);

    len = lstrlen(szSample);
    GetTextExtentPoint(hDC, szSample, len, &TextExtent);
    TextExtent.cy = tm.tmAscent - tm.tmInternalLeading;

    rcText = pFI->rcText;

    if (pFI->ProcessVersion >= 0x40000)
    {
#ifdef UNICODE
        if (!IS16BITWOWAPP(lpcf) || !(lpcf->Flags & CF_ENABLEHOOK))
#endif
        {
            DrawEdge(hDC, &rcText, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
        }
    }
#ifndef WINNT
    else
    {
        //
        //  We only care about conforming if we have no border.
        //
        FORWARD_WM_CTLCOLORSTATIC(hDlg, hDC, NULL, SendMessage);
    }
#endif

    if ((TextExtent.cx >= (rcText.right - rcText.left)) ||
        (TextExtent.cx <= 0))
    {
        x = rcText.left;
    }
    else
    {
        x = rcText.left + ((rcText.right - rcText.left) - TextExtent.cx) / 2;
    }

    y = min( rcText.bottom,
             rcText.bottom - ((rcText.bottom - rcText.top) - TextExtent.cy) / 2);

    ExtTextOut( hDC,
                x,
                y - (tm.tmAscent),
                ETO_OPAQUE | ETO_CLIPPED,
                &rcText,
                szSample,
                len,
                NULL );

    SetBkColor(hDC, rgbBack);
    SetTextColor(hDC, rgbText);

    if (hTemp)
    {
        DeleteObject(SelectObject(hDC, hTemp));
    }
}

#ifdef MM_DESIGNVECTOR_DEFINED
////////////////////////////////////////////////////////////////////////////
//
//  FillInFontEx
//
//  Fills in the ENUMLOGFONTEXDV structure based on the current selection.
//
//  bSetBits - if TRUE the Flags fields in the lpcf are set to indicate
//             what parts (face, style, size) are not selected
//
//  lpelfdv  - ENUMLOGFONTEXDV filled in upon return
//
//  Returns:   TRUE    if there was an unambiguous selection
//                     (the ENUMLOGFONTEXDV is filled in as per the enumeration)
//             FALSE   there was not a complete selection
//                     (fields set in the ENUMLOGFONTEXDV with default values)
//
////////////////////////////////////////////////////////////////////////////

BOOL FillInFontEx(
    HWND hDlg,
    PFONTINFO pFI,
    LPCHOOSEFONT lpcf,
    LPENUMLOGFONTEXDV lpelfdv,
    BOOL bSetBits)
{
    UINT i;
    BOOL bTranslated;

    ZeroMemory(lpelfdv, sizeof(ENUMLOGFONTEXDV));

    lpelfdv->elfDesignVector.dvNumAxes = pFI->DefaultDesignVector.dvNumAxes;
    lpelfdv->elfDesignVector.dvReserved = STAMP_DESIGNVECTOR;  

    for (i=0; i<lpelfdv->elfDesignVector.dvNumAxes; i++)
           lpelfdv->elfDesignVector.dvValues[i] = GetDlgItemInt(hDlg, edt1 + i, &bTranslated, TRUE);

    return FillInFont(hDlg, pFI, lpcf, &lpelfdv->elfEnumLogfontEx.elfLogFont, bSetBits);
    // memcpy (&lpelfdv->elfEnumLogfontEx.elfLogFont, &lf, sizeof(LOGFONT));
}
#endif // MM_DESIGNVECTOR_DEFINED

////////////////////////////////////////////////////////////////////////////
//
//  FillInFont
//
//  Fills in the LOGFONT structure based on the current selection.
//
//  bSetBits - if TRUE the Flags fields in the lpcf are set to indicate
//             what parts (face, style, size) are not selected
//
//  lplf     - LOGFONT filled in upon return
//
//  Returns:   TRUE    if there was an unambiguous selection
//                     (the LOGFONT is filled in as per the enumeration)
//             FALSE   there was not a complete selection
//                     (fields set in the LOGFONT with default values)
//
////////////////////////////////////////////////////////////////////////////

BOOL FillInFont(
    HWND hDlg,
    PFONTINFO pFI,
    LPCHOOSEFONT lpcf,
    LPLOGFONT lplf,
    BOOL bSetBits)
{
    HDC hdc;
    int iSel, id, pts;
    LPITEMDATA lpItemData;
    DWORD nFontType;
    PLOGFONT plf;
    TCHAR szStyle[LF_FACESIZE];
    TCHAR szMessage[128];
    BOOL bFontComplete = TRUE;
    CHARSETINFO csi;
    DWORD dwCodePage = GetACP();

    if (!TranslateCharsetInfo((DWORD*)dwCodePage, &csi, TCI_SRCCODEPAGE))
    {
        csi.ciCharset = ANSI_CHARSET;
    }

    InitLF(lplf);

    GetDlgItemText( hDlg,
                    cmb1,
                    lplf->lfFaceName,
                    sizeof(lplf->lfFaceName) / sizeof(TCHAR) );
    if (CBFindString(GetDlgItem(hDlg, cmb1), lplf->lfFaceName) >= 0)
    {
        if (bSetBits)
        {
            lpcf->Flags &= ~CF_NOFACESEL;
        }
    }
    else
    {
        bFontComplete = FALSE;
        if (bSetBits)
        {
            lpcf->Flags |= CF_NOFACESEL;
        }
    }

    iSel = CBGetTextAndData( GetDlgItem(hDlg, cmb2),
                             szStyle,
                             sizeof(szStyle) / sizeof(TCHAR),
                             (PULONG_PTR)&lpItemData );
    if ((iSel >= 0) && lpItemData)
    {
        nFontType = lpItemData->nFontType;
        plf = lpItemData->pLogFont;
        *lplf = *plf;                       // copy the LOGFONT
        lplf->lfWidth = 0;                  // 1:1 x-y scaling
        if (!lstrcmp(lplf->lfFaceName, TEXT("Small Fonts")))
        {
            lplf->lfCharSet = (BYTE) csi.ciCharset;
        }
        if (bSetBits)
        {
            lpcf->Flags &= ~CF_NOSTYLESEL;
        }
    }
    else
    {
        //
        //  Even if the style is invalid, we still need the charset.
        //
        iSel = CBGetTextAndData( GetDlgItem(hDlg, cmb2),
                                 (LPTSTR)NULL,
                                 0,
                                 (PULONG_PTR)&lpItemData );
        if ((iSel >= 0) && lpItemData)
        {
            nFontType = lpItemData->nFontType;
            plf = lpItemData->pLogFont;
            *lplf = *plf;                   // copy the LOGFONT
            lplf->lfWidth = 0;              // 1:1 x-y scaling
            if (!lstrcmp(lplf->lfFaceName, TEXT("Small Fonts")) ||
                !lstrcmp(lplf->lfFaceName, TEXT("Lucida Sans Unicode")))
            {
                lplf->lfCharSet = (BYTE) csi.ciCharset;
            }
        }

        bFontComplete = FALSE;
        if (bSetBits)
        {
            lpcf->Flags |= CF_NOSTYLESEL;
        }
        nFontType = 0;
    }

    //
    //  Now make sure the size is in range; pts will be 0 if not.
    //
    GetPointSizeInRange(hDlg, lpcf, &pts, 0);

    hdc = GetDC(NULL);
    if (pts)
    {
        if (IS_SIMPLIFIED_CHINESE(UserLangID))
        {
            UINT iHeight;
            int iLogPixY = GetDeviceCaps(hdc, LOGPIXELSY);
            int ptsfr = pts % 10;          // fractional point size

            pts /= 10;                     // real point size
            iHeight = pts * iLogPixY;
            if (ptsfr)
            {
                iHeight += MulDiv(ptsfr, iLogPixY, 10);
            }
            lplf->lfHeight = -((int)((iHeight + POINTS_PER_INCH / 2) /
                                     POINTS_PER_INCH));
        }
        else
        {
            pts /= 10;
            lplf->lfHeight = -MulDiv( pts,
                                      GetDeviceCaps(hdc, LOGPIXELSY),
                                      POINTS_PER_INCH );
        }
        if (bSetBits)
        {
            lpcf->Flags &= ~CF_NOSIZESEL;
        }
    }
    else
    {
        lplf->lfHeight = -MulDiv( DEF_POINT_SIZE,
                                  GetDeviceCaps(hdc, LOGPIXELSY),
                                  POINTS_PER_INCH );
        bFontComplete = FALSE;
        if (bSetBits)
        {
            lpcf->Flags |= CF_NOSIZESEL;
        }
    }
    ReleaseDC(NULL, hdc);

    //
    //  And the attributes we control.
    //
    lplf->lfStrikeOut = (BYTE)IsDlgButtonChecked(hDlg, chx1);
    lplf->lfUnderline = (BYTE)IsDlgButtonChecked(hDlg, chx2);
    lplf->lfCharSet   = (BYTE) pFI->iCharset;

    if (nFontType != pFI->nLastFontType)
    {
        if (lpcf->Flags & CF_PRINTERFONTS)
        {
            if (nFontType & SIMULATED_FONTTYPE)
            {
                id = iszSynth;
            }
#ifdef WINNT
            else if (nFontType & TT_OPENTYPE_FONTTYPE)
            {
                id = iszTTOpenType;
            }
            else if (nFontType & PS_OPENTYPE_FONTTYPE)
            {
                id = iszPSOpenType;
            }
            else if (nFontType & TYPE1_FONTTYPE)
            {
                id = iszType1;
            }
#endif
            else if (nFontType & TRUETYPE_FONTTYPE)
            {
                id = iszTrueType;
            }
            else if ((nFontType & (PRINTER_FONTTYPE | DEVICE_FONTTYPE)) ==
                     (PRINTER_FONTTYPE | DEVICE_FONTTYPE))
            {
                //
                //  May be both screen and printer (ATM) but we'll just
                //  call this a printer font.
                //
                id = iszPrinterFont;
            }
            else if ((nFontType & (PRINTER_FONTTYPE | SCREEN_FONTTYPE)) ==
                     SCREEN_FONTTYPE)
            {
                id = iszGDIFont;
            }
            else
            {
                szMessage[0] = 0;
                goto SetText;
            }
            LoadString( g_hinst,
                        id,
                        szMessage,
                        sizeof(szMessage) / sizeof(TCHAR) );
SetText:
            SetDlgItemText(hDlg, stc6, szMessage);
        }
    }

    pFI->nLastFontType = nFontType;

    return (bFontComplete);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetLogFont
//
//  Sets the current selection based on the LOGFONT structure passed in.
//
//  lpcf     - CHOOSEFONT structure for the current dialog
//  lplf     - LOGFONT filled in upon return
//
//  Returns:   TRUE    if there was an unambiguous selection
//                     (the LOGFONT is filled in as per the enumeration)
//             FALSE   there was not a complete selection
//                     (fields set in the LOGFONT with default values)
//
////////////////////////////////////////////////////////////////////////////

BOOL SetLogFont(
    HWND hDlg,
    LPCHOOSEFONT lpcf,
    LPLOGFONT lplf)
{
    *(lpcf->lpLogFont) = *lplf;        // Copies data & FaceName

    FORWARD_WM_COMMAND( hDlg,
                        cmb1,
                        GetDlgItem(hDlg, cmb1),
                        CBN_SELCHANGE,
                        SendMessage );
    return (TRUE);
}

#ifdef MM_DESIGNVECTOR_DEFINED
BOOL SetLogFontEx(
    HWND hDlg,
    LPCHOOSEFONT lpcf,
    LPENUMLOGFONTEXDV lplf)
{
    memcpy(lpcf->lpLogFont, lplf, sizeof(ENUMLOGFONTEXDV));

    FORWARD_WM_COMMAND( hDlg,
                        cmb1,
                        GetDlgItem(hDlg, cmb1),
                        CBN_SELCHANGE,
                        SendMessage );
    return (TRUE);
}
#endif // MM_DESIGNVECTOR_DEFINED

////////////////////////////////////////////////////////////////////////////
//
//  TermFont
//
//  Release any data required by functions in this module.
//
////////////////////////////////////////////////////////////////////////////

VOID TermFont()
{
    if (hbmFont)
    {
        DeleteObject(hbmFont);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetPointString
//
//  Converts font height into a string of digits representing point size.
//
//  Returns:   Size in points and fills in buffer with string
//
////////////////////////////////////////////////////////////////////////////

int GetPointString(
    LPTSTR buf,
    HDC hDC,
    int height)
{
    int pts;

    if (IS_SIMPLIFIED_CHINESE(UserLangID))
    {
        int ptsfr, iLogPixY, ctr;
        long lpts;
        BOOL IsZihao = FALSE;

        lpts = ((height < 0) ? -height : height) * 72;

        //
        //  Get real point size.
        //
        pts = (int)(lpts / (iLogPixY = GetDeviceCaps(hDC, LOGPIXELSY)));

        //
        //  Get fractional point size.
        //
        ptsfr = MulDiv((int)(lpts % iLogPixY), 10, iLogPixY);

        //
        //  See if it's Zihao.
        //
        for (ctr = 0; ctr < NUM_ZIHAO; ctr++)
        {
            if ((pts == stZihao[ctr].size) &&
                (abs(ptsfr - stZihao[ctr].sizeFr) <= 3))
            {
                IsZihao = TRUE;
                wsprintf(buf, TEXT("%s"), stZihao[ctr].name);
                break;
            }
        }
        if (!IsZihao)
        {
            pts = MulDiv((height < 0) ? -height : height, 72, iLogPixY);
            for (ctr = 0; ctr < NUM_ZIHAO; ctr++)
            {
                if ((pts == stZihao[ctr].size) && (!stZihao[ctr].sizeFr))
                {
                    IsZihao = TRUE;
                    wsprintf(buf, TEXT("%s"), stZihao[ctr].name);
                    break;
                }
            }
        }
        if (!IsZihao)
        {
            wsprintf(buf, szPtFormat, pts);
        }
    }
    else
    {
        pts = MulDiv( (height < 0) ? -height : height,
                      72,
                      GetDeviceCaps(hDC, LOGPIXELSY) );
        wsprintf(buf, szPtFormat, pts);
    }

    return (pts);
}


////////////////////////////////////////////////////////////////////////////
//
//  FlipColor
//
////////////////////////////////////////////////////////////////////////////

DWORD FlipColor(
    DWORD rgb)
{
    return ( RGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb)) );
}


////////////////////////////////////////////////////////////////////////////
//
//  LoadBitmaps
//
//  This routine loads DIB bitmaps, and "fixes up" their color tables
//  so that we get the desired result for the device we are on.
//
//  This routine requires:
//      the DIB is a 16 color DIB authored with the standard windows colors
//      bright blue (00 00 FF) is converted to the background color
//      light grey  (C0 C0 C0) is replaced with the button face color
//      dark grey   (80 80 80) is replaced with the button shadow color
//
//  This means you can't have any of these colors in your bitmap.
//
////////////////////////////////////////////////////////////////////////////

#define BACKGROUND      0x000000FF          // bright blue
#define BACKGROUNDSEL   0x00FF00FF          // bright blue
#define BUTTONFACE      0x00C0C0C0          // bright grey
#define BUTTONSHADOW    0x00808080          // dark grey

HBITMAP LoadBitmaps(
    int id)
{
    HDC hdc;
    HANDLE h;
    DWORD *p;
    BYTE *lpBits;
    HANDLE hRes;
    LPBITMAPINFOHEADER lpBitmapInfo;
    int numcolors;
    DWORD rgbSelected;
    DWORD rgbUnselected;
    HBITMAP hbm;
    UINT cbBitmapSize;
    LPBITMAPINFOHEADER lpBitmapData;

    rgbSelected = FlipColor(GetSysColor(COLOR_HIGHLIGHT));
    rgbUnselected = FlipColor(GetSysColor(COLOR_WINDOW));

    h = FindResource(g_hinst, MAKEINTRESOURCE(id), RT_BITMAP);
    hRes = LoadResource(g_hinst, h);

    //
    //  Lock the bitmap and get a pointer to the color table.
    //
    lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);

    if (!lpBitmapInfo)
    {
        return (FALSE);
    }

    //
    //  Lock the bitmap data and make a copy of it for the mask and the
    //  bitmap.
    //
    cbBitmapSize = SizeofResource(g_hinst, h);

    lpBitmapData = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, cbBitmapSize);

    if (!lpBitmapData)
    {
        return (NULL);
    }

    memcpy((TCHAR *)lpBitmapData, (TCHAR *)lpBitmapInfo, cbBitmapSize);

    p = (DWORD *)((LPTSTR)(lpBitmapData) + lpBitmapData->biSize);

    //
    //  Search for the Solid Blue entry and replace it with the current
    //  background RGB.
    //
    numcolors = 16;

    while (numcolors-- > 0)
    {
        if (*p == BACKGROUND)
        {
            *p = rgbUnselected;
        }
        else if (*p == BACKGROUNDSEL)
        {
            *p = rgbSelected;
        }
#if 0
        else if (*p == BUTTONFACE)
        {
            *p = FlipColor(GetSysColor(COLOR_BTNFACE));
        }
        else if (*p == BUTTONSHADOW)
        {
            *p = FlipColor(GetSysColor(COLOR_BTNSHADOW));
        }
#endif
        p++;
    }

    //
    //  First skip over the header structure.
    //
    lpBits = (BYTE *)(lpBitmapData + 1);

    //
    //  Skip the color table entries, if any.
    //
    lpBits += (1 << (lpBitmapData->biBitCount)) * sizeof(RGBQUAD);

    //
    //  Create a color bitmap compatible with the display device.
    //
    hdc = GetDC(NULL);
    hbm = CreateDIBitmap( hdc,
                          lpBitmapData,
                          (DWORD)CBM_INIT,
                          lpBits,
                          (LPBITMAPINFO)lpBitmapData,
                          DIB_RGB_COLORS );
    ReleaseDC(NULL, hdc);

    LocalFree(lpBitmapData);

    return (hbm);
}


////////////////////////////////////////////////////////////////////////////
//
//  LookUpFontSubs
//
//  Looks in the font substitute list for a real font name.
//
//  lpSubFontName  - substitute font name
//  lpRealFontName - real font name buffer
//
//  Returns:   TRUE    if lpRealFontName is filled in
//             FALSE   if not
//
////////////////////////////////////////////////////////////////////////////

BOOL LookUpFontSubs(
    LPTSTR lpSubFontName,
    LPTSTR lpRealFontName)
{
    LONG lResult;
    HKEY hKey;
    TCHAR szValueName[MAX_PATH];
    TCHAR szValueData[MAX_PATH];
    DWORD dwValueSize;
    DWORD dwIndex = 0;
    DWORD dwType, dwSize;


    //
    //  Open the font substitution's key.
    //
    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            KEY_FONT_SUBS,
                            0,
                            KEY_READ,
                            &hKey );

    if (lResult != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    //
    //  Loop through the values in the key
    //
    dwValueSize = MAX_PATH;
    dwSize = MAX_PATH;
    while (RegEnumValue( hKey,
                         dwIndex,
                         szValueName,
                         &dwValueSize,
                         NULL,
                         &dwType,
                         (LPBYTE)szValueData,
                         &dwSize ) == ERROR_SUCCESS)
    {
        //
        //  If the value name matches the requested font name, then
        //  copy the real font name to the output buffer.
        //
        if (!lstrcmpi(szValueName, lpSubFontName))
        {
            lstrcpy(lpRealFontName, szValueData);
            RegCloseKey(hKey);
            return (TRUE);
        }

        //
        //  Re-initialize for the next time through the loop.
        //
        dwValueSize = MAX_PATH;
        dwSize = MAX_PATH;
        dwIndex++;
    }

    //
    //  Clean up.
    //
    *lpRealFontName = CHAR_NULL;
    RegCloseKey(hKey);
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetUnicodeSampleText
//
//  Gets the sample text for the font selected in the HDC
//
////////////////////////////////////////////////////////////////////////////
BOOL GetUnicodeSampleText(HDC hdc, LPTSTR lpString, int nMaxCount)
{

    FONTSIGNATURE sig;
    int i, j;
    int iLang = 0;
    int base = 0;
    int mask;


    if (!lpString || !nMaxCount)
    {
        return FALSE;
    }

    //Make sure return value is nulled
    lpString[0] = 0;


    //First Get the Font Signature
    GetTextCharsetInfo(hdc, &sig, 0);

    //Select the first unicode range supported by this font

    //For each of Unicode dwords
    for (i=0; i < 4; i++)
    {
        // See if a particular bit is set
        for (j=0; j < sizeof(DWORD) * 8 ; j++)
        {
             mask =  1 << j;

            if (sig.fsUsb[i] & mask)
            {
                //if set the get the language id for that bit
                iLang = base + j;
                goto LoadString;
            }
        }    
        base +=32;
    }

LoadString:
    //Do we have lang id and  string for that language ?
    if (iLang && LoadString(g_hinst, iszUnicode + iLang, lpString, nMaxCount))
    {
        return TRUE;
    }

    return FALSE;
}

/*========================================================================*/
/*                 Ansi->Unicode Thunk routines                           */
/*========================================================================*/

#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  ThunkChooseFontA2W
//
////////////////////////////////////////////////////////////////////////////

BOOL ThunkChooseFontA2W(
    PFONTINFO pFI)
{
    BOOL bRet;
    LPCHOOSEFONTW pCFW = pFI->pCF;
    LPCHOOSEFONTA pCFA = pFI->pCFA;

    pCFW->hwndOwner = pCFA->hwndOwner;
    pCFW->lCustData = pCFA->lCustData;

    pCFW->Flags = pCFA->Flags;

    //
    //  !!! hack, should not be based on flag value, since this could happen
    //  at any time.
    //
    if (pCFA->Flags & CF_INITTOLOGFONTSTRUCT)
    {
#ifdef MM_DESIGNVECTOR_DEFINED
        if (pFI->pfnCreateFontIndirectEx !=NULL)
        {
            ThunkEnumLogFontExDvA2W( (LPENUMLOGFONTEXDVA)pCFA->lpLogFont, 
                                    (LPENUMLOGFONTEXDVW)pCFW->lpLogFont);
        }
        else
        {
            ThunkLogFontA2W( pCFA->lpLogFont, pCFW->lpLogFont);
        }
#else
        ThunkLogFontA2W( pCFA->lpLogFont, pCFW->lpLogFont);
#endif // MM_DESIGNVECTOR_DEFINED
    }

    pCFW->hInstance = pCFA->hInstance;
    pCFW->lpfnHook = pCFA->lpfnHook;

    if (pCFW->Flags & CF_PRINTERFONTS)
    {
        pCFW->hDC = pCFA->hDC;
    }

    if (pCFW->Flags & CF_USESTYLE)
    {
        bRet = RtlAnsiStringToUnicodeString(pFI->pusStyle, pFI->pasStyle, FALSE);
    }

    pCFW->nSizeMin = pCFA->nSizeMin;
    pCFW->nSizeMax = pCFA->nSizeMax;
    pCFW->rgbColors = pCFA->rgbColors;

    pCFW->iPointSize = pCFA->iPointSize;
    pCFW->nFontType = pCFA->nFontType;

    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkChooseFontW2A
//
////////////////////////////////////////////////////////////////////////////

BOOL ThunkChooseFontW2A(
    PFONTINFO pFI)
{
    BOOL bRet;
    LPCHOOSEFONTA pCFA = pFI->pCFA;
    LPCHOOSEFONTW pCFW = pFI->pCF;

#ifdef MM_DESIGNVECTOR_DEFINED
    if (pFI->pfnCreateFontIndirectEx !=NULL)
    {
        ThunkEnumLogFontExDvW2A( (LPENUMLOGFONTEXDVW)pCFW->lpLogFont, 
                                (LPENUMLOGFONTEXDVA)pCFA->lpLogFont);
    } 
    else
    {
        ThunkLogFontW2A( pCFW->lpLogFont, pCFA->lpLogFont);
    }
#else
    ThunkLogFontW2A( pCFW->lpLogFont, pCFA->lpLogFont);
#endif // MM_DESIGNVECTOR_DEFINED

    pCFA->hInstance = pCFW->hInstance;
    pCFA->lpfnHook = pCFW->lpfnHook;

    if (pCFA->Flags & CF_USESTYLE)
    {
        pFI->pusStyle->Length = (lstrlen(pFI->pusStyle->Buffer) + 1) * sizeof(WCHAR);
        bRet = RtlUnicodeStringToAnsiString(pFI->pasStyle, pFI->pusStyle, FALSE);
    }

    pCFA->Flags = pCFW->Flags;
    pCFA->nSizeMin = pCFW->nSizeMin;
    pCFA->nSizeMax = pCFW->nSizeMax;
    pCFA->rgbColors = pCFW->rgbColors;

    pCFA->iPointSize = pCFW->iPointSize;
    pCFA->nFontType = pCFW->nFontType;
    pCFA->lCustData = pCFW->lCustData;

    return (bRet);
}

#ifdef MM_DESIGNVECTOR_DEFINED
////////////////////////////////////////////////////////////////////////////
//
//  ThunkEnumLogFontExDvA2W
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkEnumLogFontExDvA2W(
    LPENUMLOGFONTEXDVA lpELFDVA,
    LPENUMLOGFONTEXDVW lpELFDVW)
{
    UINT i;

    ThunkLogFontA2W(&lpELFDVA->elfEnumLogfontEx.elfLogFont,
                    &lpELFDVW->elfEnumLogfontEx.elfLogFont);

    MultiByteToWideChar( CP_ACP,
                         0,
                         lpELFDVA->elfEnumLogfontEx.elfFullName,
                         -1,
                         lpELFDVW->elfEnumLogfontEx.elfFullName,
                         LF_FULLFACESIZE );

    MultiByteToWideChar( CP_ACP,
                         0,
                         lpELFDVA->elfEnumLogfontEx.elfScript,
                         -1,
                         lpELFDVW->elfEnumLogfontEx.elfScript,
                         LF_FACESIZE );

    MultiByteToWideChar( CP_ACP,
                         0,
                         lpELFDVA->elfEnumLogfontEx.elfStyle,
                         -1,
                         lpELFDVW->elfEnumLogfontEx.elfStyle,
                         LF_FACESIZE );

    lpELFDVW->elfDesignVector.dvNumAxes = lpELFDVA->elfDesignVector.dvNumAxes;
    lpELFDVW->elfDesignVector.dvReserved = lpELFDVA->elfDesignVector.dvReserved;

    for (i=0; i<lpELFDVA->elfDesignVector.dvNumAxes; i++)
         lpELFDVW->elfDesignVector.dvValues[i] = lpELFDVA->elfDesignVector.dvValues[i];

}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkEnumLogFontExDvW2A
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkEnumLogFontExDvW2A(
    LPENUMLOGFONTEXDVW lpELFDVW,
    LPENUMLOGFONTEXDVA lpELFDVA)
{
    BOOL fDefCharUsed;
    UINT i;

    if (lpELFDVW && lpELFDVA)
    {
        ThunkLogFontW2A(&lpELFDVW->elfEnumLogfontEx.elfLogFont,
                        &lpELFDVA->elfEnumLogfontEx.elfLogFont);

        WideCharToMultiByte( CP_ACP,
                             0,
                             lpELFDVW->elfEnumLogfontEx.elfFullName,
                             -1,
                             lpELFDVA->elfEnumLogfontEx.elfFullName,
                             LF_FULLFACESIZE,
                             NULL,
                             &fDefCharUsed );

        WideCharToMultiByte( CP_ACP,
                             0,
                             lpELFDVW->elfEnumLogfontEx.elfScript,
                             -1,
                             lpELFDVA->elfEnumLogfontEx.elfScript,
                             LF_FACESIZE,
                             NULL,
                             &fDefCharUsed );

        WideCharToMultiByte( CP_ACP,
                             0,
                             lpELFDVW->elfEnumLogfontEx.elfStyle,
                             -1,
                             lpELFDVA->elfEnumLogfontEx.elfStyle,
                             LF_FACESIZE,
                             NULL,
                             &fDefCharUsed );

        lpELFDVA->elfDesignVector.dvNumAxes = lpELFDVW->elfDesignVector.dvNumAxes;
        lpELFDVA->elfDesignVector.dvReserved = lpELFDVW->elfDesignVector.dvReserved;

        for (i=0; i<lpELFDVW->elfDesignVector.dvNumAxes; i++)
             lpELFDVA->elfDesignVector.dvValues[i] = lpELFDVW->elfDesignVector.dvValues[i];

    }
}
#endif // MM_DESIGNVECTOR_DEFINED

////////////////////////////////////////////////////////////////////////////
//
//  ThunkLogFontA2W
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkLogFontA2W(
    LPLOGFONTA lpLFA,
    LPLOGFONTW lpLFW)
{
    lpLFW->lfHeight = lpLFA->lfHeight;
    lpLFW->lfWidth = lpLFA->lfWidth;
    lpLFW->lfEscapement = lpLFA->lfEscapement;
    lpLFW->lfOrientation = lpLFA->lfOrientation;
    lpLFW->lfWeight = lpLFA->lfWeight;
    lpLFW->lfItalic = lpLFA->lfItalic;
    lpLFW->lfUnderline = lpLFA->lfUnderline;
    lpLFW->lfStrikeOut = lpLFA->lfStrikeOut;
    lpLFW->lfCharSet = lpLFA->lfCharSet;
    lpLFW->lfOutPrecision = lpLFA->lfOutPrecision;
    lpLFW->lfClipPrecision = lpLFA->lfClipPrecision;
    lpLFW->lfQuality = lpLFA->lfQuality;
    lpLFW->lfPitchAndFamily = lpLFA->lfPitchAndFamily;

    SHAnsiToUnicode(lpLFA->lfFaceName,lpLFW->lfFaceName,LF_FACESIZE );
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkLogFontW2A
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkLogFontW2A(
    LPLOGFONTW lpLFW,
    LPLOGFONTA lpLFA)
{

    if (lpLFW && lpLFA)
    {
        lpLFA->lfHeight = lpLFW->lfHeight;
        lpLFA->lfWidth = lpLFW->lfWidth;
        lpLFA->lfEscapement = lpLFW->lfEscapement;
        lpLFA->lfOrientation = lpLFW->lfOrientation;
        lpLFA->lfWeight = lpLFW->lfWeight;
        lpLFA->lfItalic = lpLFW->lfItalic;
        lpLFA->lfUnderline = lpLFW->lfUnderline;
        lpLFA->lfStrikeOut = lpLFW->lfStrikeOut;
        lpLFA->lfCharSet = lpLFW->lfCharSet;
        lpLFA->lfOutPrecision = lpLFW->lfOutPrecision;
        lpLFA->lfClipPrecision = lpLFW->lfClipPrecision;
        lpLFA->lfQuality = lpLFW->lfQuality;
        lpLFA->lfPitchAndFamily = lpLFW->lfPitchAndFamily;

        SHUnicodeToAnsi(lpLFW->lfFaceName,lpLFA->lfFaceName,LF_FACESIZE);
    }
}


#ifdef WINNT

////////////////////////////////////////////////////////////////////////////
//
//  Ssync_ANSI_UNICODE_CF_For_WOW
//
//  Function to allow NT WOW to keep the ANSI & UNICODE versions of
//  the CHOOSEFONT structure in ssync as required by many 16-bit apps.
//  See notes for Ssync_ANSI_UNICODE_Struct_For_WOW() in dlgs.c.
//
////////////////////////////////////////////////////////////////////////////

VOID Ssync_ANSI_UNICODE_CF_For_WOW(
    HWND hDlg,
    BOOL f_ANSI_to_UNICODE)
{
    PFONTINFO pFI;

    if (pFI = (PFONTINFO)GetProp(hDlg, FONTPROP))
    {
        if (pFI->pCF && pFI->pCFA)
        {
            if (f_ANSI_to_UNICODE)
            {
                ThunkChooseFontA2W(pFI);
            }
            else
            {
                ThunkChooseFontW2A(pFI);
            }
        }
    }
}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\init.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    init.c

Abstract:

    This module contains the init routines for the Win32 common dialogs.

Revision History:

--*/



//
//  Include Files.
//

#include "comdlg32.h"
#include <shlobj.h>




//
//  External Declarations.
//

extern HDC hdcMemory;
extern HBITMAP hbmpOrigMemBmp;

extern CRITICAL_SECTION g_csLocal;
extern CRITICAL_SECTION g_csNetThread;
extern CRITICAL_SECTION g_csExtError;

// TLS index to get current dlg info for the current thread
extern DWORD g_tlsiCurDlg;   

// TLS index to get most recent ExtError for the current thread
extern DWORD g_tlsiExtError; 

extern HANDLE hMPR;
extern HANDLE hMPRUI;
extern HANDLE hLNDEvent;

extern DWORD dwNumDisks;
extern OFN_DISKINFO gaDiskInfo[MAX_DISKS];

extern DWORD cbNetEnumBuf;
extern LPTSTR gpcNetEnumBuf;

extern SIZE g_sizeDlg;

extern TCHAR g_szInitialCurDir[MAX_PATH];

extern BOOL g_bDisableMyDocs;
extern BOOL g_bMyDocsHidden;
extern TCHAR const szMyDocsReg[];
extern TCHAR const szMyDocsDisable[];
extern TCHAR const szMyDocsHidden[];

//
//  Global Variables.
//

WCHAR szmsgLBCHANGEW[]          = LBSELCHSTRINGW;
WCHAR szmsgSHAREVIOLATIONW[]    = SHAREVISTRINGW;
WCHAR szmsgFILEOKW[]            = FILEOKSTRINGW;
WCHAR szmsgCOLOROKW[]           = COLOROKSTRINGW;
WCHAR szmsgSETRGBW[]            = SETRGBSTRINGW;
WCHAR szCommdlgHelpW[]          = HELPMSGSTRINGW;

TCHAR szShellIDList[]           = CFSTR_SHELLIDLIST;

//
//  Private message for WOW to indicate 32-bit logfont
//  needs to be thunked back to 16-bit log font.
//
CHAR szmsgWOWLFCHANGE[]         = "WOWLFChange";

//
//  Private message for WOW to indicate 32-bit directory needs to be
//  thunked back to 16-bit task directory.
//
CHAR szmsgWOWDIRCHANGE[]        = "WOWDirChange";
CHAR szmsgWOWCHOOSEFONT_GETLOGFONT[]  = "WOWCHOOSEFONT_GETLOGFONT";

CHAR szmsgLBCHANGEA[]           = LBSELCHSTRINGA;
CHAR szmsgSHAREVIOLATIONA[]     = SHAREVISTRINGA;
CHAR szmsgFILEOKA[]             = FILEOKSTRINGA;
CHAR szmsgCOLOROKA[]            = COLOROKSTRINGA;
CHAR szmsgSETRGBA[]             = SETRGBSTRINGA;
CHAR szCommdlgHelpA[]           = HELPMSGSTRINGA;

UINT g_cfCIDA;





////////////////////////////////////////////////////////////////////////////
//
//  FInitColor
//
////////////////////////////////////////////////////////////////////////////

extern DWORD rgbClient;
extern HBITMAP hRainbowBitmap;

int FInitColor(
    HANDLE hInst)
{
    cyCaption = (short)GetSystemMetrics(SM_CYCAPTION);
    cyBorder = (short)GetSystemMetrics(SM_CYBORDER);
    cxBorder = (short)GetSystemMetrics(SM_CXBORDER);
    cyVScroll = (short)GetSystemMetrics(SM_CYVSCROLL);
    cxVScroll = (short)GetSystemMetrics(SM_CXVSCROLL);
    cxSize = (short)GetSystemMetrics(SM_CXSIZE);

    rgbClient = GetSysColor(COLOR_3DFACE);

    hRainbowBitmap = 0;

    return (TRUE);
    hInst;
}


////////////////////////////////////////////////////////////////////////////
//
//  FInitFile
//
////////////////////////////////////////////////////////////////////////////

BOOL FInitFile(
    HANDLE hins)
{
    bMouse = GetSystemMetrics(SM_MOUSEPRESENT);

    wWinVer = 0x0A0A;

    //
    //  Initialize these to reality.
    //
#if DPMICDROMCHECK
    wCDROMIndex = InitCDROMIndex((LPWORD)&wNumCDROMDrives);
#endif

    //
    // special WOW messages
    //
    msgWOWLFCHANGE       = RegisterWindowMessageA((LPSTR)szmsgWOWLFCHANGE);
    msgWOWDIRCHANGE      = RegisterWindowMessageA((LPSTR)szmsgWOWDIRCHANGE);
    msgWOWCHOOSEFONT_GETLOGFONT = RegisterWindowMessageA((LPSTR)szmsgWOWCHOOSEFONT_GETLOGFONT);

    msgLBCHANGEA         = RegisterWindowMessageA((LPSTR)szmsgLBCHANGEA);
    msgSHAREVIOLATIONA   = RegisterWindowMessageA((LPSTR)szmsgSHAREVIOLATIONA);
    msgFILEOKA           = RegisterWindowMessageA((LPSTR)szmsgFILEOKA);
    msgCOLOROKA          = RegisterWindowMessageA((LPSTR)szmsgCOLOROKA);
    msgSETRGBA           = RegisterWindowMessageA((LPSTR)szmsgSETRGBA);

#ifdef UNICODE
    msgLBCHANGEW         = RegisterWindowMessageW((LPWSTR)szmsgLBCHANGEW);
    msgSHAREVIOLATIONW   = RegisterWindowMessageW((LPWSTR)szmsgSHAREVIOLATIONW);
    msgFILEOKW           = RegisterWindowMessageW((LPWSTR)szmsgFILEOKW);
    msgCOLOROKW          = RegisterWindowMessageW((LPWSTR)szmsgCOLOROKW);
    msgSETRGBW           = RegisterWindowMessageW((LPWSTR)szmsgSETRGBW);
#else
    msgLBCHANGEW         = msgLBCHANGEA;
    msgSHAREVIOLATIONW   = msgSHAREVIOLATIONA;
    msgFILEOKW           = msgFILEOKA;
    msgCOLOROKW          = msgCOLOROKA;
    msgSETRGBW           = msgSETRGBA;
#endif

    g_cfCIDA             = RegisterClipboardFormat(szShellIDList);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  LibMain
//
//  Initializes any instance specific data needed by functions in the
//  common dialogs.
//
//  Returns:   TRUE    - success
//             FALSE   - failure
//
////////////////////////////////////////////////////////////////////////////

// ccover needs to link to C-runtime, so we rename LibMain to DllMain
#ifdef CCOVER 
#define LibMain DllMain
#endif

BOOL LibMain(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID lpRes)
{
    switch (dwReason)
    {
        case ( DLL_THREAD_ATTACH ) :
        case ( DLL_THREAD_DETACH ) :
        {
            //
            //  Threads can only enter and leave the comdlg32 dll from the
            //  Get{Open,Save}FileName apis, so the TLS lpCurDlg alloc is
            //  done inside the InitFileDlg routine in fileopen.c
            //
            return (TRUE);
            break;
        }
        case ( DLL_PROCESS_ATTACH ) :
        {
            HKEY hkey;

            g_hinst = (HANDLE)hModule;

            if (!FInitColor(g_hinst) || !FInitFile(g_hinst))
            {
                goto CantInit;
            }

            DisableThreadLibraryCalls(hModule);

            //
            //  msgHELP is sent whenever a help button is pressed in one of
            //  the common dialogs (provided an owner was declared and the
            //  call to RegisterWindowMessage doesn't fail).
            //
            msgHELPA = RegisterWindowMessageA((LPSTR)szCommdlgHelpA);
#ifdef UNICODE
            msgHELPW = RegisterWindowMessageW((LPWSTR)szCommdlgHelpW);
#else
            msgHELPW = msgHELPA;
#endif

            //
            //  Need a semaphore locally for managing array of disk info.
            //
            InitializeCriticalSection(&g_csLocal);

            //
            //  Need a semaphore for control access to CreateThread.
            //
            InitializeCriticalSection(&g_csNetThread);

            //
            //  Need a semaphore for access to extended error info.
            //
            InitializeCriticalSection(&g_csExtError);

            //
            //  Allocate a tls index for curdlg so we can make it per-thread.
            //
            if ((g_tlsiCurDlg = TlsAlloc()) != 0xFFFFFFFF)
            {
                // mark the list as empty
                TlsSetValue(g_tlsiCurDlg, (LPVOID) 0);
            }
            else
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto CantInit;
            }

            //
            //  Store the current directory on process attach.
            //
            GetCurrentDirectory(MAX_PATH, g_szInitialCurDir);

            //
            // Read registry to see if user wants to disable jumping
            // to My Documents in comdlg32.
            //
            if (RegOpenKey(HKEY_CURRENT_USER,
                           szMyDocsReg,
                           &hkey) == ERROR_SUCCESS)
            {
                DWORD dwSize;

                if (RegQueryValueEx(hkey,
                                    szMyDocsDisable,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &dwSize) == ERROR_SUCCESS)
                {
                    g_bDisableMyDocs = TRUE;
                }
                else
                {
                    g_bDisableMyDocs = FALSE;
                }


                if (RegQueryValueEx(hkey,
                                    szMyDocsHidden,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &dwSize) == ERROR_SUCCESS)
                {
                    g_bMyDocsHidden = TRUE;
                }
                else
                {
                    g_bMyDocsHidden = FALSE;
                }


                RegCloseKey( hkey );
            }

            //
            //  Allocate a tls index for extended error.
            //
            if ((g_tlsiExtError = TlsAlloc()) == 0xFFFFFFFF)
            {
                StoreExtendedError(CDERR_INITIALIZATION);
                goto CantInit;
            }

            dwNumDisks = 0;
            gpcNetEnumBuf = NULL;

            //
            //  NetEnumBuf allocated in ListNetDrivesHandler.
            //
            cbNetEnumBuf = WNETENUM_BUFFSIZE;

            hMPR = NULL;
            hMPRUI = NULL;

            hLNDEvent = NULL;

            //
            //  For file open dialog.
            //
            g_sizeDlg.cx = 0;
            g_sizeDlg.cy = 0;

            return (TRUE);
            break;
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            //
            //  We only want to do our clean up work if we are being called
            //  with freelibrary, not if the process is ending.
            //
            if (lpRes == NULL)
            {
                TermFile();
                TermPrint();
                TermColor();
                TermFont();

                TlsFree(g_tlsiCurDlg);
                TlsFree(g_tlsiExtError);

                DeleteCriticalSection(&g_csLocal);
                DeleteCriticalSection(&g_csNetThread);
                DeleteCriticalSection(&g_csExtError);
            }

            return (TRUE);
            break;
        }
    }

CantInit:
    return (FALSE);
    lpRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\font.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    font.h

Abstract:

    This module contains the header information for the Win32 font dialogs.

Revision History:

--*/



//
//  Include Files.
//

#include <help.h>

#ifdef  MM_DESIGNVECTOR_DEFINED

// new flag that for NT 5.0/IE 5.0 is used for testing purpose only
#define CF_MM_DESIGNVECTOR             0x02000000L

#if (_WIN32_WINNT < 0x0500)
//
// new NT 5.0 definitions related to MultipleMaster desing vector, from WinGdi.h
//
#define STAMP_DESIGNVECTOR  (0x8000000 + 'd' + ('v' << 8))
#define STAMP_AXESLIST      (0x8000000 + 'a' + ('l' << 8))
#define MM_MAX_NUMAXES      16



typedef struct tagDESIGNVECTOR
{
    DWORD  dvReserved;
    DWORD  dvNumAxes;
    LONG   dvValues[MM_MAX_NUMAXES];
} DESIGNVECTOR, *PDESIGNVECTOR, FAR *LPDESIGNVECTOR;

typedef struct tagENUMLOGFONTEXDVA
{
    ENUMLOGFONTEXA elfEnumLogfontEx;
    DESIGNVECTOR   elfDesignVector;
} ENUMLOGFONTEXDVA, *PENUMLOGFONTEXDVA, FAR *LPENUMLOGFONTEXDVA;
typedef struct tagENUMLOGFONTEXDVW
{
    ENUMLOGFONTEXW elfEnumLogfontEx;
    DESIGNVECTOR   elfDesignVector;
} ENUMLOGFONTEXDVW, *PENUMLOGFONTEXDVW, FAR *LPENUMLOGFONTEXDVW;
#ifdef UNICODE
typedef ENUMLOGFONTEXDVW ENUMLOGFONTEXDV;
typedef PENUMLOGFONTEXDVW PENUMLOGFONTEXDV;
typedef LPENUMLOGFONTEXDVW LPENUMLOGFONTEXDV;
#else
typedef ENUMLOGFONTEXDVA ENUMLOGFONTEXDV;
typedef PENUMLOGFONTEXDVA PENUMLOGFONTEXDV;
typedef LPENUMLOGFONTEXDVA LPENUMLOGFONTEXDV;
#endif // UNICODE


#define MM_MAX_AXES_NAMELEN 16

typedef struct tagAXISINFOA
{
    LONG   axMinValue;
    LONG   axMaxValue;
    BYTE   axAxisName[MM_MAX_AXES_NAMELEN];
} AXISINFOA, *PAXISINFOA, FAR *LPAXISINFOA;
typedef struct tagAXISINFOW
{
    LONG   axMinValue;
    LONG   axMaxValue;
    WCHAR  axAxisName[MM_MAX_AXES_NAMELEN];
} AXISINFOW, *PAXISINFOW, FAR *LPAXISINFOW;
#ifdef UNICODE
typedef AXISINFOW AXISINFO;
typedef PAXISINFOW PAXISINFO;
typedef LPAXISINFOW LPAXISINFO;
#else
typedef AXISINFOA AXISINFO;
typedef PAXISINFOA PAXISINFO;
typedef LPAXISINFOA LPAXISINFO;
#endif // UNICODE

typedef struct tagAXESLISTA
{
    DWORD     axlReserved;
    DWORD     axlNumAxes;
    AXISINFOA axlAxisInfo[MM_MAX_NUMAXES];
} AXESLISTA, *PAXESLISTA, FAR *LPAXESLISTA;
typedef struct tagAXESLISTW
{
    DWORD     axlReserved;
    DWORD     axlNumAxes;
    AXISINFOW axlAxisInfo[MM_MAX_NUMAXES];
} AXESLISTW, *PAXESLISTW, FAR *LPAXESLISTW;
#ifdef UNICODE
typedef AXESLISTW AXESLIST;
typedef PAXESLISTW PAXESLIST;
typedef LPAXESLISTW LPAXESLIST;
#else
typedef AXESLISTA AXESLIST;
typedef PAXESLISTA PAXESLIST;
typedef LPAXESLISTA LPAXESLIST;
#endif // UNICODE

typedef struct tagENUMTEXTMETRICA
{
    NEWTEXTMETRICEXA etmNewTextMetricEx;
    AXESLISTA        etmAxesList;
} ENUMTEXTMETRICA, *PENUMTEXTMETRICA, FAR *LPENUMTEXTMETRICA;
typedef struct tagENUMTEXTMETRICW
{
    NEWTEXTMETRICEXW etmNewTextMetricEx;
    AXESLISTW        etmAxesList;
} ENUMTEXTMETRICW, *PENUMTEXTMETRICW, FAR *LPENUMTEXTMETRICW;

#ifdef UNICODE
typedef ENUMTEXTMETRICW ENUMTEXTMETRIC;
typedef PENUMTEXTMETRICW PENUMTEXTMETRIC;
typedef LPENUMTEXTMETRICW LPENUMTEXTMETRIC;
#else
typedef ENUMTEXTMETRICA ENUMTEXTMETRIC;
typedef PENUMTEXTMETRICA PENUMTEXTMETRIC;
typedef LPENUMTEXTMETRICA LPENUMTEXTMETRIC;
#endif // UNICODE

#endif // (_WIN32_WINNT < 0x0500)
#endif //  MM_DESIGNVECTOR_DEFINED

//
//  Constant Declarations.
//

// Finnish needs 17 chars (18 w/ NULL) -- let's give them 20.
#define CCHCOLORNAMEMAX      20        // max length of color name text
#define CCHCOLORS            16        // max # of pure colors in color combo

#define POINTS_PER_INCH      72
#define FFMASK               0xf0      // pitch and family mask
#define CCHSTDSTRING         12        // max length of sample text string

#define FONTPROP   (LPCTSTR) 0xA000L

#define CBN_MYEDITUPDATE     (WM_USER + 501)
#define KEY_FONT_SUBS TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes")

#define DEF_POINT_SIZE       10

#define DX_BITMAP            20
#define DY_BITMAP            12

#define FONT_INVALID_CHARSET 0x100




//
//  Typedef Declarations.
//

#ifdef  MM_DESIGNVECTOR_DEFINED
// CreateFontIndirectEx
typedef HFONT (WINAPI *PFNCREATEFONTINDIRECTEX)( IN CONST ENUMLOGFONTEXDV *);
#endif //  MM_DESIGNVECTOR_DEFINED

typedef struct {
    UINT            ApiType;
    LPCHOOSEFONT    pCF;
    UINT            iCharset;
    RECT            rcText;
    DWORD           nLastFontType;
    DWORD           ProcessVersion;

#ifdef  MM_DESIGNVECTOR_DEFINED
    PFNCREATEFONTINDIRECTEX pfnCreateFontIndirectEx;
    DESIGNVECTOR   DefaultDesignVector;
#endif //  MM_DESIGNVECTOR_DEFINED

#ifdef UNICODE
    LPCHOOSEFONTA   pCFA;
    PUNICODE_STRING pusStyle;
    PANSI_STRING    pasStyle;
#endif
} FONTINFO;

typedef FONTINFO *PFONTINFO;


typedef struct {
    HWND hwndFamily;
    HWND hwndStyle;
    HWND hwndSizes;
    HWND hwndScript;
    UINT iCharset;                // returned for enumerating scripts
    UINT cfdCharset;              // ChooseFontData charset passed in here
    HDC hDC;
    DWORD dwFlags;
    DWORD nFontType;
    BOOL bFillSize;
    BOOL bPrinterFont;
    LPCHOOSEFONT lpcf;
#ifdef  MM_DESIGNVECTOR_DEFINED
    HWND hwndParent;             // to extend the dialog for MM
    PDESIGNVECTOR   pDefaultDesignVector;
#endif //  MM_DESIGNVECTOR_DEFINED
} ENUM_FONT_DATA, *LPENUM_FONT_DATA;


typedef struct _ITEMDATA {
    PLOGFONT pLogFont;
    DWORD nFontType;
} ITEMDATA, *LPITEMDATA;


//
//  Chinese font numbers (zihao).
//
typedef struct {
    TCHAR name[5];
    int size;
    int sizeFr;
} ZIHAO;

#define NUM_ZIHAO  16

#ifdef UNICODE

ZIHAO stZihao[NUM_ZIHAO] =
{
    { L"\x516b\x53f7",  5, 0 }, { L"\x4e03\x53f7",  5, 5 },
    { L"\x5c0f\x516d",  6, 5 }, { L"\x516d\x53f7",  7, 5 },
    { L"\x5c0f\x4e94",  9, 0 }, { L"\x4e94\x53f7", 10, 5 },
    { L"\x5c0f\x56db", 12, 0 }, { L"\x56db\x53f7", 14, 0 },
    { L"\x5c0f\x4e09", 15, 0 }, { L"\x4e09\x53f7", 16, 0 },
    { L"\x5c0f\x4e8c", 18, 0 }, { L"\x4e8c\x53f7", 22, 0 },
    { L"\x5c0f\x4e00", 24, 0 }, { L"\x4e00\x53f7", 26, 0 },
    { L"\x5c0f\x521d", 36, 0 }, { L"\x521d\x53f7", 42, 0 }
};

#else

ZIHAO stZihao[NUM_ZIHAO] =
{
    { "\xb0\xcb\xba\xc5",  5, 0 }, { "\xc6\xdf\xba\xc5",  5, 5 },
    { "\xd0\xa1\xc1\xf9",  6, 5 }, { "\xc1\xf9\xba\xc5",  7, 5 },
    { "\xd0\xa1\xce\xe5",  9, 0 }, { "\xce\xe5\xba\xc5", 10, 5 },
    { "\xd0\xa1\xcb\xc4", 12, 0 }, { "\xcb\xc4\xba\xc5", 14, 0 },
    { "\xd0\xa1\xc8\xfd", 15, 0 }, { "\xc8\xfd\xba\xc5", 16, 0 },
    { "\xd0\xa1\xb6\xfe", 18, 0 }, { "\xb6\xfe\xba\xc5", 22, 0 },
    { "\xd0\xa1\xd2\xbb", 24, 0 }, { "\xd2\xbb\xba\xc5", 26, 0 },
    { "\xd0\xa1\xb3\xf5", 36, 0 }, { "\xb3\xf5\xba\xc5", 42, 0 }
};

#endif

#define IS_SIMPLIFIED_CHINESE(lang)                                         \
    (((lang) == (MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED))) ||  \
     ((lang) == (MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_HONGKONG)))   ||  \
     ((lang) == (MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SINGAPORE)))  ||  \
     ((lang) == (MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_MACAU))))




//
//  Global Variables.
//

UINT msgWOWLFCHANGE;
UINT msgWOWCHOOSEFONT_GETLOGFONT;

//
//  Color tables for color combo box.
//  Order of values must match names in sz.src.
//
DWORD rgbColors[CCHCOLORS] =
{
        RGB(  0,   0, 0),       // Black
        RGB(128,   0, 0),       // Dark red
        RGB(  0, 128, 0),       // Dark green
        RGB(128, 128, 0),       // Dark yellow
        RGB(  0,   0, 128),     // Dark blue
        RGB(128,   0, 128),     // Dark purple
        RGB(  0, 128, 128),     // Dark aqua
        RGB(128, 128, 128),     // Dark grey
        RGB(192, 192, 192),     // Light grey
        RGB(255,   0, 0),       // Light red
        RGB(  0, 255, 0),       // Light green
        RGB(255, 255, 0),       // Light yellow
        RGB(  0,   0, 255),     // Light blue
        RGB(255,   0, 255),     // Light purple
        RGB(  0, 255, 255),     // Light aqua
        RGB(255, 255, 255),     // White
};

HBITMAP hbmFont = NULL;
HFONT hDlgFont = NULL;

UINT DefaultCharset;

TCHAR szRegular[CCHSTYLE];
TCHAR szBold[CCHSTYLE];
TCHAR szItalic[CCHSTYLE];
TCHAR szBoldItalic[CCHSTYLE];

TCHAR szPtFormat[] = TEXT("%d");

TCHAR c_szRegular[]    = TEXT("Regular");
TCHAR c_szBold[]       = TEXT("Bold");
TCHAR c_szItalic[]     = TEXT("Italic");
TCHAR c_szBoldItalic[] = TEXT("Bold Italic");

LPCFHOOKPROC glpfnFontHook = 0;

LANGID UserLangID = 0;




//
//  Context Help IDs.
//

const static DWORD aFontHelpIDs[] =              // Context Help IDs
{
    stc1,    IDH_FONT_FONT,
    cmb1,    IDH_FONT_FONT,
    stc2,    IDH_FONT_STYLE,
    cmb2,    IDH_FONT_STYLE,
    stc3,    IDH_FONT_SIZE,
    cmb3,    IDH_FONT_SIZE,
    psh3,    IDH_COMM_APPLYNOW,
    grp1,    IDH_FONT_EFFECTS,
    chx1,    IDH_FONT_EFFECTS,
    chx2,    IDH_FONT_EFFECTS,
    stc4,    IDH_FONT_COLOR,
    cmb4,    IDH_FONT_COLOR,
    grp2,    IDH_FONT_SAMPLE,
    stc5,    IDH_FONT_SAMPLE,
    stc6,    NO_HELP,
    stc7,    IDH_FONT_SCRIPT,
    cmb5,    IDH_FONT_SCRIPT,

    0, 0
};

//
//  Function Prototypes.
//

#ifdef  MM_DESIGNVECTOR_DEFINED
/* flag used for ChooseFontExA, ChooseFontExW and ChooseFontX : */
   
#define CHF_DESIGNVECTOR  0x0001
/* give the MM result into DESIGNVECTOR,
   default is to convert the axis into the name for backwards compatibility */


/* ChooseFontExA and ChooseFontExW must be called with lpLogFont of size ENUMLOGFONTEXDV */
BOOL APIENTRY ChooseFontExA(LPCHOOSEFONTA, DWORD fl);
BOOL APIENTRY ChooseFontExW(LPCHOOSEFONTW, DWORD fl);
#ifdef UNICODE
#define ChooseFontEx  ChooseFontExW
#else
#define ChooseFontEx  ChooseFontExA
#endif // !UNICODE

#endif //  MM_DESIGNVECTOR_DEFINED

BOOL
ChooseFontX(
#ifdef  MM_DESIGNVECTOR_DEFINED
    PFONTINFO pFI, DWORD fl);
#else
    PFONTINFO pFI);
#endif //  MM_DESIGNVECTOR_DEFINED

VOID
SetStyleSelection(
    HWND hDlg,
    LPCHOOSEFONT lpcf,
    BOOL bInit);

#ifdef MM_DESIGNVECTOR_DEFINED
VOID 
SetMMAxesSelection(
    HWND hDlg,
    LPCHOOSEFONT lpcf);
#endif // MM_DESIGNVECTOR_DEFINED

VOID
HideDlgItem(
    HWND hDlg,
    int id);

VOID
FixComboHeights(
    HWND hDlg);

BOOL_PTR CALLBACK
FormatCharDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam);

void
SelectStyleFromLF(
    HWND hwnd,
    LPLOGFONT lplf);

int
CBSetTextFromSel(
    HWND hwnd);

int
CBSetSelFromText(
    HWND hwnd,
    LPTSTR lpszString);

int
CBGetTextAndData(
    HWND hwnd,
    LPTSTR lpszString,
    int iSize,
    PULONG_PTR lpdw);

int
CBFindString(
    HWND hwnd,
    LPTSTR lpszString);

BOOL
GetPointSizeInRange(
    HWND hDlg,
    LPCHOOSEFONT lpcf,
    LPINT pts,
    WORD wFlags);

BOOL
ResetSampleFromScript(
    HWND hdlg,
    HWND hwndScript,
    PFONTINFO pFI);

BOOL
ProcessDlgCtrlCommand(
    HWND hDlg,
    PFONTINFO pFI,
    WPARAM wParam,
    LPARAM lParam);

int
CmpFontType(
    DWORD ft1,
    DWORD ft2);

int
FontFamilyEnumProc(
    LPENUMLOGFONTEX lplf,
    LPNEWTEXTMETRIC lptm,
    DWORD nFontType,
    LPENUM_FONT_DATA lpData);

BOOL
GetFontFamily(
    HWND hDlg,
    HDC hDC,
    DWORD dwEnumCode,
    UINT iCharset);

VOID
CBAddSize(
    HWND hwnd,
    int pts,
    LPCHOOSEFONT lpcf);

int
InsertStyleSorted(
    HWND hwnd,
    LPTSTR lpszStyle,
    LPLOGFONT lplf);

PLOGFONT
CBAddStyle(
    HWND hwnd,
    LPTSTR lpszStyle,
    DWORD nFontType,
    LPLOGFONT lplf);

int
CBAddScript(
    HWND hwnd,
    LPTSTR lpszScript,
    UINT iCharset);

VOID
FillInMissingStyles(
    HWND hwnd);

VOID
FillScalableSizes(
    HWND hwnd,
    LPCHOOSEFONT lpcf);

int
FontStyleEnumProc(
    LPENUMLOGFONTEX lplf,
    LPNEWTEXTMETRIC lptm,
    DWORD nFontType,
    LPENUM_FONT_DATA lpData);

VOID
FreeFonts(
    HWND hwnd);

VOID
FreeAllItemData(
    HWND hDlg,
    PFONTINFO pFI);

VOID
InitLF(
    LPLOGFONT lplf);

#ifdef MM_DESIGNVECTOR_DEFINED
int
FontMMAxesEnumProc(
    LPENUMLOGFONTEXDV lplf,
    LPENUMTEXTMETRIC lpetm,
    DWORD nFontType,
    LPENUM_FONT_DATA lpData);
#endif // MM_DESIGNVECTOR_DEFINED

int
FontScriptEnumProc(
    LPENUMLOGFONTEX lplf,
    LPNEWTEXTMETRIC lptm,
    DWORD nFontType,
    LPENUM_FONT_DATA lpData);


BOOL
GetFontStylesAndSizes(
    HWND hDlg,
    PFONTINFO pFI,
    LPCHOOSEFONT lpcf,
    BOOL bForceSizeFill);

VOID
FillColorCombo(
    HWND hDlg);

BOOL
DrawSizeComboItem(
    LPDRAWITEMSTRUCT lpdis);

BOOL
DrawFamilyComboItem(
    LPDRAWITEMSTRUCT lpdis);

BOOL
DrawColorComboItem(
    LPDRAWITEMSTRUCT lpdis);

VOID
DrawSampleText(
    HWND hDlg,
    PFONTINFO pFI,
    LPCHOOSEFONT lpcf,
    HDC hDC);

BOOL
FillInFont(
    HWND hDlg,
    PFONTINFO pFI,
    LPCHOOSEFONT lpcf,
    LPLOGFONT lplf,
    BOOL bSetBits);

#ifdef MM_DESIGNVECTOR_DEFINED
BOOL
FillInFontEx(
    HWND hDlg,
    PFONTINFO pFI,
    LPCHOOSEFONT lpcf,
    LPENUMLOGFONTEXDV lplf,
    BOOL bSetBits);

BOOL
SetLogFontEx(
    HWND hDlg,
    LPCHOOSEFONT lpcf,
    LPENUMLOGFONTEXDV lplf);

#endif // MM_DESIGNVECTOR_DEFINED

BOOL
SetLogFont(
    HWND hDlg,
    LPCHOOSEFONT lpcf,
    LPLOGFONT lplf);

VOID
TermFont();

int
GetPointString(
    LPTSTR buf,
    HDC hDC,
    int height);

DWORD
FlipColor(
    DWORD rgb);

HBITMAP
LoadBitmaps(
    int id);

BOOL
LookUpFontSubs(
    LPTSTR lpSubFontName,
    LPTSTR lpRealFontName);

BOOL GetUnicodeSampleText(HDC hdc, LPTSTR lpString, int nMaxCount);

#ifdef UNICODE
  BOOL
  ThunkChooseFontA2W(
      PFONTINFO pFI);

  BOOL
  ThunkChooseFontW2A(
      PFONTINFO pFI);

#ifdef MM_DESIGNVECTOR_DEFINED
  VOID
  ThunkEnumLogFontExDvA2W(
      LPENUMLOGFONTEXDVA lpLFA,
      LPENUMLOGFONTEXDVW lpLFW);

  VOID
  ThunkEnumLogFontExDvW2A(
      LPENUMLOGFONTEXDVW lpLFW,
      LPENUMLOGFONTEXDVA lpLFA);
#endif // MM_DESIGNVECTOR_DEFINED

  VOID
  ThunkLogFontA2W(
      LPLOGFONTA lpLFA,
      LPLOGFONTW lpLFW);

  VOID
  ThunkLogFontW2A(
      LPLOGFONTW lpLFW,
      LPLOGFONTA lpLFA);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\parse.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    parse.c

Abstract:

    This module contains the parse routines for the Win32 common dialogs.

Revision History:

--*/



//
//  Include Files.
//

#include "comdlg32.h"
#include <shellapi.h>
#include <shlobj.h>
#include <shsemip.h>
#include "fileopen.h"



//
//  Global Variables.
//
extern TCHAR szCaption[];
extern TCHAR szWarning[];




////////////////////////////////////////////////////////////////////////////
//
//  ParseFileNew
//
//  On the return, pnExtOffset is the offset to the dot.
//
////////////////////////////////////////////////////////////////////////////

int ParseFileNew(
    LPTSTR pszPath,
    int *pnExtOffset,
    BOOL bWowApp,
    BOOL bNewStyle)
{
    int lRet = ParseFile(pszPath, TRUE, bWowApp, bNewStyle);

    if (pnExtOffset)
    {
        int nExt;

        nExt = (int)(SHORT)HIWORD(lRet);
        *pnExtOffset = ((nExt) && *(pszPath + nExt)) ? nExt : 0;
    }

    return ((int)(SHORT)LOWORD(lRet));
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseFileOld
//
//  On return, pnExtOffset is the offset to the the dot and
//  pnOldExt is the offset to the character following the dot.
//
////////////////////////////////////////////////////////////////////////////

int ParseFileOld(
    LPTSTR pszPath,
    int *pnExtOffset,
    int *pnOldExt,
    BOOL bWowApp,
    BOOL bNewStyle)
{
    int lRet = ParseFile(pszPath, TRUE, bWowApp, bNewStyle);

    int nExt = (int)(SHORT)HIWORD(lRet);
    *pnExtOffset = nExt;
    *pnOldExt = ((nExt) && *(pszPath + nExt)) ? nExt + 1 : 0;

    return ((int)(SHORT)LOWORD(lRet));
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseFile
//
//  Determines if the filename is a legal dos name.
//
//  Circumstances checked:
//      1) Valid as directory name, but not as file name
//      2) Empty String
//      3) Illegal Drive label
//      4) Period in invalid location (in extension, 1st in file name)
//      5) Missing directory character
//      6) Illegal character
//      7) Wildcard in directory name
//      8) Double slash beyond 1st 2 characters
//      9) Space character in the middle of the name (trailing spaces OK)
//         -->> no longer applies : spaces are allowed in LFN
//      10) Filename greater than 8 characters : NOT APPLICABLE TO LONG FILE NAMES
//      11) Extension greater than 3 characters: NOT APPLICABLE TO LONG FILE NAMES
//
//  lpstrFileName - ptr to a single file name
//
//  Returns:
//      LONG - LOWORD = char offset to filename,
//             HIWORD = char offset to extension (dot),
//      LONG - LOWORD is error code (<0), HIWORD is approx. place of problem
//
////////////////////////////////////////////////////////////////////////////

DWORD ParseFile(
    LPTSTR lpstrFileName,
    BOOL bLFNFileSystem,
    BOOL bWowApp,
    BOOL bNewStyle)
{
    SHORT nFile, nExt, nFileOffset, nExtOffset = 0;
    BOOL bExt;
    BOOL bWildcard;
    SHORT nNetwork = 0;
    BOOL bUNCPath = FALSE;
    LPTSTR lpstr = lpstrFileName;

    if (!*lpstr)
    {
        nFileOffset = PARSE_EMPTYSTRING;
        goto ParseFile_Failure;
    }

    if (*(lpstr + 1) == CHAR_COLON)
    {
        TCHAR cDrive = (TCHAR)CharLower((LPTSTR)(DWORD)*lpstr);

        //
        //  Test to see if the drive is legal.
        //
        //  Note: Does not test that drive exists.
        //
        if ((cDrive < CHAR_A) || (cDrive > CHAR_Z))
        {
            nFileOffset = PARSE_INVALIDDRIVE;
            goto ParseFile_Failure;
        }
        lpstr = CharNext(CharNext(lpstr));
    }

    if ((*lpstr == CHAR_BSLASH) || (*lpstr == CHAR_SLASH && !bNewStyle))
    {
        //
        //  Cannot have "c:\."
        //
        if (*++lpstr == CHAR_DOT)
        {
            //
            // 
            //
            if ((*++lpstr != CHAR_BSLASH) && (*lpstr != CHAR_SLASH || bNewStyle))
            {
                //
                //  It's the root directory.
                //
                if (!*lpstr)
                {
                    goto MustBeDir;
                }
                else
                {
                    lpstr--;
                }
            }
            else
            {
                //
                //  It's saying top dir (once again), thus allowed.
                //
                ++lpstr;
            }
        }
        else if ((*lpstr == CHAR_BSLASH) && (*(lpstr - 1) == CHAR_BSLASH))
        {
            //
            //  It seems that for a full network path, whether a drive is
            //  declared or not is insignificant, though if a drive is given,
            //  it must be valid (hence the code above should remain there).
            //

            //
            //  ...since it's the first slash, 2 are allowed.
            //
            ++lpstr;

            //
            //  Must receive server and share to be real.
            //
            nNetwork = -1;

            //
            //  No wildcards allowed if UNC name.
            //
            bUNCPath = TRUE;
        }
        else if (*lpstr == CHAR_SLASH && !bNewStyle)
        {
            nFileOffset = PARSE_INVALIDDIRCHAR;
            goto ParseFile_Failure;
        }
    }
    else if (*lpstr == CHAR_DOT)
    {
        //
        //  Up one directory.
        //
        if (*++lpstr == CHAR_DOT)
        {
            ++lpstr;
        }

        if (!*lpstr)
        {
            goto MustBeDir;
        }
        if ((*lpstr != CHAR_BSLASH) && (*lpstr != CHAR_SLASH || bNewStyle))
        {
            //
            //  Jumping to Failure here will skip the parsing that causes
            //  ".xxx.txt" to return with nFileOffset = 2.
            //
            nFileOffset = 0;
            goto ParseFile_Failure;
        }
        else
        {
            //
            //  Allow directory.
            //
            ++lpstr;
        }
    }

    if (!*lpstr)
    {
        goto MustBeDir;
    }

    //
    //  Should point to first char in filename by now.
    //
    nFileOffset = nExtOffset = nFile = nExt = 0;
    bWildcard = bExt = FALSE;
    while (*lpstr)
    {
        //
        //  Anything below the "Space" character is invalid.
        //
#ifdef UNICODE
        if (*lpstr < CHAR_SPACE)
#else
        if (((UCHAR)*lpstr) < CHAR_SPACE)
#endif
        {
            nFileOffset = PARSE_INVALIDCHAR;
            goto ParseFile_Failure;
        }
        switch (*lpstr)
        {
            case ( CHAR_COLON ) :
            case ( CHAR_BAR ) :
            case ( CHAR_LTHAN ) :
            case ( CHAR_QUOTE ) :
            {
                //
                //  Invalid characters for all file systems.
                //
                nFileOffset = PARSE_INVALIDCHAR;
                goto ParseFile_Failure;
            }
            case ( CHAR_SEMICOLON ) :
            case ( CHAR_COMMA ) :
            case ( CHAR_PLUS ) :
            case ( CHAR_LBRACKET ) :
            case ( CHAR_RBRACKET ) :
            case ( CHAR_EQUAL ) :
            {
                if (!bLFNFileSystem)
                {
                    nFileOffset = PARSE_INVALIDCHAR;
                    goto ParseFile_Failure;
                }
                else
                {
                    goto RegularCharacter;
                }
            }
            case ( CHAR_SLASH ) :
            {
                if (bNewStyle)
                {
                    nFileOffset = PARSE_INVALIDCHAR;
                    goto ParseFile_Failure;
                }

                // fall thru...
            }
            case ( CHAR_BSLASH ) :
            {
                //
                //  Subdir indicators.
                //
                nNetwork++;
                if (bWildcard)
                {
                    nFileOffset = PARSE_WILDCARDINDIR;
                    goto ParseFile_Failure;
                }

                //
                //  Can't have two in a row.
                //
                if (nFile == 0)
                {
                    nFileOffset = PARSE_INVALIDDIRCHAR;
                    goto ParseFile_Failure;
                }
                else
                {
                    //
                    //  Reset flags.
                    //
                    ++lpstr;
                    if (!nNetwork && !*lpstr)
                    {
                        nFileOffset = PARSE_INVALIDNETPATH;
                        goto ParseFile_Failure;
                    }
                    nFile = nExt = 0;
                    nExtOffset = 0;
                    bExt = FALSE;
                }
                break;
            }
            case ( CHAR_SPACE ) :
            {
                LPTSTR lpSpace = lpstr;

                if (bLFNFileSystem)
                {
                    goto RegularCharacter;
                }

                *lpSpace = CHAR_NULL;
                while (*++lpSpace)
                {
                    if (*lpSpace != CHAR_SPACE)
                    {
                        *lpstr = CHAR_SPACE;
                        nFileOffset = PARSE_INVALIDSPACE;
                        goto ParseFile_Failure;
                    }
                }

                break;
            }
            case ( CHAR_DOT ) :
            {
                if (bNewStyle)
                {
                    nExtOffset = (SHORT)(lpstr - lpstrFileName);
                    goto RegularCharacter;
                }
                if (nFile == 0)
                {
                    nFileOffset = (SHORT)(lpstr - lpstrFileName);
                    if (*++lpstr == CHAR_DOT)
                    {
                        ++lpstr;
                    }
                    if (!*lpstr)
                    {
                        goto MustBeDir;
                    }

                    //
                    //  Flags already set.
                    //
                    nFile++;
                    ++lpstr;
                }
                else
                {
                    nExtOffset = 0;
                    ++lpstr;
                    bExt = TRUE;
                }
                break;
            }
            case ( CHAR_STAR ) :
            case ( CHAR_QMARK ) :
            {
                bWildcard = TRUE;

                //  Fall thru...
            }
            default :
            {
RegularCharacter:
                if (bExt)
                {
                    if (++nExt == 1)
                    {
                        nExtOffset = (SHORT)(lpstr - lpstrFileName);
                    }
                }
                else if (++nFile == 1)
                {
                    nFileOffset = (SHORT)(lpstr - lpstrFileName);
                }

                lpstr = CharNext(lpstr);
                break;
            }
        }
    }

    if (nNetwork == -1)
    {
        nFileOffset = PARSE_INVALIDNETPATH;
        goto ParseFile_Failure;
    }
    else if (bUNCPath)
    {
        if (!nNetwork)
        {
            //
            //  Server and share only.
            //
            *lpstr = CHAR_NULL;
            nFileOffset = PARSE_DIRECTORYNAME;
            goto ParseFile_Failure;
        }
        else if ((nNetwork == 1) && !nFile)
        {
            //
            //  Server and share root.
            //
            *lpstr = CHAR_NULL;
            nFileOffset = PARSE_DIRECTORYNAME;
            goto ParseFile_Failure;
        }
    }

    if (!nFile)
    {
MustBeDir:
        nFileOffset = PARSE_DIRECTORYNAME;
        goto ParseFile_Failure;
    }

    //
    //  If true, no ext. wanted.
    //
    if (!bNewStyle)
    {
        if ((bWowApp) &&
            (*(lpstr - 1) == CHAR_DOT) &&
            (*CharNext(lpstr - 2) == CHAR_DOT))
        {
            //
            //  Remove terminating period.
            //
            *(lpstr - 1) = CHAR_NULL;
        }
        else if (!nExt)
        {
ParseFile_Failure:
            //
            //  Need to recheck bNewStyle since we can jump here.
            //
            if (!bNewStyle)
            {
                nExtOffset = (SHORT)(lpstr - lpstrFileName);
            }
        }
    }

    return (MAKELONG(nFileOffset, nExtOffset));
}


////////////////////////////////////////////////////////////////////////////
//
//  PathRemoveBslash
//
//  Removes a trailing backslash from the given path.
//
//  Returns:
//      Pointer to NULL that replaced the backslash   OR
//      Pointer to the last character if it isn't a backslash
//
////////////////////////////////////////////////////////////////////////////

LPTSTR PathRemoveBslash(
    LPTSTR lpszPath)
{
    int len = lstrlen(lpszPath) - 1;

#ifndef UNICODE
    if (IsDBCSLeadByte(*CharPrev(lpszPath, lpszPath + len + 1)))
    {
        len--;
    }
#endif

    if (!PathIsRoot(lpszPath) && (lpszPath[len] == CHAR_BSLASH))
    {
        lpszPath[len] = CHAR_NULL;
    }

    return (lpszPath + len);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsWild
//
////////////////////////////////////////////////////////////////////////////

BOOL IsWild(
    LPTSTR lpsz)
{
    return (StrChr(lpsz, CHAR_STAR) || StrChr(lpsz, CHAR_QMARK));
}


////////////////////////////////////////////////////////////////////////////
//
//  AppendExt
//
//  Appends default extension onto path name.
//  It assumes the current path name doesn't already have an extension.
//  lpExtension does not need to be null terminated.
//
////////////////////////////////////////////////////////////////////////////

VOID AppendExt(
    LPTSTR lpszPath,
    LPCTSTR lpExtension,
    BOOL bWildcard)
{
    WORD wOffset;
    SHORT i;
    TCHAR szExt[MAX_PATH + 1];

    if (lpExtension && *lpExtension)
    {
        wOffset = (WORD)lstrlen(lpszPath);
        if (bWildcard)
        {
            *(lpszPath + wOffset++) = CHAR_STAR;
        }

        //
        //  Add a period.
        //
        *(lpszPath + wOffset++) = CHAR_DOT;
        for (i = 0; *(lpExtension + i) && i < MAX_PATH; i++)
        {
            szExt[i] = *(lpExtension + i);
        }
        szExt[i] = 0;

        //
        //  Remove leading / trailing blanks in the extension.
        //
        PathRemoveBlanks(szExt);

        //
        //  Add the rest.
        //
        lstrcpy(lpszPath + wOffset, szExt);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  IsUNC
//
//  Determines if the given path is a UNC path.
//
//  Returns:
//      TRUE    if path starts with "\\" or "X:\\"
//      FALSE   otherwise
//
////////////////////////////////////////////////////////////////////////////

BOOL IsUNC(
    LPCTSTR lpszPath)
{
    return ( DBL_BSLASH(lpszPath) ||
             ((lpszPath[1] == CHAR_COLON) && DBL_BSLASH(lpszPath + 2)) );
}


////////////////////////////////////////////////////////////////////////////
//
//  PortName
//
////////////////////////////////////////////////////////////////////////////

#define PORTARRAY 14

BOOL PortName(
    LPTSTR lpszFileName)
{
    static TCHAR *szPorts[PORTARRAY] = { TEXT("LPT1"),
                                         TEXT("LPT2"),
                                         TEXT("LPT3"),
                                         TEXT("LPT4"),
                                         TEXT("COM1"),
                                         TEXT("COM2"),
                                         TEXT("COM3"),
                                         TEXT("COM4"),
                                         TEXT("EPT"),
                                         TEXT("NUL"),
                                         TEXT("PRN"),
                                         TEXT("CLOCK$"),
                                         TEXT("CON"),
                                         TEXT("AUX"),
                                       };
    short i;
    TCHAR cSave, cSave2;


    cSave = *(lpszFileName + 4);
    if (cSave == CHAR_DOT)
    {
        *(lpszFileName + 4) = CHAR_NULL;
    }

    //
    //  For "EPT".
    //
    cSave2 = *(lpszFileName + 3);
    if (cSave2 == CHAR_DOT)
    {
      *(lpszFileName + 3) = CHAR_NULL;
    }

    for (i = 0; i < PORTARRAY; i++)
    {
        if (!lstrcmpi(szPorts[i], lpszFileName))
        {
            break;
        }
    }
    *(lpszFileName + 4) = cSave;
    *(lpszFileName + 3) = cSave2;

    return (i != PORTARRAY);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsDirectory
//
////////////////////////////////////////////////////////////////////////////

BOOL IsDirectory(
    LPTSTR pszPath)
{
    DWORD dwAttributes;

    //
    //  Clean up for GetFileAttributes.
    //
    PathRemoveBslash(pszPath);

    dwAttributes = GetFileAttributes(pszPath);
    return ( (dwAttributes != (DWORD)(-1)) &&
             (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) );
}


////////////////////////////////////////////////////////////////////////////
//
//  WriteProtectedDirCheck
//
//  This function takes a full filename, strips the path, and creates
//  a temp file in that directory.  If it can't, the directory is probably
//  write protected.
//
//  Returns:
//      error code if writeprotected
//      0 if successful creation of file.
//
//  Assumptions:
//    Full Path name on input with space for full filename appended.
//
//  Note: Do NOT use this on a floppy, it's too slow!
//
////////////////////////////////////////////////////////////////////////////

int WriteProtectedDirCheck(
    LPTSTR lpszFile)
{
    SHORT nFileOffset;
    TCHAR szFile[MAX_PATH + 1];
    TCHAR szBuf[MAX_PATH + 1];

    lstrcpyn(szFile, lpszFile, MAX_PATH + 1);
    nFileOffset = (SHORT)(int)LOWORD(ParseFile(szFile, TRUE, FALSE, TRUE));

    szFile[nFileOffset - 1] = CHAR_NULL;
    if (!GetTempFileName(szFile, TEXT("TMP"), 0, szBuf))
    {
        return (GetLastError());
    }
    else
    {
        DeleteFile(szBuf);
        return (0);               // success
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  FOkToWriteOver
//
//  Verifies that the user really does want to destroy the file,
//  replacing its contents with new stuff.
//
////////////////////////////////////////////////////////////////////////////

BOOL FOkToWriteOver(
    HWND hDlg,
    LPTSTR szFileName)
{
    if (!LoadString( g_hinst,
                     iszOverwriteQuestion,
                     szCaption,
                     WARNINGMSGLENGTH - 1 ))
    {
        return (FALSE);
    }

    //
    //  Since we're passed in a valid filename, if the 3rd & 4th characters
    //  are both slashes, weve got a dummy drive as the 1st two characters.
    //
    if (DBL_BSLASH(szFileName + 2))
    {
        szFileName = szFileName + 2;
    }

    wsprintf(szWarning, szCaption, szFileName);

    GetWindowText(hDlg, szCaption, cbCaption);
    return (MessageBox( hDlg,
                        szWarning,
                        szCaption,
                        MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION ) == IDYES);
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateFileDlg
//
////////////////////////////////////////////////////////////////////////////

int CreateFileDlg(
    HWND hDlg,
    LPTSTR szPath)
{
    //
    //  Since we're passed in a valid filename, if the 3rd & 4th
    //  characters are both slashes, we've got a dummy drive as the
    //  1st two characters.
    //
    if (DBL_BSLASH(szPath + 2))
    {
        szPath = szPath + 2;
    }

    if (!LoadString(g_hinst, iszCreatePrompt, szCaption, TOOLONGLIMIT))
    {
        return (IDNO);
    }
    if (lstrlen(szPath) > TOOLONGLIMIT)
    {
        *(szPath + TOOLONGLIMIT) = CHAR_NULL;
    }

    wsprintf(szWarning, szCaption, szPath);

    GetWindowText(hDlg, szCaption, TOOLONGLIMIT);

    return (MessageBox( hDlg,
                        szWarning,
                        szCaption,
                        MB_YESNO | MB_ICONQUESTION ));
}


#ifndef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  EliminateString
//
//  Chops the string by the specified length.  If a DBCS lead byte is
//  left as the last char, then it is removed as well.
//
//  NOTE: For non-Unicode strings only.
//
////////////////////////////////////////////////////////////////////////////

VOID EliminateString(
    LPSTR lpStr,
    int nLen)
{
    LPSTR lpChar;
    BOOL bFix = FALSE;

    *(lpStr + nLen) = CHAR_NULL;
    for (lpChar = lpStr + nLen - 1; lpChar >= lpStr; lpChar--)
    {
        if (!IsDBCSLeadByte(*lpChar))
        {
            break;
        }
        bFix = !bFix;
    }
    if (bFix)
    {
        *(lpStr + nLen - 1) = CHAR_NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  IsBackSlash
//
//  Decides whether a character is a '\' or a DBCS trail byte with the same
//  code point value.
//
//  NOTE: For non-Unicode strings only.
//
////////////////////////////////////////////////////////////////////////////

BOOL IsBackSlash(
    LPSTR lpStart,
    LPSTR lpChar)
{
    if (*lpChar == CHAR_BSLASH)
    {
        BOOL bRet = TRUE;

        while (--lpChar >= lpStart)
        {
            if (!IsDBCSLeadByte(*lpChar))
            {
                break;
            }
            bRet = !bRet;
        }
        return (bRet);
    }
    return (FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\printnew.cpp ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    printnew.cpp

Abstract:

    This module implements the Win32 property sheet print dialogs.

Revision History:

    11-04-97    JulieB    Created.

--*/



//
//  Include Files.
//

#undef WINVER
#define WINVER 0x0500       // Needed to get the updated DMPAPER constants.

#include "comdlg32.h"
#include <winspool.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shsemip.h>
#include <shellp.h>
#include <commctrl.h>
#include <ole2.h>
#include <shguidp.h>
#include <sfview.h>
#include "cdids.h"
#include "prnsetup.h"
#include "printnew.h"




//
//  Constant Declarations.
//

#define CDM_SELCHANGE             (CDM_LAST + 102)
#define CDM_PRINTNOTIFY           (CDM_LAST + 103)
#define CDM_NOPRINTERS            (CDM_LAST + 104)
#define CDM_INITDONE              (CDM_LAST + 105)

#define PRINTERS_ICOL_NAME        0
#define PRINTERS_ICOL_QUEUESIZE   1
#define PRINTERS_ICOL_STATUS      2
#define PRINTERS_ICOL_COMMENT     3
#define PRINTERS_ICOL_LOCATION    4
#define PRINTERS_ICOL_MODEL       5




//
//  Macro Definitions.
//

#define Print_HwndToBrowser(hwnd)      ((CPrintBrowser *)GetWindowLongPtr(hwnd, DWLP_USER))
#define Print_StoreBrowser(hwnd, pbrs) (SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pbrs))
#define Print_IsInRange(id, idFirst, idLast) \
    ((UINT)((id) - idFirst) <= (UINT)(idLast - idFirst))




//
//  Global Variables.
//

HWND g_hwndActivePrint = NULL;
HACCEL g_haccPrint = NULL;
HHOOK g_hHook = NULL;
int g_nHookRef = -1;




//
//  Extern Declarations.
//

extern HWND
GetFocusedChild(
    HWND hwndDlg,
    HWND hwndFocus);

extern void
GetViewItemText(
    IShellFolder *psf,
    LPCITEMIDLIST pidl,
    LPTSTR pBuf,
    UINT cchBuf,
    DWORD dwFlags);





#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgExA
//
//  ANSI entry point for PrintDlgEx when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI PrintDlgExA(
    LPPRINTDLGEXA pPDA)
{
#ifdef WINNT
    PRINTINFOEX PI;
    HRESULT hResult;

    ZeroMemory(&PI, sizeof(PRINTINFOEX));

    hResult = ThunkPrintDlgEx(&PI, pPDA);
    if (SUCCEEDED(hResult))
    {
        ThunkPrintDlgExA2W(&PI);

        hResult = PrintDlgExX(&PI);

        ThunkPrintDlgExW2A(&PI);
    }
    FreeThunkPrintDlgEx(&PI);

    return (hResult);
#else
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (E_NOTIMPL);
#endif
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgExW
//
//  Stub UNICODE function for PrintDlgEx when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI PrintDlgExW(
    LPPRINTDLGEXW pPDW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (E_NOTIMPL);
}

#endif


////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgEx
//
//  The PrintDlgEx function displays a Print dialog that enables the
//  user to specify the properties of a particular print job.
//
////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI PrintDlgEx(
    LPPRINTDLGEX pPD)
{
#ifdef WINNT
    PRINTINFOEX PI;

    ZeroMemory(&PI, sizeof(PRINTINFOEX));

    PI.pPD = pPD;
    PI.ApiType = COMDLG_WIDE;

    return ( PrintDlgExX(&PI) );
#else
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (E_NOTIMPL);
#endif
}


#ifdef WINNT

////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgExX
//
//  Worker routine for the PrintDlgEx api.
//
////////////////////////////////////////////////////////////////////////////

HRESULT PrintDlgExX(
    PPRINTINFOEX pPI)
{
    LPPRINTDLGEX pPD = pPI->pPD;
    BOOL hResult;
    DWORD dwFlags;
    DWORD nCopies;
    LPPRINTPAGERANGE pPageRanges;
    DWORD nFromPage, nToPage;
    UINT Ctr;
    BOOL bHooked = FALSE;

    //
    //  Make sure the print dlg structure exists and that we're not being
    //  called from a wow app.
    //
    if ((!pPD) || (IS16BITWOWAPP(pPD)))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (E_INVALIDARG);
    }

    //
    //  Make sure the size of the print dlg structure is valid.
    //
    if (pPD->lStructSize != sizeof(PRINTDLGEX))
    {
        pPI->dwExtendedError = CDERR_STRUCTSIZE;
        return (E_INVALIDARG);
    }

    //
    //  Make sure the owner window exists and is valid.
    //
    if (!pPD->hwndOwner || !IsWindow(pPD->hwndOwner))
    {
        pPI->dwExtendedError = CDERR_DIALOGFAILURE;
        return (E_HANDLE);
    }

    //
    //  Make sure only valid flags are passed into this routine.
    //
    if ((pPD->Flags & ~(PD_ALLPAGES                   |
                        PD_SELECTION                  |
                        PD_PAGENUMS                   |
                        PD_NOSELECTION                |
                        PD_NOPAGENUMS                 |
                        PD_COLLATE                    |
                        PD_PRINTTOFILE                |
                        PD_NOWARNING                  |
                        PD_RETURNDC                   |
                        PD_RETURNIC                   |
                        PD_RETURNDEFAULT              |
                        PD_ENABLEPRINTTEMPLATE        |
                        PD_ENABLEPRINTTEMPLATEHANDLE  |
                        PD_USEDEVMODECOPIESANDCOLLATE |
                        PD_DISABLEPRINTTOFILE         |
                        PD_HIDEPRINTTOFILE            |
                        PD_CURRENTPAGE                |
                        PD_NOCURRENTPAGE              |
                        PD_EXCLUSIONFLAGS)) ||
        (pPD->Flags2 != 0) ||
        (pPD->ExclusionFlags & ~(PD_EXCL_COPIESANDCOLLATE)) ||
        (pPD->dwResultAction != 0))
    {
        pPI->dwExtendedError = PDERR_INITFAILURE;
        return (E_INVALIDARG);
    }

    //
    //  Check the template settings as much as we can here.
    //
    if (pPD->Flags & PD_ENABLEPRINTTEMPLATEHANDLE)
    {
        if (!pPD->hInstance)
        {
            pPI->dwExtendedError = CDERR_NOHINSTANCE;
            return (E_HANDLE);
        }
    }
    else if (pPD->Flags & PD_ENABLEPRINTTEMPLATE)
    {
        if (!pPD->lpPrintTemplateName)
        {
            pPI->dwExtendedError = CDERR_NOTEMPLATE;
            return (E_POINTER);
        }
        if (!pPD->hInstance)
        {
            pPI->dwExtendedError = CDERR_NOHINSTANCE;
            return (E_HANDLE);
        }
    }
    else
    {
        if (pPD->lpPrintTemplateName || pPD->hInstance)
        {
            pPI->dwExtendedError = PDERR_INITFAILURE;
            return (E_INVALIDARG);
        }
    }

    //
    //  Check the application property pages and the start page value.
    //
    if ((pPD->nPropertyPages && (pPD->lphPropertyPages == NULL)) ||
        ((pPD->nStartPage != START_PAGE_GENERAL) &&
         (pPD->nStartPage >= pPD->nPropertyPages)))
    {
        pPI->dwExtendedError = PDERR_INITFAILURE;
        return (E_INVALIDARG);
    }

    //
    //  Check the page range boundaries if the PD_NOPAGENUMS flag is
    //  not set.
    //
    if (!(pPD->Flags & PD_NOPAGENUMS))
    {
        if ((pPD->nMinPage > pPD->nMaxPage) ||
            (pPD->nPageRanges > pPD->nMaxPageRanges) ||
            (pPD->nMaxPageRanges == 0) ||
            ((pPD->nMaxPageRanges) && (!pPD->lpPageRanges)))
        {
            pPI->dwExtendedError = PDERR_INITFAILURE;
            return (E_INVALIDARG);
        }

        //
        //  Check each of the given ranges.
        //
        pPageRanges = pPD->lpPageRanges;
        for (Ctr = 0; Ctr < pPD->nPageRanges; Ctr++)
        {
            //
            //  Get the range.
            //
            nFromPage = pPageRanges[Ctr].nFromPage;
            nToPage   = pPageRanges[Ctr].nToPage;

            //
            //  Make sure the range is valid.
            //
            if ((nFromPage < pPD->nMinPage) || (nFromPage > pPD->nMaxPage) ||
                (nToPage   < pPD->nMinPage) || (nToPage   > pPD->nMaxPage))
            {
                pPI->dwExtendedError = PDERR_INITFAILURE;
                return (E_INVALIDARG);
            }
        }
    }

    //
    //  Get the process version of the app for later use.
    //
    pPI->ProcessVersion = GetProcessVersion(0);

    //
    //  Init hDC.
    //
    pPD->hDC = 0;

    //
    //  Do minimal work when requesting a default printer.
    //
    if (pPD->Flags & PD_RETURNDEFAULT)
    {
        return (Print_ReturnDefault(pPI));
    }

    //
    //  Load the necessary libraries.
    //
    if (!Print_LoadLibraries())
    {
        pPI->dwExtendedError = PDERR_LOADDRVFAILURE;
        hResult = E_OUTOFMEMORY;
        goto PrintDlgExX_DisplayWarning;
    }

    //
    //  Load the necessary icons.
    //
    if (!Print_LoadIcons())
    {
        //
        //  If the icons cannot be loaded, then fail.
        //
        pPI->dwExtendedError = PDERR_SETUPFAILURE;
        hResult = E_OUTOFMEMORY;
        goto PrintDlgExX_DisplayWarning;
    }

    //
    //  Make sure the page ranges info is valid.
    //
    if ((!(pPD->Flags & PD_NOPAGENUMS)) &&
        ((pPD->nMinPage > pPD->nMaxPage) ||
         (pPD->nPageRanges > pPD->nMaxPageRanges) ||
         (pPD->nMaxPageRanges == 0) ||
         ((pPD->nMaxPageRanges) && (!(pPD->lpPageRanges)))))
    {
        pPI->dwExtendedError = PDERR_INITFAILURE;
        return (E_INVALIDARG);
    }

    //
    //  Save the original information passed in by the app in case the
    //  user hits cancel.
    //
    //  Only the values that are modified at times other than during
    //  PSN_APPLY need to be saved.
    //
    dwFlags = pPD->Flags;
    nCopies = pPD->nCopies;
    pPI->dwFlags = dwFlags;

    //
    //  Set up the hook proc for input event messages.
    //
    if (InterlockedIncrement((LPLONG)&g_nHookRef) == 0)
    {
        g_hHook = SetWindowsHookEx( WH_MSGFILTER,
                                    Print_MessageHookProc,
                                    0,
                                    GetCurrentThreadId() );
        if (g_hHook)
        {
            bHooked = TRUE;
        }
        else
        {
            --g_nHookRef;
        }
    }
    else
    {
        bHooked = TRUE;
    }

    //
    //  Load the print folder accelerators.
    //
    if (!g_haccPrint)
    {
        g_haccPrint = LoadAccelerators( g_hinst,
                                        MAKEINTRESOURCE(IDA_PRINTFOLDER) );
    }

    //
    //  Initialize the error codes to failure in case we die before we
    //  actually bring up the property pages.
    //
    pPI->dwExtendedError = CDERR_INITIALIZATION;
    pPI->hResult = E_FAIL;

    //
    //  Bring up the dialog.
    //
    HRESULT hrInit;
    hrInit = SHOleInitialize(0);
    Print_InvokePropertySheets(pPI, pPD);
    SHOleUninitialize(hrInit);

    hResult = pPI->hResult;

    //
    //  Unhook the input event messages.
    //
    if (bHooked)
    {
        //
        //  Put this in a local so we don't need a critical section.
        //
        HHOOK hHook = g_hHook;

        if (InterlockedDecrement((LPLONG)&g_nHookRef) < 0)
        {
            UnhookWindowsHookEx(hHook);
        }
    }

    //
    //  If the user hit cancel or if there was an error, restore the original
    //  values passed in by the app.
    //
    //  Only the values that are modified at times other than during
    //  PSN_APPLY need to be restored here.
    //
    if ((pPI->FinalResult == 0) && (!pPI->fApply))
    {
        pPD->Flags   = dwFlags;
        pPD->nCopies = nCopies;
    }

    //
    //  See if we need to fill in the dwResultAction member field.
    //
    if (SUCCEEDED(hResult))
    {
        if (pPI->FinalResult != 0)
        {
            pPD->dwResultAction = PD_RESULT_PRINT;
        }
        else if (pPI->fApply)
        {
            pPD->dwResultAction = PD_RESULT_APPLY;
        }
        else
        {
            pPD->dwResultAction = PD_RESULT_CANCEL;
        }
    }

    //
    //  Display any error messages.
    //
PrintDlgExX_DisplayWarning:

    if ((!(dwFlags & PD_NOWARNING)) && FAILED(hResult) &&
        (pPI->ProcessVersion >= 0x40000))
    {
        TCHAR szWarning[SCRATCHBUF_SIZE];
        TCHAR szTitle[SCRATCHBUF_SIZE];
        int iszWarning;

        szTitle[0] = TEXT('\0');
        if (pPD->hwndOwner)
        {
            GetWindowText(pPD->hwndOwner, szTitle, SCRATCHBUF_SIZE);
        }
        if (!szTitle[0])
        {
            LoadString(g_hinst, iszWarningTitle, szTitle, SCRATCHBUF_SIZE);
        }

        switch (hResult)
        {
            case ( E_OUTOFMEMORY ) :
            {
                iszWarning = iszMemoryError;
                break;
            }
            default :
            {
                iszWarning = iszGeneralWarning;
                break;
            }
        }

        LoadString(g_hinst, iszWarning, szWarning, SCRATCHBUF_SIZE);
        MessageBeep(MB_ICONEXCLAMATION);
        MessageBox( pPD->hwndOwner,
                    szWarning,
                    szTitle,
                    MB_ICONEXCLAMATION | MB_OK );
    }

    //
    //  Return the result.
    //
    return (hResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_ReturnDefault
//
////////////////////////////////////////////////////////////////////////////

HRESULT Print_ReturnDefault(
    PPRINTINFOEX pPI)
{
    LPPRINTDLGEX pPD = pPI->pPD;
    TCHAR szPrinterName[MAX_PATH];
    LPDEVNAMES pDN;
    LPDEVMODE pDM;

    //
    //  Initialize the error code to 0.
    //
    pPI->dwExtendedError = CDERR_GENERALCODES;

    //
    //  Make sure the hDevMode and hDevNames fields are NULL.
    //
    if (pPD->hDevMode || pPD->hDevNames)
    {
        pPI->dwExtendedError = PDERR_RETDEFFAILURE;
        return (E_HANDLE);
    }

    //
    //  Get the default printer name.
    //
    szPrinterName[0] = 0;
    PrintGetDefaultPrinterName(szPrinterName, ARRAYSIZE(szPrinterName));
    if (szPrinterName[0] == 0)
    {
        pPI->dwExtendedError = PDERR_NODEFAULTPRN;
        return (E_FAIL);
    }

    //
    //  Allocate and fill in the DevNames structure.
    //
    if (!Print_SaveDevNames(szPrinterName, pPD))
    {
        pPI->dwExtendedError = CDERR_MEMALLOCFAILURE;
        return (E_OUTOFMEMORY);
    }

    //
    //  Allocate and fill in the DevMode structure.
    //
    pPD->hDevMode = Print_GetDevModeWrapper(szPrinterName, NULL);

    //
    //  Get the device or information context, depending on which one
    //  was requested (if any).
    //
    if ((pPD->hDevNames) && (pDN = (LPDEVNAMES)GlobalLock(pPD->hDevNames)))
    {
        if ((pPD->hDevMode) && (pDM = (LPDEVMODE)GlobalLock(pPD->hDevMode)))
        {
            PrintReturnICDC((LPPRINTDLG)pPD, pDN, pDM);

            GlobalUnlock(pPD->hDevMode);
            GlobalUnlock(pPD->hDevNames);

            return (S_OK);
        }
        else
        {
            GlobalUnlock(pPD->hDevNames);
        }
    }

    //
    //  Make sure the pointers are NULL since we failed.
    //
    if (pPD->hDevNames)
    {
        GlobalFree(pPD->hDevNames);
        pPD->hDevNames = NULL;
    }
    if (pPD->hDevMode)
    {
        GlobalFree(pPD->hDevMode);
        pPD->hDevMode = NULL;
    }

    //
    //  Return failure.
    //
    pPI->dwExtendedError = PDERR_NODEFAULTPRN;
    return (E_FAIL);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_LoadLibraries
//
////////////////////////////////////////////////////////////////////////////

BOOL Print_LoadLibraries()
{
    //
    //  Load PrintUI.
    //
    if (!hPrintUI)
    {
        if ((hPrintUI = LoadLibrary(SZ_PRINTUI)))
        {
            PrintUI_bPrintDlgSheetsPropPages = (PF_PRINTDLGSHEETSPROPPAGES)
                          GetProcAddress(hPrintUI, SZ_PRINTDLGSHEETSPROPPAGES);

            if (!PrintUI_bPrintDlgSheetsPropPages)
            {
                FreeLibrary(hPrintUI);
                hPrintUI = NULL;
            }
        }
    }

    //
    //  Return the result.
    //
    return (hPrintUI != NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_UnloadLibraries
//
////////////////////////////////////////////////////////////////////////////

VOID Print_UnloadLibraries()
{
    if (hPrintUI)
    {
        FreeLibrary(hPrintUI);
        hPrintUI = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_LoadIcons
//
////////////////////////////////////////////////////////////////////////////

BOOL Print_LoadIcons()
{
    //
    //  Load the collation images.
    //
    hIconCollate = LoadImage( g_hinst,
                              MAKEINTRESOURCE(ICO_COLLATE),
                              IMAGE_ICON,
                              0,
                              0,
                              LR_SHARED);
    hIconNoCollate = LoadImage( g_hinst,
                                MAKEINTRESOURCE(ICO_NO_COLLATE),
                                IMAGE_ICON,
                                0,
                                0,
                               LR_SHARED);

    //
    //  Return TRUE only if all icons/images were loaded properly.
    //
    return (hIconCollate && hIconNoCollate);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_InvokePropertySheets
//
////////////////////////////////////////////////////////////////////////////

BOOL Print_InvokePropertySheets(
    PPRINTINFOEX pPI,
    LPPRINTDLGEX pPD)
{
    PRINTDLG_DATA PrintDlgData;
    PROPSHEETPAGE pGenPages[1];
    BOOL bResult = FALSE;
    TCHAR pszTitle[MAX_PATH];
    TCHAR pszCaption[MAX_PATH];
    DWORD dwExclusionFlags;

    //
    //  Load all of the necessary strings.
    //
    LoadString(g_hinst, iszGeneralPage, pszTitle, ARRAYSIZE(pszTitle));
    LoadString(g_hinst, iszPrintCaption, pszCaption, ARRAYSIZE(pszCaption));

    //
    //  See if the exclusion flags are set properly.
    //
    if (!(pPD->Flags & PD_EXCLUSIONFLAGS))
    {
        pPD->ExclusionFlags = PD_EXCL_COPIESANDCOLLATE;
    }
    dwExclusionFlags = pPD->ExclusionFlags;

    //
    //  Set up the General page.
    //
    pGenPages[0].dwSize      = sizeof(PROPSHEETPAGE);
    pGenPages[0].dwFlags     = PSP_DEFAULT | PSP_USETITLE;
    pGenPages[0].hInstance   = g_hinst;
    pGenPages[0].pszTemplate = MAKEINTRESOURCE(IDD_PRINT_GENERAL);
    pGenPages[0].pszIcon     = NULL;
    pGenPages[0].pszTitle    = pszTitle;
    pGenPages[0].pfnDlgProc  = Print_GeneralDlgProc;
    pGenPages[0].lParam      = (LPARAM)pPI;
    pGenPages[0].pfnCallback = NULL;
    pGenPages[0].pcRefParent = NULL;

    //
    //  Call the Print UI function to bring up the property sheet pages.
    //
    PrintDlgData.dwSize            = sizeof(PRINTDLG_DATA);
    PrintDlgData.pszCaption        = pszCaption;
    PrintDlgData.hwndParent        = pPD->hwndOwner;
    PrintDlgData.hInstance         = g_hinst;
    PrintDlgData.IconID            = ICO_PRINTER;
    PrintDlgData.dwComDlgFlags     = pPI->fOld
                                       ? PDS_PROPSHEETPAGE | PDS_NOAPPLYNOW
                                       : PDS_PROPSHEETPAGE;
    PrintDlgData.nComDlgPages      = sizeof(pGenPages) / sizeof(*pGenPages);
    PrintDlgData.pComDlgpsp        = pGenPages;
    PrintDlgData.dwAppFlags        = 0;
    PrintDlgData.nAppPages         = pPD->nPropertyPages;
    PrintDlgData.pApphpage         = (pPD->nPropertyPages) ? pPD->lphPropertyPages
                                                           : NULL;
    PrintDlgData.dwExclusionFlags  = dwExclusionFlags;
    PrintDlgData.pAppPageInterface = NULL;

    if (PrintUI_bPrintDlgSheetsPropPages)
    {
        bResult = (*PrintUI_bPrintDlgSheetsPropPages)(NULL, &PrintDlgData);
    }

    //
    //  Return the result.
    //
    return (bResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_GeneralDlgProc
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK Print_GeneralDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    CPrintBrowser *pDlgStruct = NULL;

    if (uMsg != WM_INITDIALOG)
    {
        pDlgStruct = Print_HwndToBrowser(hDlg);
    }

    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            if (!Print_InitDialog(hDlg, wParam, lParam))
            {
                PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
            }
            g_hwndActivePrint = hDlg;
            break;
        }
        case ( WM_DESTROY ) :
        {
            Print_StoreBrowser(hDlg, NULL);

            if (pDlgStruct)
            {
                pDlgStruct->OnDestroyMessage();
                pDlgStruct->Release();
            }
            break;
        }
        case ( WM_ACTIVATE ) :
        {
            if (wParam == WA_INACTIVE)
            {
                //
                //  Make sure some other Print dialog has not already grabbed
                //  the focus.  This is a process global, so it should not
                //  need to be protected.
                //
                if (g_hwndActivePrint == hDlg)
                {
                    g_hwndActivePrint = NULL;
                }
            }
            else
            {
                g_hwndActivePrint = hDlg;
            }
            break;
        }
        case ( WM_COMMAND ) :
        {
            if (pDlgStruct)
            {
                return (pDlgStruct->OnCommandMessage(wParam, lParam));
            }
            break;
        }
        case ( WM_DRAWITEM ) :
        {
            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            break;
        }
        case ( WM_NOTIFY ) :
        {
            if (pDlgStruct)
            {
                return (pDlgStruct->OnNotifyMessage(wParam, (LPNMHDR)lParam));
            }
            break;
        }
        case ( WM_HELP ) :
        {
            HWND hwndItem = (HWND)((LPHELPINFO)lParam)->hItemHandle;

            //
            //  We assume that the defview has one child window that
            //  covers the entire defview window.
            //
            HWND hwndDefView = GetDlgItem(hDlg, IDC_PRINTER_LISTVIEW);
            if (GetParent(hwndItem) == hwndDefView)
            {
                hwndItem = hwndDefView;
            }

            WinHelp( hwndItem,
                     NULL,
                     HELP_WM_HELP,
                     (ULONG_PTR)(LPTSTR)aPrintExHelpIDs );

            return (TRUE);
        }
        case ( WM_CONTEXTMENU ) :
        {
            WinHelp( (HWND)wParam,
                     NULL,
                     HELP_CONTEXTMENU,
                     (ULONG_PTR)(LPVOID)aPrintExHelpIDs );

            return (TRUE);
        }
        case ( CWM_GETISHELLBROWSER ) :
        {
            ::SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LRESULT)pDlgStruct);
            return (TRUE);
        }
        case ( CDM_SELCHANGE ) :
        {
            if (pDlgStruct)
            {
                pDlgStruct->OnSelChange();
            }
            break;
        }
        case ( CDM_PRINTNOTIFY ) :
        {
            if (pDlgStruct)
            {
                LPITEMIDLIST *ppidl;
                LONG lEvent;
                BOOL bRet = FALSE;
                LPSHChangeNotificationLock pLock;

                //
                //  Get the change notification info from the shared memory
                //  block identified by the handle passed in the wParam.
                //
                pLock = SHChangeNotification_Lock( (HANDLE)wParam,
                                                   (DWORD)lParam,
                                                   &ppidl,
                                                   &lEvent );
                if (pLock == NULL)
                {
                    return (FALSE);
                }

                //
                //  Handle the change notification.
                //
                bRet = pDlgStruct->OnChangeNotify( lEvent,
                                                   (LPCITEMIDLIST *)ppidl );

                //
                //  Release the shared block.
                //
                SHChangeNotification_Unlock(pLock);

                //
                //  Return the result.
                //
                return (bRet);
            }
            break;
        }
        case ( CDM_NOPRINTERS ) :
        {
            //
            //  There are no printers, so bring up the dialog telling the
            //  user that they need to install a printer.
            //
            if (pDlgStruct)
            {
                pDlgStruct->OnNoPrinters((HWND)wParam, (UINT)lParam);
            }
        }
        case ( CDM_INITDONE ) :
        {
            if (pDlgStruct)
            {
                pDlgStruct->OnInitDone();
            }
            break;
        }
        default :
        {
            break;
        }
    }

    //
    //  Return the result.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_GeneralChildDlgProc
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK Print_GeneralChildDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT lResult;
    CPrintBrowser *pDlgStruct = Print_HwndToBrowser(GetParent(hDlg));

    //
    //  See if we need to call an application callback to handle the
    //  message.
    //
    if (pDlgStruct)
    {
        if (pDlgStruct->HandleMessage(hDlg, uMsg, wParam, lParam, &lResult) != S_FALSE)
        {
            if (uMsg == WM_INITDIALOG)
            {
                PostMessage(GetParent(hDlg), CDM_INITDONE, 0, 0);
            }

            // 
            // ISSUE: The return from a dlgproc is different than a winproc.
            //

            return (BOOLFROMPTR(lResult));

        }
    }

    //
    //  If we get to this point, we need to handle the message.
    //
    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            if (pDlgStruct)
            {
                if (!pDlgStruct->OnChildInitDialog(hDlg, wParam, lParam))
                {
                    PropSheet_PressButton( GetParent(GetParent(hDlg)),
                                           PSBTN_CANCEL );
                }
            }
            break;
        }
        case ( WM_DESTROY ) :
        {
            break;
        }
        case ( WM_ACTIVATE ) :
        {
            break;
        }
        case ( WM_COMMAND ) :
        {
            if (pDlgStruct)
            {
                return (pDlgStruct->OnChildCommandMessage(wParam, lParam));
            }
            break;
        }
        case ( WM_DRAWITEM ) :
        {
            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            break;
        }
        case ( WM_NOTIFY ) :
        {
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     NULL,
                     HELP_WM_HELP,
                     (ULONG_PTR)(LPTSTR)aPrintExChildHelpIDs );

            return (TRUE);
        }
        case ( WM_CONTEXTMENU ) :
        {
            WinHelp( (HWND)wParam,
                     NULL,
                     HELP_CONTEXTMENU,
                     (ULONG_PTR)(LPVOID)aPrintExChildHelpIDs );

            return (TRUE);
        }
        default :
        {
            break;
        }
    }

    //
    //  Return the result.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_MessageHookProc
//
//  Handles the input event messages.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK Print_MessageHookProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam)
{
    PMSG pMsg;

    //
    //  See if the nCode is negative.  If so, call the default hook proc.
    //
    if (nCode < 0)
    {
        return (DefHookProc(nCode, wParam, lParam, &g_hHook));
    }

    //
    //  Make sure we only handle dialog box messages.
    //
    if (nCode != MSGF_DIALOGBOX)
    {
        return (0);
    }

    //
    //  Get the msg structure.
    //
    pMsg = (PMSG)lParam;

    //
    //  Make sure the message is one of the WM_KEY* messages.
    //
    if (Print_IsInRange(pMsg->message, WM_KEYFIRST, WM_KEYLAST))
    {
        HWND hwndActivePrint = g_hwndActivePrint;
        HWND hwndFocus = GetFocusedChild(hwndActivePrint, pMsg->hwnd);
        CPrintBrowser *pDlgStruct;

        if (hwndFocus &&
            (pDlgStruct = Print_HwndToBrowser(hwndActivePrint)) != NULL)
        {
            return (pDlgStruct->OnAccelerator( hwndActivePrint,
                                               hwndFocus,
                                               g_haccPrint,
                                               pMsg ));
        }
    }

    //
    //  Return that the message was not handled.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_InitDialog
//
////////////////////////////////////////////////////////////////////////////

BOOL Print_InitDialog(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam)
{
    //
    //  Create the CPrintBrowser object and store it in DWL_USER.
    //
    CPrintBrowser *pDlgStruct = new CPrintBrowser(hDlg);
    if (pDlgStruct == NULL)
    {
        return (FALSE);
    }
    Print_StoreBrowser(hDlg, pDlgStruct);

    //
    //  Let the class function do the work.
    //
    return (pDlgStruct->OnInitDialog(wParam, lParam));
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_ICoCreateInstance
//
//  Create an instance of the specified shell class.
//
////////////////////////////////////////////////////////////////////////////

HRESULT Print_ICoCreateInstance(
    REFCLSID rclsid,
    REFIID riid,
    LPCITEMIDLIST pidl,
    LPVOID *ppv)
{
    LPSHELLFOLDER pshf = NULL;
    HRESULT hres = E_FAIL;

    //
    //  Initialize the pointer to the shell view.
    //
    *ppv = NULL;

    //
    //  Get the IShellFolder interface to the desktop folder and then
    //  bind to it.  This is equivalent to calling CoCreateInstance
    //  with CLSID_ShellDesktop.
    //
    hres = SHGetDesktopFolder(&pshf);
    if (SUCCEEDED(hres))
    {
        hres = pshf->BindToObject(pidl, NULL, riid, ppv);
        pshf->Release();
    }

    //
    //  Return the result.
    //
    return (hres);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_SaveDevNames
//
//  Saves the current devnames in the pPD structure.
//
////////////////////////////////////////////////////////////////////////////

BOOL Print_SaveDevNames(
    LPTSTR pCurPrinter,
    LPPRINTDLGEX pPD)
{
    TCHAR szPortName[MAX_PATH];
    TCHAR szPrinterName[MAX_PATH];
    DWORD cbDevNames;
    LPDEVNAMES pDN;

    //
    //  Get the port name.
    //
    szPortName[0] = 0;
    Print_GetPortName(pCurPrinter, szPortName, ARRAYSIZE(szPortName));

    //
    //  Compute the size of the DevNames structure.
    //
    cbDevNames = lstrlen(szDriver) + 1 +
                 lstrlen(szPortName) + 1 +
                 lstrlen(pCurPrinter) + 1 +
                 DN_PADDINGCHARS;

    cbDevNames *= sizeof(TCHAR);
    cbDevNames += sizeof(DEVNAMES);

    //
    //  Allocate the new DevNames structure.
    //
    pDN = NULL;
    if (pPD->hDevNames)
    {
        HANDLE handle;

        handle = GlobalReAlloc(pPD->hDevNames, cbDevNames, GHND);

        //Check that realloc succeeded.
        if (handle)
        {
            pPD->hDevNames  = handle;
        }
        else
        {
            //Realloc didn't succeed. Free the memory occupied.
            GlobalFree(pPD->hDevNames);
        }
    }
    else
    {
        pPD->hDevNames = GlobalAlloc(GHND, cbDevNames);
    }

    //
    //  Fill in the DevNames structure with the appropriate information.
    //
    if ( (pPD->hDevNames) &&
         (pDN = (LPDEVNAMES)GlobalLock(pPD->hDevNames)) )
    {
        //
        //  Save the driver name - winspool.
        //
        pDN->wDriverOffset = sizeof(DEVNAMES) / sizeof(TCHAR);
        lstrcpy((LPTSTR)pDN + pDN->wDriverOffset, szDriver);

        //
        //  Save the printer name.
        //
        pDN->wDeviceOffset = pDN->wDriverOffset + lstrlen(szDriver) + 1;
        lstrcpy((LPTSTR)pDN + pDN->wDeviceOffset, pCurPrinter);

        //
        //  Save the port name.
        //
        pDN->wOutputOffset = pDN->wDeviceOffset + lstrlen(pCurPrinter) + 1;
        lstrcpy((LPTSTR)pDN + pDN->wOutputOffset, szPortName);

        //
        //  Save whether or not it's the default printer.
        //
        if (pPD->Flags & PD_RETURNDEFAULT)
        {
            pDN->wDefault = DN_DEFAULTPRN;
        }
        else
        {
            szPrinterName[0] = 0;
            PrintGetDefaultPrinterName(szPrinterName, ARRAYSIZE(szPrinterName));
            if (szPrinterName[0] && !lstrcmp(pCurPrinter, szPrinterName))
            {
                pDN->wDefault = DN_DEFAULTPRN;
            }
            else
            {
                pDN->wDefault = 0;
            }
        }

        //
        //  Unlock it.
        //
        GlobalUnlock(pPD->hDevNames);
    }
    else
    {
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_GetPortName
//
//  Gets the port name for the given printer and stores it in the
//  given buffer.
//
////////////////////////////////////////////////////////////////////////////

VOID Print_GetPortName(
    LPTSTR pCurPrinter,
    LPTSTR pBuffer,
    int cchBuffer)
{
    HANDLE hPrinter;
    DWORD cbPrinter = 0;
    PRINTER_INFO_2 *pPrinter = NULL;

    //
    //  Initialize the buffer.
    //
    if (!cchBuffer)
    {
        return;
    }
    pBuffer[0] = 0;

    //
    //  Open the current printer.
    //
    if (OpenPrinter(pCurPrinter, &hPrinter, NULL))
    {
        //
        //  Get the size of the buffer needed to hold the printer info 2
        //  information.
        //
        if (!GetPrinter( hPrinter,
                         2,
                         (LPBYTE)pPrinter,
                         cbPrinter,
                         &cbPrinter ))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                //
                //  Allocate a buffer to hold the printer info 2 information.
                //
                if (pPrinter = (PRINTER_INFO_2 *)LocalAlloc(LPTR, cbPrinter))
                {
                    //
                    //  Get the printer info 2 information.
                    //
                    if (GetPrinter( hPrinter,
                                    2,
                                    (LPBYTE)pPrinter,
                                    cbPrinter,
                                    &cbPrinter ))
                    {
                        //
                        //  Save the port name in the given buffer.
                        //
                        lstrcpyn(pBuffer, pPrinter->pPortName, cchBuffer);
                        pBuffer[cchBuffer - 1] = 0;
                    }
                }
            }
        }

        //
        //  Close the printer.
        //
        ClosePrinter(hPrinter);
    }

    //
    //  Free the printer info 2 information for the current printer.
    //
    if (pPrinter)
    {
        LocalFree(pPrinter);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_GetDevModeWrapper
//
//  Calls PrintGetDevMode.
//
////////////////////////////////////////////////////////////////////////////

HANDLE Print_GetDevModeWrapper(
    LPTSTR pszDeviceName,
    HANDLE hDevMode)
{
#ifdef WINNT
    //
    //  On Win9x, the hPrinter parameter to DocumentProperties can be
    //  NULL.  On NT, it cannot be NULL.
    //
    HANDLE hPrinter;

    if (OpenPrinter(pszDeviceName, &hPrinter, NULL))
    {
        hDevMode = PrintGetDevMode(0, hPrinter, pszDeviceName, NULL);
        ClosePrinter(hPrinter);
    }
#else
    hDevMode = PrintGetDevMode(0, NULL, pszDeviceName, NULL);
#endif

    //
    //  Return the handle to the devmode.
    //
    return (hDevMode);
}


////////////////////////////////////////////////////////////////////////////
//
//  Print_NewPrintDlg
//
//  Converts the old style pPD structure to the new one and then calls
//  the PrintDlgEx function.
//
////////////////////////////////////////////////////////////////////////////

BOOL Print_NewPrintDlg(
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    PRINTINFOEX PIEx;
    PRINTDLGEX PDEx;
    PRINTPAGERANGE PageRange;
    HRESULT hResult;

    //
    //  Set up the PRINTINFOEX structure.
    //
    PIEx.ApiType = pPI->ApiType;
    PIEx.pPD     = &PDEx;
    PIEx.fOld    = TRUE;

    //
    //  Copy the page range.
    //
    PageRange.nFromPage = pPD->nFromPage;
    PageRange.nToPage   = pPD->nToPage;

    //
    //  Set up the PRINTDLGEX structure with the appropriate values from
    //  the PRINTDLG structure.
    //
    PDEx.lStructSize         = sizeof(PRINTDLGEX);
    PDEx.hwndOwner           = pPD->hwndOwner;
    PDEx.hDevMode            = pPD->hDevMode;
    PDEx.hDevNames           = pPD->hDevNames;
    PDEx.hDC                 = pPD->hDC;
    PDEx.Flags               = (pPD->Flags & ~(PD_SHOWHELP | PD_NONETWORKBUTTON)) |
                               (PD_NOCURRENTPAGE);
    PDEx.Flags2              = 0;
    PDEx.ExclusionFlags      = 0;
    PDEx.nPageRanges         = 1;
    PDEx.nMaxPageRanges      = 1;
    PDEx.lpPageRanges        = &PageRange;
    PDEx.nMinPage            = pPD->nMinPage;
    PDEx.nMaxPage            = pPD->nMaxPage;
    PDEx.nCopies             = pPD->nCopies;
    PDEx.hInstance           = pPD->hInstance;
    PDEx.lpCallback          = NULL;
    PDEx.lpPrintTemplateName = NULL;
    PDEx.nPropertyPages      = 0;
    PDEx.lphPropertyPages    = NULL;
    PDEx.nStartPage          = START_PAGE_GENERAL;
    PDEx.dwResultAction      = 0;

    //
    //  Since we're in the old dialog, allow the the hInstance to be
    //  non-NULL even if there is not a template.
    //
    if (!(pPD->Flags & (PD_ENABLEPRINTTEMPLATE | PD_ENABLEPRINTTEMPLATEHANDLE)))
    {
        PDEx.hInstance = NULL;
    }

    //
    //  Initialize the error code to 0.
    //
    StoreExtendedError(CDERR_GENERALCODES);

    //
    //  Call PrintDlgExX to bring up the dialog.
    //
    hResult = PrintDlgExX(&PIEx);

    //
    //  See if the call failed.  If so, store the error and return FALSE.
    //
    if (FAILED(hResult))
    {
        StoreExtendedError(PIEx.dwExtendedError);
        return (FALSE);
    }

    //
    //  The call succeeded, so convert the PRINTDLGEX structure back to
    //  the PRINTDLG structure if PD_RESULT_CANCEL is not set.
    //
    if (PDEx.dwResultAction != PD_RESULT_CANCEL)
    {
        pPD->hDevMode  = PDEx.hDevMode;
        pPD->hDevNames = PDEx.hDevNames;
        pPD->hDC       = PDEx.hDC;
        pPD->Flags     = PDEx.Flags & ~(PD_NOCURRENTPAGE);
        pPD->nFromPage = (WORD)PageRange.nFromPage;
        pPD->nToPage   = (WORD)PageRange.nToPage;
        pPD->nCopies   = (WORD)PDEx.nCopies;
    }

    //
    //  Return TRUE if the user hit Print.
    //
    if (PDEx.dwResultAction == PD_RESULT_PRINT)
    {
        return (TRUE);
    }

    //
    //  Return FALSE for cancel.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::CPrintBrowser
//
//  CPrintBrowser constructor.
//
////////////////////////////////////////////////////////////////////////////

CPrintBrowser::CPrintBrowser(
    HWND hDlg)
    : cRef(1),
      hwndDlg(hDlg),
      hSubDlg(NULL),
      hwndView(NULL),
      psv(NULL),
      psfv(NULL),
      psd(NULL),
      psfRoot(NULL),
      pidlRoot(NULL),
      ppf(NULL),
      pPrintDlgPage(NULL),
      pPI(NULL),
      pPD(NULL),
      pCallback(NULL),
      pSite(NULL),
      pDMInit(NULL),
      pDMCur(NULL),
      cchCurPrinter(0),
      pszCurPrinter(NULL),
      nCopies(1),
      nPageRanges(0),
      nMaxPageRanges(0),
      pPageRanges(NULL),
      fSelChangePending(FALSE),
      fFirstSel(1),
      fCollateRequested(FALSE),
      fAPWSelected(FALSE),
      fNoAccessPrinterSelected(FALSE),
      nInitDone(0),
      nListSep(0),
      uRegister(0)
{
    HMENU hMenu;

    hMenu = GetSystemMenu(hDlg, FALSE);
    DeleteMenu(hMenu, SC_MINIMIZE, MF_BYCOMMAND);
    DeleteMenu(hMenu, SC_MAXIMIZE, MF_BYCOMMAND);
    DeleteMenu(hMenu, SC_RESTORE,  MF_BYCOMMAND);

    szListSep[0] = 0;
    szScratch[0] = 0;

    pDMSave = (LPDEVMODE)GlobalAlloc(GPTR, sizeof(DEVMODE));

    Shell_GetImageLists(NULL, &himl);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::~CPrintBrowser
//
//  CPrintBrowser destructor.
//
////////////////////////////////////////////////////////////////////////////

CPrintBrowser::~CPrintBrowser()
{
    //
    //  Deregister notifications.
    //
    if (uRegister)
    {
        SHChangeNotifyDeregister(uRegister);
        uRegister = 0;
    }

    //
    //  Release the printer folder private interface.
    //
    if (ppf != NULL)
    {
        ppf->Release();
        ppf = NULL;
    }

    //
    //  Release the printer shell folder.
    //
    if (psfRoot != NULL)
    {
        psfRoot->Release();
        psfRoot = NULL;
    }

    //
    //  Free the pidl.
    //
    if (pidlRoot != NULL)
    {
        SHFree(pidlRoot);
        pidlRoot = NULL;
    }

    //
    //  Free the devmodes.
    //
    if (pDMInit)
    {
        GlobalFree(pDMInit);
        pDMInit = NULL;
    }
    if (pDMSave)
    {
        GlobalFree(pDMSave);
        pDMSave = NULL;
    }

    //
    //  Free the current printer buffer.
    //
    cchCurPrinter = 0;
    if (pszCurPrinter)
    {
        GlobalFree(pszCurPrinter);
        pszCurPrinter = NULL;
    }

    //
    //  Free the page range.
    //
    nPageRanges = 0;
    nMaxPageRanges = 0;
    if (pPageRanges)
    {
        GlobalFree(pPageRanges);
        pPageRanges = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::QueryInterface
//
//  Standard OLE2 style methods for this object.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CPrintBrowser::QueryInterface(
    REFIID riid,
    LPVOID *ppvObj)
{
    if (IsEqualIID(riid, IID_IShellBrowser) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IShellBrowser *)this;
        ++cRef;
        return (S_OK);
    }
    else if (IsEqualIID(riid, IID_ICommDlgBrowser))
    {
        *ppvObj = (ICommDlgBrowser2 *)this;
        ++cRef;
        return (S_OK);
    }
    else if (IsEqualIID(riid, IID_ICommDlgBrowser2))
    {
        *ppvObj = (ICommDlgBrowser2 *)this;
        ++cRef;
        return (S_OK);
    }
    else if (IsEqualIID(riid, IID_IPrintDialogServices))
    {
        *ppvObj = (IPrintDialogServices *)this;
        ++cRef;
        return (S_OK);
    }

    *ppvObj = NULL;
    return (E_NOINTERFACE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::AddRef
//
////////////////////////////////////////////////////////////////////////////

ULONG STDMETHODCALLTYPE CPrintBrowser::AddRef()
{
    return (++cRef);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::Release
//
////////////////////////////////////////////////////////////////////////////

ULONG STDMETHODCALLTYPE CPrintBrowser::Release()
{
    cRef--;
    if (cRef > 0)
    {
        return (cRef);
    }

    delete this;

    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetWindow
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::GetWindow(
    HWND *phwnd)
{
    *phwnd = hwndDlg;
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::ContextSensitiveHelp
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::ContextSensitiveHelp(
    BOOL fEnable)
{
    //
    //  Shouldn't need in a common dialog.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InsertMenusSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::InsertMenusSB(
    HMENU hmenuShared,
    LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SetMenuSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::SetMenuSB(
    HMENU hmenuShared,
    HOLEMENU holemenu,
    HWND hwndActiveObject)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::RemoveMenusSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::RemoveMenusSB(
    HMENU hmenuShared)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SetStatusTextSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::SetStatusTextSB(
    LPCOLESTR pwch)
{
    //
    //  We don't have any status bar.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::EnableModelessSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::EnableModelessSB(
    BOOL fEnable)
{
    //
    //  We don't have any modeless window to be enabled/disabled.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::TranslateAcceleratorSB
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::TranslateAcceleratorSB(
    LPMSG pmsg,
    WORD wID)
{
    //
    //  We don't support EXE embedding.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::BrowseObject
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::BrowseObject(
    LPCITEMIDLIST pidl,
    UINT wFlags)
{
    //
    //  We don't support browsing, or more precisely, CDefView doesn't.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetViewStateStream
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::GetViewStateStream(
    DWORD grfMode,
    LPSTREAM *pStrm)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetControlWindow
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::GetControlWindow(
    UINT id,
    HWND *lphwnd)
{
    return (E_NOTIMPL);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SendControlMsg
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::SendControlMsg(
    UINT id,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *pret)
{
    LRESULT lres = 0;

    if (pret)
    {
        *pret = lres;
    }

    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::QueryActiveShellView
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::QueryActiveShellView(
    LPSHELLVIEW *ppsv)
{
    if (psv)
    {
        *ppsv = psv;
        psv->AddRef();
        return (S_OK);
    }

    *ppsv = NULL;
    return (E_NOINTERFACE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnViewWindowActive
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::OnViewWindowActive(
    LPSHELLVIEW psv)
{
    //
    //  No need to process this. We don't do menus.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SetToolbarItems
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::SetToolbarItems(
    LPTBBUTTON lpButtons,
    UINT nButtons,
    UINT uFlags)
{
    //
    //  We don't let containers customize our toolbar.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnDefaultCommand
//
//  Process a double-click or Enter keystroke in the view control.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::OnDefaultCommand(
    struct IShellView *ppshv)
{
    //
    //  Make sure it's the correct shell view.
    //
    if (ppshv != psv)
    {
        return (E_INVALIDARG);
    }

    //
    //  See if the Add Printer Wizard is selected.
    //
    if (fAPWSelected && pPrintDlgPage)
    {
        //
        //  Invoke the Add Printer Wizard (modeless).
        //
        pPrintDlgPage->pPrintDlg->AddPrinterWizard();
    }
    else if (fNoAccessPrinterSelected)
    {
        //
        // Display error message indicated we do not have access.
        //
        ShowError(hwndDlg, IDC_PRINTER_LISTVIEW, iszNoPrinterAccess);
    }
    else
    {
        //
        //  Simulate the pressing of the OK button.
        //
        PropSheet_PressButton(GetParent(hwndDlg), PSBTN_OK);
    }

    //
    //  Tell the shell that the action has been processed.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnStateChange
//
//  Process selection change in the view control.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::OnStateChange(
    struct IShellView *ppshv,
    ULONG uChange)
{
    if (ppshv != psv)
    {
        return (E_INVALIDARG);
    }

    switch (uChange)
    {
        case ( CDBOSC_SETFOCUS ) :
        {
            break;
        }
        case ( CDBOSC_KILLFOCUS ) :
        {
            break;
        }
        case ( CDBOSC_SELCHANGE ) :
        {
            //
            //  Post one of these messages, since we seem to get a whole
            //  bunch of them.
            //
            if (!fSelChangePending)
            {
                fSelChangePending = TRUE;
                PostMessage(hwndDlg, CDM_SELCHANGE, 0, 0);
            }

            break;
        }
        case ( CDBOSC_RENAME ) :
        {
            break;
        }
        default :
        {
            return (E_NOTIMPL);
        }
    }

    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::IncludeObject
//
//  Tell the view control which objects to include in its enumerations.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::IncludeObject(
    struct IShellView *ppshv,
    LPCITEMIDLIST pidl)
{
    //
    //  Make sure it's my shell view.
    //
    if (ppshv != psv)
    {
        return (E_INVALIDARG);
    }

    //
    //  If we have the printer folder private interface, return ok only
    //  if it's a printer.
    //
    if (ppf)
    {
        return (ppf->IsPrinter(pidl) ? S_OK : S_FALSE);
    }

    //
    //  This shouldn't happen at this point, but just in case we don't have
    //  a printer folder private interface, simply return ok.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::Notify
//
//  Notification to decide whether or not a printer should be selected.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::Notify(
    struct IShellView *ppshv,
    DWORD dwNotify)
{
    HRESULT hr = S_OK;

    //
    //  Make sure it's my shell view.
    //
    if (ppshv != psv)
    {
        return (E_INVALIDARG);
    }

    switch (dwNotify)
    {
        case ( CDB2N_CONTEXTMENU_DONE ) :
        {
            SelectSVItem();
            fDontSelectPrinter = FALSE;
            break;
        }
        case ( CDB2N_CONTEXTMENU_START ) :
        {
            fDontSelectPrinter = TRUE;
            break;
        }
        default :
        {
            hr = S_FALSE;
            break;
        }
    }

    //
    //  This shouldn't happen at this point, but just in case we don't have
    //  a printer folder private interface, simply return ok.
    //
    return (hr);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetDefaultMenuText
//
//  Returns the default menu text.
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::GetDefaultMenuText(
    struct IShellView *ppshv,
    WCHAR *pszText,
    INT cchMax)
{
    //
    //  Make sure it's my shell view.
    //
    if (ppshv != psv)
    {
        return (E_INVALIDARG);
    }

    //
    //  If the add printer wizard is the selected item, do not change
    //  the default menu text.
    //
    if (fAPWSelected)
    {
        return (S_FALSE);
    }

    //
    //  Change the default menu text from 'Select' to 'Print'.
    //
    if (!LoadString(g_hinst, iszDefaultMenuText, szScratch, ARRAYSIZE(szScratch)))
    {
        return (E_FAIL);
    }

#ifdef UNICODE
    //
    //  Just copy the default menu text to the provided buffer if there
    //  is room.
    //
    if (lstrlen(szScratch) < cchMax)
    {
        lstrcpyn(pszText, szScratch, cchMax);
    }
    else
    {
        return (E_OUTOFMEMORY);
    }
#else
    //
    //  The shell only accepts the default menu text as a Unicode string,
    //  so we have to convert it from an Ansi string to a Unicode string.
    //
    if (!MultiByteToWideChar( CP_ACP,
                              MB_PRECOMPOSED,
                              szScratch,
                              -1,
                              pszText,
                              cchMax ))
    {
        return (E_FAIL);
    }
#endif

    return (S_OK);
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetViewFlags
//
//  Returns Flags to customize the view .
//
////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPrintBrowser::GetViewFlags(DWORD *pdwFlags)
{
    if (pdwFlags)
    {
        *pdwFlags = 0;
    }
    return S_OK;
}




////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InitDone
//
//  Notifies the sub dialog that initialization of the General page is
//  complete.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CPrintBrowser::InitDone()
{
    HRESULT hResult = S_FALSE;

    //
    //  Notify the sub dialog that initialization is complete.
    //
    if (pCallback)
    {
#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgExW2A(pPI);
        }
#endif

        hResult = pCallback->InitDone();

#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgExA2W(pPI);
        }
#endif
    }

    //
    //  Return the result.
    //
    return (hResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SelectionChange
//
//  Notifies the sub dialog that a selection change has taken place.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CPrintBrowser::SelectionChange()
{
    HRESULT hResult = S_FALSE;

    //
    //  Handle the Print To File here.
    //
    InitPrintToFile();

    //
    //  Notify the sub dialog that a selection change has taken place.
    //
    if (pCallback)
    {
#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgExW2A(pPI);
        }
#endif

        hResult = pCallback->SelectionChange();

#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgExA2W(pPI);
        }
#endif
    }

    //
    //  Handle the selection change.
    //
    if (hResult == S_FALSE)
    {
        //
        //  Handle copies and collate.
        //
        InitCopiesAndCollate();

        //
        //  Handle the page ranges.
        //
        InitPageRangeGroup();

        //
        //  Return success.
        //
        hResult = S_OK;
    }

    //
    //  Return the result.
    //
    return (hResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::HandleMessage
//
//  Process a message for the child window by calling the application
//  callback function.
//
////////////////////////////////////////////////////////////////////////////

HRESULT CPrintBrowser::HandleMessage(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    LRESULT *pResult)
{
    HRESULT hResult = S_FALSE;
    BOOL bTest;
    UINT nRet, ErrorId;
    DWORD nTmpCopies;

    //
    //  Initialize the return value.
    //
    *pResult = FALSE;

    //
    //  See if the message should be handled.
    //
    if (pCallback)
    {
#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgExW2A(pPI);
        }
#endif

        hResult = pCallback->HandleMessage(hDlg, uMsg, wParam, lParam, pResult);

#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgExA2W(pPI);
        }
#endif
    }

    //
    //  Handle the message.
    //
    if ((hResult == S_FALSE) && (uMsg == WM_NOTIFY))
    {
        switch (((LPNMHDR)lParam)->code)
        {
            case ( PSN_KILLACTIVE ) :
            {
                //
                //  Make sure the page has valid entries.
                //  If invalid entries are found, then set the DWL_MSGRESULT
                //  of the General page to be TRUE and return TRUE in order
                //  to prevent the page from losing the activation.
                //

                //
                //  Validate the number of copies and store it in the
                //  nCopies member.
                //
                if ((GetDlgItem(hSubDlg, IDC_COPIES)) &&
                    (fAPWSelected == FALSE))
                {
                    nTmpCopies = nCopies;
                    nCopies = GetDlgItemInt(hSubDlg, IDC_COPIES, &bTest, FALSE);
                    if (!bTest || !nCopies)
                    {
                        nCopies = nTmpCopies;
                        ShowError(hSubDlg, IDC_COPIES, iszCopiesZero);
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                        *pResult = TRUE;
                        return (E_FAIL);
                    }
                }

                //
                //  Validate the page range and store it in the pRange member.
                //
                if (IsDlgButtonChecked(hSubDlg, IDC_RANGE_PAGES) &&
                    GetDlgItem(hSubDlg, IDC_RANGE_EDIT))
                {
                    nRet = GetDlgItemText( hSubDlg,
                                           IDC_RANGE_EDIT,
                                           szScratch,
                                           ARRAYSIZE(szScratch) );
                    ErrorId = iszBadPageRange;
                    if (!nRet || !IsValidPageRange(szScratch, &ErrorId))
                    {
                        ShowError( hSubDlg,
                                   IDC_RANGE_EDIT,
                                   ErrorId,
                                   (ErrorId == iszTooManyPageRanges)
                                     ? nMaxPageRanges
                                     : pPD->nMinPage,
                                   pPD->nMaxPage );
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, TRUE);
                        *pResult = TRUE;
                        return (E_FAIL);
                    }
                }

                //
                //  Message has now been handled.
                //
                hResult = S_OK;

                break;
            }
            case ( PSN_APPLY ) :
            {
                //
                //  Clear the flags that need to be set based on the
                //  contents of the General page.
                //
                pPD->Flags &= ~((DWORD)( PD_PAGENUMS    |
                                         PD_SELECTION   |
                                         PD_CURRENTPAGE ));

                //
                //  Save the page range information.
                //
                if (IsDlgButtonChecked(hSubDlg, IDC_RANGE_SELECTION))
                {
                    pPD->Flags |= PD_SELECTION;
                }
                else if (IsDlgButtonChecked(hSubDlg, IDC_RANGE_CURRENT))
                {
                    pPD->Flags |= PD_CURRENTPAGE;
                }
                else if (IsDlgButtonChecked(hSubDlg, IDC_RANGE_PAGES))
                {
                    pPD->Flags |= PD_PAGENUMS;

                    //
                    //  Copy the page ranges to the pPageRanges structure
                    //  in the PrintDlg structure.
                    //
                    if (GetDlgItem(hSubDlg, IDC_RANGE_EDIT))
                    {
                        pPD->nPageRanges = nPageRanges;
                        CopyMemory( pPD->lpPageRanges,
                                    pPageRanges,
                                    nPageRanges * sizeof(PRINTPAGERANGE) );
                    }
                }

                //
                //  Message has now been handled.
                //
                hResult = S_OK;

                break;
            }
        }
    }

    //
    //  Return the result.
    //
    return (hResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetCurrentDevMode
//
//  Returns the current devmode structure.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CPrintBrowser::GetCurrentDevMode(
    LPDEVMODE pDevMode,
    UINT *pcbSize)
{
    UINT cbSize;

    //
    //  Make sure pcbSize is valid.
    //
    if ((pcbSize == NULL) || (*pcbSize && !pDevMode) || !pPrintDlgPage)
    {
        return (E_INVALIDARG);
    }

    //
    //  When there is no current devmode, set the size to zero and return
    //  TRUE.
    //
    if (!pDMCur)
    {
        *pcbSize = 0;
        return (S_OK);
    }

    //
    //  Save the current printer name and the current devmode in the
    //  class.
    //
    pPrintDlgPage->pPrintDlg->RefreshDevMode();
    GetCurrentPrinter();

    //
    //  See if we just need to get the size of the buffer.
    //
    if (*pcbSize == 0)
    {
        //
        //  Return the size of the buffer needed.
        //
#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            *pcbSize = sizeof(DEVMODEA) + pDMCur->dmDriverExtra;
        }
        else
#endif
        {
            *pcbSize = pDMCur->dmSize + pDMCur->dmDriverExtra;
        }
    }
    else
    {
        //
        //  Make sure the copies and collate information is up to date.
        //
        SaveCopiesAndCollateInDevMode(pDMCur, pszCurPrinter);

        //
        //  Return the devmode information as well as the size of the
        //  buffer.
        //
#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            cbSize = sizeof(DEVMODEA) + pDMCur->dmDriverExtra;
            if (*pcbSize < cbSize)
            {
                return (E_INVALIDARG);
            }
            ThunkDevModeW2A(pDMCur, (LPDEVMODEA)pDevMode);
            *pcbSize = cbSize;
        }
        else
#endif
        {
            cbSize = pDMCur->dmSize + pDMCur->dmDriverExtra;
            if (*pcbSize < cbSize)
            {
                return (E_INVALIDARG);
            }
            CopyMemory(pDevMode, pDMCur, cbSize);
            *pcbSize = cbSize;
        }
    }

    //
    //  Return success.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetCurrentPrinterName
//
//  Returns the current printer name.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CPrintBrowser::GetCurrentPrinterName(
    LPTSTR pPrinterName,
    UINT *pcchSize)
{
    UINT cchSize;

    //
    //  Make sure pcchSize is valid.
    //
    if ((pcchSize == NULL) || (*pcchSize && !pPrinterName))
    {
        return (E_INVALIDARG);
    }

    //
    //  Save the current printer name and the current devmode in the
    //  class.
    //
    GetCurrentPrinter();

    //
    //  When there is no current printer, set the size to zero and return
    //  TRUE.
    //
    if ((pszCurPrinter == NULL) || (pszCurPrinter[0] == 0))
    {
        *pcchSize = 0;
        return (S_OK);
    }

    //
    //  See if we just need to get the size of the buffer.
    //
    if (*pcchSize == 0)
    {
#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            *pcchSize = WideCharToMultiByte( CP_ACP,
                                             0,
                                             pszCurPrinter,
                                             -1,
                                             NULL,
                                             0,
                                             NULL,
                                             NULL );
        }
        else
#endif
        {
            *pcchSize = lstrlen(pszCurPrinter) + 1;
        }
    }
    else
    {
#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            *pcchSize = WideCharToMultiByte( CP_ACP,
                                             0,
                                             pszCurPrinter,
                                             -1,
                                             (LPSTR)pPrinterName,
                                             *pcchSize,
                                             NULL,
                                             NULL );
            if (*pcchSize == 0)
            {
                return (E_INVALIDARG);
            }
        }
        else
#endif
        {
            cchSize = lstrlen(pszCurPrinter) + 1;
            if (*pcchSize < cchSize)
            {
                return (E_INVALIDARG);
            }
            lstrcpy(pPrinterName, pszCurPrinter);
            *pcchSize = cchSize;
        }
    }

    //
    //  Return success.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetCurrentPortName
//
//  Returns the current port name.
//
////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CPrintBrowser::GetCurrentPortName(
    LPTSTR pPortName,
    UINT *pcchSize)
{
    UINT cchSize;
    TCHAR szPortName[MAX_PATH];

    //
    //  Make sure pcchSize is valid.
    //
    if ((pcchSize == NULL) || (*pcchSize && !pPortName))
    {
        return (E_INVALIDARG);
    }

    //
    //  Save the current printer name and the current devmode in the
    //  class.
    //
    GetCurrentPrinter();

    //
    //  When there is no current printer, set the size to zero and return
    //  TRUE.
    //
    if ((pszCurPrinter == NULL) || (pszCurPrinter[0] == 0))
    {
        *pcchSize = 0;
        return (S_OK);
    }

    //
    //  Get the port name for the current printer.
    //
    szPortName[0] = 0;
    Print_GetPortName(pszCurPrinter, szPortName, ARRAYSIZE(szPortName));

    //
    //  See if we just need to get the size of the buffer.
    //
    if (*pcchSize == 0)
    {
#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            *pcchSize = WideCharToMultiByte( CP_ACP,
                                             0,
                                             szPortName,
                                             -1,
                                             NULL,
                                             0,
                                             NULL,
                                             NULL );
        }
        else
#endif
        {
            *pcchSize = lstrlen(szPortName) + 1;
        }
    }
    else
    {
#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            *pcchSize = WideCharToMultiByte( CP_ACP,
                                             0,
                                             szPortName,
                                             -1,
                                             (LPSTR)pPortName,
                                             *pcchSize,
                                             NULL,
                                             NULL );
            if (*pcchSize == 0)
            {
                return (E_INVALIDARG);
            }
        }
        else
#endif
        {
            cchSize = lstrlen(szPortName) + 1;
            if (*pcchSize < cchSize)
            {
                return (E_INVALIDARG);
            }
            lstrcpy(pPortName, szPortName);
            *pcchSize = cchSize;
        }
    }

    //
    //  Return success.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnInitDialog
//
//  Process a WM_INITDIALOG message for the General page.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnInitDialog(
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hCtl;
    LPDEVMODE pDM;
    LPDEVNAMES pDN;
    UINT Result;
    HRESULT hResult;
    SHChangeNotifyEntry fsne;

    //
    //  Make sure these ids are actually hidden.  Otherwise, we get some
    //  strange repainting problems.
    //
    ShowWindow(GetDlgItem(hwndDlg, IDC_PRINTER_LIST), SW_HIDE);
    ShowWindow(GetDlgItem(hwndDlg, grp2), SW_HIDE);

    //
    //  Get the pointer to the PRINTDLG_PAGE structure from the lParam of
    //  the property sheet structure.
    //
    pPrintDlgPage = (PPRINTDLG_PAGE)((LPPROPSHEETPAGE)lParam)->lParam;
    if (pPrintDlgPage == NULL)
    {
        return (FALSE);
    }

    //
    //  Save the Init info.
    //
    pPI = (PPRINTINFOEX)pPrintDlgPage->lParam;
    pPD = pPI->pPD;

    //
    //  Initialize the error codes to success now that we have the
    //  pPI structure.
    //
    pPI->dwExtendedError = CDERR_GENERALCODES;
    pPI->hResult = S_OK;

    //
    //  Create the printer folder shell view.
    //
    hResult = CreatePrintShellView();
    if (FAILED(hResult))
    {
        pPI->hResult = hResult;
        return (FALSE);
    }

    //
    //  Insert the device pages for the appropriate printer.
    //
    //  First:  Try the printer in the DevMode.
    //  Second: Try the printer in the DevNames.
    //  Third:  Use the default by passing in NULLs.
    //
    Result = kError;
    if ((pPD->hDevMode) && (pDM = (LPDEVMODE)GlobalLock(pPD->hDevMode)))
    {
        DWORD cbSize = (DWORD)(pDM->dmSize + pDM->dmDriverExtra);

        if (pDMInit = (LPDEVMODE)GlobalAlloc(GPTR, cbSize))
        {
            CopyMemory(pDMInit, pDM, cbSize);
        }
        GlobalUnlock(pPD->hDevMode);

        Result = pPrintDlgPage->pPrintDlg->InsertDevicePage(
                                             (LPTSTR)(pDMInit->dmDeviceName),
                                             pDMInit );
    }
    if ((Result != kSuccess) &&
        (pPD->hDevNames) && (pDN = (LPDEVNAMES)GlobalLock(pPD->hDevNames)))
    {
        LPTSTR pPrinter = (LPTSTR)pDN + pDN->wDeviceOffset;

        Result = pPrintDlgPage->pPrintDlg->InsertDevicePage(pPrinter, NULL);
        GlobalUnlock(pPD->hDevNames);
    }
    if (Result != kSuccess)
    {
        Result = pPrintDlgPage->pPrintDlg->InsertDevicePage(NULL, NULL);
    }

    //
    //  Get the current printer name and the current devmode.
    //
    GetCurrentPrinter();

    //
    //  Initialize the "Print to file" check box appropriately.
    //
    if (hCtl = GetDlgItem(hwndDlg, IDC_PRINT_TO_FILE))
    {
        if (pPD->Flags & PD_PRINTTOFILE)
        {
            CheckDlgButton(hwndDlg, IDC_PRINT_TO_FILE, TRUE);
        }

        if (pPD->Flags & PD_HIDEPRINTTOFILE)
        {
            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);
        }
        else if (pPD->Flags & PD_DISABLEPRINTTOFILE)
        {
            EnableWindow(hCtl, FALSE);
        }
    }

    //
    //  Set the number of copies and the collation correctly.
    //
    pDM = pDMInit ? pDMInit : pDMCur;

    if (pDMCur && (pDMCur->dmFields & DM_COPIES))
    {
        if (pDMInit || (pPD->Flags & PD_USEDEVMODECOPIESANDCOLLATE))
        {
            pPD->nCopies = (DWORD)pDM->dmCopies;
        }
        else if (pPD->nCopies)
        {
            pDMCur->dmCopies = (short)pPD->nCopies;
        }
    }

    if (pDMCur && (pDMCur->dmFields & DM_COLLATE))
    {
        if (pDMInit || (pPD->Flags & PD_USEDEVMODECOPIESANDCOLLATE))
        {
            if (pDM->dmCollate == DMCOLLATE_FALSE)
            {
                pPD->Flags &= ~PD_COLLATE;
            }
            else
            {
                pPD->Flags |= PD_COLLATE;
            }
        }
        else
        {
            pDMCur->dmCollate = (pPD->Flags & PD_COLLATE)
                                    ? DMCOLLATE_TRUE
                                    : DMCOLLATE_FALSE;
        }
    }
    if (pPD->Flags & PD_COLLATE)
    {
        fCollateRequested = TRUE;
    }

    //
    //  Create the hook dialog.
    //
    hResult = CreateHookDialog();
    if (FAILED(hResult))
    {
        pPI->hResult = hResult;
        return (FALSE);
    }

    //
    //  Set the ClipChildren style bit on the main dialog so that we get
    //  proper repainting of the various children in the General page.
    //
    SetWindowLong( GetParent(hwndDlg),
                   GWL_STYLE,
                   GetWindowLong(GetParent(hwndDlg), GWL_STYLE) | WS_CLIPCHILDREN );

    //
    //  Set the OK button to Print.
    //
    LoadString(g_hinst, iszPrintButton, szScratch, ARRAYSIZE(szScratch));
    SetDlgItemText(GetParent(hwndDlg), IDOK, szScratch);

    //
    //  Disable the Apply button.
    //
    PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

    //
    //  Register change notifications.
    //
    if (pidlRoot)
    {
        fsne.pidl = pidlRoot;
        fsne.fRecursive = FALSE;

        uRegister = SHChangeNotifyRegister(
                        hwndDlg,
                        SHCNRF_NewDelivery | SHCNRF_ShellLevel |
                            SHCNRF_InterruptLevel,
                        SHCNE_ATTRIBUTES | SHCNE_UPDATEITEM | SHCNE_CREATE |
                            SHCNE_DELETE,
                        CDM_PRINTNOTIFY,
                        1,
                        &fsne );
    }

    //
    // If we failed to insert the device page then tell the 
    // user what is wrong.  Basically two messages, either there isn't
    // a printer installed or they do not have access to the selected
    // printer.
    //
    if (Result != kSuccess || !pDMCur )
    {
        if( Result == kAccessDenied )
        {
            PostMessage(hwndDlg, CDM_NOPRINTERS, (WPARAM)hwndDlg, iszNoPrinterAccess );
        }
        else
        {
            PostMessage(hwndDlg, CDM_NOPRINTERS, (WPARAM)hwndDlg, iszNoPrinters );
        }
    }

    //
    //  Give the application the pointer to the IPrintDialogServices
    //  interface.
    //
    if (pPD->lpCallback)
    {
        pPD->lpCallback->QueryInterface(IID_IObjectWithSite, (LPVOID *)&pSite);
        if (pSite)
        {
            pSite->SetSite((IPrintDialogServices *)this);
        }
    }

    //
    //  Initialization is complete.
    //
    PostMessage(hwndDlg, CDM_INITDONE, 0, 0);

    //
    //  Return success.
    //
    return (TRUE);
}



////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnChildInitDialog
//
//  Process a WM_INITDIALOG message for the child window.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnChildInitDialog(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam)
{
    WORD wCheckID;
    HWND hCtl;

    //
    //  Save the handle to the child window.
    //
    hSubDlg = hDlg;

    //
    //  Get the list separator for the current user locale.
    //
    nListSep = GetLocaleInfo( LOCALE_USER_DEFAULT,
                              LOCALE_SLIST,
                              szListSep,
                              ARRAYSIZE(szListSep) );
    if (nListSep == 0)
    {
        szListSep[0] = TEXT(',');
        szListSep[1] = 0;
        nListSep = 2;
    }
    nListSep--;

    //
    //  Set the number of copies.
    //
    pPD->nCopies = max(pPD->nCopies, 1);
    pPD->nCopies = min(pPD->nCopies, 9999);
    SetDlgItemInt(hSubDlg, IDC_COPIES, pPD->nCopies, FALSE);
    nCopies = pPD->nCopies;

    if ((hCtl = GetDlgItem(hSubDlg, IDC_COPIES)) &&
        (GetWindowLong(hCtl, GWL_STYLE) & WS_VISIBLE))
    {
        //
        //  "9999" is the maximum value.
        //
        Edit_LimitText(hCtl, COPIES_EDIT_SIZE);

        CreateUpDownControl( WS_CHILD | WS_BORDER | WS_VISIBLE |
                                 UDS_ALIGNRIGHT | UDS_SETBUDDYINT |
                                 UDS_NOTHOUSANDS | UDS_ARROWKEYS,
                             0,
                             0,
                             0,
                             0,
                             hSubDlg,
                             9999,
                             g_hinst,
                             hCtl,
                             9999,
                             1,
                             pPD->nCopies );

        //
        // Adjust the width of the copies edit control using the current
        // font and the scroll bar width.  This is necessary to handle the 
        // the up down control from encroching on the space in the edit
        // control when we are in High Contrast (extra large) mode.
        //
        SetCopiesEditWidth( hSubDlg, hCtl );
    }

    //
    //  Make sure the collate icon is centered.  Only want to do this once.
    //
    if (hCtl = GetDlgItem(hSubDlg, IDI_COLLATE))
    {
        SetWindowLong( hCtl,
                       GWL_STYLE,
                       GetWindowLong(hCtl, GWL_STYLE) | SS_CENTERIMAGE );
    }

    //
    //  Initialize the copies and collate info.
    //
    InitCopiesAndCollate();

    //
    //  Set the page range.
    //
    if (pPD->Flags & PD_NOPAGENUMS)
    {
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_PAGES), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_EDIT), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_TEXT1), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_TEXT2), FALSE);

        pPD->Flags &= ~((DWORD)PD_PAGENUMS);
    }
    else
    {
        //
        //  See if the page range only consists of one page.  If so,
        //  disable the Pages radio button and the associated edit control
        //  and disable and hide the collate check box.
        //
        if (pPD->nMinPage == pPD->nMaxPage)
        {
            EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_PAGES), FALSE);
            EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_EDIT), FALSE);

            pPD->Flags &= ~((DWORD)(PD_PAGENUMS | PD_COLLATE));
            fCollateRequested = FALSE;
            EnableWindow(GetDlgItem(hSubDlg, IDC_COLLATE), FALSE);
            ShowWindow(GetDlgItem(hSubDlg, IDC_COLLATE), SW_HIDE);
        }
        else
        {
            //
            //  Initialize the page range members.
            //
            nPageRanges = pPD->nPageRanges;
            nMaxPageRanges = pPD->nMaxPageRanges;
            pPageRanges = (LPPRINTPAGERANGE)
                          GlobalAlloc(GPTR, nMaxPageRanges * sizeof(PRINTPAGERANGE));
            if (!pPageRanges)
            {
                pPI->dwExtendedError = CDERR_MEMALLOCFAILURE;
                pPI->hResult = E_OUTOFMEMORY;
                return (FALSE);
            }
            CopyMemory( pPageRanges,
                        pPD->lpPageRanges,
                        nPageRanges * sizeof(PRINTPAGERANGE) );

            //
            //  See if we should only accept a single page range.
            //
            if (nMaxPageRanges == 1)
            {
                hCtl = GetDlgItem(hSubDlg, IDC_RANGE_TEXT2);
                ShowWindow(hCtl, SW_SHOW);
                EnableWindow(hCtl, TRUE);

                hCtl = GetDlgItem(hSubDlg, IDC_RANGE_TEXT1);
                EnableWindow(hCtl, FALSE);
                ShowWindow(hCtl, SW_HIDE);
            }
            else
            {
                hCtl = GetDlgItem(hSubDlg, IDC_RANGE_TEXT1);
                ShowWindow(hCtl, SW_SHOW);
                EnableWindow(hCtl, TRUE);

                hCtl = GetDlgItem(hSubDlg, IDC_RANGE_TEXT2);
                EnableWindow(hCtl, FALSE);
                ShowWindow(hCtl, SW_HIDE);
            }

            //
            //  Validate the page ranges.
            //
            if (!ConvertPageRangesToString(szScratch, ARRAYSIZE(szScratch)))
            {
                pPI->dwExtendedError = PDERR_INITFAILURE;
                pPI->hResult = E_INVALIDARG;
                return (FALSE);
            }

            //
            //  Put the page range string in the edit control.
            //
            if (GetDlgItem(hSubDlg, IDC_RANGE_EDIT))
            {
                SetDlgItemText(hSubDlg, IDC_RANGE_EDIT, szScratch);
            }
        }
    }

    //
    //  See if we should disable the Selection radio button.
    //
    if (pPD->Flags & PD_NOSELECTION)
    {
        if (hCtl = GetDlgItem(hSubDlg, IDC_RANGE_SELECTION))
        {
            EnableWindow(hCtl, FALSE);
        }
        pPD->Flags &= ~((DWORD)PD_SELECTION);
    }

    //
    //  See if we should disable the Current Page radio button.
    //
    if (pPD->Flags & PD_NOCURRENTPAGE)
    {
        if (hCtl = GetDlgItem(hSubDlg, IDC_RANGE_CURRENT))
        {
            EnableWindow(hCtl, FALSE);
        }
        pPD->Flags &= ~((DWORD)PD_CURRENTPAGE);
    }

    //
    //  Choose one of the page range radio buttons.
    //
    if (pPD->Flags & PD_PAGENUMS)
    {
        wCheckID = IDC_RANGE_PAGES;
    }
    else if (pPD->Flags & PD_SELECTION)
    {
        wCheckID = IDC_RANGE_SELECTION;
    }
    else if (pPD->Flags & PD_CURRENTPAGE)
    {
        wCheckID = IDC_RANGE_CURRENT;
    }
    else    // PD_ALL
    {
        wCheckID = IDC_RANGE_ALL;
    }
    CheckRadioButton(hSubDlg, IDC_RANGE_ALL, IDC_RANGE_PAGES, (int)wCheckID);

    //
    //  See if the collate check box should be checked or not.
    //
    if (pPD->Flags & PD_COLLATE)
    {
        CheckDlgButton(hSubDlg, IDC_COLLATE, TRUE);
    }

    //
    //  Display the appropriate collate icon.
    //
    if ((GetWindowLong( GetDlgItem(hSubDlg, IDC_COLLATE),
                        GWL_STYLE ) & WS_VISIBLE) &&
        (hCtl = GetDlgItem(hSubDlg, IDI_COLLATE)))
    {
        ShowWindow(hCtl, SW_HIDE);
        SendMessage( hCtl,
                     STM_SETICON,
                     IsDlgButtonChecked(hSubDlg, IDC_COLLATE)
                         ? (LONG_PTR)hIconCollate
                         : (LONG_PTR)hIconNoCollate,
                     0L );
        ShowWindow(hCtl, SW_SHOW);
    }

    //
    //  Save the flags as they are now so I know what to enable
    //  when the selection changes from the Add Printer Wizard icon.
    //
    pPI->dwFlags = pPD->Flags;
    if (pPD->nMinPage == pPD->nMaxPage)
    {
        pPI->dwFlags |= PD_NOPAGENUMS;
    }

    //
    //  Disable the Apply button.
    //
    PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

    //
    //  Initialization is complete.
    //
    PostMessage(hwndDlg, CDM_INITDONE, 0, 0);

    //
    //  Return success.
    //
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnDestroyMessage
//
//  Process a WM_DESTROY message for the General page.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::OnDestroyMessage()
{
    if (psfv)
    {
        psfv->Release();
        psfv = NULL;
    }
    if (psv)
    {
        psv->DestroyViewWindow();
        psv->Release();
        psv = NULL;
    }
    if (psd)
    {
        psd->Release();
        psd = NULL;
    }
    if (pCallback)
    {
        pCallback->Release();
        pCallback = NULL;
    }
    if (pSite)
    {
        pSite->SetSite(NULL);
        pSite->Release();
        pSite = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnCommandMessage
//
//  Process a WM_COMMAND message for the General page.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnCommandMessage(
    WPARAM wParam,
    LPARAM lParam)
{

    switch (LOWORD(wParam))
    {
        case ( IDC_FIND_PRINTER ) :
        {
            if (pPrintDlgPage)
            {
                //
                //  Turn on the hour glass.
                //
                HourGlass(TRUE);

                //
                //  Bring up the Find Printer dialog.
                //
                szScratch[0] = 0;
                if (pPrintDlgPage->pPrintDlg->FindPrinter(
                                                  hwndDlg,
                                                  szScratch,
                                                  ARRAYSIZE(szScratch) ) &&
                    (szScratch[0] != 0))
                {
                    //
                    //  Add the appropriate device pages and select the
                    //  newly found printer.
                    //
                    if (!MergeDevMode(szScratch))
                    {
                        pPrintDlgPage->pPrintDlg->InsertDevicePage(szScratch, NULL);
                    }
                    if (!fSelChangePending)
                    {
                        fFirstSel = 2;
                        fSelChangePending = TRUE;
                        PostMessage(hwndDlg, CDM_SELCHANGE, 0, 0);
                    }
                }

                //
                //  Turn off the hour glass.
                //
                HourGlass(FALSE);
            }

            break;
        }
        case ( IDC_PRINT_TO_FILE ) :
        {
            //
            //  Enable the Apply button.
            //
            PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

            break;
        }
        case ( IDC_REFRESH ) :
        {
            if (psv)
            {
                psv->Refresh();
            }

            break;
        }
        default :
        {
            break;
        }
    }

    //
    //  Return FALSE.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnChildCommandMessage
//
//  Process a WM_COMMAND message for the child window.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnChildCommandMessage(
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hCtl;
    RECT rc;
    DWORD nTmpCopies;
    BOOL bTest;

    switch (LOWORD(wParam))
    {
        case ( IDC_RANGE_ALL ) :            // Print Range - All
        case ( IDC_RANGE_SELECTION ) :      // Print Range - Selection
        case ( IDC_RANGE_CURRENT ) :        // Print Range - Current Page
        case ( IDC_RANGE_PAGES ) :          // Print Range - Pages
        {
            CheckRadioButton( hSubDlg,
                              IDC_RANGE_ALL,
                              IDC_RANGE_PAGES,
                              GET_WM_COMMAND_ID(wParam, lParam) );

            //
            //  Only move the focus to the "Pages" edit control when
            //  the up/down arrow is NOT used.
            //
            if ( !IS_KEY_PRESSED(VK_UP) &&
                 !IS_KEY_PRESSED(VK_DOWN) &&
                 ((BOOL)(GET_WM_COMMAND_ID(wParam, lParam) == IDC_RANGE_PAGES)) )
            {
                SendMessage( hSubDlg,
                             WM_NEXTDLGCTL,
                             (WPARAM)GetDlgItem(hSubDlg, IDC_RANGE_EDIT),
                             1L );
            }

            //
            //  Enable the Apply button.
            //
            PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

            break;
        }
        case ( IDC_RANGE_EDIT ) :           // Print Range - Pages edit control
        {
            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
            {
                CheckRadioButton( hSubDlg,
                                  IDC_RANGE_ALL,
                                  IDC_RANGE_PAGES,
                                  IDC_RANGE_PAGES );

                //
                //  Enable the Apply button.
                //
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            }

            break;
        }
        case ( IDC_COPIES ) :
        {
            if ((GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE) &&
                (fAPWSelected == FALSE))
            {
                //
                //  Save the number of copies.
                //
                nTmpCopies = nCopies;
                nCopies = GetDlgItemInt(hSubDlg, IDC_COPIES, &bTest, FALSE);
                if (!bTest || !nCopies)
                {
                    nCopies = nTmpCopies;
                }

                //
                //  If the copy count is > 1, enable collate.  Otherwise,
                //  disable it.
                //
                if (hCtl = GetDlgItem(hSubDlg, IDC_COLLATE))
                {
                    EnableWindow(hCtl, (nCopies > 1));
                }

                //
                //  Enable the Apply button.
                //
                PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
            }

            break;
        }
        case ( IDC_COLLATE ) :
        {
            fCollateRequested = (IsDlgButtonChecked(hSubDlg, IDC_COLLATE))
                                    ? TRUE
                                    : FALSE;

            if (hCtl = GetDlgItem(hSubDlg, IDI_COLLATE))
            {
                ShowWindow(hCtl, SW_HIDE);
                SendMessage( hCtl,
                             STM_SETICON,
                             fCollateRequested
                                 ? (LONG_PTR)hIconCollate
                                 : (LONG_PTR)hIconNoCollate,
                             0L );
                ShowWindow(hCtl, SW_SHOW);

                //
                //  Make it redraw to get rid of the old one.
                //
                GetWindowRect(hCtl, &rc);
                MapWindowRect(NULL, hwndDlg, &rc);
                RedrawWindow(hwndDlg, &rc, NULL, RDW_ERASE | RDW_INVALIDATE);
            }

            //
            //  Enable the Apply button.
            //
            PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

            break;
        }
        default :
        {
            break;
        }
    }

    //
    //  Return FALSE.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnNotifyMessage
//
//  Process WM_NOTIFY messages for the General page.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnNotifyMessage(
    WPARAM wParam,
    LPNMHDR pnm)
{
    HWND hCtl;
    LPDEVMODE pDM;
    LPDEVNAMES pDN;
    LRESULT lResult;

    switch (pnm->code)
    {
        case ( PSN_SETACTIVE ) :
        {
            break;
        }
        case ( PSN_KILLACTIVE ) :
        {
            //
            //  Validation of the copies and page range values is done
            //  in the HandleMessage function for the sub dialog.
            //
            break;
        }
        case ( PSN_APPLY ) :
        {
            //
            //  Make sure all of the driver pages are up to date.
            //
            if (pPrintDlgPage && pDMCur)
            {
                if (!pPrintDlgPage->pPrintDlg->DriverApplyNow())
                {
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    return (TRUE);
                }
            }

            //
            //  Save the current printer information.
            //
            if (!GetCurrentPrinter() || !pDMCur)
            {
                ShowError(hwndDlg, IDC_PRINTER_LISTVIEW, iszNoPrinterSelected);
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                return (TRUE);
            }

            //
            //  Clear the flags that need to be set based on the contents
            //  of the General page.
            //
            pPD->Flags &= ~((DWORD)( PD_PRINTTOFILE |
                                     PD_COLLATE     |
                                     PD_PAGENUMS    |
                                     PD_SELECTION   |
                                     PD_CURRENTPAGE ));

            //
            //  Save the collate information.
            //
            if ((hCtl = GetDlgItem(hSubDlg, IDC_COLLATE)) &&
                (fAPWSelected == FALSE))
            {
                if (IsDlgButtonChecked(hSubDlg, IDC_COLLATE))
                {
                    pPD->Flags |= PD_COLLATE;
                }
                else
                {
                    pPD->Flags &= ~PD_COLLATE;
                }
            }

            //
            //  Save the number of copies.
            //
            if ((hCtl = GetDlgItem(hSubDlg, IDC_COPIES)) &&
                (fAPWSelected == FALSE))
            {
                pPD->nCopies = nCopies;
                if (!SetCopiesOnApply())
                {
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    return (TRUE);
                }
            }

            //
            //  Save the info that the user hit OK.
            //
            pPI->FinalResult = 1;
            pPI->fApply = TRUE;

            //
            //  Save the DevMode information.
            //
            SaveDevMode();

            //
            //  Save the DevNames information.
            //
            if (!Print_SaveDevNames(pszCurPrinter, pPD))
            {
                pPI->dwExtendedError = CDERR_MEMALLOCFAILURE;
                pPI->hResult = E_OUTOFMEMORY;
                pPI->FinalResult = 0;
            }

            //
            //  Save the print to file information.
            //
            if (IsDlgButtonChecked(hwndDlg, IDC_PRINT_TO_FILE))
            {
                pPD->Flags |= PD_PRINTTOFILE;
            }

            //
            //  Save the hDC or hIC, depending on which flag is set.
            //
            if (pPI->FinalResult)
            {
                pDM = (LPDEVMODE)GlobalLock(pPD->hDevMode);
                pDN = (LPDEVNAMES)GlobalLock(pPD->hDevNames);
                if (pDM && pDN)
                {
                    PrintReturnICDC((LPPRINTDLG)pPD, pDN, pDM);
                }
                if (pDM)
                {
                    GlobalUnlock(pPD->hDevMode);
                }
                if (pDN)
                {
                    GlobalUnlock(pPD->hDevNames);
                }
            }

            //
            //  Save the view mode for the printer folder.
            //
            SetViewMode();

            //
            //  Disable the Apply button.
            //
            PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

            break;
        }

        case ( PSN_QUERYCANCEL ) :
        {
            break;
        }

        case ( PSN_RESET ) :
        {
            //
            //  Save the info that the user hit CANCEL.
            //
            pPI->FinalResult = 0;

            //
            //  Save the view mode for the printer folder.
            //
            SetViewMode();

            //
            //  Handle the case where the user saved the settings for a
            //  printer, deleted the printer, and then hit cancel.
            //
            if (pPI->fApply)
            {
                if ((pPD->hDevNames) &&
                    (pDN = (LPDEVNAMES)GlobalLock(pPD->hDevNames)))
                {
                    LPTSTR pPrinter = (LPTSTR)pDN + pDN->wDeviceOffset;

                    if (!IsPrinterInList(pPrinter))
                    {
                        ShowError(hwndDlg, 0, iszNoLongerInList, pPrinter);
                        GlobalUnlock(pPD->hDevNames);
                        pPI->fApply = FALSE;
                    }
                    GlobalUnlock(pPD->hDevNames);
                }
            }

            break;
        }
        default :
        {
            break;
        }
    }

    //
    //  Notify the sub dialog.
    //
    if (Print_IsInRange(pnm->code, PSN_LAST, PSN_FIRST) &&
        (HandleMessage(hSubDlg, WM_NOTIFY, wParam, (LPARAM)pnm, &lResult) !=
             S_FALSE))
    {
        // 
        // ISSUE: The return from a dlgproc is different than a winproc.

        return (BOOLFROMPTR(lResult) );
    }

    //
    //  Return FALSE.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnSelChange
//
//  Process a CDM_SELCHANGE message for the dialog.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnSelChange()
{
    HRESULT hres;
    LPCITEMIDLIST *ppidlSel = NULL;
    UINT uItems = 0;
    UINT uCount = 0;
    TCHAR szPrinter[MAX_PATH * 2];
    BOOL bChanged = FALSE;
    UINT rc = kSuccess;

    //
    //  We get this message during init, so use it to set the
    //  initial selection.
    //
    if (fFirstSel)
    {
        //
        //  Select the appropriate item in the list view.
        //
        //  If an item cannot be selected, it probably means that the
        //  printer that was passed in has been deleted.  In this case,
        //  insert the driver pages and select the default printer.
        //
        if (!SelectSVItem())
        {
            //
            //  Insert the device page for the default printer.
            //
            if (pPrintDlgPage)
            {
                if (pPrintDlgPage->pPrintDlg->InsertDevicePage(NULL, NULL) != kSuccess )
                {
                    pPrintDlgPage->pPrintDlg->RemoveDevicePage();
                }
            }

            //
            //  Get the current printer and select the appropriate item
            //  in the list view.
            //
            SelectSVItem();
        }

        //
        //  Notify the sub dialog that the selection changed.
        //
        SelectionChange();

        //
        //  Disable the Apply button if it's the very first time
        //  (during initialization).
        //
        if (fFirstSel == 1)
        {
            PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);
        }

        //
        //  Reset the flags.
        //
        fFirstSel = 0;
        fSelChangePending = FALSE;

        //
        //  Return success.
        //
        return (TRUE);
    }

    //
    //  Reset the flag.
    //
    fSelChangePending = FALSE;

    //
    //  Make sure we have the shell folder view interface.
    //
    if (!psfv)
    {
        return (FALSE);
    }

    //
    //  Get the selected object in the print folder.
    //
    hres = psfv->GetSelectedObjects(&ppidlSel, &uItems);
    if (SUCCEEDED(hres) && (uItems > 0) && ppidlSel && *ppidlSel)
    {
        //
        //  Get the printer name.
        //
        szPrinter[0] = 0;
        GetViewItemText( psfRoot,
                         *ppidlSel,
                         szPrinter,
                         ARRAYSIZE(szPrinter),
                         SHGDN_FORPARSING);

        //
        //  See if it's the Add Printer Wizard.
        //
        if (lstrcmpi(szPrinter, TEXT("WinUtils_NewObject")) == 0)
        {
            //
            //  It's the Add Printer Wizard.
            //
            fAPWSelected = TRUE;

            //
            //  Disable the OK and Apply buttons.
            //
            EnableWindow(GetDlgItem(GetParent(hwndDlg), IDOK), FALSE);
            PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

            //
            //  Save the current devmode settings for selection changes.
            //
            if (pDMCur && pDMSave)
            {
                CopyMemory( pDMSave,
                            pDMCur,
                            (pDMCur->dmSize > sizeof(DEVMODE))
                                ? sizeof(DEVMODE)
                                : pDMCur->dmSize );
            }

            //
            //  Remove the device pages, since no printer is selected.
            //
            if (pPrintDlgPage)
            {
                if (pPrintDlgPage->pPrintDlg->RemoveDevicePage() == kSuccess)
                {
                    bChanged = TRUE;
                }
            }

            //
            //  Update the current printer information and the printer
            //  status text (all should be empty).
            //
            GetCurrentPrinter();
            UpdateStatus(NULL);

            //
            //  Notify the sub dialog that the selection changed.
            //
            if (bChanged)
            {
                SelectionChange();
                bChanged = FALSE;
            }
        }
        else
        {
            //
            //  It's not the Add Printer Wizard.
            //
            fAPWSelected = FALSE;

            //
            //  Make sure the OK button is enabled.
            //
            EnableWindow(GetDlgItem(GetParent(hwndDlg), IDOK), TRUE);

            //
            //  Insert the device pages for the selected printer.
            //
            if (pPrintDlgPage)
            {
                if (!MergeDevMode(szPrinter))
                {
                    rc = pPrintDlgPage->pPrintDlg->InsertDevicePage( szPrinter,
                                                                     NULL );
                }
                if (rc == kSuccess)
                {
                    bChanged = TRUE;
                }
                else 
                {
                    pPrintDlgPage->pPrintDlg->RemoveDevicePage();
                }
            }

            //
            //  Get the current printer name and the current devmode and
            //  update the printer status text.
            //
            GetCurrentPrinter();

            if( rc == kSuccess )
            {
                //
                // Clear the no access printer flag.
                //
                fNoAccessPrinterSelected = FALSE;

                //
                //  Make sure the OK button is enabled.
                //
                EnableWindow(GetDlgItem(GetParent(hwndDlg), IDOK), TRUE);

                //
                // Update the printer status.
                //
                UpdateStatus(*ppidlSel);
            }
            else
            {
                //
                // Save the fact we do not have access to this printer.
                //
                if( rc == kAccessDenied )
                {
                    fNoAccessPrinterSelected = TRUE;
                }

                //
                //  Disable the OK and Apply buttons.
                //
                EnableWindow(GetDlgItem(GetParent(hwndDlg), IDOK), FALSE);
                PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

                //
                // Nuke the status.
                //
                UpdateStatus(NULL);
            }
        }

        //
        //  Free the pidl.
        //
        LocalFree(ppidlSel);
    }
    else if (fDontSelectPrinter == FALSE)
    {
        //
        //  Get the number of objects in the list view.
        //
        hres = psfv->GetObjectCount(&uCount);
        if (FAILED(hres) || !uCount)
        {
            //
            //  This should not happen, but just in case.
            //  It's not the Add Printer Wizard.
            //
            fAPWSelected = FALSE;

            //
            //  Disable the OK and Apply buttons.
            //
            EnableWindow(GetDlgItem(GetParent(hwndDlg), IDOK), FALSE);
            PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

            //
            //  Save the current devmode settings for selection changes.
            //
            if (pDMCur && pDMSave)
            {
                CopyMemory( pDMSave,
                            pDMCur,
                            (pDMCur->dmSize > sizeof(DEVMODE))
                                ? sizeof(DEVMODE)
                                : pDMCur->dmSize );
            }

            //
            //  Remove the device pages, since there are no printers.
            //
            if (pPrintDlgPage)
            {
                if (pPrintDlgPage->pPrintDlg->RemoveDevicePage() == kSuccess)
                {
                    bChanged = TRUE;
                }
            }

            //
            //  Update the current printer information and the printer
            //  status text (all should be empty).
            //
            GetCurrentPrinter();
            UpdateStatus(NULL);

            //
            //  Notify the sub dialog that the selection changed.
            //
            if (bChanged)
            {
                SelectionChange();
                bChanged = FALSE;
            }
        }
        else if (fAPWSelected == FALSE)
        {
            //
            //  Make sure the OK button is enabled.
            //
            EnableWindow(GetDlgItem(GetParent(hwndDlg), IDOK), TRUE);

            //
            //  Select the appropriate item in the list view.
            //
            if (!SelectSVItem())
            {
                //
                //  Insert the device pages for the default printer.
                //
                if (pPrintDlgPage)
                {
                    if (!MergeDevMode(NULL))
                    {
                        rc = pPrintDlgPage->pPrintDlg->InsertDevicePage(NULL, NULL);
                    }
                    if (rc == kSuccess)
                    {
                        bChanged = TRUE;
                    }
                    else 
                    {
                        pPrintDlgPage->pPrintDlg->RemoveDevicePage();
                    }
                }
                SelectSVItem();
            }
        }
        else
        {
            //
            //  Nothing is currently selected, but the Add Printer Wizard
            //  was the last thing that had been selected.
            //  Select the Add Printer Wizard.
            //
            SelectSVItem();
        }
    }

    //
    //  See if anything changed.
    //
    if (bChanged)
    {
        //
        //  Enable the Apply button.
        //
        PropSheet_Changed(GetParent(hwndDlg), hwndDlg);

        //
        //  Notify the sub dialog that the selection changed.
        //
        SelectionChange();
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnChangeNotify
//
//  Handle the change notification message.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnChangeNotify(
    LONG lNotification,
    LPCITEMIDLIST *ppidl)
{
    LPCITEMIDLIST pidl;
    UINT uRes = 0;
    TCHAR szPrinter[MAX_PATH * 2];

    //
    //  Get the pidl for the object.
    //
    pidl = _ILSkip(ppidl[0], ILGetSize(pidlRoot) - sizeof(SHORT));

    //
    //  Handle the notification.
    //
    switch (lNotification)
    {
        case ( SHCNE_ATTRIBUTES ) :
        case ( SHCNE_UPDATEITEM ) :
        {
            //
            //  If the selected object is the one that changed, then
            //  update the status text.
            //
            if (pszCurPrinter)
            {
                szPrinter[0] = 0;
                GetViewItemText( psfRoot,
                                 pidl,
                                 szPrinter,
                                 ARRAYSIZE(szPrinter),
                                 SHGDN_FORPARSING);
                if (lstrcmpi(szPrinter, pszCurPrinter) == 0)
                {
                    UpdateStatus(pidl);
                }
            }
            break;
        }
        case ( SHCNE_CREATE ) :
        {
            //
            //  If the Add Printer Wizard is selected when we get this
            //  message, then select the newly created object.
            //
            if (fAPWSelected == TRUE)
            {
                //
                //  Get the printer name.
                //
                szPrinter[0] = 0;
                GetViewItemText( psfRoot,
                                 pidl,
                                 szPrinter,
                                 ARRAYSIZE(szPrinter),
                                 SHGDN_FORPARSING);

                if (pPrintDlgPage)
                {
                    //
                    //  Add the appropriate device pages and select the
                    //  new printer.
                    //
                    if (!MergeDevMode(szPrinter))
                    {
                        pPrintDlgPage->pPrintDlg->InsertDevicePage(szPrinter, NULL);
                    }
                    if (!fSelChangePending)
                    {
                        fFirstSel = 2;
                        fSelChangePending = TRUE;
                        PostMessage(hwndDlg, CDM_SELCHANGE, 0, 0);
                    }
                }
            }
            break;
        }
        case ( SHCNE_DELETE ) :
        {
            //
            //  Save the current devmode settings for selection changes.
            //
            if (pDMCur && pDMSave)
            {
                CopyMemory( pDMSave,
                            pDMCur,
                            (pDMCur->dmSize > sizeof(DEVMODE))
                                ? sizeof(DEVMODE)
                                : pDMCur->dmSize );
            }

            //
            //  Remove the device pages.
            //
            if (pPrintDlgPage)
            {
                pPrintDlgPage->pPrintDlg->RemoveDevicePage();
            }

            break;
        }
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnAccelerator
//
//  Handles an input event message.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::OnAccelerator(
    HWND hwndActivePrint,
    HWND hwndFocus,
    HACCEL haccPrint,
    PMSG pMsg)
{
    if (psv && (hwndFocus == hwndView))
    {
        if (psv->TranslateAccelerator(pMsg) == S_OK)
        {
            return (1);
        }

        if (haccPrint &&
            TranslateAccelerator(hwndActivePrint, haccPrint, pMsg))
        {
            return (1);
        }
    }

    //
    //  Return that the message was not handled.
    //
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnNoPrinters
//
//  Displays a message box telling the user that they have no printers
//  installed.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::OnNoPrinters(
    HWND hDlg,
    UINT iId)
{
    ShowError( hDlg,
               IDC_PRINTER_LISTVIEW,
               iId );
}

////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::OnInitDone
//
//  Handle the CDM_INITDONE message.  Initialization is complete, so
//  call IPrintDialogCallback::InitDone and then switch to the chosen
//  start page if it's not the General page.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::OnInitDone()
{
    //
    //  See if we need to do this anymore.  This routine shouldn't be
    //  entered more than twice, but just in case.
    //
    if (nInitDone != -1)
    {
        //
        //  Make sure we have seen the CDM_INITDONE message for the
        //  completion of both the main dialog and the sub dialog.
        //
        if (nInitDone < 1)
        {
            //
            //  We only want to go through this code once.
            //
            nInitDone = -1;

            //
            //  Tell the sub dialog that initialization is complete.
            //
            InitDone();

            //
            //  Switch to the appropriate start page.
            //
            if (pPD->nStartPage != START_PAGE_GENERAL)
            {
                PropSheet_SetCurSel( GetParent(hwndDlg),
                                     NULL,
                                     pPD->nStartPage + 1 );
            }
        }
        else
        {
            nInitDone++;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::CreatePrintShellView
//
//  Creates the shell view window for the printer folder.
//
////////////////////////////////////////////////////////////////////////////

HRESULT CPrintBrowser::CreatePrintShellView()
{
    RECT rcView;
    FOLDERSETTINGS fs;
    HRESULT hResult;

    //
    //  Get the Printer Folder pidl.
    //
    pidlRoot = SHCloneSpecialIDList(hwndDlg, CSIDL_PRINTERS, TRUE);
    if (!pidlRoot)
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (E_FAIL);
    }

    //
    //  Create an instance of IShellFolder and store it in the CPrintBrowser
    //  class.
    //
    hResult = Print_ICoCreateInstance( CLSID_CPrinters,
                                       IID_IShellFolder,
                                       pidlRoot,
                                       (LPVOID *)&psfRoot );
    if (FAILED(hResult))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (hResult);
    }

    //
    //  Get the private printer folder interface.
    //
    hResult = psfRoot->QueryInterface(IID_IPrinterFolder, (LPVOID *)&ppf);
    if (FAILED(hResult))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (hResult);
    }

    //
    //  Create the printer folder view.
    //
    GetWindowRect(GetDlgItem(hwndDlg, IDC_PRINTER_LIST), &rcView);
    MapWindowRect(HWND_DESKTOP, hwndDlg, &rcView);

    fs.ViewMode = GetViewMode();
    fs.fFlags = FWF_AUTOARRANGE | FWF_SINGLESEL | FWF_ALIGNLEFT |
                FWF_SHOWSELALWAYS;

    hResult = psfRoot->CreateViewObject(hwndDlg, IID_IShellView, (LPVOID *)&psv);
    if (FAILED(hResult))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (hResult);
    }
    hResult = psv->CreateViewWindow(NULL, &fs, this, &rcView, &hwndView);
    if (FAILED(hResult))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (hResult);
    }

    //
    //  Get the shell folder view interface.
    //
    hResult = psv->QueryInterface(IID_IShellFolderView, (LPVOID *)&psfv);
    if (FAILED(hResult))
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (hResult);
    }

    //
    //  Move the view window to the right spot in the Z (tab) order.
    //
    SetWindowPos( hwndView,
                  HWND_TOP,
                  0, 0, 0, 0,
                  SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW | SWP_NOACTIVATE );

    //
    //  Give it the right window ID for WinHelp and error selection.
    //
    SetWindowLong(hwndView, GWL_ID, IDC_PRINTER_LISTVIEW);

    //
    //  Show the window after creating the ShellView so we do not get a
    //  big ugly gray spot.
    //
    ShowWindow(hwndDlg, SW_SHOW);
    UpdateWindow(hwndDlg);

    //
    //  Return success.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetViewMode
//
//  Gets the view mode for the printer folder.
//
////////////////////////////////////////////////////////////////////////////

UINT CPrintBrowser::GetViewMode()
{
    HKEY hKey;
    UINT ViewMode = FVM_ICON;
    DWORD cbData;

    //
    //  Open the Printers\Settings registry key and read the information
    //  from the ViewMode value entry.
    //
    if (RegOpenKeyEx( HKEY_CURRENT_USER,
                      c_szSettings,
                      0L,
                      KEY_READ,
                      &hKey ) == ERROR_SUCCESS)
    {
        cbData = sizeof(ViewMode);
        RegQueryValueEx(hKey, c_szViewMode, NULL, NULL, (LPBYTE)&ViewMode, &cbData);
        RegCloseKey(hKey);
    }

    //
    //  Make sure it's in the correct range.
    //
    if (ViewMode > FVM_DETAILS)
    {
        ViewMode = FVM_ICON;
    }

    //
    //  Return the view mode.
    //
    return (ViewMode);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SetViewMode
//
//  Gets the view mode for the printer folder.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::SetViewMode()
{
    HWND hwndListView;
    HKEY hKey;
    UINT ViewMode = FVM_ICON;
    DWORD cbData;

    //
    //  Get the view mode from the current style bits.
    //
    if (hwndListView = FindWindowEx(hwndView, NULL, WC_LISTVIEW, NULL))
    {
        ViewMode = GetWindowLong(hwndListView, GWL_STYLE) &
                     (LVS_ICON | LVS_SMALLICON | LVS_LIST | LVS_REPORT);
        switch (ViewMode)
        {
            case ( LVS_ICON ) :
            default :
            {
                ViewMode = FVM_ICON;
                break;
            }
            case ( LVS_SMALLICON ) :
            {
                ViewMode = FVM_SMALLICON;
                break;
            }
            case ( LVS_LIST ) :
            {
                ViewMode = FVM_LIST;
                break;
            }
            case ( LVS_REPORT ) :
            {
                ViewMode = FVM_DETAILS;
                break;
            }
        }
    }

    //
    //  Open the Printers\Settings registry key and save the information
    //  to the ViewMode value entry.
    //
    if (RegOpenKeyEx( HKEY_CURRENT_USER,
                      c_szSettings,
                      0L,
                      KEY_READ | KEY_WRITE,
                      &hKey ) == ERROR_SUCCESS)
    {
        cbData = sizeof(ViewMode);
        RegSetValueEx(hKey, c_szViewMode, 0L, REG_DWORD, (LPBYTE)&ViewMode, cbData);
        RegCloseKey(hKey);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::CreateHookDialog
//
//  Creates the child window for the application specific area of the
//  General page.
//
////////////////////////////////////////////////////////////////////////////

HRESULT CPrintBrowser::CreateHookDialog()
{
    DWORD Flags = pPD->Flags;
    HANDLE hTemplate;
    HINSTANCE hinst;
    LPCTSTR pDlg;
    RECT rcChild;
    DWORD dwStyle;

    //
    //  See if there is a template.
    //
    if (Flags & PD_ENABLEPRINTTEMPLATEHANDLE)
    {
        hTemplate = pPD->hInstance;
        hinst = ::g_hinst;
    }
    else
    {
        if (Flags & PD_ENABLEPRINTTEMPLATE)
        {
            pDlg = pPD->lpPrintTemplateName;
            hinst = pPD->hInstance;
        }
        else
        {
            hinst = ::g_hinst;
            pDlg = MAKEINTRESOURCE(PRINTDLGEXORD);
        }

        HRSRC hRes = FindResource(hinst, pDlg, RT_DIALOG);
        if (hRes == NULL)
        {
            pPI->dwExtendedError = CDERR_FINDRESFAILURE;
            return (E_HANDLE);
        }
        if ((hTemplate = LoadResource(hinst, hRes)) == NULL)
        {
            pPI->dwExtendedError = CDERR_LOADRESFAILURE;
            return (E_HANDLE);
        }
    }

    //
    //  Lock the resource.
    //
    if (!LockResource(hTemplate))
    {
        pPI->dwExtendedError = CDERR_LOADRESFAILURE;
        return (E_HANDLE);
    }

    //
    //  Make sure the template is a child window.
    //
    dwStyle = ((LPDLGTEMPLATE)hTemplate)->style;
    if (!(dwStyle & WS_CHILD))
    {
        //
        //  I don't want to go poking in their template, and I don't want to
        //  make a copy, so I will just fail.  This also helps us weed out
        //  "old-style" templates that were accidentally used.
        //
        pPI->dwExtendedError = CDERR_DIALOGFAILURE;
        return (E_INVALIDARG);
    }

    //
    //  Get the callback interface pointer, if necessary.
    //
    if (pPD->lpCallback)
    {
        pPD->lpCallback->QueryInterface( IID_IPrintDialogCallback,
                                         (LPVOID *)&pCallback );
    }

    //
    //  Create the child dialog.
    //
    hSubDlg = CreateDialogIndirectParam( hinst,
                                         (LPDLGTEMPLATE)hTemplate,
                                         hwndDlg,
                                         Print_GeneralChildDlgProc,
                                         (LPARAM)pPD );
    if (!hSubDlg)
    {
        pPI->dwExtendedError = CDERR_DIALOGFAILURE;
        return (E_HANDLE);
    }

    //
    //  Put the window in the designated spot on the General property page.
    //
    GetWindowRect(GetDlgItem(hwndDlg, grp2), &rcChild);
    MapWindowRect(NULL, hwndDlg, &rcChild);
    SetWindowPos( hSubDlg,
                  HWND_BOTTOM,
                  rcChild.left,
                  rcChild.top,
                  rcChild.right - rcChild.left,
                  rcChild.bottom - rcChild.top,
                  SWP_SHOWWINDOW );

    //
    //  Return success.
    //
    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::UpdateStatus
//
//  Updates the static text for the currently selected printer.
//  The fields that are set are Status, Location, and Comment.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::UpdateStatus(
    LPCITEMIDLIST pidl)
{
    HRESULT hres;
    SHELLDETAILS Details;
    TCHAR szText[MAX_PATH];

    //
    //  If the pidl is NULL, then reset all of the static text to null
    //  strings.
    //
    if (!pidl)
    {
        szText[0] = 0;

        SetDlgItemText(hwndDlg, IDC_STATUS, szText);
        UpdateWindow(GetDlgItem(hwndDlg, IDC_STATUS));

        SetDlgItemText(hwndDlg, IDC_LOCATION, szText);
        UpdateWindow(GetDlgItem(hwndDlg, IDC_LOCATION));

        SetDlgItemText(hwndDlg, IDC_COMMENT, szText);
        UpdateWindow(GetDlgItem(hwndDlg, IDC_COMMENT));

        return (TRUE);
    }

    //
    //  Get the Shell Details interface if it hasn't already been done.
    //
    if (!psd && psfRoot)
    {
        hres = psfRoot->CreateViewObject( hwndDlg,
                                          IID_IShellDetails,
                                          (LPVOID *)&psd );
        if (FAILED(hres))
        {
            return (FALSE);
        }
    }
    if (!psd)
    {
        return (FALSE);
    }

    //
    //  Get the STATUS details for the given object.
    //
    szText[0] = 0;
    hres = psd->GetDetailsOf(pidl, PRINTERS_ICOL_STATUS, &Details);
    if (FAILED(hres) ||
        !StrRetToStrN(szText, ARRAYSIZE(szText), &Details.str, NULL))
    {
        szText[0] = 0;
    }
    SetDlgItemText(hwndDlg, IDC_STATUS, szText);
    UpdateWindow(GetDlgItem(hwndDlg, IDC_STATUS));

    //
    //  Get the LOCATION details for the given object.
    //
    szText[0] = 0;
    hres = psd->GetDetailsOf(pidl, PRINTERS_ICOL_LOCATION, &Details);
    if (FAILED(hres) ||
        !StrRetToStrN(szText, ARRAYSIZE(szText), &Details.str, NULL))
    {
        szText[0] = 0;
    }
    SetDlgItemText(hwndDlg, IDC_LOCATION, szText);
    UpdateWindow(GetDlgItem(hwndDlg, IDC_LOCATION));

    //
    //  Get the COMMENT details for the given object.
    //
    szText[0] = 0;
    hres = psd->GetDetailsOf(pidl, PRINTERS_ICOL_COMMENT, &Details);
    if (FAILED(hres) ||
        !StrRetToStrN(szText, ARRAYSIZE(szText), &Details.str, NULL))
    {
        szText[0] = 0;
    }
    SetDlgItemText(hwndDlg, IDC_COMMENT, szText);
    UpdateWindow(GetDlgItem(hwndDlg, IDC_COMMENT));

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SelectSVItem
//
//  Selects the item in the shell view with the given printer name.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::SelectSVItem()
{
    HRESULT hres;
    LPITEMIDLIST pidlItem = NULL;
    UINT uCount = 0;
    TCHAR szPrinter[MAX_PATH * 2];

    //
    //  Make sure we have the current printer information.
    //
    GetCurrentPrinter();

    //
    //  Make sure we have a shell view and a shell folder view.
    //
    if (!psv || !psfv)
    {
        return (FALSE);
    }

    //
    //  Get the number of objects in the list view.
    //
    hres = psfv->GetObjectCount(&uCount);
    if (FAILED(hres))
    {
        return (FALSE);
    }

    //
    //  If there is only one object and there are no driver pages, then
    //  select the object (Add Printer Wizard) and disable the OK button.
    //
    if (!pDMCur || !pszCurPrinter || !pszCurPrinter[0])
    {
        if ((uCount == 1) || (fAPWSelected == TRUE))
        {
            //
            //  Select the Add Printer Wizard.
            //
            hres = psfv->GetObject(&pidlItem, 0);
            if (SUCCEEDED(hres) && pidlItem)
            {
                psv->SelectItem(pidlItem, SVSI_SELECT | SVSI_FOCUSED);
            }

            //
            //  It's the Add Printer Wizard.
            //
            fAPWSelected = TRUE;

        }

        //
        //  Disable the OK and Apply buttons.
        //
        EnableWindow(GetDlgItem(GetParent(hwndDlg), IDOK), FALSE);
        PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);

        return (FALSE);
    }

    //
    //  Look at each object and try to match the object's printer name
    //  with the given printer name.
    //
    while (uCount)
    {
        hres = psfv->GetObject(&pidlItem, uCount - 1);
        if (FAILED(hres))
        {
            return (FALSE);
        }
        if (pidlItem)
        {
            //
            //  Get the printer name of this pidlItem and see if it matches
            //  the given printer name.
            //
            szPrinter[0] = 0;
            GetViewItemText( psfRoot,
                             pidlItem,
                             szPrinter,
                             ARRAYSIZE(szPrinter),
                             SHGDN_FORPARSING);
            if (lstrcmpi(pszCurPrinter, szPrinter) == 0)
            {
                break;
            }
            pidlItem = NULL;
        }
        uCount--;
    }

    //
    //  If we found a matching pidl, select it and update the status
    //  information for the newly selected printer.
    //
    if (uCount && pidlItem)
    {
        hres = psv->SelectItem(pidlItem, SVSI_SELECT | SVSI_FOCUSED);
        UpdateStatus(pidlItem);
        if (FAILED(hres))
        {
            return (FALSE);
        }

        //
        //  It's not the Add Printer Wizard.
        //
        fAPWSelected = FALSE;

        //
        //  Enable the OK and Apply buttons.
        //
        EnableWindow(GetDlgItem(GetParent(hwndDlg), IDOK), TRUE);
        PropSheet_Changed(GetParent(hwndDlg), hwndDlg);
    }
    else
    {
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::IsPrinterInList
//
//  Checks to see if the given printer name is in the list view.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::IsPrinterInList(
    LPCTSTR pPrinter)
{
    HRESULT hres;
    LPITEMIDLIST pidlItem = NULL;
    UINT uCount = 0;
    TCHAR szPrinter[MAX_PATH * 2];

    //
    //  Make sure we have a shell view and a printer name.
    //
    if (!psv || !psfv || !pPrinter || !pPrinter[0])
    {
        return (FALSE);
    }

    //
    //  Get the number of objects in the list view.
    //
    hres = psfv->GetObjectCount(&uCount);
    if (FAILED(hres))
    {
        return (FALSE);
    }

    //
    //  Look at each object and try to match the object's printer name
    //  with the given printer name.
    //
    while (uCount)
    {
        hres = psfv->GetObject(&pidlItem, uCount - 1);
        if (FAILED(hres))
        {
            return (FALSE);
        }
        if (pidlItem)
        {
            //
            //  Get the printer name of this pidlItem and see if it matches
            //  the given printer name.
            //
            szPrinter[0] = 0;
            GetViewItemText( psfRoot,
                             pidlItem,
                             szPrinter,
                             ARRAYSIZE(szPrinter),
                             SHGDN_FORPARSING);
            if (lstrcmpi(pPrinter, szPrinter) == 0)
            {
                break;
            }
            pidlItem = NULL;
        }
        uCount--;
    }

    //
    //  If we found a matching pidl, return TRUE.
    //
    if (uCount && pidlItem)
    {
        return (TRUE);
    }

    //
    //  Return failure.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::GetCurrentPrinter
//
//  Saves the current printer name and the current devmode in the class.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::GetCurrentPrinter()
{
    DWORD dwSize = cchCurPrinter;

    //
    //  Reset the devmode and the current printer string.
    //
    pDMCur = NULL;
    if (pszCurPrinter && cchCurPrinter)
    {
        pszCurPrinter[0] = 0;
    }

    //
    //  Make sure we have the print ui interface.
    //
    if (!pPrintDlgPage)
    {
        return (FALSE);
    }

    //
    //  Get the name of the current printer.
    //
    if (!pPrintDlgPage->pPrintDlg->GetCurrentPrinterName( pszCurPrinter,
                                                          &dwSize ))
    {
        //
        //  Allocate a buffer large enough to hold the name of the
        //  current printer.
        //
        if (dwSize > cchCurPrinter)
        {
            if (pszCurPrinter)
            {
                LPTSTR pTemp = pszCurPrinter;
                pszCurPrinter = NULL;
                cchCurPrinter = 0;
                GlobalFree(pTemp);
            }
            pszCurPrinter = (LPTSTR)GlobalAlloc(GPTR, dwSize * sizeof(TCHAR));
            if (!pszCurPrinter)
            {
                return (FALSE);
            }
            cchCurPrinter = dwSize;
            if (cchCurPrinter)
            {
                pszCurPrinter[0] = 0;
            }
        }

        //
        //  Try to get the name of the current printer again.
        //
        if (!pPrintDlgPage->pPrintDlg->GetCurrentPrinterName( pszCurPrinter,
                                                              &dwSize ))
        {
            return (FALSE);
        }
    }

    //
    //  Get the current devmode.
    //
    pDMCur = pPrintDlgPage->pPrintDlg->GetCurrentDevMode();
    if (!pDMCur)
    {
        pszCurPrinter[0] = 0;
        return (FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InitPrintToFile
//
//  Initializes the print to file on a selection change.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::InitPrintToFile()
{
    HWND hCtl = GetDlgItem(hwndDlg, IDC_PRINT_TO_FILE);

    //
    //  See if there is a Print To File control.
    //
    if (hCtl)
    {
        //
        //  See if a printer is selected.
        //
        if (pDMCur)
        {
            //
            //  A printer is selected, so enable the print to file if
            //  appropriate.
            //
            if (!(pPI->dwFlags & (PD_HIDEPRINTTOFILE | PD_DISABLEPRINTTOFILE)))
            {
                EnableWindow(hCtl, TRUE);
            }
        }
        else
        {
            //
            //  A printer is not selected, so disable it.
            //
            EnableWindow(hCtl, FALSE);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InitPageRangeGroup
//
//  Initializes the page range group on a selection change.  It decides
//  which controls should be enabled when a selection change occurs from
//  the Add Printer Wizard.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::InitPageRangeGroup()
{
    //
    //  See if a printer is selected.
    //
    if (pDMCur)
    {
        //
        //  A printer is selected, so enable the appropriate page range
        //  controls.
        //
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_ALL), TRUE);
        if (!(pPI->dwFlags & PD_NOSELECTION))
        {
            EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_SELECTION), TRUE);
        }
        if (!(pPI->dwFlags & PD_NOCURRENTPAGE))
        {
            EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_CURRENT), TRUE);
        }
        if (!(pPI->dwFlags & PD_NOPAGENUMS))
        {
            EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_PAGES), TRUE);
            EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_EDIT), TRUE);
        }
    }
    else
    {
        //
        //  A printer is not selected, so disable all of the page range
        //  controls.
        //
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_ALL), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_SELECTION), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_CURRENT), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_PAGES), FALSE);
        EnableWindow(GetDlgItem(hSubDlg, IDC_RANGE_EDIT), FALSE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::InitCopiesAndCollate
//
//  Initializes the copies and collate information in the devmode and the
//  print dialog structure.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::InitCopiesAndCollate()
{
    HWND hCtl;
    UINT IsCollate = FALSE;
    RECT rc;

    //
    //  Save the collate state so that the collate icon doesn't flicker on
    //  a selection change.
    //
    if (hCtl = GetDlgItem(hSubDlg, IDC_COLLATE))
    {
        IsCollate = IsDlgButtonChecked(hSubDlg, IDC_COLLATE);
    }

    //
    //  See what the printer driver can do and what the app requested
    //  and set the copies and collate accordingly.
    //
    if (pDMCur)
    {
        //
        //  If PD_USEDEVMODECOPIES(COLLATE), disable copies if the driver
        //  cannot copy.
        //
        if (hCtl = GetDlgItem(hSubDlg, IDC_COPIES))
        {
            if ((pDMCur->dmFields & DM_COPIES) ||
                (!(pPD->Flags & PD_USEDEVMODECOPIESANDCOLLATE)))
            {
                SetDlgItemInt(hSubDlg, IDC_COPIES, nCopies, FALSE);
                EnableWindow(hCtl, TRUE);
            }
            else
            {
                SetDlgItemInt(hSubDlg, IDC_COPIES, 1, FALSE);
                EnableWindow(hCtl, FALSE);
                nCopies = 1;
            }
        }

        //
        //  If PD_USEDEVMODECOPIES(COLLATE), disable collate if the driver
        //  cannot collate.
        //
        if (hCtl = GetDlgItem(hSubDlg, IDC_COLLATE))
        {
            if ((pDMCur->dmFields & DM_COLLATE) ||
                (!(pPD->Flags & PD_USEDEVMODECOPIESANDCOLLATE)))
            {
                EnableWindow(hCtl, (nCopies > 1));
                CheckDlgButton( hSubDlg,
                                IDC_COLLATE,
                                fCollateRequested ? TRUE : FALSE );
            }
            else
            {
                EnableWindow(hCtl, FALSE);
                CheckDlgButton(hSubDlg, IDC_COLLATE, FALSE);
            }

            //
            //  Display the appropriate collate icon if it changed.
            //
            if ((hCtl = GetDlgItem(hSubDlg, IDI_COLLATE)) &&
                (IsCollate != IsDlgButtonChecked(hSubDlg, IDC_COLLATE)))
            {
                ShowWindow(hCtl, SW_HIDE);
                SendMessage( hCtl,
                             STM_SETICON,
                             IsCollate
                                 ? (LONG_PTR)hIconNoCollate
                                 : (LONG_PTR)hIconCollate,
                             0L );
                ShowWindow(hCtl, SW_SHOW);

                //
                //  Make it redraw to get rid of the old one.
                //
                GetWindowRect(hCtl, &rc);
                MapWindowRect(NULL, hwndDlg, &rc);
                RedrawWindow(hwndDlg, &rc, NULL, RDW_ERASE | RDW_INVALIDATE);
            }
        }
    }
    else
    {
        //
        //  A printer is not selected, so disable copies and collate.
        //
        if (hCtl = GetDlgItem(hSubDlg, IDC_COPIES))
        {
            SetDlgItemInt(hSubDlg, IDC_COPIES, 1, FALSE);
            EnableWindow(hCtl, FALSE);
        }
        if (hCtl = GetDlgItem(hSubDlg, IDC_COLLATE))
        {
            EnableWindow(hCtl, FALSE);
            CheckDlgButton(hSubDlg, IDC_COLLATE, FALSE);

            if ((hCtl = GetDlgItem(hSubDlg, IDI_COLLATE)) && IsCollate)
            {
                ShowWindow(hCtl, SW_HIDE);
                SendMessage( hCtl,
                             STM_SETICON,
                             (LONG_PTR)hIconNoCollate,
                             0L );
                ShowWindow(hCtl, SW_SHOW);

                //
                //  Make it redraw to get rid of the old one.
                //
                GetWindowRect(hCtl, &rc);
                MapWindowRect(NULL, hwndDlg, &rc);
                RedrawWindow(hwndDlg, &rc, NULL, RDW_ERASE | RDW_INVALIDATE);
            }
        }

        //
        //  Disable the Apply button since a printer is not selected.
        //  It gets turned back on when the copies and collate values are
        //  disabled.
        //
        PropSheet_UnChanged(GetParent(hwndDlg), hwndDlg);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SaveCopiesAndCollateInDevMode
//
//  Saves the copies and collate information in the given devmode.  This
//  routine does not affect the pPD structure.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::SaveCopiesAndCollateInDevMode(
    LPDEVMODE pDM,
    LPTSTR pszPrinter)
{
    //
    //  Make sure we have a devmode and a printer name.
    //
    if (!pDM || !pszPrinter || !(pszPrinter[0]))
    {
        return (FALSE);
    }

    //
    //  If the driver cannot do copies, do nothing.
    //  If the driver cannot do collate but can do copies, then save the
    //    copies in the devmode so that the app will see the copy count,
    //    but it won't get the collate information.
    //  If the driver can do both, then save both pieces of info in the
    //    devmode.
    //
    if (pDM->dmFields & DM_COPIES)
    {
        //
        //  Make sure the driver can support the number of copies requested.
        //
        if (nCopies != 1)
        {
            DWORD sMaxCopies;

            szScratch[0] = 0;
            Print_GetPortName(pszPrinter, szScratch, ARRAYSIZE(szScratch));
            sMaxCopies = DeviceCapabilities( pszPrinter,
                                             szScratch,
                                             DC_COPIES,
                                             NULL,
                                             NULL );
            if ((sMaxCopies < 1) || (sMaxCopies == (DWORD)(-1)))
            {
                sMaxCopies = 1;
            }
            if (sMaxCopies < nCopies)
            {
                return (FALSE);
            }
        }

        //
        //  Move the info to the devmode.
        //
        pDM->dmCopies = (short)nCopies;
        SetField(pDM, dmCollate, fCollateRequested ? DMCOLLATE_TRUE : DMCOLLATE_FALSE);
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SetCopiesOnApply
//
//  Sets the appropriate number of copies in the PrintDlgEx structure and
//  in the DevMode structure.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::SetCopiesOnApply()
{
    DWORD sMaxCopies;

    if (pDMCur)
    {
        if (!(pDMCur->dmFields & DM_COPIES))
        {
Print_LeaveInfoInPD:
            //
            //  The driver cannot do copies, so leave the copy/collate
            //  info in the pPD.
            //
            pDMCur->dmCopies = 1;
            SetField(pDMCur, dmCollate, DMCOLLATE_FALSE);
        }
        else if ((pDMCur->dmSpecVersion < 0x0400) ||
                 (!(pDMCur->dmFields & DM_COLLATE)))
        {
            //
            //  The driver can do copies, but not collate.
            //  Where the info goes depends on the PD_COLLATE flag.
            //
            if (pPD->Flags & PD_COLLATE)
            {
                goto Print_LeaveInfoInPD;
            }
            else
            {
                goto Print_PutInfoInDevMode;
            }
        }
        else
        {
Print_PutInfoInDevMode:
            //
            //  Make sure we have a current printer.
            //
            if (!pszCurPrinter)
            {
                goto Print_LeaveInfoInPD;
            }

            //
            //  Make sure the driver can support the number of copies
            //  requested.
            //
            szScratch[0] = 0;
            Print_GetPortName(pszCurPrinter, szScratch, ARRAYSIZE(szScratch));
            sMaxCopies = DeviceCapabilities( pszCurPrinter,
                                             szScratch,
                                             DC_COPIES,
                                             NULL,
                                             NULL );
            if ((sMaxCopies < 1) || (sMaxCopies == (DWORD)(-1)))
            {
                sMaxCopies = 1;
            }
            if (sMaxCopies < pPD->nCopies)
            {
                if (pPD->Flags & PD_USEDEVMODECOPIESANDCOLLATE)
                {
                    ShowError(hSubDlg, IDC_COPIES, iszTooManyCopies, sMaxCopies);
                    return (FALSE);
                }

                goto Print_LeaveInfoInPD;
            }

            //
            //  The driver can do both copies and collate, so move the info
            //  to the devmode.
            //
            pDMCur->dmCopies = (short)pPD->nCopies;
            SetField( pDMCur,
                      dmCollate,
                      (pPD->Flags & PD_COLLATE)
                          ? DMCOLLATE_TRUE
                          : DMCOLLATE_FALSE );
            pPD->nCopies = 1;
            pPD->Flags &= ~PD_COLLATE;
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::SaveDevMode
//
//  Saves the current devmode in the pPD structure on Apply.
//  Assumes pDMCur has the current information.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::SaveDevMode()
{
    DWORD cbSize;
    HANDLE hDevMode = NULL;
    LPDEVMODE pDM;

    //
    //  Allocate the space for the new DevMode and copy the
    //  information.
    //
    if (pDMCur)
    {
        cbSize = (DWORD)(pDMCur->dmSize + pDMCur->dmDriverExtra);
        hDevMode = GlobalAlloc(GHND, cbSize);
        if (hDevMode)
        {
            pDM = (LPDEVMODE)GlobalLock(hDevMode);
            if (pDM)
            {
                CopyMemory(pDM, pDMCur, cbSize);
                GlobalUnlock(hDevMode);
            }
            else
            {
                GlobalFree(hDevMode);
                hDevMode = NULL;
            }
        }
    }
    if (!hDevMode)
    {
        pPI->dwExtendedError = CDERR_MEMALLOCFAILURE;
        pPI->hResult = E_OUTOFMEMORY;
        pPI->FinalResult = 0;
    }

    //
    //  Free the copy of the DevMode handle passed in by the app.
    //
    if (pPD->hDevMode)
    {
        GlobalFree(pPD->hDevMode);
        pPD->hDevMode = NULL;
    }

    //
    //  Save the new DevMode in the pPD structure.
    //
    pPD->hDevMode = hDevMode;
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::MergeDevMode
//
//  Merges the current devmode with the default devmode of the newly
//  selected printer.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::MergeDevMode(
    LPTSTR pszPrinterName)
{
    HANDLE hDevMode = NULL;
    LPDEVMODE pDMNew = NULL;
    LPDEVMODE pDMOld = NULL;
    BOOL bRet = TRUE;
    DWORD cbSize;
    DWORD dmFields;
    short dmDefaultSource;

    //
    //  Make sure we have the pPrintDlgPage pointer.
    //
    if (!pPrintDlgPage)
    {
        return (FALSE);
    }

    //
    //  See if the printer name is NULL.  If so, we need to get the default
    //  printer loaded.  This happens when a printer is deleted.
    //
    if (!pszPrinterName)
    {
        //
        //  Get the devmode for the old printer.
        //
        pDMOld = pDMSave;
        if (!pDMOld)
        {
            return (FALSE);
        }

        //
        //  Get the default printer loaded.
        //
        if ((pPrintDlgPage->pPrintDlg->InsertDevicePage(NULL, NULL) != kSuccess) ||
            !GetCurrentPrinter() || !pDMCur)
        {
            return (FALSE);
        }

        //
        //  Allocate the devmode for the new printer and copy it.
        //
        cbSize = pDMCur->dmSize + pDMCur->dmDriverExtra;
        pDMNew = (LPDEVMODE)GlobalAlloc(GPTR, cbSize);
        if (!pDMNew)
        {
            return (FALSE);
        }
        CopyMemory(pDMNew, pDMCur, cbSize);
    }
    else
    {
        //
        //  Get the devmode for the old (current driver pages) printer.
        //
        GetCurrentPrinter();
        pDMOld = pDMCur ? pDMCur : pDMSave;
        if (!pDMOld)
        {
            return (FALSE);
        }

        //
        //  Get the devmode for the new printer.
        //
        hDevMode = Print_GetDevModeWrapper(pszPrinterName, NULL);
        if (hDevMode)
        {
            pDMNew = (LPDEVMODE)GlobalLock(hDevMode);
        }
        if (!pDMNew)
        {
            if (hDevMode)
            {
                GlobalFree(hDevMode);
            }
            return (FALSE);
        }
    }

    //
    //  Save the PaperSource information.
    //
    dmFields = 0;
    dmDefaultSource = pDMNew->dmDefaultSource;
    if (pDMNew->dmFields & DM_DEFAULTSOURCE)
    {
        dmFields = DM_DEFAULTSOURCE;
    }

    //
    //  Copy relevant info from the old devmode to the new devmode.
    //
    CopyMemory( &(pDMNew->dmFields),
                &(pDMOld->dmFields),
                sizeof(DEVMODE) - FIELD_OFFSET(DEVMODE, dmFields) );

    //
    //  Reset the PaperSource back to the Document Default.
    //
    pDMNew->dmFields |= dmFields;
    pDMNew->dmDefaultSource = dmDefaultSource;

    //
    //  Only save the flags for the items that should be merged.
    //
    pDMNew->dmFields = pDMNew->dmFields & (DM_ORIENTATION | DM_PAPERSIZE  |
                                           DM_PAPERLENGTH | DM_PAPERWIDTH |
                                           DM_SCALE       | DM_COPIES     |
                                           DM_COLLATE     | DM_FORMNAME   |
                                           DM_DEFAULTSOURCE);

    //
    //  Insert the device pages - this call will yield a proper devmode.
    //
    pPrintDlgPage->pPrintDlg->RemoveDevicePage();
    if (pPrintDlgPage->pPrintDlg->InsertDevicePage(pszPrinterName, pDMNew) !=
          kSuccess)
    {
        bRet = FALSE;
    }

    //
    //  Free the new devmode that was allocated.
    //
    if (hDevMode)
    {
        GlobalUnlock(hDevMode);
        GlobalFree(hDevMode);
    }
    else if (pDMNew)
    {
        GlobalFree(pDMNew);
    }

    //
    //  Return the result.
    //
    return (bRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::IsValidPageRange
//
//  Checks the validity of the page range string.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::IsValidPageRange(
    LPTSTR pszString,
    UINT *pErrorId)
{
    LPTSTR pStr = pszString;
    BOOL bDigit = FALSE;
    BOOL bOld;
    UINT Number, Ctr;
    DWORD nNumRanges = 0;
    BOOL bFrom = TRUE;

    //
    //  Initially set the error id to 0.
    //
    *pErrorId = 0;

    //
    //  See if we can only have a single page range.
    //
    bOld = (nMaxPageRanges == 1);

    //
    //  Go through the string and validate the entries.
    //
    while (*pStr)
    {
        if (ISDIGIT(*pStr))
        {
            //
            //  Make sure there is room for another range.
            //
            if (nNumRanges >= nMaxPageRanges)
            {
                break;
            }

            //
            //  Found a digit.
            //
            bDigit = TRUE;

            //
            //  Make sure the page number is in the given page range.
            //
            Number = 0;
            while (ISDIGIT(*pStr))
            {
                Number *= 10;
                Number += *pStr - TEXT('0');
                pStr++;
            }
            pStr--;

            if ((Number < pPD->nMinPage) || (Number > pPD->nMaxPage))
            {
                *pErrorId = iszBadPageRange;
                return (FALSE);
            }

            //
            //  Save the value in the page range structure.
            //
            if (bFrom)
            {
                pPageRanges[nNumRanges].nFromPage = Number;
                bFrom = FALSE;
            }
            else
            {
                pPageRanges[nNumRanges].nToPage = Number;
                bFrom = TRUE;
                nNumRanges++;
            }
        }
        else if (*pStr == TEXT('-'))
        {
            //
            //  Found a hyphen.  Make sure there is a digit preceding it
            //  and following it.  Also, make sure there isn't something
            //  like 1-2-3.
            //
            if (!bDigit || bFrom || !ISDIGIT(*(pStr + 1)))
            {
                *pErrorId = bOld ? iszBadPageRangeSyntaxOld
                                 : iszBadPageRangeSyntaxNew;
                return (FALSE);
            }
            bDigit = FALSE;
        }
        else if ((*pStr == szListSep[0]) || (*pStr == TEXT(',')))
        {
            //
            //  Found a list separator.  Make sure there is a digit
            //  preceding it.
            //
            if (!bDigit)
            {
                *pErrorId = bOld ? iszBadPageRangeSyntaxOld
                                 : iszBadPageRangeSyntaxNew;
                return (FALSE);
            }
            bDigit = FALSE;

            //
            //  If it's the list separator string instead of the simple
            //  comma, then make sure the entire list separator string
            //  is there.
            //  This will advance the string up to the last character
            //  of the list separator string.
            //
            if ((*pStr == szListSep[0]) &&
                ((szListSep[0] != TEXT(',')) || (!ISDIGIT(*(pStr + 1)))))
            {
                for (Ctr = 1; Ctr < nListSep; Ctr++)
                {
                    pStr++;
                    if (*pStr != szListSep[Ctr])
                    {
                        *pErrorId = bOld ? iszBadPageRangeSyntaxOld
                                         : iszBadPageRangeSyntaxNew;
                        return (FALSE);
                    }
                }
            }

            //
            //  Make sure the From/To page range is complete.
            //
            if (!bFrom)
            {
                pPageRanges[nNumRanges].nToPage = pPageRanges[nNumRanges].nFromPage;
                bFrom = TRUE;
                nNumRanges++;
            }
        }
        else
        {
            //
            //  Found an invalid character.
            //
            *pErrorId = bOld ? iszBadPageRangeSyntaxOld
                             : iszBadPageRangeSyntaxNew;
            return (FALSE);
        }

        //
        //  Advance the string pointer.
        //
        pStr++;
    }

    //
    //  Make sure we reached the end of the string.
    //
    if (*pStr)
    {
        *pErrorId = iszTooManyPageRanges;
        return (FALSE);
    }

    //
    //  Make sure the last thing in the string was a digit.
    //
    if (!bDigit)
    {
        *pErrorId = bOld ? iszBadPageRangeSyntaxOld
                         : iszBadPageRangeSyntaxNew;
        return (FALSE);
    }

    //
    //  Make sure the last From/To page range is complete.
    //
    if (!bFrom)
    {
        pPageRanges[nNumRanges].nToPage = pPageRanges[nNumRanges].nFromPage;
        bFrom = TRUE;
        nNumRanges++;
    }

    //
    //  Save the number of page ranges.
    //
    nPageRanges = nNumRanges;

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::ConvertPageRangesToString
//
//  Converts the page ranges to a string.
//
////////////////////////////////////////////////////////////////////////////

BOOL CPrintBrowser::ConvertPageRangesToString(
    LPTSTR pszString,
    UINT cchLen)
{
    LPTSTR pStr = pszString;
    DWORD nFromPage, nToPage;
    UINT cch = cchLen - 1;
    UINT Ctr, Ctr2, Count;

    //
    //  Initialize the string.
    //
    if (cchLen)
    {
        pszString[0] = 0;
    }

    //
    //  Validate the ranges and create the string.
    //
    for (Ctr = 0; Ctr < nPageRanges; Ctr++)
    {
        //
        //  Get the range.
        //
        nFromPage = pPageRanges[Ctr].nFromPage;
        nToPage   = pPageRanges[Ctr].nToPage;

        //
        //  Make sure the range is valid.
        //
        if ((nFromPage < pPD->nMinPage) || (nFromPage > pPD->nMaxPage) ||
            (nToPage   < pPD->nMinPage) || (nToPage   > pPD->nMaxPage))
        {
            return (FALSE);
        }

        //
        //  Make sure it's not 0xffff.
        //
        if (nFromPage == 0xffff)
        {
            continue;
        }

        //
        //  Put it in the string.
        //
        Count = IntegerToString(nFromPage, pStr, cch);
        if (!Count)
        {
            return (FALSE);
        }
        pStr += Count;
        cch -= Count;

        if ((nFromPage == nToPage) || (nToPage == 0xffff))
        {
            if (Ctr < nPageRanges - 1)
            {
                if (cch < nListSep)
                {
                    return (FALSE);
                }
                for (Ctr2 = 0; Ctr2 < nListSep; Ctr2++)
                {
                    *pStr = szListSep[Ctr2];
                    pStr++;
                }
                cch -= nListSep;
            }
        }
        else
        {
            if (!cch)
            {
                return (FALSE);
            }
            *pStr = TEXT('-');
            pStr++;
            cch--;

            Count = IntegerToString(nToPage, pStr, cch);
            if (!Count)
            {
                return (FALSE);
            }
            pStr += Count;
            cch -= Count;

            if (Ctr < nPageRanges - 1)
            {
                if (cch < nListSep)
                {
                    return (FALSE);
                }
                for (Ctr2 = 0; Ctr2 < nListSep; Ctr2++)
                {
                    *pStr = szListSep[Ctr2];
                    pStr++;
                }
                cch -= nListSep;
            }
        }
    }

    //
    //  Return success.
    //
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::IntegerToString
//
//  Converts an integer to a string and returns the number of characters
//  written to the buffer (not including the null).
//
////////////////////////////////////////////////////////////////////////////

UINT CPrintBrowser::IntegerToString(
    DWORD Value,
    LPTSTR pszString,
    UINT cchLen)
{
    DWORD TempValue = Value;
    UINT NumChars = 1;
    UINT Ctr;

    //
    //  Get the number of characters needed.
    //
    while (TempValue = TempValue / 10)
    {
        NumChars++;
    }

    //
    //  Make sure there is enough room in the buffer.
    //
    if (NumChars > cchLen)
    {
        return (0);
    }

    //
    //  Make the string.
    //
    TempValue = Value;
    for (Ctr = NumChars; Ctr > 0; Ctr--)
    {
        pszString[Ctr - 1] = ((WORD)(TempValue % 10)) + TEXT('0');
        TempValue = TempValue / 10;
    }

    //
    //  Return the number of characters written to the buffer.
    //
    return (NumChars);
}


////////////////////////////////////////////////////////////////////////////
//
//  CPrintBrowser::ShowError
//
//  Set focus to an edit control and select the entire contents.
//  This is generally used when an improper value was found at OK time.
//
//  Assumes the edit control is not disabled.
//
////////////////////////////////////////////////////////////////////////////

VOID CPrintBrowser::ShowError(
    HWND hDlg,
    int Id,
    UINT MessageId,
    ...)
{
    if (!(pPI->dwFlags & PD_NOWARNING))
    {
        HWND hEdit;
        TCHAR pszTitle[MAX_PATH];
        TCHAR pszFormat[MAX_PATH];
        TCHAR pszMessage[MAX_PATH];
        
        //
        //  Put up the error message box.
        //
        if ( GetWindowText(hwndDlg, pszTitle, MAX_PATH) &&
             LoadString(g_hinst, MessageId, pszFormat, MAX_PATH) )
        {
            va_list ArgList;
        
            va_start(ArgList, MessageId);
            wvsprintf(pszMessage, pszFormat, ArgList);
            va_end(ArgList);
            MessageBeep(MB_ICONEXCLAMATION);
            MessageBox(hDlg, pszMessage, pszTitle, MB_ICONEXCLAMATION | MB_OK);
        }
        
        //
        //  Highlight the invalid value.
        //
        if (hEdit = ((Id == 0) ? NULL : GetDlgItem(hDlg, Id)))
        {
            SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)hEdit, 1L);
            SendMessage(hEdit, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
        }
    }
}


/*========================================================================*/
/*                 Ansi->Unicode Thunk routines                           */
/*========================================================================*/

#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  ThunkPrintDlgEx
//
////////////////////////////////////////////////////////////////////////////

HRESULT ThunkPrintDlgEx(
    PPRINTINFOEX pPI,
    LPPRINTDLGEXA pPDA)
{
    LPPRINTDLGEXW pPDW;
    LPDEVNAMES pDNA;
    LPDEVMODEA pDMA;
    DWORD cbLen;

    if (!pPDA)
    {
        pPI->dwExtendedError = CDERR_INITIALIZATION;
        return (E_INVALIDARG);
    }

    if (pPDA->lStructSize != sizeof(PRINTDLGEXA))
    {
        pPI->dwExtendedError = CDERR_STRUCTSIZE;
        return (E_INVALIDARG);
    }

    if (!(pPDW = (LPPRINTDLGEXW)GlobalAlloc(GPTR, sizeof(PRINTDLGEXW))))
    {
        pPI->dwExtendedError = CDERR_MEMALLOCFAILURE;
        return (E_OUTOFMEMORY);
    }

    //
    //  IN-only constant stuff.
    //
    pPDW->lStructSize      = sizeof(PRINTDLGEXW);
    pPDW->hwndOwner        = pPDA->hwndOwner;
    pPDW->hInstance        = pPDA->hInstance;
    pPDW->lpCallback       = pPDA->lpCallback;
    pPDW->nPropertyPages   = pPDA->nPropertyPages;
    pPDW->lphPropertyPages = pPDA->lphPropertyPages;
    pPDW->nStartPage       = pPDA->nStartPage;

    //
    //  IN-OUT Variable Structs.
    //
    if ((pPDA->hDevMode) && (pDMA = (LPDEVMODEA)GlobalLock(pPDA->hDevMode)))
    {
        //
        //  Make sure the device name in the devmode is not too long such that
        //  it has overwritten the other devmode fields.
        //
        if ((pDMA->dmSize < MIN_DEVMODE_SIZEA) ||
            (lstrlenA((LPCSTR)pDMA->dmDeviceName) > CCHDEVICENAME))
        {
            pPDW->hDevMode = NULL;
        }
        else
        {
            pPDW->hDevMode = GlobalAlloc( GHND,
                                          sizeof(DEVMODEW) + pDMA->dmDriverExtra );
        }
        GlobalUnlock(pPDA->hDevMode);
    }
    else
    {
        pPDW->hDevMode = NULL;
    }

    if ((pPDA->hDevNames) && (pDNA = (LPDEVNAMES)GlobalLock(pPDA->hDevNames)))
    {
        cbLen = lstrlenA((LPSTR)pDNA + pDNA->wOutputOffset) + 1 +
                lstrlenA((LPSTR)pDNA + pDNA->wDriverOffset) + 1 +
                lstrlenA((LPSTR)pDNA + pDNA->wDeviceOffset) + 1 +
                DN_PADDINGCHARS;

        cbLen *= sizeof(WCHAR);
        cbLen += sizeof(DEVNAMES);
        pPDW->hDevNames = GlobalAlloc(GHND, cbLen);
        GlobalUnlock(pPDA->hDevNames);
    }
    else
    {
        pPDW->hDevNames = NULL;
    }

    //
    //  IN-only constant strings.
    //
    //  Init Print TemplateName constant.
    //
    if ((pPDA->Flags & PD_ENABLEPRINTTEMPLATE) && (pPDA->lpPrintTemplateName))
    {
        //
        //  See if it's a string or an integer.
        //
        if (!IS_INTRESOURCE(pPDA->lpPrintTemplateName))
        {
            //
            //  String.
            //
            cbLen = lstrlenA(pPDA->lpPrintTemplateName) + 1;
            if (!(pPDW->lpPrintTemplateName = (LPCWSTR)
                     GlobalAlloc( GPTR,
                                  (cbLen * sizeof(WCHAR)) )))
            {
                pPI->dwExtendedError = CDERR_MEMALLOCFAILURE;
                return (E_OUTOFMEMORY);
            }
            else
            {
                pPI->fPrintTemplateAlloc = TRUE;
                MultiByteToWideChar( CP_ACP,
                                     0,
                                     pPDA->lpPrintTemplateName,
                                     -1,
                                     (LPWSTR)pPDW->lpPrintTemplateName,
                                     cbLen );
            }
        }
        else
        {
            //
            //  Integer.
            //
            pPDW->lpPrintTemplateName = (LPCWSTR)pPDA->lpPrintTemplateName;
        }
    }
    else
    {
        pPDW->lpPrintTemplateName = NULL;
    }

    //
    //  Store the info in the PRINTINFOEX structure.
    //
    pPI->pPD = pPDW;
    pPI->pPDA = pPDA;
    pPI->ApiType = COMDLG_ANSI;

    return (S_OK);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeThunkPrintDlgEx
//
////////////////////////////////////////////////////////////////////////////

VOID FreeThunkPrintDlgEx(
    PPRINTINFOEX pPI)
{
    LPPRINTDLGEXW pPDW = pPI->pPD;

    if (!pPDW)
    {
        return;
    }

    if (pPDW->hDevNames)
    {
        GlobalFree(pPDW->hDevNames);
    }

    if (pPDW->hDevMode)
    {
        GlobalFree(pPDW->hDevMode);
    }

    if (pPI->fPrintTemplateAlloc)
    {
        GlobalFree((LPWSTR)(pPDW->lpPrintTemplateName));
    }

    GlobalFree(pPDW);
    pPI->pPD = NULL;
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkPrintDlgExA2W
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkPrintDlgExA2W(
    PPRINTINFOEX pPI)
{
    LPPRINTDLGEXW pPDW = pPI->pPD;
    LPPRINTDLGEXA pPDA = pPI->pPDA;

    //
    //  Copy info A => W
    //
    pPDW->hDC            = pPDA->hDC;
    pPDW->Flags          = pPDA->Flags;
    pPDW->nPageRanges    = pPDA->nPageRanges;
    pPDW->nMaxPageRanges = pPDA->nMaxPageRanges;
    pPDW->lpPageRanges   = pPDA->lpPageRanges;
    pPDW->nMinPage       = pPDA->nMinPage;
    pPDW->nMaxPage       = pPDA->nMaxPage;
    pPDW->nCopies        = pPDA->nCopies;
    pPDW->lpCallback     = pPDA->lpCallback;
    pPDW->nStartPage     = pPDA->nStartPage;

    //
    //  Thunk Device Names A => W
    //
    if (pPDA->hDevNames && pPDW->hDevNames)
    {
        LPDEVNAMES pDNA = (LPDEVNAMES)GlobalLock(pPDA->hDevNames);
        LPDEVNAMES pDNW = (LPDEVNAMES)GlobalLock(pPDW->hDevNames);

        ThunkDevNamesA2W(pDNA, pDNW);

        GlobalUnlock(pPDW->hDevNames);
        GlobalUnlock(pPDA->hDevNames);
    }

    //
    //  Thunk Device Mode A => W
    //
    if (pPDA->hDevMode && pPDW->hDevMode)
    {
        LPDEVMODEW pDMW = (LPDEVMODEW)GlobalLock(pPDW->hDevMode);
        LPDEVMODEA pDMA = (LPDEVMODEA)GlobalLock(pPDA->hDevMode);

        ThunkDevModeA2W(pDMA, pDMW);

        GlobalUnlock(pPDW->hDevMode);
        GlobalUnlock(pPDA->hDevMode);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkPrintDlgExW2A
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkPrintDlgExW2A(
    PPRINTINFOEX pPI)
{
    LPPRINTDLGEXA pPDA = pPI->pPDA;
    LPPRINTDLGEXW pPDW = pPI->pPD;
    DWORD cbLen;

    //
    //  Copy info W => A
    //
    pPDA->hDC            = pPDW->hDC;
    pPDA->Flags          = pPDW->Flags;
    pPDA->nPageRanges    = pPDW->nPageRanges;
    pPDA->nMaxPageRanges = pPDW->nMaxPageRanges;
    pPDA->lpPageRanges   = pPDW->lpPageRanges;
    pPDA->nMinPage       = pPDW->nMinPage;
    pPDA->nMaxPage       = pPDW->nMaxPage;
    pPDA->nCopies        = pPDW->nCopies;
    pPDA->lpCallback     = pPDW->lpCallback;
    pPDA->nStartPage     = pPDW->nStartPage;

    //
    //  Thunk Device Names W => A
    //
    if (pPDW->hDevNames)
    {
        LPDEVNAMES pDNW = (LPDEVNAMES)GlobalLock(pPDW->hDevNames);
        LPDEVNAMES pDNA;

        cbLen = lstrlenW((LPWSTR)pDNW + pDNW->wOutputOffset) + 1 +
                lstrlenW((LPWSTR)pDNW + pDNW->wDriverOffset) + 1 +
                lstrlenW((LPWSTR)pDNW + pDNW->wDeviceOffset) + 1 +
                DN_PADDINGCHARS;
        cbLen += sizeof(DEVNAMES);
        if (pPDA->hDevNames)
        {
            HANDLE handle;
            
            handle = GlobalReAlloc(pPDA->hDevNames, cbLen, GHND);
            
            //Check that realloc succeeded.
            if (handle)
            {
                pPDA->hDevNames  = handle;
            }
            else
            {
                //Realloc didn't succeed. Free the memory occupied.
                GlobalFree(pPDA->hDevNames);
            }

        }
        else
        {
            pPDA->hDevNames = GlobalAlloc(GHND, cbLen);
        }
        if (pPDA->hDevNames)
        {
            pDNA = (LPDEVNAMES)GlobalLock(pPDA->hDevNames);
            ThunkDevNamesW2A(pDNW, pDNA);
            GlobalUnlock(pPDA->hDevNames);
        }
        GlobalUnlock(pPDW->hDevNames);
    }

    //
    //  Thunk Device Mode W => A
    //
    if (pPDW->hDevMode)
    {
        LPDEVMODEW pDMW = (LPDEVMODEW)GlobalLock(pPDW->hDevMode);
        LPDEVMODEA pDMA;

        if (pPDA->hDevMode)
        {
            HANDLE  handle;
            handle = GlobalReAlloc( pPDA->hDevMode,
                                            sizeof(DEVMODEA) + pDMW->dmDriverExtra,
                                            GHND );
            //Check that realloc succeeded.
            if (handle)
            {
                pPDA->hDevMode  = handle;
            }
            else
            {
                //Realloc didn't succeed. Free the memory occupied.
                GlobalFree(pPDA->hDevMode);
            }

        }
        else
        {
            pPDA->hDevMode = GlobalAlloc( GHND,
                                          sizeof(DEVMODEA) + pDMW->dmDriverExtra );
        }
        if (pPDA->hDevMode)
        {
            pDMA = (LPDEVMODEA)GlobalLock(pPDA->hDevMode);
            ThunkDevModeW2A(pDMW, pDMA);
            GlobalUnlock(pPDA->hDevMode);
        }
        GlobalUnlock(pPDW->hDevMode);
    }
}
#endif   // UNICODE
#endif   // WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\printnew.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    printnew.h

Abstract:

    This module contains the header information for the Win32
    property sheet print common dialogs.

Revision History:

    11-04-97    JulieB    Created.

--*/



#ifdef __cplusplus
extern "C" {
#endif



#ifdef WINNT

//
//  Include Files.
//

#include <dlgs.h>
#include <initguid.h>
#include <winprtp.h>




//
//  Constant Declarations.
//

//
//  Dialog Constants.
//
#define IDD_PRINT_GENERAL         100

#define IDI_COLLATE               ico1

#define IDC_PRINTER_LIST          1000
#define IDC_PRINTER_LISTVIEW      1001
#define IDC_PRINT_TO_FILE         1002
#define IDC_FIND_PRINTER          1003
#define IDC_STATUS_TEXT           1004
#define IDC_STATUS                1005
#define IDC_LOCATION_TEXT         1006
#define IDC_LOCATION              1007
#define IDC_COMMENT_TEXT          1008
#define IDC_COMMENT               1009

#define IDC_RANGE_ALL             rad1
#define IDC_RANGE_SELECTION       rad2
#define IDC_RANGE_CURRENT         rad3
#define IDC_RANGE_PAGES           rad4
#define IDC_RANGE_EDIT            edt1
#define IDC_RANGE_TEXT1           stc1
#define IDC_RANGE_TEXT2           stc2

#define IDC_COPIES                edt2
#define IDC_COPIES_TEXT           stc3
#define IDC_COLLATE               chx1

#define IDC_STATIC                -1




//
//  Typedef Declarations.
//

typedef struct
{
    UINT           ApiType;
    LPPRINTDLGEX   pPD;
    DWORD          ProcessVersion;
    DWORD          dwFlags;
    UINT           FinalResult;
    HRESULT        hResult;
    BOOL           fApply;
    BOOL           fOld;
    DWORD          dwExtendedError;
#ifdef UNICODE
    LPPRINTDLGEXA  pPDA;
    BOOL           fPrintTemplateAlloc;
#endif
} PRINTINFOEX, *PPRINTINFOEX;




//
//  Global Variables.
//

//
//  PrintUI.
//
PF_PRINTDLGSHEETSPROPPAGES PrintUI_bPrintDlgSheetsPropPages = NULL;
HMODULE hPrintUI = NULL;

//
//  Registry keys.
//
static const TCHAR c_szSettings[] = TEXT("Printers\\Settings");
static const TCHAR c_szViewMode[] = TEXT("ViewMode");




//
//  CPrintBrowser Class.
//

class CPrintBrowser : public IShellBrowser, 
                      public ICommDlgBrowser2, 
                      public IPrintDialogCallback, 
                      public IPrintDialogServices
{
public:

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG, AddRef) (THIS);
    STDMETHOD_(ULONG, Release) (THIS);

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND *lphwnd);
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode);

    // *** IShellBrowser methods *** (same as IOleInPlaceFrame)
    STDMETHOD(InsertMenusSB) (THIS_ HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHOD(SetMenuSB) (THIS_ HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHOD(RemoveMenusSB) (THIS_ HMENU hmenuShared);
    STDMETHOD(SetStatusTextSB) (THIS_ LPCOLESTR lpszStatusText);
    STDMETHOD(EnableModelessSB) (THIS_ BOOL fEnable);
    STDMETHOD(TranslateAcceleratorSB) (THIS_ LPMSG lpmsg, WORD wID);

    // *** IShellBrowser methods ***
    STDMETHOD(BrowseObject) (THIS_ LPCITEMIDLIST pidl, UINT wFlags);
    STDMETHOD(GetViewStateStream) (THIS_ DWORD grfMode, LPSTREAM *pStrm);
    STDMETHOD(GetControlWindow) (THIS_ UINT id, HWND *lphwnd);
    STDMETHOD(SendControlMsg) (THIS_ UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret);
    STDMETHOD(QueryActiveShellView) (THIS_ struct IShellView **ppshv);
    STDMETHOD(OnViewWindowActive) (THIS_ struct IShellView *pshv);
    STDMETHOD(SetToolbarItems) (THIS_ LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags);

    // *** ICommDlgBrowser2 methods ***
    STDMETHOD(OnDefaultCommand) (THIS_ struct IShellView *ppshv);
    STDMETHOD(OnStateChange) (THIS_ struct IShellView *ppshv, ULONG uChange);
    STDMETHOD(IncludeObject) (THIS_ struct IShellView *ppshv, LPCITEMIDLIST lpItem);
    STDMETHOD(Notify) (THIS_ struct IShellView *ppshv, DWORD dwNotifyType);
    STDMETHOD(GetDefaultMenuText) (THIS_ struct IShellView *ppshv, WCHAR *pszText, INT cchMax);
    STDMETHOD(GetViewFlags)(THIS_ DWORD *pdwFlags);

    // *** IPrintDialogCallback methods ***
    STDMETHOD(InitDone) (THIS);
    STDMETHOD(SelectionChange) (THIS);
    STDMETHOD(HandleMessage) (THIS_ HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pResult);

    // *** IPrintDialogServices methods ***
    STDMETHOD(GetCurrentDevMode) (THIS_ LPDEVMODE pDevMode, UINT *pcbSize);
    STDMETHOD(GetCurrentPrinterName) (THIS_ LPTSTR pPrinterName, UINT *pcchSize);
    STDMETHOD(GetCurrentPortName) (THIS_ LPTSTR pPortName, UINT *pcchSize);

    // *** Our own methods ***
    CPrintBrowser(HWND hDlg);
    ~CPrintBrowser();

    BOOL    OnInitDialog(WPARAM wParam, LPARAM lParam);
    BOOL    OnChildInitDialog(HWND hDlg, WPARAM wParam, LPARAM lParam);
    VOID    OnDestroyMessage();
    BOOL    OnCommandMessage(WPARAM wParam, LPARAM lParam);
    BOOL    OnChildCommandMessage(WPARAM wParam, LPARAM lParam);
    BOOL    OnNotifyMessage(WPARAM wParam, LPNMHDR lpnmhdr);
    BOOL    OnSelChange();
    BOOL    OnChangeNotify(LONG lNotification, LPCITEMIDLIST *ppidl);
    BOOL    OnAccelerator(HWND hwndActivePrint, HWND hwndFocus, HACCEL haccPrint, PMSG pMsg);
    VOID    OnNoPrinters(HWND hDlg, UINT iId);
    VOID    OnInitDone();

private:

    HRESULT CreatePrintShellView();
    UINT    GetViewMode();
    VOID    SetViewMode();
    HRESULT CreateHookDialog();
    BOOL    UpdateStatus(LPCITEMIDLIST pidl);
    BOOL    SelectSVItem();
    BOOL    IsPrinterInList(LPCTSTR pPrinter);
    BOOL    GetCurrentPrinter();
    VOID    InitPrintToFile();
    VOID    InitPageRangeGroup();
    VOID    InitCopiesAndCollate();
    BOOL    SaveCopiesAndCollateInDevMode(LPDEVMODE pDM, LPTSTR pszPrinter);
    BOOL    SetCopiesOnApply();
    VOID    SaveDevMode();
    BOOL    MergeDevMode(LPTSTR pszPrinterName);
    BOOL    IsValidPageRange(LPTSTR pszString, UINT *pErrorId);
    BOOL    ConvertPageRangesToString(LPTSTR pszString, UINT cchLen);
    UINT    IntegerToString(DWORD Value, LPTSTR pszString, UINT cchLen);
    VOID    ShowError(HWND hDlg, int Id, UINT MessageId, ...);

    UINT cRef;                         // compobj refcount
    HWND hwndDlg;                      // handle of this dialog
    HWND hSubDlg;                      // handle of the hook dialog
    HWND hwndView;                     // current view window
    IShellView *psv;                   // shell view object
    IShellFolderView *psfv;            // shell folder view object
    IShellFolder *psfRoot;             // print folder shell folder
    IShellDetails *psd;                // shell details object
    LPITEMIDLIST pidlRoot;             // pidl for print folder
    IPrinterFolder *ppf;               // printer folder private interface

    HIMAGELIST himl;                   // system imagelist (small images)

    PPRINTDLG_PAGE pPrintDlgPage;      // ptr to PRINTDLG_PAGE struct (printui)
    PPRINTINFOEX pPI;                  // ptr to PRINTINFOEX struct
    LPPRINTDLGEX pPD;                  // caller's PRINTDLGEX struct

    IPrintDialogCallback *pCallback;   // ptr to app's callback interface
    IObjectWithSite *pSite;            // ptr to app's SetSite interface

    LPDEVMODE pDMInit;                 // ptr to the initial DEVMODE struct
    LPDEVMODE pDMCur;                  // ptr to the current DEVMODE struct
    LPDEVMODE pDMSave;                 // ptr to the last good DEVMODE struct

    UINT cchCurPrinter;                // size, in chars, of pszCurPrinter
    LPTSTR pszCurPrinter;              // ptr to name of current printer

    DWORD nCopies;                     // number of copies
    DWORD nPageRanges;                 // number of page ranges in pPageRange
    DWORD nMaxPageRanges;              // max number of page ranges allowed
    LPPRINTPAGERANGE pPageRanges;      // ptr to an array of page range structs

    BOOL fCollateRequested;            // collate is requested
    BOOL fSelChangePending;            // we have a selchange message pending
    BOOL fFirstSel;                    // still need to set first selection
    BOOL fAPWSelected;                 // add printer wizard is selected
    BOOL fNoAccessPrinterSelected;     // a printer we do not have access to is selected
    BOOL fDontSelectPrinter;           // dont track printer selection

    UINT nInitDone;                    // number of CDM_INITDONE messages

    UINT nListSep;                     // number of characters in szListSep
    TCHAR szListSep[20];               // list separator

    UINT uRegister;                    // change notify register

    TCHAR szScratch[MAX_PATH * 2];     // scratch buffer

};




//
//  Context Help IDs.
//

DWORD aPrintExHelpIDs[] =
{
    grp1,                    NO_HELP,
    IDC_PRINTER_LISTVIEW,    IDH_PRINT_PRINTER_FOLDER,

    IDC_STATUS_TEXT,         IDH_PRINT_SETUP_DETAILS,
    IDC_STATUS,              IDH_PRINT_SETUP_DETAILS,
    IDC_LOCATION_TEXT,       IDH_PRINT_SETUP_DETAILS,
    IDC_LOCATION,            IDH_PRINT_SETUP_DETAILS,
    IDC_COMMENT_TEXT,        IDH_PRINT_SETUP_DETAILS,
    IDC_COMMENT,             IDH_PRINT_SETUP_DETAILS,

    IDC_PRINT_TO_FILE,       IDH_PRINT_TO_FILE,
    IDC_FIND_PRINTER,        IDH_PRINT_FIND_PRINTER,

    grp2,                    NO_HELP,

    0, 0
};


DWORD aPrintExChildHelpIDs[] =
{
    grp1,                    NO_HELP,
    IDC_RANGE_ALL,           IDH_PRINT32_RANGE,
    IDC_RANGE_SELECTION,     IDH_PRINT32_RANGE,
    IDC_RANGE_CURRENT,       IDH_PRINT32_RANGE,
    IDC_RANGE_PAGES,         IDH_PRINT32_RANGE,
    IDC_RANGE_EDIT,          IDH_PRINT32_RANGE,
    IDC_RANGE_TEXT1,         IDH_PRINT32_RANGE,
    IDC_RANGE_TEXT2,         IDH_PRINT32_RANGE,

    grp2,                    NO_HELP,
    IDC_COPIES,              IDH_PRINT_COPIES,
    IDC_COPIES_TEXT,         IDH_PRINT_COPIES,
    IDC_COLLATE,             IDH_PRINT_COLLATE,
    IDI_COLLATE,             IDH_PRINT_COLLATE,

    0, 0
};




//
//  Function Prototypes.
//

HRESULT
PrintDlgExX(
    PPRINTINFOEX pPI);

HRESULT
Print_ReturnDefault(
    PPRINTINFOEX pPI);

BOOL
Print_LoadLibraries();

VOID
Print_UnloadLibraries();

BOOL
Print_LoadIcons();

BOOL
Print_InvokePropertySheets(
    PPRINTINFOEX pPI,
    LPPRINTDLGEX pPD);

BOOL_PTR
Print_GeneralDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

BOOL_PTR
Print_GeneralChildDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

LRESULT
Print_MessageHookProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam);

BOOL
Print_InitDialog(
    HWND hDlg,
    WPARAM wParam,
    LPARAM lParam);

HRESULT
Print_ICoCreateInstance(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID *ppv);

BOOL
Print_SaveDevNames(
    LPTSTR pCurPrinter,
    LPPRINTDLGEX pPD);

VOID
Print_GetPortName(
    LPTSTR pCurPrinter,
    LPTSTR pBuffer,
    int cchBuffer);

HANDLE
Print_GetDevModeWrapper(
    LPTSTR pszDeviceName,
    HANDLE hDevMode);

BOOL
Print_NewPrintDlg(
    PPRINTINFO pPI);


#ifdef UNICODE
  HRESULT
  ThunkPrintDlgEx(
      PPRINTINFOEX pPI,
      LPPRINTDLGEXA pPDA);

  VOID
  FreeThunkPrintDlgEx(
      PPRINTINFOEX pPI);

  VOID
  ThunkPrintDlgExA2W(
      PPRINTINFOEX pPI);

  VOID
  ThunkPrintDlgExW2A(
      PPRINTINFOEX pPI);
#endif

#endif   // WINNT

#ifdef __cplusplus
};  // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\prnsetup.c ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    prnsetup.c

Abstract:

    This module implements the Win32 print dialogs.

Revision History:

--*/



//
//  Include Files.
//

#undef WINVER
#define WINVER 0x0500       // Needed to get the updated DMPAPER constants.

#include "comdlg32.h"
#include <winspool.h>
#include <commctrl.h>
#include "prnsetup.h"




//
//  Extern Declarations.
//
#ifdef UNICODE
extern UINT ExtDeviceMode(HWND, HMODULE, LPDEVMODEA, LPSTR, LPSTR, LPDEVMODEA, LPSTR, UINT);
#endif

//
//  The PrintDlgEx routines.
//
extern VOID Print_UnloadLibraries();
extern BOOL Print_NewPrintDlg(PPRINTINFO pPI);





#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgA
//
//  ANSI entry point for PrintDlg when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI PrintDlgA(
    LPPRINTDLGA pPDA)
{
    PRINTINFO PI;
    BOOL bResult = FALSE;
    DWORD Flags;


    ZeroMemory(&PI, sizeof(PRINTINFO));

    if (bResult = ThunkPrintDlg(&PI, pPDA))
    {
        ThunkPrintDlgA2W(&PI);

        Flags = pPDA->Flags;

        bResult = PrintDlgX(&PI);

        if ((bResult) || (Flags & (PD_ENABLEPRINTHOOK | PD_ENABLESETUPHOOK)))
        {
            ThunkPrintDlgW2A(&PI);
        }
    }
    FreeThunkPrintDlg(&PI);

    return (bResult);
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgW
//
//  Stub UNICODE function for PrintDlg when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI PrintDlgW(
    LPPRINTDLGW pPDW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#endif


////////////////////////////////////////////////////////////////////////////
//
//  PrintDlg
//
//  The PrintDlg function displays a Print dialog box or a Print Setup
//  dialog box.  The Print dialog box enables the user to specify the
//  properties of a particular print job.  The Print Setup dialog box
//  allows the user to select additional job properties and to configure
//  the printer.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI PrintDlg(
    LPPRINTDLG pPD)
{
    PRINTINFO PI;

    ZeroMemory(&PI, sizeof(PRINTINFO));

    PI.pPD = pPD;
    PI.ApiType = COMDLG_WIDE;

    return ( PrintDlgX(&PI) );
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgX
//
//  Worker routine for the PrintDlg api.
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintDlgX(
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    BOOL nResult = -1;                      // <0==error, 0==CANCEL, >0==OK
    LPDEVMODE pDM = NULL;
    LPDEVMODE pDevMode = NULL;
    LPDEVNAMES pDN = NULL;
    DWORD dwFlags;                          // old copy
    WORD nCopies, nFromPage, nToPage;       // old copy
    HGLOBAL hDevNames, hDevMode;            // old copy
    TCHAR szPrinterName[MAX_PRINTERNAME];   // old copy
    LONG cbNeeded;
#ifndef WINNT
    LPCTSTR pDN_Device = NULL;
    TCHAR szDev[2];
#endif
    DWORD dwResult;


    if (!pPD)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pPD->lStructSize != sizeof(PRINTDLG))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if (pPD->hwndOwner && !IsWindow(pPD->hwndOwner))
    {
        StoreExtendedError(CDERR_DIALOGFAILURE);
        return (FALSE);
    }

#ifdef WINNT
    //
    //  See if the application should get the new look.
    //
    //  Do not allow the new look if they have hooks, templates,
    //  they want the setup dialog, or they just want to get the default
    //  printer.
    //
    //  Also don't allow the new look if we are in the context of
    //  a 16 bit process.
    //
    if ( (!(pPI->Status & PI_PRINTDLGX_RECURSE)) &&
         (!pPI->pPSD) &&
         ((!(pPD->Flags & (PD_PAGESETUP |
                           PD_PRINTSETUP |
                           PD_RETURNDEFAULT |
                           PD_ENABLEPRINTHOOK |
                           PD_ENABLESETUPHOOK |
                           PD_ENABLEPRINTTEMPLATE |
                           PD_ENABLESETUPTEMPLATE |
                           PD_ENABLEPRINTTEMPLATEHANDLE |
                           PD_ENABLESETUPTEMPLATEHANDLE)))) &&
         (!IS16BITWOWAPP(pPD)) )
    {
        //
        //  Show the new dialog.  If we get a failure, try the old dialog.
        //
        StoreExtendedError(0);

        nResult = Print_NewPrintDlg(pPI);

        if (nResult || (GetStoredExtendedError() == 0))
        {
            return (nResult);
        }
    }
#endif

    //
    //  Get the process version of the app for later use.
    //
    pPI->ProcessVersion = GetProcessVersion(0);

#ifdef UNICODE
    //
    //  Check if we need to use ExtDeviceMode.  We use this
    //  mode only if a 16 bit app is calling us with a NULL
    //  devmode.
    //
    if ((pPD->Flags & CD_WOWAPP) && !pPD->hDevMode)
    {
        pPI->bUseExtDeviceMode = TRUE;
    }
    else
    {
        pPI->bUseExtDeviceMode = FALSE;
    }
#endif

#ifndef WINNT
    //
    //  This should NOT be in NT.  The device name cannot be longer than
    //  32 characters, so it may be truncated.  If we look for it in the
    //  registry and it's supposed to be larger than 32 characters, then
    //  we won't find it and we'll fail.
    //
    //  LATER: It probably shouldn't be in WIN95 either, but I'll leave
    //         it for now.
    //
    if (pPD->hDevMode)
    {
        if (!(pDM = GlobalLock(pPD->hDevMode)))
        {
            StoreExtendedError(CDERR_MEMLOCKFAILURE);
            goto PrintDlgX_DisplayWarning;
        }
    }

    if (pPD->hDevNames)
    {
        if (!(pDN = GlobalLock(pPD->hDevNames)))
        {
            if (pDM)
            {
                GlobalUnlock(pPD->hDevMode);
            }
            StoreExtendedError(CDERR_MEMLOCKFAILURE);
            goto PrintDlgX_DisplayWarning;
        }
        else
        {
            if (pDN->wDeviceOffset)
            {
                pDN_Device = (LPCTSTR)pDN + pDN->wDeviceOffset;
            }
        }
    }

    if (pDM && pDM->dmDeviceName[0])
    {
        pDM->dmDeviceName[CCHDEVICENAME - 1] = 0;
        GetProfileString(szTextDevices, pDM->dmDeviceName, szTextNull, szDev, 2);
        if (!szDev[0])
        {
            GlobalUnlock(pPD->hDevMode);
            if (pDN)
            {
                GlobalUnlock(pPD->hDevNames);
            }
            StoreExtendedError(PDERR_PRINTERNOTFOUND);
            goto PrintDlgX_DisplayWarning;
        }
    }

    if (pDN_Device && pDN_Device[0])
    {
        GetProfileString(szTextDevices, pDN_Device, szTextNull, szDev, 2);
        if (!szDev[0])
        {
            if (pDM)
            {
                GlobalUnlock(pPD->hDevMode);
            }
            GlobalUnlock(pPD->hDevNames);
            StoreExtendedError(PDERR_PRINTERNOTFOUND);
            goto PrintDlgX_DisplayWarning;
        }
    }

    if (pDM)
    {
        GlobalUnlock(pPD->hDevMode);
    }
    if (pDN)
    {
        GlobalUnlock(pPD->hDevNames);
    }
#endif

    pPD->hDC = 0;

    StoreExtendedError(CDERR_GENERALCODES);

    //
    //  Do minimal work when requesting a default printer.
    //
    if (pPD->Flags & PD_RETURNDEFAULT)
    {
        //
        //  Do not display a warning in this case if it fails.
        //  MFC 3.1 does not specify PD_NOWARNING, but that's what
        //  it really wants.
        //
        nResult = PrintReturnDefault(pPI);
        PrintClosePrinters(pPI);
        return (nResult);
    }

    if (!PrintLoadIcons())
    {
        //
        //  If the icons cannot be loaded, then fail.
        //
        StoreExtendedError(PDERR_SETUPFAILURE);
        goto PrintDlgX_DisplayWarning;
    }

    //
    //  Printer enumeration is delayed until the combobox is dropped down.
    //  However, if a printer is specified, we must force enumeration in
    //  order to find the printer so that the correct devmode can be created.
    //
    if ((pPD->hDevMode) &&
        (pPD->hDevNames) &&
        (pDM = GlobalLock(pPD->hDevMode)))
    {
        if (pDN = GlobalLock(pPD->hDevNames))
        {
            dwResult = lstrcmp((LPTSTR)pDM->dmDeviceName,
                               (LPTSTR)pDN + pDN->wDeviceOffset);
            GlobalUnlock(pPD->hDevNames);
        }
        GlobalUnlock(pPD->hDevMode);
    }

    //
    //  First : Try to open the printer in the DevMode.
    //
    //  Note: The printer name field in the DEVMODE struct is limited to
    //        32 chars which may cause this case to fail.
    //
    if ( (!dwResult) &&
         (!pPI->hCurPrinter) &&
         (pPD->hDevMode) &&
         (pDM = GlobalLock(pPD->hDevMode)) )
    {
        PrintOpenPrinter(pPI, pDM->dmDeviceName);
        GlobalUnlock(pPD->hDevMode);
    }

    //
    //  Second : Try to open the printer in the DevNames.
    //
    if ( (!pPI->hCurPrinter) &&
         (pPD->hDevNames) &&
         (pDN = GlobalLock(pPD->hDevNames)) )
    {
        PrintOpenPrinter(pPI, (LPTSTR)pDN + pDN->wDeviceOffset);
        GlobalUnlock(pPD->hDevNames);
    }

    //
    //  Third : Try to open the Default Printer.
    //
    PrintGetDefaultPrinterName(pPI->szDefaultPrinter, MAX_PRINTERNAME);
    if (!pPI->hCurPrinter)
    {
        if (pPI->szDefaultPrinter[0])
        {
            PrintOpenPrinter(pPI, pPI->szDefaultPrinter);
        }
    }

    //
    //  Fourth : Enumerate the Printers and try to open one of those.
    //
    if (!pPI->hCurPrinter)
    {
        if (!PrintEnumAndSelect(pPD->hwndOwner, 0, pPI, NULL, TRUE))
        {
            //
            //  There are no printers installed in the system.
            //
            goto PrintDlgX_DisplayWarning;
        }
    }

    //
    //  Save the original information passed in by the app in case the user
    //  hits cancel.
    //
    dwFlags = pPD->Flags;
    nCopies = pPD->nCopies;
    nFromPage = pPD->nFromPage;
    nToPage = pPD->nToPage;
    hDevNames = pPD->hDevNames;
    hDevMode = pPD->hDevMode;
    if ((pPI->pCurPrinter) &&
        (lstrlen(pPI->pCurPrinter->pPrinterName) < MAX_PRINTERNAME))
    {
        lstrcpy(szPrinterName, pPI->pCurPrinter->pPrinterName);
    }
    else
    {
        szPrinterName[0] = 0;
    }

    pPD->hDevNames = NULL;
    pPD->hDevMode = NULL;

    //
    //  Build a copy of the DevNames.
    //
    PrintBuildDevNames(pPI);

    //
    //  Get the *correct* DevMode.
    //
    if (hDevMode)
    {
        pDevMode = GlobalLock(hDevMode);
    }

#ifdef UNICODE
    else
    {
        //
        //  If it's WOW and the app didn't specify a devmode, get the 16-bit
        //  devmode out of the registry (ie. win.ini [Windows] device section).
        //
        if (pPI->bUseExtDeviceMode)
        {
            pDevMode = (pPI->pCurPrinter)->pDevMode;
            if (pDevMode)
            {
                cbNeeded = sizeof(DEVMODEW) + pDevMode->dmDriverExtra;
                goto GotWOWDMSize;
            }

            //
            //  If a 16-bit devmode isn't available in the registry,
            //  drop through and get the system default devmode.
            //
        }
    }
#endif

    cbNeeded = DocumentProperties( pPD->hwndOwner,
                                   pPI->hCurPrinter,
                                   (pPI->pCurPrinter)
                                       ? pPI->pCurPrinter->pPrinterName
                                       : NULL,
                                   NULL,
                                   NULL,
                                   0 );
#ifdef UNICODE
GotWOWDMSize:
#endif
    if ((cbNeeded > 0) &&
        (pPD->hDevMode = GlobalAlloc(GHND, cbNeeded)))
    {
        BOOL fSuccess = FALSE;

        if (pDM = GlobalLock(pPD->hDevMode))
        {
#ifdef UNICODE
            if (pPI->bUseExtDeviceMode && !hDevMode)
            {
                CopyMemory(pDM, pDevMode, cbNeeded);
                fSuccess = TRUE;
                goto GotNewWOWDM;
            }
#endif
            fSuccess = DocumentProperties( pPD->hwndOwner,
                                           pPI->hCurPrinter,
                                           (pPI->pCurPrinter)
                                               ? pPI->pCurPrinter->pPrinterName
                                               : NULL,
                                           pDM,            // out
                                           pDevMode,       // in
                                           DM_MODIFY | DM_COPY ) == IDOK;
#ifdef UNICODE
GotNewWOWDM:
#endif
            if (pDM->dmFields & DM_COPIES)
            {
                if ((hDevMode) || (pPD->Flags & PD_USEDEVMODECOPIES))
                {
                    pPD->nCopies = pDM->dmCopies;
                }
                else if (pPD->nCopies)
                {
                    pDM->dmCopies = pPD->nCopies;
                }
            }
            if (pDM->dmFields & DM_COLLATE)
            {
                if ((hDevMode) || (pPD->Flags & PD_USEDEVMODECOPIES))
                {
                    if (pDM->dmCollate == DMCOLLATE_FALSE)
                    {
                        pPD->Flags  &= ~PD_COLLATE;
                        pPI->Status &= ~PI_COLLATE_REQUESTED;
                    }
                    else
                    {
                        pPD->Flags  |= PD_COLLATE;
                        pPI->Status |= PI_COLLATE_REQUESTED;
                    }
                }
                else
                {
                    pDM->dmCollate = (pPD->Flags & PD_COLLATE)
                                         ? DMCOLLATE_TRUE
                                         : DMCOLLATE_FALSE;
                }
            }

            GlobalUnlock(pPD->hDevMode);
        }

        if (!fSuccess)
        {
            GlobalFree(pPD->hDevMode);
            pPD->hDevMode = NULL;
        }
    }

    if (hDevMode)
    {
        GlobalUnlock(hDevMode);
    }

    //
    //  Get the default source string.
    //
    LoadString(g_hinst, iszDefaultSource, szDefaultSrc, SCRATCHBUF_SIZE);

    //
    //  Call the appropriate dialog routine.
    //
    switch (pPD->Flags & (PD_PRINTSETUP | PD_PAGESETUP))
    {
        case ( 0 ) :
        {
            nResult = PrintDisplayPrintDlg(pPI);
            break;
        }
        case ( PD_PRINTSETUP ) :
        case ( PD_PAGESETUP ) :
        {
            nResult = PrintDisplaySetupDlg(pPI);
            break;
        }
        default :
        {
            StoreExtendedError(CDERR_INITIALIZATION);
            break;
        }
    }

    if (nResult > 0)
    {
        //
        //  User hit OK, so free the copies of the handles passed in
        //  by the app.
        //
        if (hDevMode && (hDevMode != pPD->hDevMode))
        {
            GlobalFree(hDevMode);
            hDevMode = NULL;
        }
        if (hDevNames && (hDevNames != pPD->hDevNames))
        {
            GlobalFree(hDevNames);
            hDevNames = NULL;
        }

        if (pPD->hDevMode)
        {
            //
            //  Make sure the device name in the devmode is null
            //  terminated.
            //
            pDevMode = GlobalLock(pPD->hDevMode);
            pDevMode->dmDeviceName[CCHDEVICENAME - 1] = 0;
            GlobalUnlock(pPD->hDevMode);
        }
    }
    else
    {
        //
        //  User hit CANCEL or there was an error, so restore original
        //  values passed in by the app.
        //
        pPD->Flags = dwFlags;
        pPD->nCopies = nCopies;
        pPD->nFromPage = nFromPage;
        pPD->nToPage = nToPage;
        if (pPD->hDevMode && (pPD->hDevMode != hDevMode))
        {
            GlobalFree(pPD->hDevMode);
        }
        if (pPD->hDevNames && (pPD->hDevNames != hDevNames))
        {
            GlobalFree(pPD->hDevNames);
        }
        pPD->hDevNames = hDevNames;
        pPD->hDevMode = hDevMode;

        //
        //  If we've been called from Page Setup, then we need to reset
        //  the current printer.
        //
        if (pPI->Status & PI_PRINTDLGX_RECURSE)
        {
            PrintCancelPrinterChanged(pPI, szPrinterName);
        }
    }

    //
    //  Make sure that we are really supposed to be leaving this function
    //  before we start closing printers and displaying error messages.
    //
    if (pPI->Status & PI_PRINTDLGX_RECURSE)
    {
        return (nResult > 0);
    }

    //
    //  Close the printers that were opened.
    //
    PrintClosePrinters(pPI);

    //
    //  Display any error messages.
    //
PrintDlgX_DisplayWarning:

    if ((nResult < 0) && (!(pPD->Flags & PD_NOWARNING)))
    {
        DWORD dwErr = GetStoredExtendedError();

        //
        //  Only do this for new apps.
        //
        if ( (pPI->ProcessVersion >= 0x40000) ||
             (dwErr == PDERR_NODEFAULTPRN) ||
             (dwErr == PDERR_PRINTERNOTFOUND) )
        {
            TCHAR szWarning[SCRATCHBUF_SIZE];
            TCHAR szTitle[SCRATCHBUF_SIZE];
            int iszWarning;

            szTitle[0] = TEXT('\0');
            if (pPD->hwndOwner)
            {
                GetWindowText(pPD->hwndOwner, szTitle, SCRATCHBUF_SIZE);
            }
            if (!szTitle[0])
            {
                LoadString(g_hinst, iszWarningTitle, szTitle, SCRATCHBUF_SIZE);
            }

            switch (dwErr)
            {
                case ( PDERR_NODEFAULTPRN ) :
                {
                    iszWarning = iszNoPrnsInstalled;
                    break;
                }
                case ( PDERR_PRINTERNOTFOUND ) :
                {
                    iszWarning = iszPrnNotFound;
                    break;
                }
                case ( CDERR_MEMLOCKFAILURE ) :
                case ( CDERR_MEMALLOCFAILURE ) :
                case ( PDERR_LOADDRVFAILURE ) :
                {
                    iszWarning = iszMemoryError;
                    break;
                }
                default :
                {
                    iszWarning = iszGeneralWarning;
                    break;
                }
            }

            LoadString(g_hinst, iszWarning, szWarning, SCRATCHBUF_SIZE);
            MessageBeep(MB_ICONEXCLAMATION);
            MessageBox( pPD->hwndOwner,
                        szWarning,
                        szTitle,
                        MB_ICONEXCLAMATION | MB_OK );
        }
    }

    return (nResult > 0);
}


#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  PageSetupDlgA
//
//  ANSI entry point for PageSetupDlg when this code is built UNICODE.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI PageSetupDlgA(
    LPPAGESETUPDLGA pPSDA)
{
    PRINTINFO PI;
    BOOL bResult = FALSE;
    HANDLE hDevMode;
    HANDLE hDevNames;
    LPCSTR pTemplateName;


    ZeroMemory(&PI, sizeof(PRINTINFO));

    //
    //  Get the pPDA structure from the pPSDA structure.
    //
    if (bResult = ThunkPageSetupDlg(&PI, pPSDA))
    {
        //
        //  Save the original devmode and devnames.
        //
        hDevMode = pPSDA->hDevMode;
        hDevNames = pPSDA->hDevNames;
        pTemplateName = pPSDA->lpPageSetupTemplateName;

        //
        //  Convert the pPDA structure to Unicode (pPI->pPD).
        //
        if (bResult = ThunkPrintDlg(&PI, PI.pPDA))
        {
            //
            //  Fill in the pPI->pPD structure.
            //
            ThunkPrintDlgA2W(&PI);

            //
            //  Copy the Unicode information from the pPD structure to
            //  the pPSD structure for the call to PageSetupDlgX.
            //
            (PI.pPSD)->hDevMode  = (PI.pPD)->hDevMode;
            (PI.pPSD)->hDevNames = (PI.pPD)->hDevNames;

            (PI.pPSD)->lpPageSetupTemplateName = (PI.pPD)->lpSetupTemplateName;

            //
            //  Call the PageSetupDlgX function to do the work.
            //
            if (bResult = PageSetupDlgX(&PI))
            {
                //
                //  Success.  Convert the Unicode pPD structure to
                //  its ANSI equivalent.
                //
                ThunkPrintDlgW2A(&PI);

                //
                //  Save the ANSI devmode and devnames in the
                //  pPSD structure to be returned to the caller.
                //
                pPSDA->hDevMode  = (PI.pPDA)->hDevMode;
                pPSDA->hDevNames = (PI.pPDA)->hDevNames;
            }
            else
            {
                //
                //  Failure.  Restore the old devmode and devnames.
                //
                pPSDA->hDevMode = hDevMode;
                pPSDA->hDevNames = hDevNames;
            }

            //
            //  Restore the old template name (always).
            //
            pPSDA->lpPageSetupTemplateName = pTemplateName;
        }
        FreeThunkPrintDlg(&PI);
    }
    FreeThunkPageSetupDlg(&PI);

    return (bResult);
}

#else

////////////////////////////////////////////////////////////////////////////
//
//  PageSetupDlgW
//
//  Stub UNICODE function for PageSetupDlg when this code is built ANSI.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI PageSetupDlgW(
    LPPAGESETUPDLGW pPSDW)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return (FALSE);
}

#endif


////////////////////////////////////////////////////////////////////////////
//
//  PageSetupDlg
//
//  The PageSetupDlg function displays a Page Setup dialog box.  This
//  dialog box enables the user to specify the page orientation, the
//  paper size, the paper source, and the margin settings.  The
//  appearance of the printed page is shown in the dialog's page preview.
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI PageSetupDlg(
    LPPAGESETUPDLG pPSD)
{
    PRINTINFO PI;
    BOOL bResult;

    ZeroMemory(&PI, sizeof(PRINTINFO));

    PI.pPSD = pPSD;
    PI.ApiType = COMDLG_WIDE;

    bResult = PageSetupDlgX(&PI);

    if (PI.pPD)
    {
        GlobalFree(PI.pPD);
    }

    return (bResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  PageSetupDlgX
//
//  Worker routine for the PageSetupDlg api.
//
//  NOTE:  Caller of this routine must free pPI->pPD.
//
////////////////////////////////////////////////////////////////////////////

BOOL PageSetupDlgX(
    PPRINTINFO pPI)
{
    LPPAGESETUPDLG pPSD = pPI->pPSD;
    BOOL bResult = FALSE;
    LPPRINTDLG pPD;
    RECT rtMinMargin;
    RECT rtMargin;
    POINT ptPaperSize;
    DWORD Flags;


    if (!pPSD)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pPSD->lStructSize != sizeof(PAGESETUPDLG))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if ((pPSD->Flags & PSD_RETURNDEFAULT) &&
        (pPSD->hDevNames || pPSD->hDevMode))
    {
        StoreExtendedError(PDERR_RETDEFFAILURE);
        return (FALSE);
    }

    //
    //  Make sure only the PSD_* bits are on.  Otherwise, bad things
    //  will happen.
    //
    if ((pPSD->Flags & ~(PSD_MINMARGINS |
                         PSD_MARGINS |
                         PSD_INTHOUSANDTHSOFINCHES |
                         PSD_INHUNDREDTHSOFMILLIMETERS |
                         PSD_DISABLEMARGINS |
                         PSD_DISABLEPRINTER |
                         PSD_NOWARNING |                     // must be same as PD_*
                         PSD_DISABLEORIENTATION |
                         PSD_DISABLEPAPER |
                         PSD_RETURNDEFAULT |                 // must be same as PD_*
                         PSD_SHOWHELP |                      // must be same as PD_*
                         PSD_ENABLEPAGESETUPHOOK |           // must be same as PD_*
                         PSD_ENABLEPAGESETUPTEMPLATE |       // must be same as PD_*
                         PSD_ENABLEPAGESETUPTEMPLATEHANDLE | // must be same as PD_*
                         PSD_ENABLEPAGEPAINTHOOK |
                         PSD_DISABLEPAGEPAINTING |
                         CD_WX86APP |
                         PSD_NONETWORKBUTTON))  ||           // must be same as PD_*
        ((pPSD->Flags & (PSD_INTHOUSANDTHSOFINCHES |
                         PSD_INHUNDREDTHSOFMILLIMETERS)) ==
         (PSD_INTHOUSANDTHSOFINCHES | PSD_INHUNDREDTHSOFMILLIMETERS)))
    {
        StoreExtendedError(PDERR_INITFAILURE);
        return (FALSE);
    }

    if ((pPSD->Flags & PSD_MINMARGINS) && (pPSD->Flags & PSD_MARGINS))
    {
        if ( (pPSD->rtMargin.left   < pPSD->rtMinMargin.left)  ||
             (pPSD->rtMargin.top    < pPSD->rtMinMargin.top)   ||
             (pPSD->rtMargin.right  < pPSD->rtMinMargin.right) ||
             (pPSD->rtMargin.bottom < pPSD->rtMinMargin.bottom) )
        {
            StoreExtendedError(PDERR_INITFAILURE);
            return (FALSE);
        }
    }

    if (pPSD->Flags & PSD_ENABLEPAGESETUPHOOK)
    {
        if (!pPSD->lpfnPageSetupHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pPSD->lpfnPageSetupHook = NULL;
    }

    if (pPSD->Flags & PSD_ENABLEPAGEPAINTHOOK)
    {
        if (!pPSD->lpfnPagePaintHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pPSD->lpfnPagePaintHook = NULL;
    }

    if ((pPI->pPD) || (pPI->pPD = GlobalAlloc(GPTR, sizeof(PRINTDLG))))
    {
        pPD = pPI->pPD;

        pPD->lStructSize         = sizeof(PRINTDLG);
        pPD->hwndOwner           = pPSD->hwndOwner;
        pPD->Flags               = PD_PAGESETUP |
                                     (pPSD->Flags &
                                       (PSD_NOWARNING |
                                        PSD_SHOWHELP |
                                        PSD_ENABLEPAGESETUPHOOK |
                                        PSD_ENABLEPAGESETUPTEMPLATE |
                                        PSD_ENABLEPAGESETUPTEMPLATEHANDLE |
                                        CD_WX86APP |
                                        PSD_NONETWORKBUTTON));
        pPD->hInstance           = pPSD->hInstance;
        pPD->lCustData           = pPSD->lCustData;
        pPD->lpfnSetupHook       = pPSD->lpfnPageSetupHook;
        pPD->lpSetupTemplateName = pPSD->lpPageSetupTemplateName;
        pPD->hSetupTemplate      = pPSD->hPageSetupTemplate;

        //
        //  Save original settings in case the user hits cancel.
        //
        rtMinMargin = pPSD->rtMinMargin;
        rtMargin    = pPSD->rtMargin;
        ptPaperSize = pPSD->ptPaperSize;
        Flags       = pPSD->Flags;

        //
        //  Make sure the measure choice is set.
        //
        if ((pPSD->Flags & (PSD_INTHOUSANDTHSOFINCHES |
                            PSD_INHUNDREDTHSOFMILLIMETERS)) == 0)
        {
            TCHAR szIMeasure[2];

            GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IMEASURE, szIMeasure, 2);
            if (szIMeasure[0] == TEXT('1'))
            {
                pPSD->Flags |= PSD_INTHOUSANDTHSOFINCHES;
            }
            else
            {
                pPSD->Flags |= PSD_INHUNDREDTHSOFMILLIMETERS;
            }
        }

        //
        //  Set minimum margins to 0 if not passed in.
        //
        if (!(pPSD->Flags & PSD_MINMARGINS))
        {
            pPSD->rtMinMargin.left   = 0;
            pPSD->rtMinMargin.top    = 0;
            pPSD->rtMinMargin.right  = 0;
            pPSD->rtMinMargin.bottom = 0;
        }

        //
        //  Set margins to defaults if not passed in.
        //
        if (!(pPSD->Flags & PSD_MARGINS))
        {
            LONG MarginDefault = (pPSD->Flags & PSD_INTHOUSANDTHSOFINCHES)
                                     ? INCHES_DEFAULT
                                     : MMS_DEFAULT;

            pPSD->rtMargin.left   = MarginDefault;
            pPSD->rtMargin.top    = MarginDefault;
            pPSD->rtMargin.right  = MarginDefault;
            pPSD->rtMargin.bottom = MarginDefault;
        }

        TransferPSD2PD(pPI);

        bResult = PrintDlgX(pPI);

        TransferPD2PSD(pPI);

        if (!bResult)
        {
            //
            //  Restore original settings when the user hits cancel.
            //
            pPSD->rtMinMargin = rtMinMargin;
            pPSD->rtMargin    = rtMargin;
            pPSD->ptPaperSize = ptPaperSize;
            pPSD->Flags       = Flags;
        }
    }
    else
    {
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
    }

    return (bResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintLoadIcons
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintLoadIcons()
{
    //
    //  See if we need to load the icons.
    //
    if (bAllIconsLoaded == FALSE)
    {
        //
        //  Load the orientation icons.
        //
        hIconPortrait = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_PORTRAIT));
        hIconLandscape = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_LANDSCAPE));

        //
        //  Load the duplex icons.
        //
        hIconPDuplexNone = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_P_NONE));
        hIconLDuplexNone = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_L_NONE));
        hIconPDuplexTumble = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_P_HORIZ));
        hIconLDuplexTumble = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_L_VERT));
        hIconPDuplexNoTumble = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_P_VERT));
        hIconLDuplexNoTumble = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_L_HORIZ));

        //
        //  Load the page setup icons.
        //
        hIconPSStampP = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_P_PSSTAMP));
        hIconPSStampL = LoadIcon(g_hinst, MAKEINTRESOURCE(ICO_L_PSSTAMP));

        //
        //  Load the collation images.
        //
        hIconCollate = LoadImage( g_hinst,
                                  MAKEINTRESOURCE(ICO_COLLATE),
                                  IMAGE_ICON,
                                  0,
                                  0,
                                  LR_SHARED );
        hIconNoCollate = LoadImage( g_hinst,
                                    MAKEINTRESOURCE(ICO_NO_COLLATE),
                                    IMAGE_ICON,
                                    0,
                                    0,
                                    LR_SHARED );

        bAllIconsLoaded = ( hIconPortrait &&
                            hIconLandscape &&
                            hIconPDuplexNone &&
                            hIconLDuplexNone &&
                            hIconPDuplexTumble &&
                            hIconLDuplexTumble &&
                            hIconPDuplexNoTumble &&
                            hIconLDuplexNoTumble &&
                            hIconPSStampP &&
                            hIconPSStampL &&
                            hIconCollate &&
                            hIconNoCollate );
    }

    //
    //  Return TRUE only if all icons/images were loaded properly.
    //
    return (bAllIconsLoaded);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintDisplayPrintDlg
//
////////////////////////////////////////////////////////////////////////////

int PrintDisplayPrintDlg(
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    int fGotInput = -1;
    HANDLE hDlgTemplate = NULL;
    HANDLE hInstance;
#ifdef UNICODE
    UINT uiWOWFlag = 0;
#endif


    //
    //  NOTE:  The print hook check must be done here rather than in
    //         PrintDlgX.  Old apps that set this flag without the
    //         PrintHook when calling Print Setup will fail - they
    //         used to succeed.
    //
    if (pPD->Flags & PD_ENABLEPRINTHOOK)
    {
        if (!pPD->lpfnPrintHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pPD->lpfnPrintHook = NULL;
    }

    if (pPD->Flags & PD_ENABLEPRINTTEMPLATEHANDLE)
    {
        if (pPD->hPrintTemplate)
        {
            hDlgTemplate = pPD->hPrintTemplate;
            hInstance = g_hinst;
        }
        else
        {
            StoreExtendedError(CDERR_NOTEMPLATE);
        }
    }
    else
    {
        LPTSTR pTemplateName = NULL;

        if (pPD->Flags & PD_ENABLEPRINTTEMPLATE)
        {
            if (pPD->lpPrintTemplateName)
            {
                if (pPD->hInstance)
                {
                    pTemplateName = (LPTSTR)pPD->lpPrintTemplateName;
                    hInstance = pPD->hInstance;
                }
                else
                {
                    StoreExtendedError(CDERR_NOHINSTANCE);
                }
            }
            else
            {
                StoreExtendedError(CDERR_NOTEMPLATE);
            }
        }
        else
        {
            hInstance = g_hinst;
            pTemplateName = (LPTSTR)(DWORD)PRINTDLGORD;
        }

        if (pTemplateName)
        {
            hDlgTemplate = PrintLoadResource( hInstance,
                                              pTemplateName,
                                              RT_DIALOG );
        }
    }

    if (!hDlgTemplate)
    {
        return (FALSE);
    }

    if (LockResource(hDlgTemplate))
    {
        glpfnPrintHook = GETPRINTHOOKFN(pPD);

#ifdef UNICODE
        if (IS16BITWOWAPP(pPD))
        {
            uiWOWFlag = SCDLG_16BIT;
        }

        fGotInput = (BOOL)DialogBoxIndirectParamAorW( hInstance,
                                                (LPDLGTEMPLATE)hDlgTemplate,
                                                pPD->hwndOwner,
                                                PrintDlgProc,
                                                (LPARAM)pPI,
                                                uiWOWFlag );
#else
        fGotInput = (BOOL)DialogBoxIndirectParam( hInstance,
                                            (LPDLGTEMPLATE)hDlgTemplate,
                                            pPD->hwndOwner,
                                            PrintDlgProc,
                                            (LPARAM)pPI );
#endif

        glpfnPrintHook = NULL;
        if (fGotInput == -1)
        {
            StoreExtendedError(CDERR_DIALOGFAILURE);
        }
    }
    else
    {
        StoreExtendedError(CDERR_LOCKRESFAILURE);
    }

    return (fGotInput);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintDisplaySetupDlg
//
////////////////////////////////////////////////////////////////////////////

int PrintDisplaySetupDlg(
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    int fGotInput = -1;
    HANDLE hDlgTemplate = NULL;
    HANDLE hInstance;
#ifdef UNICODE
    UINT uiWOWFlag = 0;
#endif


    //
    //  NOTE:  The setup hook check must be done here rather than in
    //         PrintDlgX.  Old apps that set this flag without the
    //         SetupHook when calling Print will fail - they
    //         used to succeed.
    //
    if (pPD->Flags & PD_ENABLESETUPHOOK)
    {
        if (!pPD->lpfnSetupHook)
        {
            StoreExtendedError(CDERR_NOHOOK);
            return (FALSE);
        }
    }
    else
    {
        pPD->lpfnSetupHook = NULL;
    }

    if (pPD->Flags & PD_ENABLESETUPTEMPLATEHANDLE)
    {
        if (pPD->hSetupTemplate)
        {
            hDlgTemplate = pPD->hSetupTemplate;
            hInstance = g_hinst;
        }
        else
        {
            StoreExtendedError(CDERR_NOTEMPLATE);
        }
    }
    else
    {
        LPTSTR pTemplateName = NULL;

        if (pPD->Flags & PD_ENABLESETUPTEMPLATE)
        {
            if (pPD->lpSetupTemplateName)
            {
                if (pPD->hInstance)
                {
                    pTemplateName = (LPTSTR)pPD->lpSetupTemplateName;
                    hInstance = pPD->hInstance;
                }
                else
                {
                    StoreExtendedError(CDERR_NOHINSTANCE);
                }
            }
            else
            {
                StoreExtendedError(CDERR_NOTEMPLATE);
            }
        }
        else
        {
            hInstance = g_hinst;
            pTemplateName = (LPTSTR)(DWORD)( (pPD->Flags & PD_PRINTSETUP)
                                                 ? PRNSETUPDLGORD
                                                 : PAGESETUPDLGORD );
        }

        if (pTemplateName)
        {
            hDlgTemplate = PrintLoadResource( hInstance,
                                              pTemplateName,
                                              RT_DIALOG );
        }
    }

    if (!hDlgTemplate)
    {
        return (FALSE);
    }

    if (LockResource(hDlgTemplate))
    {
        glpfnSetupHook = GETSETUPHOOKFN(pPD);

#ifdef UNICODE
        if (IS16BITWOWAPP(pPD))
        {
            uiWOWFlag = SCDLG_16BIT;
        }

        fGotInput = (BOOL)DialogBoxIndirectParamAorW( hInstance,
                                                (LPDLGTEMPLATE)hDlgTemplate,
                                                pPD->hwndOwner,
                                                PrintSetupDlgProc,
                                                (LPARAM)pPI,
                                                uiWOWFlag );
#else
        fGotInput = (BOOL)DialogBoxIndirectParam( hInstance,
                                            (LPDLGTEMPLATE)hDlgTemplate,
                                            pPD->hwndOwner,
                                            PrintSetupDlgProc,
                                            (LPARAM)pPI );
#endif

        glpfnSetupHook = NULL;
        if (fGotInput == -1)
        {
            StoreExtendedError(CDERR_DIALOGFAILURE);
        }
    }
    else
    {
        StoreExtendedError(CDERR_LOCKRESFAILURE);
    }

    return (fGotInput);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintDlgProc
//
//  Print Dialog procedure.
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK PrintDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PPRINTINFO pPI;
    LPPRINTDLG pPD;
    HWND hCtl;
    BOOL bTest;
    BOOL bResult;
    LPDEVMODE pDM;
    LPDEVNAMES pDN;


    if (pPI = (PPRINTINFO)GetProp(hDlg, PRNPROP))
    {
        if ((pPD = pPI->pPD) && (pPD->lpfnPrintHook))
        {
            LPPRINTHOOKPROC lpfnPrintHook = GETPRINTHOOKFN(pPD);

#ifdef UNICODE
            if (pPI->ApiType == COMDLG_ANSI)
            {
                ThunkPrintDlgW2A(pPI);
            }
#endif
            if ((bResult = (*lpfnPrintHook)(hDlg, wMsg, wParam, lParam)))
            {
#ifdef UNICODE
                if (pPI->ApiType == COMDLG_ANSI)
                {
                    ThunkPrintDlgA2W(pPI);
                }
#endif
                return (bResult);
            }
        }
    }
    else if (glpfnPrintHook &&
             (wMsg != WM_INITDIALOG) &&
             (bResult = (*glpfnPrintHook)(hDlg, wMsg, wParam, lParam)))
    {

        return (bResult);
    }

    switch (wMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            DWORD dwResult = 0;

            HourGlass(TRUE);
#ifndef WINNT
            msgHELPA = RegisterWindowMessage(szCommdlgHelp);
#endif
            SetProp(hDlg, PRNPROP, (HANDLE)lParam);
            glpfnPrintHook = NULL;

            pPI = (PPRINTINFO)lParam;
            pPD = pPI->pPD;
            if (pPI->pPSD)
            {
                TCHAR szTitle[32];
                RECT aRtDlg;
                RECT aRtGrp;
                RECT aRtYep;
                RECT aRtCan;
                HWND hBtnYep = GetDlgItem(hDlg, IDOK);
                HWND hBtnCan = GetDlgItem(hDlg, IDCANCEL);
                RECT aRtWhere;
                RECT aRtCmmnt;
                LONG GapHeight, DlgTop;

                //
                //  Save the client coordinate for the top of the dialog.
                //  Also, save the height of the gap between the bottom of
                //  the original OK button and the bottom of the original
                //  dialog.
                //
                GetWindowRect(hDlg, &aRtDlg);
                GetWindowRect(hBtnYep, &aRtYep);
                ScreenToClient(hDlg, (LPPOINT)&aRtDlg.left);
                ScreenToClient(hDlg, (LPPOINT)&aRtDlg.right);
                ScreenToClient(hDlg, (LPPOINT)&aRtYep.right);
                DlgTop = aRtDlg.top;
                GapHeight = (aRtDlg.bottom - aRtYep.bottom > 0)
                               ? aRtDlg.bottom - aRtYep.bottom
                               : 15;

                //
                //  Display the title of the dialog box.
                //
                GetWindowText(GetParent(hDlg), szTitle, 32);
                SetWindowText(hDlg, szTitle);

                //
                //  Get the screen and client coordinates for the dialog,
                //  the Printer group box, the OK button, and the Cancel
                //  button.  These will be used to reposition the OK,
                //  Cancel, and Help buttons.
                //
                GetWindowRect(hDlg, &aRtDlg);
                GetWindowRect(GetDlgItem(hDlg, ID_PRINT_G_PRINTER), &aRtGrp);
                GetWindowRect(hBtnYep, &aRtYep);
                GetWindowRect(hBtnCan, &aRtCan);

                ScreenToClient(hDlg   , (LPPOINT)&aRtYep.left );
                ScreenToClient(hDlg   , (LPPOINT)&aRtCan.left );
                ScreenToClient(hDlg   , (LPPOINT)&aRtDlg.right);
                ScreenToClient(hDlg   , (LPPOINT)&aRtGrp.right);
                ScreenToClient(hBtnYep, (LPPOINT)&aRtYep.right);
                ScreenToClient(hBtnCan, (LPPOINT)&aRtCan.right);
#ifdef WINNT
                if (pPD->Flags & PD_SHOWHELP)
                {
                    HWND hBtnHlp = GetDlgItem(hDlg, ID_BOTH_P_HELP);
                    RECT aRtHlp;

                    //
                    //  Move the Help button up underneath the
                    //  Printer group box.
                    //
                    if (hBtnHlp)
                    {
                        GetWindowRect(hBtnHlp, &aRtHlp);
                        ScreenToClient(hDlg, (LPPOINT)&aRtHlp.left);
                        ScreenToClient(hBtnHlp, (LPPOINT)&aRtHlp.right);

                        MoveWindow( hBtnHlp,
                                    aRtHlp.left,
                                    aRtGrp.bottom + 2 * aRtHlp.bottom / 3,
                                    aRtHlp.right,
                                    aRtHlp.bottom,
                                    FALSE );
                    }
                }
#endif
                //
                //  Move the OK and Cancel buttons up underneath the
                //  Printer group box.
                //
                MoveWindow( hBtnYep,
                            aRtYep.left,
                            aRtGrp.bottom + 2 * aRtYep.bottom / 3,
                            aRtYep.right,
                            aRtYep.bottom,
                            FALSE );
                MoveWindow( hBtnCan,
                            aRtCan.left,
                            aRtGrp.bottom + 2 * aRtCan.bottom / 3,
                            aRtCan.right,
                            aRtCan.bottom,
                            FALSE );

                //
                //  Resize the dialog.
                //
                GetWindowRect(hBtnYep, &aRtYep);
                ScreenToClient(hDlg, (LPPOINT)&aRtYep.right);
                MoveWindow( hDlg,
                            aRtDlg.left,
                            aRtDlg.top,
                            aRtDlg.right,
                            (aRtYep.bottom - DlgTop) + GapHeight,
                            FALSE );

                //
                //  Hide all other print dlg items.
                //
                //  NOTE: Need to do a SetWindowPos to actually remove
                //        the window so that the AddNetButton call does
                //        not think it's there.
                //
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_X_TOFILE),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_X_COLLATE),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_E_FROM),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_E_TO),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_E_COPIES),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_G_RANGE),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_G_COPIES),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_I_COLLATE),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_R_ALL),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_R_SELECTION),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_R_PAGES),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_S_FROM),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_S_TO),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );
                SetWindowPos( GetDlgItem(hDlg, ID_PRINT_S_COPIES),
                              NULL,
                              0, 0, 0, 0,
                              SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER );

                //
                //  Enlarge the comment edit control, since the
                //  "print to file" check box is hidden.
                //
                GetWindowRect(GetDlgItem(hDlg, ID_BOTH_S_WHERE), &aRtWhere);
                GetWindowRect( hCtl = GetDlgItem(hDlg, ID_BOTH_S_COMMENT),
                               &aRtCmmnt );
                ScreenToClient(hDlg, (LPPOINT)&aRtCmmnt.left);
                MoveWindow( hCtl,
                            aRtCmmnt.left,
                            aRtCmmnt.top,
                            aRtWhere.right  - aRtWhere.left,
                            aRtWhere.bottom - aRtWhere.top,
                            FALSE );
#ifdef WINNT
                //
                //  Add or hide net button, if necessary.
                //
                if ((pPD->Flags & PD_NONETWORKBUTTON))
                {
                    if (hCtl = GetDlgItem(hDlg, ID_BOTH_P_NETWORK))
                    {
                        EnableWindow(hCtl, FALSE);
                        ShowWindow(hCtl, SW_HIDE);
                    }
                }
                else
                {
                    AddNetButton( hDlg,
                                  g_hinst,
                                  FILE_BOTTOM_MARGIN,
                                  TRUE,
                                  FALSE,
                                  TRUE );

                    //
                    //  The button can be added in two ways -
                    //      statically (they have it predefined in their template) and
                    //      dynamically (successful call to AddNetButton).
                    //
                    if (!IsNetworkInstalled())
                    {
                        hCtl = GetDlgItem(hDlg, ID_BOTH_P_NETWORK);

                        EnableWindow(hCtl, FALSE);
                        ShowWindow(hCtl, SW_HIDE);
                    }
                }
#endif
            }
            else
            {
                if (pPD->Flags & PD_COLLATE)
                {
                    pPI->Status |= PI_COLLATE_REQUESTED;
                }
            }

            if (!PrintInitGeneral(hDlg, ID_PRINT_C_NAME, pPI) ||
                ((dwResult = PrintInitPrintDlg( hDlg,
                                                wParam,
                                                pPI )) == 0xFFFFFFFF))
            {
                RemoveProp(hDlg, PRNPROP);
                EndDialog(hDlg, -2);
            }

            HourGlass(FALSE);
            bResult = (dwResult == 1);
            return (bResult);
        }
        case ( WM_COMMAND ) :
        {
            if (!pPI)
            {
                return (FALSE);
            }

            bResult = FALSE;

            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case ( ID_PRINT_C_NAME ) :       // Printer Name combobox
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE)
                    {
                        PrintPrinterChanged(hDlg, ID_PRINT_C_NAME, pPI);
                    }
                    else if ( (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_DROPDOWN) &&
                              !(pPI->Status & PI_PRINTERS_ENUMERATED) )
                    {
                        //
                        //  Enumerate printers if this hasn't been done yet.
                        //
                        PrintEnumAndSelect( hDlg,
                                            ID_PRINT_C_NAME,
                                            pPI,
                                            (pPI->pCurPrinter)
                                              ? pPI->pCurPrinter->pPrinterName
                                              : NULL,
                                            TRUE );
                    }

                    break;
                }
                case ( ID_BOTH_P_PROPERTIES ) :  // Properties... button
                {
                    PrintChangeProperties(hDlg, ID_PRINT_C_NAME, pPI);

                    break;
                }
                case ( ID_PRINT_P_SETUP ) :      // Setup... button
                {
                    DWORD dwFlags = pPD->Flags;
                    HWND hwndOwner = pPD->hwndOwner;

                    pPD->Flags |= PD_PRINTSETUP;
                    pPD->Flags &= ~(PD_RETURNDC | PD_RETURNIC);
                    pPI->Status |= PI_PRINTDLGX_RECURSE;
                    pPD->hwndOwner = hDlg;

                    if (PrintDlgX(pPI))
                    {
                        if (!PrintInitBannerAndQuality(hDlg, pPI, pPD))
                        {
                            StoreExtendedError(CDERR_GENERALCODES);
                        }
                    }

                    pPI->Status &= ~PI_PRINTDLGX_RECURSE;
                    pPD->Flags = dwFlags;
                    pPD->hwndOwner = hwndOwner;

                    break;
                }
                case ( ID_PRINT_R_ALL ) :        // Print Range - All
                case ( ID_PRINT_R_SELECTION ) :  // Print Range - Selection
                case ( ID_PRINT_R_PAGES ) :      // Print Range - Pages (From, To)
                {
                    CheckRadioButton( hDlg,
                                      ID_PRINT_R_ALL,
                                      ID_PRINT_R_PAGES,
                                      GET_WM_COMMAND_ID(wParam, lParam) );

                    //
                    //  Only move the the focus to the "From" control when
                    //  the up/down arrow is NOT used.
                    //
                    if ( !IS_KEY_PRESSED(VK_UP) &&
                         !IS_KEY_PRESSED(VK_DOWN) &&
                         ((BOOL)(GET_WM_COMMAND_ID(wParam, lParam) == ID_PRINT_R_PAGES)) )
                    {
                        SendMessage( hDlg,
                                     WM_NEXTDLGCTL,
                                     (WPARAM)GetDlgItem(hDlg, ID_PRINT_E_FROM),
                                     1L );
                    }

                    break;
                }
                case ( ID_PRINT_E_FROM ) :       // From  (Print Range - Pages)
                {
                    //
                    //  Only enable the "To" control if the "From" control
                    //  contains a value.
                    //
                    GetDlgItemInt(hDlg, ID_PRINT_E_FROM, &bTest, FALSE);
                    EnableWindow(GetDlgItem(hDlg, ID_PRINT_S_TO), bTest);
                    EnableWindow(GetDlgItem(hDlg, ID_PRINT_E_TO), bTest);

                    //  FALL THRU...
                }
                case ( ID_PRINT_E_TO ) :         // To  (Print Range - Pages)
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
                    {
                        CheckRadioButton( hDlg,
                                          ID_PRINT_R_ALL,
                                          ID_PRINT_R_PAGES,
                                          ID_PRINT_R_PAGES );
                    }

                    break;
                }
                case ( ID_PRINT_X_COLLATE ) :    // Collate check box
                {
                    if (hCtl = GetDlgItem(hDlg, ID_PRINT_I_COLLATE))
                    {
                        ShowWindow(hCtl, SW_HIDE);
                        SendMessage( hCtl,
                                     STM_SETICON,
                                     IsDlgButtonChecked(hDlg, ID_PRINT_X_COLLATE)
                                         ? (LONG_PTR)hIconCollate
                                         : (LONG_PTR)hIconNoCollate,
                                     0L );
                        ShowWindow(hCtl, SW_SHOW);

                        if (IsDlgButtonChecked(hDlg, ID_PRINT_X_COLLATE))
                        {
                            pPI->Status |= PI_COLLATE_REQUESTED;
                        }
                        else
                        {
                            pPI->Status &= ~PI_COLLATE_REQUESTED;
                        }
                    }

                    break;
                }
                case ( ID_BOTH_P_NETWORK ) :     // Network... button
                {
#ifdef WINNT
                    HANDLE hPrinter;
                    DWORD cbPrinter = 0;
                    PPRINTER_INFO_2 pPrinter = NULL;

                    hPrinter = (HANDLE)ConnectToPrinterDlg(hDlg, 0);
                    if (hPrinter)
                    {
                        if (!GetPrinter( hPrinter,
                                         2,
                                         (LPBYTE)pPrinter,
                                         cbPrinter,
                                         &cbPrinter ))
                        {
                            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                            {
                                if (pPrinter = LocalAlloc(LPTR, cbPrinter))
                                {
                                    if (!GetPrinter( hPrinter,
                                                     2,
                                                     (LPBYTE)pPrinter,
                                                     cbPrinter,
                                                     &cbPrinter ))
                                    {
                                        StoreExtendedError(PDERR_PRINTERNOTFOUND);
                                    }
                                    else
                                    {
                                        SendDlgItemMessage( hDlg,
                                                            ID_PRINT_C_NAME,
                                                            CB_RESETCONTENT,
                                                            0,
                                                            0 );
                                        PrintEnumAndSelect( hDlg,
                                                            ID_PRINT_C_NAME,
                                                            pPI,
                                                            pPrinter->pPrinterName,
                                                            TRUE );
                                    }
                                }
                                else
                                {
                                    StoreExtendedError(CDERR_MEMALLOCFAILURE);
                                }
                            }
                            else
                            {
                                StoreExtendedError(PDERR_SETUPFAILURE);
                            }
                        }

                        if (!GetStoredExtendedError())
                        {
                            SendDlgItemMessage( hDlg,
                                                ID_PRINT_C_NAME,
                                                CB_SETCURSEL,
                                                (WPARAM)SendDlgItemMessage(
                                                      hDlg,
                                                      ID_PRINT_C_NAME,
                                                      CB_FINDSTRING,
                                                      0,
                                                      (LPARAM)pPrinter->pPrinterName ),
                                                (LPARAM)0 );

                            PrintPrinterChanged(hDlg, ID_PRINT_C_NAME, pPI);
                        }

                        LocalFree(pPrinter);
                        ClosePrinter(hPrinter);
                    }
#else
                    WNetConnectionDialog(hDlg, RESOURCETYPE_PRINT);
#endif
                    break;
                }
                case ( ID_BOTH_P_HELP ) :        // Help button
                {
#ifdef UNICODE
                    if (pPI->ApiType == COMDLG_ANSI)
                    {
                        if (msgHELPA && pPD->hwndOwner)
                        {
                            SendMessage( pPD->hwndOwner,
                                         msgHELPA,
                                         (WPARAM)hDlg,
                                         (DWORD_PTR)pPI->pPDA );
                        }
                    }
                    else
#endif
                    {
                        if (msgHELPW && pPD->hwndOwner)
                        {
                            SendMessage( pPD->hwndOwner,
                                         msgHELPW,
                                         (WPARAM)hDlg,
                                         (DWORD_PTR)pPD );
                        }
                    }

                    break;
                }
                case ( IDOK ) :                  // OK button
                {
                    bResult = TRUE;
                    if (!(pPI->pPSD))
                    {
                        pPD->Flags &= ~((DWORD)( PD_PRINTTOFILE |
                                                 PD_PAGENUMS    |
                                                 PD_SELECTION   |
                                                 PD_COLLATE ));

                        pPD->nCopies = (WORD)GetDlgItemInt( hDlg,
                                                            ID_PRINT_E_COPIES,
                                                            &bTest,
                                                            FALSE );
                        if ((!bTest) || (!pPD->nCopies))
                        {
                            PrintEditError( hDlg,
                                            ID_PRINT_E_COPIES,
                                            iszCopiesZero );
                            return (TRUE);
                        }

                        if (IsDlgButtonChecked(hDlg, ID_PRINT_R_SELECTION))
                        {
                            pPD->Flags |= PD_SELECTION;
                        }
                        else if (IsDlgButtonChecked(hDlg, ID_PRINT_R_PAGES))
                        {
                            //
                            //  Check the "From" and "To" values.
                            //
                            pPD->Flags |= PD_PAGENUMS;
                            pPD->nFromPage = (WORD)GetDlgItemInt( hDlg,
                                                                  ID_PRINT_E_FROM,
                                                                  &bTest,
                                                                  FALSE );
                            if (!bTest)
                            {
                                PrintEditError( hDlg,
                                                ID_PRINT_E_FROM,
                                                iszPageFromError );
                                return (TRUE);
                            }

                            pPD->nToPage = (WORD)GetDlgItemInt( hDlg,
                                                                ID_PRINT_E_TO,
                                                                &bTest,
                                                                FALSE );
                            if (!bTest)
                            {
                                TCHAR szBuf[PAGE_EDIT_SIZE + 1];

                                if (GetDlgItemText( hDlg,
                                                    ID_PRINT_E_TO,
                                                    szBuf,
                                                    PAGE_EDIT_SIZE + 1 ))
                                {
                                    PrintEditError( hDlg,
                                                    ID_PRINT_E_TO,
                                                    iszPageToError );
                                    return (TRUE);
                                }
                                else
                                {
                                    pPD->nToPage = pPD->nFromPage;
                                }
                            }

                            if ( (pPD->nFromPage < pPD->nMinPage) ||
                                 (pPD->nFromPage > pPD->nMaxPage) )
                            {
                                PrintEditError( hDlg,
                                                ID_PRINT_E_FROM,
                                                iszPageRangeError,
                                                pPD->nMinPage,
                                                pPD->nMaxPage );
                                return (TRUE);
                            }
                            if ( (pPD->nToPage < pPD->nMinPage) ||
                                 (pPD->nToPage > pPD->nMaxPage) )
                            {
                                PrintEditError( hDlg,
                                                ID_PRINT_E_TO,
                                                iszPageRangeError,
                                                pPD->nMinPage,
                                                pPD->nMaxPage );
                                return (TRUE);
                            }
                            if (pPD->nFromPage > pPD->nToPage)
                            {
                                PrintEditError( hDlg,
                                                ID_PRINT_E_FROM,
                                                iszFromToError );
                                return (TRUE);
                            }
                        }
                    }

                    HourGlass(TRUE);

                    if (IsDlgButtonChecked(hDlg, ID_PRINT_X_TOFILE))
                    {
                        pPD->Flags |= PD_PRINTTOFILE;
                    }

                    if ( (hCtl = GetDlgItem(hDlg, ID_PRINT_X_COLLATE)) &&
                         IsWindowEnabled(hCtl) &&
                         IsDlgButtonChecked(hDlg, ID_PRINT_X_COLLATE) )
                    {
                        pPD->Flags |= PD_COLLATE;
                    }

                    if (!PrintSetCopies(hDlg, pPI, ID_PRINT_C_NAME))
                    {
                        HourGlass(FALSE);
                        return (TRUE);
                    }

                    pDM = NULL;
                    pDN = NULL;
                    if (pPD->hDevMode)
                    {
                        pDM = GlobalLock(pPD->hDevMode);
                    }
                    if (pPD->hDevNames)
                    {
                        pDN = GlobalLock(pPD->hDevNames);
                    }
                    if (pDM && pDN)
                    {
                        DWORD nNum;

                        if ( GetDlgItem(hDlg, ID_PRINT_C_QUALITY) &&
                             (nNum = (DWORD) SendDlgItemMessage( hDlg,
                                                         ID_PRINT_C_QUALITY,
                                                         CB_GETCURSEL,
                                                         0,
                                                         0L )) != CB_ERR )
                        {
                            pDM->dmPrintQuality =
                                (WORD)SendDlgItemMessage( hDlg,
                                                          ID_PRINT_C_QUALITY,
                                                          CB_GETITEMDATA,
                                                          (WPARAM)nNum,
                                                          0L );
                        }

                        PrintReturnICDC(pPD, pDN, pDM);
                    }
                    if (pDM)
                    {
                        GlobalUnlock(pPD->hDevMode);
                    }
                    if (pDN)
                    {
                        GlobalUnlock(pPD->hDevNames);
                    }

#ifdef UNICODE
                    if (pPD->Flags & CD_WOWAPP)
                    {
                        UpdateSpoolerInfo(pPI);
                    }
#endif

                    //  FALL THRU...
                }
                case ( IDCANCEL ) :              // Cancel button
                case ( IDABORT ) :
                {
                    HourGlass(TRUE);

                    glpfnPrintHook = GETPRINTHOOKFN(pPD);

                    RemoveProp(hDlg, PRNPROP);
                    EndDialog(hDlg, bResult);

                    HourGlass(FALSE);

                    break;
                }
                default :
                {
                    return (FALSE);
                    break;
                }
            }

            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            PrintMeasureItem(hDlg, (LPMEASUREITEMSTRUCT)lParam);
            break;
        }
        case ( WM_HELP ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPTSTR)aPrintHelpIDs );
            }
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)wParam,
                         NULL,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)aPrintHelpIDs );
            }
            break;
        }
        case ( WM_CTLCOLOREDIT ) :
        {
            if (GetWindowLong((HWND)lParam, GWL_STYLE) & ES_READONLY)
            {
                return ( (BOOL) SendMessage(hDlg, WM_CTLCOLORDLG, wParam, lParam) );
            }

            //  FALL THRU...
        }
        default :
        {
            return (FALSE);
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetupDlgProc
//
//  Print Setup Dialog proc.
//
////////////////////////////////////////////////////////////////////////////

BOOL_PTR CALLBACK PrintSetupDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PPRINTINFO pPI;
    LPPRINTDLG pPD;
    BOOL bResult;
    UINT uCmdId;
    LPDEVMODE pDM;


    if (pPI = (PPRINTINFO)GetProp(hDlg, PRNPROP))
    {
        if ((pPD = pPI->pPD) && (pPD->lpfnSetupHook))
        {
            LPSETUPHOOKPROC lpfnSetupHook = GETSETUPHOOKFN(pPD);

#ifdef UNICODE
            if (pPI->ApiType == COMDLG_ANSI)
            {
                ThunkPrintDlgW2A(pPI);
                TransferPDA2PSD(pPI);

                pPI->NestCtr++;
                bResult = (*lpfnSetupHook)(hDlg, wMsg, wParam, lParam);
                pPI->NestCtr--;

                if (bResult)
                {
                    TransferPSD2PDA(pPI);
                    ThunkPrintDlgA2W(pPI);
                    if (pPI->NestCtr == 0)
                    {
                        TransferPD2PSD(pPI);
                    }
                    return (bResult);
                }
            }
            else
#endif
            {
                TransferPD2PSD(pPI);

                bResult = (*lpfnSetupHook)(hDlg, wMsg, wParam, lParam);

                if (bResult)
                {
                    TransferPSD2PD(pPI);
                    return (bResult);
                }
            }
        }
    }
    else if (glpfnSetupHook &&
             (wMsg != WM_INITDIALOG) &&
             (bResult = (*glpfnSetupHook)(hDlg, wMsg, wParam, lParam)))
    {
        return (bResult);
    }

    switch (wMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            DWORD dwResult = 0;

            HourGlass(TRUE);
#ifndef WINNT
            msgHELPA = RegisterWindowMessage(szCommdlgHelp);
#endif
            SetProp(hDlg, PRNPROP, (HANDLE)lParam);
            pPI = (PPRINTINFO)lParam;
            pPI->bKillFocus = FALSE;
            glpfnSetupHook = NULL;

            if (!PrintInitGeneral(hDlg, ID_SETUP_C_NAME, pPI) ||
                ((dwResult = PrintInitSetupDlg( hDlg,
                                                wParam,
                                                pPI )) == 0xFFFFFFFF))
            {
                RemoveProp(hDlg, PRNPROP);
                EndDialog(hDlg, FALSE);
            }
            else if (pPI->pPSD && (pPI->pPSD->Flags & PSD_RETURNDEFAULT))
            {
                //
                //  PSD_RETURNDEFAULT goes through the entire initialization
                //  in order to set rtMinMargin, rtMargin, and ptPaperSize.
                //  Win95 Notepad relies on this behavior.
                //
                SendMessage(hDlg, WM_COMMAND, IDOK, 0);
            }

            HourGlass(FALSE);
            bResult = (dwResult == 1);
            return (bResult);
        }
        case ( WM_COMMAND ) :
        {
            if (!pPI)
            {
                return (FALSE);
            }

            bResult = FALSE;

            switch (uCmdId = GET_WM_COMMAND_ID(wParam, lParam))
            {
                case ( ID_SETUP_C_NAME ) :       // Printer Name combobox
                {
                    if ( (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_DROPDOWN) &&
                         !(pPI->Status & PI_PRINTERS_ENUMERATED) )
                    {
                        //
                        //  Enumerate printers if this hasn't been done yet.
                        //
                        PrintEnumAndSelect( hDlg,
                                            ID_SETUP_C_NAME,
                                            pPI,
                                            (pPI->pCurPrinter)
                                              ? pPI->pCurPrinter->pPrinterName
                                              : NULL,
                                            TRUE );
                    }
                    if (GET_WM_COMMAND_CMD(wParam, lParam) != CBN_SELCHANGE)
                    {
                        break;
                    }
                    if ( !GetDlgItem(hDlg, ID_SETUP_R_SPECIFIC) ||
                         IsDlgButtonChecked(hDlg, ID_SETUP_R_SPECIFIC) )
                    {
                        PrintPrinterChanged(hDlg, ID_SETUP_C_NAME, pPI);
                        break;
                    }

                    uCmdId = ID_SETUP_R_SPECIFIC;

                    // FALL THRU...
                }
                case ( ID_SETUP_R_DEFAULT ) :    // Default printer
                case ( ID_SETUP_R_SPECIFIC ) :   // Specific printer
                {
                    //
                    //  Sanity check for Publisher bug where user tries to
                    //  set focus to ID_SETUP_R_DEFAULT on exit if the
                    //  dialog has no default printer.
                    //
                    if (pPI->hCurPrinter)
                    {
                        HWND hCmb;
                        DWORD dwStyle;

                        hCmb = GetDlgItem(hDlg, ID_SETUP_C_NAME);
                        if (hCmb && (uCmdId == ID_SETUP_R_DEFAULT))
                        {
                            if (!(pPI->Status & PI_PRINTERS_ENUMERATED))
                            {
                                //
                                //  Enumerate printers if this hasn't been
                                //  done yet.  Otherwise, the default printer
                                //  may not be found in the list box when
                                //  switching from Specific to Default.
                                //
                                PrintEnumAndSelect( hDlg,
                                                    ID_SETUP_C_NAME,
                                                    pPI,
                                                    NULL,
                                                    TRUE );
                            }

                            SendMessage( hCmb,
                                         CB_SETCURSEL,
                                         (WPARAM)SendMessage(
                                             hCmb,
                                             CB_FINDSTRINGEXACT,
                                             (WPARAM)-1,
                                             (LPARAM)(pPI->szDefaultPrinter) ),
                                         (LPARAM)0 );
                        }

                        PrintPrinterChanged(hDlg, ID_SETUP_C_NAME, pPI);

                        CheckRadioButton( hDlg,
                                          ID_SETUP_R_DEFAULT,
                                          ID_SETUP_R_SPECIFIC,
                                          uCmdId);

                        dwStyle = GetWindowLong(hCmb, GWL_STYLE);
                        if (uCmdId == ID_SETUP_R_DEFAULT)
                        {
                            dwStyle &= ~WS_TABSTOP;
                        }
                        else
                        {
                            dwStyle |= WS_TABSTOP;
                            SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)hCmb, 1L);
                        }
                        SetWindowLong(hCmb, GWL_STYLE, dwStyle);
                    }

                    break;
                }
                case ( ID_BOTH_P_PROPERTIES ) :  // Properties... button
                {
                    PrintChangeProperties(hDlg, ID_SETUP_C_NAME, pPI);

                    break;
                }
                case ( ID_SETUP_P_MORE ) :      // More... button
                {
                    pDM = GlobalLock(pPD->hDevMode);

                    AdvancedDocumentProperties( hDlg,
                                                pPI->hCurPrinter,
                                                (pPI->pCurPrinter)
                                                  ? pPI->pCurPrinter->pPrinterName
                                                  : NULL,
                                                pDM,
                                                pDM );

                    GlobalUnlock(pPD->hDevMode);
                    SendMessage( hDlg,
                                 WM_NEXTDLGCTL,
                                 (WPARAM)GetDlgItem(hDlg, IDOK),
                                 1L );

                    break;
                }
                case ( ID_SETUP_R_PORTRAIT ) :   // Portrait
                case ( ID_SETUP_R_LANDSCAPE ) :  // Landscape
                {
                    if ((pPD->hDevMode) && (pDM = GlobalLock(pPD->hDevMode)))
                    {
                        PrintSetOrientation( hDlg,
                                             pPI,
                                             pDM,
                                             pPI->uiOrientationID,
                                             uCmdId );
                        GlobalUnlock(pPD->hDevMode);
                    }

                    //  FALL THRU ...
                }
                case ( ID_SETUP_R_NONE ) :       // None       (2-Sided)
                case ( ID_SETUP_R_LONG ) :       // Long Side  (2-Sided)
                case ( ID_SETUP_R_SHORT ) :      // Short Side (2-Sided)
                {
                    if ((pPD->hDevMode) && (pDM = GlobalLock(pPD->hDevMode)))
                    {
                        PrintSetDuplex(hDlg, pDM, uCmdId);
                        GlobalUnlock(pPD->hDevMode);
                    }

                    break;
                }
                case ( ID_SETUP_C_SIZE ) :       // Size combobox
                {
                    UINT Orientation;

                    if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE)
                    {
                        if ((pPD->hDevMode) && (pDM = GlobalLock(pPD->hDevMode)))
                        {
                        //  pDM->dmFields |= DM_PAPERSIZE;
                            pDM->dmPaperSize =
                                (SHORT)SendMessage( (HWND)lParam,
                                                    CB_GETITEMDATA,
                                                    SendMessage( (HWND)lParam,
                                                                 CB_GETCURSEL,
                                                                 0,
                                                                 0L ),
                                                    0L );

                            Orientation =
                                IsDlgButtonChecked(hDlg, ID_SETUP_R_PORTRAIT)
                                              ? ID_SETUP_R_PORTRAIT
                                              : ID_SETUP_R_LANDSCAPE;
                            PrintSetOrientation( hDlg,
                                                 pPI,
                                                 pDM,
                                                 Orientation,
                                                 Orientation );
                            GlobalUnlock(pPD->hDevMode);
                        }
                    }

                    break;
                }
                case ( ID_SETUP_C_SOURCE ) :       // Source combobox
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE)
                    {
                        if ((pPD->hDevMode) && (pDM = GlobalLock(pPD->hDevMode)))
                        {
                        //  pDM->dmFields |= DM_DEFAULTSOURCE;
                            pDM->dmDefaultSource =
                                (SHORT)SendMessage( (HWND)lParam,
                                                    CB_GETITEMDATA,
                                                    SendMessage( (HWND)lParam,
                                                                 CB_GETCURSEL,
                                                                 0,
                                                                 0L ),
                                                    0L );

                            GlobalUnlock(pPD->hDevMode);
                        }
                    }

                    break;
                }
                case ( ID_SETUP_E_LEFT ) :       // Left    (Margins)
                case ( ID_SETUP_E_TOP ) :        // Top     (Margins)
                case ( ID_SETUP_E_RIGHT ) :      // Right   (Margins)
                case ( ID_SETUP_E_BOTTOM ) :     // Bottom  (Margins)
                {
                    if (pPI->bKillFocus)
                    {
                        break;
                    }

                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case ( EN_KILLFOCUS ) :
                        {
                            pPI->bKillFocus = TRUE;
                            PrintSetMargin( hDlg,
                                            pPI,
                                            uCmdId,
                                            *((LONG*)&pPI->pPSD->rtMargin +
                                              uCmdId - ID_SETUP_E_LEFT) );
                            pPI->bKillFocus = FALSE;

                            break;
                        }
                        case ( EN_CHANGE ) :
                        {
                            HWND hSample;

                            PrintGetMargin( GET_WM_COMMAND_HWND(wParam, lParam),
                                            pPI,
                                            *((LONG*)&pPI->pPSD->rtMinMargin +
                                              uCmdId - ID_SETUP_E_LEFT),
                                            (LONG*)&pPI->pPSD->rtMargin +
                                              uCmdId - ID_SETUP_E_LEFT,
                                            (LONG*)&pPI->RtMarginMMs +
                                              uCmdId - ID_SETUP_E_LEFT );

                            if (hSample = GetDlgItem(hDlg, ID_SETUP_W_SAMPLE))
                            {
                                RECT rect;

                                GetClientRect(hSample, &rect);
                                InflateRect(&rect, -1, -1);
                                InvalidateRect(hSample, &rect, TRUE);
                            }

                            break;
                        }
                    }

                    break;
                }
                case ( ID_SETUP_P_PRINTER ) :    // Printer... button
                {
                    //
                    //  Save a copy of the original values.
                    //
                    HWND hwndOwner = pPD->hwndOwner;
                    DWORD dwFlags = pPD->Flags;
                    HINSTANCE hInstance = pPD->hInstance;
                    LPCTSTR lpPrintTemplateName = pPD->lpPrintTemplateName;

                    //
                    //  Set up pPI so that PrintDlgX can do all the work.
                    //
                    pPD->hwndOwner = hDlg;
                    pPD->Flags &= ~( PD_ENABLEPRINTTEMPLATEHANDLE |
                                     PD_RETURNIC |
                                     PD_RETURNDC |
                                     PD_PAGESETUP );
                    pPD->Flags |= PD_ENABLEPRINTTEMPLATE;
                    pPD->hInstance = g_hinst;
                    pPD->lpPrintTemplateName = MAKEINTRESOURCE(PRINTDLGORD);
                    pPI->Status |= PI_PRINTDLGX_RECURSE;

                    if (PrintDlgX(pPI))
                    {
                        PrintUpdateSetupDlg( hDlg,
                                             pPI,
                                             GlobalLock(pPD->hDevMode),
                                             TRUE );
                        GlobalUnlock(pPD->hDevMode);
                    }

                    //
                    //  Restore the original values.
                    //
                    pPD->hwndOwner = hwndOwner;
                    pPD->Flags = dwFlags;
                    pPD->hInstance = hInstance;
                    pPD->lpPrintTemplateName = lpPrintTemplateName;
                    pPI->Status &= ~PI_PRINTDLGX_RECURSE;

                    //
                    //  Set the keyboard focus to the OK button.
                    //
                    SendMessage( hDlg,
                                 WM_NEXTDLGCTL,
                                 (WPARAM)GetDlgItem(hDlg, IDOK),
                                 1L );

                    HourGlass(FALSE);

                    break;
                }
                case ( ID_BOTH_P_NETWORK ) :     // Network... button
                {
#ifdef WINNT
                    HANDLE hPrinter;
                    DWORD cbPrinter = 0;
                    PPRINTER_INFO_2 pPrinter = NULL;

                    hPrinter = (HANDLE)ConnectToPrinterDlg(hDlg, 0);
                    if (hPrinter)
                    {
                        if (!GetPrinter( hPrinter,
                                         2,
                                         (LPBYTE)pPrinter,
                                         cbPrinter,
                                         &cbPrinter ))
                        {
                            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                            {
                                if (pPrinter = LocalAlloc(LPTR, cbPrinter))
                                {
                                    if (!GetPrinter( hPrinter,
                                                     2,
                                                     (LPBYTE)pPrinter,
                                                     cbPrinter,
                                                     &cbPrinter ))
                                    {
                                        StoreExtendedError(PDERR_PRINTERNOTFOUND);
                                    }
                                    else
                                    {
                                        SendDlgItemMessage( hDlg,
                                                            ID_SETUP_C_NAME,
                                                            CB_RESETCONTENT,
                                                            0,
                                                            0 );
                                        PrintEnumAndSelect( hDlg,
                                                            ID_SETUP_C_NAME,
                                                            pPI,
                                                            pPrinter->pPrinterName,
                                                            TRUE );
                                    }
                                }
                                else
                                {
                                    StoreExtendedError(CDERR_MEMALLOCFAILURE);
                                }
                            }
                            else
                            {
                                StoreExtendedError(PDERR_SETUPFAILURE);
                            }
                        }

                        if (!GetStoredExtendedError())
                        {
                            SendDlgItemMessage( hDlg,
                                                ID_SETUP_C_NAME,
                                                CB_SETCURSEL,
                                                (WPARAM)SendDlgItemMessage(
                                                      hDlg,
                                                      ID_SETUP_C_NAME,
                                                      CB_FINDSTRING,
                                                      0,
                                                      (LPARAM)pPrinter->pPrinterName ),
                                                (LPARAM)0 );

                            PrintPrinterChanged(hDlg, ID_SETUP_C_NAME, pPI);
                        }

                        LocalFree(pPrinter);
                        ClosePrinter(hPrinter);
                    }
#else
                    WNetConnectionDialog(hDlg, RESOURCETYPE_PRINT);
#endif
                    break;
                }
                case ( ID_BOTH_P_HELP ) :        // Help button
                {
#ifdef UNICODE
                    if (pPI->ApiType == COMDLG_ANSI)
                    {
                        if (msgHELPA && pPD->hwndOwner)
                        {
                            SendMessage( pPD->hwndOwner,
                                         msgHELPA,
                                         (WPARAM)hDlg,
                                         (LPARAM)pPI->pPDA );
                        }
                    }
                    else
#endif
                    {
                        if (msgHELPW && pPD->hwndOwner)
                        {
                            SendMessage( pPD->hwndOwner,
                                         msgHELPW,
                                         (WPARAM)hDlg,
                                         (LPARAM)pPD );
                        }
                    }

                    break;
                }
                case ( IDOK ) :                  // OK button
                {
                    LPPAGESETUPDLG pPSD = pPI->pPSD;
                    int i;

                    if (pPSD)
                    {
                        if ((pPSD->rtMinMargin.left + pPSD->rtMinMargin.right >
                                pPSD->ptPaperSize.x) ||
                            (pPSD->rtMinMargin.top + pPSD->rtMinMargin.bottom >
                                pPSD->ptPaperSize.y))
                        {
                            //
                            //  This is an unprintable case that can happen.
                            //  Let's assume that the driver is at fault
                            //  and accept whatever the user entered.
                            //
                        }
                        else if (pPSD->rtMargin.left + pPSD->rtMargin.right >
                                     pPSD->ptPaperSize.x)
                        {
                            i = (pPSD->rtMargin.left >= pPSD->rtMargin.right)
                                    ? ID_SETUP_E_LEFT
                                    : ID_SETUP_E_RIGHT;
                            PrintEditError(hDlg, i, iszBadMarginError);
                            return (TRUE);
                        }
                        else if (pPSD->rtMargin.top + pPSD->rtMargin.bottom >
                                     pPSD->ptPaperSize.y)
                        {
                            i = (pPSD->rtMargin.top >= pPSD->rtMargin.bottom)
                                    ? ID_SETUP_E_TOP
                                    : ID_SETUP_E_BOTTOM;
                            PrintEditError(hDlg, i, iszBadMarginError);
                            return (TRUE);
                        }
                    }
                    else
                    {
                        HourGlass(TRUE);
                        if (!PrintSetCopies(hDlg, pPI, ID_SETUP_C_NAME))
                        {
                            HourGlass(FALSE);
                            return (TRUE);
                        }
                    }

                    bResult = TRUE;
                    SetFocus( GetDlgItem(hDlg, IDOK) );

                    //  FALL THRU...
                }
                case ( IDCANCEL ) :              // Cancel button
                case ( IDABORT ) :
                {
                    HourGlass(TRUE);

                    if (bResult)
                    {
                        PrintGetSetupInfo(hDlg, pPD);
#ifdef UNICODE
                        if (pPD->Flags & CD_WOWAPP)
                        {
                            UpdateSpoolerInfo(pPI);
                        }
#endif
                    }
                    else
                    {
                        SetFocus( GetDlgItem(hDlg, IDCANCEL) );
                    }
                    pPI->bKillFocus = TRUE;

                    glpfnSetupHook = GETSETUPHOOKFN(pPD);

                    RemoveProp(hDlg, PRNPROP);
                    EndDialog(hDlg, bResult);

                    HourGlass(FALSE);

                    break;
                }
                default :
                {
                    return (FALSE);
                    break;
                }
            }

            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            PrintMeasureItem(hDlg, (LPMEASUREITEMSTRUCT)lParam);
            break;
        }
        case ( WM_HELP ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                         NULL,
                         HELP_WM_HELP,
                         (ULONG_PTR)(LPTSTR)((pPD->Flags & PD_PRINTSETUP)
                                            ? aPrintSetupHelpIDs
                                            : aPageSetupHelpIDs) );
            }
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            if (IsWindowEnabled(hDlg))
            {
                WinHelp( (HWND)wParam,
                         NULL,
                         HELP_CONTEXTMENU,
                         (ULONG_PTR)(LPVOID)((pPD->Flags & PD_PRINTSETUP)
                                            ? aPrintSetupHelpIDs
                                            : aPageSetupHelpIDs) );
            }
            break;
        }
        case ( WM_CTLCOLOREDIT ) :
        {
            if (GetWindowLong((HWND)lParam, GWL_STYLE) & ES_READONLY)
            {
                return ( (BOOL) SendMessage(hDlg, WM_CTLCOLORDLG, wParam, lParam) );
            }

            //  FALL THRU...
        }
        default :
        {
            return (FALSE);
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintEditMarginProc
//
////////////////////////////////////////////////////////////////////////////

LRESULT PrintEditMarginProc(
    HWND hWnd,
    UINT msg,
    WPARAM wP,
    LPARAM lP)
{
    if ( (msg == WM_CHAR) &&
         (wP != BACKSPACE) &&
         (wP != CTRL_X_CUT) &&
         (wP != CTRL_C_COPY) &&
         (wP != CTRL_V_PASTE) &&
         (wP != (WPARAM)cIntlDecimal) &&
         (wP != (WPARAM)(cIntlMeasure[0])) &&
         ((wP < TEXT('0')) || (wP > TEXT('9'))) )
    {
        MessageBeep(0);
        return (FALSE);
    }

    return ( CallWindowProc(lpEditMarginProc, hWnd, msg, wP, lP) );
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintPageSetupPaintProc
//
////////////////////////////////////////////////////////////////////////////

LRESULT PrintPageSetupPaintProc(
    HWND hWnd,
    UINT msg,
    WPARAM wP,
    LPARAM lP)
{
    LRESULT lResult;
    PPRINTINFO pPI;
    LPPAGESETUPDLG pPSD;
    HDC hDC;
    RECT aRt, aRtPage, aRtUser;
    PAINTSTRUCT aPs;
    HGDIOBJ hPen, hBr, hFont, hFontGreek;
    HRGN hRgn;
    TCHAR szGreekText[] = TEXT("Dheevaeilnorpoefdi lfaocr, \nMoiccsriocsnoafrtf \tbnya\nSFlr acnn IF iynnnaepgmaonc\n F&i nyneelglaanm 'Ox' Mnaalgleenyn i&f QCnoamgpeannnyi FI nxca.r\nFSoaynb  Ftrfaonscoirscciom,  \rCoafl idfeopronlieav\ne\n");
    LPTSTR psGreekText;
    int i;


    if (msg != WM_PAINT)
    {
        return ( CallWindowProc(lpStaticProc, hWnd, msg, wP, lP) );
    }

    hDC = BeginPaint(hWnd, &aPs);
    GetClientRect(hWnd, &aRt);
    FillRect(hDC, &aRt, (HBRUSH)GetStockObject(WHITE_BRUSH));
    EndPaint(hWnd, &aPs);
    lResult = 0;

    if ( (!(hDC = GetDC(hWnd))) ||
         (!(pPI = (PPRINTINFO)GetProp(GetParent(hWnd), PRNPROP))) )
    {
        return (0);
    }
    pPSD = pPI->pPSD;

    TransferPD2PSD(pPI);
    aRtPage = aRt;
    hPen = (HGDIOBJ)CreatePen(PS_SOLID, 1, RGB(128, 128, 128));
    hPen = SelectObject(hDC, hPen);

    // Rectangle() does not work here
    MoveToEx( hDC, 0            , 0             , NULL );
    LineTo(   hDC, aRt.right - 1, 0              );
    MoveToEx( hDC, 0            , 1             , NULL );
    LineTo(   hDC, 0            , aRt.bottom - 1 );
    DeleteObject(SelectObject(hDC, hPen));

    // Rectangle() does not work here
    MoveToEx( hDC, aRt.right - 1, 0             , NULL );
    LineTo(   hDC, aRt.right - 1, aRt.bottom - 1 );
    MoveToEx( hDC, 0            , aRt.bottom - 1, NULL );
    LineTo(   hDC, aRt.right    , aRt.bottom - 1 );

    SetBkMode(hDC, TRANSPARENT);
    hPen = (HGDIOBJ)CreatePen(PS_DOT, 1, RGB(128, 128, 128));
    hPen = SelectObject(hDC, hPen);
    hBr  = (HGDIOBJ)GetStockObject(NULL_BRUSH);
    hBr  = SelectObject(hDC, hBr);

    hFont = hFontGreek = CreateFont( pPI->PtMargins.y,
                                     pPI->PtMargins.x,
                                     0,
                                     0,
                                     FW_DONTCARE,
                                     0,
                                     0,
                                     0,
                                     ANSI_CHARSET,
                                     OUT_DEFAULT_PRECIS,
                                     CLIP_DEFAULT_PRECIS,
                                     DEFAULT_QUALITY,
                                     VARIABLE_PITCH | FF_SWISS,
                                     NULL );
    hFont = SelectObject(hDC, hFont);

    InflateRect(&aRt, -1, -1);
    aRtUser = aRt;
    hRgn = CreateRectRgnIndirect(&aRtUser);
    SelectClipRgn(hDC, hRgn);
    DeleteObject(hRgn);

    if (pPSD->lpfnPagePaintHook)
    {
        WORD wFlags;
        LPPAGEPAINTHOOK lpfnPagePaintHook = GETPAGEPAINTHOOKFN(pPSD);

        switch (pPI->dwRotation)
        {
            default :
            {
                //
                //  Portrait mode only.
                //
                wFlags = 0x0000;
                break;
            }
            case ( ROTATE_LEFT ) :
            {
                //
                //  Dot-Matrix (270)
                //
                wFlags = 0x0001;
                break;
            }
            case ( ROTATE_RIGHT ) :
            {
                //
                //  HP PCL (90)
                //
                wFlags = 0x0003;
                break;
            }
        }
        if ( !wFlags ||
             IsDlgButtonChecked(GetParent(hWnd), ID_SETUP_R_PORTRAIT) )
        {
            //
            //  Paper in portrait.
            //
            wFlags |= 0x0004;
        }
        if (pPI->pPD->Flags & PI_WPAPER_ENVELOPE)
        {
            wFlags |= 0x0008;
            if (aRt.right < aRt.bottom)
            {
                //
                //  Envelope in portrait.
                //
                wFlags |= 0x0010;
            }
        }
        if ((*lpfnPagePaintHook)( hWnd,
                                  WM_PSD_PAGESETUPDLG,
                                  MAKELONG(pPI->wPaper, wFlags),
                                  (LPARAM)pPSD ) ||
            (*lpfnPagePaintHook)( hWnd,
                                  WM_PSD_FULLPAGERECT,
                                  (WPARAM)hDC,
                                  (LPARAM)(LPRECT)&aRtUser ))
        {
            goto NoMorePainting;
        }

        aRtUser = aRt;
        aRtUser.left   += aRtUser.right  * pPI->RtMinMarginMMs.left   / pPI->PtPaperSizeMMs.x;
        aRtUser.top    += aRtUser.bottom * pPI->RtMinMarginMMs.top    / pPI->PtPaperSizeMMs.y;
        aRtUser.right  -= aRtUser.right  * pPI->RtMinMarginMMs.right  / pPI->PtPaperSizeMMs.x;
        aRtUser.bottom -= aRtUser.bottom * pPI->RtMinMarginMMs.bottom / pPI->PtPaperSizeMMs.y;

        if ((aRtUser.left   < aRtUser.right)  &&
            (aRtUser.top    < aRtUser.bottom) &&
            (aRtUser.left   > aRtPage.left)   &&
            (aRtUser.top    > aRtPage.top)    &&
            (aRtUser.right  < aRtPage.right)  &&
            (aRtUser.bottom < aRtPage.bottom))
        {
            hRgn = CreateRectRgnIndirect(&aRtUser);
            SelectClipRgn(hDC, hRgn);
            DeleteObject(hRgn);
            if ((*lpfnPagePaintHook)( hWnd,
                                      WM_PSD_MINMARGINRECT,
                                      (WPARAM)hDC,
                                      (LPARAM)(LPRECT)&aRtUser ))
            {
                goto NoMorePainting;
            }
        }
    }

    aRt.left   += aRt.right  * pPI->RtMarginMMs.left   / pPI->PtPaperSizeMMs.x;
    aRt.top    += aRt.bottom * pPI->RtMarginMMs.top    / pPI->PtPaperSizeMMs.y;
    aRt.right  -= aRt.right  * pPI->RtMarginMMs.right  / pPI->PtPaperSizeMMs.x;
    aRt.bottom -= aRt.bottom * pPI->RtMarginMMs.bottom / pPI->PtPaperSizeMMs.y;

    if ( (aRt.left > aRtPage.left) && (aRt.left < aRtPage.right) &&
         (aRt.right < aRtPage.right) && (aRt.right > aRtPage.left) &&
         (aRt.top > aRtPage.top) && (aRt.top < aRtPage.bottom) &&
         (aRt.bottom < aRtPage.bottom) && (aRt.bottom > aRtPage.top) &&
         (aRt.left < aRt.right) &&
         (aRt.top < aRt.bottom) )
    {
        if (pPSD->lpfnPagePaintHook)
        {
            LPPAGEPAINTHOOK lpfnPagePaintHook = GETPAGEPAINTHOOKFN(pPSD);

            aRtUser = aRt;
            hRgn = CreateRectRgnIndirect(&aRtUser);
            SelectClipRgn(hDC, hRgn);
            DeleteObject(hRgn);
            if ((*lpfnPagePaintHook)( hWnd,
                                      WM_PSD_MARGINRECT,
                                      (WPARAM)hDC,
                                      (LPARAM)(LPRECT)&aRtUser ))
            {
                goto SkipMarginRectangle;
            }
        }
        if (!(pPSD->Flags & PSD_DISABLEPAGEPAINTING))
        {
            Rectangle(hDC, aRt.left, aRt.top, aRt.right, aRt.bottom);
        }

SkipMarginRectangle:

        InflateRect(&aRt, -1, -1);
        if (pPSD->lpfnPagePaintHook)
        {
            LPPAGEPAINTHOOK lpfnPagePaintHook = GETPAGEPAINTHOOKFN(pPSD);

            aRtUser = aRt;
            hRgn = CreateRectRgnIndirect(&aRtUser);
            SelectClipRgn(hDC, hRgn);
            DeleteObject(hRgn);
            if ((*lpfnPagePaintHook)( hWnd,
                                      WM_PSD_GREEKTEXTRECT,
                                      (WPARAM)hDC,
                                      (LPARAM)(LPRECT)&aRtUser ))
            {
                goto SkipGreekText;
            }
        }
        if (!(pPSD->Flags & PSD_DISABLEPAGEPAINTING))
        {
            psGreekText = LocalAlloc( LPTR,
                                      10 * (sizeof(szGreekText) + sizeof(TCHAR)) );
            for (i = 0; i < 10; i++)
            {
                CopyMemory( &(psGreekText[i * (sizeof(szGreekText) / sizeof(TCHAR))]),
                            szGreekText,
                            sizeof(szGreekText) );
            }
            aRt.left++;
            aRt.right--;
            aRt.bottom -= (aRt.bottom - aRt.top) % pPI->PtMargins.y;
            hFontGreek = SelectObject(hDC, hFontGreek);
            DrawText( hDC,
                      psGreekText,
                      10 * (sizeof(szGreekText) / sizeof(TCHAR)),
                      &aRt,
                      DT_NOPREFIX | DT_WORDBREAK );
            SelectObject(hDC, hFontGreek);
            LocalFree(psGreekText);
        }
    }

SkipGreekText:

    InflateRect(&aRtPage, -1, -1);
    if (pPI->pPD->Flags & PI_WPAPER_ENVELOPE)
    {
        int iOrientation;

        aRt = aRtPage;
        if (aRt.right < aRt.bottom)     // portrait
        //  switch (pPI->dwRotation)
            {
        //      default :               // no landscape
        //      case ( ROTATE_LEFT ) :  // dot-matrix
        //      {
        //          aRt.left = aRt.right  - 16;
        //          aRt.top  = aRt.bottom - 32;
        //          iOrientation = 2;
        //          break;
        //      }
        //      case ( ROTATE_RIGHT ) : // HP PCL
        //      {
                    aRt.right  = aRt.left + 16;
                    aRt.bottom = aRt.top  + 32;
                    iOrientation = 1;
        //          break;
        //      }
            }
        else                            // landscape
        {
            aRt.left   = aRt.right - 32;
            aRt.bottom = aRt.top   + 16;
            iOrientation = 3;
        }
        hRgn = CreateRectRgnIndirect(&aRt);
        SelectClipRgn(hDC, hRgn);
        DeleteObject(hRgn);
        if (pPSD->lpfnPagePaintHook)
        {
            LPPAGEPAINTHOOK lpfnPagePaintHook = GETPAGEPAINTHOOKFN(pPSD);

            aRtUser = aRt;
            if ((*lpfnPagePaintHook)( hWnd,
                                      WM_PSD_ENVSTAMPRECT,
                                      (WPARAM)hDC,
                                      (LPARAM)(LPRECT)&aRtUser ))
            {
                goto SkipEnvelopeStamp;
            }
        }
        if (!(pPSD->Flags & PSD_DISABLEPAGEPAINTING))
        {
            switch (iOrientation)
            {
                default :          // HP PCL
            //  case ( 1 ) :
                {
                    DrawIcon(hDC, aRt.left, aRt.top, hIconPSStampP);
                    break;
                }
            //  case ( 2 ) :       // dot-matrix
            //  {
            //      DrawIcon(hDC, aRt.left - 16, aRt.top, hIconPSStampP);
            //      break;
            //  }
                case ( 3 ) :       // landscape
                {
                    DrawIcon(hDC, aRt.left, aRt.top, hIconPSStampL);
                    break;
                }
            }
        }
    }

SkipEnvelopeStamp:;

    aRtUser = aRtPage;
    hRgn = CreateRectRgnIndirect(&aRtUser);
    SelectClipRgn(hDC, hRgn);
    DeleteObject(hRgn);
    if (pPSD->lpfnPagePaintHook)
    {
        LPPAGEPAINTHOOK lpfnPagePaintHook = GETPAGEPAINTHOOKFN(pPSD);

        if ((*lpfnPagePaintHook)( hWnd,
                                  WM_PSD_YAFULLPAGERECT,
                                  (WPARAM)hDC,
                                  (LPARAM)(LPRECT)&aRtUser ))
        {
            goto NoMorePainting;
        }
    }

    //
    //  Draw the envelope lines.
    //
    if ( (!(pPSD->Flags & PSD_DISABLEPAGEPAINTING)) &&
         (pPI->pPD->Flags & PI_WPAPER_ENVELOPE) )
    {
        int iRotation;
        HGDIOBJ hPenBlack;

        aRt = aRtPage;
        if (aRt.right < aRt.bottom)                     // portrait
        {
        //  if (pPI->dwRotation == ROTATE_LEFT )        // dot-matrix
        //      iRotation = 3;
        //  else            // ROTATE_RIGHT             // HP PCL
                iRotation = 2;
        }
        else                                            // landscape
        {
            iRotation = 1;                              // normal
        }

        switch (iRotation)
        {
            default :
        //  case ( 1 ) :      // normal
            {
                aRt.right  = aRt.left + 32;
                aRt.bottom = aRt.top  + 13;
                break;
            }
            case ( 2 ) :      // left
            {
                aRt.right = aRt.left   + 13;
                aRt.top   = aRt.bottom - 32;
                break;
            }
        //  case ( 3 ) :      // right
        //  {
        //      aRt.left   = aRt.right - 13;
        //      aRt.bottom = aRt.top   + 32;
        //      break;
        //  }
        }

        InflateRect(&aRt, -3, -3);
        hPenBlack = SelectObject(hDC, GetStockObject(BLACK_PEN));
        switch (iRotation)
        {
            case ( 1 ) :       // normal
            {
                MoveToEx(hDC, aRt.left , aRt.top    , NULL);
                LineTo(  hDC, aRt.right, aRt.top);
                MoveToEx(hDC, aRt.left , aRt.top + 3, NULL);
                LineTo(  hDC, aRt.right, aRt.top + 3);
                MoveToEx(hDC, aRt.left , aRt.top + 6, NULL);
                LineTo(  hDC, aRt.right, aRt.top + 6);

                break;
            }
        //  case ( 2 ) :       // left
        //  case ( 3 ) :       // right
            default :
            {
                MoveToEx( hDC, aRt.left      , aRt.top       , NULL );
                LineTo(   hDC, aRt.left      , aRt.bottom     );
                MoveToEx( hDC, aRt.left   + 3, aRt.top       , NULL );
                LineTo(   hDC, aRt.left   + 3, aRt.bottom     );
                MoveToEx( hDC, aRt.left   + 6, aRt.top       , NULL );
                LineTo(   hDC, aRt.left   + 6, aRt.bottom     );

                break;
            }
        }
        SelectObject(hDC, hPenBlack);
    }

NoMorePainting:

    DeleteObject(SelectObject(hDC, hPen));
    SelectObject(hDC, hBr);
    DeleteObject(SelectObject(hDC, hFont));
    TransferPSD2PD(pPI);
    ReleaseDC(hWnd, hDC);

    return (lResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintLoadResource
//
//  This routine loads the resource with the given name and type.
//
////////////////////////////////////////////////////////////////////////////

HANDLE PrintLoadResource(
    HANDLE hInst,
    LPTSTR pResName,
    LPTSTR pType)
{
    HANDLE hResInfo, hRes;


    if (!(hResInfo = FindResource(hInst, pResName, pType)))
    {
        StoreExtendedError(CDERR_FINDRESFAILURE);
        return (NULL);
    }

    if (!(hRes = LoadResource(hInst, hResInfo)))
    {
        StoreExtendedError(CDERR_LOADRESFAILURE);
        return (NULL);
    }

    return (hRes);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintGetDefaultPrinterName
//
//  This routine gets the name of the default printer and stores it
//  in the given buffer.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintGetDefaultPrinterName(
    LPTSTR pDefaultPrinter,
    UINT cchSize)
{
    DWORD dwSize;
    LPTSTR lpsz;


    if (pDefaultPrinter[0] != CHAR_NULL)
    {
        return;
    }

    //
    //  First, try to get the default printername from the win.ini file.
    //
    if (GetProfileString( szTextWindows,
                          szTextDevice,
                          szTextNull,
                          pDefaultPrinter,
                          cchSize ))
    {
        lpsz = pDefaultPrinter;

        while (*lpsz != CHAR_COMMA)
        {
            if (!*lpsz++)
            {
                pDefaultPrinter[0] = CHAR_NULL;
                goto GetDefaultFromRegistry;
            }
        }

        *lpsz = CHAR_NULL;
    }
    else
    {

GetDefaultFromRegistry:

        //
        //  Second, try to get it from the registry.
        //
        dwSize = cchSize * sizeof(TCHAR);

        if (RegOpenKeyEx( HKEY_CURRENT_USER,
                          szRegistryPrinter,
                          0,
                          KEY_READ,
                          &hPrinterKey ) == ERROR_SUCCESS)
        {
            RegQueryValueEx( hPrinterKey,
                             szRegistryDefaultValueName,
                             NULL,
                             NULL,
                             (LPBYTE)(pDefaultPrinter),
                             &dwSize );

            RegCloseKey(hPrinterKey);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintReturnDefault
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintReturnDefault(
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    LPDEVNAMES pDN;
    LPDEVMODE pDM;


    StoreExtendedError(CDERR_GENERALCODES);

    if (pPD->hDevNames || pPD->hDevMode)
    {
        StoreExtendedError(PDERR_RETDEFFAILURE);
        return (FALSE);
    }

    PrintBuildDevNames(pPI);

    if ((pPD->hDevNames) && (pDN = GlobalLock(pPD->hDevNames)))
    {
#ifdef WINNT
        //
        //  This is not needed in Win95.  An optimization was
        //  added to DocumentProperties that allows the caller to
        //  simply pass in the printer name without the printer
        //  handle.
        //
        LPTSTR pPrinterName;

        pPrinterName = (LPTSTR)pDN + pDN->wDeviceOffset;

        if (pPrinterName[0])
        {
            PrintOpenPrinter(pPI, pPrinterName);
        }

        pPD->hDevMode = PrintGetDevMode( 0,
                                         pPI->hCurPrinter,
                                         pPrinterName,
                                         NULL );
#else
        pPD->hDevMode = PrintGetDevMode( 0,
                                         NULL,
                                         (LPTSTR)pDN + pDN->wDeviceOffset,
                                         NULL );
#endif

        if ((pPD->hDevMode) && (pDM = GlobalLock(pPD->hDevMode)))
        {
            PrintReturnICDC(pPD, pDN, pDM);

            GlobalUnlock(pPD->hDevMode);
            GlobalUnlock(pPD->hDevNames);

            return (TRUE);
        }
        GlobalUnlock(pPD->hDevNames);
        GlobalFree(pPD->hDevNames);
        pPD->hDevNames = NULL;
    }

    StoreExtendedError(PDERR_NODEFAULTPRN);
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitGeneral
//
//  Initialize (enable/disable) dialog elements general to both PrintDlg
//  and SetupDlg.
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintInitGeneral(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    HWND hCtl;


    SetWindowLong( hDlg,
                   GWL_STYLE,
                   GetWindowLong(hDlg, GWL_STYLE) | DS_CONTEXTHELP );

#ifndef WINNT
    if (!lpEditMarginProc)
    {
        WNDCLASSEX wc;

        wc.cbSize = sizeof(wc);

        GetClassInfoEx(NULL, TEXT("edit"), &wc);
        lpEditMarginProc = wc.lpfnWndProc;

        GetClassInfoEx(NULL, TEXT("static"), &wc);
        lpStaticProc = wc.lpfnWndProc;
    }
#endif

    //
    //  LATER: If we don't enumerate here, there will only be ONE item
    //         in the list box.  As a result, we won't catch the
    //         keyboard strokes within the list box (eg. arrow keys,
    //         pgup, pgdown, etc).  Need to subclass the combo boxes
    //         to catch these key strokes so that the printers can be
    //         enumerated.
    //
    if (!PrintEnumAndSelect( hDlg,
                             Id,
                             pPI,
                             (pPI->pCurPrinter)
                               ? pPI->pCurPrinter->pPrinterName
                               : NULL,
                             (!(pPI->Status & PI_PRINTERS_ENUMERATED)) ))
    {
        goto InitGeneral_ConstructFailure;
    }

    PrintUpdateStatus(hDlg, pPI);

    //
    //  See if the Help button should be hidden.
    //
    if (!(pPD->Flags & PD_SHOWHELP))
    {
        if (hCtl = GetDlgItem(hDlg, ID_BOTH_P_HELP))
        {
            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);
#ifdef WINNT
            //
            //  Move the window out of this spot so that no overlap
            //  will be detected when adding the network button.
            //
            MoveWindow(hCtl, -8000, -8000, 20, 20, FALSE);
#endif
        }
    }

    return (TRUE);

InitGeneral_ConstructFailure:

    if (!GetStoredExtendedError())
    {
        StoreExtendedError(PDERR_INITFAILURE);
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitPrintDlg
//
//  Initialize PRINT DLG-specific dialog stuff.
//
//  Returns 0xFFFFFFFF if the dialog should be ended.
//  Otherwise, returns 1/0 (TRUE/FALSE) depending on focus.
//
////////////////////////////////////////////////////////////////////////////

DWORD PrintInitPrintDlg(
    HWND hDlg,
    WPARAM wParam,
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    WORD wCheckID;
    HWND hCtl;


    //
    //  Set the number of copies.
    //
    pPD->nCopies = max(pPD->nCopies, 1);
    pPD->nCopies = min(pPD->nCopies, 9999);
    SetDlgItemInt(hDlg, ID_PRINT_E_COPIES, pPD->nCopies, FALSE);

    if ( !(pPI->pPSD) &&
         (hCtl = GetDlgItem(hDlg, ID_PRINT_E_COPIES)) &&
         (GetWindowLong(hCtl, GWL_STYLE) & WS_VISIBLE) )
    {
        //
        //  "9999" is the maximum value.
        //
        Edit_LimitText(hCtl, COPIES_EDIT_SIZE);

        CreateUpDownControl( WS_CHILD | WS_BORDER | WS_VISIBLE |
                                 UDS_ALIGNRIGHT | UDS_SETBUDDYINT |
                                 UDS_NOTHOUSANDS | UDS_ARROWKEYS,
                             0,
                             0,
                             0,
                             0,
                             hDlg,
                             9999,
                             g_hinst,
                             hCtl,
                             9999,
                             1,
                             pPD->nCopies );

        //
        // Adjust the width of the copies edit control using the current
        // font and the scroll bar width.  This is necessary to handle the 
        // the up down control from encroching on the space in the edit
        // control when we are in High Contrast (extra large) mode.
        //
        SetCopiesEditWidth(hDlg, hCtl);
    }

    if (!PrintInitBannerAndQuality(hDlg, pPI, pPD))
    {
        if (!GetStoredExtendedError())
        {
            StoreExtendedError(PDERR_INITFAILURE);
        }
        return (0xFFFFFFFF);
    }

#ifdef WINNT
    if (!(pPD->Flags & PD_SHOWHELP))
    {
        if (hCtl = GetDlgItem(hDlg, ID_BOTH_P_HELP))
        {
            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);

            //
            //  Move the window out of this spot so that no overlap
            //  will be detected when adding the network button.
            //
            MoveWindow(hCtl, -8000, -8000, 20, 20, FALSE);
        }
    }
#endif

    if (hCtl = GetDlgItem(hDlg, ID_PRINT_X_TOFILE))
    {
        if (pPD->Flags & PD_PRINTTOFILE)
        {
            CheckDlgButton(hDlg, ID_PRINT_X_TOFILE, TRUE);
        }

        if (pPD->Flags & PD_HIDEPRINTTOFILE)
        {
            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);
        }
        else if (pPD->Flags & PD_DISABLEPRINTTOFILE)
        {
            EnableWindow(hCtl, FALSE);
        }
    }

    if (pPD->Flags & PD_NOPAGENUMS)
    {
        EnableWindow(GetDlgItem(hDlg, ID_PRINT_R_PAGES), FALSE);
        EnableWindow(GetDlgItem(hDlg, ID_PRINT_S_FROM), FALSE);
        EnableWindow(GetDlgItem(hDlg, ID_PRINT_E_FROM), FALSE);
        EnableWindow(GetDlgItem(hDlg, ID_PRINT_S_TO), FALSE);
        EnableWindow(GetDlgItem(hDlg, ID_PRINT_E_TO), FALSE);

        //
        //  Don't allow disabled button checked.
        //
        pPD->Flags &= ~((DWORD)PD_PAGENUMS);
    }
    else
    {
        //
        //  Some apps (marked 3.1) do not pass in valid ranges.
        //      (e.g. Corel Ventura)
        //
        if ((pPI->ProcessVersion < 0x40000) || (!(pPD->Flags & PD_PAGENUMS)))
        {
            if (pPD->nFromPage != 0xFFFF)
            {
                if (pPD->nFromPage < pPD->nMinPage)
                {
                    pPD->nFromPage = pPD->nMinPage;
                }
                else if (pPD->nFromPage > pPD->nMaxPage)
                {
                    pPD->nFromPage = pPD->nMaxPage;
                }
            }
            if (pPD->nToPage != 0xFFFF)
            {
                if (pPD->nToPage < pPD->nMinPage)
                {
                    pPD->nToPage = pPD->nMinPage;
                }
                else if (pPD->nToPage > pPD->nMaxPage)
                {
                    pPD->nToPage = pPD->nMaxPage;
                }
            }
        }

        if ( pPD->nMinPage > pPD->nMaxPage ||
             ( pPD->nFromPage != 0xFFFF &&
               ( pPD->nFromPage < pPD->nMinPage ||
                 pPD->nFromPage > pPD->nMaxPage ) ) ||
             ( pPD->nToPage != 0xFFFF &&
               ( pPD->nToPage < pPD->nMinPage ||
                 pPD->nToPage > pPD->nMaxPage ) ) )
        {
            StoreExtendedError(PDERR_INITFAILURE);
            return (0xFFFFFFFF);
        }

        if (pPD->nFromPage != 0xFFFF)
        {
            SetDlgItemInt(hDlg, ID_PRINT_E_FROM, pPD->nFromPage, FALSE);
            if (pPD->nToPage != 0xFFFF)
            {
                SetDlgItemInt(hDlg, ID_PRINT_E_TO, pPD->nToPage, FALSE);
            }
        }
        else
        {
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_S_TO), FALSE);
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_E_TO), FALSE);
        }

        if (pPD->nMinPage == pPD->nMaxPage)
        {
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_R_PAGES), FALSE);
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_S_FROM), FALSE);
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_E_FROM), FALSE);
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_S_TO), FALSE);
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_E_TO), FALSE);

            //
            //  Don't allow disabled button checked.
            //
            pPD->Flags &= ~((DWORD)(PD_PAGENUMS | PD_COLLATE));
            pPI->Status &= ~PI_COLLATE_REQUESTED;
            EnableWindow(GetDlgItem(hDlg, ID_PRINT_X_COLLATE), FALSE);
            ShowWindow(GetDlgItem(hDlg, ID_PRINT_X_COLLATE), SW_HIDE);
        }
#ifndef WINNT
        //
        //  This is NOT desirable.  Most apps use a very high number for
        //  their max page, so it looks very strange.
        //
        else
        {
            TCHAR szAll[32];
            TCHAR szBuf[64];

            if (pPD->nMinPage != pPD->nMaxPage)
            {
                if (pPD->nMaxPage != 0xFFFF)
                {
                    if (LoadString(g_hinst, iszPrintRangeAll, szAll, 32))
                    {
                        wsprintf( szBuf,
                                  szAll,
                                  (DWORD)pPD->nMaxPage - (DWORD)pPD->nMinPage + 1 );
                        SetDlgItemText(hDlg, ID_PRINT_R_ALL, szBuf);
                    }
                    else
                    {
                        StoreExtendedError(CDERR_LOADSTRFAILURE);
                        return (0xFFFFFFFF);
                    }
                }
            }
        }
#endif
    }

    if (pPD->Flags & PD_NOSELECTION)
    {
        HWND hRad = GetDlgItem(hDlg, ID_PRINT_R_SELECTION);

        if (hRad)
        {
            EnableWindow(hRad, FALSE);
        }

        //
        //  Don't allow disabled button checked.
        //
        pPD->Flags &= ~((DWORD)PD_SELECTION);
    }

    if (pPD->Flags & PD_PAGENUMS)
    {
        wCheckID = ID_PRINT_R_PAGES;
    }
    else if (pPD->Flags & PD_SELECTION)
    {
        wCheckID = ID_PRINT_R_SELECTION;
    }
    else
    {
        // PD_ALL
        wCheckID = ID_PRINT_R_ALL;
    }

    CheckRadioButton(hDlg, ID_PRINT_R_ALL, ID_PRINT_R_PAGES, (int)wCheckID);

    //
    //  Subclass the integer only edit controls.
    //
    if (!(pPI->pPSD))
    {
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_E_FROM))
        {
            //
            //  "99999" is the maximum value.
            //
            Edit_LimitText(hCtl, PAGE_EDIT_SIZE);
        }
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_E_TO))
        {
            //
            //  "99999" is the maximum value.
            //
            Edit_LimitText(hCtl, PAGE_EDIT_SIZE);
        }
    }

    if (pPD->lpfnPrintHook)
    {
        LPPRINTHOOKPROC lpfnPrintHook = GETPRINTHOOKFN(pPD);

#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            DWORD dwHookRet;

            ThunkPrintDlgW2A(pPI);
            dwHookRet = (*lpfnPrintHook)( hDlg,
                                          WM_INITDIALOG,
                                          wParam,
                                          (LONG_PTR)pPI->pPDA );
            if (dwHookRet)
            {
                ThunkPrintDlgA2W(pPI);
            }

            return (dwHookRet);
        }
        else
#endif
        {
            return ( (*lpfnPrintHook)( hDlg,
                                       WM_INITDIALOG,
                                       wParam,
                                       (LONG_PTR)pPD ) );
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitSetupDlg
//
//  Initialize SETUP-specific dialog stuff.
//
//  Returns 0xFFFFFFFF if the dialog should be ended.
//  Otherwise, returns 1/0 (TRUE/FALSE) depending on focus.
//
////////////////////////////////////////////////////////////////////////////

DWORD PrintInitSetupDlg(
    HWND hDlg,
    WPARAM wParam,
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    LPDEVMODE pDM = NULL;
    HWND hCtl;
    LPPAGESETUPDLG pPSD = pPI->pPSD;
    UINT Orientation;


    if (!pPD->hDevMode ||
        !(pDM = GlobalLock(pPD->hDevMode)))
    {
        StoreExtendedError(CDERR_MEMLOCKFAILURE);
        goto InitSetupDlg_ConstructFailure;
    }

    if (hCtl = GetDlgItem(hDlg, ID_SETUP_C_SIZE))
    {
        PrintInitPaperCombo( pPI,
                             hCtl,
                             GetDlgItem(hDlg, ID_SETUP_S_SIZE),
                             pPI->pCurPrinter,
                             pDM,
                             DC_PAPERNAMES,
                             CCHPAPERNAME,
                             DC_PAPERS );
    }

    //
    //  Provide backward compatibility for old-style-template sources
    //  ID_SETUP_C_SOURCE.
    //
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_C_SOURCE))
    {
        PrintInitPaperCombo( pPI,
                             hCtl,
                             GetDlgItem(hDlg, ID_SETUP_S_SOURCE),
                             pPI->pCurPrinter,
                             pDM,
                             DC_BINNAMES,
                             CCHBINNAME,
                             DC_BINS );
    }

    //
    //  Set the edit field lengths and other setup stuff for margins.
    //  This must be called before PrintSetMargin, which is called in
    //  PrintSetOrientation.
    //
    PrintSetupMargins(hDlg, pPI);

    PrintInitOrientation(hDlg, pPI, pDM);
    Orientation = pDM->dmOrientation + ID_SETUP_R_PORTRAIT - DMORIENT_PORTRAIT;
    PrintSetOrientation( hDlg,
                         pPI,
                         pDM,
                         Orientation,
                         Orientation );

    PrintInitDuplex(hDlg, pDM);
    PrintSetDuplex( hDlg,
                    pDM,
                    pDM->dmDuplex + ID_SETUP_R_NONE - DMDUP_SIMPLEX );

    GlobalUnlock(pPD->hDevMode);

    if (pPSD)
    {
        if (pPSD->Flags & PSD_DISABLEORIENTATION)
        {
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_R_PORTRAIT), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_R_LANDSCAPE), FALSE );
        }
        if (pPSD->Flags & PSD_DISABLEPAPER)
        {
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_S_SIZE), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_C_SIZE), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_S_SOURCE), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_C_SOURCE), FALSE );
        }
        if (pPSD->Flags & PSD_DISABLEMARGINS)
        {
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_S_LEFT), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_E_LEFT),  FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_S_RIGHT), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_E_RIGHT),  FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_S_TOP), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_E_TOP),  FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_S_BOTTOM), FALSE );
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_E_BOTTOM),  FALSE );
        }
        if (pPSD->Flags & PSD_DISABLEPRINTER)
        {
            EnableWindow(GetDlgItem(hDlg, ID_SETUP_P_PRINTER), FALSE );
        }
    }

    if (hCtl = GetDlgItem(hDlg, ID_SETUP_W_SAMPLE))
    {
        lpStaticProc = (WNDPROC)SetWindowLongPtr( hCtl,
                                               GWLP_WNDPROC,
                                               (LONG_PTR)PrintPageSetupPaintProc );
    }

    if ((pPD->Flags & PD_NONETWORKBUTTON))
    {
        if (hCtl = GetDlgItem(hDlg, ID_BOTH_P_NETWORK))
        {
            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);
        }
    }
    else if (!(pPI->pPSD))
    {
#ifdef WINNT
        AddNetButton( hDlg,
                      ((pPD->Flags & PD_ENABLESETUPTEMPLATE)
                          ? pPD->hInstance : g_hinst),
                      FILE_BOTTOM_MARGIN,
                      (pPD->Flags & (PD_ENABLESETUPTEMPLATE |
                                     PD_ENABLESETUPTEMPLATEHANDLE))
                          ? FALSE : TRUE,
                      FALSE,
                      TRUE );
#endif
        //
        //  The button can be added in two ways -
        //      statically (they have it predefined in their template) and
        //      dynamically (successful call to AddNetButton).
        //
#ifdef WINNT
        if (!IsNetworkInstalled())
#else
        if (!GetSystemMetrics(SM_NETWORK))
#endif
        {
            hCtl = GetDlgItem(hDlg, ID_BOTH_P_NETWORK);

            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);
        }
    }

#ifdef WINNT
    if (!(pPD->Flags & PD_SHOWHELP))
    {
        if (hCtl = GetDlgItem(hDlg, ID_BOTH_P_HELP))
        {
            EnableWindow(hCtl, FALSE);
            ShowWindow(hCtl, SW_HIDE);

            //
            //  Move the window out of this spot so that no overlap
            //  will be detected when adding the network button.
            //
            MoveWindow(hCtl, -8000, -8000, 20, 20, FALSE);
        }
    }
#endif

    //
    //  Provide backward compatibility for old-style-template radio buttons.
    //
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_R_DEFAULT))
    {
        TCHAR szBuf[MAX_DEV_SECT];
        TCHAR szDefFormat[MAX_DEV_SECT];

        if (pPI->szDefaultPrinter[0])
        {
            if (!LoadString( g_hinst,
                             iszDefCurOn,
                             szDefFormat,
                             MAX_DEV_SECT ))
            {
                StoreExtendedError(CDERR_LOADSTRFAILURE);
                goto InitSetupDlg_ConstructFailure;
            }

            wsprintf(szBuf, szDefFormat, pPI->szDefaultPrinter);
        }
        else
        {
            szBuf[0] = CHAR_NULL;
            EnableWindow(hCtl, FALSE);
        }
        SetDlgItemText(hDlg, ID_SETUP_S_DEFAULT, szBuf);

        if ( pPI->pCurPrinter &&
             pPI->pCurPrinter->pPrinterName &&
             !lstrcmp(pPI->pCurPrinter->pPrinterName, pPI->szDefaultPrinter) )
        {
            CheckRadioButton( hDlg,
                              ID_SETUP_R_DEFAULT,
                              ID_SETUP_R_SPECIFIC,
                              ID_SETUP_R_DEFAULT );
        }
        else
        {
            CheckRadioButton( hDlg,
                              ID_SETUP_R_DEFAULT,
                              ID_SETUP_R_SPECIFIC,
                              ID_SETUP_R_SPECIFIC );
        }
    }

    if (pPD->lpfnSetupHook)
    {
        DWORD dwHookRet;
        LPSETUPHOOKPROC lpfnSetupHook = GETSETUPHOOKFN(pPD);

#ifdef UNICODE
        if (pPI->ApiType == COMDLG_ANSI)
        {
            ThunkPrintDlgW2A(pPI);
            TransferPDA2PSD(pPI);

            pPI->NestCtr++;
            dwHookRet = (*lpfnSetupHook)( hDlg,
                                          WM_INITDIALOG,
                                          wParam,
                                          (pPI->pPSD)
                                              ? (LONG_PTR)pPI->pPSD
                                              : (LONG_PTR)pPI->pPDA );
            pPI->NestCtr--;

            if (dwHookRet)
            {
                TransferPSD2PDA(pPI);
                ThunkPrintDlgA2W(pPI);
                if (pPI->NestCtr == 0)
                {
                    TransferPD2PSD(pPI);
                }
            }
        }
        else
#endif
        {
            TransferPD2PSD(pPI);
            dwHookRet = (*lpfnSetupHook)( hDlg,
                                          WM_INITDIALOG,
                                          wParam,
                                          (pPI->pPSD)
                                              ? (LONG_PTR)pPI->pPSD
                                              : (LONG_PTR)pPD );
            TransferPSD2PD(pPI);
        }


        return (dwHookRet);
    }

    return (TRUE);

InitSetupDlg_ConstructFailure:

    if (!GetStoredExtendedError())
    {
        StoreExtendedError(PDERR_INITFAILURE);
    }

    return (0xFFFFFFFF);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintUpdateSetupDlg
//
//  Update the print setup and page setup dialogs with the new settings.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintUpdateSetupDlg(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM,
    BOOL fResetContent)
{
    HWND hCtl;
    UINT Count;
    UINT Orientation = 0;


    //
    //  Update the Size combo box.
    //
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_C_SIZE))
    {
        if (fResetContent)
        {
            PrintInitPaperCombo( pPI,
                                 hCtl,
                                 GetDlgItem(hDlg, ID_SETUP_S_SIZE),
                                 pPI->pCurPrinter,
                                 pDM,
                                 DC_PAPERNAMES,
                                 CCHPAPERNAME,
                                 DC_PAPERS );
            //
            //  PrintInitPaperCombo will turn off the hour glass cursor, so
            //  turn it back on.
            //
            HourGlass(TRUE);
        }
        else
        {
            Count = (UINT) SendMessage(hCtl, CB_GETCOUNT, 0, 0);
            while (Count != 0)
            {
                Count--;
                if (pDM->dmPaperSize == (SHORT)SendMessage( hCtl,
                                                            CB_GETITEMDATA,
                                                            Count,
                                                            0 ) )
                {
                    break;
                }
            }

            SendMessage( hCtl,
                         CB_SETCURSEL,
                         Count,
                         0 );
        }
    }

    //
    //  Update the Source combo box.
    //
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_C_SOURCE))
    {
        if (fResetContent)
        {
            PrintInitPaperCombo( pPI,
                                 hCtl,
                                 GetDlgItem(hDlg, ID_SETUP_S_SOURCE),
                                 pPI->pCurPrinter,
                                 pDM,
                                 DC_BINNAMES,
                                 CCHBINNAME,
                                 DC_BINS );
            //
            //  PrintInitPaperCombo will turn off the hour glass cursor, so
            //  turn it back on.
            //
            HourGlass(TRUE);
        }
        else
        {
            Count = (UINT) SendMessage(hCtl, CB_GETCOUNT, 0, 0);
            while (Count != 0)
            {
                Count--;
                if (pDM->dmDefaultSource == (SHORT)SendMessage( hCtl,
                                                                CB_GETITEMDATA,
                                                                Count,
                                                                0 ) )
                {
                    break;
                }
            }

            SendMessage( hCtl,
                         CB_SETCURSEL,
                         Count,
                         0 );
        }
    }

    //
    //  Update the Orientation radio buttons.
    //
    if (GetDlgItem(hDlg, ID_SETUP_R_PORTRAIT))
    {
        Orientation = pDM->dmOrientation + ID_SETUP_R_PORTRAIT - DMORIENT_PORTRAIT;
        PrintSetOrientation( hDlg,
                             pPI,
                             pDM,
                             IsDlgButtonChecked(hDlg, ID_SETUP_R_PORTRAIT)
                                 ? ID_SETUP_R_PORTRAIT
                                 : ID_SETUP_R_LANDSCAPE,
                             Orientation );
    }

    //
    //  Update the Duplex radio buttons.
    //
    if (GetDlgItem(hDlg, ID_SETUP_R_NONE))
    {
        PrintSetDuplex( hDlg,
                        pDM,
                        pDM->dmDuplex + ID_SETUP_R_NONE - DMDUP_SIMPLEX );
    }

    //
    //  Update the page setup sample picture.
    //
    if ((Orientation == 0) && (hCtl = GetDlgItem(hDlg, ID_SETUP_W_SAMPLE)))
    {
        Orientation = pDM->dmOrientation + ID_SETUP_R_PORTRAIT - DMORIENT_PORTRAIT;
        PrintUpdatePageSetup( hDlg,
                              pPI,
                              pDM,
                              0,
                              Orientation );
    }

    //
    //  Update the Default/Specific Printer radio buttons.
    //
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_R_DEFAULT))
    {
        if ( pPI->pCurPrinter &&
             pPI->pCurPrinter->pPrinterName &&
             !lstrcmp(pPI->pCurPrinter->pPrinterName, pPI->szDefaultPrinter) )
        {
            CheckRadioButton( hDlg,
                              ID_SETUP_R_DEFAULT,
                              ID_SETUP_R_SPECIFIC,
                              ID_SETUP_R_DEFAULT );
        }
        else
        {
            CheckRadioButton( hDlg,
                              ID_SETUP_R_DEFAULT,
                              ID_SETUP_R_SPECIFIC,
                              ID_SETUP_R_SPECIFIC );
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetCopies
//
//  Sets the appropriate number of copies in the PrintDlg structure and
//  in the DevMode structure.
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintSetCopies(
    HWND hDlg,
    PPRINTINFO pPI,
    UINT Id)
{
    LPPRINTDLG pPD = pPI->pPD;
    LPDEVMODE pDM;
    WORD sMaxCopies;


    if ( (pPD->hDevMode) &&
         (pDM = GlobalLock(pPD->hDevMode)) )
    {
#ifdef UNICODE
        //
        //  If we're coming from a WOW app, we need to only set
        //  the copies in the devmode if the PD_USEDEVMODECOPIES
        //  flag is set.
        //
        if (IS16BITWOWAPP(pPD))
        {
            if (pPD->Flags & PD_USEDEVMODECOPIES)
            {
                pDM->dmCopies = pPD->nCopies;
                pPD->nCopies = 1;
            }
            else
            {
                pDM->dmCopies = 1;
            }

            return (TRUE);
        }
#endif
        if ( (!(pDM->dmFields & DM_COPIES)) ||
             ((!(pPI->pPSD)) &&
              (pPI->ProcessVersion < 0x40000) &&
              (!(pPD->Flags & PD_USEDEVMODECOPIES))) )
        {
LeaveInfoInPD:
            //
            //  The driver cannot do copies, so leave the
            //  copy/collate info in the pPD.
            //
            pDM->dmCopies = 1;
            SetField(pDM, dmCollate, DMCOLLATE_FALSE);
        }
        else if ( (pDM->dmSpecVersion < 0x0400) ||
                  (!(pDM->dmFields & DM_COLLATE)) )
        {
            //
            //  The driver can do copies, but not collate.
            //  Where the info goes depends on the PD_COLLATE flag.
            //
            if (pPD->Flags & PD_COLLATE)
            {
                goto LeaveInfoInPD;
            }
            else
            {
                goto PutInfoInDevMode;
            }
        }
        else
        {
PutInfoInDevMode:
            //
            //  Make sure we have a current printer.
            //
            if (!pPI->pCurPrinter)
            {
                goto LeaveInfoInPD;
            }

            //
            //  Make sure the driver can support the number
            //  of copies requested.
            //
            sMaxCopies = (WORD)DeviceCapabilities(
                                     pPI->pCurPrinter->pPrinterName,
                                     pPI->pCurPrinter->pPortName,
                                     DC_COPIES,
                                     NULL,
                                     NULL );
            if ((sMaxCopies < 1) || (sMaxCopies == (WORD)(-1)))
            {
                sMaxCopies = 1;
            }
            if (sMaxCopies < pPD->nCopies)
            {
                if (pPD->Flags & PD_USEDEVMODECOPIES)
                {
                    PrintEditError( hDlg,
                                    (Id == ID_PRINT_C_NAME)
                                        ? ID_PRINT_E_COPIES
                                        : ID_BOTH_P_PROPERTIES,
                                    iszTooManyCopies,
                                    sMaxCopies );

                    GlobalUnlock(pPD->hDevMode);
                    return (FALSE);
                }

                goto LeaveInfoInPD;
            }

            //
            //  The driver can do both copies and collate,
            //  so move the info to the devmode.
            //
            pDM->dmCopies = pPD->nCopies;
            SetField( pDM,
                      dmCollate,
                      (pPD->Flags & PD_COLLATE)
                          ? DMCOLLATE_TRUE
                          : DMCOLLATE_FALSE );
            pPD->nCopies = 1;
            pPD->Flags &= ~PD_COLLATE;
        }

        GlobalUnlock(pPD->hDevMode);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetMinMargins
//
////////////////////////////////////////////////////////////////////////////

VOID PrintSetMinMargins(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM)
{
    LPPAGESETUPDLG pPSD = pPI->pPSD;
    HDC hDC;
    RECT rtMinMargin;


    if (!pPSD)
    {
        return;
    }

    if (pPSD->Flags & PSD_MINMARGINS)
    {
        //
        //  Convert passed in margins to 10th of MMs.
        //
        if (pPSD->Flags & PSD_INHUNDREDTHSOFMILLIMETERS)
        {
            pPI->RtMinMarginMMs.left   = pPSD->rtMinMargin.left / 10;
            pPI->RtMinMarginMMs.top    = pPSD->rtMinMargin.top / 10;
            pPI->RtMinMarginMMs.right  = pPSD->rtMinMargin.right / 10;
            pPI->RtMinMarginMMs.bottom = pPSD->rtMinMargin.bottom / 10;
        }
        else           // PSD_INTHOUSANDTHSOFINCHES
        {
            pPI->RtMinMarginMMs.left   = pPSD->rtMinMargin.left * MMS_PER_INCH / 100;
            pPI->RtMinMarginMMs.top    = pPSD->rtMinMargin.top * MMS_PER_INCH / 100;
            pPI->RtMinMarginMMs.right  = pPSD->rtMinMargin.right * MMS_PER_INCH / 100;
            pPI->RtMinMarginMMs.bottom = pPSD->rtMinMargin.bottom * MMS_PER_INCH / 100;
        }
    }
    else
    {
        //
        //  Default to no minimum if we can't get the info.
        //
        pPI->RtMinMarginMMs.left   = 0;
        pPI->RtMinMarginMMs.top    = 0;
        pPI->RtMinMarginMMs.right  = 0;
        pPI->RtMinMarginMMs.bottom = 0;
        pPSD->rtMinMargin.left   = 0;
        pPSD->rtMinMargin.top    = 0;
        pPSD->rtMinMargin.right  = 0;
        pPSD->rtMinMargin.bottom = 0;

        //
        //  Calculate new min margins from driver.
        //
        if (hDC = CreateIC(NULL, pDM->dmDeviceName, NULL, pDM))
        {
            //
            //  These are in PIXELS.
            //
            int nPageWidth = GetDeviceCaps(hDC, PHYSICALWIDTH);
            int nPageHeight = GetDeviceCaps(hDC, PHYSICALHEIGHT);
            int nPrintWidth = GetDeviceCaps(hDC, HORZRES);
            int nPrintHeight = GetDeviceCaps(hDC, VERTRES);
            int nOffsetWidth = GetDeviceCaps(hDC, PHYSICALOFFSETX);
            int nOffsetHeight = GetDeviceCaps(hDC, PHYSICALOFFSETY);
            int nPerInchWidth = GetDeviceCaps(hDC, LOGPIXELSX);
            int nPerInchHeight = GetDeviceCaps(hDC, LOGPIXELSY);

            //
            //  Calculate min margins in PIXELS.
            //
            rtMinMargin.left   = nOffsetWidth;
            rtMinMargin.top    = nOffsetHeight;
            rtMinMargin.right  = nPageWidth - nPrintWidth - nOffsetWidth;
            rtMinMargin.bottom = nPageHeight - nPrintHeight - nOffsetHeight;

            //
            //  Convert to 10ths of MMs.
            //
            if (nPerInchWidth && nPerInchHeight)
            {
                pPI->RtMinMarginMMs.left   = rtMinMargin.left * MMS_PER_INCH / nPerInchWidth / 10;
                pPI->RtMinMarginMMs.top    = rtMinMargin.top * MMS_PER_INCH / nPerInchHeight / 10;
                pPI->RtMinMarginMMs.right  = rtMinMargin.right * MMS_PER_INCH / nPerInchHeight / 10;
                pPI->RtMinMarginMMs.bottom = rtMinMargin.bottom * MMS_PER_INCH / nPerInchHeight / 10;
            }

            if (pPSD->Flags & PSD_INHUNDREDTHSOFMILLIMETERS)
            {
                //
                //  Convert to 100ths of MMs.
                //
                pPSD->rtMinMargin.left   = pPI->RtMinMarginMMs.left / 10;
                pPSD->rtMinMargin.top    = pPI->RtMinMarginMMs.top / 10;
                pPSD->rtMinMargin.right  = pPI->RtMinMarginMMs.right / 10;
                pPSD->rtMinMargin.bottom = pPI->RtMinMarginMMs.bottom / 10;
            }
            else           // PSD_INTHOUSANDTHSOFINCHES
            {
                //
                //  Convert to 1000ths of inches.
                //
                if (nPerInchWidth && nPerInchHeight)
                {
                    pPSD->rtMinMargin.left   = rtMinMargin.left * 1000 / nPerInchWidth;
                    pPSD->rtMinMargin.top    = rtMinMargin.top * 1000 / nPerInchHeight;
                    pPSD->rtMinMargin.right  = rtMinMargin.right * 1000 / nPerInchHeight;
                    pPSD->rtMinMargin.bottom = rtMinMargin.bottom * 1000 / nPerInchHeight;
                }
            }

            DeleteDC(hDC);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetupMargins
//
////////////////////////////////////////////////////////////////////////////

VOID PrintSetupMargins(
    HWND hDlg,
    PPRINTINFO pPI)
{
    TCHAR szMars[32];
    TCHAR szText[16];
    int ids[4] = { ID_SETUP_E_LEFT,
                   ID_SETUP_E_TOP,
                   ID_SETUP_E_RIGHT,
                   ID_SETUP_E_BOTTOM };
    int i;
    HWND hEdt;


    //
    //  Margins are only available from the PageSetupDlg.
    //
    if (!(pPI->pPSD))
    {
        return;
    }

    for (i = 0; i < 4; i++)
    {
        if (hEdt = GetDlgItem(hDlg, ids[i]))
        {
            //
            //  "999999" is the maximum value.
            //
            SendMessage(hEdt, EM_LIMITTEXT, MARGIN_EDIT_SIZE, 0);

            lpEditMarginProc =
                (WNDPROC)SetWindowLongPtr( hEdt,
                                        GWLP_WNDPROC,
                                        (LONG_PTR)PrintEditMarginProc );

        }
    }

    if (!GetLocaleInfo( LOCALE_USER_DEFAULT,
                        LOCALE_SDECIMAL,
                        szText,
                        16 ))
    {
        cIntlDecimal = CHAR_DOT;
    }
    else
    {
        cIntlDecimal = szText[0];
    }

    switch (pPI->pPSD->Flags & (PSD_INTHOUSANDTHSOFINCHES |
                                PSD_INHUNDREDTHSOFMILLIMETERS))
    {
        case ( PSD_INHUNDREDTHSOFMILLIMETERS ) :
        {
            LoadString(g_hinst, iszMarginsMillimeters, szMars, 32);
            LoadString(g_hinst, iszMillimeters, cIntlMeasure, 5);

            break;
        }
        case ( PSD_INTHOUSANDTHSOFINCHES ) :
        {
            LoadString(g_hinst, iszMarginsInches, szMars, 32);
            LoadString(g_hinst, iszInches, cIntlMeasure, 5);

            break;
        }
    }

    cchIntlMeasure = lstrlen(cIntlMeasure);

    SetWindowText(GetDlgItem(hDlg, ID_SETUP_G_MARGINS), szMars);
    pPI->PtMargins.x = 2 * (IS_KEY_PRESSED(pPI->PtMargins.x / 4) &&
                            IS_KEY_PRESSED(pPI->PtMargins.y / 4)
                                ? sizeof(WCHAR)
                                : sizeof(CHAR));
    pPI->PtMargins.y = 2 * pPI->PtMargins.x;
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetMargin
//
////////////////////////////////////////////////////////////////////////////

VOID PrintSetMargin(
    HWND hDlg,
    PPRINTINFO pPI,
    UINT Id,
    LONG lValue)
{
    HWND hEdt;
    TCHAR szText[32];
    TCHAR szILZero[2];
    LONG lFract;


    if (hEdt = GetDlgItem(hDlg, Id))
    {
        switch (pPI->pPSD->Flags & (PSD_INTHOUSANDTHSOFINCHES |
                                    PSD_INHUNDREDTHSOFMILLIMETERS))
        {
            case ( PSD_INHUNDREDTHSOFMILLIMETERS ) :
            {
                lFract = lValue % 100;
                wsprintf( szText,
                          lFract ? TEXT("%lu%c%02lu") : TEXT("%lu"),
                          lValue / 100,
                          cIntlDecimal,
                          lFract );
                break;
            }
            case ( PSD_INTHOUSANDTHSOFINCHES ) :
            {
                lFract = lValue % 1000;
                wsprintf( szText,
                          lFract ? TEXT("%lu%c%03lu") : TEXT("%lu"),
                          lValue / 1000,
                          cIntlDecimal,
                          lFract );
                break;
            }
        }

        //
        //  Remove trailing zeros off of fraction.
        //
        if (lFract)
        {
            LPTSTR pStr = szText + lstrlen(szText) - 1;

            while (*pStr == TEXT('0'))
            {
                *pStr-- = TEXT('\0');
            }
        }

        //
        //  Determine if a leading zero is to be used and write the
        //  text to the edit window.
        //
        if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_ILZERO, szILZero, 2))
        {
            szILZero[0] = TEXT('0');
        }
        SetWindowText( hEdt,
                       szText + (szText[0] == TEXT('0') &&
                                 szText[1] == cIntlDecimal &&
                                 szILZero[0] == TEXT('0')) );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintGetMargin
//
////////////////////////////////////////////////////////////////////////////

VOID PrintGetMargin(
    HWND hEdt,
    PPRINTINFO pPI,
    LONG lMin,
    LONG *plMargin,
    LONG *plSample)
{
    TCHAR szText[16];
    TCHAR *pText;
    TCHAR *pFrac;

    GetWindowText(hEdt, szText, 16);
    *plMargin = ConvertStringToInteger(szText);

    for (pText = szText; *pText;)
    {
        if (*pText++ == cIntlDecimal)
        {
            break;
        }
    }

    for (pFrac = pText; *pFrac; pFrac++)
    {
        if (*pFrac == cIntlMeasure[0])
        {
            *pFrac = CHAR_NULL;
            break;
        }
    }
    lstrcat(pText, TEXT("000"));

    switch (pPI->pPSD->Flags & (PSD_INTHOUSANDTHSOFINCHES |
                                PSD_INHUNDREDTHSOFMILLIMETERS))
    {
        case ( PSD_INTHOUSANDTHSOFINCHES ) :
        {
            //
            //  In 1000ths of inches.
            //
            *plMargin *= 1000;
            pText[3] = CHAR_NULL;
            *plMargin += ConvertStringToInteger(pText);
            *plMargin = max(lMin, *plMargin);

            //
            //  In 10ths of MMs.
            //
            *plSample = *plMargin * MMS_PER_INCH / 1000;

            break;
        }
        case ( PSD_INHUNDREDTHSOFMILLIMETERS ) :
        {
            //
            //  In 100ths of MMs.
            //
            *plMargin *= 100 ;
            pText[2] = CHAR_NULL;
            *plMargin += ConvertStringToInteger(pText);
            *plMargin = max(lMin, *plMargin);

            //
            //  In 10ths of MMs.
            //
            *plSample = *plMargin / 10;

            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitBannerAndQuality
//
//  Reset PRINT DLG items dependent upon which printer was selected.
//  Assumes that pPD->hDevNames is non-NULL.  pPD->hDevMode non-NULL.
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintInitBannerAndQuality(
    HWND hDlg,
    PPRINTINFO pPI,
    LPPRINTDLG pPD)
{
    HWND hCtl;
    BOOL bResult = TRUE;
    LPDEVMODE pDM = NULL;
    LPDEVNAMES pDN = NULL;
    TCHAR szText[MAX_DEV_SECT];


    //
    //  ID_PRINT_S_DEFAULT is from one of the old templates.
    //
    if (GetDlgItem(hDlg, ID_PRINT_S_DEFAULT))
    {
        if (!pPD->hDevNames ||
            !(pDN = GlobalLock(pPD->hDevNames)))
        {
            StoreExtendedError(CDERR_MEMLOCKFAILURE);
            return (FALSE);
        }

        if (PrintCreateBanner(hDlg, pDN, szText, MAX_DEV_SECT))
        {
            SetDlgItemText(hDlg, ID_PRINT_S_DEFAULT, szText);
        }
        else
        {
            //
            //  PrintCreateBanner sets the extended error.
            //
            bResult = FALSE;
        }

        GlobalUnlock(pPD->hDevNames);
    }

    //
    //  If the driver says it can do copies, pay attention to what the
    //  app requested.  If it cannot do copies, check & disable the
    //  checkbox.
    //
    if (pPD->hDevMode)
    {
        if (!(pDM = GlobalLock(pPD->hDevMode)))
        {
            StoreExtendedError(CDERR_MEMLOCKFAILURE);
            return (FALSE);
        }

        //
        //  Enable print quality, if it exists.
        //
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_S_QUALITY))
        {
            EnableWindow(hCtl, TRUE);
        }
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_C_QUALITY))
        {
            EnableWindow(hCtl, TRUE);

            PrintInitQuality( hCtl,
                              pDM->dmSpecVersion <= 0x0300 ? 0L : pPD,
                              pDM->dmPrintQuality );
        }

        //
        //  If PD_USEDEVMODECOPIES(COLLATE), disable collate if the driver
        //  cannot collate.
        //
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_X_COLLATE))
        {
            if ( pDM->dmFields & DM_COLLATE ||
                 !(pPD->Flags & PD_USEDEVMODECOPIES) )
            {
                EnableWindow(hCtl, TRUE);
                CheckDlgButton( hDlg,
                                ID_PRINT_X_COLLATE,
                                (pPI->Status & PI_COLLATE_REQUESTED)
                                    ? TRUE : FALSE );
            }
            else
            {
                EnableWindow(hCtl, FALSE);
                CheckDlgButton(hDlg, ID_PRINT_X_COLLATE, FALSE);
            }
        }

        //
        //  If PD_USEDEVMODECOPIES(COLLATE), disable copies if the driver
        //  cannot copy.
        //
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_E_COPIES))
        {
            if ( pDM->dmFields & DM_COPIES ||
                 !(pPD->Flags & PD_USEDEVMODECOPIES) )
            {
                SetDlgItemInt(hDlg, ID_PRINT_E_COPIES, pPD->nCopies, FALSE);
                EnableWindow(hCtl, TRUE);
            }
            else
            {
                SetDlgItemInt(hDlg, ID_PRINT_E_COPIES, 1, FALSE);
                EnableWindow(hCtl, FALSE);
            }
        }

        //
        //  Display the appropriate collate icon.
        //
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_I_COLLATE))
        {
            SetWindowLong( hCtl,
                           GWL_STYLE,
                           GetWindowLong(hCtl, GWL_STYLE) | SS_CENTERIMAGE );
            ShowWindow(hCtl, SW_HIDE);
            SendMessage( hCtl,
                         STM_SETICON,
                         IsDlgButtonChecked(hDlg, ID_PRINT_X_COLLATE)
                             ? (LONG_PTR)hIconCollate
                             : (LONG_PTR)hIconNoCollate,
                         0L );
            ShowWindow(hCtl, SW_SHOW);
        }

        GlobalUnlock(pPD->hDevMode);
    }
    else
    {
        //
        //  Disable the print quality, collate, and copies.
        //
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_S_QUALITY))
        {
            EnableWindow(hCtl, FALSE);
        }
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_C_QUALITY))
        {
            EnableWindow(hCtl, FALSE);
        }
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_X_COLLATE))
        {
            EnableWindow(hCtl, FALSE);
        }
        if (hCtl = GetDlgItem(hDlg, ID_PRINT_E_COPIES))
        {
            EnableWindow(hCtl, FALSE);
        }
    }

    return (bResult);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintCreateBanner
//
//  Create "Printer: Prn on Port" or "Printer:  System Printer (Prn)".
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintCreateBanner(
    HWND hDlg,
    LPDEVNAMES pDN,
    LPTSTR psBanner,
    UINT cchBanner)
{
    if (GetDlgItem(hDlg, ID_BOTH_S_PRINTER))
    {
        psBanner[0] = CHAR_NULL;
    }
    else if (!LoadString( g_hinst,
                          iszPrinter,
                          psBanner,
                          cchBanner ))
    {
        goto LoadStrFailure;
    }

    if (pDN->wDefault & DN_DEFAULTPRN)
    {
        TCHAR szSysPrn[MAX_DEV_SECT];

        if (!LoadString(g_hinst, iszSysPrn, szSysPrn, MAX_DEV_SECT))
        {
            goto LoadStrFailure;
        }
        lstrcat(psBanner, (LPTSTR)szSysPrn);
        lstrcat(psBanner, (LPTSTR)pDN + pDN->wDeviceOffset);
        lstrcat(psBanner, (LPTSTR)TEXT(")"));
    }
    else
    {
        TCHAR szPrnOnPort[64];

        if (!LoadString(g_hinst, iszPrnOnPort, szPrnOnPort, 64))
        {
            goto LoadStrFailure;
        }
        lstrcat(psBanner, (LPTSTR)pDN + pDN->wDeviceOffset);
        lstrcat(psBanner, (LPTSTR)szPrnOnPort);
        lstrcat(psBanner, (LPTSTR)pDN + pDN->wOutputOffset);
    }

    return (TRUE);

LoadStrFailure:

    StoreExtendedError(CDERR_LOADSTRFAILURE);
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitQuality
//
//  Initializes the Printer Quality Combobox.
//
//  Assumes pPD structure filled by caller.  If non-NULL, it's a 3.1 or
//  later driver.  If NULL, fill with default for 3.0.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintInitQuality(
    HANDLE hCmb,
    LPPRINTDLG pPD,
    SHORT nQuality)
{
    SHORT nStringID;
    SHORT i;
    TCHAR szBuf[64];
    LPDEVMODE  pDM = NULL;
    LPDEVNAMES pDN = NULL;


    SendMessage(hCmb, CB_RESETCONTENT, 0, 0L);

    //
    //  Enum print qualities.
    //
    if (pPD && pPD->hDevMode && pPD->hDevNames)
    {
        HANDLE hPrnQ;                  // Memory handle for print qualities
        DWORD dw;                      // return from DC_ENUMRESOLUTIONS
        LPLONG pLong;                  // Pointer to pairs of longs
        LPTSTR psDevice;
        LPTSTR psPort;

        pDM = GlobalLock(pPD->hDevMode);
        pDN = GlobalLock(pPD->hDevNames);

        if (pDM->dmSpecVersion < 0x030A)
        {
            goto EnumResNotSupported;
        }

        psDevice = (LPTSTR)pDN + pDN->wDeviceOffset;
        psPort   = (LPTSTR)pDN + pDN->wOutputOffset;

        dw = DeviceCapabilities( psDevice,
                                 psPort,
                                 DC_ENUMRESOLUTIONS,
                                 NULL,
                                 NULL );
        if (!dw || (dw == (DWORD)(-1)))
        {
            goto EnumResNotSupported;
        }

        hPrnQ = GlobalAlloc(GHND, dw * 2 * sizeof(LONG));
        if (!hPrnQ)
        {
            goto EnumResNotSupported;
        }

        if (pLong = GlobalLock(hPrnQ))
        {
            dw = DeviceCapabilities( psDevice,
                                     psPort,
                                     DC_ENUMRESOLUTIONS,
                                     (LPTSTR)pLong,
                                     0 );

            for (nStringID = 0, i = (SHORT)(LOWORD(dw) - 1); i >= 0; i--)
            {
                DWORD xRes, yRes;

                if ((xRes = pLong[i * 2]) != (yRes = pLong[i * 2 + 1]) )
                {
                    wsprintf(szBuf, TEXT("%ld dpi x %ld dpi"), xRes, yRes);
                }
                else
                {
                    wsprintf(szBuf, TEXT("%ld dpi"), yRes);
                }

                SendMessage(hCmb, CB_INSERTSTRING, 0, (LONG_PTR)(LPTSTR)szBuf);
                SendMessage(hCmb, CB_SETITEMDATA, 0, xRes);

                if ( ((SHORT)xRes == nQuality) &&
                     ( (wWinVer < 0x030A) ||
                       !pDM->dmYResolution ||
                       (pDM->dmYResolution == (SHORT)yRes) ) )
                {
                    nStringID = i;
                }
            }
            GlobalUnlock(hPrnQ);
        }
        GlobalFree(hPrnQ);

        SendMessage(hCmb, CB_SETCURSEL, (WPARAM)nStringID, 0L);
    }
    else
    {
EnumResNotSupported:

        for ( i = -1, nStringID = iszDraftPrnQ;
              nStringID >= iszHighPrnQ;
              i--, nStringID-- )
        {
            if (!LoadString(g_hinst, nStringID, szBuf, 64))
            {
                return;
            }
            SendMessage(hCmb, CB_INSERTSTRING, 0, (LONG_PTR)(LPTSTR)szBuf);
            SendMessage(hCmb, CB_SETITEMDATA, 0, MAKELONG(i, 0));
        }

        if ((nQuality >= 0) || (nQuality < -4))
        {
            //
            //  Set to HIGH.
            //
            nQuality = -4;
        }
        SendMessage(hCmb, CB_SETCURSEL, (WPARAM)(nQuality + 4), 0L);
    }

    if (pDM)
    {
        GlobalUnlock(pPD->hDevMode);
    }
    if (pDN)
    {
        GlobalUnlock(pPD->hDevNames);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintChangeProperties
//
//  Puts up the dialog to modify the properties.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintChangeProperties(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    LPDEVMODE pDM;
    LONG cbNeeded;
    HANDLE hDevMode;
    WORD nCopies, nCollate;
    BOOL bTest;
    HWND hCtl;


    //
    //  There must be a devmode already.
    //
    if (!pPD->hDevMode)
    {
        return;
    }

    //
    //  Get the number of bytes needed for the devmode.
    //
    cbNeeded = DocumentProperties( hDlg,
                                   pPI->hCurPrinter,
                                   (pPI->pCurPrinter)
                                       ? pPI->pCurPrinter->pPrinterName
                                       : NULL,
                                   NULL,
                                   NULL,
                                   0 );

    //
    //  Reallocate the devmode to be sure there is enough room in it, and
    //  then put up the document properties dialog box.
    //
    if ( (cbNeeded > 0) &&
         (hDevMode = GlobalReAlloc(pPD->hDevMode, cbNeeded, GHND)) &&
         (pDM = GlobalLock(hDevMode)) )
    {
        //
        //  This is done here to make sure that the ReAlloc succeeded
        //  before trashing the old hDevMode.
        //
        pPD->hDevMode = hDevMode;

        //
        //  Set the number of copies and collation in the devmode before
        //  calling DocumentProperties, if appropriate.
        //
        nCopies = pDM->dmCopies;
        nCollate = pDM->dmCollate;
        if (Id == ID_PRINT_C_NAME)
        {
            //
            //  Get the number of copies from the edit control.
            //
            pDM->dmCopies = (WORD)GetDlgItemInt( hDlg,
                                                 ID_PRINT_E_COPIES,
                                                 &bTest,
                                                 FALSE );
            if ((!bTest) || (!pDM->dmCopies))
            {
                pDM->dmCopies = nCopies;
            }

            //
            //  Get the collation from the check box.
            //
            if ( (hCtl = GetDlgItem(hDlg, ID_PRINT_X_COLLATE)) &&
                 IsWindowEnabled(hCtl) )
            {
                SetField( pDM,
                          dmCollate,
                          (IsDlgButtonChecked(hDlg, ID_PRINT_X_COLLATE))
                              ? DMCOLLATE_TRUE
                              : DMCOLLATE_FALSE );
            }
        }
        else   // ID_SETUP_C_NAME
        {
            if ( (pDM->dmFields & DM_COPIES) &&
                 (pPI->ProcessVersion < 0x40000) &&
                 (!(pPD->Flags & PD_USEDEVMODECOPIES)) &&
                 (pPD->nCopies) )
            {
                pDM->dmCopies = pPD->nCopies;

                if (pDM->dmFields & DM_COLLATE)
                {
                    //
                    //  DM_COLLATE was specified, so dmCollate exists.
                    //
                    pDM->dmCollate = (pPD->Flags & PD_COLLATE)
                                         ? DMCOLLATE_TRUE
                                         : DMCOLLATE_FALSE;
                }
            }
        }

        //
        //  Put up the Document Properties dialog box.
        //
        if (DocumentProperties( hDlg,
                                pPI->hCurPrinter,
                                (pPI->pCurPrinter)
                                    ? pPI->pCurPrinter->pPrinterName
                                    : NULL,
                                pDM,
                                pDM,
                                DM_PROMPT | DM_MODIFY | DM_COPY ) == IDOK)
        {
            //
            //  Save the new number of copies and collation, if appropriate.
            //
            if (pDM->dmFields & DM_COPIES)
            {
                pPD->nCopies = pDM->dmCopies;
            }
            if (pDM->dmFields & DM_COLLATE)
            {
                if (pDM->dmCollate == DMCOLLATE_FALSE)
                {
                    pPD->Flags  &= ~PD_COLLATE;
                    pPI->Status &= ~PI_COLLATE_REQUESTED;
                }
                else
                {
                    pPD->Flags  |= PD_COLLATE;
                    pPI->Status |= PI_COLLATE_REQUESTED;
                }
            }

            //
            //  Update the dialog.
            //
            if (Id == ID_PRINT_C_NAME)
            {
                //
                //  Update the print dialog with the new info.
                //
                PrintInitBannerAndQuality(hDlg, pPI, pPD);
            }
            else   // ID_SETUP_C_NAME
            {
                //
                //  Update the print setup dialog with the new info.
                //
                PrintUpdateSetupDlg(hDlg, pPI, pDM, FALSE);
            }
        }
        else
        {
            //
            //  Operation cancelled.  Restore the number of copies
            //  and the collation in the devmode.
            //
            pDM->dmCopies = nCopies;
            SetField(pDM, dmCollate, nCollate);
        }

        GlobalUnlock(pPD->hDevMode);

        SendMessage( hDlg,
                     WM_NEXTDLGCTL,
                     (WPARAM)GetDlgItem(hDlg, IDOK),
                     1L );
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  PrintPrinterChanged
//
////////////////////////////////////////////////////////////////////////////

VOID PrintPrinterChanged(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    HANDLE hDM = NULL;
    LPDEVMODE pDM = NULL;
    LPDEVMODE pDMOld = NULL;
    HWND hCtl;
    UINT Orientation;
    LONG cbSize;
    DWORD dmSize;


    HourGlass(TRUE);

    //
    //  Close the old printer, if necessary.
    //
    if (pPI->hCurPrinter)
    {
        ClosePrinter(pPI->hCurPrinter);
        pPI->hCurPrinter = 0;
    }

    //
    //  Get the current printer from the combo box.
    //
    if (Id && (hCtl = GetDlgItem(hDlg, Id)))
    {
        TCHAR szPrinter[MAX_PRINTERNAME];
        DWORD ctr;

        SendMessage( hCtl,
                     CB_GETLBTEXT,
                     (WPARAM)SendMessage(hCtl, CB_GETCURSEL, 0, 0),
                     (LPARAM)(LPTSTR)szPrinter );

        pPI->pCurPrinter = NULL;
        for (ctr = 0; ctr < pPI->cPrinters; ctr++)
        {
            if (!lstrcmp(pPI->pPrinters[ctr].pPrinterName, szPrinter))
            {
                pPI->pCurPrinter = &pPI->pPrinters[ctr];
                break;
            }
        }
        if (!pPI->pCurPrinter)
        {
            HourGlass(FALSE);
            return;
        }
    }

    //
    //  Open the current printer.
    //
    OpenPrinter(pPI->pCurPrinter->pPrinterName, &pPI->hCurPrinter, NULL);

    //
    //  Build the device names.
    //
    PrintBuildDevNames(pPI);

    //
    //  Get the devmode information.
    //
    cbSize = DocumentProperties( hDlg,
                                 pPI->hCurPrinter,
                                 pPI->pCurPrinter->pPrinterName,
                                 NULL,
                                 NULL,
                                 0 );
    if (cbSize > 0)
    {
        hDM = GlobalAlloc(GHND, cbSize);

        //
        //  Get the default DevMode for the new printer.
        //
        if (hDM && (pDM = GlobalLock(hDM)) &&
            (DocumentProperties( hDlg,
                                 pPI->hCurPrinter,
                                 pPI->pCurPrinter->pPrinterName,
                                 pDM,
                                 NULL,
                                 DM_COPY ) == IDOK))
        {
            //
            //  See if we need to merge in old DevMode settings.
            //
            if (pPD->hDevMode && (pDMOld = GlobalLock(pPD->hDevMode)))
            {
                //
                //  Reset the PaperSource back to the Document Default.
                //
                if (pDM->dmFields & DM_DEFAULTSOURCE)
                {
                    pDMOld->dmFields |= DM_DEFAULTSOURCE;
                    pDMOld->dmDefaultSource = pDM->dmDefaultSource;
                }
                else
                {
                    pDMOld->dmFields &= ~DM_DEFAULTSOURCE;
                }

                //
                //  Copy relevant info from the old devmode to the new
                //  devmode.
                //
                dmSize = min(pDM->dmSize, pDMOld->dmSize);
                if (dmSize > FIELD_OFFSET(DEVMODE, dmFields))
                {
                    CopyMemory( &(pDM->dmFields),
                                &(pDMOld->dmFields),
                                dmSize - FIELD_OFFSET(DEVMODE, dmFields) );
                }

                //
                //  Free the old devmode.
                //
                GlobalUnlock(pPD->hDevMode);
                GlobalFree(pPD->hDevMode);
            }

            //
            //  Save the new DevMode in the pPD structure.
            //
            pPD->hDevMode = hDM;

            //
            //  Get the newly merged DevMode.
            //
            pDM->dmFields = pDM->dmFields & (DM_ORIENTATION | DM_PAPERSIZE  |
                                             DM_PAPERLENGTH | DM_PAPERWIDTH |
                                             DM_SCALE       | DM_COPIES     |
                                             DM_COLLATE     | DM_FORMNAME   |
                                             DM_DEFAULTSOURCE);
            DocumentProperties( hDlg,
                                pPI->hCurPrinter,
                                pPI->pCurPrinter->pPrinterName,
                                pDM,
                                pDM,
                                DM_MODIFY | DM_COPY );
            GlobalUnlock(hDM);
        }
        else if (hDM)
        {
            if (pDM)
            {
                GlobalUnlock(hDM);
            }
            GlobalFree(hDM);
        }
    }

    //
    //  Fill in the appropriate information for the rest of the
    //  Print or Print Setup dialog box.
    //
    if (Id == ID_PRINT_C_NAME)
    {
        PrintInitBannerAndQuality(hDlg, pPI, pPD);
    }
    else   // ID_SETUP_C_NAME
    {
        if (pPD->hDevMode && (pDM = GlobalLock(pPD->hDevMode)))
        {
            if (hCtl = GetDlgItem(hDlg, ID_SETUP_C_SIZE))
            {
                PrintInitPaperCombo( pPI,
                                     hCtl,
                                     GetDlgItem(hDlg, ID_SETUP_S_SIZE),
                                     pPI->pCurPrinter,
                                     pDM,
                                     DC_PAPERNAMES,
                                     CCHPAPERNAME,
                                     DC_PAPERS );
            }

            if (hCtl = GetDlgItem(hDlg, ID_SETUP_C_SOURCE))
            {
                PrintInitPaperCombo( pPI,
                                     hCtl,
                                     GetDlgItem(hDlg, ID_SETUP_S_SOURCE),
                                     pPI->pCurPrinter,
                                     pDM,
                                     DC_BINNAMES,
                                     CCHBINNAME,
                                     DC_BINS );
            }

            PrintInitOrientation(hDlg, pPI, pDM);
            Orientation = (pDM->dmOrientation == DMORIENT_PORTRAIT)
                              ? ID_SETUP_R_PORTRAIT
                              : ID_SETUP_R_LANDSCAPE;
            PrintSetOrientation(hDlg, pPI, pDM, Orientation, Orientation);

            PrintInitDuplex(hDlg, pDM);
            PrintSetDuplex( hDlg,
                            pDM,
                            pDM->dmDuplex + ID_SETUP_R_NONE - DMDUP_SIMPLEX );

            GlobalUnlock(pPD->hDevMode);
        }
    }

    //
    //  Update the status information.
    //
    PrintUpdateStatus(hDlg, pPI);

    HourGlass(FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintCancelPrinterChanged
//
//  Opens the old printer since the user hit cancel.  The devmode and
//  devnames structures have already been set back to the old ones.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintCancelPrinterChanged(
    PPRINTINFO pPI,
    LPTSTR pPrinterName)
{
    LPPRINTDLG pPD = pPI->pPD;
    PPRINTER_INFO_2 pCurPrinter;


    //
    //  Make sure we have a previous printer and a devmode.
    //
    if ((pPrinterName[0] == 0) || (!pPD->hDevMode))
    {
        return;
    }

    //
    //  Turn on the hour glass.
    //
    HourGlass(TRUE);

    //
    //  Find the current printer in the list.
    //
    pCurPrinter = PrintSearchForPrinter(pPI, pPrinterName);
    if (!pCurPrinter)
    {
        HourGlass(FALSE);
        return;
    }

    //
    //  Close the old printer, if necessary.
    //
    if (pPI->hCurPrinter)
    {
        ClosePrinter(pPI->hCurPrinter);
        pPI->hCurPrinter = 0;
    }

    //
    //  Save the current printer.
    //
    pPI->pCurPrinter = pCurPrinter;

    //
    //  Open the current printer.
    //
    OpenPrinter(pPI->pCurPrinter->pPrinterName, &pPI->hCurPrinter, NULL);

    //
    //  Turn off the hour glass.
    //
    HourGlass(FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintUpdateStatus
//
////////////////////////////////////////////////////////////////////////////

VOID PrintUpdateStatus(
    HWND hDlg,
    PPRINTINFO pPI)
{
    TCHAR szSeparator[] = TEXT("; ");
    TCHAR szText[256];
    TCHAR szJobs[64];
    LPDEVMODE pDM;
    UINT Length;
    DWORD dwStatus;
    int ctr;
    TCHAR *ps;
    BOOL bFound;


    //
    //  Update the printer status information in the dialog.
    //
    if (!GetDlgItem(hDlg, ID_BOTH_S_STATUS) || (!pPI->pCurPrinter))
    {
        return;
    }

    //
    //  ----------------------  Update Status  ----------------------
    //
    szText[0] = CHAR_NULL;

    if (pPI->pCurPrinter->Attributes & PRINTER_ATTRIBUTE_DEFAULT)
    {
        LoadString(g_hinst, iszStatusDefaultPrinter, szText, 32);
    }

    Length = lstrlen(szText);
    dwStatus = pPI->pCurPrinter->Status;
    for (ctr = 0; ctr++ < 32; dwStatus = dwStatus >> 1)
    {
        if (dwStatus & 1)
        {
            LoadString( g_hinst,
                        iszStatusReady + ctr,
                        szText + lstrlen(szText),
                        32 );
        }
    }

    if (szText[Length])
    {
        if (LoadString(g_hinst, iszStatusDocumentsWaiting, szJobs, 64))
        {
            wsprintf( szText + lstrlen(szText),
                      szJobs,
                      pPI->pCurPrinter->cJobs );
        }
    }
    else
    {
        LoadString(g_hinst, iszStatusReady, szText + Length, 32);
    }

    SetDlgItemText(hDlg, ID_BOTH_S_STATUS, szText);
    UpdateWindow(GetDlgItem(hDlg, ID_BOTH_S_STATUS));

    //
    //  ----------------------  Update Type  ----------------------
    //
    if (pPI->pCurPrinter->pDriverName)
    {
        lstrcpy(szText, pPI->pCurPrinter->pDriverName);
    }
    else
    {
        szText[0] = CHAR_NULL;
    }

    if (pPI->pPD->hDevMode && (pDM = GlobalLock(pPI->pPD->hDevMode)))
    {
        if (pDM->dmSpecVersion < 0x0400)
        {
            lstrcat(szText, TEXT(" (3.x)"));  // old driver designation
        }
        GlobalUnlock(pPI->pPD->hDevMode);
    }

    SetDlgItemText(hDlg, ID_BOTH_S_TYPE, szText);
    UpdateWindow(GetDlgItem(hDlg, ID_BOTH_S_TYPE));

    //
    //  ----------------------  Update Location  ----------------------
    //
    if (pPI->pCurPrinter->pLocation && pPI->pCurPrinter->pLocation[0])
    {
        bFound = FALSE;
        lstrcpy(szText, pPI->pCurPrinter->pLocation);
        for (ps = szText; *ps; ps++)
        {
            if (ps[0] == TEXT('\r') && ps[1] == TEXT('\n'))
            {
                *ps++ = CHAR_SEMICOLON;
                *ps   = CHAR_SPACE;
            }
            else
            {
                bFound = TRUE;
            }
        }
        if (!bFound)
        {
            goto ShowPortName;
        }
    }
    else
    {
ShowPortName:
        if (pPI->pCurPrinter->pPortName)
        {
            lstrcpy(szText, pPI->pCurPrinter->pPortName);
        }
        else
        {
            szText[0] = CHAR_NULL;
        }
    }

    EnableWindow(GetDlgItem(hDlg, ID_BOTH_S_WHERE), szText[0]);
    SetDlgItemText(hDlg, ID_BOTH_S_WHERE, szText);
    UpdateWindow(GetDlgItem(hDlg, ID_BOTH_S_WHERE));

    //
    //  ----------------------  Update Comment  ----------------------
    //
    if (pPI->pCurPrinter->pComment && pPI->pCurPrinter->pComment[0])
    {
        bFound = FALSE;
        lstrcpy(szText, pPI->pCurPrinter->pComment);
        for (ps = szText; *ps; ps++)
        {
            if (ps[0] == TEXT('\r') && ps[1] == TEXT('\n'))
            {
                *ps++ = CHAR_SEMICOLON;
                *ps   = CHAR_SPACE;
            }
            else
            {
                bFound = TRUE;
            }
        }
        if (!bFound)
        {
            //
            //  This is needed in case the comment field only has a
            //  carriage return in it.  Without this check, it will
            //  show a ";" in the comment field.  In this case, it
            //  should show "" in the comment field.
            //
            szText[0] = CHAR_NULL;
        }
    }
    else
    {
        szText[0] = CHAR_NULL;
    }

    EnableWindow(GetDlgItem(hDlg, ID_BOTH_S_COMMENT), szText[0]);
    SetDlgItemText(hDlg, ID_BOTH_S_COMMENT, szText);
    UpdateWindow(GetDlgItem(hDlg, ID_BOTH_S_COMMENT));
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintGetSetupInfo
//
//  Purpose:  Retrieve info from Print Setup dialog elements
//  Assumes:  hDevMode handle to valid DEVMODE structure
//  Returns:  TRUE if hDevMode valid, FALSE otherwise
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintGetSetupInfo(
    HWND hDlg,
    LPPRINTDLG pPD)
{
    LPDEVMODE pDM = NULL;
    LPDEVNAMES pDN = NULL;
    HWND hCmb;
    int nInd;


    if ( !pPD->hDevMode ||
         !(pDM = GlobalLock(pPD->hDevMode)) )
    {
        return (FALSE);
    }

    // Don't need to do this - this is kept up to date.
    // pDM->dmFields |= DM_ORIENTATION;

    if (hCmb = GetDlgItem(hDlg, ID_SETUP_C_SIZE))
    {
        nInd = (int) SendMessage(hCmb, CB_GETCURSEL, 0, 0L);
        if (nInd != CB_ERR)
        {
        //  pDM->dmFields |= DM_PAPERSIZE;
            pDM->dmPaperSize = (SHORT)SendMessage( hCmb,
                                                   CB_GETITEMDATA,
                                                   nInd,
                                                   0 );
#ifndef WINNT
            if (pDM->dmSpecVersion >= 0x0400)
#endif
            {
            //  pDM->dmFields |= DM_FORMNAME;
                SendMessage( hCmb,
                             CB_GETLBTEXT,
                             nInd,
                             (LPARAM)pDM->dmFormName );
            }
        }
    }

    if (hCmb = GetDlgItem(hDlg, ID_SETUP_C_SOURCE))
    {
        nInd = (int) SendMessage(hCmb, CB_GETCURSEL, 0 , 0L);
        if (nInd != CB_ERR)
        {
        //  pDM->dmFields |= DM_DEFAULTSOURCE;
            pDM->dmDefaultSource = (SHORT)SendMessage( hCmb,
                                                       CB_GETITEMDATA,
                                                       nInd,
                                                       0 );
        }
    }

    if ( (pPD->hDevNames) &&
         (pDN = GlobalLock(pPD->hDevNames)) )
    {
        PrintReturnICDC(pPD, pDN, pDM);
        GlobalUnlock(pPD->hDevNames);
    }

    GlobalUnlock(pPD->hDevMode);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSearchForPrinter
//
//  Returns the pointer to the PRINTER_INFO_2 structure for the printer
//  with the name pPrinterName.
//
////////////////////////////////////////////////////////////////////////////

PPRINTER_INFO_2 PrintSearchForPrinter(
    PPRINTINFO pPI,
    LPCTSTR lpsPrinterName)
{
    DWORD ctr;

    //
    //  Search for the printer.
    //
    for (ctr = 0; ctr < pPI->cPrinters; ctr++)
    {
        if (!lstrcmp(pPI->pPrinters[ctr].pPrinterName, lpsPrinterName))
        {
            //
            //  Found it.
            //
            return (&pPI->pPrinters[ctr]);
        }
    }

    //
    //  Did not find the printer.
    //
    return (NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintGetExtDeviceMode
//
////////////////////////////////////////////////////////////////////////////

#ifdef UNICODE

VOID PrintGetExtDeviceMode(
    HWND hDlg,
    PPRINTINFO pPI)
{
    DWORD ctr;
    LPDEVMODEA pDMA;
    LPDEVMODEW pDMW;
    int iResult;
    CHAR szPrinterNameA[MAX_PRINTERNAME];


    if (!pPI->bUseExtDeviceMode)
    {
        return;
    }

    //
    //  Allocate the array to hold whether or not a new devmode has been
    //  allocated for each of the printers.
    //
    //  This is necessary because if the call to ExtDeviceMode fails, then
    //  nothing was allocated.  The one that is currently in the pPrinters
    //  array is actually part of the big pPrinters array (from the call
    //  to GetPrinter - it wants one giant buffer).
    //
    if (pPI->cPrinters)
    {
        if (pPI->pAllocInfo)
        {
            GlobalFree(pPI->pAllocInfo);
        }
        pPI->pAllocInfo = (LPBOOL)GlobalAlloc( GPTR,
                                               pPI->cPrinters * sizeof(BOOL) );
    }

    //
    //  If we were called from a WOW app with a NULL devmode,
    //  then call ExtDeviceMode to get a default devmode.
    //
    for (ctr = 0; ctr < pPI->cPrinters; ctr++)
    {
        //
        //  Convert the printer name from Unicode to ANSI.
        //
        WideCharToMultiByte( CP_ACP,
                             0,
                             pPI->pPrinters[ctr].pPrinterName,
                             -1,
                             szPrinterNameA,
                             MAX_PRINTERNAME,
                             NULL,
                             NULL );

        //
        //  Call ExtDeviceMode with 0 flags to find out the
        //  size of the devmode structure we need.
        //
        iResult = ExtDeviceMode( hDlg,
                                 NULL,
                                 NULL,
                                 szPrinterNameA,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0 );
        if (iResult < 0)
        {
            continue;
        }

        //
        //  Allocate the space.
        //
        pDMA = GlobalAlloc(GPTR, iResult);
        if (!pDMA)
        {
            continue;
        }

        //
        //  Call ExtDeviceMode to get the dummy devmode structure.
        //
        iResult = ExtDeviceMode( hDlg,
                                 NULL,
                                 pDMA,
                                 szPrinterNameA,
                                 NULL,
                                 NULL,
                                 NULL,
                                 DM_COPY );
        if (iResult < 0)
        {
            GlobalFree(pDMA);
            continue;
        }

        //
        //  Call AllocateUnicodeDevMode to allocate and copy the unicode
        //  version of this ANSI dev mode.
        //
        pDMW = AllocateUnicodeDevMode(pDMA);
        if (!pDMW)
        {
            GlobalFree(pDMA);
            continue;
        }

        //
        //  Store the pointer to the new devmode in the old pointer
        //  position.  We don't have to worry about freeing the
        //  current contents of pPrinter[ctr].pDevMode before sticking
        //  in the new pointer because in reality the pPrinter memory
        //  buffer is just one long allocation (the memory pDevmode
        //  points to is part of the pPrinters buffer).  So, when the
        //  buffer is freed at the end, the old devmode will be freed
        //  with it.
        //
        pPI->pPrinters[ctr].pDevMode = pDMW;
        pPI->pAllocInfo[ctr] = TRUE;

        //
        //  Free the ANSI dev mode.
        //
        GlobalFree(pDMA);
    }
}
#endif


////////////////////////////////////////////////////////////////////////////
//
//  PrintEnumAndSelect
//
//  This routine enumerates the LOCAL and CONNECTED printers.
//  It is called at initialization and when a new printer is
//  added via the NETWORK... button.
//
//  If the second parameter is set, the first parameter is overridden.
//  When the second parameter is NULL, the first parameter is used.
//  In this case, if the first parameter is greater than the total
//  number of printers enumerated, then the last one in the list is
//  selected.
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintEnumAndSelect(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI,
    LPTSTR lpsPrinterToSelect,
    BOOL bEnumPrinters)
{
    HWND hCtl = ((hDlg && Id) ? GetDlgItem(hDlg, Id) : 0);
    LPPRINTDLG pPD = pPI->pPD;
    TCHAR szPrinter[MAX_PRINTERNAME];
    DWORD cbNeeded;
    DWORD cReturned;
    DWORD ctr;
    PPRINTER_INFO_2 pPrinters = NULL;


    //
    //  Enumerate the printers, if necessary.
    //
    if (bEnumPrinters)
    {
Print_Enumerate:
        //
        //  Save lpsPrinterToSelect in a local before it gets freed.
        //
        if (lpsPrinterToSelect)
        {
            lstrcpy(szPrinter, lpsPrinterToSelect);
            lpsPrinterToSelect = szPrinter;
        }

        //
        //  Close and free any open printers.
        //
        PrintClosePrinters(pPI);

        //
        //  Clear out the error code.
        //
        StoreExtendedError(CDERR_GENERALCODES);

        //
        //  Enumerate the printers.
        //
        if (!EnumPrinters( PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
                           NULL,
                           2,
                           NULL,
                           0,
                           &cbNeeded,
                           &cReturned ))
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                if (pPrinters = GlobalAlloc(GPTR, cbNeeded))
                {
                    if (EnumPrinters( PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS,
                                      NULL,
                                      2,
                                      (LPBYTE)pPrinters,
                                      cbNeeded,
                                      &cbNeeded,
                                      &cReturned ))
                    {
                        pPI->cPrinters = cReturned;
                        pPI->pPrinters =  pPrinters;
                        pPI->Status |= PI_PRINTERS_ENUMERATED;
                    }
                    else
                    {
                        StoreExtendedError(PDERR_NODEFAULTPRN);
                    }
                }
                else
                {
                    StoreExtendedError(CDERR_MEMALLOCFAILURE);
                }
            }
            else
            {
                StoreExtendedError(PDERR_NODEFAULTPRN);
            }
        }
        else
        {
            StoreExtendedError(PDERR_NODEFAULTPRN);
        }

        if (GetStoredExtendedError())
        {
            if (pPrinters)
            {
                GlobalFree(pPrinters);
            }
            return (FALSE);
        }

        //
        //  Make modifications for a WOW app.
        //
#ifdef UNICODE
        if (pPI->bUseExtDeviceMode)
        {
            PrintGetExtDeviceMode(hDlg, pPI);
        }
#endif

        //
        //  Try the selected printer.
        //
        if (lpsPrinterToSelect)
        {
            pPI->pCurPrinter = PrintSearchForPrinter(pPI, lpsPrinterToSelect);
        }

        //
        //  Open the current printer.
        //
        if (pPI->pCurPrinter)
        {
            //
            //  Open the current printer.
            //
            OpenPrinter(pPI->pCurPrinter->pPrinterName, &pPI->hCurPrinter, NULL);
        }
        else
        {
            //
            //  If there isn't a current printer, try the printers in
            //  the list until either one is found that can be opened or
            //  until there are no more printers in the list.
            //
            for (ctr = 0; ctr < pPI->cPrinters; ctr++)
            {
                pPI->pCurPrinter = &pPI->pPrinters[ctr];

                //
                //  Try to open the printer.
                //
                if (OpenPrinter( pPI->pCurPrinter->pPrinterName,
                                 &pPI->hCurPrinter,
                                 NULL ))
                {
                    break;
                }
            }
        }
    }
    else
    {
        //
        //  If there isn't a current printer, then try to enumerate.
        //  This means something isn't setup properly.
        //
        if ((!pPI->pCurPrinter) || (!pPI->pPrinters))
        {
            goto Print_Enumerate;
        }
    }

    if (hCtl)
    {
        //
        //  Reset the contents of the list box.
        //
        SendMessage(hCtl, CB_RESETCONTENT, 0, 0);

        //
        //  Add all of the printer name strings to the list box.
        //
        for (ctr = 0; ctr < pPI->cPrinters; ctr++)
        {
            SendMessage( hCtl,
                         CB_ADDSTRING,
                         0,
                         (LPARAM)pPI->pPrinters[ctr].pPrinterName );
        }

        //
        //  Set the current selection in the list box.
        //
        SendMessage( hCtl,
                     CB_SETCURSEL,
                     SendMessage( hCtl,
                                  CB_FINDSTRINGEXACT,
                                  (WPARAM)-1,
                                  (LPARAM)pPI->pCurPrinter->pPrinterName ),
                     0L );
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintBuildDevNames
//
////////////////////////////////////////////////////////////////////////////

VOID PrintBuildDevNames(
    PPRINTINFO pPI)
{
    LPPRINTDLG pPD = pPI->pPD;
    LPTSTR pPrinterName = NULL;
    LPTSTR pPortName = NULL;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szPort[MAX_PATH];
    LPTSTR pStr;
    LPDEVNAMES pDN;
    DWORD cbDevNames;
    HANDLE hPrinter ;
    PPRINTER_INFO_2 pPrinter = NULL;


    //
    //  If this is called from PrintReturnDefault, there is no
    //  PrinterInfo (pPI->pCurPrinter) because the printers were not
    //  enumerated.  So, build the DEVNAME from win.ini.
    //
    pStr = szBuffer;
    if (!pPI->pCurPrinter)
    {
        //
        //  Get the default printer from the "Windows" section of win.ini.
        //      (eg. device=\\server\local,winspool,Ne00:)
        //
        if ( (pPD->Flags & PD_RETURNDEFAULT) &&
             GetProfileString( szTextWindows,
                               szTextDevice,
                               szTextNull,
                               szBuffer,
                               MAX_PATH ) )
        {
            //  Examples of szBuffer:
            //    "My Local Printer,winspool,LPT1:"   or
            //    "\\server\local,winspool,Ne00:"

            //
            //  Skip leading space (if any).
            //
            while (*pStr == CHAR_SPACE)
            {
                pStr++;
            }

            //
            //  First token is the printer name.
            //
            pPrinterName = pStr;

            while (*pStr && *pStr != CHAR_COMMA)
            {
                pStr++;
            }

            //
            //  NULL terminate the printer name.
            //
            *pStr++ = CHAR_NULL;

            // For Newer Apps  return the port name from the PRINT_INFO_2 structure.
            // For older apps  return the short port name give in the win.ini
            if (pPI->ProcessVersion >= 0x40000)
            {
                //Newer App
                if (OpenPrinter(pPrinterName, &hPrinter, NULL))
                {
                    if (pPrinter = PrintGetPrinterInfo2(hPrinter))
                    {
                        lstrcpy(szPort, pPrinter->pPortName);
                        pPortName = szPort;
                        GlobalFree(pPrinter);
                    }
                    ClosePrinter(hPrinter);

                 }
            }
            else
            {

                //Old App

                //
                //  Skip the driver name (second token).
                //
                while (*pStr && *pStr++ != CHAR_COMMA)
                {
                    ;
                }

                //
                //  Skip leading space (if any).
                //
                while (*pStr == CHAR_SPACE)
                {
                    pStr++;
                }

                //
                //  Third (and last) token is the port name.
                //
                pPortName = pStr;
            }
        }
        else
        {
            return;
        }
    }
    else
    {
        //
        //  Get the printer name from the PrinterInfo2 structure
        //  for the current printer.
        //
        pPrinterName = pPI->pCurPrinter->pPrinterName;

        //
        //  Newer Apps:
        //    Get the port name from the PrinterInfo2 structure for the
        //    current printer.  Want to use the PrinterInfo2 structure
        //    for newer apps so that we can support multiple ports for
        //    one printer.
        //
        //  Older Apps:
        //    First try to get the port name from the "devices" section
        //    of win.ini.  If that fails, then use the PrinterInfo2
        //    structure for the current printer.
        //
        //    This needs to use the "devices" section first due to a bug
        //    in AutoCAD.  AutoCAD only allows 13 characters for the port
        //    name and it does not check the length when it tries to copy
        //    it to its own buffer.
        //
#ifdef WINNT
        if ( (pPI->ProcessVersion >= 0x40000) ||
             (!GetProfileString( szTextDevices,
                                 pPrinterName,
                                 szTextNull,
                                 szBuffer,
                                 MAX_PATH )) ||
             (!(pPortName = StrChr(szBuffer, CHAR_COMMA))) ||
             (!((++pPortName)[0])) )
#endif
        {
            //
            //  Get the port name from the PrinterInfo2 structure
            //  for the current printer.
            //
            pPortName = pPI->pCurPrinter->pPortName;
        }
    }

    //
    //  Compute the size of the DevNames structure.
    //
    cbDevNames = lstrlen(szDriver) + 1 +
                 lstrlen(pPortName) + 1 +
                 lstrlen(pPrinterName) + 1 +
                 DN_PADDINGCHARS;

    cbDevNames *= sizeof(TCHAR);
    cbDevNames += sizeof(DEVNAMES);

    //
    //  Allocate the new DevNames structure.
    //
    pDN = NULL;
    if (pPD->hDevNames)
    {
        HANDLE handle;

        handle = GlobalReAlloc(pPD->hDevNames, cbDevNames, GHND);

        //Make sure the Realloc succeeded.
        if (handle)
        {
            pPD->hDevNames = handle;
        }
        else
        {
            //Realloc didn't succeed.  Free the old the memory
            GlobalFree(pPD->hDevNames);
        }
    }
    else
    {
        pPD->hDevNames = GlobalAlloc(GHND, cbDevNames);
    }

    //
    //  Fill in the DevNames structure with the appropriate information.
    //
    if ( (pPD->hDevNames) &&
         (pDN = GlobalLock(pPD->hDevNames)) )
    {
        pDN->wDriverOffset = sizeof(DEVNAMES) / sizeof(TCHAR);
        lstrcpy((LPTSTR)pDN + pDN->wDriverOffset, szDriver);

        pDN->wDeviceOffset = pDN->wDriverOffset + lstrlen(szDriver) + 1;
        lstrcpy((LPTSTR)pDN + pDN->wDeviceOffset, pPrinterName);

        pDN->wOutputOffset = pDN->wDeviceOffset + lstrlen(pPrinterName) + 1;
        lstrcpy((LPTSTR)pDN + pDN->wOutputOffset, pPortName);

        if ( (pPD->Flags & PD_RETURNDEFAULT) ||
             !lstrcmp(pPrinterName, pPI->szDefaultPrinter) )
        {
            pDN->wDefault = DN_DEFAULTPRN;
        }
        else
        {
            pDN->wDefault = 0;
        }

        GlobalUnlock(pPD->hDevNames);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintGetDevMode
//
//  Create and/or fill DEVMODE structure.
//
////////////////////////////////////////////////////////////////////////////

HANDLE PrintGetDevMode(
    HWND hDlg,
    HANDLE hPrinter,
    LPTSTR lpsDeviceName,
    HANDLE hDevMode)
{
    LONG cbNeeded;
    LPDEVMODE pDM;


    cbNeeded = DocumentProperties( hDlg,
                                   hPrinter,
                                   lpsDeviceName,
                                   (PDEVMODE)NULL,
                                   (PDEVMODE)NULL,
                                   0 );

    if (cbNeeded > 0)
    {
        if (hDevMode)
        {
            HANDLE handle;
            
            handle = GlobalReAlloc(hDevMode, cbNeeded, GHND);

            //Make sure realloc succeeded.
            if (handle)
            {
                hDevMode  = handle;
            }
            else
            {
                //Realloc didn't succeed. Free the memory occupied
                GlobalFree(hDevMode);
            }

        }
        else
        {
            hDevMode = GlobalAlloc(GHND, cbNeeded);
        }

        if (hDevMode && (pDM = GlobalLock(hDevMode)))
        {
            if (DocumentProperties( hDlg,
                                    hPrinter,
                                    lpsDeviceName,
                                    pDM,
                                    NULL,
                                    DM_COPY ) != IDOK)
            {
                StoreExtendedError(PDERR_NODEFAULTPRN);
                GlobalUnlock(hDevMode);
                GlobalFree(hDevMode);
                return (NULL);
            }

            GlobalUnlock(hDevMode);
        }
        else
        {
            if (hDevMode)
            {
                StoreExtendedError(CDERR_MEMLOCKFAILURE);
                GlobalFree(hDevMode);
            }
            else
            {
                StoreExtendedError(CDERR_MEMALLOCFAILURE);
            }
            return (NULL);
        }
    }
    else
    {
        DWORD dwErrCode;

        hDevMode = NULL;
        dwErrCode = GetLastError();

        if ( (dwErrCode == ERROR_UNKNOWN_PRINTER_DRIVER) ||
             (dwErrCode == ERROR_MOD_NOT_FOUND) )
        {
            if (hDlg)
            {
                PrintEditError(hDlg, 0, iszUnknownDriver, lpsDeviceName);
            }
        }
    }

    return (hDevMode);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintReturnICDC
//
//  Retrieve either the hDC or the hIC if either flag is set.
//  Assumes the PD_PRINTOFILE flag is appropriately set.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintReturnICDC(
    LPPRINTDLG pPD,
    LPDEVNAMES pDN,
    LPDEVMODE pDM)
{
    if (pPD->Flags & PD_PRINTTOFILE)
    {
        lstrcpy((LPTSTR)pDN + pDN->wOutputOffset, szFilePort);
    }

#ifdef UNICODE
    //
    //  The dmCollate field wasn't part of the Win3.1 DevMode struct.  The way
    //  16-bit apps achieved collation was by checking the PD_COLLATE flag in
    //  the PrintDlg struct.  The app would then figure out the page printing
    //  order to achieve collation.  So what we're doing here is making sure
    //  that PD_COLLATE is the only collation mechanism for 16-bit apps.  If we
    //  let DM_COLLATE get into the DC we'd end up with the driver trying to
    //  collate a job that the app is already trying to collate!
    //
    if ((pPD->Flags & CD_WOWAPP) && pDM)
    {
        if (pDM->dmFields & DM_COLLATE)
        {
            pPD->Flags |= PD_COLLATE;
        }

        // these should always be off for WOW apps
        pDM->dmCollate = DMCOLLATE_FALSE;
        pDM->dmFields &= ~DM_COLLATE;
    }
#endif

    switch (pPD->Flags & (PD_RETURNDC | PD_RETURNIC))
    {
        case ( PD_RETURNIC ) :
        {
            pPD->hDC = CreateIC( (LPTSTR)pDN + pDN->wDriverOffset,
                                 (LPTSTR)pDN + pDN->wDeviceOffset,
                                 (LPTSTR)pDN + pDN->wOutputOffset,
                                 pDM);
            if (pPD->hDC)
            {
                break;
            }

            // else fall thru...
        }
        case ( PD_RETURNDC ) :
        case ( PD_RETURNDC | PD_RETURNIC ) :
        {
            //
            //  PD_RETURNDC has priority if they are both set.
            //
            pPD->hDC = CreateDC( (LPTSTR)pDN + pDN->wDriverOffset,
                                 (LPTSTR)pDN + pDN->wDeviceOffset,
                                 (LPTSTR)pDN + pDN->wOutputOffset,
                                 pDM );
            break;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintMeasureItem
//
////////////////////////////////////////////////////////////////////////////

VOID PrintMeasureItem(
    HANDLE hDlg,
    LPMEASUREITEMSTRUCT mis)
{
    HDC hDC;
    TEXTMETRIC TM;
    HANDLE hFont;


    if (hDC = GetDC(hDlg))
    {
        hFont = (HANDLE)SendMessage(hDlg, WM_GETFONT, 0, 0L);
        if (!hFont)
        {
            hFont = GetStockObject(SYSTEM_FONT);
        }
        hFont = SelectObject(hDC, hFont);
        GetTextMetrics(hDC, &TM);
        mis->itemHeight = (WORD)TM.tmHeight;
        SelectObject(hDC, hFont);
        ReleaseDC(hDlg, hDC);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitOrientation
//
//  Enable/Disable Paper Orientation controls
//
//  NOTE: If the driver doesn't support orientation AND is smart
//  enough to tell us about it, disable the appropriate dialog items.
//  "Smart enough" means the driver must support DC_ORIENTATION in its
//  DeviceCapabilities routine.  This was introduced for 3.1, hence the
//  version test.  NotBadDriver() may need to be incorporated if a
//  problem driver is found in testing.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintInitOrientation(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM)
{
    BOOL bEnable = TRUE;
    HWND hCtl;
    HDC hDC;
    int iHeight;
    PPRINTER_INFO_2 pPrinter = pPI->pCurPrinter;


    if (!pPrinter)
    {
        return;
    }

    if (pDM->dmSpecVersion >= 0x030A)
    {
        pPI->dwRotation = DeviceCapabilities( pPrinter->pPrinterName,
                                              pPrinter->pPortName,
                                              DC_ORIENTATION,
                                              NULL,
                                              pDM );
        switch (pPI->dwRotation)
        {
            case ( ROTATE_LEFT ) :
            case ( ROTATE_RIGHT ) :
            {
                bEnable = TRUE;
                break;
            }
            default :
            {
                pPI->dwRotation = 0;
                bEnable = FALSE;
                pDM->dmOrientation = DMORIENT_PORTRAIT;
                CheckRadioButton( hDlg,
                                  ID_SETUP_R_PORTRAIT,
                                  ID_SETUP_R_LANDSCAPE,
                                  ID_SETUP_R_PORTRAIT );
                break;
            }
        }
    }

    if ( (pDM->dmOrientation != DMORIENT_PORTRAIT) &&
         (pDM->dmOrientation != DMORIENT_LANDSCAPE) )
    {
        pDM->dmOrientation  = DMORIENT_PORTRAIT;
    }

    if (hCtl = GetDlgItem(hDlg, ID_SETUP_R_LANDSCAPE))
    {
        //
        //  Landscape
        //
        if ( !( (pPI->pPSD) &&
                (pPI->pPSD->Flags & PSD_DISABLEORIENTATION) ) )
        {
            EnableWindow(hCtl, bEnable);
        }
    }
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_I_ORIENTATION))
    {
        //
        //  Orientation of icon.
        //
        SetWindowLong( hCtl,
                       GWL_STYLE,
                       GetWindowLong(hCtl, GWL_STYLE) | SS_CENTERIMAGE );
    }

    if ( (!pPI->RtSampleXYWH.left) &&
         (hCtl = GetDlgItem(hDlg, ID_SETUP_W_SAMPLE)) )
    {
        GetWindowRect(hCtl, (LPRECT)&pPI->RtSampleXYWH);
        ScreenToClient(hDlg, (LPPOINT)&pPI->RtSampleXYWH.left);
        ScreenToClient(hDlg, (LPPOINT)&pPI->RtSampleXYWH.right);

        iHeight = pPI->RtSampleXYWH.bottom - pPI->RtSampleXYWH.top;
        pPI->RtSampleXYWH.bottom = iHeight;

        if (hDC = GetDC(0))
        {
            iHeight = iHeight * GetDeviceCaps(hDC, LOGPIXELSX) /
                                GetDeviceCaps(hDC, LOGPIXELSY);
            ReleaseDC(0, hDC);
        }

        pPI->RtSampleXYWH.left =
            (pPI->RtSampleXYWH.left + pPI->RtSampleXYWH.right - iHeight) / 2;
        pPI->RtSampleXYWH.right = iHeight;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetOrientation
//
//  Switch icon, check button, for Portrait or LandScape printing mode.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintSetOrientation(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM,
    UINT uiOldId,
    UINT uiNewId)
{
    BOOL bPortrait;
    HWND hIcn;


    bPortrait = (uiNewId == ID_SETUP_R_PORTRAIT);

    pDM->dmOrientation = ( bPortrait
                               ? DMORIENT_PORTRAIT
                               : DMORIENT_LANDSCAPE );

    CheckRadioButton(hDlg, ID_SETUP_R_PORTRAIT, ID_SETUP_R_LANDSCAPE, uiNewId);

    if (hIcn = GetDlgItem(hDlg, ID_SETUP_I_ORIENTATION))
    {
        ShowWindow(hIcn, SW_HIDE);
        SendMessage( hIcn,
                     STM_SETICON,
                     bPortrait ? (LONG_PTR)hIconPortrait : (LONG_PTR)hIconLandscape,
                     0L );
        ShowWindow(hIcn, SW_SHOW);
    }

    //
    //  Update the page setup dialog, if necessary.
    //
    if (pPI->pPSD)
    {
        PrintUpdatePageSetup(hDlg, pPI, pDM, uiOldId, uiNewId);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintUpdatePageSetup
//
//  Update the page setup information.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintUpdatePageSetup(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM,
    UINT uiOldId,
    UINT uiNewId)
{
    BOOL bPortrait = (uiNewId == ID_SETUP_R_PORTRAIT);
    LPPAGESETUPDLG pPSD = pPI->pPSD;
    LPPRINTDLG pPD = pPI->pPD;
    HWND hWndSample;
    HWND hWndShadowRight;
    HWND hWndShadowBottom;
    HWND hWndSize;
    LONG lTemp;


    if (!pPSD)
    {
        return;
    }

    if (uiOldId != uiNewId)
    {
        RECT aRtMinMargin = pPSD->rtMinMargin;
        RECT aRtMargin    = pPSD->rtMargin;
        HWND hWndLeft     = GetDlgItem(hDlg, ID_SETUP_E_LEFT);
        HWND hWndTop      = GetDlgItem(hDlg, ID_SETUP_E_TOP);
        HWND hWndRight    = GetDlgItem(hDlg, ID_SETUP_E_RIGHT);
        HWND hWndBottom   = GetDlgItem(hDlg, ID_SETUP_E_BOTTOM);
        TCHAR szLeft  [8];
        TCHAR szTop   [8];
        TCHAR szRight [8];
        TCHAR szBottom[8];

        GetWindowText(hWndLeft, szLeft, 8);
        GetWindowText(hWndTop, szTop, 8);
        GetWindowText(hWndRight, szRight, 8);
        GetWindowText(hWndBottom, szBottom, 8);

        switch (uiNewId + pPI->dwRotation)
        {
            case ( ID_SETUP_R_PORTRAIT  + ROTATE_RIGHT ) :  // HP PCL
            case ( ID_SETUP_R_LANDSCAPE + ROTATE_LEFT ) :   // dot-matrix
            {
                pPSD->rtMinMargin.left   = aRtMinMargin.top;
                pPSD->rtMinMargin.top    = aRtMinMargin.right;
                pPSD->rtMinMargin.right  = aRtMinMargin.bottom;
                pPSD->rtMinMargin.bottom = aRtMinMargin.left;

                pPSD->rtMargin.left   = aRtMargin.top;
                pPSD->rtMargin.top    = aRtMargin.right;
                pPSD->rtMargin.right  = aRtMargin.bottom;
                pPSD->rtMargin.bottom = aRtMargin.left;

                SetWindowText(hWndLeft, szTop);
                SetWindowText(hWndRight, szBottom);
                SetWindowText(hWndTop, szRight);
                SetWindowText(hWndBottom, szLeft);

                break;
            }
            case ( ID_SETUP_R_PORTRAIT  + ROTATE_LEFT ) :   // dot-matrix
            case ( ID_SETUP_R_LANDSCAPE + ROTATE_RIGHT ) :  // HP PCL
            {
                pPSD->rtMinMargin.left   = aRtMinMargin.bottom;
                pPSD->rtMinMargin.top    = aRtMinMargin.left;
                pPSD->rtMinMargin.right  = aRtMinMargin.top;
                pPSD->rtMinMargin.bottom = aRtMinMargin.right;

                pPSD->rtMargin.left   = aRtMargin.bottom;
                pPSD->rtMargin.top    = aRtMargin.left;
                pPSD->rtMargin.right  = aRtMargin.top;
                pPSD->rtMargin.bottom = aRtMargin.right;

                SetWindowText(hWndLeft, szBottom);
                SetWindowText(hWndRight, szTop);
                SetWindowText(hWndTop, szLeft);
                SetWindowText(hWndBottom, szRight);

                break;
            }
        }
    }
    pPI->uiOrientationID = uiNewId;

    //
    //  Update ptPaperSize.
    //
    pPI->PtPaperSizeMMs.x = 0;
    pPI->PtPaperSizeMMs.y = 0;
    pPD->Flags &= ~PI_WPAPER_ENVELOPE;

    if ((hWndSize = GetDlgItem(hDlg, ID_SETUP_C_SIZE)) && (pPI->pCurPrinter))
    {
        PPRINTER_INFO_2 pPrinter = pPI->pCurPrinter;
        DWORD dwNumber;
        LPWORD lpPapers;
        LPPOINT lpPaperSize;
        int nInd;
        DWORD i;

        dwNumber = DeviceCapabilities( pPrinter->pPrinterName,
                                       pPrinter->pPortName,
                                       DC_PAPERS,
                                       NULL,
                                       pDM );
        if ( dwNumber &&
             (dwNumber != (DWORD)-1) &&
             (lpPapers = LocalAlloc( LPTR,
                                     dwNumber *
                                         (sizeof(WORD) + sizeof(POINT)) * 2 )) )
        {
            lpPaperSize = (LPPOINT)(lpPapers + dwNumber * 2);

            DeviceCapabilities( pPrinter->pPrinterName,
                                pPrinter->pPortName,
                                DC_PAPERS,
                                (LPTSTR)lpPapers,
                                pDM );
            DeviceCapabilities( pPrinter->pPrinterName,
                                pPrinter->pPortName,
                                DC_PAPERSIZE,
                                (LPTSTR)lpPaperSize,
                                pDM );

            if ((nInd = (int) SendMessage(hWndSize, CB_GETCURSEL, 0, 0)) != CB_ERR)
            {
                pPI->wPaper = (WORD)SendMessage( hWndSize,
                                                 CB_GETITEMDATA,
                                                 nInd,
                                                 0 );
                pDM->dmPaperSize = pPI->wPaper;
            }
            else
            {
                pPI->wPaper = pDM->dmPaperSize;
            }

#ifndef WINNT
            if (pDM->dmSpecVersion >= 0x0400)
#endif
            {
                SendMessage( hWndSize,
                             CB_GETLBTEXT,
                             nInd,
                             (LPARAM)pDM->dmFormName );
            }

            switch (pPI->wPaper)
            {
                case ( DMPAPER_ENV_9 ) :
                case ( DMPAPER_ENV_10 ) :
                case ( DMPAPER_ENV_11 ) :
                case ( DMPAPER_ENV_12 ) :
                case ( DMPAPER_ENV_14 ) :
                case ( DMPAPER_ENV_DL ) :
                case ( DMPAPER_ENV_C5 ) :
                case ( DMPAPER_ENV_C3 ) :
                case ( DMPAPER_ENV_C4 ) :
                case ( DMPAPER_ENV_C6 ) :
                case ( DMPAPER_ENV_C65 ) :
                case ( DMPAPER_ENV_B4 ) :
                case ( DMPAPER_ENV_B5 ) :
                case ( DMPAPER_ENV_B6 ) :
                case ( DMPAPER_ENV_ITALY ) :
                case ( DMPAPER_ENV_MONARCH ) :
                case ( DMPAPER_ENV_PERSONAL ) :
                case ( DMPAPER_ENV_INVITE ) :
                case ( DMPAPER_JENV_KAKU2 ) :
                case ( DMPAPER_JENV_KAKU3 ) :
                case ( DMPAPER_JENV_CHOU3 ) :
                case ( DMPAPER_JENV_CHOU4 ) :
                case ( DMPAPER_JENV_KAKU2_ROTATED ) :
                case ( DMPAPER_JENV_KAKU3_ROTATED ) :
                case ( DMPAPER_JENV_CHOU3_ROTATED ) :
                case ( DMPAPER_JENV_CHOU4_ROTATED ) :
                case ( DMPAPER_JENV_YOU4 ) :
                case ( DMPAPER_JENV_YOU4_ROTATED ) :
                case ( DMPAPER_PENV_1 ) :
                case ( DMPAPER_PENV_2 ) :
                case ( DMPAPER_PENV_3 ) :
                case ( DMPAPER_PENV_4 ) :
                case ( DMPAPER_PENV_5 ) :
                case ( DMPAPER_PENV_6 ) :
                case ( DMPAPER_PENV_7 ) :
                case ( DMPAPER_PENV_8 ) :
                case ( DMPAPER_PENV_9 ) :
                case ( DMPAPER_PENV_10 ) :
                case ( DMPAPER_PENV_1_ROTATED ) :
                case ( DMPAPER_PENV_2_ROTATED ) :
                case ( DMPAPER_PENV_3_ROTATED ) :
                case ( DMPAPER_PENV_4_ROTATED ) :
                case ( DMPAPER_PENV_5_ROTATED ) :
                case ( DMPAPER_PENV_6_ROTATED ) :
                case ( DMPAPER_PENV_7_ROTATED ) :
                case ( DMPAPER_PENV_8_ROTATED ) :
                case ( DMPAPER_PENV_9_ROTATED ) :
                case ( DMPAPER_PENV_10_ROTATED ) :
                {
                    pPD->Flags |= PI_WPAPER_ENVELOPE;
                    break;
                }
            }

            for (i = 0; i < dwNumber; i++)
            {
                if (lpPapers[i] == pPI->wPaper)
                {
                    //
                    //  In tenths of MMs.
                    //
                    *(LPPOINT)&pPI->PtPaperSizeMMs = lpPaperSize[i];
                    break;
                }
            }

            LocalFree(lpPapers);
        }
    }

    //
    //  If the paper size could not be found, use something reasonable
    //  (eg. letter).
    //
    if (!pPI->PtPaperSizeMMs.x)
    {
        pPI->PtPaperSizeMMs.x = 85 * MMS_PER_INCH / 10;
    }
    if (!pPI->PtPaperSizeMMs.y)
    {
        pPI->PtPaperSizeMMs.y = 11 * MMS_PER_INCH;
    }

    //
    //  Rotate envelopes as needed.
    //
    if ( (pPD->Flags & PI_WPAPER_ENVELOPE) &&
         (!pPI->dwRotation) &&
         (pPI->PtPaperSizeMMs.x < pPI->PtPaperSizeMMs.y) )
    {
        lTemp = pPI->PtPaperSizeMMs.x;
        pPI->PtPaperSizeMMs.x = pPI->PtPaperSizeMMs.y;
        pPI->PtPaperSizeMMs.y = lTemp;
    }

    //
    //  Maintain everything in accordance with the orientation
    //  so that apps have to do as little work as possible.
    //
    if (!bPortrait)
    {
        lTemp = pPI->PtPaperSizeMMs.x;
        pPI->PtPaperSizeMMs.x = pPI->PtPaperSizeMMs.y;
        pPI->PtPaperSizeMMs.y = lTemp;
    }

    //
    //  Set up return ptPaperSize value.
    //
    if (pPSD->Flags & PSD_INTHOUSANDTHSOFINCHES)
    {
        pPSD->ptPaperSize.x = pPI->PtPaperSizeMMs.x * 1000 / MMS_PER_INCH;
        pPSD->ptPaperSize.y = pPI->PtPaperSizeMMs.y * 1000 / MMS_PER_INCH;
    }
    else           // PSD_INHUNDREDTHSOFMILLIMETERS
    {
        pPSD->ptPaperSize.x = pPI->PtPaperSizeMMs.x * 10;
        pPSD->ptPaperSize.y = pPI->PtPaperSizeMMs.y * 10;
    }

    //
    //  Update RtMinMarginMMs and rtMinMargin for new papersize/orientation.
    //
    PrintSetMinMargins(hDlg, pPI, pDM);

    //
    //  Don't let margins overlap (page might have shrunk).
    //
    if (pPSD->rtMargin.left + pPSD->rtMargin.right > pPSD->ptPaperSize.x)
    {
        lTemp = (pPD->Flags & PSD_INTHOUSANDTHSOFINCHES) ? 1000 : MMS_PER_INCH;
        pPSD->rtMargin.left  = (pPSD->ptPaperSize.x - lTemp) / 2;
        pPSD->rtMargin.right = (pPSD->ptPaperSize.x - lTemp) / 2;
    }
    if (pPSD->rtMargin.top + pPSD->rtMargin.bottom > pPSD->ptPaperSize.y)
    {
        lTemp = (pPD->Flags & PSD_INTHOUSANDTHSOFINCHES) ? 1000 : MMS_PER_INCH;
        pPSD->rtMargin.top    = (pPSD->ptPaperSize.y - lTemp) / 2;
        pPSD->rtMargin.bottom = (pPSD->ptPaperSize.y - lTemp) / 2;
    }

    //
    //  There are new minimal margins, so adjust rtMargin
    //  (min margins might have grown).
    //
    if (pPSD->rtMargin.left < pPSD->rtMinMargin.left)
        pPSD->rtMargin.left = pPSD->rtMinMargin.left;
    if (pPSD->rtMargin.top < pPSD->rtMinMargin.top)
        pPSD->rtMargin.top = pPSD->rtMinMargin.top;
    if (pPSD->rtMargin.right < pPSD->rtMinMargin.right)
        pPSD->rtMargin.right = pPSD->rtMinMargin.right;
    if (pPSD->rtMargin.bottom < pPSD->rtMinMargin.bottom)
        pPSD->rtMargin.bottom = pPSD->rtMinMargin.bottom;

    //
    //  The margins were adjusted, so update the ui.
    //
    PrintSetMargin(hDlg, pPI, ID_SETUP_E_LEFT, pPSD->rtMargin.left);
    PrintSetMargin(hDlg, pPI, ID_SETUP_E_TOP, pPSD->rtMargin.top);
    PrintSetMargin(hDlg, pPI, ID_SETUP_E_RIGHT, pPSD->rtMargin.right);
    PrintSetMargin(hDlg, pPI, ID_SETUP_E_BOTTOM, pPSD->rtMargin.bottom);

    //
    //  Update the sample window size & shadow.
    //
    if ( (hWndSample = GetDlgItem(hDlg, ID_SETUP_W_SAMPLE)) &&
         (hWndShadowRight = GetDlgItem(hDlg, ID_SETUP_W_SHADOWRIGHT)) &&
         (hWndShadowBottom = GetDlgItem(hDlg, ID_SETUP_W_SHADOWBOTTOM)) )
    {
        int iWidth = pPI->PtPaperSizeMMs.x;
        int iLength = pPI->PtPaperSizeMMs.y;
        int iExtent;
        RECT aRtSampleXYWH = pPI->RtSampleXYWH;
        int iX = aRtSampleXYWH.right  / 16;
        int iY = aRtSampleXYWH.bottom / 16;

        if (iWidth > iLength)
        {
            iExtent = aRtSampleXYWH.bottom * iLength / iWidth;
            aRtSampleXYWH.top += (aRtSampleXYWH.bottom - iExtent) / 2;
            aRtSampleXYWH.bottom = iExtent;
        }
        else
        {
            iExtent = aRtSampleXYWH.right * iWidth / iLength;
            aRtSampleXYWH.left += (aRtSampleXYWH.right - iExtent) / 2;
            aRtSampleXYWH.right = iExtent;
        }

        SetWindowPos( hWndSample,
                      0,
                      aRtSampleXYWH.left,
                      aRtSampleXYWH.top,
                      aRtSampleXYWH.right,
                      aRtSampleXYWH.bottom,
                      SWP_NOZORDER );

        SetWindowPos( hWndShadowRight,
                      0,
                      aRtSampleXYWH.left + aRtSampleXYWH.right,
                      aRtSampleXYWH.top + iY,
                      iX,
                      aRtSampleXYWH.bottom,
                      SWP_NOZORDER );

        SetWindowPos( hWndShadowBottom,
                      0,
                      aRtSampleXYWH.left + iX,
                      aRtSampleXYWH.top + aRtSampleXYWH.bottom,
                      aRtSampleXYWH.right,
                      iY,
                      SWP_NOZORDER );

        InvalidateRect(hWndSample, NULL, TRUE);
        UpdateWindow(hDlg);
        UpdateWindow(hWndSample);
        UpdateWindow(hWndShadowRight);
        UpdateWindow(hWndShadowBottom);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitDuplex
//
//  Enable/Disable Paper Duplexing controls.
//
//  Returns TRUE iff buttons used to be disabled, now enabled.
//  Returns FALSE otherwise.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintInitDuplex(
    HWND hDlg,
    LPDEVMODE pDM)
{
    BOOL bEnable;
    HWND hCtl;


    bEnable = (pDM->dmFields & DM_DUPLEX);

    if (hCtl = GetDlgItem(hDlg, ID_SETUP_G_DUPLEX))
    {
        EnableWindow(hCtl, bEnable);
    }
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_R_NONE))
    {
        EnableWindow(hCtl, bEnable);
    }
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_R_LONG))
    {
        EnableWindow(hCtl, bEnable);
    }
    if (hCtl = GetDlgItem(hDlg, ID_SETUP_R_SHORT))
    {
        EnableWindow(hCtl, bEnable);
    }

    if (hCtl = GetDlgItem(hDlg, ID_SETUP_I_DUPLEX))
    {
        SetWindowLong( hCtl,
                       GWL_STYLE,
                       GetWindowLong(hCtl, GWL_STYLE) | SS_CENTERIMAGE );
        if (!bEnable)
        {
            ShowWindow(hCtl, SW_HIDE);
            SendMessage(hCtl, STM_SETICON, (LONG_PTR)hIconPDuplexNone, 0L);
            ShowWindow(hCtl, SW_SHOW);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintSetDuplex
//
//  This routine will operate on pDocDetails->pDMInput PSDEVMODE structure,
//  making sure that is a structure we know about and can handle.
//
//  If the pd doesn't have DM_DUPLEX caps then just display the appropriate
//  paper icon for DMDUP_SIMPLEX (case where nRad = ID_SETUP_R_NONE).
//
//  If nRad = 0, update icon but don't change radio button.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintSetDuplex(
    HWND hDlg,
    LPDEVMODE pDM,
    UINT nRad)
{
    BOOL bPortrait;
    HANDLE hDuplexIcon;
    HWND hCtl;


    bPortrait = (pDM->dmOrientation == DMORIENT_PORTRAIT);

    if (!(pDM->dmFields & DM_DUPLEX))
    {
        nRad = ID_SETUP_R_NONE;
    }

    //
    //  Boundary checking - default to ID_SETUP_R_NONE.
    //
    if (GetDlgItem(hDlg, ID_SETUP_R_NONE))
    {
        if ((nRad < ID_SETUP_R_NONE) || (nRad > ID_SETUP_R_SHORT))
        {
            if (IsDlgButtonChecked(hDlg, ID_SETUP_R_SHORT))
            {
                nRad = ID_SETUP_R_SHORT;
            }
            else if (IsDlgButtonChecked(hDlg, ID_SETUP_R_LONG))
            {
                nRad = ID_SETUP_R_LONG;
            }
            else
            {
                nRad = ID_SETUP_R_NONE;
            }
        }
        else
        {
            CheckRadioButton(hDlg, ID_SETUP_R_NONE, ID_SETUP_R_SHORT, nRad);
        }
    }

    if (hCtl = GetDlgItem(hDlg, ID_SETUP_I_DUPLEX))
    {
        switch (nRad)
        {
            case ( ID_SETUP_R_LONG ) :      // Long Side - 2 sided printing
            {
                pDM->dmDuplex = DMDUP_VERTICAL;
                hDuplexIcon = bPortrait ? hIconPDuplexNoTumble : hIconLDuplexTumble;

                break;
            }
            case ( ID_SETUP_R_SHORT ) :     // Short Side - 2 sided printing
            {
                pDM->dmDuplex = DMDUP_HORIZONTAL;
                hDuplexIcon = bPortrait ? hIconPDuplexTumble : hIconLDuplexNoTumble;

                break;
            }
            default :                       // None - 2 sided printing
            {
                pDM->dmDuplex = DMDUP_SIMPLEX;
                hDuplexIcon = bPortrait ? hIconPDuplexNone : hIconLDuplexNone;

                break;
            }
        }

        //
        //  Set the appropriate icon.
        //
        ShowWindow(hCtl, SW_HIDE);
        SendMessage(hCtl, STM_SETICON, (LONG_PTR)hDuplexIcon, 0L);
        ShowWindow(hCtl, SW_SHOW);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintInitPaperCombo
//
////////////////////////////////////////////////////////////////////////////

VOID PrintInitPaperCombo(
    PPRINTINFO pPI,
    HWND hCmb,
    HWND hStc,
    PPRINTER_INFO_2 pPrinter,
    LPDEVMODE pDM,
    WORD fwCap1,
    WORD cchSize1,
    WORD fwCap2)
{
    DWORD cStr1, cStr2, cRet1, cRet2, i;
    LPTSTR lpsOut1;
    LPWORD lpwOut2;
    BOOL fFill;


    HourGlass(TRUE);

    SendMessage(hCmb, CB_RESETCONTENT, 0, 0L);

    cStr1 = DeviceCapabilities( pPrinter->pPrinterName,
                                pPrinter->pPortName,
                                fwCap1,
                                NULL,
                                pDM );

    cStr2 = DeviceCapabilities( pPrinter->pPrinterName,
                                pPrinter->pPortName,
                                fwCap2,
                                NULL,
                                pDM );

    //
    //  Check for error from DeviceCapabilities calls.  If either
    //  call failed, simply set cStr1 to be 0 so that the windows will be
    //  disabled and nothing will be initialized.
    //
    if ((cStr1 == (DWORD)(-1)) || (cStr2 == (DWORD)(-1)))
    {
        cStr1 = 0;
    }

    fFill = (cStr1 > 0) && (cStr1 == cStr2);

    if (!((pPI->pPSD) && (pPI->pPSD->Flags & PSD_DISABLEPAPER)))
    {
        //
        //  If no entries, disable hCmb and hStc.
        //
        EnableWindow(hCmb, fFill);
        EnableWindow(hStc, fFill);
    }

    if (fFill)
    {
        lpsOut1 = LocalAlloc(LPTR, cStr1 * cchSize1 * sizeof(TCHAR));

        lpwOut2 = LocalAlloc(LPTR, cStr2 * sizeof(WORD));

        if (lpsOut1 && lpwOut2)
        {
            cRet1 = DeviceCapabilities( pPrinter->pPrinterName,
                                        pPrinter->pPortName,
                                        fwCap1,
                                        (LPTSTR)lpsOut1,
                                        pDM );

            cRet2 = DeviceCapabilities( pPrinter->pPrinterName,
                                        pPrinter->pPortName,
                                        fwCap2,
                                        (LPTSTR)lpwOut2,
                                        pDM );

            if ((pPI->dwRotation =
                    DeviceCapabilities( pPrinter->pPrinterName,
                                        pPrinter->pPortName,
                                        DC_ORIENTATION,
                                        NULL,
                                        pDM )) == (DWORD)(-1))
            {
                pPI->dwRotation = 0;
            }

            if ((cRet1 == cStr1) && (cRet2 == cStr2))
            {
                LPTSTR lpsT1 = lpsOut1;
                LPWORD lpwT2 = lpwOut2;
                int nInd;
                LPTSTR lpFound = NULL;
                LPTSTR lpFirst = NULL;

                for (i = 0; i < cRet1; i++, lpsT1 += cchSize1, lpwT2++)
                {
#ifndef WINNT
                    LPTSTR lpsT3;
                    LPWORD lpwT4;

                    //
                    //  Various checks for HP LaserJet and PostScript
                    //  driver bugs.
                    //
                    //
                    //  Look for duplicate names.
                    //
                    for (lpsT3 = lpsOut1; lpsT3 <= lpsT1; lpsT3 += cchSize1)
                    {
                        if (!lstrcmp(lpsT3, lpsT1))
                        {
                            break;
                        }
                    }
                    if (lpsT3 != lpsT1)
                    {
                        //
                        //  Duplicate found, so ignore.
                        //
                        continue;
                    }

                    //
                    //  Look for duplicate values.
                    //
                    for (lpwT4 = lpwOut2; lpwT4 <= lpwT2; lpwT4++)
                    {
                        if (*lpwT4 == *lpwT2)
                        {
                            break;
                        }
                    }
                    if (lpwT4 != lpwT2)
                    {
                        //
                        //  Duplicate found, so ignore.
                        //
                        continue;
                    }
#endif
                    //
                    //  Look for a blank name entry.
                    //
                    if (!*lpsT1)
                    {
                        //
                        //  Blank entry, so ignore.
                        //
                        continue;
                    }

                    //
                    //  Add the string to the list box.
                    //
                    nInd = (int) SendMessage( hCmb,
                                              CB_ADDSTRING,
                                              0,
                                              (LPARAM)lpsT1 );
                    if (nInd != CB_ERR)
                    {
                        //
                        //  Set the data associated with the string that
                        //  was just added to the list box.
                        //
                        SendMessage( hCmb,
                                     CB_SETITEMDATA,
                                     nInd,
                                     (LPARAM)*lpwT2 );

                        //
                        //  See if this item should be selected.
                        //
                        if (!lpFound)
                        {
                            if (!lpFirst)
                            {
                                lpFirst = lpsT1;
                            }

                            if ( (fwCap1 == DC_PAPERNAMES) &&
                                 (pDM->dmFields & DM_PAPERSIZE) &&
                                 (pDM->dmPaperSize == (SHORT)*lpwT2) )
                            {
                                lpFound = lpsT1;
                            }
                            else if ( (fwCap1 == DC_BINNAMES) &&
                                      (pDM->dmFields & DM_DEFAULTSOURCE) &&
                                      (pDM->dmDefaultSource == (SHORT)*lpwT2) )
                            {
                               lpFound = lpsT1;
                            }
                        }
                    }
                }

                //
                //  Set the appropriate selection.
                //
                if (lpFound)
                {
                    SendMessage( hCmb,
                                 CB_SETCURSEL,
                                 SendMessage( hCmb,
                                              CB_FINDSTRINGEXACT,
                                              (WPARAM)-1,
                                              (LPARAM)lpFound ),
                                 0 );
                }
                else
                {
                    if (fwCap1 == DC_PAPERNAMES)
                    {
                        //
                        //  Check for a default FORM name.
                        //
                        if (!( (pDM->dmFields & DM_FORMNAME) &&
                               ((nInd = (int) 
                                   SendMessage( hCmb,
                                                CB_SELECTSTRING,
                                                (WPARAM)-1,
                                                (LPARAM)pDM->dmFormName )) != CB_ERR) ))
                        {
                            //
                            //  Always select the first *enumerated* entry
                            //  if no other selection was found.
                            //
                            SendMessage( hCmb,
                                         CB_SETCURSEL,
                                         (lpFirst)
                                           ? SendMessage( hCmb,
                                                          CB_FINDSTRINGEXACT,
                                                          (WPARAM)-1,
                                                          (LPARAM)lpFirst )
                                           : 0,
                                         0 );
                        }
                        else
                        {
                            //
                            //  Save the paper size since the form name exists
                            //  in the list box.
                            //
                        //  pDM->dmFields |= DM_PAPERSIZE;
                            pDM->dmPaperSize =
                                (SHORT)SendMessage( hCmb,
                                                    CB_GETITEMDATA,
                                                    nInd,
                                                    0 );
                        }
                    }
                    else
                    {
                        //
                        //  Set the SOURCE to the Default if it exists.
                        //
                        nInd = (int) SendMessage( hCmb,
                                                  CB_SELECTSTRING,
                                                  (WPARAM)-1,
                                                  (LPARAM)szDefaultSrc );
                        if (nInd != CB_ERR)
                        {
                        //  pDM->dmFields |= DM_DEFAULTSOURCE;
                            pDM->dmDefaultSource =
                                (SHORT)SendMessage( hCmb,
                                                    CB_GETITEMDATA,
                                                    nInd,
                                                    0 );
                        }
                        else
                        {
                            //
                            //  Always select the first *enumerated* entry
                            //  if no other selection was found.
                            //
                            SendMessage( hCmb,
                                         CB_SETCURSEL,
                                         (lpFirst)
                                           ? SendMessage( hCmb,
                                                          CB_FINDSTRINGEXACT,
                                                          (WPARAM)-1,
                                                          (LPARAM)lpFirst )
                                           : 0,
                                         0 );
                        }
                    }
                }
            }
        }
        if (lpsOut1)
        {
            LocalFree((HLOCAL)lpsOut1);
        }

        if (lpwOut2)
        {
            LocalFree((HLOCAL)lpwOut2);
        }
    }

    HourGlass(FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintEditError
//
//  Set focus to an edit control and select the entire contents.
//  This is generally used when an improper value was found at OK time.
//
//  Assumes edit control not disabled.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintEditError(
    HWND hDlg,
    int Id,
    UINT MessageId,
    ...)
{
    HWND hEdit;
    TCHAR pszTitle[MAX_PATH];
    TCHAR pszFormat[MAX_PATH];
    TCHAR pszMessage[MAX_PATH];


    //
    //  Put up the error message box.
    //
    if ( GetWindowText(hDlg, pszTitle, MAX_PATH) &&
         LoadString(g_hinst, MessageId, pszFormat, MAX_PATH) )
    {
        va_list ArgList;

        va_start(ArgList, MessageId);
        wvsprintf(pszMessage, pszFormat, ArgList);
        va_end(ArgList);
        MessageBeep(MB_ICONEXCLAMATION);
        MessageBox(hDlg, pszMessage, pszTitle, MB_ICONEXCLAMATION | MB_OK);
    }

    //
    //  Highlight the invalid value.
    //
    if (hEdit = ((Id == 0) ? NULL : GetDlgItem(hDlg, Id)))
    {
        SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)hEdit, 1L);
        SendMessage(hEdit, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintOpenPrinter
//
//  If the OpenPrinter call is successful, this sets hPrinter, pPrinter,
//  cPrinters, and pCurPrinter.
//
////////////////////////////////////////////////////////////////////////////

VOID PrintOpenPrinter(
    PPRINTINFO pPI,
    LPTSTR pPrinterName)
{
    if (OpenPrinter(pPrinterName, &pPI->hCurPrinter, NULL))
    {
        if (pPI->pPrinters = PrintGetPrinterInfo2(pPI->hCurPrinter))
        {
            pPI->cPrinters = 1;

#ifdef UNICODE
            if (pPI->bUseExtDeviceMode)
            {
                PrintGetExtDeviceMode(NULL, pPI);
            }
#endif
        }
        pPI->pCurPrinter = pPI->pPrinters;
    }
    else
    {
        //
        //  Cannot trust the OpenPrinter call.
        //
        pPI->hCurPrinter = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  PrintClosePrinters
//
////////////////////////////////////////////////////////////////////////////

BOOL PrintClosePrinters(
    PPRINTINFO pPI)
{
    if (pPI->hCurPrinter)
    {
        ClosePrinter(pPI->hCurPrinter);
        pPI->hCurPrinter = 0;
    }
    pPI->pCurPrinter = NULL;

    FreePrinterArray(pPI);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateSpoolerInfo
//
////////////////////////////////////////////////////////////////////////////

#ifdef UNICODE

VOID UpdateSpoolerInfo(
    PPRINTINFO pPI)
{
    LPDEVMODEA pDMA;
    CHAR szPrinterNameA[33];
    LPDEVMODEW pDMW;


    //
    //  Get a pointer to the devmode structure.
    //
    pDMW = GlobalLock(pPI->pPD->hDevMode);
    if ((!pDMW) || (!pPI->pCurPrinter))
    {
        return;
    }

    //
    //  Convert the printer name from Unicode to ANSI.
    //
    WideCharToMultiByte( CP_ACP,
                         0,
                         pPI->pCurPrinter->pPrinterName,
                         -1,
                         szPrinterNameA,
                         32,
                         NULL,
                         NULL );

    //
    //  Allocate and convert the Unicode devmode to ANSI.
    //
    pDMA = AllocateAnsiDevMode(pDMW);
    if (!pDMA)
    {
        GlobalUnlock(pPI->pPD->hDevMode);
        return;
    }

    //
    //  Update the spooler's information.
    //
    ExtDeviceMode( NULL,
                   NULL,
                   NULL,
                   szPrinterNameA,
                   NULL,
                   pDMA,
                   NULL,
                   DM_UPDATE | DM_MODIFY );

    //
    //  Free the buffer.
    //
    GlobalFree(pDMA);
    GlobalUnlock(pPI->pPD->hDevMode);
}
#endif


////////////////////////////////////////////////////////////////////////////
//
//  PrintGetPrinterInfo2
//
////////////////////////////////////////////////////////////////////////////

PPRINTER_INFO_2 PrintGetPrinterInfo2(
    HANDLE hPrinter)
{
    PPRINTER_INFO_2 pPrinter = NULL;
    DWORD cbPrinter = 0;


    StoreExtendedError(CDERR_GENERALCODES);

    if (!GetPrinter(hPrinter, 2, NULL, 0, &cbPrinter) &&
        (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
    {
        if (pPrinter = GlobalAlloc(GPTR, cbPrinter))
        {
            if (!GetPrinter( hPrinter,
                             2,
                             (LPBYTE)pPrinter,
                             cbPrinter,
                             &cbPrinter ))
            {
                GlobalFree(pPrinter);
                pPrinter = NULL;
                StoreExtendedError(PDERR_PRINTERNOTFOUND);
            }
        }
        else
        {
            StoreExtendedError(CDERR_MEMALLOCFAILURE);
        }
    }
    else
    {
        StoreExtendedError(PDERR_SETUPFAILURE);
    }

    return (pPrinter);
}


////////////////////////////////////////////////////////////////////////////
//
//  ConvertStringToInteger
//
//  Converts a string to an integer.  Stops at the first non digit.
//
////////////////////////////////////////////////////////////////////////////

int ConvertStringToInteger(
    LPCTSTR pSrc)
{
    int Number = 0;
    BOOL bNeg = FALSE;


    if (*pSrc == TEXT('-'))
    {
        bNeg = TRUE;
        pSrc++;
    }

    while (ISDIGIT(*pSrc))
    {
        Number *= 10;
        Number += *pSrc - TEXT('0');
        pSrc++;
    }

    return ( bNeg ? -Number : Number );
}


////////////////////////////////////////////////////////////////////////////
//
//  FreePrinterArray
//
//  Purpose:    Frees the buffer allocated to store printers.
//
//  Parameters: PPRINTINFO pPI
//
//  Return:     void
//
////////////////////////////////////////////////////////////////////////////

VOID FreePrinterArray(
    PPRINTINFO pPI)
{
    PPRINTER_INFO_2 pPrinters = pPI->pPrinters;
#ifdef UNICODE
    DWORD dwCount;
#endif
    //
    //  If NULL, we can return now.
    //
    if (!pPrinters)
    {
        return;
    }

#ifdef UNICODE
    //
    //  If we made calls to ExtDeviceMode, then we need to
    //  free the buffers allocated for each devmode.
    //
    if (pPI->bUseExtDeviceMode)
    {
        if (pPI->pAllocInfo)
        {
            //
            //  Loop through each of the printers.
            //
            for (dwCount = 0; dwCount < pPI->cPrinters; dwCount++)
            {
                //
                //  If pDevMode exists, free it.
                //
                if ((pPrinters[dwCount].pDevMode) &&
                    (pPI->pAllocInfo[dwCount]))
                {
                    GlobalFree(pPrinters[dwCount].pDevMode);
                    pPrinters[dwCount].pDevMode = NULL;
                }
            }
            GlobalFree(pPI->pAllocInfo);
            pPI->pAllocInfo = NULL;
        }
    }
#endif

    //
    //  Free the entire block.
    //
    GlobalFree(pPI->pPrinters);
    pPI->pPrinters = NULL;
    pPI->cPrinters = 0;
}


////////////////////////////////////////////////////////////////////////////
//
//  TermPrint
//
////////////////////////////////////////////////////////////////////////////

VOID TermPrint(void)
{
#ifdef WINNT
    Print_UnloadLibraries();           // printnew.cpp
#endif
}





/*========================================================================*/
/*                   Page Setup <-> Print Dialog                          */
/*========================================================================*/


////////////////////////////////////////////////////////////////////////////
//
//  TransferPSD2PD
//
////////////////////////////////////////////////////////////////////////////

VOID TransferPSD2PD(
    PPRINTINFO pPI)
{
    if (pPI->pPSD && pPI->pPD)
    {
        pPI->pPD->hDevMode  = pPI->pPSD->hDevMode;
        pPI->pPD->hDevNames = pPI->pPSD->hDevNames;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  TransferPD2PSD
//
////////////////////////////////////////////////////////////////////////////

VOID TransferPD2PSD(
    PPRINTINFO pPI)
{
    if (pPI->pPSD && pPI->pPD)
    {
        pPI->pPSD->hDevMode  = pPI->pPD->hDevMode;
        pPI->pPSD->hDevNames = pPI->pPD->hDevNames;
    }
}


#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  TransferPSD2PDA
//
////////////////////////////////////////////////////////////////////////////

VOID TransferPSD2PDA(
    PPRINTINFO pPI)
{
    if (pPI->pPSD && pPI->pPDA)
    {
        pPI->pPDA->hDevMode  = pPI->pPSD->hDevMode;
        pPI->pPDA->hDevNames = pPI->pPSD->hDevNames;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  TransferPDA2PSD
//
////////////////////////////////////////////////////////////////////////////

VOID TransferPDA2PSD(
    PPRINTINFO pPI)
{
    if (pPI->pPSD && pPI->pPDA)
    {
        pPI->pPSD->hDevMode  = pPI->pPDA->hDevMode;
        pPI->pPSD->hDevNames = pPI->pPDA->hDevNames;
    }
}

#endif





/*========================================================================*/
/*                 Ansi->Unicode Thunk routines                           */
/*========================================================================*/

#ifdef UNICODE

////////////////////////////////////////////////////////////////////////////
//
//  ThunkPageSetupDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL ThunkPageSetupDlg(
    PPRINTINFO pPI,
    LPPAGESETUPDLGA pPSDA)
{
    LPPRINTDLGA pPDA;


    if (!pPSDA)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pPSDA->lStructSize != sizeof(PAGESETUPDLGA))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if ((pPSDA->Flags & PSD_RETURNDEFAULT) &&
        (pPSDA->hDevNames || pPSDA->hDevMode))
    {
        StoreExtendedError(PDERR_RETDEFFAILURE);
        return (FALSE);
    }

    //
    //  Reset the size of the pPSD structure to the UNICODE size and
    //  save it in the pPI structure.
    //
    //  NOTE:  This must be reset back to the ANSI size before
    //         returning to the caller.
    //
    pPSDA->lStructSize = sizeof(PAGESETUPDLGW);
    pPI->pPSD = (LPPAGESETUPDLG)pPSDA;
    pPI->ApiType = COMDLG_ANSI;

    //
    //  Create the ANSI version of the print dialog structure.
    //
    if (pPDA = GlobalAlloc(GPTR, sizeof(PRINTDLGA)))
    {
        pPI->pPDA = pPDA;

        pPDA->lStructSize         = sizeof(PRINTDLGA);
        pPDA->hwndOwner           = pPSDA->hwndOwner;
        pPDA->Flags               = PD_PAGESETUP |
                                      (pPSDA->Flags &
                                        (PSD_NOWARNING |
                                         PSD_SHOWHELP |
                                         PSD_ENABLEPAGESETUPHOOK |
                                         PSD_ENABLEPAGESETUPTEMPLATE |
                                         PSD_ENABLEPAGESETUPTEMPLATEHANDLE |
                                         CD_WX86APP |
                                         PSD_NONETWORKBUTTON));
        pPDA->hInstance           = pPSDA->hInstance;
        pPDA->lCustData           = pPSDA->lCustData;
        pPDA->lpfnSetupHook       = pPSDA->lpfnPageSetupHook;
        pPDA->lpSetupTemplateName = pPSDA->lpPageSetupTemplateName;
        pPDA->hSetupTemplate      = pPSDA->hPageSetupTemplate;

        pPDA->hDevMode            = pPSDA->hDevMode;
        pPDA->hDevNames           = pPSDA->hDevNames;
    }
    else
    {
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
        return (FALSE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeThunkPageSetupDlg
//
////////////////////////////////////////////////////////////////////////////

VOID FreeThunkPageSetupDlg(
    PPRINTINFO pPI)
{
    //
    //  Reset the size of the pPSD structure to the correct value.
    //
    if (pPI->pPSD)
    {
        pPI->pPSD->lStructSize = sizeof(PAGESETUPDLGA);
    }

    //
    //  Free the ANSI print dialog structure.
    //
    if (pPI->pPDA)
    {
        GlobalFree(pPI->pPDA);
        pPI->pPDA = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkPrintDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL ThunkPrintDlg(
    PPRINTINFO pPI,
    LPPRINTDLGA pPDA)
{
    LPPRINTDLGW pPDW;
    LPDEVNAMES pDNA;
    LPDEVMODEA pDMA;
    DWORD cbLen;


    if (!pPDA)
    {
        StoreExtendedError(CDERR_INITIALIZATION);
        return (FALSE);
    }

    if (pPDA->lStructSize != sizeof(PRINTDLGA))
    {
        StoreExtendedError(CDERR_STRUCTSIZE);
        return (FALSE);
    }

    if (!(pPDW = GlobalAlloc(GPTR, sizeof(PRINTDLGW))))
    {
        StoreExtendedError(CDERR_MEMALLOCFAILURE);
        return (FALSE);
    }

    //
    //  IN-only constant stuff.
    //
    pPDW->lStructSize    = sizeof(PRINTDLGW);
    pPDW->hwndOwner      = pPDA->hwndOwner;
    pPDW->hInstance      = pPDA->hInstance;
    pPDW->lpfnPrintHook  = pPDA->lpfnPrintHook;
    pPDW->lpfnSetupHook  = pPDA->lpfnSetupHook;
    pPDW->hPrintTemplate = pPDA->hPrintTemplate;
    pPDW->hSetupTemplate = pPDA->hSetupTemplate;

    //
    //  IN-OUT Variable Structs.
    //
    if ((pPDA->hDevMode) && (pDMA = GlobalLock(pPDA->hDevMode)))
    {
        //
        //  Make sure the device name in the devmode is not too long such that
        //  it has overwritten the other devmode fields.
        //
        if ((pDMA->dmSize < MIN_DEVMODE_SIZEA) ||
            (lstrlenA(pDMA->dmDeviceName) > CCHDEVICENAME))
        {
            pPDW->hDevMode = NULL;
        }
        else
        {
            pPDW->hDevMode = GlobalAlloc( GHND,
                                          sizeof(DEVMODEW) + pDMA->dmDriverExtra );
        }
        GlobalUnlock(pPDA->hDevMode);
    }
    else
    {
        pPDW->hDevMode = NULL;
    }

    if ((pPDA->hDevNames) && (pDNA = GlobalLock(pPDA->hDevNames)))
    {
        cbLen = lstrlenA((LPSTR)pDNA + pDNA->wOutputOffset) + 1 +
                lstrlenA((LPSTR)pDNA + pDNA->wDriverOffset) + 1 +
                lstrlenA((LPSTR)pDNA + pDNA->wDeviceOffset) + 1 +
                DN_PADDINGCHARS;

        cbLen *= sizeof(WCHAR);
        cbLen += sizeof(DEVNAMES);
        pPDW->hDevNames = GlobalAlloc(GHND, cbLen);
        GlobalUnlock(pPDA->hDevNames);
    }
    else
    {
        pPDW->hDevNames = NULL;
    }

    //
    //  IN-only constant strings.
    //
    //  Init Print TemplateName constant.
    //
    if ((pPDA->Flags & PD_ENABLEPRINTTEMPLATE) && (pPDA->lpPrintTemplateName))
    {
        //
        //  See if it's a string or an integer.
        //
        if (!IS_INTRESOURCE(pPDA->lpPrintTemplateName))
        {
            //
            //  String.
            //
            cbLen = lstrlenA(pPDA->lpPrintTemplateName) + 1;
            if (!(pPDW->lpPrintTemplateName =
                     GlobalAlloc( GPTR,
                                  (cbLen * sizeof(WCHAR)) )))
            {
                StoreExtendedError(CDERR_MEMALLOCFAILURE);
                return (FALSE);
            }
            else
            {
                pPI->fPrintTemplateAlloc = TRUE;
                MultiByteToWideChar( CP_ACP,
                                     0,
                                     pPDA->lpPrintTemplateName,
                                     -1,
                                     (LPWSTR)pPDW->lpPrintTemplateName,
                                     cbLen );
            }
        }
        else
        {
            //
            //  Integer.
            //
            (DWORD_PTR)pPDW->lpPrintTemplateName = (DWORD_PTR)pPDA->lpPrintTemplateName;
        }
    }
    else
    {
        pPDW->lpPrintTemplateName = NULL;
    }

    //
    //  Init Print Setup TemplateName constant.
    //
    if ((pPDA->Flags & PD_ENABLESETUPTEMPLATE) && (pPDA->lpSetupTemplateName))
    {
        //
        //  See if it's a string or an integer.
        //
        if (!IS_INTRESOURCE(pPDA->lpSetupTemplateName))
        {
            //
            //  String.
            //
            cbLen = lstrlenA(pPDA->lpSetupTemplateName) + 1;
            if (!(pPDW->lpSetupTemplateName =
                      GlobalAlloc( GPTR,
                                   (cbLen * sizeof(WCHAR)) )))
            {
                StoreExtendedError(CDERR_MEMALLOCFAILURE);
                return (FALSE);
            }
            else
            {
                pPI->fSetupTemplateAlloc = TRUE;
                MultiByteToWideChar( CP_ACP,
                                     0,
                                     pPDA->lpSetupTemplateName,
                                     -1,
                                     (LPWSTR)pPDW->lpSetupTemplateName,
                                     cbLen );
            }
        }
        else
        {
            //
            //  Integer.
            //
            (DWORD_PTR)pPDW->lpSetupTemplateName = (DWORD_PTR)pPDA->lpSetupTemplateName;
        }
    }
    else
    {
        pPDW->lpSetupTemplateName = NULL;
    }

    pPI->pPD = pPDW;
    pPI->pPDA = pPDA;
    pPI->ApiType = COMDLG_ANSI;

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeThunkPrintDlg
//
////////////////////////////////////////////////////////////////////////////

VOID FreeThunkPrintDlg(
    PPRINTINFO pPI)
{
    LPPRINTDLGW pPDW = pPI->pPD;


    if (!pPDW)
    {
        return;
    }

    if (pPDW->hDevNames)
    {
        GlobalFree(pPDW->hDevNames);
    }

    if (pPDW->hDevMode)
    {
        GlobalFree(pPDW->hDevMode);
    }

    if (pPI->fPrintTemplateAlloc)
    {
        GlobalFree((LPWSTR)(pPDW->lpPrintTemplateName));
    }

    if (pPI->fSetupTemplateAlloc)
    {
        GlobalFree((LPWSTR)(pPDW->lpSetupTemplateName));
    }

    GlobalFree(pPDW);
    pPI->pPD = NULL;
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkPrintDlgA2W
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkPrintDlgA2W(
    PPRINTINFO pPI)
{
    LPPRINTDLGW pPDW = pPI->pPD;
    LPPRINTDLGA pPDA = pPI->pPDA;


    //
    //  Copy info A => W
    //
    pPDW->hDC           = pPDA->hDC;
    pPDW->Flags         = pPDA->Flags;
    pPDW->nFromPage     = pPDA->nFromPage;
    pPDW->nToPage       = pPDA->nToPage;
    pPDW->nMinPage      = pPDA->nMinPage;
    pPDW->nMaxPage      = pPDA->nMaxPage;
    pPDW->nCopies       = pPDA->nCopies;
    pPDW->lCustData     = pPDA->lCustData;
    pPDW->lpfnPrintHook = pPDA->lpfnPrintHook;
    pPDW->lpfnSetupHook = pPDA->lpfnSetupHook;

    //
    //  Thunk Device Names A => W
    //
    if (pPDA->hDevNames && pPDW->hDevNames)
    {
        LPDEVNAMES pDNA = GlobalLock(pPDA->hDevNames);
        LPDEVNAMES pDNW = GlobalLock(pPDW->hDevNames);

        ThunkDevNamesA2W(pDNA, pDNW);

        GlobalUnlock(pPDW->hDevNames);
        GlobalUnlock(pPDA->hDevNames);
    }

    //
    //  Thunk Device Mode A => W
    //
    if (pPDA->hDevMode && pPDW->hDevMode)
    {
        LPDEVMODEW pDMW = GlobalLock(pPDW->hDevMode);
        LPDEVMODEA pDMA = GlobalLock(pPDA->hDevMode);

        ThunkDevModeA2W(pDMA, pDMW);

        GlobalUnlock(pPDW->hDevMode);
        GlobalUnlock(pPDA->hDevMode);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkPrintDlgW2A
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkPrintDlgW2A(
    PPRINTINFO pPI)
{
    LPPRINTDLGA pPDA = pPI->pPDA;
    LPPRINTDLGW pPDW = pPI->pPD;
    DWORD cbLen;


    //
    //  Copy info W => A
    //
    pPDA->hDC           = pPDW->hDC;
    pPDA->Flags         = pPDW->Flags;
    pPDA->nFromPage     = pPDW->nFromPage;
    pPDA->nToPage       = pPDW->nToPage;
    pPDA->nMinPage      = pPDW->nMinPage;
    pPDA->nMaxPage      = pPDW->nMaxPage;
    pPDA->nCopies       = pPDW->nCopies;
    pPDA->lCustData     = pPDW->lCustData;
    pPDA->lpfnPrintHook = pPDW->lpfnPrintHook;
    pPDA->lpfnSetupHook = pPDW->lpfnSetupHook;

    //
    //  Thunk Device Names W => A
    //
    if (pPDW->hDevNames)
    {
        LPDEVNAMES pDNW = GlobalLock(pPDW->hDevNames);
        LPDEVNAMES pDNA;

        cbLen = lstrlenW((LPWSTR)pDNW + pDNW->wOutputOffset) + 1 +
                lstrlenW((LPWSTR)pDNW + pDNW->wDriverOffset) + 1 +
                lstrlenW((LPWSTR)pDNW + pDNW->wDeviceOffset) + 1 +
                DN_PADDINGCHARS;
        cbLen += sizeof(DEVNAMES);
        if (pPDA->hDevNames)
        {
            HANDLE handle;
            
            handle = GlobalReAlloc(pPDA->hDevNames, cbLen, GHND);
            //Make sure realloc succeeded.
            if (handle)
            {
                pPDA->hDevNames = handle;
            }
            else
            {
                //Realloc didn't succeed. Free the memory occupied
                GlobalFree(pPDA->hDevNames);
            }
        }
        else
        {
            pPDA->hDevNames = GlobalAlloc(GHND, cbLen);
        }
        if (pPDA->hDevNames)
        {
            pDNA = GlobalLock(pPDA->hDevNames);
            ThunkDevNamesW2A(pDNW, pDNA);
            GlobalUnlock(pPDA->hDevNames);
        }
        GlobalUnlock(pPDW->hDevNames);
    }

    //
    //  Thunk Device Mode W => A
    //
    if (pPDW->hDevMode)
    {
        LPDEVMODEW pDMW = GlobalLock(pPDW->hDevMode);
        LPDEVMODEA pDMA;

        if (pPDA->hDevMode)
        {
            HANDLE  handle;
            handle = GlobalReAlloc( pPDA->hDevMode,
                                            sizeof(DEVMODEA) + pDMW->dmDriverExtra,
                                            GHND );
            //Make sure realloc succeeded.
            if (handle)
            {
                pPDA->hDevMode = handle;
            }
            else
            {
                //Realloc didn't succeed. Free the memory occupied
                GlobalFree(pPDA->hDevMode);
            }

        }
        else
        {
            pPDA->hDevMode = GlobalAlloc( GHND,
                                          sizeof(DEVMODEA) + pDMW->dmDriverExtra );
        }
        if (pPDA->hDevMode)
        {
            pDMA = GlobalLock(pPDA->hDevMode);
            ThunkDevModeW2A(pDMW, pDMA);
            GlobalUnlock(pPDA->hDevMode);
        }
        GlobalUnlock(pPDW->hDevMode);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkDevNamesA2W
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkDevNamesA2W(
    LPDEVNAMES pDNA,
    LPDEVNAMES pDNW)
{
    LPSTR lpTempA;
    LPWSTR lpTempW;

    if (!pDNA || !pDNW)
    {
        return;
    }

    //
    //  Note: Offsets are in CHARS not bytes.
    //
    pDNW->wDriverOffset = sizeof(DEVNAMES) / sizeof(WCHAR);
    lpTempW = (LPWSTR)pDNW + pDNW->wDriverOffset;
    lpTempA = (LPSTR)pDNA + pDNA->wDriverOffset;
    MultiByteToWideChar(CP_ACP, 0, lpTempA, -1, lpTempW, lstrlenA(lpTempA) + 1);

    pDNW->wDeviceOffset = pDNW->wDriverOffset + lstrlenW(lpTempW) + 1;
    lpTempW = (LPWSTR)pDNW + pDNW->wDeviceOffset;
    lpTempA = (LPSTR)pDNA + pDNA->wDeviceOffset;
    MultiByteToWideChar(CP_ACP, 0, lpTempA, -1, lpTempW, lstrlenA(lpTempA) + 1);

    pDNW->wOutputOffset = pDNW->wDeviceOffset + lstrlenW(lpTempW) + 1;
    lpTempW = (LPWSTR)pDNW + pDNW->wOutputOffset;
    lpTempA = (LPSTR)pDNA + pDNA->wOutputOffset;
    MultiByteToWideChar(CP_ACP, 0, lpTempA, -1, lpTempW, lstrlenA(lpTempA) + 1);

    pDNW->wDefault = pDNA->wDefault;
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkDevNamesW2A
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkDevNamesW2A(
    LPDEVNAMES pDNW,
    LPDEVNAMES pDNA)
{
    LPSTR lpTempA;
    LPWSTR lpTempW;

    if (!pDNW || !pDNA)
    {
        return;
    }

    pDNA->wDriverOffset = sizeof(DEVNAMES);
    lpTempW = (LPWSTR)pDNW + pDNW->wDriverOffset;
    lpTempA = (LPSTR)pDNA + pDNA->wDriverOffset;
    WideCharToMultiByte( CP_ACP,
                         0,
                         lpTempW,
                         -1,
                         lpTempA,
                         (lstrlenW(lpTempW) + 1) * 2,   // 2 = DBCS
                         NULL,
                         NULL );

    pDNA->wDeviceOffset = pDNA->wDriverOffset + lstrlenA(lpTempA) + 1;
    lpTempW = (LPWSTR)pDNW + pDNW->wDeviceOffset;
    lpTempA = (LPSTR)pDNA + pDNA->wDeviceOffset;
    WideCharToMultiByte( CP_ACP,
                         0,
                         lpTempW,
                         -1,
                         lpTempA,
                         (lstrlenW(lpTempW) + 1) * 2,   // 2 = DBCS
                         NULL,
                         NULL );

    pDNA->wOutputOffset = pDNA->wDeviceOffset + lstrlenA(lpTempA) + 1;
    lpTempW = (LPWSTR)pDNW + pDNW->wOutputOffset;
    lpTempA = (LPSTR)pDNA + pDNA->wOutputOffset;
    WideCharToMultiByte( CP_ACP,
                         0,
                         lpTempW,
                         -1,
                         lpTempA,
                         (lstrlenW(lpTempW) + 1) * 2,   // 2 = DBCS
                         NULL,
                         NULL );

    pDNA->wDefault = pDNW->wDefault;
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkDevModeA2W
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkDevModeA2W(
    LPDEVMODEA pDMA,
    LPDEVMODEW pDMW)
{
    LPDEVMODEA pDevModeA;

    if (!pDMA || !pDMW)
    {
        return;
    }

    //
    //  Make sure the device name in the devmode is not too long such that
    //  it has overwritten the other devmode fields.
    //
    if ((pDMA->dmSize < MIN_DEVMODE_SIZEA) ||
        (lstrlenA(pDMA->dmDeviceName) > CCHDEVICENAME))
    {
        return;
    }

    //
    //  We need to create a temporary ANSI that is a known size.
    //  The problem is if we are being called from WOW, the WOW
    //  app could be either a Windows 3.1 or 3.0 app.  The size
    //  of the devmode structure was different for both of these
    //  versions compared to the DEVMODE structure in NT.
    //  By copying the ANSI devmode to one we allocate, then we
    //  can access all of the fields (26 currently) without causing
    //  an access violation.
    //
    pDevModeA = GlobalAlloc(GPTR, sizeof(DEVMODEA) + pDMA->dmDriverExtra);
    if (!pDevModeA)
    {
        return;
    }

    CopyMemory( (LPBYTE)pDevModeA,
                (LPBYTE)pDMA,
                min(sizeof(DEVMODEA), pDMA->dmSize) );

    CopyMemory( (LPBYTE)pDevModeA + sizeof(DEVMODEA),
                (LPBYTE)pDMA + pDMA->dmSize,
                pDMA->dmDriverExtra );

    //
    //  Now we can thunk the contents of the ANSI structure to the
    //  Unicode structure.
    //
    MultiByteToWideChar( CP_ACP,
                         0,
                         (LPSTR)pDevModeA->dmDeviceName,
                         -1,
                         (LPWSTR)pDMW->dmDeviceName,
                         CCHDEVICENAME );
    pDMW->dmDeviceName[CCHDEVICENAME - 1] = 0;

    pDMW->dmSpecVersion   = pDevModeA->dmSpecVersion;
    pDMW->dmDriverVersion = pDevModeA->dmDriverVersion;
    pDMW->dmSize          = sizeof(DEVMODEW);
    pDMW->dmDriverExtra   = pDevModeA->dmDriverExtra;
    pDMW->dmFields        = pDevModeA->dmFields;
    pDMW->dmOrientation   = pDevModeA->dmOrientation;
    pDMW->dmPaperSize     = pDevModeA->dmPaperSize;
    pDMW->dmPaperLength   = pDevModeA->dmPaperLength;
    pDMW->dmPaperWidth    = pDevModeA->dmPaperWidth;
    pDMW->dmScale         = pDevModeA->dmScale;
    pDMW->dmCopies        = pDevModeA->dmCopies;
    pDMW->dmDefaultSource = pDevModeA->dmDefaultSource;
    pDMW->dmPrintQuality  = pDevModeA->dmPrintQuality;
    pDMW->dmColor         = pDevModeA->dmColor;
    pDMW->dmDuplex        = pDevModeA->dmDuplex;
    pDMW->dmYResolution   = pDevModeA->dmYResolution;
    pDMW->dmTTOption      = pDevModeA->dmTTOption;
    pDMW->dmCollate       = pDevModeA->dmCollate;

    MultiByteToWideChar( CP_ACP,
                         0,
                         (LPSTR)pDevModeA->dmFormName,
                         -1,
                         (LPWSTR)pDMW->dmFormName,
                         CCHFORMNAME );

    pDMW->dmLogPixels        = pDevModeA->dmLogPixels;
    pDMW->dmBitsPerPel       = pDevModeA->dmBitsPerPel;
    pDMW->dmPelsWidth        = pDevModeA->dmPelsWidth;
    pDMW->dmPelsHeight       = pDevModeA->dmPelsHeight;
    pDMW->dmDisplayFlags     = pDevModeA->dmDisplayFlags;
    pDMW->dmDisplayFrequency = pDevModeA->dmDisplayFrequency;

    pDMW->dmICMMethod        = pDevModeA->dmICMMethod;
    pDMW->dmICMIntent        = pDevModeA->dmICMIntent;
    pDMW->dmMediaType        = pDevModeA->dmMediaType;
    pDMW->dmDitherType       = pDevModeA->dmDitherType;

    pDMW->dmReserved1        = pDevModeA->dmReserved1;
    pDMW->dmReserved2        = pDevModeA->dmReserved2;

    pDMW->dmPanningWidth     = pDevModeA->dmPanningWidth;
    pDMW->dmPanningHeight    = pDevModeA->dmPanningHeight;

    CopyMemory( (pDMW + 1),
                (pDevModeA + 1),
                pDevModeA->dmDriverExtra );

    //
    //  Free the memory we allocated.
    //
    GlobalFree(pDevModeA);
}


////////////////////////////////////////////////////////////////////////////
//
//  ThunkDevModeW2A
//
////////////////////////////////////////////////////////////////////////////

VOID ThunkDevModeW2A(
    LPDEVMODEW pDMW,
    LPDEVMODEA pDMA)
{
    if (!pDMW || !pDMA)
    {
        return;
    }

    WideCharToMultiByte( CP_ACP,
                         0,
                         (LPWSTR)pDMW->dmDeviceName,
                         -1,
                         (LPSTR)pDMA->dmDeviceName,
                         CCHDEVICENAME,
                         NULL,
                         NULL );
    pDMA->dmDeviceName[CCHDEVICENAME - 1] = 0;

    pDMA->dmSpecVersion   = pDMW->dmSpecVersion;
    pDMA->dmDriverVersion = pDMW->dmDriverVersion;
    pDMA->dmSize          = sizeof(DEVMODEA);
    pDMA->dmDriverExtra   = pDMW->dmDriverExtra;
    pDMA->dmFields        = pDMW->dmFields;
    pDMA->dmOrientation   = pDMW->dmOrientation;
    pDMA->dmPaperSize     = pDMW->dmPaperSize;
    pDMA->dmPaperLength   = pDMW->dmPaperLength;
    pDMA->dmPaperWidth    = pDMW->dmPaperWidth;
    pDMA->dmScale         = pDMW->dmScale;
    pDMA->dmCopies        = pDMW->dmCopies;
    pDMA->dmDefaultSource = pDMW->dmDefaultSource;
    pDMA->dmPrintQuality  = pDMW->dmPrintQuality;
    pDMA->dmColor         = pDMW->dmColor;
    pDMA->dmDuplex        = pDMW->dmDuplex;
    pDMA->dmYResolution   = pDMW->dmYResolution;
    pDMA->dmTTOption      = pDMW->dmTTOption;
    pDMA->dmCollate       = pDMW->dmCollate;

    WideCharToMultiByte( CP_ACP,
                         0,
                         (LPWSTR)pDMW->dmFormName,
                         -1,
                         (LPSTR)pDMA->dmFormName,
                         CCHFORMNAME,
                         NULL,
                         NULL );

    pDMA->dmLogPixels        = pDMW->dmLogPixels;
    pDMA->dmBitsPerPel       = pDMW->dmBitsPerPel;
    pDMA->dmPelsWidth        = pDMW->dmPelsWidth;
    pDMA->dmPelsHeight       = pDMW->dmPelsHeight;
    pDMA->dmDisplayFlags     = pDMW->dmDisplayFlags;
    pDMA->dmDisplayFrequency = pDMW->dmDisplayFrequency;

    pDMA->dmICMMethod        = pDMW->dmICMMethod;
    pDMA->dmICMIntent        = pDMW->dmICMIntent;
    pDMA->dmMediaType        = pDMW->dmMediaType;
    pDMA->dmDitherType       = pDMW->dmDitherType;

    pDMA->dmReserved1        = pDMW->dmReserved1;
    pDMA->dmReserved2        = pDMW->dmReserved2;

    pDMA->dmPanningWidth     = pDMW->dmPanningWidth;
    pDMA->dmPanningHeight    = pDMW->dmPanningHeight;

    CopyMemory( (pDMA + 1),
                (pDMW + 1),
                pDMA->dmDriverExtra );
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateUnicodeDevMode
//
//  Purpose:    Allocates a Unicode devmode structure, and calls
//              the thunk function to fill it in.
//
//  Parameters: LPDEVMODEA pANSIDevMode
//
//  Return:     LPDEVMODEW - pointer to new devmode if successful
//                           NULL if not.
//
////////////////////////////////////////////////////////////////////////////

LPDEVMODEW AllocateUnicodeDevMode(
    LPDEVMODEA pANSIDevMode)
{
    int iSize;
    LPDEVMODEW pUnicodeDevMode;

    //
    //  Check for NULL pointer.
    //
    if (!pANSIDevMode)
    {
        return (NULL);
    }

    //
    //  Determine output structure size.  This has two components:  the
    //  DEVMODEW structure size,  plus any private data area.  The latter
    //  is only meaningful when a structure is passed in.
    //
    iSize = sizeof(DEVMODEW);

    iSize += pANSIDevMode->dmDriverExtra;

    pUnicodeDevMode = GlobalAlloc(GPTR, iSize);

    if (!pUnicodeDevMode)
    {
        return (NULL);
    }

    //
    //  Now call the thunk routine to copy the ANSI devmode to the
    //  Unicode devmode.
    //
    ThunkDevModeA2W(pANSIDevMode, pUnicodeDevMode);

    //
    //  Return the pointer.
    //
    return (pUnicodeDevMode);
}


////////////////////////////////////////////////////////////////////////////
//
//  AllocateAnsiDevMode
//
//  Purpose:    Allocates a Ansi devmode structure, and calls
//              the thunk function to fill it in.
//
//  Parameters: LPDEVMODEW pUnicodeDevMode
//
//  Return:     LPDEVMODEA - pointer to new devmode if successful
//                           NULL if not.
//
////////////////////////////////////////////////////////////////////////////

LPDEVMODEA AllocateAnsiDevMode(
    LPDEVMODEW pUnicodeDevMode)
{
    int iSize;
    LPDEVMODEA pANSIDevMode;

    //
    //  Check for NULL pointer.
    //
    if (!pUnicodeDevMode)
    {
        return (NULL);
    }

    //
    //  Determine output structure size.  This has two components:  the
    //  DEVMODEW structure size,  plus any private data area.  The latter
    //  is only meaningful when a structure is passed in.
    //
    iSize = sizeof(DEVMODEA);

    iSize += pUnicodeDevMode->dmDriverExtra;

    pANSIDevMode = GlobalAlloc(GPTR, iSize);

    if (!pANSIDevMode)
    {
        return (NULL);
    }

    //
    //  Now call the thunk routine to copy the Unicode devmode to the
    //  ANSI devmode.
    //
    ThunkDevModeW2A(pUnicodeDevMode, pANSIDevMode);

    //
    //  Return the pointer.
    //
    return (pANSIDevMode);
}


#ifdef WINNT

////////////////////////////////////////////////////////////////////////////
//
//  Ssync_ANSI_UNICODE_PD_For_WOW
//
//  Function to allow NT WOW to keep the ANSI & UNICODE versions of
//  the CHOOSEFONT structure in ssync as required by many 16-bit apps.
//  See notes for Ssync_ANSI_UNICODE_Struct_For_WOW() in dlgs.c.
//
////////////////////////////////////////////////////////////////////////////

VOID Ssync_ANSI_UNICODE_PD_For_WOW(
    HWND hDlg,
    BOOL f_ANSI_to_UNICODE)
{
    PPRINTINFO pPI;

    if (pPI = (PPRINTINFO)GetProp(hDlg, PRNPROP))
    {
        if (pPI->pPD && pPI->pPDA)
        {
            if (f_ANSI_to_UNICODE)
            {
                ThunkPrintDlgA2W(pPI);
            }
            else
            {
                ThunkPrintDlgW2A(pPI);
            }
        }
    }
}

#endif

#endif

////////////////////////////////////////////////////////////////////////////
//
//  SetCopiesEditWidth
//
// Adjust the width of the copies edit control using the current
// font and the scroll bar width.  This is necessary to handle the 
// the up down control from encroching on the space in the edit
// control when we are in High Contrast (extra large) mode.
//
////////////////////////////////////////////////////////////////////////////

VOID SetCopiesEditWidth(
    HWND hDlg,
    HWND hControl)
{
    HDC hDC                 = NULL;
    LONG MaxDigitExtant     = 0;
    LONG EditControlWidth   = 0;
    LONG CurrentWidth       = 0;
    UINT i                  = 0;
    INT aDigitWidth[10];
    WINDOWPLACEMENT WndPl;

    //
    // Acquire the edit controls device context.
    //
    hDC = GetDC( hControl );

    if (hDC)
    {
        //
        // Determine max width of the digit group.
        //
        if (GetCharWidth32( hDC, TEXT('0'), TEXT('9'), aDigitWidth))
        {
            for (i = 0; i < ARRAYSIZE(aDigitWidth); i++)
            {
                if (aDigitWidth[i] > MaxDigitExtant)
                {
                    MaxDigitExtant = aDigitWidth[i];
                }
            }

            //
            // Get the edit control placement.
            //
            WndPl.length = sizeof( WndPl );

            if (GetWindowPlacement( hControl, &WndPl ))
            {
                //
                // Calculate the edit control current width.
                //
                EditControlWidth = MaxDigitExtant * COPIES_EDIT_SIZE;

                //
                // Calculate the current width of the edit control.
                //
                CurrentWidth = WndPl.rcNormalPosition.right - WndPl.rcNormalPosition.left;
                
                //
                // Set the new position of the edit control.
                //                
                WndPl.rcNormalPosition.left = WndPl.rcNormalPosition.left - (EditControlWidth - CurrentWidth);

                //
                // Place the control.
                //
                SetWindowPlacement( hControl, &WndPl );
            }
        }

        //
        // Release the device context.
        //
        ReleaseDC( hControl, hDC );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\srccpp.inc ===
!include ..\..\comdlg32mm\comdlg32.inc

NO_BROWSER_FILE = 1

SOURCES_USED = $(SOURCES_USED) ..\..\comdlg32mm\comdlg32.inc

TARGETNAME = srccpp
TARGETPATH = obj
TARGETTYPE = LIBRARY

SOURCES    = ..\filemru.cpp  \
             ..\filenew.cpp   \
             ..\printnew.cpp  \
             ..\tlog.cpp      \
             ..\util.cpp

# PRECOMPILED_CXX = 1
# PRECOMPILED_INCLUDE = ..\pch.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\prnsetup.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    prnsetup.h

Abstract:

    This module contains the header information for the Win32 print dialogs.

Revision History:

--*/



//
//  Include Files.
//

#include <help.h>




//
//  Constant Declarations.
//

#ifndef WINNT
  #define COMDLG_ANSI     0x0
  #define COMDLG_WIDE     0x1
#endif

#define PI_PRINTERS_ENUMERATED    0x00000001
#define PI_COLLATE_REQUESTED      0x00000002
#define PI_WPAPER_ENVELOPE        0x00000004     // wPaper is DMPAPER_ENV_x
#define PI_PRINTDLGX_RECURSE      0x00000008     // PrintDlgX calls PrintDlgX

#define PRNPROP (LPCTSTR)         0xA000L

#define DN_PADDINGCHARS           16             // extra devnames padding

#define MMS_PER_INCH              254            // 25.4 mms/inch

#define INCHES_DEFAULT            1000
#define MMS_DEFAULT               2500

#define COPIES_EDIT_SIZE          4
#define PAGE_EDIT_SIZE            5
#define MARGIN_EDIT_SIZE          6

#define CCHPAPERNAME              64
#define CCHBINNAME                24

#define ROTATE_LEFT               270            // dot-matrix
#define ROTATE_RIGHT              90             // HP PCL

#define MAX_DEV_SECT              512
#define BACKSPACE                 0x08
#define CTRL_X_CUT                0x18
#define CTRL_C_COPY               0x03
#define CTRL_V_PASTE              0x16

#define SIZEOF_DEVICE_INFO        32

#define MAX_PRINTERNAME           (MAX_PATH * 2)

#define SCRATCHBUF_SIZE           256

#define MIN_DEVMODE_SIZEA         40             // from spooler\inc\splcom.h



//
//  Constant Declarations for DLG file.
//

#define ID_BOTH_P_PROPERTIES      psh2
#define ID_BOTH_P_NETWORK         psh14
#define ID_BOTH_P_HELP            pshHelp
#define ID_BOTH_S_PRINTER         stc6
#define ID_BOTH_S_STATUS          stc12
#define ID_BOTH_S_TYPE            stc11
#define ID_BOTH_S_WHERE           stc14
#define ID_BOTH_S_COMMENT         stc13

#define ID_PRINT_X_TOFILE         chx1
#define ID_PRINT_X_COLLATE        chx2
#define ID_PRINT_C_QUALITY        cmb1
#define ID_PRINT_C_NAME           cmb4
#define ID_PRINT_E_FROM           edt1
#define ID_PRINT_E_TO             edt2
#define ID_PRINT_E_COPIES         edt3
#define ID_PRINT_G_RANGE          grp1
#define ID_PRINT_G_COPIES         grp2
#define ID_PRINT_G_PRINTER        grp4
#define ID_PRINT_I_COLLATE        ico3
#define ID_PRINT_P_SETUP          psh1
#define ID_PRINT_R_ALL            rad1
#define ID_PRINT_R_SELECTION      rad2
#define ID_PRINT_R_PAGES          rad3
#define ID_PRINT_S_DEFAULT        stc1
#define ID_PRINT_S_FROM           stc2
#define ID_PRINT_S_TO             stc3
#define ID_PRINT_S_QUALITY        stc4
#define ID_PRINT_S_COPIES         stc5

#define ID_SETUP_C_NAME           cmb1
#define ID_SETUP_C_SIZE           cmb2
#define ID_SETUP_C_SOURCE         cmb3
#define ID_SETUP_E_LEFT           edt4
#define ID_SETUP_E_TOP            edt5
#define ID_SETUP_E_RIGHT          edt6
#define ID_SETUP_E_BOTTOM         edt7
#define ID_SETUP_G_ORIENTATION    grp1
#define ID_SETUP_G_PAPER          grp2
#define ID_SETUP_G_DUPLEX         grp3
#define ID_SETUP_G_MARGINS        grp4
#define ID_SETUP_I_ORIENTATION    ico1
#define ID_SETUP_I_DUPLEX         ico2
#define ID_SETUP_P_MORE           psh1
#define ID_SETUP_P_PRINTER        psh3
#define ID_SETUP_R_PORTRAIT       rad1
#define ID_SETUP_R_LANDSCAPE      rad2
#define ID_SETUP_R_DEFAULT        rad3
#define ID_SETUP_R_SPECIFIC       rad4
#define ID_SETUP_R_NONE           rad5
#define ID_SETUP_R_LONG           rad6
#define ID_SETUP_R_SHORT          rad7
#define ID_SETUP_S_DEFAULT        stc1
#define ID_SETUP_S_SIZE           stc2
#define ID_SETUP_S_SOURCE         stc3
#define ID_SETUP_S_LEFT           stc15
#define ID_SETUP_S_RIGHT          stc16
#define ID_SETUP_S_TOP            stc17
#define ID_SETUP_S_BOTTOM         stc18
#define ID_SETUP_W_SAMPLE         rct1
#define ID_SETUP_W_SHADOWRIGHT    rct2
#define ID_SETUP_W_SHADOWBOTTOM   rct3




//
//  Typedef Declarations.
//

typedef struct {
    UINT            ApiType;
    LPPRINTDLG      pPD;
    LPPAGESETUPDLG  pPSD;
    DWORD           cPrinters;
    PPRINTER_INFO_2 pPrinters;
    PPRINTER_INFO_2 pCurPrinter;
    HANDLE          hCurPrinter;
    DWORD           Status;
    TCHAR           szDefaultPrinter[MAX_PRINTERNAME];
    WORD            wPaper;
    DWORD           dwRotation;
    UINT            uiOrientationID;
    POINT           PtPaperSizeMMs;
    RECT            RtMinMarginMMs;
    RECT            RtMarginMMs;
    POINT           PtMargins;
    RECT            RtSampleXYWH;
    BOOL            bKillFocus;
    DWORD           ProcessVersion;
#ifdef UNICODE
    LPPRINTDLGA     pPDA;
    LPBOOL          pAllocInfo;
    BOOL            bUseExtDeviceMode;
    BOOL            fPrintTemplateAlloc;
    BOOL            fSetupTemplateAlloc;
    UINT            NestCtr;
#endif
} PRINTINFO, *PPRINTINFO;




//
//  Global Variables.
//

#ifndef WINNT
  UINT msgHELPA;
#endif


#ifndef WINNT
  typedef DWORD (WINAPI *LPFNWNETCONNECTIONDIALOG)(HWND, DWORD);
  LPFNWNETCONNECTIONDIALOG MPR_WNetConnectionDialog = NULL;
  CHAR szWNetConnectionDialog[] = "WNetConnectionDialog";
#endif


static TCHAR  szTextWindows[]     = TEXT("Windows");
static TCHAR  szTextDevices[]     = TEXT("devices");
static TCHAR  szTextDevice[]      = TEXT("device");
static TCHAR  szTextNull[]        = TEXT("");
static TCHAR  szFilePort[]        = TEXT("FILE:");
static TCHAR  szDriver[]          = TEXT("winspool");

#ifndef WINNT
  static TCHAR  szCommdlgHelp[]   = HELPMSGSTRING;
#endif


LPPRINTHOOKPROC glpfnPrintHook = NULL;
LPSETUPHOOKPROC glpfnSetupHook = NULL;

#ifdef WINNT
  WNDPROC lpEditNumOnlyProc = NULL;
#endif
WNDPROC lpEditMarginProc = NULL;
WNDPROC lpStaticProc = NULL;

HKEY hPrinterKey;
TCHAR *szRegistryPrinter = TEXT("Printers");
TCHAR *szRegistryDefaultValueName = TEXT("Default");

#ifndef WINNT
  HANDLE hMPR = NULL;
  TCHAR szMprDll[] = TEXT("mpr.dll");
#endif


static BOOL   bAllIconsLoaded = FALSE;         // if all icons/images loaded

static HANDLE hIconCollate = NULL;             // Image
static HANDLE hIconNoCollate = NULL;           // Image

static HICON  hIconPortrait = NULL;            // Icon
static HICON  hIconLandscape = NULL;           // Icon
static HICON  hIconPDuplexNone = NULL;         // Icon
static HICON  hIconLDuplexNone = NULL;         // Icon
static HICON  hIconPDuplexTumble = NULL;       // Icon
static HICON  hIconLDuplexTumble = NULL;       // Icon
static HICON  hIconPDuplexNoTumble = NULL;     // Icon
static HICON  hIconLDuplexNoTumble = NULL;     // Icon
static HICON  hIconPSStampP = NULL;            // Icon
static HICON  hIconPSStampL = NULL;            // Icon


static TCHAR  cIntlDecimal = CHAR_NULL;        // decimal separator (.)
static TCHAR  cIntlMeasure[5] = TEXT("");      // measurement designator ("/mm)
static int    cchIntlMeasure = 0;              // # of chars in cIntlMeasure
static TCHAR  szDefaultSrc[SCRATCHBUF_SIZE] = TEXT("");




//
//  Context Help IDs.
//

const static DWORD aPrintHelpIDs[] =             // Context Help IDs
{
    // for Print dialog

    grp4,  NO_HELP,
    stc6,  IDH_PRINT_CHOOSE_PRINTER,
    cmb4,  IDH_PRINT_CHOOSE_PRINTER,

    psh2,  IDH_PRINT_PROPERTIES,

    stc8,  IDH_PRINT_SETUP_DETAILS,
    stc12, IDH_PRINT_SETUP_DETAILS,
    stc7,  IDH_PRINT_SETUP_DETAILS,
    stc11, IDH_PRINT_SETUP_DETAILS,
    stc10, IDH_PRINT_SETUP_DETAILS,
    stc14, IDH_PRINT_SETUP_DETAILS,
    stc9,  IDH_PRINT_SETUP_DETAILS,
    stc13, IDH_PRINT_SETUP_DETAILS,

    chx1,  IDH_PRINT_TO_FILE,

    grp1,  NO_HELP,
    ico1,  IDH_PRINT32_RANGE,
    rad1,  IDH_PRINT32_RANGE,
    rad2,  IDH_PRINT32_RANGE,
    rad3,  IDH_PRINT32_RANGE,
    stc2,  IDH_PRINT32_RANGE,
    edt1,  IDH_PRINT32_RANGE,
    stc3,  IDH_PRINT32_RANGE,
    edt2,  IDH_PRINT32_RANGE,

    grp2,  NO_HELP,
    edt3,  IDH_PRINT_COPIES,
    ico3,  IDH_PRINT_COLLATE,
    chx2,  IDH_PRINT_COLLATE,

    // for win3.1 Print template

    stc1,  IDH_PRINT_SETUP_DETAILS,

    stc4,  IDH_PRINT_QUALITY,
    cmb1,  IDH_PRINT_QUALITY,

    stc5,  IDH_PRINT_COPIES,

    psh1,  IDH_PRINT_PRINTER_SETUP,
    psh14, IDH_PRINT_NETWORK,
    pshHelp, IDH_HELP,

    0,     0
};

const static DWORD aPrintSetupHelpIDs[] =        // Context Help IDs
{
    // for PrintSetup dialog

    grp4,  NO_HELP,
    stc6,  IDH_PRINT_CHOOSE_PRINTER,
    cmb1,  IDH_PRINT_CHOOSE_PRINTER,

    psh2,  IDH_PRINT_PROPERTIES,

    stc8,  IDH_PRINT_SETUP_DETAILS,
    stc12, IDH_PRINT_SETUP_DETAILS,
    stc7,  IDH_PRINT_SETUP_DETAILS,
    stc11, IDH_PRINT_SETUP_DETAILS,
    stc10, IDH_PRINT_SETUP_DETAILS,
    stc14, IDH_PRINT_SETUP_DETAILS,
    stc9,  IDH_PRINT_SETUP_DETAILS,
    stc13, IDH_PRINT_SETUP_DETAILS,

    grp2,  NO_HELP,
    stc2,  IDH_PAGE_PAPER_SIZE,
    cmb2,  IDH_PAGE_PAPER_SIZE,
    stc3,  IDH_PAGE_PAPER_SOURCE,
    cmb3,  IDH_PAGE_PAPER_SOURCE,

    grp1,  NO_HELP,
    ico1,  IDH_PRINT_SETUP_ORIENT,
    rad1,  IDH_PRINT_SETUP_ORIENT,
    rad2,  IDH_PRINT_SETUP_ORIENT,

    // for win3.1 PrintSetup template

    grp3,  NO_HELP,
    stc1,  IDH_PRINT_CHOOSE_PRINTER,
    rad3,  IDH_PRINT_CHOOSE_PRINTER,
    rad4,  IDH_PRINT_CHOOSE_PRINTER,
    cmb1,  IDH_PRINT_CHOOSE_PRINTER,

    psh1,  IDH_PRINT_PROPERTIES,
    psh14, IDH_PRINT_NETWORK,
    pshHelp, IDH_HELP,

    // for winNT PrintSetup template

    grp2,  NO_HELP,                              // grp2 used for win31 help
    ico2,  IDH_PRINT_SETUP_DUPLEX,
    rad5,  IDH_PRINT_SETUP_DUPLEX,
    rad6,  IDH_PRINT_SETUP_DUPLEX,
    rad7,  IDH_PRINT_SETUP_DUPLEX,

    0,     0
};

const static DWORD aPageSetupHelpIDs[] =         // Context Help IDs
{
    rct1,  IDH_PAGE_SAMPLE,
    rct2,  IDH_PAGE_SAMPLE,
    rct3,  IDH_PAGE_SAMPLE,

    grp2,  NO_HELP,
    stc2,  IDH_PAGE_PAPER_SIZE,
    cmb2,  IDH_PAGE_PAPER_SIZE,
    stc3,  IDH_PAGE_PAPER_SOURCE,
    cmb3,  IDH_PAGE_PAPER_SOURCE,

    grp1,  NO_HELP,
    rad1,  IDH_PAGE_ORIENTATION,
    rad2,  IDH_PAGE_ORIENTATION,

    grp4,  NO_HELP,
    stc15, IDH_PAGE_MARGINS,
    edt4,  IDH_PAGE_MARGINS,
    stc16, IDH_PAGE_MARGINS,
    edt6,  IDH_PAGE_MARGINS,
    stc17, IDH_PAGE_MARGINS,
    edt5,  IDH_PAGE_MARGINS,
    stc18, IDH_PAGE_MARGINS,
    edt7,  IDH_PAGE_MARGINS,

    psh3,  IDH_PAGE_PRINTER,

    psh14, IDH_PRINT_NETWORK,
    pshHelp, IDH_HELP,

    0, 0
};




//
//  Macro Definitions.
//

#define IS_KEY_PRESSED(key)       ( GetKeyState(key) & 0x8000 )

#define ISDIGIT(c)                ((c) >= TEXT('0') && (c) <= TEXT('9'))

//
//  SetField is used to modify new-for-ver-4.0 DEVMODE fields.
//  We don't have to worry about the GET case, because we always check for
//  the existance-of-field bit before looking at the field.
//
#define SetField(_pdm, _fld, _val)     \
        ((_pdm)->dmSpecVersion >= 0x0400 ? (((_pdm)->_fld = (_val)), TRUE) : FALSE)




#ifdef __cplusplus
extern "C" {
#endif



//
//  Function Prototypes.
//

BOOL
PrintDlgX(
    PPRINTINFO pPI);

BOOL
PageSetupDlgX(
    PPRINTINFO pPI);

BOOL
PrintLoadIcons();

int
PrintDisplayPrintDlg(
    PPRINTINFO pPI);

int
PrintDisplaySetupDlg(
    PPRINTINFO pPI);

BOOL_PTR CALLBACK
PrintDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam);

BOOL_PTR CALLBACK
PrintSetupDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam);

LRESULT
PrintEditNumberOnlyProc(
    HWND hWnd,
    UINT msg,
    WPARAM wP,
    LPARAM lP);

LRESULT
PrintEditMarginProc(
    HWND hWnd,
    UINT msg,
    WPARAM wP,
    LPARAM lP);

LRESULT
PrintPageSetupPaintProc(
    HWND hWnd,
    UINT msg,
    WPARAM wP,
    LPARAM lP);

HANDLE
PrintLoadResource(
    HANDLE hInst,
    LPTSTR pResName,
    LPTSTR pType);

VOID
PrintGetDefaultPrinterName(
    LPTSTR pDefaultPrinter,
    UINT cchSize);

BOOL
PrintReturnDefault(
    PPRINTINFO pPI);

BOOL
PrintInitGeneral(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI);

DWORD
PrintInitPrintDlg(
    HWND hDlg,
    WPARAM wParam,
    PPRINTINFO pPI);

DWORD
PrintInitSetupDlg(
    HWND hDlg,
    WPARAM wParam,
    PPRINTINFO pPI);

VOID
PrintUpdateSetupDlg(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM,
    BOOL fResetContent);

BOOL
PrintSetCopies(
    HWND hDlg,
    PPRINTINFO pPI,
    UINT Id);

VOID
PrintSetMinMargins(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM);

VOID
PrintSetupMargins(
    HWND hDlg,
    PPRINTINFO pPI);

VOID
PrintSetMargin(
    HWND hDlg,
    PPRINTINFO pPI,
    UINT Id,
    LONG lValue);

VOID
PrintGetMargin(
    HWND hEdt,
    PPRINTINFO pPI,
    LONG lMin,
    LONG *plMargin,
    LONG *plSample);

BOOL
PrintInitBannerAndQuality(
    HWND hDlg,
    PPRINTINFO pPI,
    LPPRINTDLG pPD);

BOOL
PrintCreateBanner(
    HWND hDlg,
    LPDEVNAMES pDN,
    LPTSTR psBanner,
    UINT cchBanner);

VOID
PrintInitQuality(
    HANDLE hCmb,
    LPPRINTDLG pPD,
    SHORT nQuality);

VOID
PrintChangeProperties(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI);

VOID
PrintPrinterChanged(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI);

VOID
PrintCancelPrinterChanged(
    PPRINTINFO pPI,
    LPTSTR pPrinterName);

VOID
PrintUpdateStatus(
    HWND hDlg,
    PPRINTINFO pPI);

BOOL
PrintGetSetupInfo(
    HWND hDlg,
    LPPRINTDLG pPD);

PPRINTER_INFO_2
PrintSearchForPrinter(
    PPRINTINFO pPI,
    LPCTSTR lpsPrinterName);

#ifdef UNICODE
  VOID
  PrintGetExtDeviceMode(
      HWND hDlg,
      PPRINTINFO pPI);
#endif

BOOL
PrintEnumAndSelect(
    HWND hDlg,
    UINT Id,
    PPRINTINFO pPI,
    LPTSTR lpsPrinterToSelect,
    BOOL bEnumPrinters);

VOID
PrintBuildDevNames(
    PPRINTINFO pPI);

HANDLE
PrintGetDevMode(
    HWND hDlg,
    HANDLE hPrinter,
    LPTSTR lpsDeviceName,
    HANDLE hDevMode);

VOID
PrintReturnICDC(
    LPPRINTDLG pPD,
    LPDEVNAMES pDN,
    LPDEVMODE pDM);

VOID
PrintMeasureItem(
    HANDLE hDlg,
    LPMEASUREITEMSTRUCT mis);

VOID
PrintInitOrientation(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM);

VOID
PrintSetOrientation(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM,
    UINT uiOldId,
    UINT uiNewId);

VOID
PrintUpdatePageSetup(
    HWND hDlg,
    PPRINTINFO pPI,
    LPDEVMODE pDM,
    UINT uiOldId,
    UINT uiNewId);

VOID
PrintInitDuplex(
    HWND hDlg,
    LPDEVMODE pDM);

VOID
PrintSetDuplex(
    HWND hDlg,
    LPDEVMODE pDM,
    UINT nRad);

VOID
PrintInitPaperCombo(
    PPRINTINFO pPI,
    HWND hCmb,
    HWND hStc,
    PPRINTER_INFO_2 pPrinter,
    LPDEVMODE pDM,
    WORD fwCap1,
    WORD cchSize1,
    WORD fwCap2);

VOID
PrintEditError(
    HWND hDlg,
    int Id,
    UINT MessageId,
    ...);

VOID
PrintOpenPrinter(
    PPRINTINFO pPI,
    LPTSTR pPrinterName);

BOOL
PrintClosePrinters(
    PPRINTINFO pPI);

VOID SetCopiesEditWidth(
    HWND hDlg,
    HWND hControl);

#ifdef UNICODE
  VOID
  UpdateSpoolerInfo(
      PPRINTINFO pPI);
#endif

PPRINTER_INFO_2
PrintGetPrinterInfo2(
    HANDLE hPrinter);

int
ConvertStringToInteger(
    LPCTSTR pSrc);

VOID
FreePrinterArray(
    PPRINTINFO pPI);

VOID
TermPrint(void);

VOID
TransferPSD2PD(
    PPRINTINFO pPI);

VOID
TransferPD2PSD(
    PPRINTINFO pPI);

#ifdef UNICODE
  VOID
  TransferPSD2PDA(
      PPRINTINFO pPI);

  VOID
  TransferPDA2PSD(
      PPRINTINFO pPI);

  BOOL
  ThunkPageSetupDlg(
      PPRINTINFO pPI,
      LPPAGESETUPDLGA pPSDA);

  VOID
  FreeThunkPageSetupDlg(
      PPRINTINFO pPI);

  BOOL
  ThunkPrintDlg(
      PPRINTINFO pPI,
      LPPRINTDLGA pPDA);

  VOID
  FreeThunkPrintDlg(
      PPRINTINFO pPI);

  VOID
  ThunkPrintDlgA2W(
      PPRINTINFO pPI);

  VOID
  ThunkPrintDlgW2A(
      PPRINTINFO pPI);

  VOID
  ThunkDevNamesA2W(
      LPDEVNAMES pDNA,
      LPDEVNAMES pDNW);

  VOID
  ThunkDevNamesW2A(
      LPDEVNAMES pDNW,
      LPDEVNAMES pDNA);

  VOID
  ThunkDevModeA2W(
      LPDEVMODEA pDMA,
      LPDEVMODEW pDMW);

  VOID
  ThunkDevModeW2A(
      LPDEVMODEW pDMW,
      LPDEVMODEA pDMA);

  LPDEVMODEW
  AllocateUnicodeDevMode(
      LPDEVMODEA pANSIDevMode);

  LPDEVMODEA
  AllocateAnsiDevMode(
      LPDEVMODEW pUnicodeDevMode);
#endif


#ifdef __cplusplus
};  // extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\sources.inc ===
CCSHELL_DIR = \nt\private\shell

!include $(CCSHELL_DIR)\common.inc

NO_BROWSER_FILE = 1

INCLUDES = ..\..\comdlg32mm;$(INCLUDES);$(SHELL_INC_PATH)

SOURCES_USED = $(SOURCES_USED) ..\..\comdlg32mm\comdlg32.inc $(CCSHELL_DIR)\common.inc

TARGETNAME    = comdlg32mm

TARGETPATHLIB = ..\..\obj
TARGETPATH    = ..\..\obj
TARGETTYPE    = DYNLINK

TARGETLIBS = $(SDK_LIB_PATH)\shlwapip.lib     \
             $(LIBRARY_PLATFORM_PATH)\*\kernel32.lib      \
             $(SDK_LIB_PATH)\user32.lib        \
             $(SDK_LIB_PATH)\gdi32.lib         \
             $(LIBRARY_PLATFORM_PATH)\*\advapi32.lib      \
             $(LIBRARY_PLATFORM_PATH)\*\comctlp.lib       \
             $(LIBRARY_PLATFORM_PATH)\*\shell32p.lib      \
             $(LIBRARY_PLATFORM_PATH)\*\shell32.lib       \
             $(LIBRARY_PLATFORM_PATH)\*\winspool.lib      \
             $(LIBRARY_PLATFORM_PATH)\*\uuid.lib          \
             $(CCSHELL_DIR)\lib\$O\shguidp.lib            \
             $(CCSHELL_DIR)\lib\$O\stocklib.lib

# ccover needs to link to C run-time lib, so we need to add msvcrt.lib to the link list
!ifdef CCOVER
TARGETLIBS = $(TARGETLIBS) $(LIBRARY_PLATFORM_PATH)\*\msvcrt.lib
!endif

!if defined(TARGET_WIN95)
LINKLIBS = ..\w95cpp\$O\srccpp.lib
!else
LINKLIBS = ..\ntcpp\$O\srccpp.lib
!endif

DLLDEF   = $(O)\comdlg32.def

# ccover needs C run time, thus we need to rename LibMain to DllMain
!ifdef CCOVER
DLLENTRY = DllMain
!else
DLLENTRY = LibMain
!endif
DELAYLOAD = winspool.drv

SOURCES = ..\comdlg32.rc  \
          ..\color.c      \
          ..\color2.c     \
          ..\data.c       \
          ..\dlgs.c       \
          ..\dllload.c    \
          ..\fileopen.c   \
          ..\find.c       \
          ..\font.c       \
          ..\init.c       \
          ..\parse.c      \
          ..\prnsetup.c

# PRECOMPILED_INCLUDE = ..\priv.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\tlog.cpp ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    tlog.cpp

Abstract:

    This module implements the travel log functionality for file open
    and save as dialogs.

Revision History:
    02-20-98          arulk                 created

--*/
#include "comdlg32.h"
#include <shellapi.h>
#include <shlobj.h>
#include <shsemip.h>
#include <shellp.h>
#include <commctrl.h>
#include <coguid.h>
#include <shlguid.h>
#include <shguidp.h>
#include <oleguid.h>

#include <commdlg.h>
#include "util.h"

#include "tlog.h"

//-------------------------------------------------------------------------
// Travel Log Link implementation
//-------------------------------------------------------------------------

TLogLink::TLogLink()
:_cRef(1), _pidl(NULL), _ptllNext(NULL), _ptllPrev(NULL)
{
}


TLogLink::TLogLink(LPITEMIDLIST  pidl)
:_cRef(1), _pidl(NULL), _ptllNext(NULL), _ptllPrev(NULL)
{
    _pidl = ILClone(pidl);
}

TLogLink::~TLogLink()
{
    if (_pidl)
    {
        ILFree(_pidl);
    }

    if (_ptllNext)
    {
        _ptllNext->Release();
    }
}

UINT TLogLink::AddRef()
{
    return ++_cRef;
}

UINT TLogLink::Release()
{
    if (--_cRef > 0)
    {
        return _cRef;
    }

    delete this;
    return 0;
}


void TLogLink::SetNextLink(TLogLink* ptllNext)
{
    //Do we already have Next Link ?
    if (_ptllNext)
    {
        // Release the next link
        _ptllNext->Release();
    }

    //Set the given pointer as our next pointer
    _ptllNext = ptllNext;

    if (_ptllNext)
    {
        //Since we are caching the pointer , Add reference to it
        _ptllNext->AddRef();

        //Also update the prev link of our new pointer to point to us
        _ptllNext->_ptllPrev = this;
    }
}


HRESULT TLogLink::GetPidl(LPITEMIDLIST* ppidl)
{
    *ppidl = ILClone(_pidl);
    if (*ppidl)
        return NOERROR;
    else {
        return E_OUTOFMEMORY;
    }
}

HRESULT TLogLink::SetPidl(LPITEMIDLIST pidl)
{
    if (_pidl)
    {
        ILFree(_pidl);
    }
    _pidl = ILClone(pidl);
    return NOERROR;
}

BOOL TLogLink::CanTravel(int iDir)
{
    BOOL fRet = FALSE;
    switch ( iDir )
    {
        case ( TRAVEL_BACK ) :
        {
            if (_ptllPrev != NULL)
            {
                fRet = TRUE;
            }
            break;
        }

        case ( TRAVEL_FORWARD ) :
        {
            if (_ptllNext !=NULL)
            {
                fRet = TRUE;
            }
            break;
        }
    }

    return fRet;
}


//----------------------------------------------------------------------------------
//Travel Log Class  Implementation
//----------------------------------------------------------------------------------

TravelLog::TravelLog()
:_cRef(1),_ptllCurrent(NULL), _ptllRoot(NULL)
{
}


TravelLog::~TravelLog()
{
    if (_ptllRoot)
    {
        _ptllRoot->Release();
    }
}

UINT TravelLog::AddRef()
{
   return  ++_cRef;
}


UINT TravelLog::Release()
{
    if (--_cRef > 0 )
        return _cRef;

    delete this;
    return 0;
}


HRESULT TravelLog::AddEntry(LPITEMIDLIST pidl)
{
    TLogLink  *ptll =  new TLogLink(pidl);
    if (!ptll)
        return E_FAIL;

    if (_ptllCurrent) {
        _ptllCurrent->SetNextLink(ptll);
        ptll->Release();
    }
    else
    {
        _ptllRoot = ptll;
    }

    _ptllCurrent = ptll;
    
    return NOERROR;
}


BOOL TravelLog::CanTravel(int iDir)
{
    if (_ptllCurrent)
    {
        return _ptllCurrent->CanTravel(iDir);
    }
    return FALSE;
}

HRESULT TravelLog::Travel(int iDir)
{
    HRESULT hres = E_FAIL;
    TLogLink *ptll;
    switch(iDir)
    {
        case ( TRAVEL_FORWARD ) :
        {
            if (CanTravel(iDir))
            {
                ptll = _ptllCurrent->GetNextLink();
                _ptllCurrent = ptll;
                hres = NOERROR;
            }
            break;

        }

        case ( TRAVEL_BACK ):
        {
            if (CanTravel(iDir))
            {
                ptll = _ptllCurrent->GetPrevLink();
                _ptllCurrent = ptll;
                hres = NOERROR;
            }
            break;

        }
    }

    return hres;
}


HRESULT TravelLog::GetCurrent(LPITEMIDLIST *ppidl)
{
    //Set the return value. Just in case
    *ppidl = NULL;
    if (_ptllCurrent)
    {
        return _ptllCurrent->GetPidl(ppidl);
        
    }
    return E_FAIL;
}

HRESULT Create_TravelLog(TravelLog **pptlog)
{
    HRESULT hres = E_FAIL;
    *pptlog = new TravelLog();

    if (*pptlog)
    {
        hres = S_OK;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\tlog.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    tlog.h

Abstract:

    This module implements the travel log functionality for file open
    and save as dialogs.

Revision History:
    02-20-98          arulk                 created

--*/
#ifndef _TLOG_H_
#define _TLOG_H_

#ifdef __cplusplus

#include "comdlg32.h"
#include <shellapi.h>
#include <shlobj.h>
#include <shsemip.h>
#include <shellp.h>
#include <commctrl.h>


//
//  Defines for Travel Log.
//
#define TRAVEL_BACK             0x0001
#define TRAVEL_FORWARD          0x0002



//--------------------------------------------------------------------
//Travel Log Link Class Definition
//--------------------------------------------------------------------
class TLogLink
{
public:
    TLogLink();
    TLogLink(LPITEMIDLIST pidl);    
    ~TLogLink();
    UINT AddRef();
    UINT Release();
    TLogLink *GetNextLink() { return _ptllNext;};
    TLogLink *GetPrevLink() { return _ptllPrev;};

    void SetNextLink(TLogLink* ptllNext);    

    HRESULT GetPidl(LPITEMIDLIST* ppidl);    
    HRESULT SetPidl(LPITEMIDLIST pidl);

    BOOL    CanTravel(int iDir);


private:
    UINT _cRef;
    LPITEMIDLIST _pidl;
    TLogLink * _ptllPrev;
    TLogLink * _ptllNext;
};



//------------------------------------------------------------------------
//Travel Log Class Definition
//------------------------------------------------------------------------
class TravelLog
{
public:
    friend HRESULT Create_TravelLog(TravelLog *pptlog);
    TravelLog();
    ~TravelLog();
    UINT AddRef();
    UINT Release();
    HRESULT AddEntry(LPITEMIDLIST pidl);
    BOOL CanTravel(int iDir);
    HRESULT Travel(int iDir);
    HRESULT GetCurrent(LPITEMIDLIST *ppidl);

private:
    UINT _cRef;
    TLogLink *_ptllCurrent;
    TLogLink *_ptllRoot;
};

#endif //_cplusplus

#ifdef _cplusplus
extern "C" {
#endif //_cplusplus

HRESULT Create_TravelLog(TravelLog **pptlog);

#ifdef _cplusplus
extern "C"
};
#endif //_cplusplus

#endif //_TLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\util.cpp ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    util.cpp

Abstract:

    This module implements utility functions for the common dialog.

Author :
    Arul Kumaravel              (arulk@microsoft.com)
--*/


#include "comdlg32.h"
#include <shellapi.h>
#include <shlobj.h>
#include <shsemip.h>
#include <shellp.h>
#include <commctrl.h>
#include <ole2.h>
#include "cdids.h"
#include "fileopen.h"
#include "filenew.h"

#include <coguid.h>
#include <shlguid.h>
#include <shguidp.h>
#include <oleguid.h>

#include <commdlg.h>

#include "util.h"

#ifndef ASSERT
#define ASSERT Assert
#endif


#define USE_AUTOCOMPETE_DEFAULT         TRUE
#define SZ_REGKEY_USEAUTOCOMPLETE       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\AutoComplete")
#define SZ_REGVALUE_FILEDLGAUTOCOMPLETE TEXT("AutoComplete In File Dialog")

/****************************************************\
    FUNCTION: AutoComplete

    DESCRIPTION:
        This function will have AutoComplete take over
    an editbox to help autocomplete DOS paths.
\****************************************************/
HRESULT AutoComplete(HWND hwndEdit, ICurrentWorkingDirectory ** ppcwd, DWORD dwFlags)
{
    HRESULT hr;
    IUnknown * punkACLISF;
    static BOOL fUseAutoComplete = -10; // Not inited.
    
    if (-10 == fUseAutoComplete)
        fUseAutoComplete = (SHRegGetBoolUSValue(SZ_REGKEY_USEAUTOCOMPLETE, SZ_REGVALUE_FILEDLGAUTOCOMPLETE, FALSE, USE_AUTOCOMPETE_DEFAULT));

    // WARNING: If you want to disable AutoComplete by default, 
    //          turn USE_AUTOCOMPETE_DEFAULT to FALSE
    if (fUseAutoComplete)
    {
        Assert(!dwFlags);	// Not yet used.
        hr = SHCoCreateInstance(NULL, &CLSID_ACListISF, NULL, IID_IUnknown, (void **)&punkACLISF);

        Assert(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
        {
            IAutoComplete * pac;

            // Create the AutoComplete Object
            hr = SHCoCreateInstance(NULL, &CLSID_AutoComplete, NULL, IID_IAutoComplete, (void **)&pac);

            Assert(SUCCEEDED(hr));
            if (SUCCEEDED(hr))
            {
                hr = pac->Init(hwndEdit, punkACLISF, NULL, NULL);
                pac->Release();
            }

            if (ppcwd)
            {
                punkACLISF->QueryInterface(IID_ICurrentWorkingDirectory, (void **)ppcwd);
            }

            punkACLISF->Release();
        }
    }

    return hr;
}


/****************************************************\
    FUNCTION: SetAutoCompleteCWD

    DESCRIPTION:
\****************************************************/
HRESULT SetAutoCompleteCWD(LPCTSTR pszDir, ICurrentWorkingDirectory * pcwd)
{
    WCHAR wsDir[MAX_PATH];

    if (!pcwd)
       return S_OK;

    SHTCharToUnicode(pszDir, wsDir, ARRAYSIZE(wsDir));
    return pcwd->SetDirectory(wsDir);
}


////////////////////////////////////////////////////////////////////////////
//
//  Overloaded allocation operators.
//
////////////////////////////////////////////////////////////////////////////
void * __cdecl operator new(
    unsigned int size)
{
    return ((void *)LocalAlloc(LPTR, size));
}

void __cdecl operator delete(
    void *ptr)
{
    LocalFree(ptr);
}

__cdecl _purecall(void)
{
    return (0);
}





////////////////////////////////////////////////////////////////////////////
//
//  Common Dialog Administrator Restrictions
//
////////////////////////////////////////////////////////////////////////////

const SHRESTRICTIONITEMS c_rgRestItems[] =
{
    {REST_NOPLACESBAR,             L"Comdlg32", L"NoPlacesBar"},
    {REST_NOBACKBUTTON,            L"Comdlg32", L"NoBackButton"},
    {REST_NOFILEMRU ,              L"Comdlg32", L"NoFileMru"},
    {0, NULL, NULL},
};

#define NUMRESTRICTIONS  ARRAYSIZE(c_rgRestItems)


DWORD g_rgRestItemValues[NUMRESTRICTIONS - 1 ] = { -1 };

DWORD IsRestricted(COMMDLG_RESTRICTIONS rest)
{   static BOOL bFirstTime = TRUE;

    if (bFirstTime)
    {
       memset((LPBYTE)g_rgRestItemValues,(BYTE)-1, SIZEOF(g_rgRestItemValues));
       bFirstTime = FALSE;
    }
    return SHRestrictionLookup(rest, NULL, c_rgRestItems, g_rgRestItemValues);
}


STDAPI CDBindToObject(IShellFolder *psf, REFIID riid, LPCITEMIDLIST pidl, void **ppvOut)
{
    HRESULT hres;

    *ppvOut = NULL;

    
    if (!psf)
    {
       if (FAILED(SHGetDesktopFolder(&psf)))
       {
           return E_FAIL;
       }
    }

    if (!pidl || ILIsEmpty(pidl))
    {
        hres = psf->QueryInterface(riid, ppvOut);
    }
    else
    {
        hres = psf->BindToObject(pidl, NULL, IID_IShellFolder, ppvOut);
    }

    return hres;
}


STDAPI CDBindToIDListParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
{
    HRESULT hres;
    
    LPITEMIDLIST pidlParent = ILClone(pidl);
    if (pidlParent) 
    {
        ILRemoveLastID(pidlParent);
        hres = CDBindToObject(NULL, riid, pidlParent, ppv);
        ILFree(pidlParent);
    }
    else
        hres = E_OUTOFMEMORY;

    if (ppidlLast)
        *ppidlLast = ILFindLastID(pidl);

    return hres;
}


STDAPI CDGetNameAndFlags(LPCITEMIDLIST pidl, DWORD dwFlags, LPTSTR pszName, UINT cchName, DWORD *pdwAttribs)
{
    if (pszName)
    {
        *pszName = 0;
    }

    IShellFolder *psf;
    LPCITEMIDLIST pidlLast;
    HRESULT hres = CDBindToIDListParent(pidl, IID_IShellFolder, (void **)&psf, &pidlLast);
    if (SUCCEEDED(hres))
    {
        if (pszName)
        {
            STRRET str;
            hres = psf->GetDisplayNameOf(pidlLast, dwFlags, &str);
            if (SUCCEEDED(hres))
                StrRetToStrN(pszName, cchName, &str, pidlLast);
        }

        if (pdwAttribs)
        {
            ASSERT(*pdwAttribs);    // this is an in-out param
            hres = psf->GetAttributesOf(1, (LPCITEMIDLIST *)&pidlLast, pdwAttribs);
        }
        psf->Release();
    }
    return hres;
}


STDAPI CDGetAttributesOf(LPCITEMIDLIST pidl, ULONG* prgfInOut)
{
    return CDGetNameAndFlags(pidl, 0, NULL, 0, prgfInOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftblt.c ===
/******************************Module*Header*******************************\
* Module Name: ftblt.c
*
* Test general blting (arbitrary rops, brush, etc.) to all format bitmaps.
*
* Created: 25-Jul-1991 10:21:58
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

extern BYTE abColorLines[];
extern BYTE abBitCat[];

// These globals define the source DIB's we are going to create.

typedef struct _BITMAPINFO1
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[2];
} BITMAPINFO1;

typedef struct _BITMAPINFO4
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[16];
} BITMAPINFO4;

typedef struct _BITMAPINFO8
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[256];
} BITMAPINFO8;

typedef struct _BITMAPINFO16
{
    BITMAPINFOHEADER                 bmiHeader;
    ULONG                            bmiColors[3];
} BITMAPINFO16;

typedef struct _BITMAPINFO32
{
    BITMAPINFOHEADER                 bmiHeader;
    ULONG                            bmiColors[3];
} BITMAPINFO32;

#define MASK_TEST 0

/******************************Public*Routine******************************\
* vTestGeneralBlt
*
* This is an easy sniff test for general rop blting.
*
* History:
*  20-Jul-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestGeneralBlt(
HDC hdcScreen,	   // Screen to display on, Assume 100 X 400.
ULONG xCord,	   // x coordinate to display at.
ULONG yCord,	   // y coordinate to display at.
HDC hdcTarg,	   // Target DC to general blting on, Assume 100 X 400.

		   // A source of all different types to try blting from.

HDC hdcSrc1,	   // 32 * 32
HDC hdcSrc4,	   // 64 * 64
HDC hdcSrc8,	   // 32 * 32
HDC hdcSrc16,	   // 32 * 32
HDC hdcSrc24,	   // 32 * 32
HDC hdcSrc32,	   // 32 * 32
HBITMAP hbmMask,   // A mask to blt with.
ULONG Rop1)	   // The rop you want to try.
{
    ULONG ulTemp;
    HBITMAP hbmOld;
    HBRUSH hbr, hbrOld;

    PatBlt(hdcTarg, 0, 0, 100, 400, BLACKNESS);

// So some Rop1 stuff.

    BitBlt(hdcTarg, 0, 0,   32, 32, hdcSrc1, 0, 0, Rop1);
    BitBlt(hdcTarg, 0, 32,  64, 64, hdcSrc4, 0, 0, Rop1);
    BitBlt(hdcTarg, 32, 0,  32, 32, hdcSrc8, 0, 0, Rop1);
    BitBlt(hdcTarg, 64, 32, 32, 32, hdcSrc16,0, 0, Rop1);
    BitBlt(hdcTarg, 64, 64, 32, 32, hdcSrc24,0, 0, Rop1);
    BitBlt(hdcTarg, 64, 0,  32, 32, hdcSrc32,0, 0, Rop1);

// Do MaskBlt 1/bpp

    hbmOld = SelectObject(hdcSrc1, hbmMask);

    if (hbmOld == NULL)
    {
	DbgPrint("Failed hbmOld in DC 1\n");
	return;
    }

    if ((hbr = CreatePatternBrush(hbmOld)) == (HBRUSH) 0)
    {
	DbgPrint("Failed CreatePatternBrush in DC 1\n");
	return;
    }

    if (0 == SelectObject(hdcSrc1, hbmOld))
    {
	DbgPrint("Failed select in DC 1\n");
	return;
    }

    hbrOld = SelectObject(hdcTarg, hbr);
#if MASK_ON
    MaskBlt(hdcTarg, 0, 100, 100, 50,
            hdcTarg, 0, 0, hbmMask, 0, 0, 0xAAF00000);
#else
    PatBlt(hdcTarg, 0, 100, 100, 50, PATCOPY);
#endif
    SelectObject(hdcTarg, hbrOld);
    DeleteObject(hbr);

// Do MaskBlt 4/bpp

    hbmOld = SelectObject(hdcSrc4, hbmMask);
    hbr = CreatePatternBrush(hbmOld);
    SelectObject(hdcSrc4, hbmOld);

    hbrOld = SelectObject(hdcTarg, hbr);
#if MASK_ON
    MaskBlt(hdcTarg, 0, 150, 50, 100,
            hdcTarg, 0, 0, hbmMask, 0, 0, 0xAAF00000);
#else
    PatBlt(hdcTarg, 0, 150, 100, 50, PATCOPY);
#endif
    SelectObject(hdcTarg, hbrOld);
    DeleteObject(hbr);

// Do MaskBlt 8/bpp

    hbmOld = SelectObject(hdcSrc8, hbmMask);
    hbr = CreatePatternBrush(hbmOld);
    SelectObject(hdcSrc8, hbmOld);

    hbrOld = SelectObject(hdcTarg, hbr);
#if MaSK_ON
    MaskBlt(hdcTarg, 0, 200, 100, 50,
            hdcTarg, 0, 0, hbmMask, 0, 0, 0xAAF00000);
#else
    PatBlt(hdcTarg, 0, 200, 100, 50, PATCOPY);
#endif
    SelectObject(hdcTarg, hbrOld);
    DeleteObject(hbr);

// Do MaskBlt 16/bpp

    hbmOld = SelectObject(hdcSrc16, hbmMask);
    hbr = CreatePatternBrush(hbmOld);
    SelectObject(hdcSrc16, hbmOld);

    hbrOld = SelectObject(hdcTarg, hbr);
#if MASK_ON
    MaskBlt(hdcTarg, 0, 250, 100, 50,
            hdcTarg, 0, 0, hbmMask, 0, 0, 0xAAF00000);
#else
    PatBlt(hdcTarg, 0, 250, 100, 50, PATCOPY);
#endif
    SelectObject(hdcTarg, hbrOld);
    DeleteObject(hbr);

// Do MaskBlt 24/bpp

    hbmOld = SelectObject(hdcSrc24, hbmMask);
    hbr = CreatePatternBrush(hbmOld);
    SelectObject(hdcSrc24, hbmOld);

    hbrOld = SelectObject(hdcTarg, hbr);
#if MASK_ON
    MaskBlt(hdcTarg, 0, 300, 100, 50,
            hdcTarg, 0, 0, hbmMask, 0, 0, 0xAAF00000);
#else
    PatBlt(hdcTarg, 0, 300, 100, 50, PATCOPY);
#endif
    SelectObject(hdcTarg, hbrOld);
    DeleteObject(hbr);

// Do MaskBlt 32/bpp

    hbmOld = SelectObject(hdcSrc32, hbmMask);
    hbr = CreatePatternBrush(hbmOld);
    SelectObject(hdcSrc32, hbmOld);

    hbrOld = SelectObject(hdcTarg, hbr);
#if MASK_ON
    MaskBlt(hdcTarg, 0, 350, 100, 50,
            hdcTarg, 0, 0, hbmMask, 0, 0, 0xAAF00000);
#else
    PatBlt(hdcTarg, 0, 350, 100, 50, PATCOPY);
#endif
    SelectObject(hdcTarg, hbrOld);
    DeleteObject(hbr);

    SetBkMode(hdcTarg, TRANSPARENT);
    TextOut(hdcTarg, 0, 300, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz12345678", 62);

    BitBlt(hdcScreen, xCord, yCord, 100, 400, hdcTarg, 0, 0, SRCCOPY);
}

/******************************Public*Routine******************************\
* vTestBlting
*
* This tests the blting functionality.
*
* History:
*  21-Jul-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestBlting(HWND hwnd, HDC hdcScreen, RECT* prcl)
{
    HDC hdc1, hdc4, hdc8, hdc16, hdc24, hdc32, hdcTarg;
    HBITMAP hbm1, hbm4, hbm8, hbm16, hbm24, hbm32, hbmTarg, hbmDefault, hbmMask;
    HBRUSH hbrR, hbrG, hbrB, hbrM, hbrDefault;
    ULONG ulTemp;

// These are the n-bpp sources.

    BITMAPINFO1 bmi1 = {{40,32,32,1,1,BI_RGB,0,0,0,0,0}, {{0,0,0,0}, {0xff,0xff,0xff,0}}};

    BITMAPINFO4 bmi4 =
    {
        {
            sizeof(BITMAPINFOHEADER),
            64,
            64,
            1,
            4,
            BI_RGB,
            0,
            0,
            0,
            0,
            0
        },

        {                               // B    G    R
            { 0,   0,   0,   0 },       // 0
            { 0,   0,   0x80,0 },       // 1
            { 0,   0x80,0,   0 },       // 2
            { 0,   0x80,0x80,0 },       // 3
            { 0x80,0,   0,   0 },       // 4
            { 0x80,0,   0x80,0 },       // 5
            { 0x80,0x80,0,   0 },       // 6
            { 0x80,0x80,0x80,0 },       // 7

            { 0xC0,0xC0,0xC0,0 },       // 8
            { 0,   0,   0xFF,0 },       // 9
            { 0,   0xFF,0,   0 },       // 10
            { 0,   0xFF,0xFF,0 },       // 11
            { 0xFF,0,   0,   0 },       // 12
            { 0xFF,0,   0xFF,0 },       // 13
            { 0xFF,0xFF,0,   0 },       // 14
            { 0xFF,0xFF,0xFF,0 }        // 15
        }
    };

    BITMAPINFO8 bmi8;
    BITMAPINFO16 bmi16 = {{40,32,32,1,16,BI_BITFIELDS,0,0,0,0,0},
                          {0x00007C00, 0x000003E0, 0x0000001F}};

    BITMAPINFOHEADER bmi24 = {40,32,32,1,24,BI_RGB,0,0,0,0,0};

    BITMAPINFO32 bmi32 = {{40,32,32,1,32,BI_BITFIELDS,0,0,0,0,0},
                          {0x00FF0000, 0x0000FF00, 0x000000FF}};

// Initialize the 8BPP DIB.

    bmi8.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    bmi8.bmiHeader.biWidth         = 32;
    bmi8.bmiHeader.biHeight        = 32;
    bmi8.bmiHeader.biPlanes        = 1;
    bmi8.bmiHeader.biBitCount      = 8;
    bmi8.bmiHeader.biCompression   = BI_RGB;
    bmi8.bmiHeader.biSizeImage     = 0;
    bmi8.bmiHeader.biXPelsPerMeter = 0;
    bmi8.bmiHeader.biYPelsPerMeter = 0;
    bmi8.bmiHeader.biClrUsed       = 0;
    bmi8.bmiHeader.biClrImportant  = 0;

// Generate 256 (= 8*8*4) RGB combinations to fill
// in the palette.

    {
        BYTE red, green, blue, unUsed;
        unUsed = red = green = blue = 0;

        for (ulTemp = 0; ulTemp < 256; ulTemp++)
        {
            bmi8.bmiColors[ulTemp].rgbRed      = red;
            bmi8.bmiColors[ulTemp].rgbGreen    = green;
            bmi8.bmiColors[ulTemp].rgbBlue     = blue;
            bmi8.bmiColors[ulTemp].rgbReserved = 0;

            if (!(red += 32))
            if (!(green += 32))
            blue += 64;
        }

        for (ulTemp = 248; ulTemp < 256; ulTemp++)
        {
            bmi8.bmiColors[ulTemp].rgbRed      = bmi4.bmiColors[ulTemp - 240].rgbRed;
            bmi8.bmiColors[ulTemp].rgbGreen    = bmi4.bmiColors[ulTemp - 240].rgbGreen;
            bmi8.bmiColors[ulTemp].rgbBlue     = bmi4.bmiColors[ulTemp - 240].rgbBlue;
            bmi8.bmiColors[ulTemp].rgbReserved = 0;

            if (!(red += 32))
            if (!(green += 32))
            blue += 64;
        }
    }

// Start Drawing

    PatBlt(hdcScreen, 0, 0, 10000, 10000, WHITENESS);

    hbrR = CreateSolidBrush(RGB(0xff, 0,    0));
    hbrG = CreateSolidBrush(RGB(0,    0xff, 0));
    hbrB = CreateSolidBrush(RGB(0,    0,    0xff));
    hbrM = CreateSolidBrush(RGB(0x80, 0x80, 0));

    if ((hbrR == (HBRUSH) 0) ||
	(hbrG == (HBRUSH) 0) ||
	(hbrB == (HBRUSH) 0) ||
	(hbrM == (HBRUSH) 0))
    {
	DbgPrint("Failed brush creation\n");
	goto br_cleanup;
    }

    hbmMask = CreateBitmap(32, 32, 1, 1, abBitCat);
    hbm1  = CreateDIBitmap(hdcScreen, NULL, CBM_INIT | CBM_CREATEDIB, abBitCat, (BITMAPINFO *) &bmi1, DIB_RGB_COLORS);
    hbm4  = CreateDIBitmap(hdcScreen, NULL, CBM_INIT | CBM_CREATEDIB, abColorLines, (BITMAPINFO *) &bmi4, DIB_RGB_COLORS);
    hbm8  = CreateDIBitmap(hdcScreen, NULL, CBM_CREATEDIB,NULL,(BITMAPINFO *) &bmi8,  DIB_RGB_COLORS);
    hbm16 = CreateDIBitmap(hdcScreen, NULL, CBM_CREATEDIB,NULL,(BITMAPINFO *) &bmi16, DIB_RGB_COLORS);
    hbm24 = CreateDIBitmap(hdcScreen, NULL, CBM_CREATEDIB,NULL,(BITMAPINFO *) &bmi24, DIB_RGB_COLORS);
    hbm32 = CreateDIBitmap(hdcScreen, NULL, CBM_CREATEDIB,NULL,(BITMAPINFO *) &bmi32, DIB_RGB_COLORS);

    if ((hbm1  == (HBITMAP) 0) ||
	(hbm4  == (HBITMAP) 0) ||
	(hbm8  == (HBITMAP) 0) ||
	(hbm16 == (HBITMAP) 0) ||
	(hbm24 == (HBITMAP) 0) ||
	(hbm32 == (HBITMAP) 0))
    {
	DbgPrint("Failed bitmap creation\n");
	goto bm_cleanup;
    }

    hdc1  = CreateCompatibleDC(hdcScreen);
    hdc4  = CreateCompatibleDC(hdcScreen);
    hdc8  = CreateCompatibleDC(hdcScreen);
    hdc16 = CreateCompatibleDC(hdcScreen);
    hdc24 = CreateCompatibleDC(hdcScreen);
    hdc32 = CreateCompatibleDC(hdcScreen);
    hdcTarg = CreateCompatibleDC(hdcScreen);

    if ((hdc1  == (HDC) 0) ||
	(hdc4  == (HDC) 0) ||
	(hdc8  == (HDC) 0) ||
	(hdc16 == (HDC) 0) ||
	(hdc24 == (HDC) 0) ||
	(hdc32 == (HDC) 0) ||
	(hdcTarg == (HDC) 0))
    {
	DbgPrint("Failed dc creation\n");
	goto dc_cleanup;
    }

    hbmDefault = SelectObject(hdc1,  hbm1);
    SelectObject(hdc4,	hbm4);
    SelectObject(hdc8,	hbm8);
    SelectObject(hdc16, hbm16);
    SelectObject(hdc24, hbm24);
    SelectObject(hdc32, hbm32);

// Draw some color on screen.

    hbrDefault = SelectObject(hdcScreen, hbrR);
    PatBlt(hdcScreen, 0, 0, 32, 32, PATCOPY);
    SelectObject(hdcScreen,hbrB);
    PatBlt(hdcScreen, 0, 0, 24, 24, PATCOPY);
    SelectObject(hdcScreen,hbrG);
    PatBlt(hdcScreen, 0, 0, 10, 10, PATCOPY);
    SelectObject(hdcScreen, hbrDefault);

// Set background color to RED so color to mono is interesting.

    SetBkColor(hdc1, RGB(0xFF, 0, 0));
    SetBkColor(hdc4, RGB(0xFF, 0, 0));
    SetBkColor(hdc8, RGB(0xFF, 0, 0));
    SetBkColor(hdc16, RGB(0xFF, 0, 0));
    SetBkColor(hdc24, RGB(0xFF, 0, 0));
    SetBkColor(hdc32, RGB(0xFF, 0, 0));

//!!! HACK till BitBlt message passes hdcSrc iBackColor across.
//!!! This gets the correct color set in.

    PatBlt(hdc4, 0, 0, 1, 1, WHITENESS);

// Set up the bitmap 8/pel

    hbrDefault = SelectObject(hdc8, hbrR);
    PatBlt(hdc8, 0, 0, 32, 32, PATCOPY);
    SelectObject(hdc8, hbrG);
    PatBlt(hdc8, 8, 8, 16, 16, PATCOPY);
    SelectObject(hdc8, hbrB);
    PatBlt(hdc8, 12, 12, 8, 8, PATCOPY);
    SelectObject(hdc8, hbrDefault);

// Set up 16 bit per pel.

    hbrDefault = SelectObject(hdc16, hbrR);
    PatBlt(hdc16, 0, 0, 32, 32, PATCOPY);
    SelectObject(hdc16,hbrB);
    PatBlt(hdc16, 0, 0, 24, 24, PATCOPY);
    SelectObject(hdc16,hbrG);
    PatBlt(hdc16, 0, 0, 10, 10, PATCOPY);
    SelectObject(hdc16, hbrDefault);

// Set up the bitmap 24/pel

    PatBlt(hdc24, 0, 0, 32, 32, WHITENESS);
    ulTemp = GetPixel(hdc24, 16, 16);

    if (ulTemp != 0xFFFFFF)
	DbgPrint("24 The pixel should be 0xFFFFFF is %lx\n", ulTemp);

    PatBlt(hdc24, 0, 0, 32, 32, BLACKNESS);
    ulTemp = GetPixel(hdc24, 16, 16);

    if (ulTemp != 0)
	DbgPrint("The pixel should be 0 is %lx\n", ulTemp);

    hbrDefault = SelectObject(hdc24, hbrR);
    PatBlt(hdc24, 0, 0, 8, 32, PATCOPY);
    ulTemp = GetPixel(hdc24, 0, 0);

    if (ulTemp != 0x000000FF)
	DbgPrint("The pixel should be 0x000000FF is %lx\n", ulTemp);

    SelectObject(hdc24, hbrG);
    PatBlt(hdc24, 8, 0, 8, 32, PATCOPY);
    ulTemp = GetPixel(hdc24, 8, 9);

    if (ulTemp != 0x0000FF00)
	DbgPrint("The pixel should be 0x0000FF00 is %lx\n", ulTemp);

    SelectObject(hdc24, hbrB);
    PatBlt(hdc24, 16, 0, 8, 32, PATCOPY);
    ulTemp = GetPixel(hdc24, 16, 17);

    if (ulTemp != 0x00FF0000)
	DbgPrint("The pixel should be 0x00FF0000 is %lx\n", ulTemp);

    SelectObject(hdc24, hbrM);
    PatBlt(hdc24, 24, 0, 8, 32, PATCOPY);
    SelectObject(hdc24, hbrDefault);

// Set up the bitmap 32/pel, check that RGB's are set up correctly.

    PatBlt(hdc32, 0, 0, 32, 32, WHITENESS);
    ulTemp = GetPixel(hdc32, 16, 16);

    if (ulTemp != 0xFFFFFF)
	DbgPrint("32 The pixel should be 0xFFFFFF is %lx\n", ulTemp);

    PatBlt(hdc32, 0, 0, 32, 32, BLACKNESS);
    ulTemp = GetPixel(hdc32, 16, 16);

    if (ulTemp != 0)
	DbgPrint("The pixel should be 0 is %lx\n", ulTemp);

    hbrDefault = SelectObject(hdc32, hbrR);
    PatBlt(hdc32, 0, 0, 32, 8, PATCOPY);
    ulTemp = GetPixel(hdc32, 8, 0);

    if (ulTemp != 0x000000FF)
	DbgPrint("The pixel should be 0x000000FF is %lx\n", ulTemp);

    SelectObject(hdc32, hbrG);
    PatBlt(hdc32, 0, 8, 32, 8, PATCOPY);
    ulTemp = GetPixel(hdc32, 8, 9);

    if (ulTemp != 0x0000FF00)
	DbgPrint("The pixel should be 0x0000FF00 is %lx\n", ulTemp);

    SelectObject(hdc32, hbrB);
    PatBlt(hdc32, 0, 16, 32, 8, PATCOPY);
    ulTemp = GetPixel(hdc32, 8, 17);

    if (ulTemp != 0x00FF0000)
	DbgPrint("The pixel should be 0x00FF0000 is %lx\n", ulTemp);

    SelectObject(hdc32, hbrM);
    PatBlt(hdc32, 0, 24, 32, 8, PATCOPY);
    SelectObject(hdc32, hbrDefault);

// Test Screen

    vTestGeneralBlt(hdcScreen,
                    0,
                    0,
                    hdcScreen,
                    hdc1,
                    hdc4,
                    hdc8,
                    hdc16,
                    hdc24,
                    hdc32,
                    hbmMask,
                    SRCCOPY);

    TextOut(hdcScreen, 0, 400, "This is Screen  ", 14);

// Test 1

    bmi1.bmiHeader.biWidth  = 100;
    bmi1.bmiHeader.biHeight = 400;

    hbmTarg  = CreateDIBitmap(hdcScreen, NULL, CBM_CREATEDIB,NULL,(BITMAPINFO *) &bmi1,  DIB_RGB_COLORS);

    if (hbmTarg == (HBITMAP) 0)
    {
        DbgPrint("CreateDIB 1 failed\n");
        goto all_cleanup;
    }

    SelectObject(hdcTarg, hbmTarg);

    vTestGeneralBlt(hdcScreen,
                    100,
                    0,
                    hdcTarg,
                    hdc1,
                    hdc4,
                    hdc8,
                    hdc16,
                    hdc24,
                    hdc32,
                    hbmMask,
                    SRCCOPY);

    TextOut(hdcScreen, 100, 400, "This is 1/pel   ", 14);

    SelectObject(hdcTarg, hbmDefault);
    DeleteObject(hbmTarg);

// Test 4

    bmi4.bmiHeader.biWidth  = 100;
    bmi4.bmiHeader.biHeight = 400;

    hbmTarg  = CreateDIBitmap(hdcScreen, NULL, CBM_CREATEDIB,NULL,(BITMAPINFO *) &bmi4,  DIB_RGB_COLORS);

    if (hbmTarg == (HBITMAP) 0)
        goto all_cleanup;

    SelectObject(hdcTarg, hbmTarg);

    vTestGeneralBlt(hdcScreen,
                    200,
                    0,
                    hdcTarg,
                    hdc1,
                    hdc4,
                    hdc8,
                    hdc16,
                    hdc24,
                    hdc32,
                    hbmMask,
                    SRCCOPY);

    TextOut(hdcScreen, 200, 400, "This is 4/pel   ", 14);

    SelectObject(hdcTarg, hbmDefault);
    DeleteObject(hbmTarg);

// Test 8

    bmi8.bmiHeader.biWidth  = 100;
    bmi8.bmiHeader.biHeight = 400;

    hbmTarg  = CreateDIBitmap(hdcScreen, NULL, CBM_CREATEDIB,NULL,(BITMAPINFO *) &bmi8,  DIB_RGB_COLORS);

    if (hbmTarg == (HBITMAP) 0)
        goto all_cleanup;

    SelectObject(hdcTarg, hbmTarg);

    vTestGeneralBlt(hdcScreen,
                    300,
                    0,
                    hdcTarg,
                    hdc1,
                    hdc4,
                    hdc8,
                    hdc16,
                    hdc24,
                    hdc32,
                    hbmMask,
                    SRCCOPY);

    TextOut(hdcScreen, 300, 400, "This is 8/pel   ", 14);

    SelectObject(hdcTarg, hbmDefault);
    DeleteObject(hbmTarg);

// Test 16

    bmi16.bmiHeader.biWidth  = 100;
    bmi16.bmiHeader.biHeight = 400;

    hbmTarg  = CreateDIBitmap(hdcScreen, NULL, CBM_CREATEDIB,NULL,(BITMAPINFO *) &bmi16,  DIB_RGB_COLORS);

    if (hbmTarg == (HBITMAP) 0)
    {
        DbgPrint("Failed 16 creation\n");
        goto all_cleanup;
    }

    SelectObject(hdcTarg, hbmTarg);

    vTestGeneralBlt(hdcScreen,
                    400,
                    0,
                    hdcTarg,
                    hdc1,
                    hdc4,
                    hdc8,
                    hdc16,
                    hdc24,
                    hdc32,
                    hbmMask,
                    SRCCOPY);

    TextOut(hdcScreen, 400, 400, "This is 16/pel  ", 14);

    SelectObject(hdcTarg, hbmDefault);
    DeleteObject(hbmTarg);

// Test 24

    bmi24.biWidth  = 100;
    bmi24.biHeight = 400;

    hbmTarg  = CreateDIBitmap(hdcScreen, NULL, CBM_CREATEDIB,NULL,(BITMAPINFO *) &bmi24,  DIB_RGB_COLORS);

    if (hbmTarg == (HBITMAP) 0)
        goto all_cleanup;

    SelectObject(hdcTarg, hbmTarg);

    vTestGeneralBlt(hdcScreen,
                    500,
                    0,
                    hdcTarg,
                    hdc1,
                    hdc4,
                    hdc8,
                    hdc16,
                    hdc24,
                    hdc32,
                    hbmMask,
                    SRCCOPY);

    TextOut(hdcScreen, 500, 400, "This is 24/pel   ", 14);

    SelectObject(hdcTarg, hbmDefault);
    DeleteObject(hbmTarg);

// Test 32

    bmi32.bmiHeader.biWidth  = 100;
    bmi32.bmiHeader.biHeight = 400;

    hbmTarg  = CreateDIBitmap(hdcScreen, NULL, CBM_CREATEDIB,NULL,(BITMAPINFO *) &bmi32,  DIB_RGB_COLORS);

    if (hbmTarg == (HBITMAP) 0)
        goto all_cleanup;

    SelectObject(hdcTarg, hbmTarg);

    vTestGeneralBlt(hdcScreen,
                    600,
                    0,
                    hdcTarg,
                    hdc1,
                    hdc4,
                    hdc8,
                    hdc16,
                    hdc24,
                    hdc32,
                    hbmMask,
                    SRCCOPY);

    TextOut(hdcScreen, 600, 400, "This is 32/pel  ", 14);

    SelectObject(hdcTarg, hbmDefault);
    DeleteObject(hbmTarg);

// Test Compatible / (Device if supported)

    hbmTarg  = CreateCompatibleBitmap(hdcScreen, 100, 400);

    if (hbmTarg == (HBITMAP) 0)
        goto all_cleanup;

    SelectObject(hdcTarg, hbmTarg);

    vTestGeneralBlt(hdcScreen,
                    700,
                    0,
                    hdcTarg,
                    hdc1,
                    hdc4,
                    hdc8,
                    hdc16,
                    hdc24,
                    hdc32,
                    hbmMask,
                    SRCCOPY);

    TextOut(hdcScreen, 700, 400, "This is Compatible  ", 14);

    SelectObject(hdcTarg, hbmDefault);
    DeleteObject(hbmTarg);

#if 1
// Test StretchBlting all formats

    StretchBlt(hdcScreen,   0, 900, 100, 100, hdc1,  0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 100, 900, 100, 100, hdc4,  0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 200, 900, 100, 100, hdc8,  0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 300, 900, 100, 100, hdc16, 0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 400, 900, 100, 100, hdc24, 0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 500, 900, 100, 100, hdc32, 0, 0, 32, 32, SRCCOPY);

    StretchBlt(hdcScreen,   0, 600, 100, 200, hdc1,  0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 100, 600, 100, 200, hdc4,  0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 200, 600, 100, 200, hdc8,  0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 300, 600, 100, 200, hdc16, 0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 400, 600, 100, 200, hdc24, 0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 500, 600, 100, 200, hdc32, 0, 0, 32, 32, SRCCOPY);
#endif

// Test StretchBlting all formats

    StretchBlt(hdcScreen,   0, 450, 100, 100, hdc1,  0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 100, 450, 100, 100, hdc4,  0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 200, 450, 100, 100, hdc8,  0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 300, 450, 100, 100, hdc16, 0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 400, 450, 100, 100, hdc24, 0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 500, 450, 100, 100, hdc32, 0, 0, 32, 32, SRCCOPY);

    StretchBlt(hdcScreen,   0, 550, 100, 200, hdc1,  0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 100, 550, 100, 200, hdc4,  0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 200, 550, 100, 200, hdc8,  0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 300, 550, 100, 200, hdc16, 0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 400, 550, 100, 200, hdc24, 0, 0, 32, 32, SRCCOPY);
    StretchBlt(hdcScreen, 500, 550, 100, 200, hdc32, 0, 0, 32, 32, SRCCOPY);

// Test blting from screen to the bitmaps.

    BitBlt(hdc1,  0, 0, 100, 100, hdcScreen, 0, 0, SRCCOPY);
    BitBlt(hdc4,  0, 0, 100, 100, hdcScreen, 0, 0, SRCCOPY);
    BitBlt(hdc8,  0, 0, 100, 100, hdcScreen, 0, 0, SRCCOPY);
    BitBlt(hdc16, 0, 0, 100, 100, hdcScreen, 0, 0, SRCCOPY);
    BitBlt(hdc24, 0, 0, 100, 100, hdcScreen, 0, 0, SRCCOPY);
    BitBlt(hdc32, 0, 0, 100, 100, hdcScreen, 0, 0, SRCCOPY);

    GdiFlush();

// Clean up

all_cleanup:
dc_cleanup:

    DeleteDC(hdc1);
    DeleteDC(hdc4);
    DeleteDC(hdc8);
    DeleteDC(hdc16);
    DeleteDC(hdc24);
    DeleteDC(hdc32);
    DeleteDC(hdcTarg);

bm_cleanup:

    DeleteObject(hbm1);
    DeleteObject(hbm4);
    DeleteObject(hbm8);
    DeleteObject(hbm16);
    DeleteObject(hbm24);
    DeleteObject(hbm32);
    DeleteObject(hbmMask);

br_cleanup:

    DeleteObject(hbrR);
    DeleteObject(hbrG);
    DeleteObject(hbrB);
    DeleteObject(hbrM);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\fonttest.nt\comdlg32mm\util.h ===
/*++

Copyright (c) 1990-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    util.h

Abstract:

    This module implements utility functions for the common dialog.

Revision History:
    02-20-98          arulk                 created

--*/
#ifndef _UTIL_H_
#define _UTIL_H_

#include <shlobjp.h>

////////////////////////////////////////////////////////////////////////////
//  Autocomplete 
//
////////////////////////////////////////////////////////////////////////////
HRESULT AutoComplete(HWND hwndEdit, ICurrentWorkingDirectory ** ppcwd, DWORD dwFlags);
HRESULT SetAutoCompleteCWD(LPCTSTR pszDir, ICurrentWorkingDirectory * pcwd);

////////////////////////////////////////////////////////////////////////////
//  Common Dilaog Restrictions
//
////////////////////////////////////////////////////////////////////////////
typedef enum
{
    REST_NULL                       = 0x00000000,
    REST_NOPLACESBAR                = 0x00000001,
    REST_NOBACKBUTTON               = 0x00000002,
    REST_NOFILEMRU                  = 0x00000003,
}COMMDLG_RESTRICTIONS;

DWORD IsRestricted(COMMDLG_RESTRICTIONS rest);

////////////////////////////////////////////////////////////////////////////
//
// Utility functions
//
////////////////////////////////////////////////////////////////////////////

STDAPI CDBindToObject(IShellFolder *psf, REFIID riid, LPCITEMIDLIST pidl, void **ppvOut);
STDAPI CDBindToIDListParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast);
STDAPI CDGetNameAndFlags(LPCITEMIDLIST pidl, DWORD dwFlags, LPTSTR pszName, UINT cchName, DWORD *pdwAttribs);
STDAPI CDGetAttributesOf(LPCITEMIDLIST pidl, ULONG* prgfInOut);



////////////////////////////////////////////////////////////////////////////
//
//  Overloaded allocation operators.
//
////////////////////////////////////////////////////////////////////////////
#ifdef _cplusplus
extern "C" {
#endif //_cplusplus

void * __cdecl operator new(unsigned int size);
void __cdecl operator delete(void *ptr);
__cdecl _purecall(void);

#ifdef _cplusplus
};
#endif //_cplusplus

#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ft.c ===
/******************************Module*Header*******************************\
* Module Name: ft.c
*
* Functionality Test for GDI.  This is a test app that runs under USER.
* It should be run before checking in changes to the graphics engine.
* When functionality becomes stable in the engine a set of routines that
* test the new functionality should be added to Ft.
*
* How to add a new set of tests to Ft:
*
* 1. add menu item IDM_XXXX to ft.rc
* 2. add a .c file with the new tests to sources.
* 3. add a function call to it from TestAll.
* 4. add a case to the WM_COMMAND for your IDM_XXXX that sets pfnFtTest to
*    your function.
*
* Look at previous tests added for an example.
*
* Created: 25-May-1991 11:32:09
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

// Global Varibles which the testing thread will look at

LONG gcTestsToRun = 0;
RECT gRect;
PFN_FT_TEST pfnFtTest = vTestAll;
BOOL bDbgBreak = FALSE;
HDC hdcBM;  // Bitmap DC when testing other formats.

HBRUSH hbrFillCars;

// function prototypes

BOOL InitializeApp(void);
LRESULT FtWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT About(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
VOID vFtThread(HWND);
VOID vTestRGBBrush(HDC hdc, ULONG cx, ULONG cy);
VOID vTestDitherStuff(HDC hdc, ULONG rgb);
VOID vTestXlates(HDC hdc, RECT *prcl);
VOID vTestRainbow(HDC hdc);
VOID vTestRainbow1(HDC hdc);
VOID vTestRainbow2(HDC hdc);
VOID vTestDIBToScreen(HDC hdc);
VOID vTestKernel(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestFontSpeed(HWND hwnd);
VOID vTestTTRealizationSpeed(HDC hdc);
VOID vTestTextOutSpeedwt(HDC hdc);
VOID vTestDIBSECTION1(HWND hwnd, HDC hdcScreen, RECT* prcl, LONG width);

// global variables for window management

HWND ghwndMain, ghwndAbout;
HANDLE ghInstance = NULL;
DWORD dwThreadID;
HBRUSH ghbrWhite;
SIZE sizlWindow;
SIZE sizlViewport;

// Global Varibles for Target destination.  These are used so the FT tests
// can be played to any type of bitmap surface or direct to the screen to
// enable more thorough testing of bitmap support.  If a bitmap format is
// selected Ft creates a bitmap equal to the size of visible window and plays
// the tests into the bitmap and then SRCCOPY's it to the screen after each
// test.

HDC     ghdcBM = (HDC) 0;         // The compat dest
HBITMAP ghbmBM = (HBITMAP) 0;     // The current dest bitmap.
ULONG   giDstFormat = IDM_DIRECT; // The current desired dest format.

// Communication between message thread and test thread.

ULONG  iWaitLevel = 0;  // The larger this is, the more often a test pauses.
HANDLE hEvent;

// Image color management stuffs.

LONG   lIcmMode = ICM_OFF;
CHAR   chIcmProfile[MAX_PATH] = "\0";
BOOL   bPalIcmed = FALSE;

PALETTEENTRY palSaved[256];

/******************************Public*Routine******************************\
* main
*
* Sets up the message loop.
*
* History:
*  25-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

int __cdecl main(
    int argc,
    char *argv[])
{
    MSG msg;
    HANDLE haccel;
    LPSTR lpstrCmd;
    CHAR ch;

    ghInstance = GetModuleHandle(NULL);

    lpstrCmd = GetCommandLine();

    do
        ch = *lpstrCmd++;
    while (ch != ' ' && ch != '\t' && ch != '\0');
    while (ch == ' ' || ch == '\t')
        ch = *lpstrCmd++;
    while (ch == '-') {
        ch = *lpstrCmd++;

        //  process multiple switch characters as needed

        do {
            switch (ch) {

                case 'S':
                case 's':
                    ch = *lpstrCmd++;
                    gcTestsToRun = 1;
                    break;
                default:
                    break;
                }
            }
        while (ch != ' ' && ch != '\t' && ch != '\0');

        //  skip over any following white space

        while (ch == ' ' || ch == '\t')
            ch = *lpstrCmd++;
        }
    InitializeApp();

    haccel = LoadAccelerators(ghInstance, "MAINACC");

    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    argc;
    argv;
    return 1;
}

/******************************Public*Routine******************************\
* InitializeApp
*
* Registers the window class with USER.
*
* History:
*  25-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL InitializeApp(void)
{
    WNDCLASS wc;
    HMENU hFtMenu;

    ghbrWhite = CreateSolidBrush(0x00FFFFFF);

    wc.style            = 0;
    wc.lpfnWndProc      = (WNDPROC) FtWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(ghInstance, "Ft");
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = NULL;             // for now
    wc.lpszClassName    = "FtWindowClass";

    if (!RegisterClass(&wc))
        return FALSE;

    hFtMenu = LoadMenu(ghInstance, "Ft");
    if (hFtMenu == NULL)
        DbgPrint("ERROR: Menu did not load\n");

    ghwndMain = CreateWindowEx(0L, "FtWindowClass", "FT Tests",
            WS_OVERLAPPED | WS_CAPTION | WS_BORDER | WS_THICKFRAME |
            WS_MAXIMIZEBOX | WS_MINIMIZEBOX | WS_CLIPCHILDREN |
            WS_VISIBLE | WS_SYSMENU,
            100, 50, 500, 400, NULL, hFtMenu, ghInstance, NULL);

    if (ghwndMain == NULL)
        return(FALSE);

    hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);

    if (hEvent == NULL)
        DbgPrint("Crummy Event Handle.\n");
    //
    // init alpha bitmap
    //

    {
        HBITMAP hbmCars = LoadBitmap(ghInstance,MAKEINTRESOURCE(CAR_BITMAP));
        LOGBRUSH      lgBrush;

        lgBrush.lbStyle = BS_PATTERN;
        lgBrush.lbColor = 0;
        lgBrush.lbHatch = (ULONG_PTR)hbmCars;

        hbrFillCars = CreateBrushIndirect(&lgBrush);

        DeleteObject(hbmCars);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* About
*
* Dialog box procedure
*
* History:
*  25-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

LRESULT About(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            return (TRUE);
        case WM_COMMAND:
            if (wParam == IDOK)
                EndDialog(hDlg,0);
            return (TRUE);
    }
    return (FALSE);

    lParam;
}

typedef struct _LOGPALETTE256
{
    USHORT palVersion;
    USHORT palNumEntries;
    PALETTEENTRY palPalEntry[256];
} LOGPALETTE256;

LOGPALETTE256 pal256;

void vWhitePalette(HDC hDCGlobal)
{
    HBRUSH hbr, hbrOld;
    HPALETTE hpal1, hpalTemp;
    int iTemp;

    pal256.palVersion = 0x300;
    pal256.palNumEntries = 256;

    for (iTemp = 0; iTemp < 256; iTemp++)
    {
        pal256.palPalEntry[iTemp].peRed = 0xff;
        pal256.palPalEntry[iTemp].peGreen = 0xff;
        pal256.palPalEntry[iTemp].peBlue = 0xff;
        pal256.palPalEntry[iTemp].peFlags = 0;
    }

    for (iTemp = 0; iTemp < 255; iTemp++)
    {
        pal256.palPalEntry[iTemp].peFlags = PC_NOCOLLAPSE | PC_RESERVED;
    }

    hpal1 = CreatePalette((PLOGPALETTE)&pal256);
    hpalTemp = SelectPalette(hDCGlobal, hpal1, 0);
    RealizePalette(hDCGlobal);
    hbr = CreateSolidBrush(PALETTEINDEX(255));
    hbrOld = SelectObject(hDCGlobal,hbr);
    PatBlt(hDCGlobal, 0, 0, 100,100, PATCOPY);
    SelectObject(hDCGlobal, hbrOld);
    DeleteObject(hbr);
    SelectPalette(hDCGlobal, hpalTemp, 1);
    DeleteObject(hpal1);
}


/******************************Public*Routine******************************\
* FtWndProc
*
* Processes all messages for the window
*
* History:
*  25-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

LRESULT FtWndProc(
HWND hwnd,
UINT message,
WPARAM wParam,
LPARAM lParam)
{
    PAINTSTRUCT ps;
    HDC hdc;

    switch (message)
    {
    case WM_CREATE:

        vInitMaze();
        break;

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        PatBlt(hdc, gRect.top, gRect.left, gRect.right, gRect.bottom, WHITENESS);
        EndPaint(hwnd, &ps);
        GetClientRect(hwnd, &gRect);
        break;

    case WM_DESTROY:
        if (hwnd == ghwndMain)
        {
            PostQuitMessage(0);
            break;
        }
        return DefWindowProc(hwnd, message, wParam, lParam);

    case WM_RBUTTONDOWN:

        InvalidateRect(NULL, NULL, TRUE);
        break;

    case WM_SIZE:
        InvalidateRect(hwnd, NULL, 1);

        hdc = GetDC(hwnd);

        GetClientRect(hwnd, &gRect);

        sizlViewport.cx = gRect.right - gRect.left;
        sizlViewport.cy = gRect.bottom - gRect.top;

        if (GetMapMode(hdc) == MM_TEXT)
            sizlWindow = sizlViewport;
        else
        {
            sizlWindow.cx = 100;
            sizlWindow.cy = 100;
        }

        ReleaseDC(hwnd,hdc);

        break;

    case WM_CHAR:

        switch (wParam)
        {
        case 'a':

            hdc = CreateDC("DISPLAY",NULL,NULL,NULL);
            SaveDC(hdc);
            RestoreDC(hdc,0);
            RestoreDC(hdc,-10);
            TextOut(hdc, 0, 0, "Hello Johnc", 11);
            DeleteDC(hdc);
            break;

        case 'b':

            {
                HBITMAP hbmMem;
                HDC     hdcMem;

                hdc = GetDC(hwnd);
                hbmMem = CreateBitmap(500,300,1,1,NULL);
                hdcMem = CreateCompatibleDC(hdc);
                SelectObject(hdcMem,hbmMem);
                vTestTextOutSpeedwt(hdcMem);
                DbgPrint("f12 for OldOld\n");
                vMatchOldLogFontToOldRealizationwt(hdcMem);
                DbgPrint("f12 for NewOld\n");
                vMatchNewLogFontToOldRealizationwt(hdcMem);
                DbgPrint("End Test\n");
                DeleteDC(hdcMem);
                DeleteObject(hbmMem);
                ReleaseDC(hwnd,hdc);
            }

            break;

        case 'c':

            {
                HBITMAP hbmMem,hbmMem1;
                HDC     hdcMem,hdcMem1;

                hdc = GetDC(hwnd);
                vWhitePalette(hdc);
                ReleaseDC(hwnd,hdc);
            }
            break;

        case 'd':

            hdc = GetDC(hwnd);
            vTestDitherStuff(hdc,256);
            ReleaseDC(hwnd,hdc);
            break;

        case 'e':

            hdc = GetDC(hwnd);
            vTestDitherStuff(hdc,256*256);
            ReleaseDC(hwnd,hdc);
            break;

        case 'f':

            hdc = GetDC(hwnd);
            vTestDitherStuff(hdc,256*256 + 256 + 1);
            ReleaseDC(hwnd,hdc);
            break;

        case 'g':

            hdc = GetDC(hwnd);
            GetClientRect(hwnd, &gRect);
            vTestDIBSECTION1(hwnd,hdc, &gRect,1);
            ReleaseDC(hwnd,hdc);
            break;

        case 'h':

            hdc = GetDC(hwnd);
            GetClientRect(hwnd, &gRect);
            vTestDIBSECTION1(hwnd,hdc, &gRect,-1);
            ReleaseDC(hwnd,hdc);
            break;

        case 'i':

            hdc = GetDC(hwnd);
            GetClientRect(hwnd, &gRect);
            vTestRainbow(hdc);
            ReleaseDC(hwnd,hdc);
            break;

        case 'j':

            hdc = GetDC(hwnd);
            GetClientRect(hwnd, &gRect);
            vTestRainbow1(hdc);
            ReleaseDC(hwnd,hdc);
            break;

        case 'k':

            hdc = GetDC(hwnd);
            GetClientRect(hwnd, &gRect);
            vTestRainbow2(hdc);
            ReleaseDC(hwnd,hdc);
            break;

        case 'l':
            hdc = GetDC(hwnd);
            vTestDIBToScreen(hdc);
            ReleaseDC(hwnd,hdc);
            break;

        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            iWaitLevel = (ULONG)wParam - '0';
            ResetEvent(hEvent);
            break;

        case ' ':
            SetEvent(hEvent);
            break;

        default:
            break;

        }
        break;

    case WM_COMMAND:

        switch (wParam)
        {
        case IDM_ABOUT:
            ghwndAbout = CreateDialog(ghInstance, "AboutBox", ghwndMain, (DLGPROC) About);
            break;

    // This first bunch sets the number of times to run the test

        case IDM_TEST1:

            gcTestsToRun = 1;
            CreateThread(NULL, 8192, (LPTHREAD_START_ROUTINE)vFtThread, hwnd, 0, &dwThreadID);
            break;

        case IDM_TEST10:

            gcTestsToRun = 10;
            CreateThread(NULL, 8192, (LPTHREAD_START_ROUTINE)vFtThread, hwnd, 0, &dwThreadID);
            break;

        case IDM_TEST100:

            gcTestsToRun = 100;
            CreateThread(NULL, 8192, (LPTHREAD_START_ROUTINE)vFtThread, hwnd, 0, &dwThreadID);
            break;

        case IDM_TESTALOT:

            gcTestsToRun = 10000000;
            CreateThread(NULL, 8192, (LPTHREAD_START_ROUTINE)vFtThread, hwnd, 0, &dwThreadID);
            break;

        case IDM_TESTFOREVER:

            gcTestsToRun = 10000000;
            CreateThread(NULL, 8192, (LPTHREAD_START_ROUTINE)vFtThread, hwnd, 0, &dwThreadID);
            break;

        case IDM_TESTSTOP:

            gcTestsToRun = 0;
            break;

    // This second batch sets the test to run.

        case IDM_ALL:

                pfnFtTest = vTestAll;
                break;

        case IDM_BITMAP:

                pfnFtTest = vTestBitmap;
                break;

        case IDM_STINK4:

                pfnFtTest = vTestStink4;
                break;

        case IDM_UNICODE:

                pfnFtTest = vTestUnicode;
                break;

        case IDM_GEN_TEXT:

                pfnFtTest = vTestGenText;
                break;

        case IDM_XFORMTXT:

                pfnFtTest = vTestXformText;
                break;

        case IDM_ESCAPEMENT:

                pfnFtTest = vTestEscapement;
                break;

        case IDM_BLTING:

                pfnFtTest = vTestBlting;
                break;

        case IDM_BM_TEXT:

                pfnFtTest = vTestBMText;
                break;

        case IDM_BRUSH:

                pfnFtTest = vTestBrush;
                break;

        case IDM_GRADFILL:

                pfnFtTest = vTestGradFill;
                break;

        case IDM_ALPHABLEND:

                pfnFtTest = vTestAlphaBlend;
                break;

        case IDM_COLOR:

                pfnFtTest = vTestColor;
                break;

        case IDM_DIB:

                pfnFtTest = vTestDIB;
                break;

        case IDM_FILLING:

                pfnFtTest = vTestFilling;
                break;

        case IDM_FONT:

                pfnFtTest = vTestFonts;
                break;

        case IDM_OUTLINE:

                pfnFtTest = vTestGlyphOutline;
                break;

        case IDM_LINE:

                pfnFtTest = vTestLines;
                break;

        case IDM_MAPPING:

                pfnFtTest = vTestMapping;
                break;

        case IDM_MAZE:

                pfnFtTest = vTestMaze;
                break;

        case IDM_PALETTE:

                hdc = GetDC(hwnd);

                vTestPalettes(hwnd, hdc, &gRect);

                ReleaseDC(hwnd,hdc);

                pfnFtTest = vTestPalettes;
                break;

        case IDM_PLGBLT:

                pfnFtTest = vTestPlgBlt;
                break;

        case IDM_REGION:

                pfnFtTest = vTestRegion;
                break;

        case IDM_STRETCH:

                pfnFtTest = vTestStretch;
                break;

        case IDM_PRINTERS:

                pfnFtTest = vTestPrinters;
                break;

        case IDM_LFONT:

                pfnFtTest = vTestLFONTCleanup;
                break;

        case IDM_ODDPAT:

                pfnFtTest = vTestOddBlt;
                break;

        case IDM_JNLTEST:

                pfnFtTest = vTestJournaling;
                gcTestsToRun = 1;
                break;

        case IDM_RESETDC:

                pfnFtTest = vTestResetDC;
                gcTestsToRun = 1;
                break;

        case IDM_CSRSPEED:

                pfnFtTest = vTestCSR;
                gcTestsToRun = 1;
                break;

// This batch tells what dst format to use

        case IDM_1BPP:
        case IDM_4BPP:
        case IDM_8BPP:
        case IDM_16BPP:
        case IDM_24BPP:
        case IDM_32BPP:
        case IDM_COMPAT:
        case IDM_DIRECT:

                giDstFormat = (ULONG)wParam;
                break;

        case IDM_KERN:

                pfnFtTest = vTestKerning;
                break;

        case IDM_POLYTEXT:

                pfnFtTest = vTestPolyTextOut;
                break;

        case IDM_QUICKTEST:

                pfnFtTest = vTestAll;
                gcTestsToRun = 1;
                CreateThread(NULL, 8192, (LPTHREAD_START_ROUTINE)vFtThread, hwnd, 0, &dwThreadID);
                break;

// Turning on or off debugging

        case IDM_BREAKON:

                bDbgBreak = TRUE;
                break;

        case IDM_BREAKOFF:

                bDbgBreak = FALSE;
                break;

// Turing on/off ICM

        case IDM_ICMOFF:

                lIcmMode = ICM_OFF;
                chIcmProfile[0] = '\0';
                CheckMenuItem(GetMenu(hwnd),IDM_ICMOFF,MF_CHECKED);
                CheckMenuItem(GetMenu(hwnd),IDM_ICMONDEF,MF_UNCHECKED);
                CheckMenuItem(GetMenu(hwnd),IDM_ICMONCUS,MF_UNCHECKED);
                break;

        case IDM_ICMONDEF:

                lIcmMode = ICM_ON;
                chIcmProfile[0] = '\0';
                CheckMenuItem(GetMenu(hwnd),IDM_ICMOFF,MF_UNCHECKED);
                CheckMenuItem(GetMenu(hwnd),IDM_ICMONDEF,MF_CHECKED);
                CheckMenuItem(GetMenu(hwnd),IDM_ICMONCUS,MF_UNCHECKED);
                break;

        case IDM_ICMONCUS:
        {
                OPENFILENAME op;

                ZeroMemory(&op,sizeof(OPENFILENAME));

                op.lStructSize = sizeof(OPENFILENAME);
                op.hwndOwner   = hwnd;
                op.lpstrFile   = chIcmProfile;
                op.nMaxFile    = MAX_PATH;

                GetOpenFileName(&op);
                lIcmMode = ICM_ON;

                CheckMenuItem(GetMenu(hwnd),IDM_ICMOFF,MF_UNCHECKED);
                CheckMenuItem(GetMenu(hwnd),IDM_ICMONDEF,MF_UNCHECKED);
                CheckMenuItem(GetMenu(hwnd),IDM_ICMONCUS,MF_CHECKED);

                break;
        }

        case IDM_ICMPALETTE:

                bPalIcmed = !bPalIcmed;

                if (bPalIcmed)
                    CheckMenuItem(GetMenu(hwnd),IDM_ICMPALETTE,MF_CHECKED);
                else
                    CheckMenuItem(GetMenu(hwnd),IDM_ICMPALETTE,MF_UNCHECKED);

                break;

// Special tests for timing

        case IDM_FONTSPEED:

                vTestFontSpeed(hwnd);
                break;

        case IDM_BRUSHSPEED:

                pfnFtTest = vTestKernel;
                break;

        case IDM_QLPC:

                pfnFtTest = vTestQLPC;
                break;

        case IDM_CHARTEST:
                vTestChar(hwnd);
                break;

        case IDM_WIN95API:

                pfnFtTest = vTestWin95Apis;
                break;

        case IDM_MAPEVENT:

                pfnFtTest = vMapEvent;
                break;


        case IDM_STRESS:

                // pfnFtTest = vTestStress;
                break;

        default:
            //DbgPrint("WM_COMMAND: %lx, %lx\n", wParam, lParam);
            return DefWindowProc(hwnd, message, wParam, lParam);
        }
        return (0);

    default:
        return DefWindowProc(hwnd, message, wParam, lParam);
    }

    return 0L;
}

/******************************Public*Routine******************************\
* vShortSleep
*
* Tells the number of 1/8s of a second to sleep.
*
* History:
*  27-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vShortSleep(DWORD ulSecs)
{
    LARGE_INTEGER    time;

    time.LowPart = ((DWORD) -((LONG) ulSecs * 10000000L));
    time.HighPart = ~0;
    NtDelayExecution(0, &time);
}

/******************************Public*Routine******************************\
* vSleep
*
* delays execution ulSecs.
*
* History:
*  27-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSleep(DWORD ulSecs)
{
    LARGE_INTEGER    time;

    time.LowPart = ((DWORD) -((LONG) ulSecs * 10000000L));
    time.HighPart = ~0;
    NtDelayExecution(0, &time);
}

/******************************Public*Routine******************************\
* vFtThread
*
* Thread from which the tests are executed.
*
* History:
*  27-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vFtThread(
    HWND hwnd)
{
    HDC     hdc;
    HBITMAP hbmBM = 0;
    ULONG ulWidth,ulHeight;

// Get the DC

    while(1)
    {
    // Wait till the count gets set

        if (gcTestsToRun <= 0)
            return;

    // Party on Garth

        gcTestsToRun--;

        if (bDbgBreak)
            DbgBreakPoint();

        hdc = GetDC(hwnd);
        hdcBM = CreateCompatibleDC(hdc);
        GdiSetBatchLimit(1);
        GetClientRect(hwnd, &gRect);
        ulWidth  = gRect.right - gRect.left;
        ulHeight = gRect.bottom - gRect.top;

        if (giDstFormat != IDM_DIRECT)
        {
            switch(giDstFormat)
            {
            case IDM_1BPP:
                hbmBM = hbmCreateDIBitmap(hdc, ulWidth,ulHeight,1);
                break;
            case IDM_4BPP:
                hbmBM = hbmCreateDIBitmap(hdc, ulWidth,ulHeight,4);
                break;
            case IDM_8BPP:
                hbmBM = hbmCreateDIBitmap(hdc, ulWidth,ulHeight,8);
                break;
            case IDM_16BPP:
                hbmBM = hbmCreateDIBitmap(hdc, ulWidth,ulHeight,16);
                break;
            case IDM_24BPP:
                hbmBM = hbmCreateDIBitmap(hdc, ulWidth,ulHeight,24);
                break;
            case IDM_32BPP:
                hbmBM = hbmCreateDIBitmap(hdc, ulWidth,ulHeight,32);
                break;
            case IDM_COMPAT:
                hbmBM = CreateCompatibleBitmap(hdc,ulWidth,ulHeight);
                break;
            default:
                DbgPrint("ERROR ft unknown giDstFormat\n");
            }

            SelectObject(hdcBM,hbmBM);
        }

// configure ICM mode.

        if (chIcmProfile[0] != '\0')
        {
            SetICMProfile(hdc,chIcmProfile);
        }
        // else
        // {
        //     the default profile for this DC will be used.
        // }

        SetICMMode(hdc,lIcmMode);

// Comment why this stuff is here.

        sizlViewport.cx = gRect.right - gRect.left;
        sizlViewport.cy = gRect.bottom - gRect.top;

        if (GetMapMode(hdc) == MM_TEXT)
            sizlWindow = sizlViewport;
        else
        {
            sizlWindow.cx = 100;
            sizlWindow.cy = 100;
        }

// End Comment why this stuff is here.

        if ((giDstFormat == IDM_DIRECT) ||
            (pfnFtTest == vTestAll))
        {
            (*pfnFtTest)(hwnd, hdc, &gRect);
        }
        else
        {
            (*pfnFtTest)(hwnd, hdcBM, &gRect);
            BitBlt(hdc, 0, 0, ulWidth, ulHeight, hdcBM, 0, 0, SRCCOPY);
        }

        if (!DeleteDC(hdcBM))
            DbgPrint("hdcBM failed delete\n");

        if (hbmBM != (HBITMAP) 0)
        {
            if (!DeleteObject(hbmBM))
                DbgPrint("Failed delete of hbmBM\n");

            hbmBM = (HBITMAP) 0;
        }

        ReleaseDC(hwnd, hdc);
    }
}

/******************************Public*Routine******************************\
* vDoTest
*
* This is does the test to the correct surface.
*
* History:
*  23-Mar-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vDoTest(char *psz, PFN_FT_TEST pfnFtTest, HWND hwnd, HDC hdc, RECT *prcl, HDC hdcBM)
{
    char ach[100];

    GetWindowText(hwnd,ach,sizeof(ach));
    SetWindowText(hwnd,psz);
    if (giDstFormat == IDM_DIRECT)
        (*pfnFtTest)(hwnd, hdc, &gRect);
    else
    {
        (*pfnFtTest)(hwnd, hdcBM, &gRect);

        BitBlt(hdc, 0, 0, 10000, 10000, hdcBM, 0, 0, SRCCOPY);
    }
    SetWindowText(hwnd,ach);
}

/******************************Public*Routine******************************\
* vTestAll
*
* This function calls all the other tests once.
*
* History:
*  26-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestAll(HWND hwnd, HDC hdc, RECT *prclClient)
{
// Don't use prclClient.  We pass the global rcl to each test so if it get's updated
// during one of the tests the next test will get the correct rcl in case
// it uses it.

    prclClient = prclClient;

// Call each test once.

    vDoTest("vTestBitmap",vTestBitmap, hwnd, hdc, &gRect, hdcBM);
    vDoTest("vTestBlting",vTestBlting, hwnd,hdc,&gRect, hdcBM);
    vDoTest("vTestBrush",vTestBrush, hwnd, hdc, &gRect, hdcBM);
    vDoTest("vTestColor",vTestColor, hwnd, hdc, &gRect, hdcBM);
    vDoTest("vTestBMText",vTestBMText, hwnd, hdc, &gRect, hdcBM);
    vDoTest("vTestDIB",vTestDIB, hwnd,hdc, &gRect, hdcBM);
    vDoTest("vTestFilling",vTestFilling, hwnd, hdc, &gRect, hdcBM);
    vDoTest("vTestTextXforms", vTestXformText, hwnd, hdc, &gRect, hdcBM);
    vDoTest("vTestFonts",vTestFonts, hwnd, hdc, &gRect, hdcBM);
    vDoTest("vTestLines",vTestLines, hwnd, hdc, &gRect, hdcBM);
    vDoTest("vTestPalettes",vTestPalettes, hwnd, hdc, &gRect, hdcBM);
    vDoTest("vTestPlgBlt",vTestPlgBlt, hwnd, hdc, &gRect, hdcBM);
    vDoTest("vTestMapping",vTestMapping, hwnd, hdc, &gRect, hdcBM);
    vDoTest("vTestRegion",vTestRegion, hwnd, hdc, &gRect, hdcBM);
    vDoTest("vTestStretch",vTestStretch, hwnd, hdc, &gRect, hdcBM);
    // vDoTest(vTestUnicode, hwnd, hdc, &gRect, hdcBM);
    // vDoTest(vTestStink4, hwnd, hdc, &gRect, hdcBM);
    // vDoTest(vTestGenText, hwnd, hdc, &gRect, hdcBM);
    // vDoTest(vTestEscapement, hwnd, hdc, &gRect, hdcBM);
    vDoTest("vTestOddBlt",vTestOddBlt, hwnd, hdc, &gRect, hdcBM);
    vDoTest("vTestKerning",vTestKerning,hwnd, hdc, &gRect, hdcBM);
    vDoTest("vTestPolyTextOut",vTestPolyTextOut,hwnd, hdc, &gRect, hdcBM);
    vDoTest("vTestFlag",vTestFlag, hwnd, hdc, &gRect, hdcBM);
    vDoTest("vTestGradFill",vTestGradFill, hwnd, hdc, &gRect, hdcBM);
    vDoTest("vTestAlphaBlend",vTestAlphaBlend, hwnd, hdc, &gRect, hdcBM);

}

/******************************Public*Routine******************************\
* vTestBrushXY
*
* Generic speed test for brushes.
*
* History:
*  13-Aug-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestBrushSpeedXY(HDC hdc, DWORD x, DWORD y)
{
// First let's stress it a little bit.

    ULONG ulTime;
    LARGE_INTEGER  time, timeEnd;
    ULONG ulCount;
    HBITMAP hbmMask;
    POINT aPoint[3] = {{0,1}, {4,5}, {7,8}};

    hbmMask = CreateBitmap(5, 5, 1, 1, NULL);

    GdiFlush();

// Do the PatBlt test.

    NtQuerySystemTime(&time);

    ulCount = 5000;

    while (ulCount--)
    {
        TextOut(hdc, 0, 0, "Hello Jack", 10);
        BitBlt(hdc, 10, 10, 4, 4, hdc, 0, 0, SRCCOPY);
        StretchBlt(hdc, 10, 10, 5, 5, hdc, 0, 0, 2, 2, SRCCOPY);
        Polyline(hdc, aPoint, 3);
        PlgBlt(hdc, aPoint, hdc, 3, 3, 3, 3, 0, 0, 0);
        SetPixelV(hdc, 3, 3, 0x0000FF00);
        Ellipse(hdc, 3, 3, 8, 8);
        PatBlt(hdc, 10, 10, 6, 6, BLACKNESS);
        FloodFill(hdc, 12, 12, 0);
        Polygon(hdc, aPoint, 3);
        RoundRect(hdc, 1, 1, 7,7 ,2 ,2);
        MaskBlt(hdc, 0, 0, 5, 5, hdc, 3, 3, hbmMask, 0, 0, 0xAADE0000);
    }

    GdiFlush();

    NtQuerySystemTime(&timeEnd);

    ulTime = timeEnd.LowPart - time.LowPart;
    ulTime = ulTime / 10000;
    DbgPrint("For %lu by %lu time was %lu.%lu\n", x, y, (ulTime / 1000),
                                                        (ulTime % 1000));

    DeleteObject(hbmMask);
}

/******************************Public*Routine******************************\
* vTestBrushSpeed
*
* test brush speed
*
* History:
*  13-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

#define DO_MEMORY 1

VOID vTestBrushSpeed(HWND hwnd, HDC hdc, RECT* prcl)
{
    POINT   aPoint[4];
    HDC hdcTemp;
    HBITMAP hbmTemp;
    hwnd;

    PatBlt(hdc, 0, 0, prcl->right, prcl->bottom, WHITENESS);

#if DO_MEMORY
    hdcTemp = CreateCompatibleDC(hdc);
    hbmTemp = CreateCompatibleBitmap(hdc, 100, 100);
    SelectObject(hdcTemp, hbmTemp);
    PatBlt(hdcTemp, 0, 0, 1000, 1000, WHITENESS);
#else
    hdcTemp = hdc;
    hbmTemp = 0;
#endif

    GdiFlush();

// Do the client side PatBlt test.

    DbgPrint("This is the client side time 1 10 100\n");

    GdiSetBatchLimit(1);
    vTestBrushSpeedXY(hdcTemp, 1, 1);

    GdiSetBatchLimit(10);
    vTestBrushSpeedXY(hdcTemp, 1, 1);

    GdiSetBatchLimit(100);
    vTestBrushSpeedXY(hdcTemp, 1, 1);

    GdiSetBatchLimit(1000);
    vTestBrushSpeedXY(hdcTemp, 1, 1);

// Do the server side call.

    //PatBlt(hdc, 0, 0, prcl->right, prcl->bottom, WHITENESS);
    //PlgBlt(hdc, aPoint, hdc, 0, 0, 100, 100, (HBITMAP) 0, 0, 0);
    GdiFlush();

#if DO_MEMORY
    DeleteDC(hdcTemp);
    DeleteObject(hbmTemp);
#endif

}

#define RANGE  240
#define HUEINC 4
#define SATINC 8
#define  HLSMAX   RANGE
#define  RGBMAX   255

/* utility routine for HLStoRGB */
WORD HueToRGB(WORD n1, WORD n2, WORD hue)
{

#ifdef REMOVE  /* WORD value can't be negative */
   /* range check: note values passed add/subtract thirds of range */
   if (hue < 0)
      hue += HLSMAX;
#endif

   if (hue >= HLSMAX)
      hue -= HLSMAX;

   /* return r,g, or b value from this tridrant */
   if (hue < (HLSMAX/6))
      return (WORD)( n1 + (((n2-n1)*hue+(HLSMAX/12))/(HLSMAX/6)) );
   if (hue < (HLSMAX/2))
      return ( n2 );
   if (hue < ((HLSMAX*2)/3))
      return (WORD)( n1 + (((n2-n1)*(((HLSMAX*2)/3)-hue)+(HLSMAX/12)) / (HLSMAX/6)) );
   else
      return ( n1 );
}

DWORD HLStoRGB(WORD hue, WORD lum, WORD sat)
{
  WORD R,G,B;                      /* RGB component values */
  WORD  Magic1,Magic2;       /* calculated magic numbers (really!) */

  if (sat == 0) {               /* achromatic case */
      R = G = B = (WORD)((lum * RGBMAX) / HLSMAX);
  }
  else {                         /* chromatic case */
      /* set up magic numbers */
      if (lum <= (HLSMAX/2))
          Magic2 = (WORD)((lum * ((DWORD)HLSMAX + sat) + (HLSMAX/2))/HLSMAX);
      else
          Magic2 = lum + sat - (WORD)(((lum*sat) + (DWORD)(HLSMAX/2))/HLSMAX);
      Magic1 = (WORD)(2*lum-Magic2);

      /* get RGB, change units from HLSMAX to RGBMAX */
      R = (WORD)(((HueToRGB(Magic1,Magic2,(WORD)(hue+(HLSMAX/3)))*(DWORD)RGBMAX + (HLSMAX/2))) / HLSMAX);
      G = (WORD)(((HueToRGB(Magic1,Magic2,hue)*(DWORD)RGBMAX + (HLSMAX/2))) / HLSMAX);
      B = (WORD)(((HueToRGB(Magic1,Magic2,(WORD)(hue-(HLSMAX/3)))*(DWORD)RGBMAX + (HLSMAX/2))) / HLSMAX);
  }
  return(RGB(R,G,B));
}

/******************************Public*Routine******************************\
* vTestRainbow
*
* This creates the rainbow dialog box.
*
* History:
*  15-Jun-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestRainbow(HDC hdc)
{
// First let's stress it a little bit.

    HDC hdcMem;
    HBITMAP hbmMem, hbmTemp;
    WORD Sat, Hue;
    RECT Rect;
    DWORD nHueWidth, nSatHeight;
    ULONG ulTime;
    LARGE_INTEGER  time, timeEnd;
    HBRUSH hbrSwipe;
    ULONG ulTemp = 10;

    PatBlt(hdc, 0, 0, 10000, 10000, WHITENESS);

    hdcMem = CreateCompatibleDC(hdc);
    hbmMem = CreateCompatibleBitmap(hdc, 400, 400);
    hbmTemp = SelectObject(hdcMem, hbmMem);

    nHueWidth  = 400;
    nSatHeight = 400;
    Rect.bottom = 0;

    NtQuerySystemTime(&time);

// Draw the rainbow pattern 10 times

    while (ulTemp--)
    {
        for (Sat = RANGE; Sat > 0; Sat -= SATINC)
        {
            Rect.top = Rect.bottom;
            Rect.bottom = (nSatHeight * RANGE - (Sat - SATINC) * nSatHeight) / RANGE;
            Rect.right = 0;

            for (Hue = 0; Hue < (RANGE - 1); Hue += HUEINC)
            {
                Rect.left = Rect.right;
                Rect.right = ((Hue + HUEINC) * nHueWidth) / RANGE;
                hbrSwipe = CreateSolidBrush(HLStoRGB(Hue, RANGE / 2, Sat));
                FillRect(hdcMem, (LPRECT) &Rect, hbrSwipe);
                DeleteObject(hbrSwipe);
            }
        }
    }

    GdiFlush();

    NtQuerySystemTime(&timeEnd);
    ulTime = timeEnd.LowPart - time.LowPart;
    ulTime = ulTime / 10000;
    DbgPrint("For all Rainbow was %lu.%lu\n",(ulTime / 1000), (ulTime % 1000));

    BitBlt(hdc, 0, 0, 400, 400, hdcMem, 0, 0, SRCCOPY);
    SelectObject(hdcMem, hbmTemp);
    DeleteObject(hbmMem);
    DeleteDC(hdcMem);

}

/******************************Public*Routine******************************\
* vTestRainbow1
*
* This creates the rainbow dialog box.
*
* History:
*  15-Jun-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestRainbow1(HDC hdc)
{
// First let's stress it a little bit.

    HDC hdcMem;
    HBITMAP hbmMem, hbmTemp;
    WORD Sat, Hue;
    RECT Rect;
    DWORD nHueWidth, nSatHeight;
    ULONG ulTime;
    LARGE_INTEGER  time, timeEnd;
    HBRUSH hbrSwipe,hbrTemp;
    ULONG ulTemp = 10;

    PatBlt(hdc, 0, 0, 10000, 10000, WHITENESS);

    hdcMem = CreateCompatibleDC(hdc);
    hbmMem = CreateCompatibleBitmap(hdc, 400, 400);
    hbmTemp = SelectObject(hdcMem, hbmMem);

    nHueWidth  = 400;
    nSatHeight = 400;
    Rect.bottom = 0;

    NtQuerySystemTime(&time);

// Draw the rainbow pattern 10 times

    while (ulTemp--)
    {
        for (Sat = RANGE; Sat > 0; Sat -= SATINC)
        {
            Rect.top = Rect.bottom;
            Rect.bottom = (nSatHeight * RANGE - (Sat - SATINC) * nSatHeight) / RANGE;
            Rect.right = 0;

            for (Hue = 0; Hue < (RANGE - 1); Hue += HUEINC)
            {
                Rect.left = Rect.right;
                Rect.right = ((Hue + HUEINC) * nHueWidth) / RANGE;
                hbrSwipe = CreateSolidBrush(HLStoRGB(Hue, RANGE / 2, Sat));
                hbrTemp = SelectObject(hdcMem,hbrSwipe);
                PatBlt(hdcMem, Rect.left, Rect.top, Rect.right - Rect.left, Rect.bottom - Rect.top, PATCOPY);
                SelectObject(hdcMem, hbrTemp);
                DeleteObject(hbrSwipe);
            }
        }
    }

    GdiFlush();

    NtQuerySystemTime(&timeEnd);
    ulTime = timeEnd.LowPart - time.LowPart;
    ulTime = ulTime / 10000;
    DbgPrint("For all Rainbow1 was %lu.%lu\n",(ulTime / 1000), (ulTime % 1000));

    BitBlt(hdc, 0, 0, 400, 400, hdcMem, 0, 0, SRCCOPY);
    SelectObject(hdcMem, hbmTemp);
    DeleteObject(hbmMem);
    DeleteDC(hdcMem);

}

/******************************Public*Routine******************************\
* vTestRainbow2
*
* This creates the rainbow dialog box.
*
* History:
*  15-Jun-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestRainbow2(HDC hdc)
{
// First let's stress it a little bit.

    HDC hdcMem;
    HBITMAP hbmMem, hbmTemp;
    WORD Sat, Hue;
    RECT Rect;
    DWORD nHueWidth, nSatHeight;
    ULONG ulTime;
    LARGE_INTEGER  time, timeEnd;
    HBRUSH hbrSwipe,hbrTemp;
    ULONG ulTemp = 10;
    ULONG ulLimit;

    PatBlt(hdc, 0, 0, 10000, 10000, WHITENESS);

    hdcMem = CreateCompatibleDC(hdc);
    hbmMem = CreateCompatibleBitmap(hdc, 400, 400);
    hbmTemp = SelectObject(hdcMem, hbmMem);

    nHueWidth  = 400;
    nSatHeight = 400;
    Rect.bottom = 0;

    NtQuerySystemTime(&time);

    hbrSwipe = CreateHatchBrush(HS_DITHEREDTEXTCLR, 0);
    hbrTemp = SelectObject(hdcMem,hbrSwipe);
    ulLimit = GdiSetBatchLimit(1000);

// Draw the rainbow pattern 10 times

    while (ulTemp--)
    {
        for (Sat = RANGE; Sat > 0; Sat -= SATINC)
        {
            Rect.top = Rect.bottom;
            Rect.bottom = (nSatHeight * RANGE - (Sat - SATINC) * nSatHeight) / RANGE;
            Rect.right = 0;

            for (Hue = 0; Hue < (RANGE - 1); Hue += HUEINC)
            {
                Rect.left = Rect.right;
                Rect.right = ((Hue + HUEINC) * nHueWidth) / RANGE;
                SetTextColor(hdcMem, HLStoRGB(Hue, RANGE / 2, Sat));
                PatBlt(hdcMem, Rect.left, Rect.top, Rect.right - Rect.left, Rect.bottom - Rect.top, PATCOPY);
            }
        }
    }

    SelectObject(hdcMem, hbrTemp);
    DeleteObject(hbrSwipe);

    GdiSetBatchLimit(ulLimit);
    GdiFlush();

    NtQuerySystemTime(&timeEnd);
    ulTime = timeEnd.LowPart - time.LowPart;
    ulTime = ulTime / 10000;
    DbgPrint("For all Rainbow2 was %lu.%lu\n",(ulTime / 1000), (ulTime % 1000));

    BitBlt(hdc, 0, 0, 400, 400, hdcMem, 0, 0, SRCCOPY);
    SelectObject(hdcMem, hbmTemp);
    DeleteObject(hbmMem);
    DeleteDC(hdcMem);
}

/******************************Public*Routine******************************\
* vTestRGBBrush
*
* This creates and PatBlts all the RGB brushes once.  Exhaustive testing of
* the dither code..
*
* History:
*  15-Jun-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestRGBBrush(HDC hdc, ULONG cx, ULONG cy)
{
// First let's stress it a little bit.

    ULONG ulTime;
    LARGE_INTEGER  time, timeEnd;
    ULONG ulCount;
    ULONG ulRed,ulBlu,ulGre;
    HBRUSH hbrTemp, hbrRGB;

    NtQuerySystemTime(&time);

    for (ulRed = 0; ulRed <= 255; ulRed++)
    {
        DbgPrint("ulRed is %lu\n", ulRed);

        for (ulGre = 0; ulGre <= 255; ulGre++)
        {
            for (ulBlu = 0; ulBlu <= 255; ulBlu++)
            {
                hbrRGB = CreateSolidBrush(ulRed | (ulGre << 8) | (ulBlu << 16));
                hbrTemp = SelectObject(hdc, hbrRGB);
                PatBlt(hdc, 100, cx, cy, 100, PATCOPY);
                SelectObject(hdc,hbrTemp);
                DeleteObject(hbrRGB);
            }
        }
    }

    GdiFlush();

    NtQuerySystemTime(&timeEnd);

    ulTime = timeEnd.LowPart - time.LowPart;
    ulTime = ulTime / 10000;
    DbgPrint("For all RGB brushes %lu by %lu time was %lu.%lu\n", cx, cy, (ulTime / 1000),
                                                        (ulTime % 1000));
}

/******************************Public*Routine******************************\
* vTestDitherStuff.
*
* Prints out 256 dithers from a base dither.
*
* History:
*  18-Jun-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestDitherStuff(HDC hdc, ULONG rgb)
{
// First let's stress it a little bit.

    ULONG ulX,ulY,ulColor;
    HBRUSH hbrTemp, hbrRGB;

    ulColor = 0;

    for (ulX = 0; ulX < 16; ulX++)
    {
        for (ulY = 0; ulY < 16; ulY++)
        {
            hbrRGB = CreateSolidBrush(ulColor);
            hbrTemp = SelectObject(hdc, hbrRGB);
            PatBlt(hdc, ulX * 32, ulY * 32, 32, 32, PATCOPY);
            SelectObject(hdc,hbrTemp);
            DeleteObject(hbrRGB);

            ulColor += rgb;
        }
    }
}


NTSTATUS
FtFloodFill (
    IN HANDLE hdc,
    IN LONG x,
    IN LONG y,
    IN ULONG color,
    IN ULONG iFillType
    )
{
    ULONG aTemp[1500];
    ULONG uiTemp;
    ULONG uiSum = 0;

    for (uiTemp = 0; uiTemp < 1500; uiTemp+=6)
    {
        aTemp[uiTemp] = uiTemp + y + x;
        uiSum += aTemp[uiTemp];
    }

    return((NTSTATUS) uiSum);
}

/******************************Public*Routine******************************\
* QLPC Time Functions
*
* History:
*  24-Apr-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

#define NUMBER_OF_RUNS 2
#define NUMBER_OF_LOOP 10000
#define NUMBER_OF_FUNC 5
#define NUMBER_TOTAL   (NUMBER_OF_LOOP * NUMBER_OF_FUNC)

typedef struct _QLPCRUN
{
    ULONG ulTime1;
    ULONG ulTime10;
    ULONG ulTime100;
} QLPCRUN;

/******************************Public*Routine******************************\
* vTestQLPCSpeed
*
* Generic speed test for brushes.
*
* History:
*  13-Aug-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

NTSTATUS
NtFloodFill (
    IN HANDLE hdc,
    IN LONG x,
    IN LONG y,
    IN ULONG color,
    IN ULONG iFillType
    );


VOID vTestQLPCSpeed(HDC hdc, ULONG *pul, HBITMAP hbmMask)
{
// First let's stress it a little bit.

    ULONG ulTime;
    LARGE_INTEGER  time, timeEnd;
    ULONG ulCount;

    POINT aPoint[3] = {{0,1}, {4,5}, {7,8}};

    GdiFlush();

// Do the PatBlt test.

    NtQuerySystemTime(&time);

    ulCount = NUMBER_OF_LOOP;

    while (ulCount--)
    {
        #if 0
        {
            ULONG aTemp[1500];
            ULONG uiTemp;
            ULONG uiSum = 0;

            uiSum = 0;
            for (uiTemp = 0; uiTemp < 1500; uiTemp+=6)
            {
                aTemp[uiTemp] = uiTemp;
                uiSum += aTemp[uiTemp];
            }
        }
        #endif

        // BitBlt(hdc, 0, 0, 70,70, 0, 0, 0, WHITENESS);
        TextOut(hdc, 0, 0, "A", 1);
        // TextOut(hdc, 0, 0, "Hello Guys", 10);
        PatBlt(hdc, 0, 0, 1, 1, BLACKNESS);
        Ellipse(hdc, 3, 3, 8, 8);
        // NtFloodFill(hdc, 1, 1, 0, 0);
        // ExtFloodFill(hdc, 1, 1, 0, 0);
        // FtFloodFill(hdc, 1, 1, 0, 0);
        // Polyline(hdc, aPoint, 3);
        SetPixelV(hdc, 0, 0, 0x0000FF);
        // BitBlt(hdc, 0, 0, 5, 5, 0, 0, 0, 0x5f0000);
        // Polygon(hdc, aPoint, 3);
        RoundRect(hdc, 1, 1, 7,7 ,2 ,2);
        // NtQuerySystemTime(&timeEnd);
    }

    GdiFlush();

    NtQuerySystemTime(&timeEnd);

    ulTime = timeEnd.LowPart - time.LowPart;

    *pul = ulTime;

    // ulTime = ulTime / 10000;
    // DbgPrint("Time was %lu\n", ulTime);
}

/******************************Public*Routine******************************\
* vTestQLPC
*
* Test QLPC speed.
*
* History:
*  13-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestQLPC(HWND hwnd, HDC hdc, RECT* prcl)
{
    HDC hdcTemp;
    HBITMAP hbmTemp, hbmMask;
    ULONG ulTemp, ulTime100, ulTime10,ulTime1;

// Data for NUMBER_OF_RUNS, each run has 3 times, each time has 2 ULONGS.

    QLPCRUN aQLPCTimeRuns[NUMBER_OF_RUNS + 1];
    char ach[256];

    hwnd;

    hbmMask = CreateBitmap(5, 5, 1, 1, NULL);

    PatBlt(hdc, 0, 0, prcl->right, prcl->bottom, WHITENESS);

    hdcTemp = CreateCompatibleDC(hdc);
    hbmTemp = CreateBitmap(100, 100, 1, 8, NULL);
    SelectObject(hdcTemp, hbmTemp);
    PatBlt(hdcTemp, 0, 0, 1000, 1000, WHITENESS);
    // DbgPrint("Starting QLPC time overhead test\n");
    GdiFlush();

    for (ulTemp = 0; ulTemp < NUMBER_OF_RUNS; ulTemp++)
    {
        GdiSetBatchLimit(1);
        vTestQLPCSpeed(hdcTemp, &(aQLPCTimeRuns[ulTemp].ulTime1), hbmMask);

        GdiSetBatchLimit(10);
        vTestQLPCSpeed(hdcTemp, &(aQLPCTimeRuns[ulTemp].ulTime10), hbmMask);

        GdiSetBatchLimit(100);
        vTestQLPCSpeed(hdcTemp, &(aQLPCTimeRuns[ulTemp].ulTime100), hbmMask);
    }

    DeleteDC(hdcTemp);
    DeleteObject(hbmTemp);
    DeleteObject(hbmMask);

// Average the data.  Don't use first run, mouse still moving, other apps still
// processing messages being generated.

    aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime1   =
    aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime10  =
    aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime100 = 0;

    for (ulTemp = 1; ulTemp < NUMBER_OF_RUNS; ulTemp++)
    {
        aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime1   += aQLPCTimeRuns[ulTemp].ulTime1;
        aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime10  += aQLPCTimeRuns[ulTemp].ulTime10;
        aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime100 += aQLPCTimeRuns[ulTemp].ulTime100;
    }

    aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime1   /= (NUMBER_OF_RUNS - 1);
    aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime10  /= (NUMBER_OF_RUNS - 1);
    aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime100 /= (NUMBER_OF_RUNS - 1);

    DbgPrint("\nTotal # of calls was %lu\n", NUMBER_TOTAL);

    DbgPrint("Ave Total # of 1/10ths Microseconds for test was 1 %lu 10 %lu 100 %lu\n",
                                   (aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime1),
                                   (aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime10),
                                   (aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime100));

    DbgPrint("Ave # of 1/10ths Microseconds per call was 1 %lu 10 %lu 100 %lu\n",
                                   (aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime1 / NUMBER_TOTAL),
                                   (aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime10 / NUMBER_TOTAL),
                                   (aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime100 / NUMBER_TOTAL));

// Compute the QLPC Time from the average.

    ulTime100 = aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime1 - aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime100;
    ulTime10  = aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime1 - aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime10;
    ulTime1   = aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime10 - aQLPCTimeRuns[NUMBER_OF_RUNS].ulTime100;

    ulTime100 = (ulTime100 / 99) * 100; // (NUMBER_TOTAL - (NUMBER_TOTAL / 100));
    ulTime10  = (ulTime10 / 9) * 10;   // = ulTime10 / (NUMBER_TOTAL - (NUMBER_TOTAL / 10));
    ulTime1   = (ulTime1 / 9) * 100;   // = ulTime10 / (NUMBER_TOTAL - (NUMBER_TOTAL / 10));

    DbgPrint("The Round Trip overhead of 1 QLPC trip is\n");
    DbgPrint("Based on Batch 10/1  %lu 10ths of Microseconds\n", ulTime10 / NUMBER_TOTAL);
    DbgPrint("Based on Batch 100/1 %lu 10ths of Microseconds\n", ulTime100 / NUMBER_TOTAL);
    DbgPrint("Based on Batch 100/10 %lu 10ths of Microseconds\n", ulTime1 / NUMBER_TOTAL);

    // time / 10000000 = seconds
#if 0
{
    LARGE_INTEGER  time, timeEnd;
    ULONG ulTime;

    GdiFlush();

    NtQuerySystemTime(&time);
    vSleep(2);
    NtQuerySystemTime(&timeEnd);

    ulTime = timeEnd.LowPart - time.LowPart;

    DbgPrint("Time was %lu\n", ulTime);
}
#endif
}

typedef struct _BITMAPINFO32
{
    BITMAPINFOHEADER                 bmiHeader;
    ULONG                            bmiColors[3];
} BITMAPINFO32;

HPALETTE CreateGreyPalette(void);

#define HOW_BIG 256

VOID vTestDIBToScreen(HDC hdc)
{
    DWORD *pBits;
    ULONG ulTemp = HOW_BIG*HOW_BIG;
    HPALETTE hpalGrey, hpalOld;
    BITMAPINFO32 bmi32 = {{40,HOW_BIG,HOW_BIG,1,32,BI_BITFIELDS,HOW_BIG*HOW_BIG*4,0,0,0,0},
                          {0x00FF0000, 0x0000FF00, 0x000000FF}};

    pBits = (DWORD *) LocalAlloc(LMEM_FIXED, HOW_BIG*HOW_BIG*4);

    if (pBits == NULL)
    {
        DbgPrint("Alloc failed\n");
        return;
    }

    hpalGrey = CreateGreyPalette();
    hpalOld = SelectPalette(hdc, hpalGrey,0);
    RealizePalette(hdc);

    while (ulTemp--)
    {
        pBits[ulTemp] = ulTemp;
    }

    SetDIBitsToDevice(hdc, 0, 0, HOW_BIG, HOW_BIG, 0, 0, 0, HOW_BIG, pBits, (const struct tagBITMAPINFO *)&bmi32, DIB_RGB_COLORS);

    LocalFree(pBits);

    DbgPrint("vTestDIBToScreen \n");

    SelectPalette(hdc, hpalOld, 0);
    DeleteObject(hpalGrey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ft.h ===
/******************************Module*Header*******************************\
* Module Name: ft.h
*
* Contains function prototypes and constants for the FT tests.
*
* Created: 25-May-1991 12:11:02
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#define IDM_ABOUT	   100
#define IDM_TEST1	   101
#define IDM_TEST10	   102
#define IDM_TEST100	   103
#define IDM_TESTALOT	   104
#define IDM_TESTSTOP	   105
#define IDM_ALL 	   106
#define IDM_BITMAP	   107
#define IDM_BRUSH	   108
#define IDM_FILLING	   109
#define IDM_FONT	   110
#define IDM_LINE	   111
#define IDM_MAZE	   112
#define IDM_MAPPING	   113
#define IDM_REGION	   114
#define IDM_EXIT	   115
#define IDM_BREAKON	   116
#define IDM_BREAKOFF	   117
#define IDM_FONTSPEED	   118
#define IDM_DIB 	   119
#define IDM_BM_TEXT	   120
#define IDM_COLOR	   121
#define IDM_BRUSHSPEED	   122
#define IDM_STRESS	   123
#define IDM_TESTFOREVER    125
#define IDM_BLTING	   126
#define IDM_UNICODE	   127
#define IDM_STINK4	   128
#define IDM_PALETTE	   129
#define IDM_STRETCH	   130
#define IDM_GEN_TEXT       131
#define IDM_ESCAPEMENT     132
#define IDM_PRINTERS       133
#define IDM_LFONT	   134
#define IDM_PLGBLT	   135
#define IDM_ODDPAT	   136
#define IDM_JNLTEST        137
#define IDM_SHOWSTATS	   138
#define IDM_1BPP	   139
#define IDM_4BPP	   140
#define IDM_8BPP	   141
#define IDM_16BPP	   142
#define IDM_24BPP	   143
#define IDM_32BPP	   144
#define IDM_COMPAT	   145
#define IDM_DIRECT	   146
#define IDM_CSRSPEED       147
#define IDM_XFORMTXT       148
#define IDM_OUTLINE        149
#define IDM_KERN           150
#define IDM_QLPC           151
#define IDM_POLYTEXT       152
#define IDM_QUICKTEST      153
#define IDM_RESETDC        154
#define IDM_DIBSECTION     155
#define IDM_CHARTEST       156
#define IDM_WIN95API       157
#define IDM_MAPEVENT       158
#define IDM_GRADFILL       159
#define IDM_ALPHABLEND     160
#define CAR_BITMAP         161
#define IDM_ICMOFF         162
#define IDM_ICMONDEF       163
#define IDM_ICMONCUS       164
#define IDM_ICMPALETTE     165

VOID vTestInfiniteStress(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestAll(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestBitmap(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestBlting(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestBMText(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestBrush(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestBrushSpeed(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestColor(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestDIB(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestFilling(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestFonts(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestLines(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestMaze(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestMapping(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestPalettes(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestRegion(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestStretch(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestStress(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestUnicode(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestStink4(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestGenText(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestEscapement(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestPrinters(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestLFONTCleanup(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestPlgBlt(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestOddBlt(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestJournaling(HWND hwnd, HDC hdc, RECT *prcl);
VOID vTestResetDC(HWND hwnd, HDC hdc, RECT *prcl);
VOID vTestFlag(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestCSR(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestXformText(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestGlyphOutline(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestKerning(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestQLPC(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestPolyTextOut(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestQuick(HWND hwnd, HDC hdc, RECT* prcl);
VOID vInitMaze(VOID);
VOID vTestDIBSECTION(HWND hwnd, HDC hdcScreen, RECT* prcl);
void vTestChar(HWND hwnd);
VOID vTestWin95Apis(HWND hwnd, HDC hdcScreen, RECT* prcl);
VOID vMatchOldLogFontToOldRealizationwt(HDC hdc);
VOID vMatchNewLogFontToOldRealizationwt(HDC hdc);
VOID vMapEvent(HWND hwnd, HDC hdc, RECT* prcl);


VOID vTestGradTriangle(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestGradRectVert(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestGradRectHorz(HWND hwnd, HDC hdc, RECT* prcl);
VOID vTestGradFill(HWND hwnd, HDC hdc, RECT* prcl); 
VOID vTestAlphaBlend(HWND hwnd, HDC hdc, RECT* prcl); 



VOID vTestPlg1(HDC hdc);

VOID vSleep(DWORD ulSecs);

typedef VOID (*PFN_FT_TEST)(HWND hwnd, HDC hdc, RECT* prcl);

// Special tests for timing.

VOID vDoPause(ULONG i);
HBITMAP hbmCreateDIBitmap(HDC hdc, ULONG x, ULONG y, ULONG nBitsPixel);

#define NOTUSED(x) x

extern HBRUSH hbrFillCars;
#define RIP(x) {DbgPrint(x); DbgBreakPoint();}
#define ASSERTGDI(x,y) if(!(x)) RIP(y)

// These no longer exist
#define TransparentDIBits(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13) 1
#define AlphaDIBBlend(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13) 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftalpha.c ===
/******************************Module*Header*******************************\
* Module Name: ftalpha.cxx
*
*
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop



/**************************************************************************\
* hCreateAlphaStretchDIB
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/8/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#define FORMAT_ALPHA  0x01
#define FORMAT_32_RGB 0x02
#define FORMAT_32_GRB 0x04
#define FORMAT_16_555 0x08
#define FORMAT_16_565 0x10
#define FORMAT_16_664 0x20

//
// translate RGB [3 3 2] into halftone palette index
//

BYTE gHalftoneColorXlate332[] = {
    0x00,0x5f,0x85,0xfc,0x21,0x65,0xa6,0xfc,0x21,0x65,0xa6,0xcd,0x27,0x6b,0x8a,0xcd,
    0x2d,0x70,0x81,0xd3,0x33,0x76,0x95,0xd9,0x33,0x76,0x95,0xd9,0xfa,0x7b,0x9b,0xfe,
    0x1d,0x60,0xa2,0xfc,0x22,0x66,0x86,0xc8,0x22,0x66,0x86,0xc8,0x28,0x6c,0x8b,0xce,
    0x2e,0x71,0x90,0xd4,0x34,0x77,0x96,0xda,0x34,0x77,0x96,0xda,0xfa,0x7c,0x9c,0xdf,
    0x1d,0x60,0xa2,0xc5,0x22,0x66,0x86,0xc8,0x22,0x13,0x86,0xc8,0x28,0x12,0x8b,0xce,
    0x2e,0x71,0x90,0xd4,0x34,0x77,0x96,0xda,0x34,0x77,0x96,0xda,0x39,0x7c,0x9c,0xdf,
    0x1e,0x61,0x87,0xc5,0x23,0x67,0x8c,0xc9,0x23,0x12,0x8c,0xc9,0x29,0x6d,0xae,0xe6,
    0x2f,0x72,0x91,0xd5,0x35,0x97,0x9d,0xdb,0x35,0x97,0x9d,0xdb,0x39,0xe4,0xc0,0xe8,

    0x1f,0x62,0x83,0xc6,0x24,0x68,0x82,0xca,0x24,0x68,0x82,0xca,0x2a,0x6e,0x8d,0xd0,
    0x30,0x73,0x92,0xd6,0x36,0x78,0xf7,0xdc,0x36,0x78,0x98,0xdc,0x3a,0x7d,0x9e,0xe1,
    0x20,0x63,0x84,0x80,0x25,0x69,0x88,0xcb,0x25,0x69,0x88,0xcb,0x2b,0x6f,0x8e,0xd1,
    0x31,0x74,0xf7,0xd7,0x37,0x79,0xef,0x09,0x37,0x79,0x08,0xdd,0x3b,0x7e,0x9f,0xe2,
    0x20,0x63,0x84,0x80,0x25,0x69,0x88,0xcb,0x25,0x69,0x88,0xcb,0x2b,0x6f,0x8e,0xd1,
    0x31,0x74,0x93,0xd7,0x37,0x79,0x99,0xdd,0x37,0x79,0x99,0xdd,0x3b,0x7e,0x9f,0xe2,
    0xf9,0x64,0x89,0xfd,0x26,0x6a,0x8f,0xcc,0x26,0x17,0x8f,0xcc,0x2c,0xe3,0xb1,0xe7,
    0x32,0x75,0x94,0xd8,0x38,0x7a,0x9a,0xde,0x38,0x7a,0x9a,0xde,0xfb,0xe5,0xa0,0xff
    };

//
// inter-test delay
//

ULONG  gAlphaSleep = 100;

ULONG DefPalette[20] = { 0x00000000,0x00000080,0x00008000,0x00008080,
                         0x00800000,0x00800080,0x00808000,0x00c0c0c0,
                         0x00c0dcc0,0x00f0caa6,0x00f0fbff,0x00a4a0a0,
                         0x00808080,0x000000ff,0x0000ff00,0x0000ffff,
                         0x00ff0000,0x00ff00ff,0x00ffff00,0x00ffffff
                       };
ULONG DefPaletteRGBQUAD[20] = { 0x00000000,0x00800000,0x00008000,0x00808000,
                                0x00000080,0x00800080,0x00008080,0x00c0c0c0,
                                0x00c0dcc0,0x00a6caf0,0x00fffbf0,0x00a0a0a4,
                                0x00808080,0x00ff0000,0x0000ff00,0x00ffff00,
                                0x000000ff,0x00ff00ff,0x0000ffff,0x00ffffff
                              };

ULONG htPalette[256] = {
     0x00000000,0x00000080,0x00008000,0x00008080,
     0x00800000,0x00800080,0x00808000,0x00c0c0c0,
     0x00c0dcc0,0x00f0caa6,0x04040404,0x04080808,
     0x040c0c0c,0x04111111,0x04161616,0x041c1c1c,
     0x04222222,0x04292929,0x04555555,0x044d4d4d,
     0x04424242,0x04393939,0x04807CFF,0x045050FF,
     0x049300D6,0x04FFECCC,0x04C6D6EF,0x04D6E7E7,
     0x0490A9AD,0x04000033,0x04000066,0x04000099,
     0x040000cc,0x04003300,0x04003333,0x04003366,
     0x04003399,0x040033cc,0x040033ff,0x04006600,
     0x04006633,0x04006666,0x04006699,0x040066cc,
     0x040066ff,0x04009900,0x04009933,0x04009966,
     0x04009999,0x040099cc,0x040099ff,0x0400cc00,
     0x0400cc33,0x0400cc66,0x0400cc99,0x0400cccc,
     0x0400ccff,0x0400ff66,0x0400ff99,0x0400ffcc,
     0x04330000,0x04330033,0x04330066,0x04330099,
     0x043300cc,0x043300ff,0x04333300,0x04333333,
     0x04333366,0x04333399,0x043333cc,0x043333ff,
     0x04336600,0x04336633,0x04336666,0x04336699,
     0x043366cc,0x043366ff,0x04339900,0x04339933,
     0x04339966,0x04339999,0x043399cc,0x043399ff,
     0x0433cc00,0x0433cc33,0x0433cc66,0x0433cc99,
     0x0433cccc,0x0433ccff,0x0433ff33,0x0433ff66,
     0x0433ff99,0x0433ffcc,0x0433ffff,0x04660000,
     0x04660033,0x04660066,0x04660099,0x046600cc,
     0x046600ff,0x04663300,0x04663333,0x04663366,
     0x04663399,0x046633cc,0x046633ff,0x04666600,
     0x04666633,0x04666666,0x04666699,0x046666cc,
     0x04669900,0x04669933,0x04669966,0x04669999,
     0x046699cc,0x046699ff,0x0466cc00,0x0466cc33,
     0x0466cc99,0x0466cccc,0x0466ccff,0x0466ff00,
     0x0466ff33,0x0466ff99,0x0466ffcc,0x04cc00ff,
     0x04ff00cc,0x04999900,0x04993399,0x04990099,
     0x049900cc,0x04990000,0x04993333,0x04990066,
     0x049933cc,0x049900ff,0x04996600,0x04996633,
     0x04993366,0x04996699,0x049966cc,0x049933ff,
     0x04999933,0x04999966,0x04999999,0x049999cc,
     0x049999ff,0x0499cc00,0x0499cc33,0x0466cc66,
     0x0499cc99,0x0499cccc,0x0499ccff,0x0499ff00,
     0x0499ff33,0x0499cc66,0x0499ff99,0x0499ffcc,
     0x0499ffff,0x04cc0000,0x04990033,0x04cc0066,
     0x04cc0099,0x04cc00cc,0x04993300,0x04cc3333,
     0x04cc3366,0x04cc3399,0x04cc33cc,0x04cc33ff,
     0x04cc6600,0x04cc6633,0x04996666,0x04cc6699,
     0x04cc66cc,0x049966ff,0x04cc9900,0x04cc9933,
     0x04cc9966,0x04cc9999,0x04cc99cc,0x04cc99ff,
     0x04cccc00,0x04cccc33,0x04cccc66,0x04cccc99,
     0x04cccccc,0x04ccccff,0x04ccff00,0x04ccff33,
     0x0499ff66,0x04ccff99,0x04ccffcc,0x04ccffff,
     0x04cc0033,0x04ff0066,0x04ff0099,0x04cc3300,
     0x04ff3333,0x04ff3366,0x04ff3399,0x04ff33cc,
     0x04ff33ff,0x04ff6600,0x04ff6633,0x04cc6666,
     0x04ff6699,0x04ff66cc,0x04cc66ff,0x04ff9900,
     0x04ff9933,0x04ff9966,0x04ff9999,0x04ff99cc,
     0x04ff99ff,0x04ffcc00,0x04ffcc33,0x04ffcc66,
     0x04ffcc99,0x04ffcccc,0x04ffccff,0x04ffff33,
     0x04ccff66,0x04ffff99,0x04ffffcc,0x046666ff,
     0x0466ff66,0x0466ffff,0x04ff6666,0x04ff66ff,
     0x04ffff66,0x042100A5,0x045f5f5f,0x04777777,
     0x04868686,0x04969696,0x04cbcbcb,0x04b2b2b2,
     0x04d7d7d7,0x04dddddd,0x04e3e3e3,0x04eaeaea,
     0x04f1f1f1,0x04f8f8f8,0x00f0fbff,0x00a4a0a0,
     0x00808080,0x000000ff,0x0000ff00,0x0000ffff,
     0x00ff0000,0x00ff00ff,0x00ffff00,0x00ffffff
     };

ULONG htPaletteRGBQUAD[256] = {
     0x00000000,0x00800000,0x00008000,0x00808000,
     0x00000080,0x00800080,0x00008080,0x00c0c0c0,
     0x00c0dcc0,0x00a6caf0,0x04040404,0x04080808,
     0x040c0c0c,0x04111111,0x04161616,0x041c1c1c,
     0x04222222,0x04292929,0x04555555,0x044d4d4d,
     0x04424242,0x04393939,0x04FF7C80,0x04FF5050,
     0x04D60093,0x04CCECFF,0x04EFD6C6,0x04E7E7D6,
     0x04ADA990,0x04330000,0x04660000,0x04990000,
     0x04cc0000,0x04003300,0x04333300,0x04663300,
     0x04993300,0x04cc3300,0x04ff3300,0x04006600,
     0x04336600,0x04666600,0x04996600,0x04cc6600,
     0x04ff6600,0x04009900,0x04339900,0x04669900,
     0x04999900,0x04cc9900,0x04ff9900,0x0400cc00,
     0x0433cc00,0x0466cc00,0x0499cc00,0x04cccc00,
     0x04ffcc00,0x0466ff00,0x0499ff00,0x04ccff00,
     0x04000033,0x04330033,0x04660033,0x04990033,
     0x04cc0033,0x04ff0033,0x04003333,0x04333333,
     0x04663333,0x04993333,0x04cc3333,0x04ff3333,
     0x04006633,0x04336633,0x04666633,0x04996633,
     0x04cc6633,0x04ff6633,0x04009933,0x04339933,
     0x04669933,0x04999933,0x04cc9933,0x04ff9933,
     0x0400cc33,0x0433cc33,0x0466cc33,0x0499cc33,
     0x04cccc33,0x04ffcc33,0x0433ff33,0x0466ff33,
     0x0499ff33,0x04ccff33,0x04ffff33,0x04000066,
     0x04330066,0x04660066,0x04990066,0x04cc0066,
     0x04ff0066,0x04003366,0x04333366,0x04663366,
     0x04993366,0x04cc3366,0x04ff3366,0x04006666,
     0x04336666,0x04666666,0x04996666,0x04cc6666,
     0x04009966,0x04339966,0x04669966,0x04999966,
     0x04cc9966,0x04ff9966,0x0400cc66,0x0433cc66,
     0x0499cc66,0x04cccc66,0x04ffcc66,0x0400ff66,
     0x0433ff66,0x0499ff66,0x04ccff66,0x04ff00cc,
     0x04cc00ff,0x04009999,0x04993399,0x04990099,
     0x04cc0099,0x04000099,0x04333399,0x04660099,
     0x04cc3399,0x04ff0099,0x04006699,0x04336699,
     0x04663399,0x04996699,0x04cc6699,0x04ff3399,
     0x04339999,0x04669999,0x04999999,0x04cc9999,
     0x04ff9999,0x0400cc99,0x0433cc99,0x0466cc66,
     0x0499cc99,0x04cccc99,0x04ffcc99,0x0400ff99,
     0x0433ff99,0x0466cc99,0x0499ff99,0x04ccff99,
     0x04ffff99,0x040000cc,0x04330099,0x046600cc,
     0x049900cc,0x04cc00cc,0x04003399,0x043333cc,
     0x046633cc,0x049933cc,0x04cc33cc,0x04ff33cc,
     0x040066cc,0x043366cc,0x04666699,0x049966cc,
     0x04cc66cc,0x04ff6699,0x040099cc,0x043399cc,
     0x046699cc,0x049999cc,0x04cc99cc,0x04ff99cc,
     0x0400cccc,0x0433cccc,0x0466cccc,0x0499cccc,
     0x04cccccc,0x04ffcccc,0x0400ffcc,0x0433ffcc,
     0x0466ff99,0x0499ffcc,0x04ccffcc,0x04ffffcc,
     0x043300cc,0x046600ff,0x049900ff,0x040033cc,
     0x043333ff,0x046633ff,0x049933ff,0x04cc33ff,
     0x04ff33ff,0x040066ff,0x043366ff,0x046666cc,
     0x049966ff,0x04cc66ff,0x04ff66cc,0x040099ff,
     0x043399ff,0x046699ff,0x049999ff,0x04cc99ff,
     0x04ff99ff,0x0400ccff,0x0433ccff,0x0466ccff,
     0x0499ccff,0x04ccccff,0x04ffccff,0x0433ffff,
     0x0466ffcc,0x0499ffff,0x04ccffff,0x04ff6666,
     0x0466ff66,0x04ffff66,0x046666ff,0x04ff66ff,
     0x0466ffff,0x04A50021,0x045f5f5f,0x04777777,
     0x04868686,0x04969696,0x04cbcbcb,0x04b2b2b2,
     0x04d7d7d7,0x04dddddd,0x04e3e3e3,0x04eaeaea,
     0x04f1f1f1,0x04f8f8f8,0x00fffbf0,0x00a0a0a4,
     0x00808080,0x00ff0000,0x0000ff00,0x00ffff00,
     0x000000ff,0x00ff00ff,0x0000ffff,0x00ffffff
     };


ULONG    ulBpp[] = {          32,           32,            32,24,           16,           16,           16,8,4,1,0};
ULONG    ulFor[] = {FORMAT_ALPHA,FORMAT_32_RGB, FORMAT_32_GRB, 0,FORMAT_16_555,FORMAT_16_565,FORMAT_16_664,0,0,0,0};
PCHAR    pFormatStr[] = {
                        " 32 bpp RGBA",
                        " 32 bpp RGB",
                        " 32 bpp GRB",
                        " 24 bpp",
                        " 16 bpp 555",
                        " 16 bpp 565",
                        " 16 BPP 664",
                        "  8 bpp DIB_RGB_COLORS",
                        "  4 bpp DIB_RGB_COLORS",
                        "  1 bpp DIB_RGB_COLORS",
                        };

ULONG    ulBppDIB[] = {          32,32,24,           16,           16,8,8,4,4,1,1,0};
ULONG    ulForDIB[] = {FORMAT_ALPHA, 0, 0,FORMAT_16_555,FORMAT_16_565,0,1,0,1,0,1,0};

PCHAR    pFormatStrDIB[] = {
                        " 32 bpp RGBA",
                        " 32 bpp no Alpha",
                        " 24 bpp",
                        " 16 bpp 555",
                        " 16 bpp 565",
                        "  8 bpp DIB_RGB_COLORS",
                        "  8 bpp DIB_PAL_COLORS",
                        "  4 bpp DIB_RGB_COLORS",
                        "  4 bpp DIB_PAL_COLORS",
                        "  1 bpp DIB_RGB_COLORS",
                        "  1 bpp DIB_PAL_COLORS"
                        };

/**************************************************************************\
* hCreateAlphaStretchBitmap - create and init DIBSection based on input
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/9/1997 Mark Enstrom [marke]
*
\**************************************************************************/

HBITMAP
hCreateAlphaStretchBitmap(
    HDC   hdc,
    ULONG BitsPerPixel,
    ULONG ColorFormat,
    ULONG  xDib,
    ULONG  yDib
    )
{
    PBITMAPINFO pbmi;
    ULONG       ux,uy;
    PULONG      pDib;
    HBITMAP     hdib = NULL;
    LONG        Compression = BI_RGB;

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

    if (pbmi)
    {
        PULONG pulMask = (PULONG)&pbmi->bmiColors[0];

        //
        // prepare compression and color table
        //

        if ((BitsPerPixel == 32) && (ColorFormat & FORMAT_32_RGB))
        {
            pulMask[0] = 0x0000ff;
            pulMask[1] = 0x00ff00;
            pulMask[2] = 0xff0000;
            Compression = BI_BITFIELDS;
        }
        else if ((BitsPerPixel == 32) && ((ColorFormat & FORMAT_32_GRB)))
        {
            pulMask[0] = 0x00ff00;
            pulMask[1] = 0xff0000;
            pulMask[2] = 0x0000ff;
            Compression = BI_BITFIELDS;
        }
        else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_565))
        {
            pulMask[0] = 0xf800;
            pulMask[1] = 0x07e0;
            pulMask[2] = 0x001f;
            Compression = BI_BITFIELDS;
        }
        else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_555))
        {
            pulMask[0] = 0x7c00;
            pulMask[1] = 0x03e0;
            pulMask[2] = 0x001f;
            Compression = BI_BITFIELDS;
        }
        else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_664))
        {
            pulMask[0] = 0xFC00;
            pulMask[1] = 0x03F0;
            pulMask[2] = 0x000f;
            Compression = BI_BITFIELDS;
        }
        else if (BitsPerPixel == 8)
        {
            ULONG ulIndex;

            for (ulIndex=0;ulIndex<256;ulIndex++)
            {
                pulMask[ulIndex] = htPaletteRGBQUAD[ulIndex];
            }
        }
        else if (BitsPerPixel == 4)
        {
            ULONG ulIndex;

            for (ulIndex=0;ulIndex<8;ulIndex++)
            {
                pulMask[ulIndex]    = DefPaletteRGBQUAD[ulIndex];
                pulMask[15-ulIndex] = DefPaletteRGBQUAD[19-ulIndex];
            }
        }
        else if (BitsPerPixel == 1)
        {
            pulMask[0] = DefPaletteRGBQUAD[0];
            pulMask[1] = DefPaletteRGBQUAD[19];
        }

        //
        // create DIB
        //

        pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth           = xDib;
        pbmi->bmiHeader.biHeight          = yDib;
        pbmi->bmiHeader.biPlanes          = 1;
        pbmi->bmiHeader.biBitCount        = (USHORT)BitsPerPixel;
        pbmi->bmiHeader.biCompression     = Compression;
        pbmi->bmiHeader.biSizeImage       = 0;
        pbmi->bmiHeader.biXPelsPerMeter   = 0;
        pbmi->bmiHeader.biYPelsPerMeter   = 0;
        pbmi->bmiHeader.biClrUsed         = 0;
        pbmi->bmiHeader.biClrImportant    = 0;

        hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

        if (hdib == NULL)
        {
            CHAR tmsg[256];

            //wsprintf(tmsg,"Format = %libpp, Comp = %li",BitsPerPixel,Compression);
            //MessageBox(NULL,"Can't create stretch DIBSECTION",tmsg,MB_OK);
        }
        else
        {

            //
            // init 32 bpp dib
            //

            if ((BitsPerPixel == 32) && (ColorFormat & FORMAT_ALPHA))
            {
                PULONG ptmp = pDib;

                for (uy=0;uy<yDib;uy++)
                {
                    for (ux=0;ux<xDib;ux++)
                    {
                        BYTE cx   = (BYTE)ux & 0x7f;
                        BYTE cy   = (BYTE)uy & 0x7f;
                        BYTE blue  = (cx*2);
                        BYTE green = (cy*2);
                        BYTE red   = 255 - cx - cy;
                        BYTE alpha = 0xff;
                        *ptmp++ = (alpha << 24) | (red << 16) | (green << 8) | (blue);
                    }
                }
            }
            else if ((BitsPerPixel == 32) && (ColorFormat & FORMAT_32_RGB))
            {
                PULONG ptmp = pDib;

                for (uy=0;uy<yDib;uy++)
                {
                    for (ux=0;ux<xDib;ux++)
                    {
                        BYTE cx   = (BYTE)ux & 0x7f;
                        BYTE cy   = (BYTE)uy & 0x7f;
                        BYTE blue  = (cx*2);
                        BYTE green = (cy*2);
                        BYTE red   = 255 - cx - cy;
                        *ptmp++ = (blue << 16) | (green << 8) | (red);
                    }
                }
            }
            else if ((BitsPerPixel == 32) && (ColorFormat & FORMAT_32_GRB))
            {
                PULONG ptmp = pDib;

                for (uy=0;uy<yDib;uy++)
                {
                    for (ux=0;ux<xDib;ux++)
                    {
                        BYTE cx   = (BYTE)ux & 0x7f;
                        BYTE cy   = (BYTE)uy & 0x7f;
                        BYTE blue  = (cx*2);
                        BYTE green = (cy*2);
                        BYTE red   = 255 - cx - cy;
                        *ptmp++ = (blue) | (red << 8) | (green << 16);
                    }
                }
            }
            else if (BitsPerPixel == 24)
            {
                PBYTE ptmp  = (PBYTE)pDib;
                PBYTE pscan = ptmp;
                LONG  Delta = ((yDib * 3) + 3) & ~3;

                //
                // since scan line is 128, alignment works. If width changes, this breaks
                //

                for (uy=0;uy<yDib;uy++)
                {
                    ptmp = pscan;
                    for (ux=0;ux<xDib;ux++)
                    {
                        BYTE cx   = (BYTE)ux & 0x7f;
                        BYTE cy   = (BYTE)uy & 0x7f;
                        BYTE blue  = (cx*2);
                        BYTE green = (cy*2);
                        BYTE red   = 255 - cx - cy;
                        *ptmp++ = (blue);
                        *ptmp++ = (green);
                        *ptmp++ = (red);
                    }
                    pscan += Delta;
                }
            }
            else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_565))
            {
                PUSHORT ptmp = (PUSHORT)pDib;

                for (uy=0;uy<yDib;uy++)
                {
                    for (ux=0;ux<xDib;ux++)
                    {
                        BYTE cx   = (BYTE)ux & 0x7f;
                        BYTE cy   = (BYTE)uy & 0x7f;
                        BYTE blue  = (cx*2);
                        BYTE green = (cy*2);
                        BYTE red   = 255 - cx - cy;
                        BYTE alpha = 0xff;
                        *ptmp++ = ((red & 0xf8)   << 8) |
                                  ((green & 0xfc) << 3) |
                                  (blue >> 3);
                    }
                }
            }
            else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_555))
            {
                PUSHORT ptmp = (PUSHORT)pDib;

                for (uy=0;uy<yDib;uy++)
                {
                    for (ux=0;ux<xDib;ux++)
                    {
                        BYTE cx   = (BYTE)ux & 0x7f;
                        BYTE cy   = (BYTE)uy & 0x7f;
                        BYTE blue  = (cx*2);
                        BYTE green = (cy*2);
                        BYTE red   = 255 - cx - cy;
                        BYTE alpha = 0xff;
                        *ptmp++ = ((red & 0xf8)   << 7) |
                                  ((green & 0xf8) << 2) |
                                  (blue >> 3);
                    }
                }
            }
            else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_664))
            {
                PUSHORT ptmp = (PUSHORT)pDib;

                for (uy=0;uy<yDib;uy++)
                {
                    for (ux=0;ux<xDib;ux++)
                    {
                        BYTE cx   = (BYTE)ux & 0x7f;
                        BYTE cy   = (BYTE)uy & 0x7f;
                        BYTE blue  = (cx*2);
                        BYTE green = (cy*2);
                        BYTE red   = 255 - cx - cy;
                        BYTE alpha = 0xff;
                        *ptmp++ = ((red & 0xfc)   << 8) |
                                  ((green & 0xfc) << 2) |
                                  (blue >> 4);
                    }
                }
            }
            else if (BitsPerPixel == 8)
            {
                PBYTE ptmp = (PBYTE)pDib;

                for (uy=0;uy<yDib;uy++)
                {
                    for (ux=0;ux<xDib;ux++)
                    {
                        BYTE cx   = (BYTE)ux & 0x7f;
                        BYTE cy   = (BYTE)uy & 0x7f;
                        BYTE blue  = (cx*2);
                        BYTE green = (cy*2);
                        BYTE red   = 255 - cx - cy;
                        *ptmp++ = gHalftoneColorXlate332[(red & 0xe0) | ((green & 0xe0) >> 3) | ((blue & 0xc0) >> 6)];
                    }
                }
            }
            else if (BitsPerPixel == 4)
            {
                PBYTE ptmp = (PBYTE)pDib;

                for (uy=0;uy<yDib;uy++)
                {
                    for (ux=0;ux<(xDib/2);ux++)
                    {
                        BYTE cx   = (BYTE)ux & 0x7f;
                        BYTE cy   = (BYTE)uy & 0x7f;
                        BYTE Color = ((cx & 0x60) >> 3) | ((cy >> 5));

                        *ptmp++ = Color | (Color << 4);
                    }
                }
            }
            else if (BitsPerPixel == 1)
            {
                PBYTE ptmp = (PBYTE)pDib;

                for (uy=0;uy<yDib;uy++)
                {
                    for (ux=0;ux<(xDib/8);ux++)
                    {
                        *ptmp++ = 0;
                    }
                }
            }
        }

        //
        // draw text into bitmap
        //

        if (hdib)
        {

            ULONG             ux,uy;

            HDC hdcm  = CreateCompatibleDC(hdc);

            //
            // display over black
            //

            HPALETTE hpal = CreateHalftonePalette(hdc);

            SelectObject(hdcm,hdib);

            SelectPalette(hdcm,hpal,FALSE);

            RealizePalette(hdcm);

            SetTextColor(hdcm,RGB(255,255,255));
            SetBkMode(hdcm,TRANSPARENT);

            TextOut(hdcm,0,  0," 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F",47);
            TextOut(hdcm,0, 10,"10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F",47);
            TextOut(hdcm,0, 20,"20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F",47);
            TextOut(hdcm,0, 30,"30 33 32 33 34 33 36 37 38 39 3A 3B 3C 3D 3E 3F",47);
            TextOut(hdcm,0, 40,"40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F",47);
            TextOut(hdcm,0, 50,"50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F",47);
            TextOut(hdcm,0, 60,"60 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F",47);
            TextOut(hdcm,0, 70,"70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F",47);
            TextOut(hdcm,0, 80,"80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F",47);
            TextOut(hdcm,0, 90,"90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F",47);
            TextOut(hdcm,0,100,"a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 AA AB AC AD AE AF",47);
            TextOut(hdcm,0,110,"b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 BA BB BC BD BE BF",47);

            DeleteDC(hdcm);
            DeleteObject(hpal);
        }

        LocalFree(pbmi);
    }

    return(hdib);
}

/******************************Public*Routine******************************\
* vTestAlphaStretch - routine is called by format specific routines to do
* all drawing
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vRunAlphaStretch(
    HDC     hdc,
    HBITMAP hdib
    )
{
    ULONG         xpos  = 10;
    ULONG         ypos  = 10;
    ULONG         dy    = 136;
    ULONG         dx    = 128+5;
    HPALETTE      hpal;
    HPALETTE      hpalOld;
    BLENDFUNCTION BlendFunction;
    BYTE          Alphas[] = {64,128,160,192,224,255};
    RECT          rect;
    PBITMAPINFO   pbmi;
    ULONG         ux,uy;
    PULONG        pDib;
    HDC           hdcm  = CreateCompatibleDC(hdc);

    //
    // Clear screen
    //

    SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));
    PatBlt(hdc,0,0,2000,2000,PATCOPY);

    hpal = CreateHalftonePalette(hdc);

    SelectObject(hdcm,hdib);

    SelectPalette(hdcm,hpal,FALSE);

    RealizePalette(hdcm);

    SetTextColor(hdc,RGB(255,255,255));
    SetBkMode(hdc,TRANSPARENT);
    SelectObject(hdc,hbrFillCars);

    BlendFunction.BlendOp             = AC_SRC_OVER;
    BlendFunction.AlphaFormat         = 0;
    BlendFunction.SourceConstantAlpha = Alphas[3];

    xpos = 10;

    TextOut(hdc,xpos,ypos,"- - 128 128,   0   0 128,128",28);

    xpos += 250;

    TextOut(hdc,xpos,ypos,"- - 128 128,   0   0  64, 64",28);

    xpos += 250;

    TextOut(hdc,xpos,ypos,"- - 128 128,   0   0 256,256",28);

    xpos =  10;
    ypos += 12;

    PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
    AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);

    xpos += 250;

    PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
    AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm, 0,0,64,64,BlendFunction);

    xpos += 250;

    PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
    AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm, 0,0,256,256,BlendFunction);

    xpos += 250;
    BitBlt(hdc,xpos,ypos,128,128,hdcm,0,0,SRCCOPY);

    ypos += 180;
    xpos  = 10;

    TextOut(hdc,xpos,ypos,"- - 128 128, -64   0 128,128",28);
    xpos += 250;

    TextOut(hdc,xpos,ypos,"- - 128 128,   0 -64 128,128",28);
    xpos += 250;

    TextOut(hdc,xpos,ypos,"- - 128 128, -64 -64 128,128",28);

    ypos += 12;
    xpos = 10;

    PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
    AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm,-64,0,128,128,BlendFunction);

    xpos += 250;

    PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
    AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm,0,-64,128,128,BlendFunction);

    xpos += 250;

    PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
    AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm, -64,-64,128,128,BlendFunction);

    xpos += 250;
    BitBlt(hdc,xpos,ypos,128,128,hdcm,0,0,SRCCOPY);

    ypos += 180;
    xpos  = 10;

    TextOut(hdc,xpos,ypos,"- - 128 128, -32 -32 192,192",28);
    xpos += 250;

    TextOut(hdc,xpos,ypos,"- - 128 128,   0 -32 128,192",28);
    xpos += 250;

    TextOut(hdc,xpos,ypos,"- - 128 128, -32   0 192,128",28);

    ypos += 12;
    xpos = 10;

    PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
    AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm,-32,-32,192,192,BlendFunction);

    xpos += 250;

    PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
    AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm,0,-32,128,192,BlendFunction);

    xpos += 250;

    PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
    AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm, -32,0,192,128,BlendFunction);

    xpos += 250;
    BitBlt(hdc,xpos,ypos,128,128,hdcm,0,0,SRCCOPY);

    ypos += 180;
    xpos  = 10;

    TextOut(hdc,xpos,ypos,"- - 128 128, -32 -32 42,42",28);
    xpos += 250;

    TextOut(hdc,xpos,ypos,"128-10,128-10  10 10 41   5 ",28);
    xpos += 250;

    TextOut(hdc,xpos,ypos,"- - 128 128, -1000,-1000,100",28);

    ypos += 12;
    xpos = 10;

    PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
    AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm,-32,-32,42,42,BlendFunction);

    xpos += 250;

    PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
    AlphaBlend(hdc,xpos+128-10,ypos+128-10,10,10,hdcm,10,10,41,5,BlendFunction);

    xpos += 250;

    PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
    AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm, -1000,-10000,1000,1000,BlendFunction);

    xpos += 250;
    BitBlt(hdc,xpos,ypos,128,128,hdcm,0,0,SRCCOPY);

    //
    // free objects
    //

    DeleteDC(hdcm);
    DeleteObject(hpal);
}


/**************************************************************************\
* pbmiCreateAlphaStretchDIB - create bitmapinfo and alloc and init bits
*                             based on input
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/9/1997 Mark Enstrom [marke]
*
\**************************************************************************/

PBITMAPINFO
pbmiCreateAlphaStretchDIB(
    HDC      hdc,
    ULONG    BitsPerPixel,
    ULONG    ColorFormat,
    PVOID   *pBits,
    HBITMAP *phdib
    )
{
    PBITMAPINFO pbmi;
    BYTE        ux,uy;
    HBITMAP     hdib = NULL;
    LONG        Compression = BI_RGB;
    PULONG      pDib = NULL;
    LONG        BitmapSize = 0;
    ULONG       iUsage = DIB_RGB_COLORS;

    //
    // prepare src DC log colors
    //

    HPALETTE hpal = CreateHalftonePalette(hdc);
    HPALETTE hpalOld = SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    //
    // alloc pbmi, caller must free
    //

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

    if (pbmi)
    {
        PULONG pulMask = (PULONG)&pbmi->bmiColors[0];


        //
        // prepare compression and color table
        //

        if ((BitsPerPixel == 32) && (!(ColorFormat & FORMAT_ALPHA)))
        {
            pulMask[0] = 0x0000ff;
            pulMask[1] = 0x00ff00;
            pulMask[2] = 0xff0000;
            Compression = BI_BITFIELDS;
        }
        else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_565))
        {
            pulMask[0] = 0xf800;
            pulMask[1] = 0x07e0;
            pulMask[2] = 0x001f;
            Compression = BI_BITFIELDS;
        }
        else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_555))
        {
            pulMask[0] = 0x7c00;
            pulMask[1] = 0x03e0;
            pulMask[2] = 0x001f;
            Compression = BI_BITFIELDS;
        }
        else if ((BitsPerPixel == 8) && (ColorFormat == DIB_RGB_COLORS))
        {
            ULONG ulIndex;

            for (ulIndex=0;ulIndex<256;ulIndex++)
            {
                pulMask[ulIndex] = htPaletteRGBQUAD[ulIndex];
            }
        }
        else if ((BitsPerPixel == 8) && (ColorFormat == DIB_PAL_COLORS))
        {
            ULONG ulIndex;
            PUSHORT pusIndex = (PUSHORT)pulMask;

            for (ulIndex=0;ulIndex<256;ulIndex++)
            {
                pusIndex[ulIndex] = (USHORT)ulIndex;
            }
            iUsage = DIB_PAL_COLORS;
        }
        else if ((BitsPerPixel == 4) && (ColorFormat == DIB_RGB_COLORS))
        {
            ULONG ulIndex;

            for (ulIndex=0;ulIndex<8;ulIndex++)
            {
                pulMask[ulIndex]    = DefPaletteRGBQUAD[ulIndex];
                pulMask[15-ulIndex] = DefPaletteRGBQUAD[20-ulIndex];
            }
            BitmapSize = (128 * 128)/2;
        }
        else if ((BitsPerPixel == 4) && (ColorFormat == DIB_PAL_COLORS))
        {
            ULONG ulIndex;
            PUSHORT pusIndex = (PUSHORT)pulMask;

            for (ulIndex=0;ulIndex<8;ulIndex++)
            {
                pusIndex[ulIndex] = (USHORT)ulIndex;
                pusIndex[15-ulIndex] = (USHORT)(255-ulIndex);
            }
            iUsage = DIB_PAL_COLORS;
        }
        else if ((BitsPerPixel == 1) && (ColorFormat == DIB_RGB_COLORS))
        {
            pulMask[0] = DefPaletteRGBQUAD[0];
            pulMask[1] = DefPalette[19];
            BitmapSize = (128 * 128)/8;
        }
        else if ((BitsPerPixel == 1) && (ColorFormat == DIB_PAL_COLORS))
        {
            ULONG ulIndex;
            PUSHORT pusIndex = (PUSHORT)pulMask;

            pusIndex[0] = 0;
            pusIndex[1] = 255;
            iUsage = DIB_PAL_COLORS;
        }

        //
        // init bitmap info
        //

        pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth           = 128;
        pbmi->bmiHeader.biHeight          = 128;
        pbmi->bmiHeader.biPlanes          = 1;
        pbmi->bmiHeader.biBitCount        = (USHORT)BitsPerPixel;
        pbmi->bmiHeader.biCompression     = Compression;
        pbmi->bmiHeader.biSizeImage       = 0;
        pbmi->bmiHeader.biXPelsPerMeter   = 0;
        pbmi->bmiHeader.biYPelsPerMeter   = 0;
        pbmi->bmiHeader.biClrUsed         = 0;
        pbmi->bmiHeader.biClrImportant    = 0;

        hdib  = CreateDIBSection(hdc,pbmi,iUsage,(VOID **)&pDib,NULL,0);

        if (hdib == NULL)
        {
            CHAR tmsg[256];

            //wsprintf(tmsg,"Format = %libpp, Comp = %li",BitsPerPixel,Compression);
            //MessageBox(NULL,"Can't create stretchDIB DIBSECTION",tmsg,MB_OK);
            //LocalFree(pbmi);
            //return(NULL);
        }
        else
        {
            //
            // init 32 bpp dib
            //

            if ((BitsPerPixel == 32) && (ColorFormat & FORMAT_ALPHA))
            {
                PULONG ptmp = pDib;

                for (uy=0;uy<128;uy++)
                {
                    for (ux=0;ux<128;ux++)
                    {
                        BYTE blue  = (ux*2);
                        BYTE green = (uy*2);
                        BYTE red   = 255 - ux - uy;
                        BYTE alpha = 0xff;
                        *ptmp++ = (alpha << 24) | (red << 16) | (green << 8) | (blue);
                    }
                }
            }
            else if (BitsPerPixel == 32)
            {
                PULONG ptmp = pDib;

                for (uy=0;uy<128;uy++)
                {
                    for (ux=0;ux<128;ux++)
                    {
                        BYTE blue  = (ux*2);
                        BYTE green = (uy*2);
                        BYTE red   = 255 - ux - uy;
                        *ptmp++ = (blue << 16) | (green << 8) | (red);
                    }
                }
            }
            else if (BitsPerPixel == 24)
            {
                PBYTE ptmp = (PBYTE)pDib;

                //
                // since scan line is 128, alignment works. If width changes, this breaks
                //

                for (uy=0;uy<128;uy++)
                {
                    for (ux=0;ux<128;ux++)
                    {
                        BYTE blue  = (ux*2);
                        BYTE green = (uy*2);
                        BYTE red   = 255 - ux - uy;
                        *ptmp++ = (blue);
                        *ptmp++ = (green);
                        *ptmp++ = (red);
                    }
                }
            }
            else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_565))
            {
                PUSHORT ptmp = (PUSHORT)pDib;

                for (uy=0;uy<128;uy++)
                {
                    for (ux=0;ux<128;ux++)
                    {
                        BYTE blue  = (ux*2);
                        BYTE green = (uy*2);
                        BYTE red   = 255 - ux - uy;
                        BYTE alpha = 0xff;
                        *ptmp++ = ((red & 0xf8)   << 8) |
                                  ((green & 0xfc) << 3) |
                                  (blue >> 3);
                    }
                }
            }
            else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_555))
            {
                PUSHORT ptmp = (PUSHORT)pDib;

                for (uy=0;uy<128;uy++)
                {
                    for (ux=0;ux<128;ux++)
                    {
                        BYTE blue  = (ux*2);
                        BYTE green = (uy*2);
                        BYTE red   = 255 - ux - uy;
                        BYTE alpha = 0xff;
                        *ptmp++ = ((red & 0xf8)   << 7) |
                                  ((green & 0xf8) << 2) |
                                  (blue >> 3);
                    }
                }
            }
            else if (BitsPerPixel == 8)
            {
                PBYTE ptmp = (PBYTE)pDib;

                for (uy=0;uy<128;uy++)
                {
                    for (ux=0;ux<128;ux++)
                    {
                        BYTE blue  = (ux*2);
                        BYTE green = (uy*2);
                        BYTE red   = 255 - ux - uy;
                        *ptmp++ = gHalftoneColorXlate332[(red & 0xe0) | ((green & 0xe0) >> 3) | ((blue & 0xc0) >> 6)];
                    }
                }
            }
            else if (BitsPerPixel == 4)
            {
                PBYTE ptmp = (PBYTE)pDib;

                for (uy=0;uy<128;uy++)
                {
                    for (ux=0;ux<(128/2);ux++)
                    {
                        BYTE Color = ((ux & 0x60) >> 3) | ((uy >> 5));

                        *ptmp++ = Color | (Color << 4);
                    }
                }
            }
            else if (BitsPerPixel == 1)
            {
                PBYTE ptmp = (PBYTE)pDib;

                for (uy=0;uy<128;uy++)
                {
                    for (ux=0;ux<(128/8);ux++)
                    {
                        *ptmp++ = 0;
                    }
                }
            }
        }
    }

    //
    //  create a test memory DC
    //

    if (hdib)
    {
        //
        // write text into DIB
        //

        HDC hdcm  = CreateCompatibleDC(hdc);

        //
        // display over black
        //

        SelectObject(hdcm,hdib);
        SelectPalette(hdcm,hpal,FALSE);
        RealizePalette(hdcm);

        SetTextColor(hdcm,RGB(255,255,255));
        SetBkMode(hdcm,TRANSPARENT);

        TextOut(hdcm,0,  0," 0  1  2  3  4  5  6  7  8  9 ",30);
        TextOut(hdcm,0, 10,"10 11 12 13 14 15 16 17 18 19 ",30);
        TextOut(hdcm,0, 20,"20 21 22 23 24 25 26 27 28 29 ",30);
        TextOut(hdcm,0, 30,"30 33 32 33 34 33 36 37 38 39 ",30);
        TextOut(hdcm,0, 40,"40 41 42 43 44 45 46 47 48 49 ",30);
        TextOut(hdcm,0, 50,"50 51 52 53 54 55 56 57 58 59 ",30);
        TextOut(hdcm,0, 60,"60 61 62 63 64 65 66 67 68 69 ",30);
        TextOut(hdcm,0, 70,"70 71 72 73 74 75 76 77 78 79 ",30);
        TextOut(hdcm,0, 80,"80 81 82 83 84 85 86 87 88 89 ",30);
        TextOut(hdcm,0, 90,"90 91 92 93 94 95 96 97 98 99 ",30);
        TextOut(hdcm,0,100,"a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 ",30);
        TextOut(hdcm,0,110,"b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 ",30);

        DeleteDC(hdcm);
    }

    SelectPalette(hdc,hpalOld,TRUE);
    DeleteObject(hpal);

    *pBits = (PVOID)pDib;
    *phdib = hdib;

    if (hdib == NULL)
    {
        LocalFree(pbmi);
        pbmi = NULL;
    }

    return(pbmi);
}

/******************************Public*Routine******************************\
* vTestAlphaStretch - routine is called by format specific routines to do
* all drawing
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vRunAlphaStretchDIB(
    HDC         hdc,
    PBITMAPINFO pbmi,
    PVOID       pBits,
    ULONG       iUsage
    )
{
    ULONG         xpos  = 10;
    ULONG         ypos  = 10;
    ULONG         dy    = 136;
    ULONG         dx    = 128+5;
    HPALETTE      hpal;
    HPALETTE      hpalOld;
    BLENDFUNCTION BlendFunction;
    BYTE          Alphas[] = {64,128,160,192,224,255};
    RECT          rect;

    if ((iUsage != DIB_RGB_COLORS) && (iUsage != DIB_PAL_COLORS))
    {
        iUsage = DIB_RGB_COLORS;
    }

    //
    // Clear screen
    //

    SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));
    PatBlt(hdc,0,0,2000,2000,PATCOPY);

    {
        ULONG             ux,uy;

        SetTextColor(hdc,RGB(255,255,255));
        SetBkMode(hdc,TRANSPARENT);
        SelectObject(hdc,hbrFillCars);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.AlphaFormat         = 0;
        BlendFunction.SourceConstantAlpha = Alphas[2];

        xpos = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0   0 128,128",28);

        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0   0  64, 64",28);

        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0   0 256,256",28);

        xpos =  10;
        ypos += 12;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);

        xpos += 250;
        SetDIBitsToDevice(hdc,xpos,ypos,128,128,0,0,0,128,pBits,pbmi,iUsage);

        ypos += 180;
        xpos  = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128, -64   0 128,128",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0 -64 128,128",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128, -64 -64 128,128",28);

        ypos += 12;
        xpos = 10;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);

        xpos += 250;
        SetDIBitsToDevice(hdc,xpos,ypos,128,128,0,0,0,128,pBits,pbmi,iUsage);

        ypos += 180;
        xpos  = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128, -32 -32 192,192",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0 -32 128,192",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128, -32   0 192,128",28);

        ypos += 12;
        xpos = 10;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);

        xpos += 250;
        SetDIBitsToDevice(hdc,xpos,ypos,128,128,0,0,0,128,pBits,pbmi,iUsage);

        ypos += 180;
        xpos  = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128, -32 -32 42,42",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"128-10,128-10  10 10 41   5 ",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128, -1000,-1000,100",28);

        ypos += 12;
        xpos = 10;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);

        xpos += 250;
        SetDIBitsToDevice(hdc,xpos,ypos,128,128,0,0,0,128,pBits,pbmi,iUsage);
    }
}


/**************************************************************************\
* vTestAlphaStretch
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestAlphaStretch(
    HWND  hwnd,
    HDC   hdc,
    RECT* prcl
    )
{
    HDC      hdcm = CreateCompatibleDC(hdc);
    HPALETTE hpal = CreateHalftonePalette(hdc);
    HPALETTE hpalOld;
    CHAR     Title[256];
    CHAR     NewTitle[256];
    ULONG    ulIndex = 0;

    GetWindowText(hwnd,Title,256);

    lstrcpy(NewTitle,Title);
    lstrcat(NewTitle,pFormatStr[ulIndex]);
    SetWindowText(hwnd,NewTitle);

    //
    // repeat for each src format
    //


    hpalOld = SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    while (ulBpp[ulIndex] != 0)
    {
        HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],128,128);

        if (hdib != NULL)
        {
            lstrcpy(NewTitle,Title);
            lstrcat(NewTitle,pFormatStr[ulIndex]);
            SetWindowText(hwnd,NewTitle);

            vRunAlphaStretch(hdc,hdib);
            DeleteObject(hdib);
        }

        Sleep(gAlphaSleep);
        ulIndex++;
    }

    SetWindowText(hwnd,Title);
    SelectPalette(hdc,hpalOld,TRUE);
    DeleteDC(hdcm);
    DeleteObject(hpal);
}

/**************************************************************************\
* vTestAlphaStretchDIB
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestAlphaStretchDIB(
     HWND  hwnd,
     HDC   hdc,
     RECT* prcl
    )
{
    HDC      hdcm = CreateCompatibleDC(hdc);
    HPALETTE hpal = CreateHalftonePalette(hdc);
    HPALETTE hpalOld;
    CHAR     Title[256];
    CHAR     NewTitle[256];
    ULONG    ulIndex = 0;

    GetWindowText(hwnd,Title,256);

    hpalOld = SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    while (ulBppDIB[ulIndex] != 0)
    {
       PVOID       pBits = NULL;
       PBITMAPINFO pbmi  = NULL;
       HBITMAP     hdib  = NULL;

        pbmi = pbmiCreateAlphaStretchDIB(hdc,ulBppDIB[ulIndex],ulForDIB[ulIndex],&pBits,&hdib);

        if (hdib != NULL)
        {
            lstrcpy(NewTitle,Title);
            lstrcat(NewTitle,pFormatStrDIB[ulIndex]);
            SetWindowText(hwnd,NewTitle);

            vRunAlphaStretchDIB(hdc,pbmi,pBits,ulForDIB[ulIndex]);
            DeleteObject(hdib);
        }

        Sleep(gAlphaSleep);
        ulIndex++;
    }

    SetWindowText(hwnd,Title);
    SelectPalette(hdc,hpalOld,TRUE);
    DeleteDC(hdcm);
    DeleteObject(hpal);
}


/**************************************************************************\
* vRunGradHorz
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/17/1997 Mark Enstrom [marke]
*
\**************************************************************************/
VOID
vRunGradRectHorz(
    HDC     hdc,
    HBITMAP hdib,
    ULONG   ulRectMode
    )
{
    ULONG         xpos  = 10;
    ULONG         ypos  = 10;
    ULONG         dy    = 10;
    ULONG         dx    = 10;
    HPALETTE      hpal;
    HPALETTE      hpalOld;
    RECT          rect;

    //
    //  create mem dc, select test DIBSection
    //

    ULONG   ux,uy;
    ULONG   dibx,diby;
    PULONG  pDib;

    HDC hdcm  = CreateCompatibleDC(hdc);

    GRADIENT_RECT gRect = {0,1};
    TRIVERTEX vert[6];
    HBRUSH hbrCyan = CreateSolidBrush(RGB(0,255,255));
    USHORT OffsetX = 0;
    USHORT OffsetY = 0;
    HRGN hrgn1 = CreateEllipticRgn(10,10,246,246);

    //
    // Clear screen
    //

    SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));
    PatBlt(hdc,0,0,2000,2000,PATCOPY);

    //
    // display over black
    //

    hpal = CreateHalftonePalette(hdc);

    SelectObject(hdcm,hdib);
    SelectObject(hdcm,GetStockObject(DKGRAY_BRUSH));
    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    hpalOld = SelectPalette(hdc,hpal,FALSE);
    SelectPalette(hdcm,hpal,FALSE);

    RealizePalette(hdc);
    RealizePalette(hdcm);

    SetTextColor(hdc,RGB(255,255,255));
    SetBkMode(hdc,TRANSPARENT);


    //
    // fill screen background
    //

    vert[0].x     = -101;
    vert[0].y     = -102;
    vert[0].Red   = 0x4000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x8000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 2000;
    vert[1].y     = 3004;
    vert[1].Red   = 0xff00;
    vert[1].Green = 0x0000;
    vert[1].Blue  = 0xff00;
    vert[1].Alpha = 0x0000;

    GradientFill(hdc,vert,2,(PVOID)&gRect,1,ulRectMode);

    //
    // test widths and heights
    //

    diby = 16;

    for (uy=0;uy<16;uy++)
    {
        dibx = 16;

        for (ux=1;ux<17;ux++)
        {
            vert[0].x     = dibx;
            vert[0].y     = diby;
            vert[0].Red   = 0x0000;
            vert[0].Green = 0x0000;
            vert[0].Blue  = 0x0000;
            vert[0].Alpha = 0x0000;

            vert[1].x     = dibx + ux;
            vert[1].y     = diby + ux;
            vert[1].Red   = 0xff00;
            vert[1].Green = 0x0000;
            vert[1].Blue  = 0xff00;
            vert[1].Alpha = 0x0000;

            GradientFill(hdcm,vert,2,(PVOID)&gRect,1,ulRectMode);

            dibx = dibx + 17;
        }

        diby += 20;
    }

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);
    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    //
    // test Solid Widths and heights
    //

    xpos = xpos + (256 + 16);

    diby = 16;

    for (uy=1;uy<16;uy++)
    {
        dibx = 16;

        for (ux=1;ux<17;ux++)
        {
            vert[0].x     = dibx;
            vert[0].y     = diby;
            vert[0].Red   = 0x0000;
            vert[0].Green = 0xff00;
            vert[0].Blue  = 0xff00;
            vert[0].Alpha = 0x0000;

            vert[1].x     = dibx + uy;
            vert[1].y     = diby + uy;
            vert[1].Red   = 0x0000;
            vert[1].Green = 0xff00;
            vert[1].Blue  = 0xff00;
            vert[1].Alpha = 0x0000;

            GradientFill(hdcm,vert,2,(PVOID)&gRect,1,ulRectMode);

            dibx = dibx + 17;
        }

        diby += 20;
    }

    //
    // display
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    //
    // xor copy
    //

    xpos += (256+16);

    BitBlt(hdc,xpos+256+16,ypos,256,256,hdcm,0,0,SRCCOPY);

    //
    // Draw same thing with solid brush and xor
    //

    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    SelectObject(hdcm,hbrCyan);

    diby = 16;

    for (uy=1;uy<16;uy++)
    {
        dibx = 16;

        for (ux=1;ux<17;ux++)
        {
            PatBlt(hdcm,dibx,diby,uy,uy,PATCOPY);

            dibx = dibx + 17;
        }

        diby += 20;
    }

    SelectObject(hdcm,GetStockObject(DKGRAY_BRUSH));
    DeleteObject(hbrCyan);

    //
    // display
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    //
    // XOR
    //

    BitBlt(hdc,xpos+256+16,ypos,256,256,hdcm,0,0,0x660000);


    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    xpos = 16;
    ypos += (16+256);

    //
    // draw a single rectangle, then draw same rectangle by drawing
    // smaller rectangles inside each other. XOR to compare
    //
    //
    //
    //
    //

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0x8000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 256;
    vert[1].y     = 256;
    vert[1].Red   = 0x8000;
    vert[1].Green = 0x8000;
    vert[1].Blue  = 0x8000;
    vert[1].Alpha = 0x0000;

    GradientFill(hdcm,vert,2,(PVOID)&gRect,1,ulRectMode);

    //
    // display copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    xpos += (256+16);

    //
    // xor copy
    //

    BitBlt(hdc,xpos+256+16,ypos,256,256,hdcm,0,0,SRCCOPY);

    //
    // draw rectangles inside rectangles to test dither org
    //


    //
    // range in x = 256, range in color = 0xfe00 (256 * 128)
    //

    while (OffsetX < 128)
    {
        vert[0].x     = OffsetX;
        vert[0].y     = OffsetY;
        vert[0].Red   = 0x8000;
        vert[0].Green = 0x0000 + (128 * OffsetX);
        vert[0].Blue  = 0x0000 + (128 * OffsetX);
        vert[0].Alpha = 0x0000;

        vert[1].x     = 256-OffsetX;
        vert[1].y     = 256-OffsetY;
        vert[1].Red   = 0x8000;
        vert[1].Green = 0x8000 - (128 * OffsetX);
        vert[1].Blue  = 0x8000 - (128 * OffsetX);
        vert[1].Alpha = 0x0000;

        GradientFill(hdcm,vert,2,(PVOID)&gRect,1,ulRectMode);

        OffsetX += 9;
        OffsetY += 9;
    }

    //
    // display copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    xpos += (256+16);

    //
    // xor copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,0x660000);

    xpos = 16;
    ypos += (16+256);

    //
    // draw a single rectangle, then draw same rectangle by drawing
    // smaller rectangles inside each other. XOR to compare
    //
    //
    // Use Complex Clip
    //
    //

    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    ExtSelectClipRgn(hdcm,hrgn1,RGN_COPY);

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0x8000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 256;
    vert[1].y     = 256;
    vert[1].Red   = 0x8000;
    vert[1].Green = 0x8000;
    vert[1].Blue  = 0x8000;
    vert[1].Alpha = 0x0000;

    GradientFill(hdcm,vert,2,(PVOID)&gRect,1,ulRectMode);

    //
    // display copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    xpos += (256+16);

    //
    // xor copy
    //

    BitBlt(hdc,xpos+256+16,ypos,256,256,hdcm,0,0,SRCCOPY);

    //
    // draw rectangles inside rectangles to test dither org
    //

    OffsetX = 0;
    OffsetY = 0;

    //
    // range in x = 256, range in color = 0xfe00 (256 * 128)
    //

    while (OffsetX < 128)
    {
        vert[0].x     = OffsetX;
        vert[0].y     = OffsetY;
        vert[0].Red   = 0x8000;
        vert[0].Green = 0x0000 + (128 * OffsetX);
        vert[0].Blue  = 0x0000 + (128 * OffsetX);
        vert[0].Alpha = 0x0000;

        vert[1].x     = 256-OffsetX;
        vert[1].y     = 256-OffsetY;
        vert[1].Red   = 0x8000;
        vert[1].Green = 0x8000 - (128 * OffsetX);
        vert[1].Blue  = 0x8000 - (128 * OffsetX);
        vert[1].Alpha = 0x0000;

        GradientFill(hdcm,vert,2,(PVOID)&gRect,1,ulRectMode);

        OffsetX += 9;
        OffsetY += 9;
    }

    //
    // display copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    xpos += (256+16);

    //
    // xor copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,0x660000);

    ExtSelectClipRgn(hdcm,NULL,RGN_COPY);
    DeleteObject(hrgn1);

    xpos = 16;
    ypos += (256+16);

    SelectPalette(hdc,hpalOld,TRUE);

    DeleteObject(hdcm);
    DeleteObject(hpal);
}

/**************************************************************************\
* vTestGradHorz
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestGradRectHorz(
    HWND  hwnd,
    HDC   hdc,
    RECT* prcl
    )
{
    HPALETTE hpal = CreateHalftonePalette(hdc);
    HPALETTE hpalOld;
    CHAR     Title[256];
    CHAR     NewTitle[256];

    //
    // repeat for each src format
    //

    ULONG    ulIndex = 0;

    hpalOld = SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    while (ulBpp[ulIndex] != 0)
    {
        HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],256,256);

        if (hdib != NULL)
        {
            lstrcpy(NewTitle,Title);
            lstrcat(NewTitle,pFormatStr[ulIndex]);

            vRunGradRectHorz(hdc,hdib,GRADIENT_FILL_RECT_H);
            DeleteObject(hdib);
        }

        Sleep(gAlphaSleep);
        ulIndex++;
    }

    SelectPalette(hdc,hpalOld,TRUE);
    DeleteObject(hpal);
}

/**************************************************************************\
* vTestGradVert
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestGradRectVert(
    HWND  hwnd,
    HDC   hdc,
    RECT* prcl
    )
{
    HPALETTE hpal = CreateHalftonePalette(hdc);
    HPALETTE hpalOld;
    CHAR     Title[256];
    CHAR     NewTitle[256];

    ULONG    ulIndex = 0;

    hpalOld = SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    //
    // repeat for each src format
    //

    while (ulBpp[ulIndex] != 0)
    {
        HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],256,256);

        if (hdib != NULL)
        {
            lstrcpy(NewTitle,Title);
            lstrcat(NewTitle,pFormatStr[ulIndex]);

            vRunGradRectHorz(hdc,hdib,GRADIENT_FILL_RECT_V);
            DeleteObject(hdib);
        }

        Sleep(gAlphaSleep);
        ulIndex++;
    }

    SelectPalette(hdc,hpalOld,TRUE);
    DeleteObject(hpal);
}

/**************************************************************************\
* vRunGradTriangle
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/17/1997 Mark Enstrom [marke]
*
\**************************************************************************/
VOID
vRunGradTriangle(
    HDC     hdc,
    HBITMAP hdib
    )
{
    ULONG         xpos  = 10;
    HBRUSH        hbrCyan = CreateSolidBrush(RGB(0,255,255));
    ULONG         ypos  = 10;
    ULONG         dy    = 10;
    ULONG         dx    = 10;
    HPALETTE      hpal;
    HPALETTE      hpalOld;
    RECT          rect;
    HRGN          hrgn1 = CreateEllipticRgn(10,10,246,246);
    ULONG         ux,uy;
    ULONG         dibx,diby;
    PULONG        pDib;
    TRIVERTEX     vert[6];
    USHORT        OffsetX = 0;
    USHORT        OffsetY = 0;
    HDC           hdcm  = CreateCompatibleDC(hdc);

    GRADIENT_TRIANGLE gTri[2] ={{0,1,2},{0,2,3}};

    //
    // Clear screen
    //

    SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));
    PatBlt(hdc,0,0,2000,2000,PATCOPY);

    //
    // display over black
    //

    hpal = CreateHalftonePalette(hdc);

    SelectObject(hdcm,hdib);
    SelectObject(hdcm,GetStockObject(DKGRAY_BRUSH));
    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    hpalOld = SelectPalette(hdc,hpal,FALSE);
    SelectPalette(hdcm,hpal,FALSE);

    RealizePalette(hdc);
    RealizePalette(hdcm);

    SetTextColor(hdc,RGB(255,255,255));
    SetBkMode(hdc,TRANSPARENT);

    //
    // fill screen background
    //

    vert[0].x     = -101;
    vert[0].y     = -102;
    vert[0].Red   = 0x4000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x8000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 2000;
    vert[1].y     = -102;
    vert[1].Red   = 0x4400;
    vert[1].Green = 0x4400;
    vert[1].Blue  = 0xff00;
    vert[1].Alpha = 0x0000;

    vert[2].x     = 2000;
    vert[2].y     = 1000;
    vert[2].Red   = 0xff00;
    vert[2].Green = 0x0000;
    vert[2].Blue  = 0xff00;
    vert[2].Alpha = 0x0000;

    vert[3].x     = -101;
    vert[3].y     = 1000;
    vert[3].Red   = 0x0000;
    vert[3].Green = 0x4300;
    vert[3].Blue  = 0x0000;
    vert[3].Alpha = 0x0000;

    GradientFill(hdc,vert,4,(PVOID)&gTri,2,GRADIENT_FILL_TRIANGLE);

    //
    // test widths and heights
    //

    diby = 16;

    for (uy=0;uy<16;uy++)
    {
        dibx = 16;

        for (ux=1;ux<17;ux++)
        {
            vert[0].x     = dibx;
            vert[0].y     = diby;
            vert[0].Red   = 0x0000;
            vert[0].Green = 0x0000;
            vert[0].Blue  = 0x0000;
            vert[0].Alpha = 0x0000;

            vert[1].x     = dibx + ux;
            vert[1].y     = diby;
            vert[1].Red   = 0xff00;
            vert[1].Green = 0x0000;
            vert[1].Blue  = 0x0000;
            vert[1].Alpha = 0x0000;

            vert[2].x     = dibx + ux;
            vert[2].y     = diby + ux;
            vert[2].Red   = 0xff00;
            vert[2].Green = 0x0000;
            vert[2].Blue  = 0xff00;
            vert[2].Alpha = 0x0000;

            vert[3].x     = dibx;
            vert[3].y     = diby + ux;
            vert[3].Red   = 0x0000;
            vert[3].Green = 0x0000;
            vert[3].Blue  = 0xff00;
            vert[3].Alpha = 0x0000;

            GradientFill(hdcm,vert,4,(PVOID)&gTri,2,GRADIENT_FILL_TRIANGLE);

            dibx = dibx + 17;
        }

        diby += 20;
    }

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);
    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    //
    // test Solid Widths and heights
    //

    xpos = xpos + (256 + 16);

    diby = 16;

    for (uy=1;uy<16;uy++)
    {
        dibx = 16;

        for (ux=1;ux<17;ux++)
        {
            vert[0].x     = dibx;
            vert[0].y     = diby;
            vert[0].Red   = 0x0000;
            vert[0].Green = 0xff00;
            vert[0].Blue  = 0xff00;
            vert[0].Alpha = 0x0000;

            vert[1].x     = dibx + uy;
            vert[1].y     = diby;
            vert[1].Red   = 0x0000;
            vert[1].Green = 0xff00;
            vert[1].Blue  = 0xff00;
            vert[1].Alpha = 0x0000;

            vert[2].x     = dibx + uy;
            vert[2].y     = diby + uy;
            vert[2].Red   = 0x0000;
            vert[2].Green = 0xff00;
            vert[2].Blue  = 0xff00;
            vert[2].Alpha = 0x0000;

            vert[3].x     = dibx;
            vert[3].y     = diby + uy;
            vert[3].Red   = 0x0000;
            vert[3].Green = 0xff00;
            vert[3].Blue  = 0xff00;
            vert[3].Alpha = 0x0000;

            GradientFill(hdcm,vert,4,(PVOID)&gTri,2,GRADIENT_FILL_TRIANGLE);

            dibx = dibx + 17;
        }

        diby += 20;
    }

    //
    // display
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    //
    // xor copy
    //

    xpos += (256+16);

    BitBlt(hdc,xpos+256+16,ypos,256,256,hdcm,0,0,SRCCOPY);

    //
    // Draw same thing with solid brush and xor
    //

    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    SelectObject(hdcm,hbrCyan);

    diby = 16;

    for (uy=1;uy<16;uy++)
    {
        dibx = 16;

        for (ux=1;ux<17;ux++)
        {
            PatBlt(hdcm,dibx,diby,uy,uy,PATCOPY);

            dibx = dibx + 17;
        }

        diby += 20;
    }

    SelectObject(hdcm,GetStockObject(DKGRAY_BRUSH));
    DeleteObject(hbrCyan);

    //
    // display
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    //
    // XOR
    //

    BitBlt(hdc,xpos+256+16,ypos,256,256,hdcm,0,0,0x660000);


    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    xpos = 16;
    ypos += (16+256);

    //
    // draw a single rectangle, then draw same rectangle by drawing
    // smaller rectangles inside each other. XOR to compare
    //
    //
    //
    //
    //

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0x0000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 256;
    vert[1].y     = 0;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0x0000;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0x0000;

    vert[2].x     = 256;
    vert[2].y     = 256;
    vert[2].Red   = 0xfe00;
    vert[2].Green = 0xfe00;
    vert[2].Blue  = 0xfe00;
    vert[2].Alpha = 0x0000;

    vert[3].x     = 0;
    vert[3].y     = 256;
    vert[3].Red   = 0xfe00;
    vert[3].Green = 0xfe00;
    vert[3].Blue  = 0xfe00;
    vert[3].Alpha = 0x0000;

    GradientFill(hdcm,vert,4,(PVOID)&gTri,2,GRADIENT_FILL_TRIANGLE);

    //
    // display copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    xpos += (256+16);

    //
    // xor copy
    //

    BitBlt(hdc,xpos+256+16,ypos,256,256,hdcm,0,0,SRCCOPY);

    //
    // draw rectangles inside rectangles to test dither org
    //
    // range in x = 256, range in color = 0xfe00 (256 * 128)
    //

    while ((OffsetX < 100) && (OffsetY < 100))
    {
        vert[0].x     = OffsetX;
        vert[0].y     = OffsetY;
        vert[0].Red   = 0x0000 + (254 * OffsetY);
        vert[0].Green = 0x0000 + (254 * OffsetY);
        vert[0].Blue  = 0x0000 + (254 * OffsetY);
        vert[0].Alpha = 0x0000;

        vert[1].x     = 256-OffsetX;
        vert[1].y     = OffsetY;
        vert[1].Red   = 0x0000 + (254 * OffsetY);
        vert[1].Green = 0x0000 + (254 * OffsetY);
        vert[1].Blue  = 0x0000 + (254 * OffsetY);
        vert[1].Alpha = 0x0000;

        vert[2].x     = 256-OffsetX;
        vert[2].y     = 256-OffsetY;
        vert[2].Red   = 0xfe00 - (254 * OffsetY);
        vert[2].Green = 0xfe00 - (254 * OffsetY);
        vert[2].Blue  = 0xfe00 - (254 * OffsetY);
        vert[2].Alpha = 0x0000;

        vert[3].x     = OffsetX;
        vert[3].y     = 256-OffsetY;
        vert[3].Red   = 0xfe00 - (254 * OffsetY);
        vert[3].Green = 0xfe00 - (254 * OffsetY);
        vert[3].Blue  = 0xfe00 - (254 * OffsetY);
        vert[3].Alpha = 0x0000;

        GradientFill(hdcm,vert,4,(PVOID)&gTri,2,GRADIENT_FILL_TRIANGLE);


        OffsetX += 9;
        OffsetY += 9;
    }

    //
    // display copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    xpos += (256+16);

    //
    // xor copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,0x660000);

    xpos = 16;
    ypos += (16+256);

    //
    // draw a single rectangle, then draw same rectangle by drawing
    // smaller rectangles inside each other. XOR to compare
    //
    //
    // Use Complex Clip
    //
    //

    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    ExtSelectClipRgn(hdcm,hrgn1,RGN_COPY);

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0x0000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 256;
    vert[1].y     = 0;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0x0000;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0x0000;

    vert[2].x     = 256;
    vert[2].y     = 256;
    vert[2].Red   = 0xfe00;
    vert[2].Green = 0xfe00;
    vert[2].Blue  = 0xfe00;
    vert[2].Alpha = 0x0000;

    vert[3].x     = 0;
    vert[3].y     = 256;
    vert[3].Red   = 0xfe00;
    vert[3].Green = 0xfe00;
    vert[3].Blue  = 0xfe00;
    vert[3].Alpha = 0x0000;

    GradientFill(hdcm,vert,4,(PVOID)&gTri,2,GRADIENT_FILL_TRIANGLE);

    //
    // display copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    xpos += (256+16);

    //
    // xor copy
    //

    BitBlt(hdc,xpos+256+16,ypos,256,256,hdcm,0,0,SRCCOPY);

    //
    // draw rectangles inside rectangles to test dither org
    //

    OffsetX = 0;
    OffsetY = 0;

    //
    // range in x = 256, range in color = 0xfe00 (256 * 128)
    //

    while ((OffsetX < 100) && (OffsetY < 100))
    {
        vert[0].x     = OffsetX;
        vert[0].y     = OffsetY;
        vert[0].Red   = 0x0000 + (254 * OffsetY);
        vert[0].Green = 0x0000 + (254 * OffsetY);
        vert[0].Blue  = 0x0000 + (254 * OffsetY);
        vert[0].Alpha = 0x0000;

        vert[1].x     = 256-OffsetX;
        vert[1].y     = OffsetY;
        vert[1].Red   = 0x0000 + (254 * OffsetY);
        vert[1].Green = 0x0000 + (254 * OffsetY);
        vert[1].Blue  = 0x0000 + (254 * OffsetY);
        vert[1].Alpha = 0x0000;

        vert[2].x     = 256-OffsetX;
        vert[2].y     = 256-OffsetY;
        vert[2].Red   = 0xfe00 - (254 * OffsetY);
        vert[2].Green = 0xfe00 - (254 * OffsetY);
        vert[2].Blue  = 0xfe00 - (254 * OffsetY);
        vert[2].Alpha = 0x0000;

        vert[3].x     = OffsetX;
        vert[3].y     = 256-OffsetY;
        vert[3].Red   = 0xfe00 - (254 * OffsetY);
        vert[3].Green = 0xfe00 - (254 * OffsetY);
        vert[3].Blue  = 0xfe00 - (254 * OffsetY);
        vert[3].Alpha = 0x0000;

        GradientFill(hdcm,vert,4,(PVOID)&gTri,2,GRADIENT_FILL_TRIANGLE);

        OffsetX += 9;
        OffsetY += 9;
    }

    //
    // display copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    xpos += (256+16);

    //
    // xor copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,0x660000);

    ExtSelectClipRgn(hdcm,NULL,RGN_COPY);

    xpos = 16;
    ypos += (256+16);

    SelectPalette(hdc,hpalOld,TRUE);

    DeleteObject(hdcm);
    DeleteObject(hpal);
    DeleteObject(hrgn1);
    DeleteObject(hbrCyan);
}

/**************************************************************************\
* vTestTriangle
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestGradTriangle(
    HWND  hwnd,
    HDC   hdc,
    RECT* prcl
    )
{
    HPALETTE hpal = CreateHalftonePalette(hdc);
    HPALETTE hpalOld = NULL;

    CHAR     Title[256];
    CHAR     NewTitle[256];

    ULONG    ulIndex = 0;

    hpalOld = SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    while (ulBpp[ulIndex] != 0)
    {
        HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],256,256);

        if (hdib != NULL)
        {
            vRunGradTriangle(hdc,hdib);
            DeleteObject(hdib);
        }

        Sleep(gAlphaSleep);
        ulIndex++;
    }

    SelectPalette(hdc,hpalOld,TRUE);
    DeleteObject(hpal);
}

/**************************************************************************\
* vTestGradFill
* vTestAlphaBlend
*
*   run tests
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestGradFill(
    HWND  hwnd,
    HDC   hdc,
    RECT* prcl
    )
{
    vTestGradTriangle(hwnd,hdc,prcl);
    //vTestGradRectVert(hwnd,hdc,prcl);
    //vTestGradRectHorz(hwnd,hdc,prcl);
}

VOID
vTestAlphaBlend(
    HWND  hwnd,
    HDC   hdc,
    RECT* prcl
    )
{
    vTestAlphaStretch(hwnd,hdc,prcl);
    vTestAlphaStretchDIB(hwnd,hdc,prcl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftbm.c ===
/******************************Module*Header*******************************\
* Module Name: ftbm.c
*
* This is a test of the genblt functions
*
* Created: 8-NOV-1990 12:52:00
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

// This is to create a bitmapinfo structure

typedef struct _BITMAPINFOPAT2
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[20];
} BITMAPINFOPAT2;

typedef struct _BITMAPINFOPAT
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[16];
} BITMAPINFOPAT;

BITMAPINFOPAT bmiPat =
{
    {
        sizeof(BITMAPINFOHEADER),
        32,
        32,
        1,
        1,
        BI_RGB,
        (32 * 32),
        0,
        0,
        2,
        2
    },

    {                               // B    G    R
        { 0,   0,   0x80,0 },       // 1
        { 0,   0x80,0,   0 },       // 2
        { 0,   0,   0,   0 },       // 0
        { 0,   0x80,0x80,0 },       // 3
        { 0x80,0,   0,   0 },       // 4
        { 0x80,0,   0x80,0 },       // 5
        { 0x80,0x80,0,   0 },       // 6
	{ 0x80,0x80,0x80,0 },	    // 7
	{ 0xC0,0xC0,0xC0,0 },	    // 8
        { 0,   0,   0xFF,0 },       // 9
        { 0,   0xFF,0,   0 },       // 10
        { 0,   0xFF,0xFF,0 },       // 11
        { 0xFF,0,   0,   0 },       // 12
        { 0xFF,0,   0xFF,0 },       // 13
        { 0xFF,0xFF,0,   0 },       // 14
        { 0xFF,0xFF,0xFF,0 }        // 15
    }
};

BYTE abColorLines[64 * 64 / 2] =
{
// 0
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,

     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
// 8
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,

     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
// 16
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,

     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
// 24
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,

     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
// 32
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,

     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
// 40
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,

     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
// 48
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,

     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
// 56
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,

     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF
// 64
};

BITMAPINFOPAT bmiPat1 =
{
    {
        sizeof(BITMAPINFOHEADER),
        64,
        64,
        1,
        4,
        BI_RGB,
        (64 * 64 / 2),
        0,
        0,
        16,
        16
    },

    {                               // B    G    R
        { 0xFF,0xFF,0xFF,0 },       // 15
        { 0xFF,0xFF,0,   0 },       // 14
        { 0xFF,0,   0xFF,0 },       // 13
        { 0xFF,0,   0,   0 },       // 12
        { 0,   0xFF,0xFF,0 },       // 11
        { 0,   0xFF,0,   0 },       // 10
        { 0,   0,   0xFF,0 },       // 9
        { 0x80,0x80,0x80,0 },       // 8

        { 0xC0,0xC0,0xC0,0 },       // 7
        { 0x80,0x80,0,   0 },       // 6
        { 0x80,0,   0x80,0 },       // 5
        { 0x80,0,   0,   0 },       // 4
        { 0,   0x80,0x80,0 },       // 3
        { 0,   0x80,0,   0 },       // 2
        { 0,   0,   0x80,0 },       // 1
        { 0,   0,   0,   0 }        // 0
    }
};

BITMAPINFOPAT2 bmiPat2 =
{
    {
        sizeof(BITMAPINFOHEADER),
        32,
        32,
        1,
        8,
        BI_RGB,
        32*32,
        0,
        0,
        20,
        20
    },

    {                               // B    G    R
        { 0xFF,0xFF,0xFF,0 },       // 15
        { 0xFF,0xFF,0,   0 },       // 14
        { 0xFF,0,   0xFF,0 },       // 13
        { 0xFF,0,   0,   0 },       // 12
        { 0,   0xFF,0xFF,0 },       // 11
        { 0,   0xFF,0,   0 },       // 10
        { 0,   0,   0xFF,0 },       // 9
        { 0x80,0x80,0x80,0 },       // 8

        { 0xC0,0xC0,0xC0,0 },       // 7
        { 0x80,0x80,0,   0 },       // 6
        { 0x80,0,   0x80,0 },       // 5
        { 0x80,0,   0,   0 },       // 4
        { 0,   0x80,0x80,0 },       // 3
        { 0,   0x80,0,   0 },       // 2
        { 0,   0,   0x80,0 },       // 1
        { 0,   0,   0,   0 },       // 0

        { 0,   0,   0x80,0 },       // 1
        { 0x80,0,   0x80,0 },       // 5
        { 0,   0,   0xFF,0 },       // 9
        { 0xFF,0,   0xFF,0 }        // 13
    }
};

BYTE abColorLines2[32 * 32] =
{
    16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16,
    16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16,
    16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16,
    16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16,
    16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16,
    16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16,
    16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16,
    16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16,

    17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17,

    18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18,
    18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18,
    18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18,
    18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18,
    18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18,
    18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18,
    18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18,
    18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18,

    19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19,
    19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19,
    19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19,
    19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19,
    19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19,
    19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19,
    19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19,
    19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19
};

BYTE abBitCat[] =	 {0xFF, 0xFF, 0xFF, 0xFF,
                          0x80, 0xA2, 0x45, 0x01,
                          0x80, 0xA2, 0x45, 0x01,
                          0x80, 0xA2, 0x45, 0xE1,
                          0x80, 0xA2, 0x45, 0x11,
                          0x80, 0xA2, 0x45, 0x09,
                          0x80, 0x9C, 0x39, 0x09,
                          0x80, 0xC0, 0x03, 0x05,

                          0x80, 0x40, 0x02, 0x05,
                          0x80, 0x40, 0x02, 0x05,
                          0x80, 0x40, 0x02, 0x05,
                          0x80, 0x20, 0x04, 0x05,
                          0x80, 0x20, 0x04, 0x05,
                          0x80, 0x20, 0x04, 0x05,
                          0x80, 0x10, 0x08, 0x05,
                          0x80, 0x10, 0x08, 0x09,

                          0x80, 0x10, 0x08, 0x11,
                          0x80, 0x08, 0x10, 0x21,
                          0x80, 0x08, 0x10, 0xC1,
                          0x80, 0x08, 0x10, 0x09,
                          0x80, 0x07, 0xE0, 0x09,
                          0x80, 0x08, 0x10, 0x09,
                          0x80, 0xFC, 0x3F, 0x09,
                          0x80, 0x09, 0x90, 0x09,

                          0x80, 0xFC, 0x3F, 0x01,
                          0x80, 0x08, 0x10, 0x01,
                          0x80, 0x1A, 0x58, 0x01,
                          0x80, 0x28, 0x14, 0x01,
                          0x80, 0x48, 0x12, 0x01,
                          0x80, 0x8F, 0xF1, 0x01,
                          0x81, 0x04, 0x20, 0x81,
                          0xFF, 0xFF, 0xFF, 0xFF } ;

static BYTE abBigCat[] = {
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

typedef struct _VGALOGPALETTE
{
    USHORT ident;
    USHORT NumEntries;
    PALETTEENTRY palPalEntry[16];
} VGALOGPALETTE;

VGALOGPALETTE logPalVGA =
{

0x300,  // driver version
16,     // num entries
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },	// 6
    { 0x80,0x80,0x80,0 },	// 7

    { 0xC0,0xC0,0xC0,0 },	// 8
    { 0xFF,0,   0,   0 },       // 9
    { 0,   0xFF,0,   0 },       // 10
    { 0xFF,0xFF,0,   0 },       // 11
    { 0,   0,   0xFF,0 },       // 12
    { 0xFF,0,   0xFF,0 },       // 13
    { 0,   0xFF,0xFF,0 },       // 14
    { 0xFF,0xFF,0xFF,0 }        // 15
}
};

VOID vTestBitmap(HWND hwnd, HDC hdcScreen, RECT* prcl)
{
    HDC hdcClone;
    HBITMAP hbm1Cat, hbm1Cat0, hbm4Lines, hbm4Lines0, hbm8Lines, hbm8Lines0;
    HBITMAP hbm1BigCat, hbm1BigCat0, hbmClone, hbmDefault;
    HDC hdc1Cat, hdc1Cat0, hdc4Lines, hdc4Lines0, hdc8Lines, hdc8Lines0;
    HDC hdc1BigCat, hdc1BigCat0;
    HBRUSH hbrushGreen, hbrDefault, hbrNull;
    HBRUSH hbr1, hbr4, hbr8, hbrHatch, hbrOld;
    HPEN hPen, hPenOld, hPenDefault;
    ULONG ScreenWidth, ScreenHeight;
    HPALETTE hpalVGA, hpalOld;
    ULONG x,ulTemp;
    LOGBRUSH logbrush;
    LOGPEN logpen;

    hwnd = hwnd;
    prcl = prcl;

    hpalVGA = CreatePalette((LOGPALETTE *) &logPalVGA);
    if (hpalVGA == (HPALETTE) 0)
	DbgPrint("ERROR in CreatePalette\n");

    hpalOld = SelectPalette(hdcScreen, hpalVGA, 0);

    if (hpalOld == (HPALETTE) 0)
	DbgPrint("ERROR in CreatePalette1\n");

    RealizePalette(hdcScreen);

    hbrushGreen  = CreateSolidBrush(RGB(0x00,0xff,0x00));

    ScreenWidth  = GetDeviceCaps(hdcScreen, HORZRES);
    ScreenHeight = GetDeviceCaps(hdcScreen, VERTRES);

// We create 6 formats of bitmaps for testing.  2 of each. 1 backup
// so we can refresh after every draw.  The ****0 is the backup.

    hdc1BigCat =   CreateCompatibleDC(hdcScreen);
    hdc1BigCat0 =  CreateCompatibleDC(hdcScreen);
    hdc1Cat  =     CreateCompatibleDC(hdcScreen);
    hdc1Cat0 =     CreateCompatibleDC(hdcScreen);
    hdc4Lines =    CreateCompatibleDC(hdcScreen);
    hdc4Lines0 =   CreateCompatibleDC(hdcScreen);
    hdc8Lines =    CreateCompatibleDC(hdcScreen);
    hdc8Lines0 =   CreateCompatibleDC(hdcScreen);
    hdcClone =     CreateCompatibleDC(hdcScreen);

    if ((hdc1Cat == 0) || (hdcClone == 0) || (hdcScreen == 0))
        DbgPrint("ERROR hdc creation %lu %lu %lu \n", hdcScreen, hdc8Lines0, hdc1Cat);

// Clear the screen

    BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, WHITENESS);

    bmiPat.bmiHeader.biWidth = 32;

    hbm1Cat = CreateDIBitmap((HDC) 0,
			  (BITMAPINFOHEADER *) &bmiPat,
			  CBM_INIT,
                          abBitCat,
			  (BITMAPINFO *) &bmiPat,
			  DIB_RGB_COLORS);

    if (hbm1Cat == (HBITMAP) 0)
	DbgPrint("Bitmap creation failed\n");

    bmiPat.bmiHeader.biWidth = 128;

    hbm1BigCat = CreateDIBitmap((HDC) 0,
			  (BITMAPINFOHEADER *) &bmiPat,
			  CBM_INIT,
                          abBigCat,
			  (BITMAPINFO *) &bmiPat,
			  DIB_RGB_COLORS);

    if (hbm1BigCat == 0)
	DbgPrint("hbm1BitCat failed\n");

    hbm4Lines = CreateDIBitmap(hdcScreen,
			  (BITMAPINFOHEADER *) &bmiPat1,
			  CBM_INIT | CBM_CREATEDIB,
                          abColorLines,
			  (BITMAPINFO *) &bmiPat1,
			  DIB_RGB_COLORS);

    if (hbm4Lines == 0)
	DbgPrint("hbm4Lines failed\n");

    hbm8Lines = CreateDIBitmap(hdcScreen,
			  (BITMAPINFOHEADER *) &bmiPat2,
			  CBM_INIT | CBM_CREATEDIB,
                          abColorLines2,
			  (BITMAPINFO *) &bmiPat2,
			  DIB_RGB_COLORS);

    if (hbm8Lines == 0)
	DbgPrint("hbm8Lines failed\n");

    hbmDefault = SelectObject(hdc1Cat, hbm1Cat);

    if (hbmDefault == (HBITMAP) 0)
	DbgPrint("hbm Old is invalid\n");

    if (hbmDefault != SelectObject(hdc1BigCat, hbm1BigCat))
	DbgPrint("hbmDefault wrong1\n");

    if (hbmDefault != SelectObject(hdc4Lines, hbm4Lines))
	DbgPrint("hbmDefault wrong2\n");

    if (hbmDefault != SelectObject(hdc8Lines, hbm8Lines))
	DbgPrint("hbmDefault wrong3\n");

    if(!BitBlt(hdcScreen, 0, 200, 32, 32, hdc1Cat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 64, 200, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 196, 200, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 0, 264, 128, 32, hdc1BigCat, 0, 0, SRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

// Ok let's throw in some CreateCompatible calls.

    hbm1Cat0 =    CreateCompatibleBitmap(hdc1Cat, 32, 32);
    hbm1BigCat0 = CreateCompatibleBitmap(hdc1BigCat, 128, 32);
    hbm4Lines0 =  CreateCompatibleBitmap(hdc4Lines, 64, 64);
    hbm8Lines0 =  CreateCompatibleBitmap(hdc8Lines, 32, 32);
    hbmClone =	  CreateCompatibleBitmap(hdc8Lines, 320, 320);

    if (hbmDefault != SelectObject(hdc1Cat0, hbm1Cat0))
	DbgPrint("hbmDefault wrong4\n");

    if (hbmDefault != SelectObject(hdc1BigCat0, hbm1BigCat0))
	DbgPrint("hbmDefault wrong5\n");

    if (hbmDefault != SelectObject(hdc4Lines0, hbm4Lines0))
	DbgPrint("hbmDefault wrong6\n");

    if (hbmDefault != SelectObject(hdc8Lines0, hbm8Lines0))
	DbgPrint("hbmDefault wrong7\n");

    if (hbmDefault != SelectObject(hdcClone, hbmClone))
	DbgPrint("hbmDefault wrong8\n");

    hbrDefault = SelectObject(hdcClone, hbrushGreen);
    SelectObject(hdcScreen, hbrushGreen);

    if (hbrDefault == (HBRUSH) 0)
	DbgPrint("ERROR: hbrDefault is invalid\n");

// Really it is blackness.

    PatBlt(hdcClone, 0, 0, 320, 320, WHITENESS);

    if(!BitBlt(hdc1Cat0, 0, 0, 32, 32, hdc1Cat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc1BigCat0, 0, 0, 128, 32, hdc1BigCat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc4Lines0, 0, 0, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines0, 0, 0, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    BitBlt(hdcClone, 100,100, 64, 64, hdc4Lines, 0, 0, SRCCOPY);

    PatBlt(hdcClone, 0, 0, 100, 100, PATCOPY);

// Ok real quick here let's test if CreateCompatible Bitmap does an
// identity blt to the screen.

    if(!BitBlt(hdcScreen, 32, 200, 32, 32, hdc1Cat0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 128, 200, 64, 64, hdc4Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 228, 200, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 128, 264, 128, 32, hdc1BigCat0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    BitBlt(hdcScreen, 0, 0, 300, 150, hdcClone, 0, 0, SRCCOPY);

    hbr1 = CreatePatternBrush(hbm1Cat);
    hbr4 = CreatePatternBrush(hbm4Lines);
    hbr8 = CreatePatternBrush(hbm8Lines);

    if ((hbr1 == (HBRUSH) NULL) ||
	(hbr4 == (HBRUSH) NULL) ||
	(hbr8 == (HBRUSH) NULL))
    {
	DbgPrint("ERROR hbr1 %lu hbr4 %lu hbr8 %lu \n", hbr1, hbr4, hbr8);
	DbgBreakPoint();
    }

// Test the VGA brushes.

// Test 1 BPP brush

    hbrOld = SelectObject(hdcScreen, hbr1);
    if (hbrOld != hbrushGreen)
	DbgPrint("Error on select of hbr1 for VGA\n");
    PatBlt(hdcScreen, 0, 300, 300, 150, PATCOPY);

// Test 4 BPP brush

    hbrOld = SelectObject(hdcScreen, hbr4);
    if (hbrOld != hbr1)
	DbgPrint("Error on select of hbr4\n");
    PatBlt(hdcScreen, 0, 150, 300, 150, PATCOPY);

// Test 8 BPP brush

    hbrOld = SelectObject(hdcScreen, hbr8);
    if (hbrOld != hbr4)
	DbgPrint("Error on select of hbr8\n");
    PatBlt(hdcScreen, 0, 0, 300, 150, PATCOPY);

// Now test the hatch brush, brush/pen selection, brush/pen deletion.

    SelectObject(hdcScreen, hbrDefault);

    for (x = 0; x < 6; x++)
    {
    // First test brush creation and selection.

	hbrHatch = CreateHatchBrush(x, RGB(0xFF, 0, 0));

	if (hbrHatch == (HBRUSH) NULL)
	{
	    DbgPrint("ERROR hbrHatch loop %lu\n",x);
	}

	hbrOld = SelectObject(hdcScreen, hbrHatch);

	if (hbrOld != hbrDefault)
	    DbgPrint("Error on select of hbrHatch in loop0\n");

	hbrOld = SelectObject(hdcScreen, hbrHatch);

	if (hbrOld != hbrHatch)
	    DbgPrint("Error on select of hbrHatch in loop1\n");

    // Now do some brush output to a bitmap

	PatBlt(hdcScreen, x * 32, x * 20, 50, 50, PATCOPY);

    // Now delete the brush and pen, try to delete the defaults also.

	hbrOld = SelectObject(hdcScreen, hbrDefault);

	if (hbrOld != hbrHatch)
	    DbgPrint("Error on select of hbrDefault in loop11\n");

	if (!DeleteObject(hbrHatch))
	    DbgPrint("Error in loop brush delete\n");
    }

// End of Tests for VGA

// Test 1 BPP brush

    PatBlt(hdcClone, 0, 0, 320, 320, WHITENESS);
    hbrOld = SelectObject(hdcClone, hbr1);
    if (hbrOld != hbrushGreen)
	DbgPrint("Error on select of hbr1 for bitmap\n");
    PatBlt(hdcClone, 0, 0, 300, 150, PATCOPY);
    BitBlt(hdcScreen, 0, 0, 300, 150, hdcClone, 0, 0, SRCCOPY);
    PatBlt(hdcClone, 0, 0, 320, 320, WHITENESS);
    MaskBlt(hdcClone, 0,0,300,150, (HDC) 0, 0, 0, hbm1Cat, 0, 0,
		      0xAAF00000);
    BitBlt(hdcScreen, 300, 0, 300, 150, hdcClone, 0, 0, SRCCOPY);

// Test 4 BPP brush

    PatBlt(hdcClone, 0, 0, 320, 320, WHITENESS);
    hbrOld = SelectObject(hdcClone, hbr4);
    if (hbrOld != hbr1)
	DbgPrint("Error on select of hbr4\n");
    PatBlt(hdcClone, 0, 0,   300, 150, PATCOPY);
    BitBlt(hdcScreen,0, 150, 300, 150, hdcClone, 0, 0, SRCCOPY);
    PatBlt(hdcClone, 0, 0, 320, 320, WHITENESS);
    MaskBlt(hdcClone, 0,0,300,150, (HDC) 0, 0, 0, hbm1Cat, 0, 0,
		      0xAAF00000);
    BitBlt(hdcScreen, 300, 150, 300, 150, hdcClone, 0, 0, SRCCOPY);

// Test 8 BPP brush

    PatBlt(hdcClone, 0, 0, 320, 320, WHITENESS);
    hbrOld = SelectObject(hdcClone, hbr8);
    if (hbrOld != hbr4)
	DbgPrint("Error on select of hbr8\n");
    PatBlt(hdcClone, 0, 0, 300, 150, PATCOPY);
    BitBlt(hdcScreen, 0, 300, 300, 150, hdcClone, 0, 0, SRCCOPY);
    PatBlt(hdcClone, 0, 0, 320, 320, WHITENESS);
    MaskBlt(hdcClone, 0,0,300,150, (HDC) 0, 0, 0, hbm1Cat, 0, 0,
		      0xAAF00000);
    BitBlt(hdcScreen, 300, 300, 300, 150, hdcClone, 0, 0, SRCCOPY);

// Now test the hatch brush, brush/pen selection, brush/pen deletion.

    hPen = CreatePen(PS_NULL, 2, RGB(0, 0xFF, 0));

    if (hPen == (HPEN) NULL)
    {
	DbgPrint("ERROR hpen creation\n");
    }

    hPenDefault = SelectObject(hdcClone, hPen);
    hPenOld = SelectObject(hdcClone, hPenDefault);

    if (hPenOld != hPen)
	DbgPrint("Error on select of hpen in loop1\n");

    if (!DeleteObject(hPen))
	DbgPrint("Failed to delete the hPen 134\n");

    SelectObject(hdcClone, hbrDefault);

    for (x = 0; x < 6; x++)
    {
    // First test brush creation and selection.

	hbrHatch = CreateHatchBrush(x, RGB(0xFF, 0, 0));

	if (hbrHatch == (HBRUSH) NULL)
	{
	    DbgPrint("ERROR hbrHatch loop %lu\n",x);
	}

	hbrOld = SelectObject(hdcClone, hbrHatch);

	if (hbrOld != hbrDefault)
	    DbgPrint("Error on select of hbrHatch in loop0\n");

	hbrOld = SelectObject(hdcClone, hbrHatch);

	if (hbrOld != hbrHatch)
	    DbgPrint("Error on select of hbrHatch in loop1\n");

    // Next test pen creation and selection.

	hPen = CreatePen(PS_SOLID, 2, RGB(0, 0xFF, 0));

	if (hPen == (HPEN) NULL)
	{
	    DbgPrint("ERROR hpen loop %lu\n", x);
	}

	hPenOld = SelectObject(hdcClone, hPen);

	if (hPenOld != hPenDefault)
	    DbgPrint("Error on select of hpen in loop0\n");

	hPenOld = SelectObject(hdcClone, hPen);

	if (hPenOld != hPen)
	    DbgPrint("Error on select of hpen in loop1\n");

    // Make sure GetObject works.

	logbrush.lbStyle = 0;
	logbrush.lbColor = 0;
	logbrush.lbHatch = 0;
	logpen.lopnStyle = 0;
	logpen.lopnWidth.x = 0;
	logpen.lopnColor = 0;

       if (sizeof(LOGBRUSH) != GetObject(hbrHatch, sizeof(LOGBRUSH), &logbrush))
	    DbgPrint("Error return GetObject brush");

	if (logbrush.lbStyle != BS_HATCHED)
	    DbgPrint("ERROR hatched !\n");

	if (logbrush.lbColor != RGB(0xFF, 0, 0))
	    DbgPrint("ERROR color brush\n");

	if (logbrush.lbHatch != x)
	    DbgPrint("ERROR color brush\n");

	ulTemp = GetObject(hPen, sizeof(LOGPEN), &logpen);

	if (sizeof(LOGPEN) != ulTemp)
	    DbgPrint("Error GetObject Pen failed %lu %lu \n", ulTemp, sizeof(LOGPEN));

	if (logpen.lopnStyle != PS_SOLID)
	    DbgPrint("ERROR pen styleadsfd\n");

	if (logpen.lopnWidth.x != 2)
	    DbgPrint("ERROR pen width\n");

	if (logpen.lopnColor != RGB(0, 0xFF, 0))
	    DbgPrint("ERROR wrong pen color\n");

    // Now do some brush output to a bitmap

	PatBlt(hdcClone, 0, 0, 50, 50, PATCOPY);
	BitBlt(hdcScreen, x * 32, x*20, 50, 50, hdcClone, 0, 0, SRCCOPY);

    // Now delete the brush and pen, try to delete the defaults also.

	hbrOld = SelectObject(hdcClone, hbrDefault);
	if (hbrOld != hbrHatch)
	    DbgPrint("Error on select of hbrDefault in loop11\n");

	hPenOld = SelectObject(hdcClone, hPenDefault);
	if (hPenOld != hPen)
	    DbgPrint("Error on select of hpen in loop11\n");

	if (!DeleteObject(hbrHatch))
	    DbgPrint("Error in loop brush delete\n");
	if (!DeleteObject(hbrDefault))
	    DbgPrint("Error in loop brush delete default\n");

	if (!DeleteObject(hPen))
	    DbgPrint("Error in loop pen delete\n");
	if (!DeleteObject(hPenDefault))
	    DbgPrint("Error in loop pen delete default\n");
    }

    hbrNull = GetStockObject(HOLLOW_BRUSH);

    if (hbrNull == (HBRUSH) 0)
	DbgPrint("hbrNull is 0\n");

    logbrush.lbStyle = BS_HOLLOW;

    SelectObject(hdcScreen, hbrNull);

#if 0

// This is what I really want but for now batching always returns TRUE.

    if (FALSE != PatBlt(hdcScreen, 0, 0, 100, 100, PATCOPY))
	DbgPrint("Failed to not fail on Null brush\n");
#endif

    PatBlt(hdcScreen, 0, 0, 400, 400, PATCOPY);

// test for valid brushes.

    if (((HBRUSH) 0) == GetStockObject(BLACK_BRUSH))
	DbgPrint("ERROR GetStockObject brush/pen 1\n");

    SelectObject(hdcScreen, GetStockObject(BLACK_BRUSH));

    PatBlt(hdcScreen, 200, 0, 32, 32, PATCOPY);

    if (((HBRUSH) 0) == GetStockObject(GRAY_BRUSH))
	DbgPrint("ERROR GetStockObject brush/pen 3\n");

    if (GetStockObject(BLACK_BRUSH) != SelectObject(hdcScreen, GetStockObject(GRAY_BRUSH)))
	DbgPrint("Select on Stock object failed\n");

    PatBlt(hdcScreen, 232, 0, 32, 32, PATCOPY);

    if (((HBRUSH) 0) == GetStockObject(LTGRAY_BRUSH))
	DbgPrint("ERROR GetStockObject brush/pen 4\n");

    if (GetStockObject(GRAY_BRUSH) != SelectObject(hdcScreen, GetStockObject(LTGRAY_BRUSH)))
	DbgPrint("Select on Stock object failed\n");

    PatBlt(hdcScreen, 264, 0, 32, 32, PATCOPY);

    if (((HBRUSH) 0) == GetStockObject(WHITE_BRUSH))
	DbgPrint("ERROR GetStockObject brush/pen 2\n");

    if (GetStockObject(LTGRAY_BRUSH) != SelectObject(hdcScreen, GetStockObject(WHITE_BRUSH)))
	DbgPrint("Select on Stock object failed\n");

    PatBlt(hdcScreen, 296, 0, 32, 32, PATCOPY);

    if (((HBRUSH) 0) == GetStockObject(HOLLOW_BRUSH))
	DbgPrint("ERROR GetStockObject brush/pen 5\n");
    if (((HBRUSH) 0) == GetStockObject(NULL_BRUSH))
	DbgPrint("ERROR GetStockObject brush/pen 6\n");

// test for valid pens

    if (((HBRUSH) 0) == GetStockObject(BLACK_PEN))
	DbgPrint("ERROR GetStockObject brush/pen 7\n");
    if (((HBRUSH) 0) == GetStockObject(WHITE_PEN))
	DbgPrint("ERROR GetStockObject brush/pen 8\n");
    if (((HBRUSH) 0) == GetStockObject(NULL_PEN))
	DbgPrint("ERROR GetStockObject brush/pen 9\n");

/*
    DbgPrint("These are the handles %lu %lu %lu\n",
		GetStockObject(BLACK_PEN),
		GetStockObject(WHITE_PEN),
		GetStockObject(NULL_PEN));
*/

    SelectObject(hdcScreen, GetStockObject(BLACK_PEN));

    hPenOld = SelectObject(hdcScreen, GetStockObject(WHITE_PEN));

    if (GetStockObject(BLACK_PEN) != hPenOld)
	DbgPrint("ERROR of select white pen %lu %lu\n",
		       hPenOld, GetStockObject(BLACK_PEN));

    hPenOld = SelectObject(hdcScreen, GetStockObject(NULL_PEN));

    if (GetStockObject(WHITE_PEN) != hPenOld)
	DbgPrint("ERROR of select NULL pen %lu %lu\n",
		       hPenOld, GetStockObject(NULL_PEN));

/*************************************************************************

    Test Solid Brush Output to 8

**************************************************************************/

    SelectObject(hdcScreen, hbrushGreen);
    SelectObject(hdc8Lines, hbrushGreen);

    PatBlt(hdcScreen, 0, 300, 100, 99, PATCOPY);

    PatBlt(hdc8Lines, 0, 0, 9, 8, PATCOPY);

    if(!BitBlt(hdcScreen, 0, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    PatBlt(hdc8Lines, 0, 8, 4, 8, PATCOPY);

    if(!BitBlt(hdcScreen, 32, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    PatBlt(hdc8Lines, 1, 16, 2, 8, PATCOPY);

    if(!BitBlt(hdcScreen, 64, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    PatBlt(hdc8Lines, 2, 24, 4, 8, PATCOPY);

    if(!BitBlt(hdcScreen, 96, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 0, 0, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 128, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/*************************************************************************

    Test Solid Brush Output to 8 generally

**************************************************************************/

    PatBlt(hdc8Lines, 0, 0, 9, 8, 0x00020000);

    if(!BitBlt(hdcScreen, 0, 352, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    PatBlt(hdc8Lines, 0, 8, 4, 8, 0x00020000);

    if(!BitBlt(hdcScreen, 32, 352, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    PatBlt(hdc8Lines, 1, 16, 2, 8, 0x00020000);

    if(!BitBlt(hdcScreen, 64, 352, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    PatBlt(hdc8Lines, 2, 24, 4, 8, 0x00020000);

    if(!BitBlt(hdcScreen, 96, 352, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 0, 0, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 128, 352, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/*********************************************************************

    8 on 8 tests

***********************************************************************/

    if(!BitBlt(hdc8Lines, 8, 16, 8, 8, hdc8Lines0, 16, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 0, 256, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 24, 24, 8, 8, hdc8Lines, 16, 16, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 32, 256, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 0, 24, 8, 8, hdc8Lines, 16, 16, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 64, 256, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 24, 0, 8, 8, hdc8Lines, 16, 16, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 96, 256, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 0, 0, 8, 8, hdc8Lines, 16, 16, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 16, 16, 8, 8, hdc8Lines, 16, 16, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 128, 256, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 0, 0, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 160, 256, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/*********************************************************************

    8 on 8 generally

***********************************************************************/

    if(!BitBlt(hdc8Lines, 8, 16, 8, 8, hdc8Lines0, 16, 0, 0x00010000))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 0, 288, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 24, 24, 8, 8, hdc8Lines, 16, 16, 0x00010000))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 32, 288, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 0, 24, 8, 8, hdc8Lines, 16, 16, 0x00010000))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 64, 288, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 24, 0, 8, 8, hdc8Lines, 16, 16, 0x00010000))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 96, 288, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 0, 0, 8, 8, hdc8Lines, 16, 16, 0x00010000))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 16, 16, 8, 8, hdc8Lines, 16, 16, 0x00010000))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 128, 288, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 0, 0, 32, 32, hdc8Lines0, 0, 0, 0x00010000))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 160, 288, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/************************************************************************

    Test 1 to 8 blting

*************************************************************************/

    if(!BitBlt(hdc8Lines, 4,4, 16, 16, hdc1Cat, 4, 4, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 0, 0, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 4, 4, 17, 17, hdc1Cat, 4, 4, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 32, 0, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 3, 3, 25, 25, hdc1Cat, 3, 3, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 64, 0, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 3, 3, 26, 26, hdc1Cat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 96, 0, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 0, 0, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 128, 0, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/************************************************************************

    Test 1 to 8 blting generally

*************************************************************************/

    if(!BitBlt(hdc8Lines, 4,4, 16, 16, hdc1Cat, 4, 4, 0x00010000))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 0, 32, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 4, 4, 17, 17, hdc1Cat, 4, 4, 0x00010000))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 32, 32, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 3, 3, 25, 25, hdc1Cat, 3, 3, 0x00010000))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 64, 32, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 3, 3, 26, 26, hdc1Cat, 0, 0, 0x00010000))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 96, 32, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 0, 0, 32, 32, hdc8Lines0, 0, 0, 0x00010000))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 128, 32, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/*************************************************************************

    Test 4 to 8 blting

**************************************************************************/

    if(!BitBlt(hdc8Lines, 4,4, 16, 16, hdc4Lines, 4, 4, SRCCOPY))
        DbgPrint("ERR