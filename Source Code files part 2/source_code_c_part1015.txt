ge(CDataExchange * pDX)
{
    if (!pDX->m_bSaveAndValidate || !BSaved())
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // TODO: Modify the following lines to represent the data displayed on this page.
        //{{AFX_DATA_MAP(CPrintSpoolerParamsPage)
        DDX_Control(pDX, IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR, m_editSpoolDir);
        DDX_Control(pDX, IDC_PP_PRTSPOOL_PARAMS_DRIVER_DIR, m_editDriverDir);
        DDX_Text(pDX, IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR, m_strSpoolDir);
        DDX_Text(pDX, IDC_PP_PRTSPOOL_PARAMS_TIMEOUT, m_nJobCompletionTimeout);
        DDX_Text(pDX, IDC_PP_PRTSPOOL_PARAMS_DRIVER_DIR, m_strDriverDir);
        //}}AFX_DATA_MAP

        if (!BBackPressed())
        {
            DDX_Number(pDX, IDC_PP_PRTSPOOL_PARAMS_TIMEOUT, m_nJobCompletionTimeout, 0, 0x7fffffff / 1000);
        }

        if (pDX->m_bSaveAndValidate && !BBackPressed())
        {
            DDV_RequiredText(pDX, IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR, IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR_LABEL, m_strSpoolDir);
            DDV_MaxChars(pDX, m_strSpoolDir, MAX_PATH);
            DDV_Path(pDX, IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR, IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR_LABEL, m_strSpoolDir);

            DDV_MaxChars(pDX, m_strDriverDir, MAX_PATH);
            DDV_Path(pDX, IDC_PP_PRTSPOOL_PARAMS_DRIVER_DIR, IDC_PP_PRTSPOOL_PARAMS_DRIVER_DIR_LABEL, m_strDriverDir);
        }  // if:  saving data from dialog and back button not pressed
    }  // if:  not saving or haven't saved yet

    CBasePropertyPage::DoDataExchange(pDX);

}  //*** CPrintSpoolerParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPrintSpoolerParamsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CPrintSpoolerParamsPage::OnInitDialog(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Get a default value for the spool directory if it hasn't been set yet.
    if (m_strSpoolDir.GetLength() == 0)
        ConstructDefaultDirectory(m_strSpoolDir, IDS_DEFAULT_SPOOL_DIR);

    // Call the base class.
    CBasePropertyPage::OnInitDialog();

    // Set limits on the edit controls.
    m_editSpoolDir.SetLimitText(MAX_PATH);
    m_editDriverDir.SetLimitText(MAX_PATH);

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CPrintSpoolerParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPrintSpoolerParamsPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CPrintSpoolerParamsPage::OnSetActive(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Enable/disable the Next/Finish button.
    if (BWizard())
    {
        if (m_strSpoolDir.GetLength() == 0)
            EnableNext(FALSE);
        else
            EnableNext(TRUE);
    }  // if:  enable/disable the Next button

    return CBasePropertyPage::OnSetActive();

}  //*** CPrintSpoolerParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPrintSpoolerParamsPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CPrintSpoolerParamsPage::BApplyChanges(void)
{
    BOOL    bSuccess;
    CWaitCursor wc;

    // Convert the job completion timeout from seconds to milliseconds.
    m_nJobCompletionTimeout *= 1000;

    // Call the base class method.
    bSuccess = CBasePropertyPage::BApplyChanges();

    // Convert the job completion timeout back to seconds.
    if (bSuccess)
        m_nPrevJobCompletionTimeout = m_nJobCompletionTimeout;
    m_nJobCompletionTimeout /= 1000;

    return bSuccess;

}  //*** CPrintSpoolerParamsPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPrintSpoolerParamsPage::OnChangeSpoolDir
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Spool Folder edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CPrintSpoolerParamsPage::OnChangeSpoolDir(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeCtrl();

    if (BWizard())
    {
        if (m_editSpoolDir.GetWindowTextLength() == 0)
            EnableNext(FALSE);
        else
            EnableNext(TRUE);
    }  // if:  in a wizard

}  //*** CPrintSpoolerParamsPage::OnChangeSpoolDir()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\ipaddr.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      IpAddr.cpp
//
//  Abstract:
//      Implementation of the CIpAddrParamsPage class.
//
//  Author:
//      David Potter (davidp)   June 5, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <clusapi.h>
#include <clusudef.h>
#include "CluAdmX.h"
#include "ExtObj.h"
#include "IpAddr.h"
#include "DDxDDv.h"
#include "HelpData.h"
#include "PropList.h"
#include "AdmNetUtils.h"    // for BIsValidxxx net utility functions

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Need this because MFC is incompatible with IE4/5
#ifndef IPM_ISBLANK
#define IPM_ISBLANK (WM_USER+105)
#endif

/////////////////////////////////////////////////////////////////////////////
// CIpAddrParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CIpAddrParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CIpAddrParamsPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CIpAddrParamsPage)
    ON_EN_CHANGE(IDC_PP_IPADDR_PARAMS_SUBNET_MASK, OnChangeSubnetMask)
    ON_EN_CHANGE(IDC_PP_IPADDR_PARAMS_ADDRESS, OnChangeIPAddress)
    ON_EN_KILLFOCUS(IDC_PP_IPADDR_PARAMS_ADDRESS, OnKillFocusIPAddress)
    ON_CBN_SELCHANGE(IDC_PP_IPADDR_PARAMS_NETWORK, OnChangeRequiredFields)
    //}}AFX_MSG_MAP
    // TODO: Modify the following lines to represent the data displayed on this page.
    ON_BN_CLICKED(IDC_PP_IPADDR_PARAMS_ENABLE_NETBIOS, OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::CIpAddrParamsPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CIpAddrParamsPage::CIpAddrParamsPage(void)
    : CBasePropertyPage(g_aHelpIDs_IDD_PP_IPADDR_PARAMETERS, g_aHelpIDs_IDD_WIZ_IPADDR_PARAMETERS)
{
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_INIT(CIpAddrParamsPage)
    m_strIPAddress = _T("");
    m_strSubnetMask = _T("");
    m_strNetwork = _T("");
    m_bEnableNetBIOS = TRUE;
    //}}AFX_DATA_INIT

    // Setup the property array.
    {
        m_rgProps[epropNetwork].Set(REGPARAM_IPADDR_NETWORK, m_strNetwork, m_strPrevNetwork);
        m_rgProps[epropAddress].Set(REGPARAM_IPADDR_ADDRESS, m_strIPAddress, m_strPrevIPAddress);
        m_rgProps[epropSubnetMask].Set(REGPARAM_IPADDR_SUBNET_MASK, m_strSubnetMask, m_strPrevSubnetMask);
        m_rgProps[epropEnableNetBIOS].Set(REGPARAM_IPADDR_ENABLE_NETBIOS, m_bEnableNetBIOS, m_bPrevEnableNetBIOS);
    }  // Setup the property array

    m_iddPropertyPage = IDD_PP_IPADDR_PARAMETERS;
    m_iddWizardPage = IDD_WIZ_IPADDR_PARAMETERS;

    m_bIsSubnetUpdatedManually = FALSE;
    m_bIsIPAddressModified = TRUE;

}  //*** CIpAddrParamsPage::CIpAddrParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::~CIpAddrParamsPage
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CIpAddrParamsPage::~CIpAddrParamsPage(void)
{
    ClearNetworkObjectList();

}  //*** CIpAddrParamsPage::CIpAddrParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::HrInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      peo         [IN OUT] Pointer to the extension object.
//
//  Return Value:
//      S_OK        Page initialized successfully.
//      hr          Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CIpAddrParamsPage::HrInit(IN OUT CExtObject * peo)
{
    HRESULT     _hr;
    CWaitCursor _wc;

    do
    {
        // Call the base class method.
        _hr = CBasePropertyPage::HrInit(peo);
        if (FAILED(_hr))
            break;

        //
        // Initialize common controls.
        //
        {
#ifndef ICC_INTERNET_CLASSES
#define ICC_INTERNET_CLASSES 0x00000800
#endif
            static BOOL g_bInitializedCommonControls = FALSE;
            static INITCOMMONCONTROLSEX g_icce =
            {
                sizeof(g_icce),
                ICC_WIN95_CLASSES | ICC_INTERNET_CLASSES
            };

            if (!g_bInitializedCommonControls)
            {
                BOOL bSuccess;
                bSuccess = InitCommonControlsEx(&g_icce);
                _ASSERTE(bSuccess);
                g_bInitializedCommonControls = TRUE;
            } // if:  common controls not initialized yet
        } // Initialize common controls
    } while ( 0 );

    return _hr;

}  //*** CIpAddrParamsPage::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIpAddrParamsPage::DoDataExchange(CDataExchange * pDX)
{
    if (!pDX->m_bSaveAndValidate || !BSaved())
    {
        CString strMsg;

        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // TODO: Modify the following lines to represent the data displayed on this page.
        //{{AFX_DATA_MAP(CIpAddrParamsPage)
        DDX_Control(pDX, IDC_PP_IPADDR_PARAMS_ENABLE_NETBIOS, m_chkEnableNetBIOS);
        DDX_Control(pDX, IDC_PP_IPADDR_PARAMS_NETWORK, m_cboxNetworks);
        DDX_Control(pDX, IDC_PP_IPADDR_PARAMS_SUBNET_MASK, m_editSubnetMask);
        DDX_Control(pDX, IDC_PP_IPADDR_PARAMS_ADDRESS, m_editIPAddress);
        DDX_Text(pDX, IDC_PP_IPADDR_PARAMS_ADDRESS, m_strIPAddress);
        DDX_Text(pDX, IDC_PP_IPADDR_PARAMS_SUBNET_MASK, m_strSubnetMask);
        DDX_CBString(pDX, IDC_PP_IPADDR_PARAMS_NETWORK, m_strNetwork);
        DDX_Check(pDX, IDC_PP_IPADDR_PARAMS_ENABLE_NETBIOS, m_bEnableNetBIOS);
        //}}AFX_DATA_MAP

        if (pDX->m_bSaveAndValidate)
        {
            if (!BBackPressed())
            {
                DDV_RequiredText(pDX, IDC_PP_IPADDR_PARAMS_NETWORK, IDC_PP_IPADDR_PARAMS_NETWORK_LABEL, m_strNetwork);
                DDV_RequiredText(pDX, IDC_PP_IPADDR_PARAMS_ADDRESS, IDC_PP_IPADDR_PARAMS_ADDRESS_LABEL, m_strIPAddress);
                DDV_RequiredText(pDX, IDC_PP_IPADDR_PARAMS_SUBNET_MASK, IDC_PP_IPADDR_PARAMS_SUBNET_MASK_LABEL, m_strSubnetMask);

                if (!BIsValidIpAddress(m_strIPAddress))
                {
                    strMsg.FormatMessage(IDS_INVALID_IP_ADDRESS, m_strIPAddress);
                    AfxMessageBox(strMsg, MB_OK | MB_ICONEXCLAMATION);
                    DDX_Text(pDX, IDC_PP_IPADDR_PARAMS_ADDRESS, m_strIPAddress);
                    strMsg.Empty();
                    pDX->Fail();
                }  // if:  invalid address

                //
                // Make sure we process the IP address.
                // If we don't call it here, and the user pressed a tab button
                // while sitting in the IP address field, the EN_KILLFOCUS
                // message won't get processed until after this method returns.
                //
                if (   (m_strSubnetMask.GetLength() == 0)
                    || (m_editSubnetMask.SendMessage(IPM_ISBLANK, 0, 0)) )
                {
                    OnKillFocusIPAddress();
                } // if:  subnet mask not specified

                if (!BIsValidSubnetMask(m_strSubnetMask))
                {
                    strMsg.FormatMessage(IDS_INVALID_SUBNET_MASK, m_strSubnetMask);
                    AfxMessageBox(strMsg, MB_OK | MB_ICONEXCLAMATION);
                    DDX_Text(pDX, IDC_PP_IPADDR_PARAMS_SUBNET_MASK, m_strSubnetMask);
                    strMsg.Empty();
                    pDX->Fail();
                }  // if:  invalid subnet mask

                if (!BIsValidIpAddressAndSubnetMask(m_strIPAddress, m_strSubnetMask))
                {
                    strMsg.FormatMessage(IDS_INVALID_ADDRESS_AND_SUBNET_MASK, m_strIPAddress, m_strSubnetMask);
                    AfxMessageBox(strMsg, MB_OK | MB_ICONEXCLAMATION);
                    DDX_Text(pDX, IDC_PP_IPADDR_PARAMS_ADDRESS, m_strIPAddress);
                    strMsg.Empty();
                    pDX->Fail();
                }  // if:  invalid address-mask combination

                if (BIsSubnetUpdatedManually())
                {
                    int id = AfxMessageBox(IDS_IP_SUBNET_CANT_BE_VALIDATED, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION);
                    if (id != IDYES)
                    {
                        DDX_Text(pDX, IDC_PP_IPADDR_PARAMS_SUBNET_MASK, m_strSubnetMask);
                        pDX->Fail();
                    }  // if:  subnet mask not valid
                }  // if:  subnet mask has been updated manually

                //
                // If there are Network Name resources dependent on this resource
                // and the EnableNetBIOS checkbox is unchecked, display a warning.
                //
                if (Peo()->BIsAnyNodeVersionLowerThanNT5() && !m_bEnableNetBIOS)
                {
                    if (BIsNetNameProvider())
                    {
                        m_chkEnableNetBIOS.SetCheck(BST_CHECKED);
                        AfxMessageBox(IDS_IP_PROVIDES_FOR_NETNAME, MB_ICONEXCLAMATION);
                        DDX_Check(pDX, IDC_PP_IPADDR_PARAMS_ENABLE_NETBIOS, m_bEnableNetBIOS);
                        pDX->Fail();
                    } // if:  resource provides for net name resource
                    else
                    {
                        int id = AfxMessageBox(IDS_NETNAMES_MAY_NOT_WORK, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION);
                        if (id != IDYES)
                        {
                            m_chkEnableNetBIOS.SetCheck(BST_CHECKED);
                            DDX_Check(pDX, IDC_PP_IPADDR_PARAMS_ENABLE_NETBIOS, m_bEnableNetBIOS);
                            pDX->Fail();
                        } // if:  user didn't continue
                    } // else:  resource doesn't provide for net name resource
                } // if:  in NT4 Sp3 or Sp4 cluster with and no NetBIOS support
            }  // if:  Back button not pressed
        }  // if:  saving data
    }  // if:  not saving or haven't saved yet

    CBasePropertyPage::DoDataExchange(pDX);

}  //*** CIpAddrParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIpAddrParamsPage::OnInitDialog(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBasePropertyPage::OnInitDialog();

    // Collect networks and fill the combobox.
    {
        POSITION            pos;
        CNetworkObject *    pno;
        int                 inet;

        CollectNetworks();

        pos = m_lnetobjNetworks.GetHeadPosition();
        while (pos != NULL)
        {
            pno = m_lnetobjNetworks.GetNext(pos);
            ASSERT(pno != NULL);
            inet = m_cboxNetworks.AddString(pno->m_strName);
            ASSERT(inet != CB_ERR);
            m_cboxNetworks.SetItemDataPtr(inet, pno);
        }  // while:  more items in the list

        // Default to the first one if creating a new resource.
        if (BWizard())
        {
            if (m_lnetobjNetworks.GetCount() != 0)
            {
                pos = m_lnetobjNetworks.GetHeadPosition();
                pno = m_lnetobjNetworks.GetNext(pos);
                ASSERT(pno != NULL);
                m_strNetwork = pno->m_strName;
            }  // if:  list is not empty
        }  // if:  creating new resource

        // Set the current selection.
        UpdateData(FALSE /*bSaveAndValidate*/);
    }  // Fill the combobox

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CIpAddrParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE notification message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIpAddrParamsPage::OnSetActive(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Enable/disable the Next/Finish button.
    if (BWizard())
    {
        if ((m_strIPAddress.GetLength() == 0)
                || (m_strSubnetMask.GetLength() == 0)
                || (m_strNetwork.GetLength() == 0))
            EnableNext(FALSE);
        else
            EnableNext(TRUE);
    }  // if:  enable/disable the Next button

    return CBasePropertyPage::OnSetActive();

}  //*** CIpAddrParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::OnChangeRequiredFields
//
//  Routine Description:
//      Handler for the EN_CHANGE message on required fields.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIpAddrParamsPage::OnChangeRequiredFields(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeCtrl();

    if (BWizard())
    {
        if ((m_editIPAddress.GetWindowTextLength() == 0)
                || (m_editSubnetMask.GetWindowTextLength() == 0)
                || (m_cboxNetworks.GetCurSel() == CB_ERR))
            EnableNext(FALSE);
        else
            EnableNext(TRUE);
    }  // if:  in a wizard

}  //*** CIpAddrParamsPage::OnChangeRequiredFields()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::OnChangeSubnetMask
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Subnet Mask field.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIpAddrParamsPage::OnChangeSubnetMask(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeRequiredFields();
    m_bIsSubnetUpdatedManually = TRUE;

}  //*** CIpAddrParamsPage::OnChangeSubnetMask()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::OnChangeIPAddress
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the IP Address field.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIpAddrParamsPage::OnChangeIPAddress(void) 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeRequiredFields();
    m_bIsIPAddressModified = TRUE;

}  //*** CIpAddrParamsPage::OnChangeIPAddress
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::OnKillFocusIPAddress
//
//  Routine Description:
//      Handler for the EN_KILLFOCUS command notification on
//      IDC_PP_IPADDR_PARAMS_ADDRESS.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIpAddrParamsPage::OnKillFocusIPAddress(void)
{
    if ( m_bIsIPAddressModified != FALSE )
    {
        CString             strAddress;
        CNetworkObject *    pno;

        m_editIPAddress.GetWindowText(strAddress);

        if (strAddress.GetLength() == 0)
        {
            m_editIPAddress.SetSel(0, 0, FALSE);
        } // if:  empty string
        else if (!BIsValidIpAddress(strAddress))
        {
        } // else if:  invalid address
        else
        {
            pno = PnoNetworkFromIpAddress(strAddress);
            if (pno != NULL)
            {
                SelectNetwork(pno);
            } // if:  network found
            else
            {
    //          m_editSubnetMask.SetWindowText(_T(""));
            } // else:  network not found
        } // else:  valid address

        m_bIsIPAddressModified = FALSE;
    } // if:  the IP Address field has been modified

} //*** CIpAddrParamsPage::OnKillFocusIPAddress()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::CollectNetworks
//
//  Routine Description:
//      Collect the networks in the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIpAddrParamsPage::CollectNetworks(void)
{
    DWORD                   dwStatus;
    DWORD                   inet;
    CLUSTER_NETWORK_ROLE    nRole;
    DWORD                   nType;
    DWORD                   cchNameCurrent;
    DWORD                   cchName = 256;
    LPWSTR                  pszName = NULL;
    LPWSTR                  psz;
    HCLUSENUM               hclusenum = NULL;
    HNETWORK                hnetwork = NULL;
    CClusPropList           cpl;
    CNetworkObject *        pno = NULL;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Clear the existing list.
    ClearNetworkObjectList();

    try
    {
        // Open an enumerator.
        hclusenum = ClusterOpenEnum(Hcluster(), CLUSTER_ENUM_NETWORK);
        if (hclusenum != NULL)
        {
            // Allocate a name buffer.
            pszName = new WCHAR[cchName];
            if ( pszName == NULL )
                goto Cleanup;

            for (inet = 0 ; ; inet++)
            {
                // Get the next network name.
                cchNameCurrent = cchName;
                dwStatus = ClusterEnum(hclusenum, inet, &nType, pszName, &cchNameCurrent);
                if (dwStatus == ERROR_MORE_DATA)
                {
                    delete [] pszName;
                    cchName = ++cchNameCurrent;
                    pszName = new WCHAR[cchNameCurrent];
                    if ( pszName == NULL )
                        goto Cleanup;
                    dwStatus = ClusterEnum(hclusenum, inet, &nType, pszName, &cchNameCurrent);
                }  // if:  buffer is too small
                if (dwStatus == ERROR_NO_MORE_ITEMS)
                    break;

                // Open the network.
                if (hnetwork != NULL)
                    CloseClusterNetwork(hnetwork);
                hnetwork = OpenClusterNetwork(Hcluster(), pszName);
                if (hnetwork == NULL)
                    continue;

                // Get properties on the network.
                dwStatus = cpl.ScGetNetworkProperties(hnetwork, CLUSCTL_NETWORK_GET_COMMON_PROPERTIES);
                if (dwStatus != ERROR_SUCCESS)
                    continue;

                // Find the Role property.
                dwStatus = ResUtilFindDwordProperty(
                                        cpl.PbPropList(),
                                        cpl.CbPropList(),
                                        CLUSREG_NAME_NET_ROLE,
                                        (DWORD *) &nRole
                                        );
                if (dwStatus != ERROR_SUCCESS)
                    continue;

                // If this network is used for client access, add it to the list.
                if (nRole & ClusterNetworkRoleClientAccess)
                {
                    // Allocate a network object and store common properties.
                    pno = new CNetworkObject;
                    if ( pno == NULL )
                        goto Cleanup;
                    pno->m_strName = pszName;
                    pno->m_nRole = nRole;

                    // Get read-only common properties.
                    dwStatus = cpl.ScGetNetworkProperties(hnetwork, CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES);
                    if (dwStatus != ERROR_SUCCESS)
                    {
                        delete pno;
                        pno = NULL;
                        continue;
                    }  // if:  error getting read-only common properties

                    // Get the address property.
                    dwStatus = ResUtilFindSzProperty(
                                            cpl.PbPropList(),
                                            cpl.CbPropList(),
                                            CLUSREG_NAME_NET_ADDRESS,
                                            &psz
                                            );
                    if (dwStatus != ERROR_SUCCESS)
                    {
                        delete pno;
                        pno = NULL;
                        continue;
                    }  // if:  error getting property
                    pno->m_strAddress = psz;

                    // Get the address mask property.
                    dwStatus = ResUtilFindSzProperty(
                                            cpl.PbPropList(),
                                            cpl.CbPropList(),
                                            CLUSREG_NAME_NET_ADDRESS_MASK,
                                            &psz
                                            );
                    if (dwStatus != ERROR_SUCCESS)
                    {
                        delete pno;
                        pno = NULL;
                        continue;
                    }  // if:  error getting property
                    pno->m_strAddressMask = psz;

                    // Convert the strings to numbers.
                    dwStatus = ClRtlTcpipStringToAddress(pno->m_strAddress, &pno->m_nAddress);
                    if (dwStatus == ERROR_SUCCESS)
                        dwStatus = ClRtlTcpipStringToAddress(pno->m_strAddressMask, &pno->m_nAddressMask);
                    if (dwStatus != ERROR_SUCCESS)
                    {
                        delete pno;
                        pno = NULL;
                        continue;
                    }  // if:  error getting property

                    // Add the network to the list.
                    m_lnetobjNetworks.AddTail(pno);
                    pno = NULL;
                }  // if:  network is used for client access
            }  // for:  each network
        }  // if:  enumerator opened successful
    }  // try
    catch (CException * pe)
    {
        pe->Delete();
    }  // catch:  CException

Cleanup:
    delete pno;
    delete [] pszName;
    if (hclusenum != NULL)
        ClusterCloseEnum(hclusenum);
    if (hnetwork != NULL)
        CloseClusterNetwork(hnetwork);

}  //*** CIpAddrParamsPage::CollectNetworks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::ClearNetworkObjectList
//
//  Routine Description:
//      Remove all the entries in the network object list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIpAddrParamsPage::ClearNetworkObjectList(void)
{
    POSITION            pos;
    CNetworkObject *    pno;

    pos = m_lnetobjNetworks.GetHeadPosition();
    while (pos != NULL)
    {
        pno = m_lnetobjNetworks.GetNext(pos);
        ASSERT(pno != NULL);
        delete pno;
    }  // while:  more items in the list

    m_lnetobjNetworks.RemoveAll();

}  //*** CIpAddrParamsPage::ClearNetworkObjectList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::PnoNetworkFromIpAddress
//
//  Routine Description:
//      Find the network for the specified IP address.
//
//  Arguments:
//      pszAddress      [IN] IP address to match.
//
//  Return Value:
//      NULL            No matching network found.
//      pno             Network that supports the specfied IP address.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetworkObject * CIpAddrParamsPage::PnoNetworkFromIpAddress(IN LPCWSTR pszAddress)
{
    DWORD               dwStatus;
    DWORD               nAddress;
    POSITION            pos;
    CNetworkObject *    pno;

    // Convert the address to a number.
    dwStatus = ClRtlTcpipStringToAddress(pszAddress, &nAddress);
    if (dwStatus != ERROR_SUCCESS)
        return NULL;

    // Search the list for a matching address.
    pos = m_lnetobjNetworks.GetHeadPosition();
    while (pos != NULL)
    {
        pno = m_lnetobjNetworks.GetNext(pos);
        ASSERT(pno != NULL);

        if (ClRtlAreTcpipAddressesOnSameSubnet(nAddress, pno->m_nAddress, pno->m_nAddressMask))
            return pno;
    }  // while:  more items in the list

    return NULL;

}  //*** CIpAddrParamsPage::PnoNetworkFromIpAddress()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::SelectNetwork
//
//  Routine Description:
//      Select the specified network in the network combobox, and set the
//      subnet mask in the subnet mask edit control.
//
//  Arguments:
//      pno         [IN] Network object structure for network to select.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIpAddrParamsPage::SelectNetwork(IN CNetworkObject * pno)
{
    int     inet;
    CString strSubnetMask;

    ASSERT(pno != NULL);

    // Find the proper item in the checkbox.
    inet = m_cboxNetworks.FindStringExact(-1, pno->m_strName);
    if (inet != CB_ERR)
    {
        m_cboxNetworks.SetCurSel(inet);
        m_editSubnetMask.GetWindowText(strSubnetMask);
        if (strSubnetMask != pno->m_strAddressMask)
            m_editSubnetMask.SetWindowText(pno->m_strAddressMask);
        m_bIsSubnetUpdatedManually = FALSE;
        m_strSubnetMask = pno->m_strAddressMask;
        m_strNetwork = pno->m_strName;
    }  // if:  match found

}  //*** CIpAddrParamsPage::SelectNetwork()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::BIsNetNameProvider
//
//  Routine Description:
//      Determine if a network name resource is dependent on this resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIpAddrParamsPage::BIsNetNameProvider(void)
{
    DWORD                       dwStatus = ERROR_SUCCESS;
    BOOL                        bIsNetNameProvider = FALSE;
    HRESENUM                    hresenum;
    HRESOURCE                   hres = NULL;
    DWORD                       ires;
    DWORD                       dwType;
    DWORD                       cchName;
    DWORD                       cchNameSize;
    DWORD                       cbResType;
    DWORD                       cbResTypeSize;
    LPWSTR                      pszName = NULL;
    LPWSTR                      pszResType = NULL;

    // Open the provides-for enumerator.
    hresenum = ClusterResourceOpenEnum(
                        Peo()->PrdResData()->m_hresource,
                        CLUSTER_RESOURCE_ENUM_PROVIDES
                        );
    if (hresenum == NULL)
        return NULL;

    // Allocate a default size name and type buffer.
    cchNameSize = 512;
    pszName = new WCHAR[cchNameSize];
    if ( pszName == NULL )
    {
        dwStatus = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    cbResTypeSize = 256;
    pszResType = new WCHAR[cbResTypeSize / 2];
    if ( pszResType == NULL )
    {
        dwStatus = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    for (ires = 0 ; ; ires++)
    {
        // Get the name of the next resource.
        cchName = cchNameSize;
        dwStatus = ClusterResourceEnum(
                            hresenum,
                            ires,
                            &dwType,
                            pszName,
                            &cchName
                            );
        if (dwStatus == ERROR_MORE_DATA)
        {
            delete [] pszName;
            cchNameSize = cchName;
            pszName = new WCHAR[cchNameSize];
            if ( pszName == NULL )
            {
                dwStatus = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }
            dwStatus = ClusterResourceEnum(
                                hresenum,
                                ires,
                                &dwType,
                                pszName,
                                &cchName
                                );
        }  // if:  name buffer too small
        if (dwStatus != ERROR_SUCCESS)
            break;

        // Open the resource.
        hres = OpenClusterResource(Hcluster(), pszName);
        if (hres == NULL)
        {
            dwStatus = GetLastError();
            break;
        }  // if:  error opening the resource

        // Get the type of the resource.
        dwStatus = ClusterResourceControl(
                            hres,
                            NULL,
                            CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                            NULL,
                            0,
                            pszResType,
                            cbResTypeSize,
                            &cbResType
                            );
        if (dwStatus == ERROR_MORE_DATA)
        {
            delete [] pszResType;
            cbResTypeSize = cbResType;
            pszResType = new WCHAR[cbResTypeSize / 2];
            if ( pszResType == NULL )
            {
                dwStatus = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }
            dwStatus = ClusterResourceControl(
                                hres,
                                NULL,
                                CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                                NULL,
                                0,
                                pszResType,
                                cbResTypeSize,
                                &cbResType
                                );
        }  // if:  resource type buffer too small
        if (dwStatus != ERROR_SUCCESS)
            break;

        // If this is a Network Name resource, we're done.
        if (lstrcmpiW(pszResType, CLUS_RESTYPE_NAME_NETNAME) == 0)
        {
            bIsNetNameProvider = TRUE;
            break;
        }  // if:  resource is a Network Name

        // Not storage-class resource.
        CloseClusterResource(hres);
        hres = NULL;
    }  // for each resource on which we are dependent

Cleanup:
    // Handle errors.
    if ( hres != NULL )
    {
        CloseClusterResource(hres);
        hres = NULL;
    }  // if:  error getting resource

    ClusterResourceCloseEnum(hresenum);
    delete [] pszName;
    delete [] pszResType;

    return bIsNetNameProvider;

}  //*** CIpAddrParamsPage::BIsNetNameProvider()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\ipaddr.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		IpAddr.h
//
//	Abstract:
//		Definition of the CIpAddrParamsPage class, which implements the
//		Parameters page for IP Address resources.
//
//	Implementation File:
//		IpAddr.cpp
//
//	Author:
//		David Potter (davidp)	June 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _IPADDR_H_
#define _IPADDR_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

struct CNetworkObject;
class CIpAddrEdit;
class CIpAddrParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CNetworkObject
/////////////////////////////////////////////////////////////////////////////

struct CNetworkObject
{
	CString					m_strName;
	CLUSTER_NETWORK_ROLE	m_nRole;
	CString					m_strAddress;
	CString					m_strAddressMask;

	DWORD					m_nAddress;
	DWORD					m_nAddressMask;

};  //*** struct CNetworkObject

typedef CList< CNetworkObject*, CNetworkObject* > CNetObjectList;


/////////////////////////////////////////////////////////////////////////////
// class CIpAddrParamsPage
/////////////////////////////////////////////////////////////////////////////

class CIpAddrParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CIpAddrParamsPage)

// Construction
public:
	CIpAddrParamsPage(void);
	~CIpAddrParamsPage(void);

	// Second phase construction.
	virtual HRESULT		HrInit(IN OUT CExtObject * peo);

// Dialog Data
	//{{AFX_DATA(CIpAddrParamsPage)
	enum { IDD = IDD_PP_IPADDR_PARAMETERS };
	CButton	m_chkEnableNetBIOS;
	CComboBox	m_cboxNetworks;
	CEdit	m_editSubnetMask;
	CEdit	m_editIPAddress;
	CString	m_strIPAddress;
	CString	m_strSubnetMask;
	CString	m_strNetwork;
	BOOL	m_bEnableNetBIOS;
	//}}AFX_DATA
	CString	m_strPrevIPAddress;
	CString	m_strPrevSubnetMask;
	CString	m_strPrevNetwork;
	BOOL	m_bPrevEnableNetBIOS;
	CNetObjectList	m_lnetobjNetworks;

	CNetworkObject *	PnoNetworkFromIpAddress(IN LPCWSTR pszAddress);
	void				SelectNetwork(IN CNetworkObject * pno);

	BOOL				m_bIsSubnetUpdatedManually;
	BOOL				BIsSubnetUpdatedManually(void) const	{ return m_bIsSubnetUpdatedManually; }

	BOOL				m_bIsIPAddressModified;
	BOOL				BIsIPAddressModified(void) const	{ return m_bIsIPAddressModified; }

protected:
	enum
	{
		epropNetwork,
		epropAddress,
		epropSubnetMask,
		epropEnableNetBIOS,
		epropMAX
	};

	CObjectProperty		m_rgProps[epropMAX];

// Overrides
public:
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CIpAddrParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }

// Implementation
protected:
	void				CollectNetworks(void);
	void				ClearNetworkObjectList(void);
	BOOL				BIsNetNameProvider(void);

	// Generated message map functions
	//{{AFX_MSG(CIpAddrParamsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeSubnetMask();
	afx_msg void OnKillFocusIPAddress();
	afx_msg void OnChangeRequiredFields();
	afx_msg void OnChangeIPAddress();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CIpAddrParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _IPADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\prtspool.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1999 Microsoft Corporation
//
//  Module Name:
//      PrtSpool.h
//
//  Abstract:
//      Definition of the CPrintSpoolerParamsPage class, which implements the
//      Parameters page for Print Spooler resources.
//
//  Implementation File:
//      PrtSpool.cpp
//
//  Author:
//      David Potter (davidp)   October 17, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _PRTSPOOL_H_
#define _PRTSPOOL_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"   // for CBasePropertyPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CPrintSpoolerParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CPrintSpoolerParamsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CPrintSpoolerParamsPage : public CBasePropertyPage
{
    DECLARE_DYNCREATE(CPrintSpoolerParamsPage)

// Construction
public:
    CPrintSpoolerParamsPage(void);

    // Second phase construction.
    virtual HRESULT     HrInit(IN OUT CExtObject * peo);

// Dialog Data
    //{{AFX_DATA(CPrintSpoolerParamsPage)
    enum { IDD = IDD_PP_PRTSPOOL_PARAMETERS };
    CEdit   m_editSpoolDir;
    CString m_strSpoolDir;
    DWORD   m_nJobCompletionTimeout;
    CEdit   m_editDriverDir;
    CString m_strDriverDir;
    //}}AFX_DATA
    CString m_strPrevSpoolDir;
    DWORD   m_nPrevJobCompletionTimeout;
    CString m_strPrevDriverDir;

protected:
    enum
    {
        epropSpoolDir,
        epropTimeout,
        epropDriverDir,
        epropMAX
    };

    CObjectProperty     m_rgProps[epropMAX];

// Overrides
public:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrintSpoolerParamsPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    virtual BOOL        BApplyChanges(void);

protected:
    virtual const CObjectProperty * Pprops(void) const  { return m_rgProps; }
    virtual DWORD                   Cprops(void) const  { return sizeof(m_rgProps) / sizeof(CObjectProperty); }

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CPrintSpoolerParamsPage)
    afx_msg void OnChangeSpoolDir();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CPrintSpoolerParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _PRTSPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\regexts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		RegExtS.cpp
//
//	Abstract:
//		Stub for implementation of extension registration classes.
//
//	Author:
//		David Potter (davidp)	May 16, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "RegExt.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\regkey.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		RegKey.cpp
//
//	Abstract:
//		Implementation of the CEditRegKeyDlg class.
//
//	Author:
//		David Potter (davidp)	February 23, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "RegKey.h"
#include "HelpData.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditRegKeyDlg dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CEditRegKeyDlg, CBaseDialog)
	//{{AFX_MSG_MAP(CEditRegKeyDlg)
	ON_EN_CHANGE(IDC_REGKEY, OnChangeRegKey)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CEditRegKeyDlg::CEditRegKeyDlg
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pParent			[IN] Parent window for the dialog.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CEditRegKeyDlg::CEditRegKeyDlg(CWnd * pParent /*=NULL*/)
	: CBaseDialog(IDD, g_aHelpIDs_IDD_EDIT_REGKEY, pParent)
{
	//{{AFX_DATA_INIT(CEditRegKeyDlg)
	m_strRegKey = _T("");
	//}}AFX_DATA_INIT

}  //*** CEditRegKeyDlg::CEditRegKeyDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CEditRegKeyDlg::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CEditRegKeyDlg::DoDataExchange(CDataExchange * pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEditRegKeyDlg)
	DDX_Control(pDX, IDOK, m_pbOK);
	DDX_Control(pDX, IDC_REGKEY, m_editRegKey);
	DDX_Text(pDX, IDC_REGKEY, m_strRegKey);
	//}}AFX_DATA_MAP

}  //*** CEditRegKeyDlg::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CEditRegKeyDlg::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CEditRegKeyDlg::OnInitDialog(void)
{
	CBaseDialog::OnInitDialog();

	if (m_strRegKey.GetLength() == 0)
		m_pbOK.EnableWindow(FALSE);

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CEditRegKeyDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CEditRegKeyDlg::OnChangeRegKey
//
//	Routine Description:
//		Handler for the EN_CHANGE message on the Name edit control.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CEditRegKeyDlg::OnChangeRegKey(void)
{
	BOOL	bEnable;

	bEnable = (m_editRegKey.GetWindowTextLength() > 0);
	m_pbOK.EnableWindow(bEnable);

}  //*** CEditRegKeyDlg::OnChangeRegKey()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\regkey.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		RegKey.h
//
//	Abstract:
//		Definition of the CEditRegKeyDlg class, which implements a dialog
//		allowing the user to enter or modify a registry key.
//
//	Implementation File:
//		RegKey.cpp
//
//	Author:
//		David Potter (davidp)	February 23, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _REGKEY_H_
#define _REGKEY_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEDLG_H_
#include "BaseDlg.h"	// for CBaseDialog
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CEditRegKeyDlg;

/////////////////////////////////////////////////////////////////////////////
// CEditRegKeyDlg dialog
/////////////////////////////////////////////////////////////////////////////

class CEditRegKeyDlg : public CBaseDialog
{
// Construction
public:
	CEditRegKeyDlg(CWnd * pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CEditRegKeyDlg)
	enum { IDD = IDD_EDIT_REGKEY };
	CButton	m_pbOK;
	CEdit	m_editRegKey;
	CString	m_strRegKey;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditRegKeyDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEditRegKeyDlg)
	afx_msg void OnChangeRegKey();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CEditRegKeyDlg

/////////////////////////////////////////////////////////////////////////////

#endif // _REGKEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\regrepl.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		RegRepl.h
//
//	Abstract:
//		Definition of the CRegReplParamsPage class, which implements the
//		Registry Replication page for Generic Application and Generic
//		Service resources.
//
//	Implementation File:
//		RegRepl.cpp
//
//	Author:
//		David Potter (davidp)	February 23, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _REGREPL_H_
#define _REGREPL_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegReplParamsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CRegReplParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CRegReplParamsPage)

// Construction
public:
	CRegReplParamsPage(void);
	~CRegReplParamsPage(void);

	// Second phase construction.
	virtual HRESULT	HrInit(IN OUT CExtObject * peo);

// Dialog Data
	//{{AFX_DATA(CRegReplParamsPage)
	enum { IDD = IDD_PP_REGREPL_PARAMETERS };
	CButton	m_pbRemove;
	CButton	m_pbModify;
	CListCtrl	m_lcRegKeys;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRegReplParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL		BApplyChanges(void);

// Implementation
protected:
	LPWSTR				m_pwszRegKeys;

	LPCWSTR				PwszRegKeys(void) const		{ return m_pwszRegKeys; }
	DWORD				ScReadRegKeys(void);
	void				FillList(void);

	// Generated message map functions
	//{{AFX_MSG(CRegReplParamsPage)
	afx_msg void OnAdd();
	afx_msg void OnModify();
	afx_msg void OnRemove();
	virtual BOOL OnInitDialog();
	afx_msg void OnItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblClkList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CRegReplParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _REGREPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CluAdmEx.rc
//
#define IDD_PP_DISKS_PARAMETERS         120
#define IDD_PP_GENAPP_PARAMETERS        121
#define IDD_PP_GENSVC_PARAMETERS        122
#define IDD_PP_NETNAME_PARAMETERS       123
#define IDD_PP_FILESHR_PARAMETERS       124
#define IDD_PP_FILESHR_SECURITY         125
#define IDD_PP_IPADDR_PARAMETERS        126
#define IDD_PP_PRTSPOOL_PARAMETERS      127
#define IDD_PP_REGREPL_PARAMETERS       128
#define IDD_PP_GENSCRIPT_PARAMETERS     129
#define IDD_WIZ_DISKS_PARAMETERS        140
#define IDD_WIZ_GENAPP_PARAMETERS       141
#define IDD_WIZ_GENSVC_PARAMETERS       142
#define IDD_WIZ_IPADDR_PARAMETERS       143
#define IDD_WIZ_NETNAME_PARAMETERS      144
#define IDD_WIZ_FILESHR_PARAMETERS      145
#define IDD_WIZ_PRTSPOOL_PARAMETERS     146
#define IDD_WIZ_REGREPL_PARAMETERS      147
#define IDD_WIZ_GENSCRIPT_PARAMETERS    148
#define IDD_EDIT_REGKEY                 160
#define IDD_EDIT_CLUSTER_NAME           161
#define IDD_FILESHR_ADVANCED            162
#define IDD_FILESHR_CACHE_SETTINGS      163
#define IDI_ICON_FILEMGMT               500
#define IDC_PP_ICON                     1000
#define IDC_PP_TITLE                    1001
#define IDC_PP_NODE_PARAM_GROUP         1002
#define IDC_PP_NODES_LABEL              1003
#define IDC_PP_NODES                    1004
#define IDC_PP_GENAPP_PARAMS_IMAGE_NAME_LABEL 1010
#define IDC_PP_GENAPP_PARAMS_IMAGE_NAME 1011
#define IDC_PP_GENAPP_PARAMS_COMMAND_LINE_LABEL 1012
#define IDC_PP_GENAPP_PARAMS_COMMAND_LINE 1013
#define IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY_LABEL 1014
#define IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY 1015
#define IDC_PP_GENAPP_PARAMS_INTERACT_WITH_DESKTOP 1016
#define IDC_PP_GENAPP_PARAMS_USE_NETWORK_NAME 1017
#define IDC_PP_GENSVC_PARAMS_SERVICE_NAME_LABEL 1020
#define IDC_PP_GENSVC_PARAMS_SERVICE_NAME 1021
#define IDC_PP_GENSVC_PARAMS_COMMAND_LINE_LABEL 1022
#define IDC_PP_GENSVC_PARAMS_COMMAND_LINE 1023
#define IDC_PP_GENSVC_PARAMS_USE_NETWORK_NAME 1024
#define IDC_PP_NETNAME_PARAMS_NAME_LABEL 1030
#define IDC_PP_NETNAME_PARAMS_NAME      1031
#define IDC_PP_NETNAME_PARAMS_RENAME    1032
#define IDC_PP_NETNAME_PARAMS_CORE_TEXT 1033
#define IDC_PP_NETNAME_PARAMS_CORE_TEXT2 1034
#define IDC_PP_NETNAME_PARAMS_CHECKBOX_DNS 1035
#define IDC_PP_NETNAME_PARAMS_CHECKBOX_KERBEROS 1036
#define IDC_PP_NETNAME_PARAMS_STATUS_NETBIOS 1037
#define IDC_PP_NETNAME_PARAMS_STATUS_DNS 1038
#define IDC_PP_NETNAME_PARAMS_STATUS_KERBEROS 1039
#define IDC_PP_DISKS_PARAMS_DISK_LABEL  1040
#define IDC_PP_DISKS_PARAMS_DISK        1041
#define IDC_PP_FILESHR_PARAMS_SHARE_NAME_LABEL 1050
#define IDC_PP_FILESHR_PARAMS_SHARE_NAME 1051
#define IDC_PP_FILESHR_PARAMS_PATH_LABEL 1052
#define IDC_PP_FILESHR_PARAMS_PATH      1053
#define IDC_PP_FILESHR_PARAMS_REMARK_LABEL 1054
#define IDC_PP_FILESHR_PARAMS_REMARK    1055
#define IDC_PP_FILESHR_PARAMS_MAX_USERS_GROUP 1056
#define IDC_PP_FILESHR_PARAMS_MAX_USERS_ALLOWED_RB 1057
#define IDC_PP_FILESHR_PARAMS_MAX_USERS_RB 1058
#define IDC_PP_FILESHR_PARAMS_MAX_USERS 1059
#define IDC_PP_FILESHR_PARAMS_MAX_USERS_SPIN 1060
#define IDC_PP_FILESHR_PARAMS_MAX_USERS_END 1061
#define IDC_PP_FILESHR_PARAMS_PERMISSIONS 1062
#define IDC_PP_FILESHR_PARAMS_ADVANCED  1063
#define IDC_PP_FILESHR_PARAMS_CACHING   1064
#define IDC_PP_IPADDR_PARAMS_NETWORK    1070
#define IDC_PP_IPADDR_PARAMS_NETWORK_LABEL 1071
#define IDC_PP_IPADDR_PARAMS_ADDRESS_LABEL 1072
#define IDC_PP_IPADDR_PARAMS_ADDRESS    1073
#define IDC_PP_IPADDR_PARAMS_SUBNET_MASK_LABEL 1075
#define IDC_PP_IPADDR_PARAMS_SUBNET_MASK 1076
#define IDC_PP_IPADDR_PARAMS_ENABLE_NETBIOS 1077
#define IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR_LABEL 1100
#define IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR 1101
#define IDC_PP_PRTSPOOL_PARAMS_TIMEOUT_LABEL1 1102
#define IDC_PP_PRTSPOOL_PARAMS_TIMEOUT  1103
#define IDC_PP_PRTSPOOL_PARAMS_TIMEOUT_LABEL2 1104
#define IDC_PP_PRTSPOOL_PARAMS_DRIVER_DIR_LABEL 1105
#define IDC_PP_PRTSPOOL_PARAMS_DRIVER_DIR 1106
#define IDC_PP_REGREPL_PARAMS_NOTE      1110
#define IDC_PP_REGREPL_PARAMS_LIST      1111
#define IDC_PP_REGREPL_PARAMS_ADD       1112
#define IDC_PP_REGREPL_PARAMS_REMOVE    1113
#define IDC_PP_REGREPL_PARAMS_MODIFY    1114
#define IDC_REGKEY_LABEL                1120
#define IDC_REGKEY                      1121
#define IDC_CLUSNAME_TEXT               1130
#define IDC_CLUSNAME_LABEL              1131
#define IDC_CLUSNAME                    1132
#define IDC_FILESHR_ADV_NORMAL_SHARE    1150
#define IDC_FILESHR_ADV_DFS_ROOT        1151
#define IDC_FILESHR_ADV_SHARE_SUBDIRS   1152
#define IDC_FILESHR_ADV_HIDE_SUBDIR_SHARES 1153
#define IDC_FILESHR_CACHE_ALLOW_CACHING_GROUP   1160
#define IDC_FILESHR_CACHE_ALLOW_CACHING         1161
#define IDC_FILESHR_CACHE_SETTINGS_LABEL        1162
#define IDC_FILESHR_CACHE_OPTIONS               1163
#define IDC_FILESHR_CACHE_HINT                  1164
#define IDC_FILESHR_CACHE_CS_HELP               1165
#define IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH 1188
#define IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH_LABEL 1189
#define IDS_CLUADMEX_DESC               30500
#define IDS_ACLEDIT_PERM_GEN_NO_ACCESS  30501
#define IDS_ACLEDIT_PERM_GEN_READ       30502
#define IDS_ACLEDIT_PERM_GEN_MODIFY     30503
#define IDS_ACLEDIT_PERM_GEN_ALL        30504
#define IDS_ACLEDIT_TITLE               30505
#define IDS_MSGTITLE                    30506
#define IDS_MENU_WHATS_THIS             30507
#define IDS_COLTEXT_REGKEY              30508
#define IDS_DEFAULT_SPOOL_DIR           30509
#define IDS_DEFAULT_GENAPP_CURRENT_DIR  30510
#define IDS_RESCLASS_UNKNOWN            30750
#define IDS_RESCLASS_STORAGE            30751
#define IDS_RESCLASS_RESERVED_1         30752
#define IDS_RESCLASS_RESERVED_2         30752
#define IDS_CSC_MANUAL_WORKGROUP_SHARE              30800
#define IDS_CSC_MANUAL_WORKGROUP_SHARE_HINT         30801
#define IDS_CSC_AUTOMATIC_WORKGROUP_SHARE           30802
#define IDS_CSC_AUTOMATIC_WORKGROUP_SHARE_HINT      30803
#define IDS_CSC_AUTOMATIC_APPLICATION_SHARE         30804
#define IDS_CSC_AUTOMATIC_APPLICATION_SHARE_HINT    30805
#define IDS_ERROR_MSG_ID                31100
#define IDS_APPLY_PARAM_CHANGES_ERROR   31101
#define IDS_NOACLEDITOR                 31103
#define IDS_INVALID_NETWORK_NAME        31104
#define IDS_INVALID_NETWORK_NAME_TOO_LONG 31105
#define IDS_INVALID_NETWORK_NAME_INVALID_CHARS 31106
#define IDS_INVALID_NETWORK_NAME_IN_USE 31107
#define IDS_ERROR_ADDING_REGKEY         31108
#define IDS_ERROR_DELETING_REGKEY       31109
#define IDS_ERROR_READING_REGKEYS       31110
#define IDS_GET_AVAILABLE_DISKS_ERROR   31111
#define IDS_GET_DISK_INFO_ERROR         31112
#define IDS_ERROR_SETTING_CLUSTER_NAME  31113
#define IDS_INVALID_GENERIC_SERVICE     31114
#define IDS_LOCAL_ACCOUNTS_SPECIFIED_SMB 31115
#define IDS_INVALID_IP_ADDRESS          31116
#define IDS_INVALID_SUBNET_MASK         31117
#define IDS_INVALID_ADDRESS_AND_SUBNET_MASK 31118
#define IDS_IP_SUBNET_CANT_BE_VALIDATED 31119
#define IDS_IP_ADDRESS_IN_USE           31120
#define IDS_ACLEDIT_PERMISSIONS         31121
#define IDS_IP_PROVIDES_FOR_NETNAME     31122
#define IDS_NETNAMES_MAY_NOT_WORK       31123
#define IDS_LOCAL_ACCOUNTS_SPECIFIED_CLUS 31124
#define IDS_SYS_ACCOUNT_NOT_SPECIFIED   31125
#define IDS_ADMIN_ACCOUNT_NOT_SPECIFIED 31126
#define IDS_ERROR_SETTING_PROPERTIES    31127
#define IDS_ERROR_VALIDATING_PROPERTIES 31128
#define IDS_ERROR_CONSTRUCTING_DEF_DIR  31129
#define IDS_ERROR_VALIDATING_NETWORK_NAME 31130
#define IDS_REQUIRED_DEPENDENCY_NOT_FOUND 31131
#define IDS_ERROR_GETTING_PROPERTIES    31132
#define IDS_ERROR_VALIDATING_CLUSTER_SECURITY_DESCRIPTOR 31133
#define IDS_ERROR_GET_RESOURCE_FLAGS    31134
#define IDS_SERVICE_ACCOUNT_NOT_SPECIFIED 31135
#define IDS_ERROR_GET_CLASS_INFO        31136
#define IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS 31137
#define IDS_ERROR_GETTING_CLUSTER_INFORMATION 31138
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        154
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1190
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\smbshare.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2001 Microsoft Corporation
//
//  Module Name:
//      SmbShare.cpp
//
//  Abstract:
//      Implementation of the CFileShareParamsPage classes.
//
//  Author:
//      David Potter (davidp)   June 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <lmcons.h>
#include <lmaccess.h>
#include <clusudef.h>
#include "CluAdmX.h"
#include "ExtObj.h"
#include "SmbShare.h"
#include "DDxDDv.h"
#include "PropList.h"
#include "HelpData.h"
#include "FSAdv.h"
#include "FSCache.h"

#include "SmbSSht.h"
#include "AclUtils.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileShareParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CFileShareParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CFileShareParamsPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CFileShareParamsPage)
    ON_EN_CHANGE(IDC_PP_FILESHR_PARAMS_SHARE_NAME, OnChangeRequiredField)
    ON_EN_CHANGE(IDC_PP_FILESHR_PARAMS_PATH, OnChangeRequiredField)
    ON_BN_CLICKED(IDC_PP_FILESHR_PARAMS_MAX_USERS_ALLOWED_RB, OnBnClickedMaxUsers)
    ON_BN_CLICKED(IDC_PP_FILESHR_PARAMS_MAX_USERS_RB, OnBnClickedMaxUsers)
    ON_EN_CHANGE(IDC_PP_FILESHR_PARAMS_MAX_USERS, OnEnChangeMaxUsers)
    ON_BN_CLICKED(IDC_PP_FILESHR_PARAMS_PERMISSIONS, OnBnClickedPermissions)
    ON_BN_CLICKED(IDC_PP_FILESHR_PARAMS_ADVANCED, OnBnClickedAdvanced)
    ON_BN_CLICKED(IDC_PP_FILESHR_PARAMS_CACHING, OnBnClickedCaching)
    //}}AFX_MSG_MAP
    // TODO: Modify the following lines to represent the data displayed on this page.
    ON_EN_CHANGE(IDC_PP_FILESHR_PARAMS_REMARK, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()
/*
static void Junk(
    void
    )
{
    HKEY    hKey;

    if ( ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE, _T( "System\\CurrentControlSet\\Services\\LanManServer\\Shares\\Security" ), &hKey ) )
    {
        BYTE    buffer [1024];
        DWORD   dwLen = sizeof( buffer );
        DWORD   dwType;

        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, _T( "DDisk" ), NULL, &dwType, buffer, &dwLen ) )
        {
            PSECURITY_DESCRIPTOR    psec;

            psec = LocalAlloc( LMEM_ZEROINIT, dwLen );
            CopyMemory( psec, buffer, dwLen);

            ASSERT( IsValidSecurityDescriptor( psec ) );
#ifdef _DEBUG_SECURITY
            ::ClRtlExamineSD( psec );
#endif

            LocalFree( psec );
        }

        RegCloseKey( hKey );
    }
}
*/
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::CFileShareParamsPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CFileShareParamsPage::CFileShareParamsPage( void )
    : CBasePropertyPage(g_aHelpIDs_IDD_PP_FILESHR_PARAMETERS, g_aHelpIDs_IDD_WIZ_FILESHR_PARAMETERS)
{
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_INIT(CFileShareParamsPage)
    m_strShareName = _T("");
    m_strPath = _T("");
    m_strRemark = _T("");
    //}}AFX_DATA_INIT

    m_psec      = NULL;
    m_psecNT4   = NULL;
    m_psecNT5   = NULL;
    m_psecPrev  = NULL;

    m_dwMaxUsers = (DWORD) -1;
    m_bShareSubDirs = FALSE;
    m_bPrevShareSubDirs = FALSE;
    m_bHideSubDirShares = FALSE;
    m_bPrevHideSubDirShares = FALSE;
    m_bIsDfsRoot = FALSE;
    m_bPrevIsDfsRoot = FALSE;

    // Setup the property array.
    {
        m_rgProps[epropShareName].Set(REGPARAM_FILESHR_SHARE_NAME, m_strShareName, m_strPrevShareName);
        m_rgProps[epropPath].Set(REGPARAM_FILESHR_PATH, m_strPath, m_strPrevPath);
        m_rgProps[epropRemark].Set(REGPARAM_FILESHR_REMARK, m_strRemark, m_strPrevRemark);
        m_rgProps[epropMaxUsers].Set(REGPARAM_FILESHR_MAX_USERS, m_dwMaxUsers, m_dwPrevMaxUsers);
        m_rgProps[epropShareSubDirs].Set(REGPARAM_FILESHR_SHARE_SUBDIRS, m_bShareSubDirs, m_bPrevShareSubDirs, CObjectProperty::opfNew);
        m_rgProps[epropHideSubDirShares].Set(REGPARAM_FILESHR_HIDE_SUBDIR_SHARES, m_bHideSubDirShares, m_bPrevHideSubDirShares, CObjectProperty::opfNew);
        m_rgProps[epropIsDfsRoot].Set(REGPARAM_FILESHR_IS_DFS_ROOT, m_bIsDfsRoot, m_bPrevIsDfsRoot, CObjectProperty::opfNew);
        m_rgProps[epropCSCCache].Set(REGPARAM_FILESHR_CSC_CACHE, m_dwCSCCache, m_dwPrevCSCCache, CObjectProperty::opfNew);
    }  // Setup the property array

    m_iddPropertyPage = IDD_PP_FILESHR_PARAMETERS;
    m_iddWizardPage = IDD_WIZ_FILESHR_PARAMETERS;

}  //*** CFileShareParamsPage::CFileShareParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::~CFileShareParamsPage
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CFileShareParamsPage::~CFileShareParamsPage(
    void
    )
{
    ::LocalFree(m_psec);
    ::LocalFree(m_psecNT4);
    ::LocalFree(m_psecNT5);
    ::LocalFree(m_psecPrev);

}  //*** CFileShareParamsPage::~CFileShareParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::ScParseUnknownProperty
//
//  Routine Description:
//      Parse a property that is not in the array of automatically-parsed
//      properties.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      rvalue          [IN] CLUSPROP property value.
//      cbBuf           [IN] Total size of the value buffer.
//
//  Return Value:
//      ERROR_SUCCESS   Properties were parsed successfully.
//
//  Exceptions Thrown:
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CFileShareParamsPage::ScParseUnknownProperty(
    IN LPCWSTR                          pwszName,
    IN const CLUSPROP_BUFFER_HELPER &   rvalue,
    IN DWORD                            cbBuf
    )
{
    ASSERT(pwszName != NULL);
    ASSERT(rvalue.pb != NULL);

    DWORD   sc = ERROR_SUCCESS;

    if (lstrcmpiW(pwszName, REGPARAM_FILESHR_SD) == 0)
    {
        sc = ScConvertPropertyToSD(rvalue, cbBuf, &m_psecNT5);
    }  // if:  new security descriptor

    if (sc == ERROR_SUCCESS)
    {
        if (lstrcmpiW(pwszName, REGPARAM_FILESHR_SECURITY) == 0)
        {
            sc = ScConvertPropertyToSD(rvalue, cbBuf, &m_psecNT4);
        }  // if:  old security descriptor
    } // if:

    return sc;

}  //*** CFileShareParamsPage::ScParseUnknownProperty()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CFileShareParamsPage::DoDataExchange(
    CDataExchange * pDX
    )
{
    if (!pDX->m_bSaveAndValidate || !BSaved())
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // TODO: Modify the following lines to represent the data displayed on this page.
        //{{AFX_DATA_MAP(CFileShareParamsPage)
        DDX_Control(pDX, IDC_PP_FILESHR_PARAMS_PERMISSIONS, m_pbPermissions);
        DDX_Control(pDX, IDC_PP_FILESHR_PARAMS_MAX_USERS_SPIN, m_spinMaxUsers);
        DDX_Control(pDX, IDC_PP_FILESHR_PARAMS_MAX_USERS_RB, m_rbMaxUsers);
        DDX_Control(pDX, IDC_PP_FILESHR_PARAMS_MAX_USERS_ALLOWED_RB, m_rbMaxUsersAllowed);
        DDX_Control(pDX, IDC_PP_FILESHR_PARAMS_MAX_USERS, m_editMaxUsers);
        DDX_Control(pDX, IDC_PP_FILESHR_PARAMS_REMARK, m_editRemark);
        DDX_Control(pDX, IDC_PP_FILESHR_PARAMS_PATH, m_editPath);
        DDX_Control(pDX, IDC_PP_FILESHR_PARAMS_SHARE_NAME, m_editShareName);
        DDX_Text(pDX, IDC_PP_FILESHR_PARAMS_SHARE_NAME, m_strShareName);
        DDX_Text(pDX, IDC_PP_FILESHR_PARAMS_PATH, m_strPath);
        DDX_Text(pDX, IDC_PP_FILESHR_PARAMS_REMARK, m_strRemark);
        //}}AFX_DATA_MAP

#ifndef UDM_SETRANGE32
#define UDM_SETRANGE32 (WM_USER+111)
#endif
#ifndef UD_MAXVAL32
#define UD_MAXVAL32 0x7fffffff
#endif

        if (pDX->m_bSaveAndValidate)
        {
            if (!BBackPressed())
            {
                DDV_MaxChars(pDX, m_strShareName, NNLEN);
                DDV_MaxChars(pDX, m_strPath, MAX_PATH);
                DDV_MaxChars(pDX, m_strRemark, MAXCOMMENTSZ);
                DDV_RequiredText(pDX, IDC_PP_FILESHR_PARAMS_SHARE_NAME, IDC_PP_FILESHR_PARAMS_SHARE_NAME_LABEL, m_strShareName);
                DDV_RequiredText(pDX, IDC_PP_FILESHR_PARAMS_PATH, IDC_PP_FILESHR_PARAMS_PATH_LABEL, m_strPath);
            }  // if:  Back button not pressed

            // Get the max # users.
            if (m_rbMaxUsersAllowed.GetCheck() == BST_CHECKED)
                m_dwMaxUsers = (DWORD) -1;
            else if (BBackPressed())
                DDX_Text(pDX, IDC_PP_FILESHR_PARAMS_MAX_USERS, m_dwMaxUsers);
            else
#ifdef UD32
                DDX_Number(pDX, IDC_PP_FILESHR_PARAMS_MAX_USERS, m_dwMaxUsers, 1, UD_MAXVAL32, FALSE /*bSigned*/);
#else
                DDX_Number(pDX, IDC_PP_FILESHR_PARAMS_MAX_USERS, m_dwMaxUsers, 1, UD_MAXVAL, FALSE /*bSigned*/);
#endif
        }  // if:  saving data from dialog
        else
        {
#ifdef UD32
            DDX_Number(pDX, IDC_PP_FILESHR_PARAMS_MAX_USERS, m_dwMaxUsers, 1, UD_MAXVAL32, FALSE /*bSigned*/);
#else
            DDX_Number(pDX, IDC_PP_FILESHR_PARAMS_MAX_USERS, m_dwMaxUsers, 1, UD_MAXVAL, FALSE /*bSigned*/);
#endif
            if (m_dwMaxUsers == (DWORD) -1)
            {
                m_rbMaxUsersAllowed.SetCheck(BST_CHECKED);
                m_rbMaxUsers.SetCheck(BST_UNCHECKED);
                m_editMaxUsers.SetWindowText(_T(""));
            }  // if:  unlimited specified
            else
            {
                m_rbMaxUsersAllowed.SetCheck(BST_UNCHECKED);
                m_rbMaxUsers.SetCheck(BST_CHECKED);
            }  // else:  a maximum was specified

        }  // else:  setting data to dialog
    }  // if:  not saving or haven't saved yet

    CBasePropertyPage::DoDataExchange(pDX);

}  //*** CFileShareParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CFileShareParamsPage::OnInitDialog(
    void
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBasePropertyPage::OnInitDialog();

    // Set limits on the edit controls.
    m_editShareName.SetLimitText(NNLEN);
    m_editPath.SetLimitText(MAX_PATH);
    m_editRemark.SetLimitText(MAXCOMMENTSZ);

    // Set the spin control limits.
#ifdef UD32
    m_spinMaxUsers.SendMessage(UDM_SETRANGE32, 1, UD_MAXVAL32);
#else
    m_spinMaxUsers.SetRange(1, UD_MAXVAL);
#endif

    m_pbPermissions.EnableWindow(TRUE);

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CFileShareParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CFileShareParamsPage::OnSetActive(
    void
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Enable/disable the Next/Finish button.
    if (BWizard())
    {
        if ((m_strShareName.GetLength() == 0) || (m_strPath.GetLength() == 0))
            EnableNext(FALSE);
        else
            EnableNext(TRUE);
    }  // if:  enable/disable the Next button

    return CBasePropertyPage::OnSetActive();

}  //*** CFileShareParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CFileShareParamsPage::BApplyChanges(
    void
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWaitCursor wc;

    return CBasePropertyPage::BApplyChanges();

}  //*** CFileShareParamsPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::BBuildPropList
//
//  Routine Description:
//      Build the property list.
//
//  Arguments:
//      rcpl        [IN OUT] Cluster property list.
//      bNoNewProps [IN] TRUE = exclude properties marked with opfNew.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusPropList::ScAddProp().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CFileShareParamsPage::BBuildPropList(
    IN OUT CClusPropList &  rcpl,
    IN BOOL                 bNoNewProps     // = FALSE
    )
{
    BOOL    bSuccess;

    // Call the base class method.
    bSuccess = CBasePropertyPage::BBuildPropList(rcpl, bNoNewProps);
    if (bSuccess)
    {
        if (!bNoNewProps)
            rcpl.ScAddProp(
                    REGPARAM_FILESHR_SD,
                    (LPBYTE) m_psec,
                    (m_psec == NULL ? 0 : ::GetSecurityDescriptorLength(m_psec)),
                    (LPBYTE) m_psecPrev,
                    (m_psecPrev == NULL ? 0 : ::GetSecurityDescriptorLength(m_psecPrev))
                    );

        PSECURITY_DESCRIPTOR    psd = ::ClRtlConvertFileShareSDToNT4Format(m_psec);

        rcpl.ScAddProp(
                REGPARAM_FILESHR_SECURITY,
                (LPBYTE) psd,
                (psd == NULL ? 0 : ::GetSecurityDescriptorLength(psd)),
                (LPBYTE) m_psecPrev,
                (m_psecPrev == NULL ? 0 : ::GetSecurityDescriptorLength(m_psecPrev))
                );

        ::LocalFree(psd);
    } // if:  rest of property list build successfully

    return bSuccess;

}  //*** CFileShareParamsPage::BBuildPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::OnChangeRequiredField
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Share name or Path edit
//      controls.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CFileShareParamsPage::OnChangeRequiredField(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeCtrl();

    if (BWizard())
    {
        if ((m_editShareName.GetWindowTextLength() == 0)
                || (m_editPath.GetWindowTextLength() == 0))
            EnableNext(FALSE);
        else
            EnableNext(TRUE);
    }  // if:  in a wizard

}  //*** CFileShareParamsPage::OnChangeRequiredField()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::OnBnClickedMaxUsers
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Max Users radio buttons.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CFileShareParamsPage::OnBnClickedMaxUsers(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    SetModified(TRUE);

    if (m_rbMaxUsersAllowed.GetCheck() == BST_CHECKED)
    {
        m_editMaxUsers.SetWindowText(_T(""));
    }
    else
    {
        m_editMaxUsers.SetFocus();
    }

}  //*** CFileShareParamsPage::OnBnClickedMaxUsers()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::OnEnChangeMaxUsers
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Max Users edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CFileShareParamsPage::OnEnChangeMaxUsers(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeCtrl();

    if (m_editMaxUsers.m_hWnd != NULL)
    {
        if (m_editMaxUsers.GetWindowTextLength() == 0)
        {
            m_rbMaxUsersAllowed.SetCheck(BST_CHECKED);
            m_rbMaxUsers.SetCheck(BST_UNCHECKED);
        }  // if:  maximum # users has not been specified
        else
        {
            m_rbMaxUsersAllowed.SetCheck(BST_UNCHECKED);
            m_rbMaxUsers.SetCheck(BST_CHECKED);
        }  // if:  maximum # users has been specified
    }  // if:  control variables have been initialized

}  //*** CFileShareParamsPage::OnEnChangeMaxUsers()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::OnBnClickedPermissions
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Permissions push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CFileShareParamsPage::OnBnClickedPermissions(void)
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    HRESULT _hr;
    INT_PTR nRet = 0;
    CString strNode;
    CString strShareName;

    // Get the node on which the Cluster Name resource is online.
    if ( !BGetClusterNetworkNameNode( strNode ) )
    {
        return;
    }

    CWaitCursor wc;

    try
    {
        m_editShareName.GetWindowText( strShareName );
        m_strCaption.Format(
            IDS_ACLEDIT_PERMISSIONS,
            (LPCTSTR) strShareName,
            (LPCTSTR) Peo()->RrdResData().m_strName
            );

    }  // try
    catch ( CMemoryException * pme )
    {
        pme->Delete();
    }

    CFileShareSecuritySheet fsSecurity( this, m_strCaption );

    _hr = fsSecurity.HrInit( this, Peo(), strNode, strShareName );
    if ( SUCCEEDED( _hr ) )
    {
        nRet = fsSecurity.DoModal();
        m_strCaption.Empty();
    }

}  //*** CFileShareParamsPage::OnBnClickedPermissions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::OnBnClickedAdvanced
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Advanced push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CFileShareParamsPage::OnBnClickedAdvanced(void)
{
    CFileShareAdvancedDlg dlg(m_bShareSubDirs, m_bHideSubDirShares, m_bIsDfsRoot, this);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (dlg.DoModal() == IDOK)
    {
        if (   (m_bHideSubDirShares != dlg.m_bHideSubDirShares)
            || (m_bShareSubDirs != dlg.m_bShareSubDirs)
            || (m_bIsDfsRoot != dlg.m_bIsDfsRoot))
        {
            m_bHideSubDirShares = dlg.m_bHideSubDirShares;
            m_bShareSubDirs = dlg.m_bShareSubDirs;
            m_bIsDfsRoot = dlg.m_bIsDfsRoot;

            SetModified(TRUE);
        } // if:  data changed
    }  // if:  user accepted the dialog

}  //*** CFileShareParamsPage::OnBnClickedAdvanced()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::OnBnClickedCaching
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Caching push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CFileShareParamsPage::OnBnClickedCaching(void)
{
    CFileShareCachingDlg dlg(m_dwCSCCache, this);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (dlg.DoModal() == IDOK)
    {
        if (m_dwCSCCache != dlg.m_dwFlags)
        {
            m_dwCSCCache = dlg.m_dwFlags;

            SetModified(TRUE);
        } // if:  data changed
    }  // if:  user accepted the dialog

}  //*** CFileShareParamsPage::OnBnClickedCaching()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::SetSecurityDescriptor
//
//  Routine Description:
//      Save the passed in descriptor into m_psec.
//
//  Arguments:
//      psec        [IN] new security descriptor
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CFileShareParamsPage::SetSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR psec
    )
{
    ASSERT( psec != NULL );
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    HRESULT hr = E_FAIL;

    try
    {
        if ( psec != NULL )
        {
            ASSERT( IsValidSecurityDescriptor( psec ) );
            if ( IsValidSecurityDescriptor( psec ) )
            {
                LocalFree( m_psecPrev );
                m_psecPrev = NULL;
                if ( m_psec == NULL )
                {
                    m_psecPrev = NULL;
                } // if: no previous value
                else
                {
                    m_psecPrev = ::ClRtlCopySecurityDescriptor( m_psec );
                    if ( m_psecPrev == NULL )
                    {
                        hr = GetLastError();            // Get the last error
                        hr = HRESULT_FROM_WIN32( hr );  // Convert to HRESULT
                        goto Cleanup;
                    } // if: error copying the security descriptor
                } // else: previous value exists

                LocalFree( m_psec );
                m_psec = NULL;

                m_psec = ::ClRtlCopySecurityDescriptor( psec );
                if ( m_psec == NULL )
                {
                    hr = GetLastError();            // Get the last error
                    hr = HRESULT_FROM_WIN32( hr );  // Convert to HRESULT
                    goto Cleanup;
                } // if: error copying the security descriptor

                SetModified( TRUE );
                hr = S_OK;
            } // if: security descriptor is valid
        } // if: non-NULL security descriptor specified
        else
        {
            TRACE( _T("CFileShareParamsPage::SetSecurityDescriptor() - new SD is NULL.\r") );
        }
    } // try
    catch (...)
    {
        ;
    }

Cleanup:
    return hr;

}  //*** CFileShareParamsPage::SetSecurityDescriptor()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::ScConvertPropertyToSD
//
//  Routine Description:
//      Convert the property into an SD.
//
//  Arguments:
//      rvalue          [IN] CLUSPROP property value.
//      cbBuf           [IN] Total size of the value buffer.
//      ppsec           [IN] SD to save the property to.
//
//  Return Value:
//      none.
//
//  Exceptions Thrown:
//      Any exceptions from CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CFileShareParamsPage::ScConvertPropertyToSD(
    IN const CLUSPROP_BUFFER_HELPER &   rvalue,
    IN DWORD                            cbBuf,
    IN PSECURITY_DESCRIPTOR             *ppsec
    )
{
    ASSERT(rvalue.pSyntax->wFormat == CLUSPROP_FORMAT_BINARY);
    ASSERT(cbBuf >= sizeof(*rvalue.pBinaryValue) + ALIGN_CLUSPROP(rvalue.pValue->cbLength));
    ASSERT(ppsec);

    DWORD   sc = ERROR_SUCCESS;

    if ((ppsec != NULL) && (rvalue.pBinaryValue->cbLength != 0))
    {
        *ppsec = ::LocalAlloc(LMEM_ZEROINIT, rvalue.pBinaryValue->cbLength);
        if (*ppsec == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        ::CopyMemory(*ppsec, rvalue.pBinaryValue->rgb, rvalue.pBinaryValue->cbLength);

        ASSERT(::IsValidSecurityDescriptor(*ppsec));

        if (!::IsValidSecurityDescriptor(*ppsec))
        {
            ::LocalFree(*ppsec);
            *ppsec = NULL;
        }  // if:  invalid security descriptor
    }  // if:  security descriptor specified
    else
    {
        ::LocalFree(*ppsec);
        *ppsec = NULL;
    }  // else:  no security descriptor specified

    return sc;

}  //*** CFileShareParamsPage::ScConvertPropertyToSD()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::Psec
//
//  Routine Description:
//      Return the SD for the FileShare.  Since we may have two different
//      SDs we have to choose one and go with it...  Since AclUi can use
//      the NT4 one without change it's OK to use it as is if the NT5 one
//      is not present...
//
//  Arguments:
//      none.
//
//  Return Value:
//      The SD...
//
//  Exceptions Thrown:
//
//--
/////////////////////////////////////////////////////////////////////////////
const PSECURITY_DESCRIPTOR CFileShareParamsPage::Psec(
    void
    )
{
    if (m_psec == NULL)
    {
        // try the NT5 one first...
        if (m_psecNT5 != NULL)
        {
            m_psec = ::ClRtlCopySecurityDescriptor(m_psecNT5);
            if ( m_psec == NULL )
            {
                goto Cleanup;
            } // if: error copying the security descriptor
        }
        else
        {
            if (m_psecNT4 != NULL)
            {
                m_psec = ::ClRtlCopySecurityDescriptor(m_psecNT4);
                if ( m_psec == NULL )
                {
                    goto Cleanup;
                } // if: error copying the security descriptor
            }
        }

        // Set current values as the previous values to track changes.
        m_psecPrev = ::ClRtlCopySecurityDescriptor(m_psec);
    }

Cleanup:
    return m_psec;

}  //*** CFileShareParamsPage::Psec()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\regrepl.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		RegRepl.cpp
//
//	Abstract:
//		Implementation of the CRegReplParamsPage class.
//
//	Author:
//		David Potter (davidp)	February 23, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "RegRepl.h"
#include "RegKey.h"
#include "ExtObj.h"
#include "HelpData.h"	// for g_rghelpmap*

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegReplParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CRegReplParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CRegReplParamsPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CRegReplParamsPage)
	ON_BN_CLICKED(IDC_PP_REGREPL_PARAMS_ADD, OnAdd)
	ON_BN_CLICKED(IDC_PP_REGREPL_PARAMS_MODIFY, OnModify)
	ON_BN_CLICKED(IDC_PP_REGREPL_PARAMS_REMOVE, OnRemove)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_PP_REGREPL_PARAMS_LIST, OnItemChanged)
	ON_NOTIFY(NM_DBLCLK, IDC_PP_REGREPL_PARAMS_LIST, OnDblClkList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRegReplParamsPage::CRegReplParamsPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CRegReplParamsPage::CRegReplParamsPage(void)
	: CBasePropertyPage(g_aHelpIDs_IDD_PP_REGREPL_PARAMETERS, g_aHelpIDs_IDD_WIZ_REGREPL_PARAMETERS)
{
	//{{AFX_DATA_INIT(CRegReplParamsPage)
	//}}AFX_DATA_INIT

	m_pwszRegKeys = NULL;

	m_iddPropertyPage = IDD_PP_REGREPL_PARAMETERS;
	m_iddWizardPage = IDD_WIZ_REGREPL_PARAMETERS;

}  //*** CRegReplParamsPage::CRegReplParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRegReplParamsPage::~CRegReplParamsPage
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CRegReplParamsPage::~CRegReplParamsPage(void)
{
	delete [] m_pwszRegKeys;

}  //*** CRegReplParamsPage::~CRegReplParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRegReplParamsPage::HrInit
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		peo			[IN OUT] Pointer to the extension object.
//						property sheet.
//
//	Return Value:
//		S_OK		Page initialized successfully.
//		hr			Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CRegReplParamsPage::HrInit(IN OUT CExtObject * peo)
{
	HRESULT		_hr;
	DWORD		_sc;
	CWaitCursor	_wc;

	do
	{
		// Call the base class method.
		_hr = CBasePropertyPage::HrInit(peo);
		if (FAILED(_hr))
			break;

		ASSERT(m_pwszRegKeys == NULL);

		// Read the list of registry keys to replicate.
		_sc = ScReadRegKeys();
		if (_sc != ERROR_SUCCESS)
		{
			CString		strPrompt;
			CString		strError;
			CString		strMsg;

			AFX_MANAGE_STATE(AfxGetStaticModuleState());

			strPrompt.LoadString(IDS_ERROR_READING_REGKEYS);
			FormatError(strError, _sc);
			strMsg.Format(_T("%s\n\n%s"), strPrompt, strError);
			AfxMessageBox(strMsg, MB_OK | MB_ICONEXCLAMATION);
		}  // if:  error eading registry keys
	} while ( 0 );

	return _hr;

}  //*** CRegReplParamsPage::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRegReplParamsPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRegReplParamsPage::DoDataExchange(CDataExchange* pDX)
{
	if (!pDX->m_bSaveAndValidate || !BSaved())
	{
		//{{AFX_DATA_MAP(CRegReplParamsPage)
		DDX_Control(pDX, IDC_PP_REGREPL_PARAMS_REMOVE, m_pbRemove);
		DDX_Control(pDX, IDC_PP_REGREPL_PARAMS_MODIFY, m_pbModify);
		DDX_Control(pDX, IDC_PP_REGREPL_PARAMS_LIST, m_lcRegKeys);
		//}}AFX_DATA_MAP
	}  // if:  not saving or haven't saved yet

	CBasePropertyPage::DoDataExchange(pDX);

}  //*** CRegReplParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRegReplParamsPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CRegReplParamsPage::OnInitDialog(void)
{
	CBasePropertyPage::OnInitDialog();

	// Add the column.
	{
		CString		strColumn;

		AFX_MANAGE_STATE(AfxGetStaticModuleState());

		strColumn.LoadString(IDS_COLTEXT_REGKEY);
		m_lcRegKeys.InsertColumn(0, strColumn, LVCFMT_LEFT, 300);
	}  // Add the column

	// Display the list of registry keys.
	FillList();

	// Enable/disable the Modify and Remove buttons.
	{
		UINT	cSelected = m_lcRegKeys.GetSelectedCount();

		// If there is an item selected, enable the Modify and Remove buttons.
		m_pbModify.EnableWindow((cSelected > 0) ? TRUE : FALSE);
		m_pbRemove.EnableWindow((cSelected > 0) ? TRUE : FALSE);
	}  // Enable/disable the Modify and Remove buttons

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CRegReplParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRegReplParamsPage::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CRegReplParamsPage::OnSetActive(void)
{
	if (BWizard())
		EnableNext(TRUE);

	return CBasePropertyPage::OnSetActive();

}  //*** CRegReplParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRegReplParamsPage::BApplyChanges
//
//	Routine Description:
//		Apply changes made on the page.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CRegReplParamsPage::BApplyChanges(void)
{
	DWORD		dwStatus	= ERROR_SUCCESS;
	CWaitCursor	wc;

	// Add new items.
	{
		int		iitem;
		CString	strItem;
		LPCWSTR	pwszRegKeys;
		DWORD	cbReturned;

		for ( iitem = -1
				; (iitem = m_lcRegKeys.GetNextItem(iitem, LVNI_ALL)) != -1
				; )
		{
			strItem = m_lcRegKeys.GetItemText(iitem, 0);
			pwszRegKeys = PwszRegKeys();
			while (*pwszRegKeys != L'\0')
			{
				if (strItem.CompareNoCase(pwszRegKeys) == 0)
					break;
				pwszRegKeys += lstrlenW(pwszRegKeys) + 1;
			}  // while:  more items in the list

			if (*pwszRegKeys == L'\0')
			{
				dwStatus = ClusterResourceControl(
								Peo()->PrdResData()->m_hresource,
								NULL,	// hNode
								CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT,
								(PVOID) (LPCWSTR) strItem,
								(strItem.GetLength() + 1) * sizeof(WCHAR),
								NULL,	// OutBuffer
								0,		// OutBufferSize
								&cbReturned	// BytesReturned
								);
				if ((dwStatus != ERROR_SUCCESS) && (dwStatus != ERROR_ALREADY_EXISTS))
				{
					CString		strPrompt;
					CString		strError;
					CString		strMsg;

					{
						AFX_MANAGE_STATE(AfxGetStaticModuleState());
						strPrompt.FormatMessage(IDS_ERROR_ADDING_REGKEY, strItem);
					}

					FormatError(strError, dwStatus);
					strMsg.Format(_T("%s\n\n%s"), strPrompt, strError);
					AfxMessageBox(strMsg, MB_OK | MB_ICONEXCLAMATION);
					return FALSE;
				}  // if:  error adding the item
			}  // if:  found a new one
		}  // for:  each item in the list
	}  // Add new items

	// Remove deleted items.
	{
		int			iitem;
		CString		strItem;
		LPCWSTR		pwszRegKeys = PwszRegKeys();
		DWORD		cbReturned;

		while (*pwszRegKeys != L'\0')
		{
			for ( iitem = -1
					; (iitem = m_lcRegKeys.GetNextItem(iitem, LVNI_ALL)) != -1
					; )
			{
				strItem = m_lcRegKeys.GetItemText(iitem, 0);
				if (strItem.CompareNoCase(pwszRegKeys) == 0)
					break;
			}  // for:  all items in the list

			if (iitem == -1)
			{
				dwStatus = ClusterResourceControl(
								Peo()->PrdResData()->m_hresource,
								NULL,	// hNode
								CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT,
								(PVOID) pwszRegKeys,
								(lstrlenW(pwszRegKeys) + 1) * sizeof(WCHAR),
								NULL,	// OutBuffer
								0,		// OutBufferSize
								&cbReturned	// BytesReturned
								);
				if (dwStatus != ERROR_SUCCESS)
				{
					CString		strPrompt;
					CString		strError;
					CString		strMsg;

					{
						AFX_MANAGE_STATE(AfxGetStaticModuleState());
						strPrompt.FormatMessage(IDS_ERROR_DELETING_REGKEY, strItem);
					}

					FormatError(strError, dwStatus);
					strMsg.Format(_T("%s\n\n%s"), strPrompt, strError);
					AfxMessageBox(strMsg, MB_OK | MB_ICONEXCLAMATION);
					return FALSE;
				}  // if:  error adding the item
			}  // if:  key was deleted

			pwszRegKeys += lstrlenW(pwszRegKeys) + 1;
		}  // while:  more strings
	}  // Remove deleted items

	// Re-read the keys.
	ScReadRegKeys();
	FillList();

	return CBasePropertyPage::BApplyChanges();

}  //*** CRegReplParamsPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRegReplParamsPage::OnAdd
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the Add button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRegReplParamsPage::OnAdd(void)
{
	INT_PTR			idReturn;
	CEditRegKeyDlg	dlg(this);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	idReturn = dlg.DoModal();
	if (idReturn == IDOK)
	{
		m_lcRegKeys.InsertItem(m_lcRegKeys.GetItemCount(), dlg.m_strRegKey);
		m_lcRegKeys.SetFocus();
		SetModified(TRUE);
	}  // if:  user accepted the dialog

}  //*** CRegReplParamsPage::OnAdd()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRegReplParamsPage::OnModify
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the Modify button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRegReplParamsPage::OnModify(void)
{
	int				iSelectedItem;
	INT_PTR			idReturn;
	CEditRegKeyDlg	dlg(this);

	// Set the text in the dialog to the text of the selected item.
	iSelectedItem = m_lcRegKeys.GetNextItem(-1, LVNI_SELECTED);
	ASSERT(iSelectedItem != -1);
	dlg.m_strRegKey = m_lcRegKeys.GetItemText(iSelectedItem, 0);

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Display the dialog.
	idReturn = dlg.DoModal();
	if (idReturn == IDOK)
	{
		m_lcRegKeys.SetItemText(iSelectedItem, 0, dlg.m_strRegKey);
		m_lcRegKeys.SetFocus();
		SetModified(TRUE);
	}  // if:  user accepted the dialog

}  //*** CRegReplParamsPage::OnModify()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRegReplParamsPage::OnRemove
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the Remove button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRegReplParamsPage::OnRemove(void)
{
	int				iSelectedItem;

	iSelectedItem = m_lcRegKeys.GetNextItem(-1, LVNI_SELECTED);
	ASSERT(iSelectedItem != -1);
	m_lcRegKeys.DeleteItem(iSelectedItem);
	SetModified(TRUE);

}  //*** CRegReplParamsPage::OnRemove()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRegReplParamsPage::OnItemChanged
//
//	Routine Description:
//		Handler for the LVN_ITEM_CHANGED message on the list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRegReplParamsPage::OnItemChanged(NMHDR * pNMHDR, LRESULT * pResult)
{
	NM_LISTVIEW * pNMListView = (NM_LISTVIEW *) pNMHDR;

	// If the selection changed, enable/disable the Properties button.
	if ((pNMListView->uChanged & LVIF_STATE)
			&& ((pNMListView->uOldState & LVIS_SELECTED)
					|| (pNMListView->uNewState & LVIS_SELECTED)))
	{
		UINT	cSelected = m_lcRegKeys.GetSelectedCount();

		// If there is an item selected, enable the Modify and Remove buttons.
		m_pbModify.EnableWindow((cSelected > 0) ? TRUE : FALSE);
		m_pbRemove.EnableWindow((cSelected > 0) ? TRUE : FALSE);
	}  // if:  selection changed

	*pResult = 0;

}  //*** CRegReplParamsPage::OnItemChanged()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRegReplParamsPage::OnDblClkList
//
//	Routine Description:
//		Handler for the NM_DBLCLK message on the list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRegReplParamsPage::OnDblClkList(NMHDR * pNMHDR, LRESULT * pResult)
{
	OnModify();
	*pResult = 0;

}  //*** CRegReplParamsPage::OnDblClkList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRegReplParamsPage::ScReadRegKeys
//
//	Routine Description:
//		Read the registry keys.
//
//	Arguments:
//		None.
//
//	Return Value:
//		ERROR_SUCCESS	Registry keys read successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CRegReplParamsPage::ScReadRegKeys(void)
{
	DWORD				dwStatus		= ERROR_SUCCESS;
	DWORD				cbRegKeys		= 256;
	LPWSTR				pwszRegKeys 	= NULL;
	CWaitCursor 		wc;
	CMemoryException	me(FALSE /*bAutoDelete*/, 0 /*nResourceID*/);

	// Read the list of registry keys to replicate.
	try
	{
		// Get registry keys.
		pwszRegKeys = new WCHAR[cbRegKeys / sizeof(WCHAR)];
		if (pwszRegKeys == NULL)
		{
			throw &me;
		} // if: error allocating key name buffer
		dwStatus = ClusterResourceControl(
						Peo()->PrdResData()->m_hresource,
						NULL,	// hNode
						CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS,
						NULL,	// lpInBuffer
						0,		// nInBufferSize
						pwszRegKeys,
						cbRegKeys,
						&cbRegKeys
						);
		if (dwStatus == ERROR_MORE_DATA)
		{
			delete [] pwszRegKeys;
			ASSERT(cbRegKeys == (cbRegKeys / sizeof(WCHAR)) * sizeof(WCHAR));
			pwszRegKeys = new WCHAR[cbRegKeys / sizeof(WCHAR)];
			if (pwszRegKeys == NULL)
			{
				throw &me;
			} // if: error allocating key name buffer
			dwStatus = ClusterResourceControl(
							Peo()->PrdResData()->m_hresource,
							NULL,	// hNode
							CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS,
							NULL,	// lpInBuffer
							0,		// nInBufferSize
							pwszRegKeys,
							cbRegKeys,
							&cbRegKeys
							);
		}  // if:  buffer too small
	}  // try
	catch (CMemoryException * pme)
	{
		pme->ReportError();
		pme->Delete();
		return ERROR_NOT_ENOUGH_MEMORY;
	}  // catch:  CMemoryException

	if ((dwStatus != ERROR_SUCCESS) || (cbRegKeys == 0))
		*pwszRegKeys = L'\0';

	delete [] m_pwszRegKeys;
	m_pwszRegKeys = pwszRegKeys;

	return dwStatus;

}  //*** CRegReplParamsPage::ScReadRegKeys()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRegReplParamsPage::FillList
//
//	Routine Description:
//		Fill the list control.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRegReplParamsPage::FillList(void)
{
	m_lcRegKeys.DeleteAllItems();

	if (PwszRegKeys() != NULL)
	{
		int		iitem;
		int		iitemRet;
		LPCWSTR	pwszRegKeys = PwszRegKeys();

		for (iitem = 0 ; *pwszRegKeys != L'\0' ; iitem++)
		{
			iitemRet = m_lcRegKeys.InsertItem(iitem, pwszRegKeys);
			ASSERT(iitemRet == iitem);
			pwszRegKeys += lstrlenW(pwszRegKeys) + 1;
		}  // while:  more strings in the list
	}  // if:  there are any keys to display

}  //*** CRegReplParamsPage::FillList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\smbspage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		SmbSPage.cpp
//
//	Abstract:
//		CClusterFileShareSecurityPage class implementation.  This class will encapsulate
//		the cluster file share security page.
//
//	Author:
//		Galen Barbee	(galenb)	February 11, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "SmbSPage.h"
#include "AclUtils.h"
#include <clusudef.h>
#include "SmbShare.h"
#include "SmbSSht.h"

static GENERIC_MAPPING ShareMap =
{
	FILE_GENERIC_READ,
	FILE_GENERIC_WRITE,
	FILE_GENERIC_EXECUTE,
	FILE_ALL_ACCESS
};

static SI_ACCESS siFileShareAccesses[] =
{
	{ &GUID_NULL, FILE_ALL_ACCESS,             				MAKEINTRESOURCE(IDS_ACLEDIT_PERM_GEN_ALL),    	SI_ACCESS_GENERAL },
	{ &GUID_NULL, FILE_GENERIC_WRITE | DELETE, 				MAKEINTRESOURCE(IDS_ACLEDIT_PERM_GEN_MODIFY),	SI_ACCESS_GENERAL },
	{ &GUID_NULL, FILE_GENERIC_READ | FILE_GENERIC_EXECUTE, MAKEINTRESOURCE(IDS_ACLEDIT_PERM_GEN_READ), 	SI_ACCESS_GENERAL }
};

/////////////////////////////////////////////////////////////////////////////
// CClusterFileShareSecurityInformation security page
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterFileShareSecurityInformation::CClusterFileShareSecurityInformation
//
//	Routine Description:
//		Default contructor
//
//	Arguments:
//		none
//
//	Return Value:
//		none
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterFileShareSecurityInformation::CClusterFileShareSecurityInformation(
	void
	)
{
	m_pShareMap		= &ShareMap;
	m_psiAccess		= (SI_ACCESS *) &siFileShareAccesses;
	m_nAccessElems	= ARRAYSIZE( siFileShareAccesses );
	m_nDefAccess	= 2;   // FILE_GEN_READ
	m_dwFlags		=   SI_EDIT_PERMS
						| SI_NO_ACL_PROTECT
						//| SI_UGOP_PROVIDED
						;

}  //*** CClusterFileShareSecurityInformation::CClusterFileShareSecurityInformation()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterFileShareSecurityInformation::~CClusterFileShareSecurityInformation
//
//	Routine Description:
//		Destructor
//
//	Arguments:
//		none
//
//	Return Value:
//		none
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterFileShareSecurityInformation::~CClusterFileShareSecurityInformation(
	void
	)
{
}  //*** CClusterFileShareSecurityInformation::~CClusterFileShareSecurityInformation()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterFileShareSecurityInformation::GetSecurity
//
//	Routine Description:
//		Give the security descriptor to the common UI.
//
//	Arguments:
//		RequestedInformation	[IN]
//		ppSecurityDescriptor	[IN, OUT] get the security descriptor
//		fDefault				[IN]
//
//	Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterFileShareSecurityInformation::GetSecurity(
	IN SECURITY_INFORMATION RequestedInformation,
	IN OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
	IN BOOL fDefault
	)
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	HRESULT	hr = E_FAIL;

	try
	{
		if ( ppSecurityDescriptor != NULL )
		{
			*ppSecurityDescriptor = ::ClRtlCopySecurityDescriptor( Pcsp()->Pss()->Ppp()->Psec() );
			hr = S_OK;
		}
	}
	catch ( ... )
	{
		TRACE( _T("CClusterFileShareSecurityInformation::GetSecurity() - Unknown error occurred.\n") );
	}

	return hr;

}  //*** CClusterFileShareSecurityInformation::GetSecurity()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterFileShareSecurityInformation::SetSecurity
//
//	Routine Description:
//		Save the passed in descriptor
//
//	Arguments:
//		RequestedInformation	[IN]
//		ppSecurityDescriptor	[IN] the new security descriptor
//		fDefault				[IN]
//
//	Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterFileShareSecurityInformation::SetSecurity(
	SECURITY_INFORMATION SecurityInformation,
	PSECURITY_DESCRIPTOR pSecurityDescriptor
	)
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	HRESULT	hr = E_FAIL;

	try
	{
		hr = CSecurityInformation::SetSecurity( SecurityInformation, pSecurityDescriptor );
		if ( hr == S_OK )
		{
			hr = Pcsp()->Pss()->Ppp()->SetSecurityDescriptor( pSecurityDescriptor );
		}
	}
	catch( ... )
	{
		;
	}

	return hr;

}  //*** CClusterFileShareSecurityInformation::SetSecurity()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareParamsPage::HrInit
//
//	Routine Description:
//		Initialize the object
//
//	Arguments:
//		pcsp		[IN] back pointer to the parent property page
//		strServer	[IN] cluster name
//
//	Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterFileShareSecurityInformation::HrInit(
	CClusterFileShareSecurityPage * pcsp,
	IN CString const & 				strServer,
	IN CString const & 				strNode
	)
{
	ASSERT( pcsp != NULL );
	ASSERT( strServer.GetLength() > 0 );
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	m_pcsp						= pcsp;
	m_strServer					= strServer;
	m_strNode					= strNode;
	m_nLocalSIDErrorMessageID 	= IDS_LOCAL_ACCOUNTS_SPECIFIED_SMB;

	return S_OK;

}  //*** CClusterFileShareSecurityInformation::HrInit()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterFileShareSecurityPage security property page
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterFileShareSecurityPage::CClusterFileShareSecurityPage
//
//	Routine Description:
//		Default contructor
//
//	Arguments:
//		none
//
//	Return Value:
//		none
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterFileShareSecurityPage::CClusterFileShareSecurityPage( void )
	: m_hpage( 0 )
	, m_hkey( 0 )
	, m_psecinfo( NULL )
	, m_pss( NULL )
{
//	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

}  //*** CClusterFileShareSecurityPage::CClusterFileShareSecurityPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterFileShareSecurityPage::~CClusterFileShareSecurityPage
//
//	Routine Description:
//		Destructor
//
//	Arguments:
//		none
//
//	Return Value:
//		none
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterFileShareSecurityPage::~CClusterFileShareSecurityPage( void )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	m_psecinfo->Release();

}  //*** CClusterFileShareSecurityPage::~CClusterFileShareSecurityPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterFileShareSecurityPage::HrInit
//
//	Routine Description:
//
//
//	Arguments:
//
//
//	Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterFileShareSecurityPage::HrInit(
	IN CExtObject *					peo,
	IN CFileShareSecuritySheet *	pss,
	IN CString const & 				strNode
	)
{
	ASSERT( peo != NULL );
	ASSERT( pss != NULL );
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	HRESULT	hr = E_FAIL;

	if ( ( pss != NULL ) && ( peo != NULL ) )
	{
		m_peo = peo;
		m_pss = pss;

		hr = CComObject<CClusterFileShareSecurityInformation>::CreateInstance( &m_psecinfo );
		if ( SUCCEEDED( hr ) )
		{
			m_psecinfo->AddRef();

			m_hkey = GetClusterKey( Hcluster(), KEY_ALL_ACCESS );
			if ( m_hkey != NULL )
			{
				m_hpage = CreateClusterSecurityPage( m_psecinfo );
				if ( m_hpage != NULL )
				{
					CString	strServer;

					strServer.Format( _T( "\\\\%s" ), Peo()->StrClusterName() );

					hr = m_psecinfo->HrInit( this, strServer, strNode );
				}
				else
				{
					hr = E_FAIL;
				}
			}
			else
			{
				DWORD sc = ::GetLastError();
				hr = HRESULT_FROM_WIN32( sc );
			}
		}
	}

	return hr;

}  //*** CClusterFileShareSecurityPage::HrInit()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\smbspage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		SmbSPage.h
//
//	Abstract:
//		CClusterFileShareSecurityPage class declaration.  This class will encapsulate
//		the cluster file share security page.
//
//	Implementation File:
//		ClusPage.cpp
//
//	Author:
//		Galen Barbee	(galenb)	February 11, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _SMBSPAGE_H_
#define _SMBSPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif //_BASEPAGE_H_

#ifndef _ACLBASE_H_
#include "AclBase.h"
#endif //_ACLBASE_H_

#include "ExtObj.h"

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterFileShareSecurityPage;
class CFileShareSecuritySheet;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CClusterFileShareSecurityInformation security information
/////////////////////////////////////////////////////////////////////////////

class CClusterFileShareSecurityInformation : public CSecurityInformation
{
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault );
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor );

public:
	CClusterFileShareSecurityInformation( void );
	virtual ~CClusterFileShareSecurityInformation( void );

	HRESULT	HrInit( IN CClusterFileShareSecurityPage * pcsp, IN CString const & strServer, IN CString const & strNode );

protected:
	CClusterFileShareSecurityPage*	m_pcsp;

	CClusterFileShareSecurityPage*	Pcsp( void ) const { return m_pcsp; };
};

/////////////////////////////////////////////////////////////////////////////
// CClusterFileShareSecurityPage security property page wrapper
/////////////////////////////////////////////////////////////////////////////

class CClusterFileShareSecurityPage : public CBasePropertyPage
{
public:
	CClusterFileShareSecurityPage( void );
	~CClusterFileShareSecurityPage( void );

			HRESULT						HrInit(
											IN CExtObject *					peo,
											IN CFileShareSecuritySheet *	pss,
											IN CString const & 				strServer
											);
	const	HPROPSHEETPAGE				GetHPage( void ) const		{ return m_hpage; };
			CFileShareSecuritySheet*	Pss( void ) const			{ return m_pss; };

protected:
	CFileShareSecuritySheet*							m_pss;
	HPROPSHEETPAGE										m_hpage;
	HKEY												m_hkey;
	CComObject<CClusterFileShareSecurityInformation>*	m_psecinfo;
};

#endif //_SMBSPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\smbshare.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2001 Microsoft Corporation
//
//  Module Name:
//      SmbShare.h
//
//  Description:
//      Definition of the CFileShareParamsPage classes, which implement
//      the Parameters page for the File Share resource.
//      Share resources.
//
//  Implementation File:
//      SmbShare.cpp
//
//  Maintained By:
//      David Potter (davidp)   June 28, 1996
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _SMBSHARE_H_
#define _SMBSHARE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"   // for CBasePropertyPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CFileShareParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CFileShareParamsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CFileShareParamsPage : public CBasePropertyPage
{
    DECLARE_DYNCREATE(CFileShareParamsPage)

// Construction
public:
    CFileShareParamsPage(void);
    virtual ~CFileShareParamsPage(void);

// Dialog Data
    //{{AFX_DATA(CFileShareParamsPage)
    enum { IDD = IDD_PP_FILESHR_PARAMETERS };
    CButton m_pbPermissions;
    CSpinButtonCtrl m_spinMaxUsers;
    CButton m_rbMaxUsers;
    CButton m_rbMaxUsersAllowed;
    CEdit   m_editMaxUsers;
    CEdit   m_editRemark;
    CEdit   m_editPath;
    CEdit   m_editShareName;
    CString m_strShareName;
    CString m_strPath;
    CString m_strRemark;
    DWORD   m_dwCSCCache;
    //}}AFX_DATA
    CString m_strPrevShareName;
    CString m_strPrevPath;
    CString m_strPrevRemark;
    DWORD   m_dwMaxUsers;
    BOOL    m_bShareSubDirs;
    BOOL    m_bHideSubDirShares;
    BOOL    m_bIsDfsRoot;
    DWORD   m_dwPrevMaxUsers;
    BOOL    m_bPrevShareSubDirs;
    BOOL    m_bPrevHideSubDirShares;
    BOOL    m_bPrevIsDfsRoot;
    DWORD   m_dwPrevCSCCache;

    const   PSECURITY_DESCRIPTOR    Psec(void);
            HRESULT                 SetSecurityDescriptor( IN PSECURITY_DESCRIPTOR psec );

protected:
    enum
    {
        epropShareName,
        epropPath,
        epropRemark,
        epropMaxUsers,
        epropShareSubDirs,
        epropHideSubDirShares,
        epropIsDfsRoot,
        epropCSCCache,
        epropMAX
    };

    CObjectProperty     m_rgProps[epropMAX];

// Overrides
public:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CFileShareParamsPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    virtual DWORD       ScParseUnknownProperty(
                            IN LPCWSTR                          pwszName,
                            IN const CLUSPROP_BUFFER_HELPER &   rvalue,
                            IN DWORD                            cbBuf
                            );
    virtual BOOL        BApplyChanges(void);
    virtual BOOL        BBuildPropList(IN OUT CClusPropList & rcpl, IN BOOL bNoNewProps = FALSE);
    DWORD               ScConvertPropertyToSD(
                            IN const CLUSPROP_BUFFER_HELPER &   rvalue,
                            IN DWORD                            cbBuf,
                            IN PSECURITY_DESCRIPTOR             *ppsec
                            );

    virtual const CObjectProperty * Pprops(void) const  { return m_rgProps; }
    virtual DWORD                   Cprops(void) const  { return sizeof(m_rgProps) / sizeof(CObjectProperty); }

// Implementation
protected:
    CString                 m_strCaption;
    PSECURITY_DESCRIPTOR    m_psecNT4;
    PSECURITY_DESCRIPTOR    m_psecNT5;
    PSECURITY_DESCRIPTOR    m_psec;
    PSECURITY_DESCRIPTOR    m_psecPrev;

    // Generated message map functions
    //{{AFX_MSG(CFileShareParamsPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeRequiredField();
    afx_msg void OnBnClickedMaxUsers();
    afx_msg void OnEnChangeMaxUsers();
    afx_msg void OnBnClickedPermissions();
    afx_msg void OnBnClickedAdvanced();
    afx_msg void OnBnClickedCaching();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CFileShareParamsPage

#endif // _SMBSHARE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\aclhelp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       helpids.h
//
//  Contents:   Help context identifiers
//
//  History:    13-Sep-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#define HC_OK                       1
#define HC_CANCEL                   2
#define HC_SHARE_SHARENAME          3
#define HC_SHARE_COMMENT            4
#define HC_SHARE_MAXIMUM            5
#define HC_SHARE_ALLOW              6
#define HC_SHARE_ALLOW_VALUE        7
#define HC_SHARE_PERMISSIONS        8
#define HC_SHARE_NOTSHARED          9
#define HC_SHARE_SHAREDAS           10
#define HC_SHARE_SHARENAME_COMBO    11
#define HC_SHARE_REMOVE             12
#define HC_SHARE_NEWSHARE           13
#define HC_SHARE_LIMIT              14

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// The following are help ids for the ACL editor

// stolen from \nt\private\net\ui\common\h\uihelp.h
#define HC_UI_BASE              7000
#define HC_UI_SHELL_BASE        (HC_UI_BASE+10000)

// stolen from \nt\private\net\ui\shellui\h\helpnums.h
#define HC_NTSHAREPERMS              11 // Main share perm dialog
// The following four have to be consecutive
#define HC_SHAREADDUSER              12 // Share perm add dlg
#define HC_SHAREADDUSER_LOCALGROUP   13 // Share perm add->Members
#define HC_SHAREADDUSER_GLOBALGROUP  14 // Share perm add->Members
#define HC_SHAREADDUSER_FINDUSER     15 // Share perm add->FindUser
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\smbssht.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		SmbSSht.h
//
//	Abstract:
//
//	Implementation File:
//		SmbSSht.cpp
//
//	Author:
//		Galen Barbee	(galenb)	February 12, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _SMBSSHT_H_
#define _SMBSSHT_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

#ifndef _ACLBASE_H_
#include "AclBase.h"
#endif //_ACLBASE_H_

#include "SmbSPage.h"

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CFileShareParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CFileShareSecuritySheet property sheet
/////////////////////////////////////////////////////////////////////////////

class CFileShareSecuritySheet : public CPropertySheet
{
// Construction
public:
	CFileShareSecuritySheet(
		IN CWnd *			pParent,
		IN CString const &	strCaption
		);

	virtual ~CFileShareSecuritySheet(void);

	HRESULT HrInit(
		IN CFileShareParamsPage*	ppp,
		IN CExtObject*				peo,
		IN CString const &			strNode,
		IN CString const &			strShareName
		);

		CFileShareParamsPage*	Ppp( void ) const { return m_ppp; };

// Dialog Data
	//{{AFX_DATA(CFileShareSecuritySheet)
	enum { IDD = IDD_PP_FILESHR_SECURITY };
	//}}AFX_DATA

//	PSECURITY_DESCRIPTOR	m_psec;
//	PSECURITY_DESCRIPTOR	m_psecPrev;

// Overrides
public:
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFileShareSecuritySheet)
	public:
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual void BuildPropPageArray( void );

#ifdef _DEBUG
	virtual void AssertValid( void ) const;
#endif

	// Implementation
protected:
//	BOOL			m_bSecurityChanged;
	CExtObject *					m_peo;
	CFileShareParamsPage*			m_ppp;
	CString							m_strShareName;
	CString							m_strNodeName;
	CClusterFileShareSecurityPage	m_page;

	// Generated message map functions
	//{{AFX_MSG(CFileShareSecuritySheet)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CExtObject *	Peo(void) const					{ return m_peo; }

};  //*** class CFileShareSecuritySheet

/////////////////////////////////////////////////////////////////////////////

#endif // _SMBSSHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\smbssht.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		SmbSSht.cpp
//
//	Abstract:
//		Implementation of the CFileShareSecuritySheet class.
//
//	Author:
//		Galen Barbee	(galenb)	February 12, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "SmbSSht.h"
#include "AclUtils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileShareSecuritySheet property page
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CFileShareSecuritySheet, CPropertySheet)
	//{{AFX_MSG_MAP(CFileShareSecuritySheet)
	//}}AFX_MSG_MAP
	// TODO: Modify the following lines to represent the data displayed on this page.
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareSecuritySheet::CFileShareSecuritySheet
//
//	Routine Description:
//		constructor.
//
//	Arguments:
//		pParent			[IN]
//		strCaption		[IN]
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CFileShareSecuritySheet::CFileShareSecuritySheet(
	IN CWnd *			pParent,
	IN CString const &	strCaption
	) : CPropertySheet( strCaption, pParent ),
		m_peo( NULL ),
		m_ppp( NULL )
{
	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_INIT(CFileShareSecuritySheet)
	//}}AFX_DATA_INIT

}  //*** CFileShareSecuritySheet::CFileShareSecuritySheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareSecuritySheet::~CFileShareSecuritySheet
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CFileShareSecuritySheet::~CFileShareSecuritySheet(
	void
	)
{
}  //*** CFileShareSecuritySheet::~CFileShareSecuritySheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareSecuritySheet::HrInit
//
//	Routine Description:
//
//
//	Arguments:
//		ppp				[IN]
//		peo				[IN]
//		strNodeName		[IN]
//		strShareName	[IN]
//
//	Return Value:
//		hr
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CFileShareSecuritySheet::HrInit(
	IN CFileShareParamsPage*	ppp,
	IN CExtObject*				peo,
	IN CString const&			strNodeName,
	IN CString const&			strShareName
	)
{
	ASSERT( ppp != NULL );
	ASSERT( peo != NULL );

	HRESULT _hr = S_FALSE;

	if ( ( peo != NULL ) && ( ppp != NULL ) )
	{
		m_ppp			= ppp;
		m_peo			= peo;
		m_strNodeName	= strNodeName;
		m_strShareName	= strShareName;

		_hr = m_page.HrInit( peo, this, strNodeName );
	}

	return _hr;

}  //*** CFileShareSecuritySheet::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareSecuritySheet::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CFileShareSecuritySheet::DoDataExchange(
	CDataExchange * pDX
	)
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_MAP(CFileShareSecuritySheet)
	//}}AFX_DATA_MAP

	CPropertySheet::DoDataExchange( pDX );

}  //*** CFileShareSecuritySheet::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareSecuritySheet::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CFileShareSecuritySheet::OnInitDialog(
	void
	)
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	CPropertySheet::OnInitDialog();

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CFileShareSecuritySheet::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareSecuritySheet::BuildPropPageArray
//
//	Routine Description:
//		Overridden from CPropertySheet.  Puts the security hpage into the
//		PROPSHEETHEADER before calling ::PropertySheet().
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CFileShareSecuritySheet::BuildPropPageArray(
	void
	)
{
	// delete existing prop page array
	delete[] (PROPSHEETPAGE*) m_psh.ppsp;						// delete any old PROPSHEETPAGEs
	m_psh.ppsp = NULL;

	// build new PROPSHEETPAGE array and coerce to an HPROPSHEETPAGE
	m_psh.phpage = (HPROPSHEETPAGE *) new PROPSHEETPAGE[1];

	m_psh.dwFlags	   &= ~PSH_PROPSHEETPAGE;					// ensure that the hpage is used
	m_psh.phpage[0]		= m_page.GetHPage();					// assign the hpage
	m_psh.nPages		= 1;

}  //*** CFileShareSecuritySheet::BuildPropPageArray()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareSecuritySheet::AssertValid
//
//	Routine Description:
//		Overridden from CPropertySheet.  Couldn't have an assertion that
//		the PROPSHEETHEADER was using phpage instead of pspp...
//		CPropertyPage::AssertValid() required that the flag PSH_PROPSHHETPAGE
//		be set.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
void
CFileShareSecuritySheet::AssertValid(
	void
	) const
{
	CWnd::AssertValid();

	// NB: MFC is built using _WIN32_IE set to 0x0300.  Until MFC moves up
	// we cannot do the following checks because they don't align then
	// _WIN32_IE is set to 0x0400.
#if	( _WIN32_IE == 0x0300 )
		m_pages.AssertValid();
		ASSERT( m_psh.dwSize == sizeof( PROPSHEETHEADER ) );
#endif

}  //*** CFileShareSecuritySheet::AssertValid()
#endif	// _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	CluAdmEx.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#ifndef _UNICODE
#define _UNICODE            // Microsoft Windows NT Cluster Administrator
                            //   Extension DLLs need to be Unicode
                            //   applications.
#endif

// Choose which threading model you want by commenting or uncommenting
// the proper constant definition.  If you want multi-threading
// (i.e. "both"), comment both definitions out.  Also change the
// THREADFLAGS_xxx set in the DECLARE_REGISTRY macro invokation in ExtObj.h
//#define _ATL_SINGLE_THREADED
#define _ATL_APARTMENT_THREADED

// Link against the Microsoft Windows NT Cluster API library.
#pragma comment(lib, "clusapi.lib")

// Link against the Cluster Administrator Extensions library.
#pragma comment(lib, "cluadmex.lib")

/////////////////////////////////////////////////////////////////////////////
// Common Pragmas
/////////////////////////////////////////////////////////////////////////////

#pragma warning(disable : 4100)     // unreferenced formal parameters
#pragma warning(disable : 4702)     // unreachable code
#pragma warning(disable : 4711)     // function selected for automatic inline expansion

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>
#include <afxtempl.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

// Need to include this for WM_COMMANDHELP.  Unfortunately, both afxpriv.h and
// atlconv.h define some of the same macros.  Since we are using ATL, we'll use
// the ATL versions.
#define __AFXCONV_H__
#include <afxpriv.h>
#undef __AFXCONV_H__
#undef DEVMODEW2A
#undef DEVMODEA2W
#undef TEXTMETRICW2A
#undef TEXTMETRICA2W

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <commctrl.h>

#ifndef _CLUSTER_API_
#include <clusapi.h>    // for cluster definitions
#endif

#include <resapi.h>

#ifndef _CLUSRTL_INCLUDED_
#include "clusrtl.h"
#endif

#ifndef _CLUSUDEF_H_
#include "clusudef.h"
#endif

#include <htmlhelp.h>
#include <lmshare.h>

/////////////////////////////////////////////////////////////////////////////
// Common Types
/////////////////////////////////////////////////////////////////////////////

typedef UINT    IDS;
typedef UINT    IDD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmex\tracetag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		TraceTag.h
//
//	Abstract:
//		Dummy header file because we don't support trace tags in DLLs.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TRACETAG_H_
#define _TRACETAG_H_

class CTraceTag
{
public:
	CTraceTag(IN LPCTSTR pszSubsystem, IN LPCTSTR pszName, IN UINT uiFlagsDefault = NULL) {}

};  //*** class CTraceTag

 //			Expand to ";", <tab>, one "/" followed by another "/"
 //			(which is //).
 //			NOTE: This means the Trace statements have to be on ONE line.
 //			If you need multiple line Trace statements, enclose them in
 //			a #ifdef _DEBUG block.
 #define	Trace					;	/##/
#ifdef _DEBUG
 inline void TraceError(IN OUT CException & rexcept)		{ }
 inline void TraceError(IN LPCTSTR pszModule, IN DWORD sc)	{ }
 inline void TraceMenu(IN OUT CTraceTag & rtag, IN const CMenu * pmenu, IN LPCTSTR pszPrefix) { }
 inline void InitAllTraceTags(void)							{ }
 inline void CleanupAllTraceTags(void)						{ }
#else
 #define TraceError(_rexcept)
 #define TraceMenu(_rtag, _pmenu, _pszPrefix)
 #define InitAllTraceTags()
 #define CleanupAllTraceTags()
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _TRACETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\about.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		About.cpp
//
//	Abstract:
//		Implementation of the CAboutDlg class.
//
//	Author:
//		David Potter (davidp)	October 11, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "About.h"
#include "VerInfo.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CAboutDlg::CAboutDlg
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CAboutDlg::CAboutDlg(void) : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	m_strWarning = _T("");
	m_strProductTitle = _T("");
	m_strFileTitle = _T("");
	m_strVersion = _T("");
	m_strCopyright = _T("");
	//}}AFX_DATA_INIT

}  //*** CAboutDlg::CAboutDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CAboutDlg::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CAboutDlg::DoDataExchange(CDataExchange * pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	DDX_Control(pDX, IDC_ABOUT_ICON, m_staticIcon);
	DDX_Control(pDX, IDC_ABOUT_VERSION, m_staticVersion);
	DDX_Control(pDX, IDC_ABOUT_FILE_TITLE, m_staticFileTitle);
	DDX_Control(pDX, IDC_ABOUT_PRODUCT_TITLE, m_staticProductTitle);
	DDX_Control(pDX, IDC_ABOUT_WARNING, m_staticWarning);
	DDX_Control(pDX, IDC_ABOUT_COPYRIGHT, m_staticCopyright);
	DDX_Text(pDX, IDC_ABOUT_WARNING, m_strWarning);
	DDX_Text(pDX, IDC_ABOUT_PRODUCT_TITLE, m_strProductTitle);
	DDX_Text(pDX, IDC_ABOUT_FILE_TITLE, m_strFileTitle);
	DDX_Text(pDX, IDC_ABOUT_VERSION, m_strVersion);
	DDX_Text(pDX, IDC_ABOUT_COPYRIGHT, m_strCopyright);
	//}}AFX_DATA_MAP

}  //*** CAboutDlg::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CAboutDlg::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus not set yet.
//		FALSE		Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CAboutDlg::OnInitDialog(void)
{
	// Get the version info.
	try
	{
		CVersionInfo	verinfo;

		// Get the warning text.
		m_strWarning.LoadString(IDS_ABOUT_WARNING);

		// Initialize the version info.
		verinfo.Init();

		// Get strings from the version resource.
		m_strProductTitle = verinfo.PszQueryValue(_T("ProductName"));
		m_strFileTitle = verinfo.PszQueryValue(_T("FileDescription"));
		m_strCopyright = verinfo.PszQueryValue(_T("LegalCopyright"));

		// Get the version display string.
		verinfo.QueryFileVersionDisplayString(m_strVersion);
	}  // try
	catch (...)
	{
		// Who cares if an exception is thrown.  We're just displaying the about box.
	}  // catch:  anything

	// Call the base class method.
	CDialog::OnInitDialog();

	// Create fonts.
//	BCreateFont(m_fontProductTitle, 16, TRUE /*bBold*/);
//	BCreateFont(m_fontCopyright, 14, TRUE /*bBold*/);
//	BCreateFont(m_fontWarning, 4, FALSE /*bBold*/);

//	m_staticProductTitle.SetFont(&m_fontProductTitle, FALSE /*bRedraw*/);
//	m_staticFileTitle.SetFont(&m_fontProductTitle, FALSE /*bRedraw*/);
//	m_staticVersion.SetFont(&m_fontProductTitle, FALSE /*bRedraw*/);
//	m_staticCopyright.SetFont(&m_fontCopyright, FALSE /*bRedraw*/);
//	m_staticWarning.SetFont(&m_fontWarning, FALSE /*bRedraw*/);

	// Set the icon to the big cluster picture.
	{
		HICON	hicon;

		// Create huge image list.
		VERIFY(m_ilImages.Create(
					(int) 64,		// cx
					64,				// cy
					TRUE,			// bMask
					1,				// nInitial
					4				// nGrow
					));
		m_ilImages.SetBkColor(::GetSysColor(COLOR_WINDOW));

		// Load the images into the large image list.
		CClusterAdminApp::LoadImageIntoList(&m_ilImages, IDB_CLUSTER_64);

		hicon = m_ilImages.ExtractIcon(0);
		if (hicon != NULL)
			m_staticIcon.SetIcon(hicon);
	}  // Set the icon to the big cluster picture

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CAboutDlg::OnInitDialog()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\about.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		About.h
//
//	Abstract:
//		Definition of the CAboutDlg class.
//
//	Implementation File:
//		About.cpp
//
//	Author:
//		David Potter (davidp)	October 11, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _ABOUT_H_
#define _ABOUT_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CAboutDlg;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg:
/////////////////////////////////////////////////////////////////////////////

class CAboutDlg : public CDialog
{
public:
	CAboutDlg(void);

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	CStatic	m_staticIcon;
	CStatic	m_staticVersion;
	CStatic	m_staticFileTitle;
	CStatic	m_staticProductTitle;
	CStatic	m_staticWarning;
	CStatic	m_staticCopyright;
	CString	m_strWarning;
	CString	m_strProductTitle;
	CString	m_strFileTitle;
	CString	m_strVersion;
	CString	m_strCopyright;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CFont		m_fontProductTitle;
	CFont		m_fontCopyright;
	CFont		m_fontWarning;
    CImageList	m_ilImages;

	//{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CAboutDlg

/////////////////////////////////////////////////////////////////////////////

#endif // _ABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\actgrp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ActGrp.cpp
//
//	Abstract:
//		Implementation of the CActiveGroups class.
//
//	Author:
//		David Potter (davidp)	November 24, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ActGrp.h"
#include "Group.h"
#include "Node.h"
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CActiveGroups
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CActiveGroups, CClusterItem)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CActiveGroups, CClusterItem)
	//{{AFX_MSG_MAP(CActiveGroups)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CActiveGroups::CActiveGroups
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CActiveGroups::CActiveGroups(void) : CClusterItem(NULL, IDS_ITEMTYPE_CONTAINER)
{
	m_pciNode = NULL;
	m_bDocObj = FALSE;

}  //*** CActiveGroups::CActiveGroups()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CActiveGroups::Cleanup
//
//	Routine Description:
//		Cleanup the item.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CActiveGroups::Cleanup(void)
{
	// If we have been initialized, release our pointer to the node.
	if (PciNode() != NULL)
	{
		PciNode()->Release();
		m_pciNode = NULL;
	}  // if:  there is an owner

}  //*** CActiveGroups::Cleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CActiveGroups::Init
//
//	Routine Description:
//		Initialize the item.
//
//	Arguments:
//		pdoc		[IN OUT] Document to which this item belongs.
//		lpszName	[IN] Name of the item.
//		pciNode		[IN OUT] Node to which this container belongs.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CActiveGroups::Init(
	IN OUT CClusterDoc *	pdoc,
	IN LPCTSTR				lpszName,
	IN OUT CClusterNode *	pciNode
	)
{
	// Call the base class method.
	CClusterItem::Init(pdoc, lpszName);

	// Add a reference to the node.
	ASSERT(pciNode != NULL);
	ASSERT(m_pciNode == NULL);
	m_pciNode = pciNode;
	m_pciNode->AddRef();

}  //*** CActiveGroups::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CActiveGroups::BCanBeDropTarget
//
//	Routine Description:
//		Determine if the specified item can be dropped on this item.
//
//	Arguments:
//		pci			[IN OUT] Item to be dropped on this item.
//
//	Return Value:
//		TRUE		Can be drop target.
//		FALSE		Can NOT be drop target.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CActiveGroups::BCanBeDropTarget(IN const CClusterItem * pci) const
{
	ASSERT(PciNode() != NULL);
	return PciNode()->BCanBeDropTarget(pci);

}  //*** CActiveGroups::BCanBeDropTarget()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CActiveGroups::DropItem
//
//	Routine Description:
//		Process an item being dropped on this item.
//
//	Arguments:
//		pci			[IN OUT] Item dropped on this item.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CActiveGroups::DropItem(IN OUT CClusterItem * pci)
{
	ASSERT(PciNode() != NULL);
	PciNode()->DropItem(pci);

}  //*** CActiveGroups::DropItem()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\actgrp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ActGrp.h
//
//	Abstract:
//		Definition of the CActiveGroups class.
//
//	Implementation File:
//		ActGrp.cpp
//
//	Author:
//		David Potter (davidp)	November 24, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _ACTGRP_H_
#define _ACTGRP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CActiveGroups;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterDoc;
class CClusterNode;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_
#include "ClusItem.h"	// for CClusterItem
#endif

/////////////////////////////////////////////////////////////////////////////
// CActiveGroups command target
/////////////////////////////////////////////////////////////////////////////

class CActiveGroups : public CClusterItem
{
	DECLARE_DYNCREATE(CActiveGroups)

// Construction
public:
	CActiveGroups(void);			// protected constructor used by dynamic creation

	void					Init(
								IN OUT CClusterDoc *	pdoc,
								IN LPCTSTR				lpszName,
								IN OUT CClusterNode *	pciNode
								);

// Attributes
protected:
	CClusterNode *			m_pciNode;

public:
	CClusterNode *			PciNode(void) const			{ return m_pciNode; }

// Operations

// Overrides
public:
	virtual void			Cleanup(void);

	// Drag & Drop
	virtual BOOL			BCanBeDropTarget(IN const CClusterItem * pci) const;
	virtual void			DropItem(IN OUT CClusterItem * pci);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CActiveGroups)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CActiveGroups(void) { Cleanup(); }

public:
	// Generated message map functions
	//{{AFX_MSG(CActiveGroups)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

};  //*** class CActiveGroups

/////////////////////////////////////////////////////////////////////////////

#endif // _ACTGRP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\barf.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		Barf.h
//
//	Abstract:
//		Definition of the Basic Artifical Resource Failure classes.
//		BARF allows API call failures to be simulated automatically to
//		ensure full code test coverage.
//
//	Implementation File:
//		Barf.cpp
//
//	Author:
//		David Potter (davidp)	April 11, 1997
//
//	Revision History:
//
//	Notes:
//		This file compiles only in _DEBUG mode.
//
//		To implement a new BARF type, declare a global instance of CBarf:
//			CBarf g_barfMyApi(_T("My API"));
//
//		To bring up the BARF dialog:
//			DoBarfDialog();
//		This brings up a modeless dialog with the BARF settings.
//
//		A few functions are provided for special circumstances.
//		Usage of these should be fairly limited:
//			BarfAll(void);		Top Secret -> NYI.
//			EnableBarf(BOOL);	Allows you to disable/reenable BARF.
//			FailOnNextBarf;		Force the next failable call to fail.
//
//		NOTE:	Your code calls the standard APIs (e.g. LoadIcon) and the
//				BARF files do the rest.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BARF_H_
#define _BARF_H_

// Only process the rest of this file if BARF is to be implemented in the
// including module.
//#ifndef _NO_BARF_DEFINITIONS_
//#define _USING_BARF_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBarf;
class CBarfSuspend;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CTraceTag;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#define BARF_REG_SECTION		_T("Debug\\BARF")
#define BARF_REG_SECTION_FMT	BARF_REG_SECTION _T("\\%s")

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//	CBarf
//
//	Purpose:
//		Basic Artificial Resource Failure class.  Contains the BARF
//		information for a class of calls
//
//		The constructor initializes a bunch of parameters.  CBarfDialog
//		(a friend class) adjusts the various flags.  The only public API
//		is FFail().  This method determines if the next call should generate
//		an artificial failure or not.
//
/////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG

typedef void (*PFNBARFPOSTUPDATE)(void);

class CBarf : public CObject
{
	friend class CBarfSuspend;
	friend class CBarfDialog;
	friend void  InitBarf(void);
	friend void  CleanupBarf(void);
	friend void  EnableBarf(BOOL);
	friend void  BarfAll(void);
	friend void  DoBarfDialog(void);

public:
	CBarf(IN LPCTSTR pszName);

protected:
	void Init(void);

// Attributes
protected:
	LPCTSTR			m_pszName;

	BOOL			m_bDisabled;
	BOOL			m_bContinuous;
	DWORD			m_nFail;
	DWORD			m_nCurrent;
	DWORD			m_nCurrentSave;
	DWORD			m_nBarfAll;

public:
	LPCTSTR			PszName(void) const					{ return m_pszName; }
	BOOL			BDisabled(void) const				{ return m_bDisabled; }
	BOOL			BContinuous(void) const				{ return m_bContinuous; }
	DWORD			NFail(void) const					{ return m_nFail; }
	DWORD			NCurrent(void) const				{ return m_nCurrent; }
	DWORD			NCurrentSave(void) const			{ return m_nCurrentSave; }
	DWORD			NBarfAll(void) const				{ return m_nBarfAll; }

// Operations
public:
	BOOL			BFail(void);

// Implementation
public:
	static PVOID	PvSpecialMem(void)					{ return s_pvSpecialMem; }

protected:
	static CBarf *  s_pbarfFirst;
	CBarf *			m_pbarfNext;

	static LONG     s_nSuspend;
	static BOOL     s_bGlobalEnable;

	// Routine for use by the BARF dialog so that it can be
	// automatically updated with results of the BARF run.
	static PFNBARFPOSTUPDATE	s_pfnPostUpdate;
	static void					SetPostUpdateFn(IN PFNBARFPOSTUPDATE pfn)	{ ASSERT(pfn != NULL); s_pfnPostUpdate = pfn; }
	static void					ClearPostUpdateFn(void)						{ ASSERT(s_pfnPostUpdate != NULL); s_pfnPostUpdate = NULL; }
	static PFNBARFPOSTUPDATE	PfnPostUpdate(void)							{ return s_pfnPostUpdate; }

	// Pointer for use by the memory subsystem so that the BARF
	// dialog can be ignored.
	static PVOID				s_pvSpecialMem;
	static void					SetSpecialMem(IN PVOID pv)					{ ASSERT(pv != NULL); s_pvSpecialMem = pv; }

};  //*** class CBarf

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
//
//	class CBarfSuspend
//
//	Purpose:
//		Temporarily suspends BARF counters.  This is especially useful
//		from within BARF code.
//
//	Usage:
//		Create an object on the stack. Counting will be
//		suspended while the object exist.
//
//		For example:
//
//		void Foo(void)
//		{
//			DoFuncA();		// BARF counters are enabled
//
//			{
//				CBarfSuspend bs;
//
//				DoFuncB();	// BARF counters are suspended
//			}
//
//			DoFuncC();		// BARF counters are enabled again
//		}
//
//		NOTE:	This is mostly for use within the DEBUG subsystem
//				to avoid testing the DEBUG code against BARF.
//
/////////////////////////////////////////////////////////////////////////////
#ifdef	_DEBUG

class CBarfSuspend
{
private:
	static	CRITICAL_SECTION	s_critsec;
	static	BOOL				s_bCritSecValid;

protected:
	static	PCRITICAL_SECTION	Pcritsec(void)		{ return &s_critsec; }
	static	BOOL				BCritSecValid(void)	{ return s_bCritSecValid; }

public:
	CBarfSuspend(void);
	~CBarfSuspend(void);

	// for initialization only.
	static	void		Init(void);
	static	void		Cleanup(void);

};  //*** class CBarfSuspend

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Global Functions and Data
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

 extern BOOL g_bFailOnNextBarf;

 void EnableBarf(IN BOOL bEnable);
 inline void FailOnNextBarf(void)		{ g_bFailOnNextBarf = TRUE; }
 void InitBarf(void);
 void CleanupBarf(void);

 extern CTraceTag g_tagBarf;

#else

 inline void EnableBarf(IN BOOL bEnable)	{ }
 inline void FailOnNextBarf(void)			{ }
 inline void InitBarf(void)					{ }
 inline void CleanupBarf(void)				{ }

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////

//#endif // _NO_BARF_DEFINITIONS_
#endif // _BARF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\barfclus.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BarfClus.h
//
//	Abstract:
//		Definition of the Basic Artifical Resource Failure entry points
//		for CLUSAPI functions.
//
//	Implementation File:
//		BarfClus.cpp
//
//	Author:
//		David Potter (davidp)	April 14, 1997
//
//	Revision History:
//
//	Notes:
//		This file compiles only in _DEBUG mode.
//
//		To implement a new BARF type, declare a global instance of CBarf:
//			CBarf g_barfMyApi(_T("My API"));
//
//		To bring up the BARF dialog:
//			DoBarfDialog();
//		This brings up a modeless dialog with the BARF settings.
//
//		A few functions are provided for special circumstances.
//		Usage of these should be fairly limited:
//			BarfAll(void);		Top Secret -> NYI.
//			EnableBarf(BOOL);	Allows you to disable/reenable BARF.
//			FailOnNextBarf;		Force the next failable call to fail.
//
//		NOTE:	Your code calls the standard APIs (e.g. LoadIcon) and the
//				BARF files do the rest.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BARFCLUS_H_
#define _BARFCLUS_H_

// Only process the rest of this file if BARF is to be implemented in the
// including module.
#ifndef _NO_BARF_DEFINITIONS_
#define _USING_BARF_

#ifdef _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Cluster Management Functions
/////////////////////////////////////////////////////////////////////////////

#undef		CloseCluster
#define		CloseCluster(_hCluster) BARFCloseCluster(_hCluster)
BOOL		BARFCloseCluster(HCLUSTER hCluster);

#undef		CloseClusterNotifyPort
#define		CloseClusterNotifyPort(_hChange) BARFCloseClusterNotifyPort(_hChange)
BOOL		BARFCloseClusterNotifyPort(HCHANGE hChange);

#undef		ClusterCloseEnum
#define		ClusterCloseEnum(_hClusEnum) BARFClusterCloseEnum(_hClusEnum)
DWORD		BARFClusterCloseEnum(HCLUSENUM hClusEnum);

#undef		ClusterEnum
#define		ClusterEnum(_hClusEnum, _dwIndex, _lpdwType, _lpszName, _lpcchName) BARFClusterEnum(_hClusEnum, _dwIndex, _lpdwType, _lpszName, _lpcchName)
DWORD		BARFClusterEnum(HCLUSENUM hClusEnum, DWORD dwIndex, LPDWORD lpdwType, LPWSTR lpszName, LPDWORD lpcchName);

#undef		ClusterOpenEnum
#define		ClusterOpenEnum(_hCluster, _dwType) BARFClusterOpenEnum(_hCluster, _dwType)
HCLUSENUM	BARFClusterOpenEnum(HCLUSTER hCluster, DWORD dwType);

#undef		ClusterResourceTypeControl
#define		ClusterResourceTypeControl(_hCluster, _lpszResourceTypeName, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned) BARFClusterResourceTypeControl(_hCluster, _lpszResourceTypeName, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned)
DWORD		BARFClusterResourceTypeControl(HCLUSTER hCluster, LPCWSTR lpszResourceTypeName, HNODE hHostNode, DWORD dwControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned);

#undef		CreateClusterNotifyPort
#define		CreateClusterNotifyPort(_hChange, _hCluster, _dwFilter, _dwNotifyKey) BARFCreateClusterNotifyPort(_hChange, _hCluster, _dwFilter, _dwNotifyKey)
HCHANGE		BARFCreateClusterNotifyPort(HCHANGE hChange, HCLUSTER hCluster, DWORD dwFilter, DWORD_PTR dwNotifyKey);

#undef		CreateClusterResourceType
#define		CreateClusterResourceType(_hCluster, _lpszResourceTypeName, _lpszDisplayName, _lpszResourceTypeDll, _dwLooksAlivePollInterval, _dwIsAlivePollInterval) BARFCreateClusterResourceType(_hCluster, _lpszResourceTypeName, _lpszDisplayName, _lpszResourceTypeDll, _dwLooksAlivePollInterval, _dwIsAlivePollInterval)
DWORD		BARFCreateClusterResourceType(HCLUSTER hCluster, LPCWSTR lpszResourceTypeName, LPCWSTR lpszDisplayName, LPCWSTR lpszResourceTypeDll, DWORD dwLooksAlivePollInterval, DWORD dwIsAlivePollInterval);

#undef		DeleteClusterResourceType
#define		DeleteClusterResourceType(_hCluster, _lpszResourceTypeName) BARFDeleteClusterResourceType(_hCluster, _lpszResourceTypeName)
DWORD		BARFDeleteClusterResourceType(HCLUSTER hCluster, LPCWSTR lpszResourceTypeName);

#undef		GetClusterInformation
#define		GetClusterInformation(_hCluster, _lpszClusterName, _lpcchClusterName, _lpClusterInfo) BARFGetClusterInformation(_hCluster, _lpszClusterName, _lpcchClusterName, _lpClusterInfo)
DWORD		BARFGetClusterInformation(HCLUSTER hCluster, LPWSTR lpszClusterName, LPDWORD lpcchClusterName, LPCLUSTERVERSIONINFO lpClusterInfo);

#undef		GetClusterNotify
#define		GetClusterNotify(_hChange, _lpdwNotifyKey, _lpdwFilterType, _lpszName, _lpcchName, _dwMilliseconds) BARFGetClusterNotify(_hChange, _lpdwNotifyKey, _lpdwFilterType, _lpszName, _lpcchName, _dwMilliseconds)
DWORD		BARFGetClusterNotify(HCHANGE hChange, DWORD_PTR *lpdwNotifyKey, LPDWORD lpdwFilterType, LPWSTR lpszName, LPDWORD lpcchName, DWORD dwMilliseconds);

#undef		GetClusterQuorumResource
#define		GetClusterQuorumResource(_hCluster, _lpszResourceName, _lpcbResourceName, _lpszDeviceName, _lpcbDeviceName, _lpdwMaxQuorumLogSize) BARFGetClusterQuorumResource(_hCluster, _lpszResourceName, _lpcbResourceName, _lpszDeviceName, _lpcbDeviceName, _lpdwMaxQuorumLogSize)
DWORD		BARFGetClusterQuorumResource(HCLUSTER hCluster, LPWSTR lpszResourceName, LPDWORD lpcbResourceName, LPWSTR lpszDeviceName, LPDWORD lpcbDeviceName, LPDWORD lpdwMaxQuorumLogSize);

#undef		OpenCluster
#define		OpenCluster(_lpszClusterName) BARFOpenCluster(_lpszClusterName)
HCLUSTER	BARFOpenCluster(LPCWSTR lpszClusterName);

#undef		RegisterClusterNotify
#define		RegisterClusterNotify(_hChange, _dwFilter, _hObject, _dwNotifyKey) BARFRegisterClusterNotify(_hChange, _dwFilter, _hObject, _dwNotifyKey)
DWORD		BARFRegisterClusterNotify(HCHANGE hChange, DWORD dwFilter, HANDLE hObject, DWORD_PTR dwNotifyKey);

#undef		SetClusterName
#define		SetClusterName(_hCluster, _lpszNewClusterName) BARFSetClusterName(_hCluster, _lpszNewClusterName)
DWORD		BARFSetClusterName(HCLUSTER hCluster, LPCWSTR lpszNewClusterName);

#undef		SetClusterQuorumResource
#define		SetClusterQuorumResource(_hResource, _lpszDeviceName, _dwMazQuoLogSize) BARFSetClusterQuorumResource(_hResource, _lpszDeviceName, _dwMazQuoLogSize)
DWORD		BARFSetClusterQuorumResource(HRESOURCE hResource, LPCWSTR lpszDeviceName, DWORD dwMaxQuoLogSize);

/////////////////////////////////////////////////////////////////////////////
// Node Management Functions
/////////////////////////////////////////////////////////////////////////////

#undef		CloseClusterNode
#define		CloseClusterNode(_hNode) BARFCloseClusterNode(_hNode)
BOOL		BARFCloseClusterNode(HNODE hNode);

#undef		ClusterNodeControl
#define		ClusterNodeControl(_hNode, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned) BARFClusterNodeControl(_hNode, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned)
DWORD		BARFClusterNodeControl(HNODE hNode, HNODE hHostNode, DWORD dwControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned);

#undef		EvictClusterNode
#define		EvictClusterNode(_hNode) BARFEvictClusterNode(_hNode)
DWORD		BARFEvictClusterNode(HNODE hNode);

#undef		GetClusterNodeId
#define		GetClusterNodeId(_hNode, _lpszNodeId, _lpcchNodeId) BARFGetClusterNodeId(_hNode, _lpszNodeId, _lpcchNodeId)
DWORD		BARFGetClusterNodeId(HNODE hNode, LPWSTR lpszNodeId, LPDWORD lpcchNodeId);

#undef		GetClusterNodeState
#define		GetClusterNodeState(_hNode) BARFGetClusterNodeState(_hNode)
CLUSTER_NODE_STATE BARFGetClusterNodeState(HNODE hNode);

#undef		OpenClusterNode
#define		OpenClusterNode(_hCluster, _lpszNodeName) BARFOpenClusterNode(_hCluster, _lpszNodeName)
HNODE		BARFOpenClusterNode(HCLUSTER hCluster, LPCWSTR lpszNodeName);

#undef		PauseClusterNode
#define		PauseClusterNode(_hNode) BARFPauseClusterNode(_hNode)
DWORD		BARFPauseClusterNode(HNODE hNode);

#undef		ResumeClusterNode
#define		ResumeClusterNode(_hNode) BARFResumeClusterNode(_hNode)
DWORD		BARFResumeClusterNode(HNODE hNode);

/////////////////////////////////////////////////////////////////////////////
// Group Management Functions
/////////////////////////////////////////////////////////////////////////////

#undef		CloseClusterGroup
#define		CloseClusterGroup(_hGroup) BARFCloseClusterGroup(_hGroup)
BOOL		BARFCloseClusterGroup(HGROUP hGroup);

#undef		ClusterGroupCloseEnum
#define		ClusterGroupCloseEnum(_hGroupEnum) BARFClusterGroupCloseEnum(_hGroupEnum)
DWORD		BARFClusterGroupCloseEnum(HGROUPENUM hGroupEnum);

#undef		ClusterGroupControl
#define		ClusterGroupControl(_hGroup, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned) BARFClusterGroupControl(_hGroup, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned)
DWORD		BARFClusterGroupControl(HGROUP hGroup, HNODE hHostNode, DWORD dwControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned);

#undef		ClusterGroupEnum
#define		ClusterGroupEnum(_hGroupEnum, _dwIndex, _lpdwType, _lpszResourceName, _lpcchName) BARFClusterGroupEnum(_hGroupEnum, _dwIndex, _lpdwType, _lpszResourceName, _lpcchName)
DWORD		BARFClusterGroupEnum(HGROUPENUM hGroupEnum, DWORD dwIndex, LPDWORD lpdwType, LPWSTR lpszResourceName, LPDWORD lpcchName);

#undef		ClusterGroupOpenEnum
#define		ClusterGroupOpenEnum(_hGroup, _dwType) BARFClusterGroupOpenEnum(_hGroup, _dwType)
HGROUPENUM	BARFClusterGroupOpenEnum(HGROUP hGroup, DWORD dwType);

#undef		CreateClusterGroup
#define		CreateClusterGroup(_hCluster, _lpszGroupName) BARFCreateClusterGroup(_hCluster, _lpszGroupName)
HGROUP		BARFCreateClusterGroup(HCLUSTER hCluster, LPCWSTR lpszGroupName);

#undef		DeleteClusterGroup
#define		DeleteClusterGroup(_hGroup) BARFDeleteClusterGroup(_hGroup)
DWORD		BARFDeleteClusterGroup(HGROUP hGroup);

#undef		GetClusterGroupState
#define		GetClusterGroupState(_hGroup, _lpszNodeName, _lpcchNodeName) BARFGetClusterGroupState(_hGroup, _lpszNodeName, _lpcchNodeName)
CLUSTER_GROUP_STATE BARFGetClusterGroupState(HGROUP hGroup, LPWSTR lpszNodeName, LPDWORD lpcchNodeName);

#undef		MoveClusterGroup
#define		MoveClusterGroup(_hGroup, _hDestinationNode) BARFMoveClusterGroup(_hGroup, _hDestinationNode)
DWORD		BARFMoveClusterGroup(HGROUP hGroup, HNODE hDestinationNode);

#undef		OfflineClusterGroup
#define		OfflineClusterGroup(_hGroup) BARFOfflineClusterGroup(_hGroup)
DWORD		BARFOfflineClusterGroup(HGROUP hGroup);

#undef		OnlineClusterGroup
#define		OnlineClusterGroup(_hGroup, _hDestinationNode) BARFOnlineClusterGroup(_hGroup, _hDestinationNode)
DWORD		BARFOnlineClusterGroup(HGROUP hGroup, HNODE hDestinationNode);

#undef		OpenClusterGroup
#define		OpenClusterGroup(_hCluster, _lpszGroupName) BARFOpenClusterGroup(_hCluster, _lpszGroupName)
HGROUP		BARFOpenClusterGroup(HCLUSTER hCluster, LPCWSTR lpszGroupName);

#undef		SetClusterGroupName
#define		SetClusterGroupName(_hGroup, _lpszGroupName) BARFSetClusterGroupName(_hGroup, _lpszGroupName)
DWORD		BARFSetClusterGroupName(HGROUP hGroup, LPCWSTR lpszGroupName);

#undef		SetClusterGroupNodeList
#define		SetClusterGroupNodeList(_hGroup, _cNodeCount, _phNodeList) BARFSetClusterGroupNodeList(_hGroup, _cNodeCount, _phNodeList)
DWORD		BARFSetClusterGroupNodeList(HGROUP hGroup, DWORD cNodeCount, HNODE phNodeList[]);

/////////////////////////////////////////////////////////////////////////////
// Resource Management Functions
/////////////////////////////////////////////////////////////////////////////

#undef		AddClusterResourceDependency
#define		AddClusterResourceDependency(_hResource, _hDependsOn) BARFAddClusterResourceDependency(_hResource, _hDependsOn)
DWORD		BARFAddClusterResourceDependency(HRESOURCE hResource, HRESOURCE hDependsOn);

#undef		AddClusterResourceNode
#define		AddClusterResourceNode(_hResource, _hNode) BARFAddClusterResourceNode(_hResource, _hNode)
DWORD		BARFAddClusterResourceNode(HRESOURCE hResource, HNODE hNode);

#undef		CanResourceBeDependent
#define		CanResourceBeDependent(_hResource, _hResourceDependent) BARFCanResourceBeDependent(_hResource, _hResourceDependent)
BOOL		BARFCanResourceBeDependent(HRESOURCE hResource, HRESOURCE hResourceDependent);

#undef		ChangeClusterResourceGroup
#define		ChangeClusterResourceGroup(_hResource, _hGroup) BARFChangeClusterResourceGroup(_hResource, _hGroup)
DWORD		BARFChangeClusterResourceGroup(HRESOURCE hResource, HGROUP hGroup);

#undef		CloseClusterResource
#define		CloseClusterResource(_hResource) BARFCloseClusterResource(_hResource)
BOOL		BARFCloseClusterResource(HRESOURCE hResource);

#undef		ClusterResourceCloseEnum
#define		ClusterResourceCloseEnum(_hResEnum) BARFClusterResourceCloseEnum(_hResEnum)
DWORD		BARFClusterResourceCloseEnum(HRESENUM hResEnum);

#undef		ClusterResourceControl
#define		ClusterResourceControl(_hResource, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned) BARFClusterResourceControl(_hResource, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned)
DWORD		BARFClusterResourceControl(HRESOURCE hResource, HNODE hHostNode, DWORD dwControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned);

#undef		ClusterResourceEnum
#define		ClusterResourceEnum(_hResEnum, _dwIndex, _lpdwType, _lpszName, _lpcchName) BARFClusterResourceEnum(_hResEnum, _dwIndex, _lpdwType, _lpszName, _lpcchName)
DWORD		BARFClusterResourceEnum(HRESENUM hResEnum, DWORD dwIndex, LPDWORD lpdwType, LPWSTR lpszName, LPDWORD lpcchName);

#undef		ClusterResourceOpenEnum
#define		ClusterResourceOpenEnum(_hResource, _dwType) BARFClusterResourceOpenEnum(_hResource, _dwType)
HRESENUM	BARFClusterResourceOpenEnum(HRESOURCE hResource, DWORD dwType);

#undef		CreateClusterResource
#define		CreateClusterResource(_hGroup, _lpszResourceName, _lpszResourceType, _dwFlags) BARFCreateClusterResource(_hGroup, _lpszResourceName, _lpszResourceType, _dwFlags)
HRESOURCE	BARFCreateClusterResource(HGROUP hGroup, LPCWSTR lpszResourceName, LPCWSTR lpszResourceType, DWORD dwFlags);

#undef		DeleteClusterResource
#define		DeleteClusterResource(_hResource) BARFDeleteClusterResource(_hResource)
DWORD		BARFDeleteClusterResource(HRESOURCE hResource);

#undef		FailClusterResource
#define		FailClusterResource(_hResource) BARFFailClusterResource(_hResource)
DWORD		BARFFailClusterResource(HRESOURCE hResource);

#undef		GetClusterResourceNetworkName
#define		GetClusterResourceNetworkName(_hResource, _lpBuffer, _nSize) BARFGetClusterResourceNetworkName(_hResource, _lpBuffer, _nSize)
BOOL		BARFGetClusterResourceNetworkName(HRESOURCE hResource, LPWSTR lpBuffer, LPDWORD nSize);

#undef		GetClusterResourceState
#define		GetClusterResourceState(_hResource, _lpszNodeName, _lpcchNodeName, _lpszGroupName, _lpcchGroupName) BARFGetClusterResourceState(_hResource, _lpszNodeName, _lpcchNodeName, _lpszGroupName, _lpcchGroupName)
CLUSTER_RESOURCE_STATE BARFGetClusterResourceState(HRESOURCE hResource, LPWSTR lpszNodeName, LPDWORD lpcchNodeName, LPWSTR lpszGroupName, LPDWORD lpcchGroupName);

#undef		OfflineClusterResource
#define		OfflineClusterResource(_hResource) BARFOfflineClusterResource(_hResource)
DWORD		BARFOfflineClusterResource(HRESOURCE hResource);

#undef		OnlineClusterResource
#define		OnlineClusterResource(_hResource) BARFOnlineClusterResource(_hResource)
DWORD		BARFOnlineClusterResource(HRESOURCE hResource);

#undef		OpenClusterResource
#define		OpenClusterResource(_hCluster, _lpszResourceName) BARFOpenClusterResource(_hCluster, _lpszResourceName)
HRESOURCE	BARFOpenClusterResource(HCLUSTER hCluster, LPCWSTR lpszResourceName);

#undef		RemoveClusterResourceNode
#define		RemoveClusterResourceNode(_hResource, _hNode) BARFRemoveClusterResourceNode(_hResource, _hNode)
DWORD		BARFRemoveClusterResourceNode(HRESOURCE hResource, HNODE hNode);

#undef		RemoveClusterResourceDependency
#define		RemoveClusterResourceDependency(_hResource, _hDependsOn) BARFRemoveClusterResourceDependency(_hResource, _hDependsOn)
DWORD		BARFRemoveClusterResourceDependency(HRESOURCE hResource, HRESOURCE hDependsOn);

#undef		SetClusterResourceName
#define		SetClusterResourceName(_hResource, _lpszResourceName) BARFSetClusterResourceName(_hResource, _lpszResourceName)
DWORD		BARFSetClusterResourceName(HRESOURCE hResource, LPCWSTR lpszResourceName);

/////////////////////////////////////////////////////////////////////////////
// Network Management Functions
/////////////////////////////////////////////////////////////////////////////

#undef		OpenClusterNetwork
#define		OpenClusterNetwork(_hCluster, _lpszNetworkName) BARFOpenClusterNetwork(_hCluster, _lpszNetworkName)
HNETWORK	BARFOpenClusterNetwork(HCLUSTER hCluster, LPCWSTR lpszNetworkName);

#undef		CloseClusterNetwork
#define		CloseClusterNetwork(_hNetwork) BARFCloseClusterNetwork(_hNetwork)
BOOL		BARFCloseClusterNetwork(HNETWORK hNetwork);

#undef		ClusterNetworkOpenEnum
#define		ClusterNetworkOpenEnum(_hNetwork, _dwType) BARFClusterNetworkOpenEnum(_hNetwork, _dwType)
HNETWORKENUM BARFClusterNetworkOpenEnum(HNETWORK hNetwork, DWORD dwType);

#undef		ClusterNetworkEnum
#define		ClusterNetworkEnum(_hNetworkEnum, _dwIndex, _lpdwType, _lpszName, _lpcchName) BARFClusterNetworkEnum(_hNetworkEnum, _dwIndex, _lpdwType, _lpszName, _lpcchName)
DWORD		BARFClusterNetworkEnum(HNETWORKENUM hNetworkEnum, DWORD dwIndex, DWORD * lpdwType, LPWSTR lpszName, LPDWORD lpcchName);

#undef		ClusterNetworkCloseEnum
#define		ClusterNetworkCloseEnum(_hNetworkEnum) BARFClusterNetworkCloseEnum(_hNetworkEnum)
DWORD		BARFClusterNetworkCloseEnum(HNETWORKENUM hNetworkEnum);

#undef		GetClusterNetworkState
#define		GetClusterNetworkState(_hNetwork) BARFGetClusterNetworkState(_hNetwork)
CLUSTER_NETWORK_STATE BARFGetClusterNetworkState(HNETWORK hNetwork);

#undef		SetClusterNetworkName
#define		SetClusterNetworkName(_hNetwork, _lpszName) BARFSetClusterNetworkName(_hNetwork, _lpszName)
DWORD		BARFSetClusterNetworkName(HNETWORK hNetwork, LPCWSTR lpszName);

#undef		ClusterNetworkControl
#define		ClusterNetworkControl(_hNetwork, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned) BARFClusterNetworkControl(_hNetwork, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned)
DWORD		BARFClusterNetworkControl(HNETWORK hNetwork, HNODE hHostNode, DWORD dwControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned);

/////////////////////////////////////////////////////////////////////////////
// Network Interface Management Functions
/////////////////////////////////////////////////////////////////////////////

#undef		OpenClusterNetInterface
#define		OpenClusterNetInterface(_hCluster, _lpszInterfaceName) BARFOpenClusterNetInterface(_hCluster, _lpszInterfaceName)
HNETINTERFACE BARFOpenClusterNetInterface(HCLUSTER hCluster, LPCWSTR lpszInterfaceName);

#undef		GetClusterNetInterface
#define		GetClusterNetInterface(_hCluster, _lpszNodeName, _lpszNetworkName, _lpszNetInterfaceName, _lpcchNetInterfaceName) BARFGetClusterNetInterface(_hCluster, _lpszNodeName, _lpszNetworkName, _lpszNetInterfaceName, _lpcchNetInterfaceName)
HNETINTERFACE BARFGetClusterNetInterface(HCLUSTER hCluster, LPCWSTR lpszNodeName, LPCWSTR lpszNetworkName, LPWSTR lpszNetInterfaceName, DWORD * lpcchNetInterfaceName);

#undef		CloseClusterNetInterface
#define		CloseClusterNetInterface(_hNetInterface) BARFCloseClusterNetInterface(_hNetInterface)
BOOL		BARFCloseClusterNetInterface(HNETINTERFACE hNetInterface);

#undef		GetClusterNetInterfaceState
#define		GetClusterNetInterfaceState(_hNetInterface) BARFGetClusterNetInterfaceState(_hNetInterface)
CLUSTER_NETINTERFACE_STATE BARFGetClusterNetInterfaceState(HNETINTERFACE hNetInterface);

#undef		ClusterNetInterfaceControl
#define		ClusterNetInterfaceControl(_hNetInterface, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned) BARFClusterNetInterfaceControl(_hNetInterface, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned)
DWORD		BARFClusterNetInterfaceControl(HNETINTERFACE hNetInterface, HNODE hHostNode, DWORD dwControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned);

/////////////////////////////////////////////////////////////////////////////
// Cluster Database Management Functions
/////////////////////////////////////////////////////////////////////////////

#undef		ClusterRegCloseKey
#define		ClusterRegCloseKey(_hKey) BARFClusterRegCloseKey(_hKey)
LONG		BARFClusterRegCloseKey(HKEY hKey);

#undef		ClusterRegCreateKey
#define		ClusterRegCreateKey(_hKey, _lpszSubKey, _dwOptions, _samDesired, _lpSecurityAttributes, _phkResult, _lpdwDisposition) BARFClusterRegCreateKey(_hKey, _lpszSubKey, _dwOptions, _samDesired, _lpSecurityAttributes, _phkResult, _lpdwDisposition)
LONG		BARFClusterRegCreateKey(HKEY hKey, LPCWSTR lpszSubKey, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);

#undef		ClusterRegDeleteKey
#define		ClusterRegDeleteKey(_hKey, _lpszSubKey) BARFClusterRegDeleteKey(_hKey, _lpszSubKey)
LONG		BARFClusterRegDeleteKey(HKEY hKey, LPCWSTR lpszSubKey);

#undef		ClusterRegDeleteValue
#define		ClusterRegDeleteValue(_hKey, _lpszValueName) BARFClusterRegDeleteValue(_hKey, _lpszValueName)
DWORD		BARFClusterRegDeleteValue(HKEY hKey, LPCWSTR lpszValueName);

#undef		ClusterRegEnumKey
#define		ClusterRegEnumKey(_hKey, _dwIndex, _lpszName, _lpcchName, _lpftLastWriteTime) BARFClusterRegEnumKey(_hKey, _dwIndex, _lpszName, _lpcchName, _lpftLastWriteTime)
LONG		BARFClusterRegEnumKey(HKEY hKey, DWORD dwIndex, LPWSTR lpszName, LPDWORD lpcchName, PFILETIME lpftLastWriteTime);

#undef		ClusterRegEnumValue
#define		ClusterRegEnumValue(_hKey, _dwIndex, _lpszValueName, _lpcchValueName, _lpdwType, _lpbData, _lpcbData) BARFClusterRegEnumValue(_hKey, _dwIndex, _lpszValueName, _lpcchValueName, _lpdwType, _lpbData, _lpcbData)
DWORD		BARFClusterRegEnumValue(HKEY hKey, DWORD dwIndex, LPWSTR lpszValueName, LPDWORD lpcchValueName, LPDWORD lpdwType, LPBYTE lpbData, LPDWORD lpcbData);

#undef		ClusterRegGetKeySecurity
#define		ClusterRegGetKeySecurity(_hKey, _SecurityInformation, _pSecurityDescriptor, _lpcbSecurityDescriptor) BARFClusterRegGetKeySecurity(_hKey, _SecurityInformation, _pSecurityDescriptor, _lpcbSecurityDescriptor)
LONG		BARFClusterRegGetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, LPDWORD lpcbSecurityDescriptor);

#undef		ClusterRegOpenKey
#define		ClusterRegOpenKey(_hKey, _lpszSubKey, _samDesired, _phkResult) BARFClusterRegOpenKey(_hKey, _lpszSubKey, _samDesired, _phkResult)
LONG		BARFClusterRegOpenKey(HKEY hKey, LPCWSTR lpszSubKey, REGSAM samDesired, PHKEY phkResult);

#undef		ClusterRegQueryInfoKey
#define		ClusterRegQueryInfoKey(_hKey, _lpcSubKeys, _lpcbMaxSubKeyLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime) BARFClusterRegQueryInfoKey(_hKey, _lpcSubKeys, _lpcbMaxSubKeyLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime)
LONG		BARFClusterRegQueryInfoKey(HKEY hKey, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);

#undef		ClusterRegQueryValue
#define		ClusterRegQueryValue(_hKey, _lpszValueName, _lpdwValueType, _lpbData, _lpcbData) BARFClusterRegQueryValue(_hKey, _lpszValueName, _lpdwValueType, _lpbData, _lpcbData)
LONG		BARFClusterRegQueryValue(HKEY hKey, LPCWSTR lpszValueName, LPDWORD lpdwValueType, LPBYTE lpbData, LPDWORD lpcbData);

#undef		ClusterRegSetKeySecurity
#define		ClusterRegSetKeySecurity(_hKey, _SecurityInformation, _pSecurityDescriptor) BARFClusterRegSetKeySecurity(_hKey, _SecurityInformation, _pSecurityDescriptor)
LONG		BARFClusterRegSetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor);

#undef		ClusterRegSetValue
#define		ClusterRegSetValue(_hKey, _lpszValueName, _dwType, _lpbData, _cbData) BARFClusterRegSetValue(_hKey, _lpszValueName, _dwType, _lpbData, _cbData)
DWORD		BARFClusterRegSetValue(HKEY hKey, LPCWSTR lpszValueName, DWORD dwType, CONST BYTE * lpbData, DWORD cbData);

#undef		GetClusterGroupKey
#define		GetClusterGroupKey(_hGroup, _samDesired) BARFGetClusterGroupKey(_hGroup, _samDesired)
HKEY		BARFGetClusterGroupKey(HGROUP hGroup, REGSAM samDesired);

#undef		GetClusterKey
#define		GetClusterKey(_hCluster, _samDesired) BARFGetClusterKey(_hCluster, _samDesired)
HKEY		BARFGetClusterKey(HCLUSTER hCluster, REGSAM samDesired);

#undef		GetClusterNodeKey
#define		GetClusterNodeKey(_hNode, _samDesired) BARFGetClusterNodeKey(_hNode, _samDesired)
HKEY		BARFGetClusterNodeKey(HNODE hNode, REGSAM samDesired);

#undef		GetClusterResourceKey
#define		GetClusterResourceKey(_hResource, _samDesired) BARFGetClusterResourceKey(_hResource, _samDesired)
HKEY		BARFGetClusterResourceKey(HRESOURCE hResource, REGSAM samDesired);

#undef		GetClusterResourceTypeKey
#define		GetClusterResourceTypeKey(_hCluster, _lpszTypeName, _samDesired) BARFGetClusterResourceTypeKey(_hCluster, _lpszTypeName, _samDesired)
HKEY		BARFGetClusterResourceTypeKey(HCLUSTER hCluster, LPCWSTR lpszTypeName, REGSAM samDesired);

#undef		GetClusterNetworkKey
#define		GetClusterNetworkKey(_hNetwork, _samDesired) BARFGetClusterNetworkKey(_hNetwork, _samDesired)
HKEY		BARFGetClusterNetworkKey(HNETWORK hNetwork, REGSAM samDesired);

#undef		GetClusterNetInterfaceKey
#define		GetClusterNetInterfaceKey(_hNetInterface, _samDesired) BARFGetClusterNetInterfaceKey(_hNetInterface, _samDesired)
HKEY		BARFGetClusterNetInterfaceKey(HNETINTERFACE hNetInterface, REGSAM samDesired);

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////

#endif // _NO_BARF_DEFINITIONS_
#endif // _BARF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\barfdlg.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      BarfDlg.cpp
//
//  Abstract:
//      Implementation of the Basic Artifical Resource Failure dialog classes.
//
//  Author:
//      David Potter (davidp)   April 11, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#define _RESOURCE_H_

#define _NO_BARF_DEFINITIONS_

#include "Barf.h"
#include "BarfDlg.h"
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef  _USING_BARF_
 #error BARF failures should be disabled!
#endif

#ifdef _DEBUG   // The entire file!

#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

CTraceTag   g_tagBarfDialog(_T("Debug"), _T("BARF Dialog"), 0);


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CBarfDialog
/////////////////////////////////////////////////////////////////////////////

CBarfDialog *   CBarfDialog::s_pdlg     = NULL;
HICON           CBarfDialog::s_hicon    = NULL;

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CBarfDialog, CDialog)
    //{{AFX_MSG_MAP(CBarfDialog)
    ON_BN_CLICKED(IDC_BS_RESET_CURRENT_COUNT, OnResetCurrentCount)
    ON_BN_CLICKED(IDC_BS_RESET_ALL_COUNTS, OnResetAllCounts)
    ON_BN_CLICKED(IDC_BS_GLOBAL_ENABLE, OnGlobalEnable)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_BS_CATEGORIES_LIST, OnItemChanged)
    ON_BN_CLICKED(IDC_BS_CONTINUOUS, OnStatusChange)
    ON_BN_CLICKED(IDC_BS_DISABLE, OnStatusChange)
    ON_EN_CHANGE(IDC_BS_FAIL_AT, OnStatusChange)
    ON_WM_CLOSE()
    //}}AFX_MSG_MAP
    ON_COMMAND(IDCANCEL, OnCancel)
    ON_MESSAGE(WM_USER+5, OnBarfUpdate)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::CBarfDialog
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBarfDialog::CBarfDialog(void)
{
    //{{AFX_DATA_INIT(CBarfDialog)
    m_nFailAt = 0;
    m_bContinuous = FALSE;
    m_bDisable = FALSE;
    m_bGlobalEnable = FALSE;
    //}}AFX_DATA_INIT

    Trace(g_tagBarfDialog, _T("CBarfDialog::CBarfDialog"));

    m_pbarfSelected = NULL;

}  //*** CBarfDialog::CBarfDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::Create
//
//  Routine Description:
//      Modeless dialog creation method.
//
//  Arguments:
//      pParentWnd      [IN OUT] Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBarfDialog::Create(
    IN OUT CWnd * pParentWnd //=NULL
    )
{
    Trace(g_tagBarfDialog, _T("CBarfDialog::Create"));

    return CDialog::Create(IDD, pParentWnd);

}  //*** CBarfDialog::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::DoDataExchange(CDataExchange * pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CBarfDialog)
    DDX_Control(pDX, IDC_BS_GLOBAL_ENABLE, m_ckbGlobalEnable);
    DDX_Control(pDX, IDC_BS_DISABLE, m_ckbDisable);
    DDX_Control(pDX, IDC_BS_CONTINUOUS, m_ckbContinuous);
    DDX_Control(pDX, IDC_BS_CATEGORIES_LIST, m_lcCategories);
    DDX_Text(pDX, IDC_BS_FAIL_AT, m_nFailAt);
    DDX_Check(pDX, IDC_BS_CONTINUOUS, m_bContinuous);
    DDX_Check(pDX, IDC_BS_DISABLE, m_bDisable);
    DDX_Check(pDX, IDC_BS_GLOBAL_ENABLE, m_bGlobalEnable);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
    }  // if:  saving data from the dialog
    else
    {
        int     ili;
        CBarf * pbarf;
        CString str;

        ili = m_lcCategories.GetNextItem(-1, LVNI_SELECTED);
        if (ili == -1)
            ili = m_lcCategories.GetNextItem(-1, LVNI_FOCUSED);
        if (ili != -1)
        {
            pbarf = (CBarf *) m_lcCategories.GetItemData(ili);

            // Set the current count.
            str.Format(_T("%d"), pbarf->NCurrent());
            VERIFY(m_lcCategories.SetItemText(ili, 1, str));

            // Set the failure point.
            str.Format(_T("%d"), pbarf->NFail());
            VERIFY(m_lcCategories.SetItemText(ili, 2, str));
        }  // if:  there is an item with focus

    }  // else:  setting data to the dialog

}  //*** CBarfDialog::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBarfDialog::OnInitDialog(void)
{
    // Call the base class.
    CDialog::OnInitDialog();

    ASSERT(Pdlg() == NULL);
    s_pdlg = this;

    // Set the post update function to point to our static function.
    CBarf::SetPostUpdateFn(&PostUpdate);
    CBarf::SetSpecialMem(Pdlg());

    // Add the columns to the list control.
    {
        m_lcCategories.InsertColumn(0, _T("Category"), LVCFMT_LEFT, 100);
        m_lcCategories.InsertColumn(1, _T("Count"), LVCFMT_LEFT, 50);
        m_lcCategories.InsertColumn(2, _T("Fail At"), LVCFMT_LEFT, 50);
    }  // Add the columns to the list control

    // Set-up the dialog based on the real values...
    FillList();
    OnUpdate();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CBarfDialog::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnClose
//
//  Routine Description:
//      Handler method for the WM_CLOSE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::OnClose(void)
{
    CDialog::OnClose();
    DestroyWindow();

}  //*** CBarfDialog::OnClose()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnCancel
//
//  Routine Description:
//      Handler method for the WM_COMMAND message when IDCANCEL is sent.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::OnCancel(void)
{
    CDialog::OnCancel();
    DestroyWindow();

}  //*** CBarfDialog::OnCancel()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::PostNcDestroy
//
//  Routine Description:
//      Processing after non-client has been destroyed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::PostNcDestroy(void)
{
    CDialog::PostNcDestroy();
    delete this;
    CBarf::ClearPostUpdateFn();
    s_pdlg = NULL;

}  //*** CBarfDialog::PostNcDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::FillList
//
//  Routine Description:
//      Loads the list of failure categories.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::FillList(void)
{
    int             ili;
    int             iliReturn;
    CString         str;
    CBarf *         pbarf   = CBarf::s_pbarfFirst;
    CBarfSuspend    bs;

    m_lcCategories.DeleteAllItems();

    for (ili = 0 ; pbarf != NULL ; ili++)
    {
        // Insert the item.
        iliReturn = m_lcCategories.InsertItem(ili, pbarf->PszName());
        ASSERT(iliReturn != -1);

        // Set the current count.
        str.Format(_T("%d"), pbarf->NCurrent());
        VERIFY(m_lcCategories.SetItemText(iliReturn, 1, str));

        // Set the failure point.
        str.Format(_T("%d"), pbarf->NFail());
        VERIFY(m_lcCategories.SetItemText(iliReturn, 2, str));

        // Set the pointer in the entry so we can retrieve it later.
        VERIFY(m_lcCategories.SetItemData(iliReturn, (DWORD) pbarf));

        // Advance to the next entry
        pbarf = pbarf->m_pbarfNext;
    }  // while:  more BARF entries

    // If no known selection yet, get the current selection.
    if (m_pbarfSelected == NULL)
    {
        ili = m_lcCategories.GetNextItem(-1, LVNI_SELECTED);
        if (ili == -1)
            ili = 0;
        m_pbarfSelected = (CBarf *) m_lcCategories.GetItemData(ili);
        if (m_pbarfSelected != NULL)
            OnUpdate();
    }  // if:  no know selection

    // Select the proper item.
    {
        LV_FINDINFO lvfi = { LVFI_PARAM, NULL, (DWORD) m_pbarfSelected };

        ili = m_lcCategories.FindItem(&lvfi);
        if (ili != -1)
            m_lcCategories.SetItemState(ili, LVIS_SELECTED, LVIS_SELECTED);
    }  // Select the proper item

}  //*** CBarfDialog::FillList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnUpdate
//
//  Routine Description:
//      Updates the displayed counts to their TRUE values.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::OnUpdate(void)
{
    Trace(g_tagBarfDialog, _T("Updating the counts."));

    ASSERT(m_pbarfSelected != NULL);

    m_bContinuous = m_pbarfSelected->BContinuous();
    m_bDisable = m_pbarfSelected->BDisabled();
    m_nFailAt = m_pbarfSelected->NFail();
    
    m_bGlobalEnable = CBarf::s_bGlobalEnable;

    UpdateData(FALSE /*bSaveAndValidate*/);

}  //*** CBarfDialog::OnUpdate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnGlobalEnable
//
//  Routine Description:
//      Handler function for the BN_CLICKED message on the Global Enable
//      checkbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::OnGlobalEnable(void)
{
    ASSERT(m_ckbGlobalEnable.m_hWnd != NULL);
    CBarf::s_bGlobalEnable = m_ckbGlobalEnable.GetCheck() == BST_CHECKED;

}  //*** CBarfDialog::OnGlobalEnable()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnResetCurrentCount
//
//  Routine Description:
//      Handler function for the BN_CLICKED message on the Reset Current
//      Count button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::OnResetCurrentCount(void)
{
    int         ili;
    CBarf *     pbarf;

    ASSERT(m_lcCategories.m_hWnd != NULL);

    // Get the selected item.
    ili = m_lcCategories.GetNextItem(-1, LVIS_SELECTED);
    ASSERT(ili != -1);
    pbarf = (CBarf *) m_lcCategories.GetItemData(ili);
    ASSERT(pbarf != NULL);
    ASSERT(pbarf == m_pbarfSelected);

    // Reset the count.
    pbarf->m_nCurrent = 0;

    OnStatusChange();

}  //*** CBarfDialog::OnResetCurrentCount()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnResetAllCounts
//
//  Routine Description:
//      Handler function for the BN_CLICKED message on the Reset All
//      Counts button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::OnResetAllCounts(void)
{
    CBarf *     pbarf = CBarf::s_pbarfFirst;

    Trace(g_tagBarfDialog, _T("Resetting ALL current counts."));

    while (pbarf != NULL)
    {
        pbarf->m_nCurrent = 0;
        pbarf = pbarf->m_pbarfNext;
    }  // while:  more BARF entries

    FillList();

}  //*** CBarfDialog::OnResetAllCounts()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnResetAllCounts
//
//  Routine Description:
//      Handler function for the LVN_ITEMCHANGED message from the list control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::OnItemChanged(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW * pNMListView = (NM_LISTVIEW *) pNMHDR;

    // If the item just became unselected or selected, change the checkboxes to match.
    if ((pNMListView->uChanged & LVIF_STATE)
            && ((pNMListView->uOldState & LVIS_SELECTED)
                || (pNMListView->uNewState & LVIS_SELECTED)))
    {
        // Handle a selection change.
        m_pbarfSelected = (CBarf *) pNMListView->lParam;
        OnStatusChange();
    }  // if:  item received the focus

    *pResult = 0;

}  //*** CBarfDialog::OnItemChanged()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnStatusChange
//
//  Routine Description:
//      Adjusts the C== object when the status of the currently selected
//      item changes.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::OnStatusChange(void)
{
    ASSERT(m_pbarfSelected != NULL);

    UpdateData(TRUE /*bSaveAndValidate*/);

    m_pbarfSelected->m_bContinuous = m_bContinuous;
    m_pbarfSelected->m_bDisabled = m_bDisable;
    m_pbarfSelected->m_nFail = m_nFailAt;

    UpdateData(FALSE /*bSaveAndValidate*/);

}  //*** CBarfDialog::OnStatusChange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnBarfUpdate
//
//  Routine Description:
//      Handler for the WM_USER message.
//      Processes barf notifications.
//
//  Arguments:
//      wparam      1st parameter.
//      lparam      2nd parameter.
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBarfDialog::OnBarfUpdate(WPARAM wparam, LPARAM lparam)
{
    OnUpdate();
    return 0;

}  //*** CBarfDialog::OnBarfUpdate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::PostUpdate
//
//  Routine Description:
//      Static function so that CBarf::BFail can post updates to us.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::PostUpdate(void)
{
    // If this function gets called, there should be BARF dialog.
    ASSERT(Pdlg() != NULL);

    if (Pdlg() != NULL)
        ::PostMessage(Pdlg()->m_hWnd, WM_USER+5, NULL, NULL);

}  //*** CBarfDialog::PostUpdate()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CBarfAllDialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CBarfAllDialog, CDialog)
    //{{AFX_MSG_MAP(CBarfAllDialog)
    ON_BN_CLICKED(IDC_BAS_MENU_ITEM, OnMenuItem)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfAllDialog::CBarfAllDialog
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pParentWnd      [IN OUT] Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBarfAllDialog::CBarfAllDialog(
    IN OUT CWnd * pParentWnd //=NULL
    )
    : CDialog(IDD, pParentWnd)
{
    //{{AFX_DATA_INIT(CBarfAllDialog)
    //}}AFX_DATA_INIT

    m_hwndBarf = NULL;
    m_wmBarf = 0;
    m_wparamBarf = 0;
    m_lparamBarf = 0;

}  //*** CBarfAllDialog::CBarfAllDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfAllDialog::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfAllDialog::DoDataExchange(CDataExchange * pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CBarfAllDialog)
    DDX_Control(pDX, IDC_BAS_LPARAM, m_editLparam);
    DDX_Control(pDX, IDC_BAS_WPARAM, m_editWparam);
    DDX_Control(pDX, IDC_BAS_WM, m_editWm);
    DDX_Control(pDX, IDC_BAS_HWND, m_editHwnd);
    //}}AFX_DATA_MAP
    DDX_Text(pDX, IDC_BAS_HWND, (DWORD &) m_hwndBarf);
    DDX_Text(pDX, IDC_BAS_WM, m_wmBarf);
    DDX_Text(pDX, IDC_BAS_WPARAM, m_wparamBarf);
    DDX_Text(pDX, IDC_BAS_LPARAM, m_lparamBarf);

}  //*** CBarfAllDialog::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfAllDialog::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBarfAllDialog::OnInitDialog(void)
{
    // Call the base class.
    CDialog::OnInitDialog();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CBarfAllDialog::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfAllDialog::OnOK
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the OK button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfAllDialog::OnOK(void)
{
    if (m_hwndBarf == NULL)
        m_hwndBarf = AfxGetMainWnd()->m_hWnd;

    CDialog::OnOK();

}  //*** CBarfAllDialog::OnDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfAllDialog::OnMenuItem
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Menu Item button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfAllDialog::OnMenuItem(void)
{
    m_editHwnd.SetWindowText(_T("0"));
    m_editWm.SetWindowText(_T("273")); // WM_COMMAND
    m_editLparam.SetWindowText(_T("0"));
    m_editWparam.SetWindowText(_T("0"));

}  //*** CBarfAllDialog::OnMenuItem()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  BarfAll
//
//  Routine Description:
//      Exercises all possible single failures.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void BarfAll(void)
{
    CBarf *         pbarf;
    CBarfAllDialog  dlg(AfxGetMainWnd());
    ID              id;
    CString         str;

    // First, pick-up the message to test.

    id = dlg.DoModal();

    if (id != IDOK)
    {
        Trace(g_tagAlways, _T("BarfAll() -  operation cancelled."));
        return;
    }  // if:  BarfAll cancelled

    Trace(g_tagAlways,
        _T("BarfAll with hwnd = %#08lX, wm = 0x%4x, wparam = %d, lparam = %d"),
        dlg.HwndBarf(), dlg.WmBarf(), dlg.WparamBarf(), dlg.LparamBarf());

    // Now, find out how many counts of each resource...
    
    pbarf = CBarf::s_pbarfFirst;
    while (pbarf != NULL)
    {
        pbarf->m_nCurrentSave = pbarf->m_nCurrent;
        pbarf->m_nCurrent = 0;
        pbarf->m_nFail = 0;
        pbarf->m_bContinuous = FALSE;
        pbarf->m_bDisabled = FALSE;
        pbarf = pbarf->m_pbarfNext;
    }  // while:  more BARF entries
    if (CBarfDialog::Pdlg())
        CBarfDialog::Pdlg()->OnUpdate();

    str = _T("BarfAll Test pass.");
    Trace(g_tagAlways, str);
    SendMessage(dlg.HwndBarf(), dlg.WmBarf(),
                        dlg.WparamBarf(), dlg.LparamBarf());

    pbarf = CBarf::s_pbarfFirst;
    while (pbarf != NULL)
    {
        pbarf->m_nBarfAll = pbarf->m_nCurrentSave;
        pbarf = pbarf->m_pbarfNext;
    }  // while:  more entries in the list
    MessageBox(dlg.HwndBarf(), str, _T("BARF Status"), MB_OK | MB_ICONEXCLAMATION);

    // Finally, THE big loop...
    
    pbarf = CBarf::s_pbarfFirst;
    while (pbarf != NULL)
    {
        for (pbarf->m_nFail = 1
                ; pbarf->m_nFail <= pbarf->m_nBarfAll
                ; pbarf->m_nFail++)
        {
//          CBarfMemory::Mark();
            pbarf->m_nCurrent = 0;
            if (CBarfDialog::Pdlg())
                CBarfDialog::Pdlg()->OnUpdate();

            str.Format(_T("BarfAll on resource %s, call # %d of %d"),
                        pbarf->m_pszName, pbarf->m_nFail, pbarf->m_nBarfAll);
            Trace(g_tagAlways, str);
            SendMessage(dlg.HwndBarf(), dlg.WmBarf(),
                        dlg.WparamBarf(), dlg.LparamBarf());

//          CBarfMemory::DumpMarked();
//          ValidateMemory();
            str += _T("\nContinue?");
            if (MessageBox(dlg.HwndBarf(), str, _T("BARF: Pass Complete."), MB_YESNO | MB_ICONEXCLAMATION) != IDYES)
                break;
        }  // for:  while the failure count is less than the BARF All count

        pbarf->m_nFail = 0;
        pbarf->m_nCurrent = pbarf->m_nCurrentSave;
        pbarf = pbarf->m_pbarfNext;
    }  // while:  more BARF entries

    if (CBarfDialog::Pdlg())
        CBarfDialog::Pdlg()->OnUpdate();

}  //*** BarfAll()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DoBarfDialog
//
//  Routine Description:
//      Launches the Barf Settings dialog.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DoBarfDialog( void )
{
    if ( CBarf::s_pbarfFirst == NULL )
    {
        AfxMessageBox( _T("No BARF counters defined yet."), MB_OK );
    }  // if:  no counters defined yet
    else if ( CBarfDialog::Pdlg() )
    {
        BringWindowToTop( CBarfDialog::Pdlg()->m_hWnd );
        if ( IsIconic( CBarfDialog::Pdlg()->m_hWnd ) )
        {
            SendMessage( CBarfDialog::Pdlg()->m_hWnd, WM_SYSCOMMAND, SC_RESTORE,  NULL );
        } // if: window is currently minimized
    }  // if:  there is already a dialog up
    else
    {
        CBarfDialog *   pdlg = NULL;

        try
        {
            pdlg = new CBarfDialog;
            if ( pdlg == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the dialog
            pdlg->Create( AfxGetMainWnd() );
        }  // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
    }  // else:  no dialog up yet

}  //*** DoBarfDialog()

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\barf.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		Barf.cpp
//
//	Abstract:
//		Implementation of the Basic Artifical Resource Failure classes.
//
//	Author:
//		David Potter (davidp)	April 11, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#define _NO_BARF_DEFINITIONS_

#include "Barf.h"
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef	_USING_BARF_
 #error BARF failures should be disabled!
#endif

#ifdef _DEBUG	// The entire file!

#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

BOOL		g_bFailOnNextBarf	= FALSE;

CTraceTag	g_tagBarf(_T("Debug"), _T("BARF Failures"), CTraceTag::tfDebug);


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CBarf
/////////////////////////////////////////////////////////////////////////////

BOOL				CBarf::s_bGlobalEnable	= TRUE;
LONG				CBarf::s_nSuspend		= 0;
CBarf *				CBarf::s_pbarfFirst		= NULL;
PFNBARFPOSTUPDATE	CBarf::s_pfnPostUpdate	= NULL;
PVOID				CBarf::s_pvSpecialMem	= NULL;


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBarf::CBarf
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pszName			[IN] Name of the set of APIs to BARF.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBarf::CBarf(IN LPCTSTR pszName)
{
	ASSERT(pszName != NULL);

	m_pszName = pszName;

	m_bDisabled = FALSE;
	m_bContinuous = FALSE;
	m_nFail = 0;
	m_nCurrent = 0;

	m_pbarfNext = s_pbarfFirst;
	s_pbarfFirst = this;

}  //*** CBarf::CBarf()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBarf::Init
//
//	Routine Description:
//		Initializes the BARF counters instance by giving it its name and
//		giving it a startup value (from the registry if possible).
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarf::Init(void)
{
	CString		strSection;
	CString		strValue;

	strSection.Format(BARF_REG_SECTION_FMT, m_pszName);

	m_bDisabled = AfxGetApp()->GetProfileInt(strSection, _T("Disabled"), FALSE);
	m_bContinuous = AfxGetApp()->GetProfileInt(strSection, _T("Continuous"), FALSE);
	m_nFail = AfxGetApp()->GetProfileInt(strSection, _T("Fail"), 0);

}  //*** CBarf::Init()

/////////////////////////////////////////////////////////////////////////////
//
//	CBarf::BFail
//
//	Routine Description:
//		Determines if the next call should artificially fail.
//		Typical usage of this method is:
//			BOOL BARFFoo( void )
//			{
//				if (barfMyApi.BFail())
//					return FALSE;
//				else
//					return Foo();
//			}
//
//	Return value:
//		bFail	TRUE indicates the call should be made to
//				artificially fail.
//
/////////////////////////////////////////////////////////////////////////////
BOOL CBarf::BFail(void)
{
	BOOL	bFail	= FALSE;

	// If BARF is suspended, don't artificially fail.
	// Otherwise, check the counters.
	if (s_nSuspend == 0)
	{
		// Increment the call count.
		m_nCurrent++;

		// Call the post-update routine to allow UI to be updated.
		if (PfnPostUpdate())
			((*PfnPostUpdate())());

		// If not disable and not globally disabled, keep checking.
		if (!m_bDisabled && s_bGlobalEnable)
		{
			// If in continuous fail mode, check to see if the counters
			// are above the specified range.  Otherwise check to see if
			// the counter is exactly the same as what was specified.
			if (m_bContinuous)
			{
				if (m_nCurrent >= m_nFail)
					bFail = TRUE;
			}  // if:  in continuous fail mode
			else
			{
				if (m_nCurrent == m_nFail)
					bFail = TRUE;
			}  // else:  not in continuous fail mode

			// If this API set was marked to fail on the next (this) call,
			// fail the call and reset the marker.
			if (g_bFailOnNextBarf)
			{
				bFail = TRUE;
				g_bFailOnNextBarf = FALSE;
			}  // if:  counters marked to fail on next (this) call
		}  // if:  not disabled and globally enabled
	}  // if:  not suspended

	return bFail;
	
}  //*** CBarf::BFail()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CBarfSuspend
/////////////////////////////////////////////////////////////////////////////

CRITICAL_SECTION	CBarfSuspend::s_critsec;
BOOL				CBarfSuspend::s_bCritSecValid = FALSE;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBarfSuspend::CBarfSuspend
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBarfSuspend::CBarfSuspend(void)
{
	if (BCritSecValid())
		EnterCriticalSection(Pcritsec());

	CBarf::s_nSuspend++;

	if (BCritSecValid())
		LeaveCriticalSection(Pcritsec());

}  //*** CBarfSuspend::CBarfSuspend()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBarfSuspend::~CBarfSuspend
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBarfSuspend::~CBarfSuspend(void)
{
	if (BCritSecValid())
		EnterCriticalSection(Pcritsec());

	CBarf::s_nSuspend--;
	ASSERT(CBarf::s_nSuspend >= 0);

	if (BCritSecValid())
		LeaveCriticalSection(Pcritsec());

}  //*** CBarfSuspend::~CBarfSuspend()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBarfSuspend::Init
//
//	Routine Description:
//		Initialize the class.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfSuspend::Init(void)
{
	InitializeCriticalSection(Pcritsec());
	s_bCritSecValid = TRUE;

}  //*** CBarfSuspend::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBarfSuspend::Cleanup
//
//	Routine Description:
//		Initialize the class.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfSuspend::Cleanup(void)
{
	if (BCritSecValid())
	{
		DeleteCriticalSection(Pcritsec());
		s_bCritSecValid = FALSE;
	}  // if:  critical section is valid

}  //*** CBarfSuspend::Cleanup()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	InitBarf
//
//	Routine Description:
//		Initializes all BARF counters in the BARF list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void InitBarf(void)
{
	CBarf *	pbarf;

	// Loop through the BARF counter list.
	for (pbarf = CBarf::s_pbarfFirst ; pbarf != NULL ; pbarf = pbarf->m_pbarfNext)
		pbarf->Init();

	CBarfSuspend::Init();

}  //*** InitBarf()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CleanupBarf
//
//	Routine Description:
//		Cleanup after BARF.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CleanupBarf(void)
{
	CBarfSuspend::Cleanup();

}  //*** CleanupBarf()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	EnableBarf
//
//	Routine Description:
//		Allows user code to enable/disable BARF for sections of code.
//
//	Arguments:
//		bEnable		[IN] TRUE = enable BARF, FALSE = disable BARF.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void EnableBarf(IN BOOL bEnable)
{
	if (bEnable)
		Trace(g_tagBarf, _T("Artificial Failures enabled"));
	else
		Trace(g_tagBarf, _T("Artificial Failures disabled"));

	CBarf::s_bGlobalEnable = bEnable;

}  //*** EnableBarf()

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\basecmdt.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BaseCmdT.cpp
//
//	Abstract:
//		Implementation of the CBaseCmdTarget class.
//
//	Author:
//		David Potter (davidp)	December 11, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BaseCmdT.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CBaseCmdTarget
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBaseCmdTarget, CCmdTarget)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CBaseCmdTarget, CCmdTarget)
	//{{AFX_MSG_MAP(CBaseCmdTarget)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\barfdlg.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BarfDlg.h
//
//	Abstract:
//		Definition of the Basic Artifical Resource Failure dialog classes.
//
//	Implementation File:
//		BarfDlg.cpp
//
//	Author:
//		David Potter (davidp)	April 11, 1997
//
//	Revision History:
//
//	Notes:
//		This file compiles only in _DEBUG mode.
//
//		To implement a new BARF type, declare a global instance of CBarf:
//			CBarf g_barfMyApi(_T("My API"));
//
//		To bring up the BARF dialog:
//			DoBarfDialog();
//		This brings up a modeless dialog with the BARF settings.
//
//		A few functions are provided for special circumstances.
//		Usage of these should be fairly limited:
//			BarfAll(void);		Top Secret -> NYI.
//			EnableBarf(BOOL);	Allows you to disable/reenable BARF.
//			FailOnNextBarf;		Force the next failable call to fail.
//
//		NOTE:	Your code calls the standard APIs (e.g. LoadIcon) and the
//				BARF files do the rest.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BARFDLG_H_
#define _BARFDLG_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBarfDialog;
class CBarfAllDialog;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBarf;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//	class CBarfDialog
//
//	Purpose:
//		Implements the BARF Settings dialog
//
//	Usage:
//		Use the constructor, then Create().
//		Update() is called by CBarf::BFail() to indicate
//		one of the current counts has changed.
//
/////////////////////////////////////////////////////////////////////////////
#ifdef	_DEBUG

class CBarfDialog : public CDialog
{
// Construction
public:
	CBarfDialog(void);
	BOOL Create(CWnd * pParentWnd = NULL);

// Dialog Data
	//{{AFX_DATA(CBarfDialog)
	enum { IDD = IDD_BARF_SETTINGS };
	CButton	m_ckbGlobalEnable;
	CButton	m_ckbDisable;
	CButton	m_ckbContinuous;
	CListCtrl	m_lcCategories;
	DWORD	m_nFailAt;
	BOOL	m_bContinuous;
	BOOL	m_bDisable;
	BOOL	m_bGlobalEnable;
	//}}AFX_DATA
//	CButton	m_ckbGlobalEnable;
//	CButton	m_ckbDisable;
//	CButton	m_ckbContinuous;
//	CListCtrl	m_lcCategories;
//	DWORD	m_nFailAt;
//	BOOL	m_bContinuous;
//	BOOL	m_bDisable;
//	BOOL	m_bGlobalEnable;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBarfDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void PostNcDestroy();
	//}}AFX_VIRTUAL

// Implementation
protected:

private:
	static	CBarfDialog *	s_pdlg;
	static	HICON			s_hicon;

protected:
	CBarf *				m_pbarfSelected;

	// Generated message map functions
	//{{AFX_MSG(CBarfDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnResetCurrentCount();
	afx_msg void OnResetAllCounts();
	afx_msg void OnGlobalEnable();
	afx_msg void OnItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnStatusChange();
	afx_msg void OnClose();
	//}}AFX_MSG
	virtual void OnCancel();
	afx_msg LRESULT OnBarfUpdate(WPARAM wparam, LPARAM lparam);
	DECLARE_MESSAGE_MAP()

//	virtual	LRESULT		LDlgProc(UINT, WPARAM, LPARAM);

//	void				GetSelection(void);
//	void				OnGlobalEnable(void);
//	void				OnResetAllCounts(void);
//	void				OnSelectionChange(void);
//	void				OnStatusChange(IN BOOL bReset);

//	void				FormatBarfString(CBarf *, CString * pstr);
	void				FillList(void);

	static	void		PostUpdate(void);

public:
	static CBarfDialog *	Pdlg()	{ return s_pdlg; }
	void					OnUpdate(void);

};  //*** class CBarfDialog

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
//
//	class CBarfAllDialog
//
//	Purpose:
//		Implements the Barf Everything dialog.
//
//	Usage:
//		Similar to most Modal dialogs: Construct, then do dlg.DoModal()
//		In addition, the methods Hwnd(), Wm(), Wparam() and Lparam()
//		can be called when the dialog is dismissed (only if DoModal()
//		returns IDOK).
//
/////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG

class CBarfAllDialog : public CDialog
{
// Construction
public:
	CBarfAllDialog(IN OUT CWnd * pParent);

protected:
// Dialog Data
	//{{AFX_DATA(CBarfAllDialog)
	enum { IDD = IDD_BARF_ALL_SETTINGS };
	CEdit	m_editLparam;
	CEdit	m_editWparam;
	CEdit	m_editWm;
	CEdit	m_editHwnd;
	//}}AFX_DATA
	HWND		m_hwndBarf;
	UINT		m_wmBarf;
	WPARAM		m_wparamBarf;
	LPARAM		m_lparamBarf;

public:
	HWND		HwndBarf(void)		{ return m_hwndBarf; }
	UINT		WmBarf(void)		{ return m_wmBarf; }
	WPARAM		WparamBarf(void)	{ return m_wparamBarf; }
	LPARAM		LparamBarf(void)	{ return m_lparamBarf; }


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBarfAllDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CBarfAllDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnMenuItem();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

//	virtual	void		OnButton(ID id);
//	virtual	void		OnOK(void);

};  //*** class CBarfAllDialog

#endif  // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Global Functions and Data
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

 void DoBarfDialog(void);
 void BarfAll(void);

#else

 inline void DoBarfDialog(void)	{ }
 inline void BarfAll(void)		{ }

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////

#endif // _BARFDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\barfclus.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BarfClus.cpp
//
//	Abstract:
//		Implementation of the Basic Artifical Resource Failure entry points
//		for CLUSAPI functions.
//
//	Author:
//		David Potter (davidp)	April 14, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#define _NO_BARF_DEFINITIONS_

#include "Barf.h"
#include "BarfClus.h"
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef	_USING_BARF_
 #error BARF failures should be disabled!
#endif

#ifdef _DEBUG	// The entire file!

#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

CBarf	g_barfClusApi(_T("CLUSAPI Calls"));

/////////////////////////////////////////////////////////////////////////////
// Cluster Management Functions
/////////////////////////////////////////////////////////////////////////////

BOOL BARFCloseCluster(HCLUSTER hCluster)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CloseCluster()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return FALSE;
	}  // if:  BARF failure
	else
		return CloseCluster(hCluster);

}  //*** BARFCloseCluster()

BOOL BARFCloseClusterNotifyPort(HCHANGE hChange)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CloseClusterNotifyPort()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return FALSE;
	}  // if:  BARF failure
	else
		return CloseClusterNotifyPort(hChange);

}  //*** BARFCloseClusterNotifyPort()

DWORD BARFClusterCloseEnum(HCLUSENUM hClusEnum)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterCloseEnum()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterCloseEnum(hClusEnum);

}  //*** BARFClusterCloseEnum()

DWORD BARFClusterEnum(
	HCLUSENUM hClusEnum,
	DWORD dwIndex,
	LPDWORD lpdwType,
	LPWSTR lpszName,
	LPDWORD lpcchName
	)
{
//	if (g_barfClusApi.BFail())
//	{
//		Trace(g_tagBarf, _T("ClusterEnum()"));
//		return ERROR_INVALID_FUNCTION;
//	}  // if:  BARF failure
//	else
		return ClusterEnum(hClusEnum, dwIndex, lpdwType, lpszName, lpcchName);

}  //*** BARFClusterEnum()

HCLUSENUM BARFClusterOpenEnum(HCLUSTER hCluster, DWORD dwType)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterOpenEnum()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return ClusterOpenEnum(hCluster, dwType);

}  //*** BARFClusterOpenEnum()

DWORD BARFClusterResourceTypeControl(
	HCLUSTER hCluster,
	LPCWSTR lpszResourceTypeName,
	HNODE hHostNode,
	DWORD dwControlCode,
	LPVOID lpInBuffer,
	DWORD nInBufferSize,
	LPVOID lpOutBuffer,
	DWORD nOutBufferSize,
	LPDWORD lpBytesReturned
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterResourceTypeControl()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterResourceTypeControl(
					hCluster,
					lpszResourceTypeName,
					hHostNode,
					dwControlCode,
					lpInBuffer,
					nInBufferSize,
					lpOutBuffer,
					nOutBufferSize,
					lpBytesReturned
					);

}  //*** BARFClusterResourceTypeControl()

HCHANGE BARFCreateClusterNotifyPort(
	HCHANGE hChange,
	HCLUSTER hCluster,
	DWORD dwFilter,
	DWORD_PTR dwNotifyKey
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CreateClusterNotifyPort()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return CreateClusterNotifyPort(
					hChange,
					hCluster,
					dwFilter,
					dwNotifyKey
					);

}  //*** BARFCreateClusterNotifyPort()

DWORD BARFCreateClusterResourceType(
	HCLUSTER hCluster,
	LPCWSTR lpszResourceTypeName,
	LPCWSTR lpszDisplayName,
	LPCWSTR lpszResourceTypeDll,
	DWORD dwLooksAlivePollInterval,
	DWORD dwIsAlivePollInterval
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CreateClusterResourceType()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return CreateClusterResourceType(
					hCluster,
					lpszResourceTypeName,
					lpszDisplayName,
					lpszDisplayName,
					dwLooksAlivePollInterval,
					dwIsAlivePollInterval
					);

}  //*** BARFCreateClusterResourceType()

DWORD BARFDeleteClusterResourceType(HCLUSTER hCluster, LPCWSTR lpszResourceTypeName)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("DeleteClusterResourceType()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return DeleteClusterResourceType(
					hCluster,
					lpszResourceTypeName
					);

}  //*** BARFDeleteClusterResourceType()

DWORD BARFGetClusterInformation(
	HCLUSTER hCluster,
	LPWSTR lpszClusterName,
	LPDWORD lpcchClusterName,
	LPCLUSTERVERSIONINFO lpClusterInfo
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterInformation()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return GetClusterInformation(
					hCluster,
					lpszClusterName,
					lpcchClusterName,
					lpClusterInfo
					);

}  //*** BARFGetClusterInformation()

DWORD BARFGetClusterNotify(
	HCHANGE hChange,
	DWORD_PTR *lpdwNotifyKey,
	LPDWORD lpdwFilterType,
	LPWSTR lpszName,
	LPDWORD lpcchName,
	DWORD dwMilliseconds
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterNotify()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return GetClusterNotify(
					hChange,
					lpdwNotifyKey,
					lpdwFilterType,
					lpszName,
					lpcchName,
					dwMilliseconds
					);

}  //*** BARFGetClusterNotify()

DWORD BARFGetClusterQuorumResource(
	HCLUSTER hCluster,
	LPWSTR lpszResourceName,
	LPDWORD lpcbResourceName,
	LPWSTR lpszDeviceName,
	LPDWORD lpcbDeviceName,
	LPDWORD lpdwMaxQuorumLogSize
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterQuorumResource()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return GetClusterQuorumResource(
					hCluster,
					lpszResourceName,
					lpcbResourceName,
					lpszDeviceName,
					lpcbDeviceName,
					lpdwMaxQuorumLogSize
					);

}  //*** BARFGetClusterQuorumResource()

HCLUSTER BARFOpenCluster(LPCWSTR lpszClusterName)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OpenCluster()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return OpenCluster(lpszClusterName);

}  //*** BARFOpenCluster()

DWORD BARFRegisterClusterNotify(
	HCHANGE hChange,
	DWORD dwFilter,
	HANDLE hObject,
	DWORD_PTR dwNotifyKey
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("RegisterClusterNotify()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return RegisterClusterNotify(
						hChange,
						dwFilter,
						hObject,
						dwNotifyKey
						);

}  //*** BARFRegisterClusterNotify()

DWORD BARFSetClusterName(HCLUSTER hCluster, LPCWSTR lpszNewClusterName)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("SetClusterName()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return SetClusterName(hCluster, lpszNewClusterName);

}  //*** BARFSetClusterName()

DWORD BARFSetClusterQuorumResource(
	HRESOURCE hResource,
	LPCWSTR lpszDeviceName,
	DWORD dwMaxQuoLogSize
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("SetClusterQuorumResource()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return SetClusterQuorumResource(
						hResource,
						lpszDeviceName,
						dwMaxQuoLogSize
						);

}  //*** BARFSetClusterQuorumResource()

/////////////////////////////////////////////////////////////////////////////
// Node Management Functions
/////////////////////////////////////////////////////////////////////////////

BOOL BARFCloseClusterNode(HNODE hNode)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CloseClusterNode()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return FALSE;
	}  // if:  BARF failure
	else
		return CloseClusterNode(hNode);

}  //*** BARFCloseClusterNode()

DWORD BARFClusterNodeControl(
	HNODE hNode,
	HNODE hHostNode,
	DWORD dwControlCode,
	LPVOID lpInBuffer,
	DWORD nInBufferSize,
	LPVOID lpOutBuffer,
	DWORD nOutBufferSize,
	LPDWORD lpBytesReturned
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterNodeControl()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterNodeControl(
						hNode,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						nInBufferSize,
						lpOutBuffer,
						nOutBufferSize,
						lpBytesReturned
						);

}  //*** BARFClusterNodeControl()

DWORD BARFEvictClusterNode(HNODE hNode)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("EvictClusterNode()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return EvictClusterNode(hNode);

}  //*** BARFEvictClusterNode()

DWORD BARFGetClusterNodeId(HNODE hNode, LPWSTR lpszNodeId, LPDWORD lpcchNodeId)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterNodeId()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return GetClusterNodeId(hNode, lpszNodeId, lpcchNodeId);

}  //*** BARFGetClusterNodeId()

CLUSTER_NODE_STATE BARFGetClusterNodeState(HNODE hNode)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterNodeState()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return ClusterNodeStateUnknown;
	}  // if:  BARF failure
	else
		return GetClusterNodeState(hNode);

}  //*** BARFGetClusterNodeState()

HNODE BARFOpenClusterNode(HCLUSTER hCluster, LPCWSTR lpszNodeName)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OpenClusterNode()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return OpenClusterNode(hCluster, lpszNodeName);

}  //*** BARFOpenClusterNode()

DWORD BARFPauseClusterNode(HNODE hNode)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("PauseClusterNode()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return PauseClusterNode(hNode);

}  //*** BARFPauseClusterNode()

DWORD BARFResumeClusterNode(HNODE hNode)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ResumeClusterNode()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ResumeClusterNode(hNode);

}  //*** BARFResumeClusterNode()

/////////////////////////////////////////////////////////////////////////////
// Group Management Functions
/////////////////////////////////////////////////////////////////////////////

BOOL BARFCloseClusterGroup(HGROUP hGroup)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CloseClusterGroup()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return FALSE;
	}  // if:  BARF failure
	else
		return CloseClusterGroup(hGroup);

}  //*** BARFCloseClusterGroup()

DWORD BARFClusterGroupCloseEnum(HGROUPENUM hGroupEnum)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterGroupCloseEnum()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterGroupCloseEnum(hGroupEnum);

}  //*** BARFClusterGroupCloseEnum()

DWORD BARFClusterGroupControl(
	HGROUP hGroup,
	HNODE hHostNode,
	DWORD dwControlCode,
	LPVOID lpInBuffer,
	DWORD nInBufferSize,
	LPVOID lpOutBuffer,
	DWORD nOutBufferSize,
	LPDWORD lpBytesReturned
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterGroupControl()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterGroupControl(
						hGroup,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						nInBufferSize,
						lpOutBuffer,
						nOutBufferSize,
						lpBytesReturned
						);

}  //*** BARFClusterGroupControl()

DWORD BARFClusterGroupEnum(
	HGROUPENUM hGroupEnum,
	DWORD dwIndex,
	LPDWORD lpdwType,
	LPWSTR lpszResourceName,
	LPDWORD lpcchName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterGroupEnum()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterGroupEnum(
						hGroupEnum,
						dwIndex,
						lpdwType,
						lpszResourceName,
						lpcchName
						);

}  //*** BARFClusterGroupEnum()

HGROUPENUM BARFClusterGroupOpenEnum(HGROUP hGroup, DWORD dwType)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterGroupOpenEnum()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return ClusterGroupOpenEnum(hGroup, dwType);

}  //*** BARFClusterGroupOpenEnum()

HGROUP BARFCreateClusterGroup(HCLUSTER hCluster, LPCWSTR lpszGroupName)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CreateClusterGroup()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return CreateClusterGroup(hCluster, lpszGroupName);

}  //*** BARFCreateClusterGroup()

DWORD BARFDeleteClusterGroup(HGROUP hGroup)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("DeleteClusterGroup()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return DeleteClusterGroup(hGroup);

}  //*** BARFDeleteClusterGroup()

CLUSTER_GROUP_STATE BARFGetClusterGroupState(
	HGROUP hGroup,
	LPWSTR lpszNodeName,
	LPDWORD lpcchNodeName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterGroupState()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return ClusterGroupStateUnknown;
	}  // if:  BARF failure
	else
		return GetClusterGroupState(
						hGroup,
						lpszNodeName,
						lpcchNodeName
						);

}  //*** BARFGetClusterGroupState()

DWORD BARFMoveClusterGroup(HGROUP hGroup, HNODE hDestinationNode)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("MoveClusterGroup()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return MoveClusterGroup(hGroup, hDestinationNode);

}  //*** BARFMoveClusterGroup()

DWORD BARFOfflineClusterGroup(HGROUP hGroup)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OfflineClusterGroup()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return OfflineClusterGroup(hGroup);

}  //*** BARFOfflineClusterGroup()

DWORD BARFOnlineClusterGroup(HGROUP hGroup, HNODE hDestinationNode)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OnlineClusterGroup()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return OnlineClusterGroup(hGroup, hDestinationNode);

}  //*** BARFOnlineClusterGroup()

HGROUP BARFOpenClusterGroup(HCLUSTER hCluster, LPCWSTR lpszGroupName)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OpenClusterGroup()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return OpenClusterGroup(hCluster, lpszGroupName);

}  //*** BARFOpenClusterGroup()

DWORD BARFSetClusterGroupName(HGROUP hGroup, LPCWSTR lpszGroupName)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("SetClusterGroupName()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return SetClusterGroupName(hGroup, lpszGroupName);

}  //*** BARFSetClusterGroupName()

DWORD BARFSetClusterGroupNodeList(
	HGROUP hGroup,
	DWORD cNodeCount,
	HNODE phNodeList[]
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("SetClusterGroupNodeList()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return SetClusterGroupNodeList(
						hGroup,
						cNodeCount,
						phNodeList
						);

}  //*** BARFSetClusterGroupNodeList()

/////////////////////////////////////////////////////////////////////////////
// Resource Management Functions
/////////////////////////////////////////////////////////////////////////////

DWORD BARFAddClusterResourceDependency(HRESOURCE hResource, HRESOURCE hDependsOn)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("AddClusterResourceDependency()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return AddClusterResourceDependency(hResource, hDependsOn);

}  //*** BARFAddClusterResourceDependency()

DWORD BARFAddClusterResourceNode(HRESOURCE hResource, HNODE hNode)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("AddClusterResourceNode()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return AddClusterResourceNode(hResource, hNode);

}  //*** BARFAddClusterResourceNode()

BOOL BARFCanResourceBeDependent(HRESOURCE hResource, HRESOURCE hResourceDependent)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CanResourceBeDependent()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return FALSE;
	}  // if:  BARF failure
	else
		return CanResourceBeDependent(hResource, hResourceDependent);

}  //*** BARFCanResourceBeDependent()

DWORD BARFChangeClusterResourceGroup(HRESOURCE hResource, HGROUP hGroup)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ChangeClusterResourceGroup()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ChangeClusterResourceGroup(hResource, hGroup);

}  //*** BARFChangeClusterResourceGroup()

BOOL BARFCloseClusterResource(HRESOURCE hResource)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CloseClusterResource()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return FALSE;
	}  // if:  BARF failure
	else
		return CloseClusterResource(hResource);

}  //*** BARFCloseClusterResource()

DWORD BARFClusterResourceCloseEnum(HRESENUM hResEnum)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterResourceCloseEnum()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterResourceCloseEnum(hResEnum);

}  //*** BARFClusterResourceCloseEnum()

DWORD BARFClusterResourceControl(
	HRESOURCE hResource,
	HNODE hHostNode,
	DWORD dwControlCode,
	LPVOID lpInBuffer,
	DWORD nInBufferSize,
	LPVOID lpOutBuffer,
	DWORD nOutBufferSize,
	LPDWORD lpBytesReturned
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterResourceControl()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterResourceControl(
						hResource,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						nInBufferSize,
						lpOutBuffer,
						nOutBufferSize,
						lpBytesReturned
						);

}  //*** BARFClusterResourceControl()

DWORD BARFClusterResourceEnum(
	HRESENUM hResEnum,
	DWORD dwIndex,
	LPDWORD lpdwType,
	LPWSTR lpszName,
	LPDWORD lpcchName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterResourceEnum()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterResourceEnum(
						hResEnum,
						dwIndex,
						lpdwType,
						lpszName,
						lpcchName
						);

}  //*** BARFClusterResourceEnum()

HRESENUM BARFClusterResourceOpenEnum(HRESOURCE hResource, DWORD dwType)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterResourceOpenEnum()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return ClusterResourceOpenEnum(hResource, dwType);

}  //*** BARFClusterResourceOpenEnum()

HRESOURCE BARFCreateClusterResource(
	HGROUP hGroup,
	LPCWSTR lpszResourceName,
	LPCWSTR lpszResourceType,
	DWORD dwFlags
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CreateClusterResource()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return CreateClusterResource(
						hGroup,
						lpszResourceName,
						lpszResourceType,
						dwFlags
						);

}  //*** BARFCreateClusterResource()

DWORD BARFDeleteClusterResource(HRESOURCE hResource)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("DeleteClusterResource()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return DeleteClusterResource(hResource);

}  //*** BARFDeleteClusterResource()

DWORD BARFFailClusterResource(HRESOURCE hResource)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("FailClusterResource()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return FailClusterResource(hResource);

}  //*** BARFFailClusterResource()

BOOL BARFGetClusterResourceNetworkName(
	HRESOURCE hResource,
	LPWSTR lpBuffer,
	LPDWORD nSize
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterResourceNetworkName()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return GetClusterResourceNetworkName(
						hResource,
						lpBuffer,
						nSize
						);

}  //*** BARFGetClusterResourceNetworkName()

CLUSTER_RESOURCE_STATE BARFGetClusterResourceState(
	HRESOURCE hResource,
	LPWSTR lpszNodeName,
	LPDWORD lpcchNodeName,
	LPWSTR lpszGroupName,
	LPDWORD lpcchGroupName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterResourceNetworkName()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return ClusterResourceStateUnknown;
	}  // if:  BARF failure
	else
		return GetClusterResourceState(
						hResource,
						lpszNodeName,
						lpcchNodeName,
						lpszGroupName,
						lpcchGroupName
						);

}  //*** BARFGetClusterResourceState()

DWORD BARFOfflineClusterResource(HRESOURCE hResource)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OfflineClusterResource()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return OfflineClusterResource(hResource);

}  //*** BARFOfflineClusterResource()

DWORD BARFOnlineClusterResource(HRESOURCE hResource)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OnlineClusterResource()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return OnlineClusterResource(hResource);

}  //*** BARFOnlineClusterResource()

HRESOURCE BARFOpenClusterResource(
	HCLUSTER hCluster,
	LPCWSTR lpszResourceName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OpenClusterResource()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return OpenClusterResource(hCluster, lpszResourceName);

}  //*** BARFOpenClusterResource()

DWORD BARFRemoveClusterResourceNode(
	HRESOURCE hResource,
	HNODE hNode
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("RemoveClusterResourceNode()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return RemoveClusterResourceNode(hResource, hNode);

}  //*** BARFRemoveClusterResourceNode()

DWORD BARFRemoveClusterResourceDependency(
	HRESOURCE hResource,
	HRESOURCE hDependsOn
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("RemoveClusterResourceDependency()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return RemoveClusterResourceDependency(hResource, hDependsOn);

}  //*** BARFRemoveClusterResourceDependency()

DWORD BARFSetClusterResourceName(
	HRESOURCE hResource,
	LPCWSTR lpszResourceName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("SetClusterResourceName()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return SetClusterResourceName(hResource, lpszResourceName);

}  //*** BARFSetClusterResourceName()

/////////////////////////////////////////////////////////////////////////////
// Network Management Functions
/////////////////////////////////////////////////////////////////////////////

HNETWORK BARFOpenClusterNetwork(
	HCLUSTER hCluster,
	LPCWSTR lpszNetworkName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OpenClusterNetwork()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return OpenClusterNetwork(hCluster, lpszNetworkName);

}  //*** BARFOpenClusterNetwork()

BOOL BARFCloseClusterNetwork(HNETWORK hNetwork)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CloseClusterNetwork()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return FALSE;
	}  // if:  BARF failure
	else
		return CloseClusterNetwork(hNetwork);

}  //*** BARFOpenClusterNetwork()

HNETWORKENUM BARFClusterNetworkOpenEnum(
	HNETWORK hNetwork,
	DWORD dwType
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterNetworkOpenEnum()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return ClusterNetworkOpenEnum(hNetwork, dwType);

}  //*** BARFClusterNetworkOpenEnum()

DWORD BARFClusterNetworkEnum(
	HNETWORKENUM hNetworkEnum,
	DWORD dwIndex,
	DWORD * lpdwType,
	LPWSTR lpszName,
	LPDWORD lpcchName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterNetworkEnum()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterNetworkEnum(
						hNetworkEnum,
						dwIndex,
						lpdwType,
						lpszName,
						lpcchName
						);

}  //*** BARFClusterNetworkEnum()

DWORD BARFClusterNetworkCloseEnum(HNETWORKENUM hNetworkEnum)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterNetworkCloseEnum()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterNetworkCloseEnum(hNetworkEnum);

}  //*** BARFClusterNetworkCloseEnum()

CLUSTER_NETWORK_STATE BARFGetClusterNetworkState(HNETWORK hNetwork)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterNetworkState()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return ClusterNetworkStateUnknown;
	}  // if:  BARF failure
	else
		return GetClusterNetworkState(hNetwork);

}  //*** BARFGetClusterNetworkState()

DWORD BARFSetClusterNetworkName(
	HNETWORK hNetwork,
	LPCWSTR lpszName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("SetClusterNetworkName()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return SetClusterNetworkName(hNetwork, lpszName);

}  //*** BARFSetClusterNetworkName()

DWORD BARFClusterNetworkControl(
	HNETWORK hNetwork,
	HNODE hHostNode,
	DWORD dwControlCode,
	LPVOID lpInBuffer,
	DWORD nInBufferSize,
	LPVOID lpOutBuffer,
	DWORD nOutBufferSize,
	LPDWORD lpBytesReturned
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterNetworkControl()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterNetworkControl(
						hNetwork,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						nInBufferSize,
						lpOutBuffer,
						nOutBufferSize,
						lpBytesReturned
						);

}  //*** BARFClusterNetworkControl()

/////////////////////////////////////////////////////////////////////////////
// Network Interface Management Functions
/////////////////////////////////////////////////////////////////////////////

HNETINTERFACE BARFOpenClusterNetInterface(
	HCLUSTER hCluster,
	LPCWSTR lpszInterfaceName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OpenClusterNetInterface()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return OpenClusterNetInterface(hCluster, lpszInterfaceName);

}  //*** BARFOpenClusterNetInterface()

DWORD BARFGetClusterNetInterface(
	HCLUSTER hCluster,
	LPCWSTR lpszNodeName,
	LPCWSTR lpszNetworkName,
	LPWSTR lpszNetInterfaceName,
	DWORD * lpcchNetInterfaceName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterNetInterface()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return GetClusterNetInterface(
							hCluster,
							lpszNodeName,
							lpszNetworkName,
							lpszNetInterfaceName,
							lpcchNetInterfaceName
							);

}  //*** BARFGetClusterNetInterface()

BOOL BARFCloseClusterNetInterface(HNETINTERFACE hNetInterface)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CloseClusterNetInterface()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return FALSE;
	}  // if:  BARF failure
	else
		return CloseClusterNetInterface(hNetInterface);

}  //*** BARFCloseClusterNetInterface()

CLUSTER_NETINTERFACE_STATE BARFGetClusterNetInterfaceState(HNETINTERFACE hNetInterface)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterNetInterfaceState()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return ClusterNetInterfaceStateUnknown;
	}  // if:  BARF failure
	else
		return GetClusterNetInterfaceState(hNetInterface);

}  //*** BARFGetClusterNetInterfaceState()

DWORD BARFClusterNetInterfaceControl(
	HNETINTERFACE hNetInterface,
	HNODE hHostNode,
	DWORD dwControlCode,
	LPVOID lpInBuffer,
	DWORD nInBufferSize,
	LPVOID lpOutBuffer,
	DWORD nOutBufferSize,
	LPDWORD lpBytesReturned
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterNetInterfaceControl()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterNetInterfaceControl(
						hNetInterface,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						nInBufferSize,
						lpOutBuffer,
						nOutBufferSize,
						lpBytesReturned
						);

}  //*** BARFClusterNetInterfaceControl()

/////////////////////////////////////////////////////////////////////////////
// Cluster Database Management Functions
/////////////////////////////////////////////////////////////////////////////

LONG BARFClusterRegCloseKey(HKEY hKey)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegCloseKey()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegCloseKey(hKey);

}  //*** BARFClusterRegCloseKey()

LONG BARFClusterRegCreateKey(
	HKEY hKey,
	LPCWSTR lpszSubKey,
	DWORD dwOptions,
	REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	PHKEY phkResult,
	LPDWORD lpdwDisposition
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegCreateKey()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegCreateKey(
						hKey,
						lpszSubKey,
						dwOptions,
						samDesired,
						lpSecurityAttributes,
						phkResult,
						lpdwDisposition
						);

}  //*** BARFClusterRegCreateKey()

LONG BARFClusterRegDeleteKey(
	HKEY hKey,
	LPCWSTR lpszSubKey
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegDeleteKey()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegDeleteKey(hKey, lpszSubKey);

}  //*** BARFClusterRegDeleteKey()

DWORD BARFClusterRegDeleteValue(
	HKEY hKey,
	LPCWSTR lpszValueName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegDeleteValue()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegDeleteValue(hKey, lpszValueName);

}  //*** BARFClusterRegDeleteValue()

LONG BARFClusterRegEnumKey(
	HKEY hKey,
	DWORD dwIndex,
	LPWSTR lpszName,
	LPDWORD lpcchName,
	PFILETIME lpftLastWriteTime
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegEnumKey()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegEnumKey(
						hKey,
						dwIndex,
						lpszName,
						lpcchName,
						lpftLastWriteTime
						);

}  //*** BARFClusterRegEnumKey()

DWORD BARFClusterRegEnumValue(
	HKEY hKey,
	DWORD dwIndex,
	LPWSTR lpszValueName,
	LPDWORD lpcchValueName,
	LPDWORD lpdwType,
	LPBYTE lpbData,
	LPDWORD lpcbData
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegEnumValue()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegEnumValue(
						hKey,
						dwIndex,
						lpszValueName,
						lpcchValueName,
						lpdwType,
						lpbData,
						lpcbData
						);

}  //*** BARFClusterRegEnumValue()

LONG BARFClusterRegGetKeySecurity(
	HKEY hKey,
	SECURITY_INFORMATION SecurityInformation,
	PSECURITY_DESCRIPTOR pSecurityDescriptor,
	LPDWORD lpcbSecurityDescriptor
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegGetKeySecurity()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegGetKeySecurity(
						hKey,
						SecurityInformation,
						pSecurityDescriptor,
						lpcbSecurityDescriptor
						);

}  //*** BARFClusterRegGetKeySecurity()

LONG BARFClusterRegOpenKey(
	HKEY hKey,
	LPCWSTR lpszSubKey,
	REGSAM samDesired,
	PHKEY phkResult
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegOpenKey()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegOpenKey(
						hKey,
						lpszSubKey,
						samDesired,
						phkResult
						);

}  //*** BARFClusterRegOpenKey()

LONG BARFClusterRegQueryInfoKey(
	HKEY hKey,
	LPDWORD lpcSubKeys,
	LPDWORD lpcbMaxSubKeyLen,
	LPDWORD lpcValues,
	LPDWORD lpcbMaxValueNameLen,
	LPDWORD lpcbMaxValueLen,
	LPDWORD lpcbSecurityDescriptor,
	PFILETIME lpftLastWriteTime
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegQueryInfoKey()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegQueryInfoKey(
						hKey,
						lpcSubKeys,
						lpcbMaxSubKeyLen,
						lpcValues,
						lpcbMaxValueNameLen,
						lpcbMaxValueLen,
						lpcbSecurityDescriptor,
						lpftLastWriteTime
						);

}  //*** BARFClusterRegQueryInfoKey()

LONG BARFClusterRegQueryValue(
	HKEY hKey,
	LPCWSTR lpszValueName,
	LPDWORD lpdwValueType,
	LPBYTE lpbData,
	LPDWORD lpcbData
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegQueryValue()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegQueryValue(
						hKey,
						lpszValueName,
						lpdwValueType,
						lpbData,
						lpcbData
						);

}  //*** BARFClusterRegQueryValue()

LONG BARFClusterRegSetKeySecurity(
	HKEY hKey,
	SECURITY_INFORMATION SecurityInformation,
	PSECURITY_DESCRIPTOR pSecurityDescriptor
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegSetKeySecurity()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegSetKeySecurity(
						hKey,
						SecurityInformation,
						pSecurityDescriptor
						);

}  //*** BARFClusterRegSetKeySecurity()

DWORD BARFClusterRegSetValue(
	HKEY hKey,
	LPCWSTR lpszValueName,
	DWORD dwType,
	CONST BYTE * lpbData,
	DWORD cbData
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegSetValue()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegSetValue(
						hKey,
						lpszValueName,
						dwType,
						lpbData,
						cbData
						);

}  //*** BARFClusterRegSetValue()

HKEY BARFGetClusterGroupKey(
	HGROUP hGroup,
	REGSAM samDesired
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterGroupKey()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return GetClusterGroupKey(hGroup, samDesired);

}  //*** BARFGetClusterGroupKey()

HKEY BARFGetClusterKey(
	HCLUSTER hCluster,
	REGSAM samDesired
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterKey()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return GetClusterKey(hCluster, samDesired);

}  //*** BARFGetClusterKey()

HKEY BARFGetClusterNodeKey(
	HNODE hNode,
	REGSAM samDesired
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterNodeKey()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return GetClusterNodeKey(hNode, samDesired);

}  //*** BARFGetClusterNodeKey()

HKEY BARFGetClusterResourceKey(
	HRESOURCE hResource,
	REGSAM samDesired
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterResourceKey()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return GetClusterResourceKey(hResource, samDesired);

}  //*** BARFGetClusterResourceKey()

HKEY BARFGetClusterResourceTypeKey(
	HCLUSTER hCluster,
	LPCWSTR lpszTypeName,
	REGSAM samDesired
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterResourceTypeKey()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return GetClusterResourceTypeKey(hCluster, lpszTypeName, samDesired);

}  //*** BARFGetClusterResourceTypeKey()

HKEY BARFGetClusterNetworkKey(
	HNETWORK hNetwork,
	REGSAM samDesired
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterNetworkKey()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return GetClusterNetworkKey(hNetwork, samDesired);

}  //*** BARFGetClusterNetworkKey()

HKEY BARFGetClusterNetInterfaceKey(
	HNETINTERFACE hNetInterface,
	REGSAM samDesired
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterNetInterfaceKey()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return GetClusterNetInterfaceKey(hNetInterface, samDesired);

}  //*** BARFGetClusterNetInterfaceKey()

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\basecmdt.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BaseCmdT.h
//
//	Abstract:
//		Definition of the CBaseCmdTarget class.
//
//	Implementation File:
//		BaseCmdT.cpp
//
//	Author:
//		David Potter (davidp)	December 11, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASECMDT_H_
#define _BASECMDT_H_

/////////////////////////////////////////////////////////////////////////////
//	Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseCmdTarget;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CBaseCmdTarget command target
/////////////////////////////////////////////////////////////////////////////

class CBaseCmdTarget : public CCmdTarget
{
	DECLARE_DYNCREATE(CBaseCmdTarget)

// Construction
public:
	CBaseCmdTarget(void) { m_nReferenceCount = 0; }	// protected constructor used by dynamic creation

// Attributes
protected:
	ULONG				m_nReferenceCount;

public:
	ULONG				NReferenceCount(void) const	{ return m_nReferenceCount; }

// Operations
public:
	ULONG				AddRef(void)
	{
		return ++m_nReferenceCount;
	}
	ULONG				Release(void)
	{
		ULONG	nReferenceCount;

		ASSERT(m_nReferenceCount != 0);

		nReferenceCount = --m_nReferenceCount;
		if (m_nReferenceCount == 0)
			delete this;

		return nReferenceCount;
	}

// Overrides
public:
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBaseCmdTarget)
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CBaseCmdTarget)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

};  //*** class CBaseCmdTarget

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//	Global Variables
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////

#endif // _BASECMDT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\basedlg.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		BaseDlg.cpp
//
//	Abstract:
//		Implementation of the CBaseDialog class.
//
//	Author:
//		David Potter (davidp)	February 5, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BaseDlg.h"
#include "TraceTag.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag	g_tagBaseDlg(_T("UI"), _T("BASE DIALOG"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CBaseDialog class
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBaseDialog, CDialog)

/////////////////////////////////////////////////////////////////////////////
// CBaseDialog Message Map

BEGIN_MESSAGE_MAP(CBaseDialog, CDialog)
	//{{AFX_MSG_MAP(CBaseDialog)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::CBaseDialog
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pdwHelpMap			[IN] Control to help ID map.
//		lpszTemplateName	[IN] Dialog template name.
//		pParentWnd			[IN OUT] Parent window for the dialog.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseDialog::CBaseDialog(
	IN LPCTSTR			lpszTemplateName,
	IN const DWORD *	pdwHelpMap,
	IN OUT CWnd *		pParentWnd
	)
	: CDialog(lpszTemplateName, pParentWnd)
	, m_dlghelp(pdwHelpMap, 0) // no help mask in this case
{
}  //*** CBaseDialog::CBaseDialog(LPCTSTR, CWnd*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::CBaseDialog
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idd				[IN] Dialog template resource ID.
//		pdwHelpMap		[IN] Control to help ID map.
//		pParentWnd		[IN OUT] Parent window for the dialog.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseDialog::CBaseDialog(
	IN UINT				idd,
	IN const DWORD *	pdwHelpMap,
	IN OUT CWnd *		pParentWnd
	)
	: CDialog(idd, pParentWnd)
	, m_dlghelp(pdwHelpMap, idd)
{
	//{{AFX_DATA_INIT(CBaseDialog)
	//}}AFX_DATA_INIT

}  //*** CBaseDialog::CBaseDialog(UINT, CWnd*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseDialog::DoDataExchange(CDataExchange * pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBaseDialog)
	//}}AFX_DATA_MAP

}  //*** CBaseDialog::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::OnContextMenu
//
//	Routine Description:
//		Handler for the WM_CONTEXTMENU message.
//
//	Arguments:
//		pWnd	Window in which user clicked the right mouse button.
//		point	Position of the cursor, in screen coordinates.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseDialog::OnContextMenu(CWnd * pWnd, CPoint point)
{
	m_dlghelp.OnContextMenu(pWnd, point);

}  //*** CBaseDialog::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::OnHelpInfo
//
//	Routine Description:
//		Handler for the WM_HELPINFO message.
//
//	Arguments:
//		pHelpInfo	Structure containing info about displaying help.
//
//	Return Value:
//		TRUE		Help processed.
//		FALSE		Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseDialog::OnHelpInfo(HELPINFO * pHelpInfo)
{
	BOOL	bProcessed;

	bProcessed = m_dlghelp.OnHelpInfo(pHelpInfo);
	if (!bProcessed)
		bProcessed = CDialog::OnHelpInfo(pHelpInfo);
	return bProcessed;

}  //*** CBaseDialog::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::OnCommandHelp
//
//	Routine Description:
//		Handler for the WM_COMMANDHELP message.
//
//	Arguments:
//		wParam		[IN] WPARAM.
//		lParam		[IN] LPARAM.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBaseDialog::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
	LRESULT	lProcessed;

	lProcessed = m_dlghelp.OnCommandHelp(wParam, lParam);
	if (!lProcessed)
		lProcessed = CDialog::OnCommandHelp(wParam, lParam);

	return lProcessed;

}  //*** CBaseDialog::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\basedlg.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BaseDlg.h
//
//	Abstract:
//		Definition of the CBaseDialog class.
//
//	Implementation File:
//		BaseDlg.cpp
//
//	Author:
//		David Potter (davidp)	February 5, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEDLG_H_
#define _BASEDLG_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseDialog;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _DLGHELP_H_
#include "DlgHelp.h"	// for CDialogHelp
#endif

/////////////////////////////////////////////////////////////////////////////
// CBaseDialog dialog
/////////////////////////////////////////////////////////////////////////////

class CBaseDialog : public CDialog
{
	DECLARE_DYNCREATE(CBaseDialog)

// Construction
public:
	CBaseDialog(void) { }
	CBaseDialog(
		IN LPCTSTR			lpszTemplateName,
		IN const DWORD *	pdwHelpMap,
		IN OUT CWnd *		pParentWnd = NULL
		);
	CBaseDialog(
		IN UINT				idd,
		IN const DWORD *	pdwHelpMap,
		IN OUT CWnd *		pParentWnd = NULL
		);

// Dialog Data
	//{{AFX_DATA(CBaseDialog)
	enum { IDD = 0 };
	//}}AFX_DATA

// Attributes

// Operations
public:
	void			SetHelpMask(IN DWORD dwMask)	{ m_dlghelp.SetHelpMask(dwMask); }

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBaseDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CDialogHelp		m_dlghelp;

	// Generated message map functions
	//{{AFX_MSG(CBaseDialog)
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CBaseDialog

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\baseppag.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BasePPag.cpp
//
//	Abstract:
//		Implementation of the CBasePropertyPage class.
//
//	Author:
//		David Potter (davidp)	August 31, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BasePPag.h"
#include "ClusItem.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBasePropertyPage, CBasePage)

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage Message Map

BEGIN_MESSAGE_MAP(CBasePropertyPage, CBasePage)
	//{{AFX_MSG_MAP(CBasePropertyPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CBasePropertyPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(void)
{
}  //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CBasePropertyPage
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idd				[IN] Dialog template resource ID.
//		pdwHelpMap		[IN] Control to help ID map.
//		nIDCaption		[IN] Caption string resource ID.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
	IN UINT				idd,
	IN const DWORD *	pdwHelpMap,
	IN UINT				nIDCaption
	)
	: CBasePage(idd, pdwHelpMap, nIDCaption)
{
	//{{AFX_DATA_INIT(CBasePage)
	//}}AFX_DATA_INIT

}  //*** CBasePropertyPage::CBasePropertyPage(UINT, UINT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\basepage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BasePage.h
//
//	Abstract:
//		Definition of the CBasePage class.
//
//	Implementation File:
//		BasePage.cpp
//
//	Author:
//		David Potter (davidp)	May 14, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#define _BASEPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASESHT_H_
#include "BaseSht.h"	// for CBaseSheet
#endif

#ifndef _DLGHELP_H_
#include "DlgHelp.h"	// for CDialogHelp
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePage dialog
/////////////////////////////////////////////////////////////////////////////

class CBasePage : public CPropertyPage
{
	DECLARE_DYNCREATE(CBasePage)

// Construction
public:
	CBasePage(void);
	CBasePage(
		IN UINT				idd,
		IN const DWORD *	pdwHelpMap,
		IN UINT				nIDCaption = 0
		);

	void					CommonConstruct(void);
	virtual	BOOL			BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CBasePage)
	enum { IDD = 0 };
	//}}AFX_DATA
	CStatic	m_staticIcon;
	CStatic	m_staticTitle;

// Attributes
protected:
	CBaseSheet *			m_psht;
	BOOL					m_bReadOnly;

	CBaseSheet *			Psht(void) const		{ return m_psht; }
	BOOL					BReadOnly(void) const	{ return m_bReadOnly || Psht()->BReadOnly(); }

// Operations
public:
	void					SetHelpMask(IN DWORD dwMask)	{ m_dlghelp.SetHelpMask(dwMask); }
	void					SetObjectTitle(IN const CString & rstrTitle);

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBasePage)
	public:
	virtual BOOL OnApply();
	virtual BOOL OnKillActive();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CDialogHelp				m_dlghelp;

	// Generated message map functions
	//{{AFX_MSG(CBasePage)
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	virtual afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnChangeCtrl();
	DECLARE_MESSAGE_MAP()

};  //*** class CBasePage

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\baseppag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BasePPag.h
//
//	Abstract:
//		Definition of the CBasePropertyPage class.
//
//	Implementation File:
//		BasePPag.cpp
//
//	Author:
//		David Potter (davidp)	August 31, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPPAG_H_
#define _BASEPPAG_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePage
#endif

#ifndef _BASEPSHT_H_
#include "BasePsht.h"	// for CBasePropertySheet
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage dialog
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage : public CBasePage
{
	DECLARE_DYNCREATE(CBasePropertyPage)

// Construction
public:
	CBasePropertyPage(void);
	CBasePropertyPage(
		IN UINT				idd,
		IN const DWORD *	pdwHelpMap,
		IN UINT				nIDCaption = 0
		);

// Dialog Data
	//{{AFX_DATA(CBasePropertyPage)
	enum { IDD = 0 };
	//}}AFX_DATA

// Attributes
protected:
	CBasePropertySheet *	Ppsht(void) const	{ return (CBasePropertySheet *) Psht(); }
	CClusterItem *			Pci(void) const		{ ASSERT_VALID(m_psht); return Ppsht()->Pci(); }

// Operations

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBasePropertyPage)
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CBasePropertyPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CBasePropertyPage

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPPAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\basepsht.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      BasePSht.cpp
//
//  Abstract:
//      Implementation of the CBasePropertySheet class.
//
//  Author:
//      David Potter (davidp)   August 31, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BasePSht.h"
#include "ClusItem.h"
#include "TraceTag.h"
#include "BasePPag.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagBasePropSheet(_T("UI"), _T("BASE PROP SHEET"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePropertySheet
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CBasePropertySheet, CBaseSheet)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CBasePropertySheet, CBaseSheet)
    //{{AFX_MSG_MAP(CBasePropertySheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheet::CBasePropertySheet
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pParentWnd  [IN OUT] Parent window for this property sheet.
//      iSelectPage [IN] Page to show first.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertySheet::CBasePropertySheet(
    IN OUT CWnd *   pParentWnd,
    IN UINT         iSelectPage
    )
    :
    CBaseSheet(pParentWnd, iSelectPage)
{
    m_pci = NULL;

}  //*** CBasePropertySheet::CBaseSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheet::~CBasePropertySheet
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertySheet::~CBasePropertySheet(void)
{
    if (m_pci != NULL)
        m_pci->Release();

}  //*** CBasePropertySheet::~CBasePropertySheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheet::BInit
//
//  Routine Description:
//      Initialize the property sheet.
//
//  Arguments:
//      pci         [IN OUT] Cluster item whose properties are to be displayed.
//      iimgIcon    [IN] Index in the large image list for the image to use
//                    as the icon on each page.
//
//  Return Value:
//      TRUE        Property sheet initialized successfully.
//      FALSE       Error initializing property sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertySheet::BInit(
    IN OUT CClusterItem *   pci,
    IN IIMG                 iimgIcon
    )
{
    BOOL        bSuccess    = TRUE;
    CWaitCursor wc;

    ASSERT_VALID(pci);

    // Call the base class method.
    if (!CBaseSheet::BInit(iimgIcon))
        return FALSE;

    ASSERT(m_pci == NULL);
    m_pci = pci;
    pci->AddRef();

    try
    {
        // Set the object title.
        m_strObjTitle = Pci()->PszTitle();

        // Set the property sheet caption.
        SetCaption(StrObjTitle());

        // Add non-extension pages.
        {
            CBasePropertyPage **    ppages  = Ppages();
            int                     cpages  = Cpages();
            int                     ipage;

            ASSERT(ppages != NULL);
            ASSERT(cpages != 0);

            for (ipage = 0 ; ipage < cpages ; ipage++)
            {
                ASSERT_VALID(ppages[ipage]);
                ppages[ipage]->BInit(this);
                AddPage(ppages[ipage]);
            }  // for:  each page
        }  // Add non-extension pages

        // Add extension pages.
        AddExtensionPages(Pci()->PlstrExtensions(), Pci());

    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        bSuccess = FALSE;
    }  // catch:  anything

    return bSuccess;

}  //*** CBasePropertySheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheet::DoModal
//
//  Routine Description:
//      Display a modal property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      id          Control the user pressed to dismiss the sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
INT_PTR CBasePropertySheet::DoModal(void)
{
    INT_PTR id      = IDCANCEL;

    // Don't display a help button.
    m_psh.dwFlags &= ~PSH_HASHELP;

    // Display the property sheet.
    id = CBaseSheet::DoModal();

    // Update the state.
    Trace(g_tagBasePropSheet, _T("DoModal: Calling UpdateState()"));
    Pci()->UpdateState();

    return id;

}  //*** CBasePropertySheet::DoModal()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheet::AddExtensionPages
//
//  Routine Description:
//      Add extension pages to the sheet.
//
//  Arguments:
//      plstrExtensions [IN] List of extension names (CLSIDs).
//      pci             [IN OUT] Cluster item.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertySheet::AddExtensionPages(
    IN const CStringList *  plstrExtensions,
    IN OUT CClusterItem *   pci
    )
{
    ASSERT_VALID(pci);

    // Add extension pages.
    if ((plstrExtensions != NULL)
            && (plstrExtensions->GetCount() > 0))
    {
        // Enclose the loading of the extension in a try/catch block so
        // that the loading of the extension won't prevent all pages
        // from being displayed.
        try
        {
            Ext().CreatePropertySheetPages(
                    this,
                    *plstrExtensions,
                    pci,
                    NULL,
                    Hicon()
                    );
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
        catch (...)
        {
        }  // catch:  anything
    }  // Add extension pages

}  //*** CBasePropertySheet::AddExtensionPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheet::HrAddPage
//
//  Routine Description:
//      Add an extension page.
//
//  Arguments:
//      hpage       [IN OUT] Page to be added.
//
//  Return Value:
//      TRUE        Page added successfully.
//      FALSE       Page not added.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CBasePropertySheet::HrAddPage(IN OUT HPROPSHEETPAGE hpage)
{
    HRESULT     hr = ERROR_SUCCESS;

    ASSERT(hpage != NULL);
    if (hpage == NULL)
        return FALSE;

    // Add the page to the end of the list.
    try
    {
        Lhpage().AddTail(hpage);
    }  // try
    catch (...)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  anything

    return hr;

}  //*** CBasePropertySheet::HrAddPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheet::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertySheet::OnInitDialog(void)
{
    BOOL    bFocusNotSet;

    bFocusNotSet = CBaseSheet::OnInitDialog();

    // Add all the extension pages.
    {
        POSITION        pos;
        HPROPSHEETPAGE  hpage;

        pos = Lhpage().GetHeadPosition();
        while (pos != NULL)
        {
            hpage = (HPROPSHEETPAGE) Lhpage().GetNext(pos);
            SendMessage(PSM_ADDPAGE, 0, (LPARAM) hpage);
        }  // while:  more pages to add
    }  // Add all the extension pages

    return bFocusNotSet;

}  //*** CBasePropertySheet::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheet::SetCaption
//
//  Routine Description:
//      Set the caption for the property sheet.
//
//  Arguments:
//      pszTitle    [IN] String to be included in the caption.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertySheet::SetCaption(IN LPCTSTR pszTitle)
{
    CString strCaption;

    ASSERT(pszTitle != NULL);

    try
    {
        strCaption.FormatMessage(IDS_PROPSHEET_CAPTION, pszTitle);
        SetTitle(strCaption);
    }  // try
    catch (CException * pe)
    {
        // Ignore the error.
        pe->Delete();
    }  // catch:  CException

}  //*** CBasePropertySheet::SetCaption()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\basepage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BasePage.cpp
//
//	Abstract:
//		Implementation of the CBasePage class.
//
//	Author:
//		David Potter (davidp)	May 15, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BasePage.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBasePage, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// CBasePage Message Map

BEGIN_MESSAGE_MAP(CBasePage, CPropertyPage)
	//{{AFX_MSG_MAP(CBasePage)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::CBasePage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePage::CBasePage(void)
{
	CommonConstruct();

}  //*** CBasePage::CBasePage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::CBasePage
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idd				[IN] Dialog template resource ID.
//		pdwHelpMap		[IN] Control to help ID map.
//		nIDCaption		[IN] Caption string resource ID.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePage::CBasePage(
	IN UINT				idd,
	IN const DWORD *	pdwHelpMap,
	IN UINT				nIDCaption
	)
	: CPropertyPage(idd, nIDCaption)
	, m_dlghelp(pdwHelpMap, idd)
{
	//{{AFX_DATA_INIT(CBasePage)
	//}}AFX_DATA_INIT

	CommonConstruct();

}  //*** CBasePage::CBasePage(UINT, UINT)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::CommonConstruct
//
//	Routine Description:
//		Common construction code.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePage::CommonConstruct(void)
{
	m_bReadOnly = FALSE;

}  //*** CBasePage::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::BInit
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		psht		[IN OUT] Property sheet to which this page belongs.
//
//	Return Value:
//		TRUE		Page initialized successfully.
//		FALSE		Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePage::BInit(IN OUT CBaseSheet * psht)
{
	ASSERT_VALID(psht);

	m_psht = psht;

	// Don't display a help button.
	m_psp.dwFlags &= ~PSP_HASHELP;

	return TRUE;

}  //*** CBasePage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePage::DoDataExchange(CDataExchange * pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBasePage)
	//}}AFX_DATA_MAP
	DDX_Control(pDX, IDC_PP_ICON, m_staticIcon);
	DDX_Control(pDX, IDC_PP_TITLE, m_staticTitle);

	if (!pDX->m_bSaveAndValidate)
	{
		// Set the title.
		DDX_Text(pDX, IDC_PP_TITLE, (CString &) Psht()->StrObjTitle());
	}  // if:  not saving data

}  //*** CBasePage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus not set yet.
//		FALSE		Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePage::OnInitDialog(void)
{
	BOOL	bFocusNotSetYet;

	bFocusNotSetYet = CPropertyPage::OnInitDialog();

	// Display an icon for the object.
	if (Psht()->Hicon() != NULL)
		m_staticIcon.SetIcon(Psht()->Hicon());

	return bFocusNotSetYet;	// return TRUE unless you set the focus to a control
							// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CBasePage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::OnSetActive
//
//	Routine Description:
//		Handler for when the PSM_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePage::OnSetActive(void)
{
	return CPropertyPage::OnSetActive();

}  //*** CBasePage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::OnKillActive
//
//	Routine Description:
//		Handler for the PSM_KILLACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page focus successfully killed.
//		FALSE	Error killing page focus.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePage::OnKillActive(void)
{
	return CPropertyPage::OnKillActive();

}  //*** CBasePage::OnKillActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::OnApply
//
//	Routine Description:
//		Handler for the PSM_APPLY message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePage::OnApply(void)
{
	ASSERT(!BReadOnly());
	return CPropertyPage::OnApply();

}  //*** CBasePage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::OnChangeCtrl
//
//	Routine Description:
//		Handler for the messages sent when a control is changed.  This
//		method can be specified in a message map if all that needs to be
//		done is enable the Apply button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePage::OnChangeCtrl(void)
{
	SetModified(TRUE);

}  //*** CBasePage::OnChangeCtrl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::SetObjectTitle
//
//	Routine Description:
//		Set the title control on the page.
//
//	Arguments:
//		rstrTitle	[IN] Title string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePage::SetObjectTitle(IN const CString & rstrTitle)
{
	Psht()->SetObjectTitle(rstrTitle);
	if (m_hWnd != NULL)
		m_staticTitle.SetWindowText(rstrTitle);

}  //*** CBasePage::SetObjectTitle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::OnContextMenu
//
//	Routine Description:
//		Handler for the WM_CONTEXTMENU message.
//
//	Arguments:
//		pWnd	Window in which user clicked the right mouse button.
//		point	Position of the cursor, in screen coordinates.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePage::OnContextMenu(CWnd * pWnd, CPoint point)
{
	m_dlghelp.OnContextMenu(pWnd, point);

}  //*** CBasePage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::OnHelpInfo
//
//	Routine Description:
//		Handler for the WM_HELPINFO message.
//
//	Arguments:
//		pHelpInfo	Structure containing info about displaying help.
//
//	Return Value:
//		TRUE		Help processed.
//		FALSE		Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePage::OnHelpInfo(HELPINFO * pHelpInfo)
{
	BOOL	bProcessed;

	bProcessed = m_dlghelp.OnHelpInfo(pHelpInfo);
	if (!bProcessed)
		bProcessed = CPropertyPage::OnHelpInfo(pHelpInfo);
	return bProcessed;

}  //*** CBasePage::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::OnCommandHelp
//
//	Routine Description:
//		Handler for the WM_COMMANDHELP message.
//
//	Arguments:
//		wParam		[IN] WPARAM.
//		lParam		[IN] LPARAM.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePage::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
	LRESULT	lProcessed;

	lProcessed = m_dlghelp.OnCommandHelp(wParam, lParam);
	if (!lProcessed)
		lProcessed = CPropertyPage::OnCommandHelp(wParam, lParam);

	return lProcessed;

}  //*** CBasePage::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\basepsht.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BasePSht.cpp
//
//	Abstract:
//		Definition of the CBasePropertySheet class.
//
//	Author:
//		David Potter (davidp)	August 31, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPSHT_H_
#define _BASEPSHT_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASESHT_H_
#include "BaseSht.h"	// for CBaseSheet, CHpageList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertySheet;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterItem;
class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// CBasePropertySheet
/////////////////////////////////////////////////////////////////////////////

class CBasePropertySheet : public CBaseSheet
{
	DECLARE_DYNAMIC(CBasePropertySheet)

// Construction
public:
	CBasePropertySheet(
		IN OUT CWnd *	pParentWnd = NULL,
		IN UINT			iSelectPage = 0
		);
	virtual ~CBasePropertySheet(void);
	virtual BOOL					BInit(
										IN OUT CClusterItem *	pciCluster,
										IN IIMG					iimgIcon
										);

// Attributes

// Operations

// Overrides
public:
	virtual INT_PTR         		DoModal(void);
	virtual void					AddExtensionPages(
										IN const CStringList *	plstrExtensions,
										IN OUT CClusterItem *	pci
										);
	virtual HRESULT					HrAddPage(IN OUT HPROPSHEETPAGE hpage);
	virtual CBasePropertyPage **	Ppages(void)	= 0;
	virtual int						Cpages(void)	= 0;

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBasePropertySheet)
	public:
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
protected:
	CClusterItem *					m_pci;
	CHpageList						m_lhpage;

public:
	CClusterItem *					Pci(void) const			{ return m_pci; }
	CHpageList &					Lhpage(void)			{ return m_lhpage; }
	void							SetCaption(IN LPCTSTR pszTitle);

	// Generated message map functions
	//{{AFX_MSG(CBasePropertySheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CBasePropertySheet

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPSHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\basesht.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BaseSht.cpp
//
//	Abstract:
//		Definition of the CBaseSheet class.
//
//	Author:
//		David Potter (davidp)	May 14, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASESHT_H_
#define _BASESHT_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXTDLL_H_
#include "ExtDll.h"		// for CExtensions
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseSheet;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterItem;
class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef CList<HANDLE, HANDLE> CHpageList;

/////////////////////////////////////////////////////////////////////////////
// CBaseSheet
/////////////////////////////////////////////////////////////////////////////

class CBaseSheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CBaseSheet)

// Construction
public:
	CBaseSheet(
		IN OUT CWnd *	pParentWnd = NULL,
		IN UINT			iSelectPage = 0
		);
	CBaseSheet(
		IN UINT			nIDCaption,
		IN OUT CWnd *	pParentWnd = NULL,
		IN UINT			iSelectPage = 0
		);
	BOOL				BInit(IN IIMG iimgIcon);

protected:
	void				CommonConstruct(void);

// Attributes

// Operations
public:
	void				SetPfGetResNetName(PFGETRESOURCENETWORKNAME pfGetResNetName, PVOID pvContext)
	{
		Ext().SetPfGetResNetName(pfGetResNetName, pvContext);
	}

// Overrides
public:
	virtual void		AddExtensionPages(
							IN const CStringList *	plstrExtensions,
							IN OUT CClusterItem *	pci
							) = 0;
	virtual HRESULT		HrAddPage(IN OUT HPROPSHEETPAGE hpage) = 0;

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBaseSheet)
	public:
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CBaseSheet(void);

protected:
	BOOL				m_bReadOnly;
	HICON				m_hicon;
	CString				m_strObjTitle;

	CExtensions			m_ext;

public:
	BOOL				BReadOnly(void) const					{ return m_bReadOnly; }
	void				SetReadOnly(IN BOOL bReadOnly = TRUE)	{ m_bReadOnly = bReadOnly; }
	HICON				Hicon(void) const						{ return m_hicon; }
	const CString &		StrObjTitle(void) const					{ return m_strObjTitle; }
	void				SetObjectTitle(IN const CString & rstrTitle)
	{
		m_strObjTitle = rstrTitle;
	}

	CExtensions &		Ext(void)								{ return m_ext; }

	// Generated message map functions
	//{{AFX_MSG(CBaseSheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CBaseSheet

/////////////////////////////////////////////////////////////////////////////

#endif // _BASESHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\basewiz.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      BaseWiz.h
//
//  Abstract:
//      Definition of the CBaseWizard class.
//
//  Implementation File:
//      BaseWiz.cpp
//
//  Author:
//      David Potter (davidp)   July 23, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEWIZ_H_
#define _BASEWIZ_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASESHT_H_
#include "BaseSht.h"    // for CBaseSheet
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

struct CWizPage;
class CBaseWizard;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseWizardPage;
class CClusterItem;

/////////////////////////////////////////////////////////////////////////////
// CWizPage
/////////////////////////////////////////////////////////////////////////////

struct CWizPage
{
    CBaseWizardPage *   m_pwpage;
    DWORD               m_dwWizButtons;

};  //*** struct CWizPage

/////////////////////////////////////////////////////////////////////////////
// CBaseWizard
/////////////////////////////////////////////////////////////////////////////

class CBaseWizard : public CBaseSheet
{
    DECLARE_DYNAMIC(CBaseWizard)

// Construction
public:
    CBaseWizard(
        IN UINT         nIDCaption,
        IN OUT CWnd *   pParentWnd  = NULL,
        IN UINT         iSelectPage = 0
        );
    virtual                 ~CBaseWizard( void )
    {
    } //*** ~CBaseWizard( )

    BOOL                    BInit( IN IIMG iimgIcon );

// Attributes
    CWizPage *              PwizpgFromPwpage( IN const CBaseWizardPage & rwpage );

// Operations
public:
    void                    LoadExtensions( IN OUT CClusterItem * pci );
    void                    SetWizardButtons( IN const CBaseWizardPage & rwpage );
    void                    SetWizardButtons( DWORD dwFlags )
    {
        CBaseSheet::SetWizardButtons( dwFlags );
    } //*** SetWizardButtons( )

    void                    EnableNext(
                                IN const CBaseWizardPage &  rwpage,
                                IN BOOL bEnable = TRUE
                                );

// Overrides
public:
    virtual INT_PTR         DoModal( void );
    virtual void            AddExtensionPages(
                                IN const CStringList *  plstrExtensions,
                                IN OUT CClusterItem *   pci
                                );
    virtual HRESULT         HrAddPage( IN OUT HPROPSHEETPAGE hpage );
    virtual void            OnWizardFinish( void );
    virtual void            OnCancel( void );
    virtual CWizPage *      Ppages( void )    = 0;
    virtual int             Cpages( void )    = 0;

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CBaseWizard)
    public:
    virtual BOOL OnInitDialog();
    //}}AFX_VIRTUAL

// Implementation
protected:
    CClusterItem *          m_pci;
    CHpageList              m_lhpage;
    BOOL                    m_bNeedToLoadExtensions;

public:
    CClusterItem *          Pci( void ) const                   { return m_pci; }
    CHpageList &            Lhpage( void )                      { return m_lhpage; }
    BOOL                    BNeedToLoadExtensions( void ) const { return m_bNeedToLoadExtensions; }

    // Generated message map functions
protected:
    //{{AFX_MSG(CBaseWizard)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CBaseWizard

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\basewiz.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      BaseWiz.cpp
//
//  Description:
//      Implementation of the CBaseWizard class.
//
//  Maintained By:
//      David Potter (davidp)   July 23, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BaseWiz.h"
#include "BaseWPag.h"
#include "ClusItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBaseWizard
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC( CBaseWizard, CBaseSheet )

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP( CBaseWizard, CBaseSheet )
    //{{AFX_MSG_MAP(CBaseWizard)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::CBaseWizard
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      nIDCaption  [IN] String resource ID for the caption for the wizard.
//      pParentWnd  [IN OUT] Parent window for this property sheet.
//      iSelectPage [IN] Page to show first.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseWizard::CBaseWizard(
    IN UINT         nIDCaption,
    IN OUT CWnd *   pParentWnd,
    IN UINT         iSelectPage
    )
    : CBaseSheet( nIDCaption, pParentWnd, iSelectPage )
{
    m_pci = NULL;
    m_bNeedToLoadExtensions = TRUE;

}  //*** CBaseWizard::CBaseWizard( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::BInit
//
//  Routine Description:
//      Initialize the wizard.
//
//  Arguments:
//      iimgIcon    [IN] Index in the large image list for the image to use
//                    as the icon on each page.
//
//  Return Value:
//      TRUE    Wizard initialized successfully.
//      FALSE   Wizard not initialized successfully.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseWizard::BInit( IN IIMG iimgIcon )
{
    BOOL        bSuccess    = TRUE;
    CWaitCursor wc;

    // Call the base class method.
    if ( ! CBaseSheet::BInit( iimgIcon ) )
    {
        return FALSE;
    } // if

    // Make this sheet a wizard.
    SetWizardMode( );

    // Add non-extension pages.
    try
    {
        // Add non-extension pages.
        {
            CWizPage *  ppages  = Ppages( );
            int         cpages  = Cpages( );
            int         ipage;

            ASSERT( ppages != NULL );
            ASSERT( cpages != 0 );

            for ( ipage = 0 ; ipage < cpages ; ipage++ )
            {
                ASSERT_VALID( ppages[ ipage ].m_pwpage );
                ppages[ ipage ].m_pwpage->BInit( this );
                AddPage( ppages[ ipage ].m_pwpage );
            }  // for:  each page
        }  // Add non-extension pages

    }  // try
    catch ( CException * pe )
    {
        pe->ReportError( );
        pe->Delete( );
        bSuccess = FALSE;
    }  // catch:  anything

    return bSuccess;

}  //*** CBaseWizard::BInit( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::DoModal
//
//  Routine Description:
//      Display a modal wizard.  Calls OnWizardFinish( ) or OnCancel( ) based
//      on what the user pressed to dismiss the wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      id          Control the user pressed to dismiss the wizard.
//
//--
/////////////////////////////////////////////////////////////////////////////
INT_PTR CBaseWizard::DoModal( void )
{
    INT_PTR     id;

    // Don't display a help button.
    m_psh.dwFlags &= ~PSH_HASHELP;

    // Display the property sheet.
    id = CBaseSheet::DoModal( );
    if ( id == ID_WIZFINISH )
    {
        OnWizardFinish( );
    } // if
    else if ( id == IDCANCEL )
    {
        OnCancel( );
    } // else

    return id;

}  //*** CBaseWizard::DoModal( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseWizard::OnInitDialog( void )
{
    BOOL    bFocusNotSet;

    // Call the base class method.
    bFocusNotSet = CBaseSheet::OnInitDialog( );

    // Remove the system menu.
    ModifyStyle( WS_SYSMENU, 0 );

    return bFocusNotSet;

}  //*** CBaseWizard::OnInitDialog( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::OnWizardFinish
//
//  Routine Description:
//      Called after the wizard has been dismissed when the Finish button
//      has been pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseWizard::OnWizardFinish( void )
{
}  //*** CBaseWizard::OnWizardFinish( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::OnCancel
//
//  Routine Description:
//      Called after the wizard has been dismissed when the Cancel button
//      has been pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseWizard::OnCancel( void )
{
}  //*** CBaseWizard::OnCancel( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::LoadExtensions
//
//  Routine Description:
//      Load extensions to the wizard.  Unload existing extension pages
//      if necessary.
//
//  Arguments:
//      pci             [IN OUT] Cluster item.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseWizard::LoadExtensions(
    IN OUT CClusterItem *   pci
    )
{
    ASSERT_VALID( pci );

    if ( BNeedToLoadExtensions( ) )
    {
        // Remove previous extensions.
        {
            POSITION    pos;

            pos = Lhpage( ).GetHeadPosition( );
            while ( pos != NULL )
            {
                SendMessage( PSM_REMOVEPAGE, 0, (LPARAM) Lhpage( ).GetNext( pos ) );
            } // while
            Lhpage( ).RemoveAll( );
        }  // Remove previous extensions

        // Add extension pages.
        m_pci = pci;
        AddExtensionPages( Pci( )->PlstrExtensions( ), Pci( ) );
        m_bNeedToLoadExtensions = FALSE;

        // Set the last page's wizard button setting.
        {
            CWizPage *  pwizpg = &Ppages( )[ Cpages( ) - 1 ];

            if ( Lhpage( ).GetCount( ) == 0 )
            {
                pwizpg->m_dwWizButtons &= ~PSWIZB_NEXT;
                pwizpg->m_dwWizButtons |= PSWIZB_FINISH;
            }  // if:  no pages added
            else
            {
                pwizpg->m_dwWizButtons |= PSWIZB_NEXT;
                pwizpg->m_dwWizButtons &= ~PSWIZB_FINISH;
            }  // else:  some pages were added
        }  // Set the last page's wizard button setting
    }  // if:  extensions need to be loaded

}  //*** CBaseWizard::LoadExtensions( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::AddExtensionPages
//
//  Routine Description:
//      Add extension pages to the sheet.
//
//  Arguments:
//      plstrExtensions [IN] List of extension names (CLSIDs).
//      pci             [IN OUT] Cluster item.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseWizard::AddExtensionPages(
    IN const CStringList *  plstrExtensions,
    IN OUT CClusterItem *   pci
    )
{
    ASSERT_VALID( pci );

    // Add extension pages.
    if ( ( plstrExtensions != NULL )
      && ( plstrExtensions->GetCount( ) > 0 ) )
    {
        // Enclose the loading of the extension in a try/catch block so
        // that the loading of the extension won't prevent all pages
        // from being displayed.
        try
        {
            Ext( ).CreateWizardPages(
                    this,
                    *plstrExtensions,
                    pci,
                    NULL,
                    Hicon( )
                    );
        }  // try
        catch ( CException * pe )
        {
            pe->ReportError( );
            pe->Delete( );
        }  // catch:  CException
        catch ( ... )
        {
        }  // catch:  anything
    }  // Add extension pages

}  //*** CBaseWizard::AddExtensionPages( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::SetWizardButtons
//
//  Routine Description:
//      Set the wizard buttons based on which page is asking.
//
//  Arguments:
//      rwpage      [IN] Page to set the buttons for.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseWizard::SetWizardButtons( IN const CBaseWizardPage & rwpage )
{
    CWizPage *  pwizpg;

    pwizpg = PwizpgFromPwpage( rwpage );
    if ( pwizpg != NULL )
    {
        SetWizardButtons( pwizpg->m_dwWizButtons );
    } // if: page was found

}  //*** CBaseWizard::SetWizardButtons( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::EnableNext
//
//  Routine Description:
//      Enables or disables the NEXT or FINISH button.
//
//  Arguments:
//      bEnable     [IN] TRUE = enable the button, FALSE = disable the button.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseWizard::EnableNext(
    IN const CBaseWizardPage &  rwpage,
    IN BOOL                     bEnable /*=TRUE*/
    )
{
    DWORD   dwWizButtons;
    CWizPage *  pwizpg;

    pwizpg = PwizpgFromPwpage( rwpage );
    if ( pwizpg != NULL )
    {
        dwWizButtons = pwizpg->m_dwWizButtons;
        if ( ! bEnable )
        {
            dwWizButtons &= ~( PSWIZB_NEXT | PSWIZB_FINISH );
            if ( pwizpg->m_dwWizButtons & PSWIZB_FINISH )
            {
                dwWizButtons |= PSWIZB_DISABLEDFINISH;
            } // if
        }  // if:  disabling the button

        SetWizardButtons( dwWizButtons );
    } // if: page was found

}  //*** CBaseWizard::EnableNext( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::PwizpgFromPwpage
//
//  Routine Description:
//      Find the CWizPage entry for the specified CBaseWizardPage.
//
//  Arguments:
//      rwpage      [IN] Page to search for.
//
//  Return Value:
//      pwizpg      Entry in the Ppages( ) array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWizPage * CBaseWizard::PwizpgFromPwpage( IN const CBaseWizardPage & rwpage )
{
    int         cwizpg = Cpages( );
    CWizPage *  pwizpg = Ppages( );

    while ( cwizpg-- > 0 )
    {
        if ( pwizpg->m_pwpage == &rwpage )
        {
            return pwizpg;
        } // if
        pwizpg++;
    }  // while:  more pages in the list

    return NULL;

}  //*** CBaseWizard::PwizpgFromPwpage( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::HrAddPage
//
//  Routine Description:
//      Add an extension page.
//
//  Arguments:
//      hpage       [IN OUT] Page to be added.
//
//  Return Value:
//      S_OK        Page added successfully.
//      S_FALSE     Page not added.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CBaseWizard::HrAddPage( IN OUT HPROPSHEETPAGE hpage )
{
    HRESULT     hr = S_OK;

    ASSERT( hpage != NULL );
    if ( hpage == NULL )
    {
        return S_FALSE;
    } // if

    // Add the page to the wizard.
    try
    {
        // Add the page to the wizard.
        SendMessage( PSM_ADDPAGE, 0, (LPARAM) hpage );

        // Add the page to the end of the list.
        Lhpage( ).AddTail( hpage );
    }  // try
    catch ( CMemoryException * pme )
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        pme->Delete( );
    }  // catch:  anything

    return hr;

}  //*** CBaseWizard::HrAddPage( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\basewpag.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BaseWPag.cpp
//
//	Abstract:
//		Implementation of the CBaseWizardPage class.
//
//	Author:
//		David Potter (davidp)	July 23, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BaseWPag.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBaseWizardPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBaseWizardPage, CBasePage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CBaseWizardPage, CBasePage)
	//{{AFX_MSG_MAP(CBaseWizardPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseWizardPage::CBaseWizardPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseWizardPage::CBaseWizardPage(void)
{
	m_bBackPressed = FALSE;

}  //*** CBaseWizardPage::CBaseWizardPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseWizardPage::CBaseWizardPage
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idd				[IN] Dialog template resource ID.
//		pdwHelpMap		[IN] Control to help ID map.
//		nIDCaption		[IN] Caption string resource ID.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseWizardPage::CBaseWizardPage(
	IN UINT				idd,
	IN const DWORD *	pdwHelpMap,
	IN UINT				nIDCaption
	)
	: CBasePage(idd, pdwHelpMap, nIDCaption)
{
	//{{AFX_DATA_INIT(CBaseWizardPage)
	//}}AFX_DATA_INIT

	m_bBackPressed = FALSE;

}  //*** CBaseWizardPage::CBaseWizardPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseWizardPage::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseWizardPage::OnSetActive(void)
{
	BOOL	bSuccess;

	Pwiz()->SetWizardButtons(*this);

	m_bBackPressed = FALSE;

	bSuccess = CBasePage::OnSetActive();
	if (bSuccess)
		m_staticTitle.SetWindowText(Pwiz()->StrObjTitle());

	return bSuccess;

}  //*** CBaseWizardPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseWizardPage::OnWizardBack
//
//	Routine Description:
//		Handler for the PSN_WIZBACK message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		-1		Don't change the page.
//		0		Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBaseWizardPage::OnWizardBack(void)
{
	LRESULT		lResult;

	lResult = CBasePage::OnWizardBack();
	if (lResult != -1)
		m_bBackPressed = TRUE;

	return lResult;

}  //*** CBaseWizardPage::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseWizardPage::OnWizardNext
//
//	Routine Description:
//		Handler for when the PSN_WIZNEXT message is sent.
//
//	Arguments:
//		None.
//
//	Return Value:
//		-1		Don't change the page.
//		0		Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBaseWizardPage::OnWizardNext(void)
{
	CWaitCursor	wc;

	// Update the data in the class from the page.
	if (!UpdateData(TRUE /*bSaveAndValidate*/))
		return -1;

	// Save the data in the sheet.
	if (!BApplyChanges())
		return -1;

	return CBasePage::OnWizardNext();

}  //*** CBaseWizardPage::OnWizardNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseWizardPage::OnWizardFinish
//
//	Routine Description:
//		Handler for when the PSN_WIZFINISH message is sent.
//
//	Arguments:
//		None.
//
//	Return Value:
//		FALSE	Don't change the page.
//		TRUE	Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseWizardPage::OnWizardFinish(void)
{
	CWaitCursor	wc;

	// Update the data in the class from the page.
	if (!UpdateData(TRUE /*bSaveAndValidate*/))
		return FALSE;

	// Save the data in the sheet.
	if (!BApplyChanges())
		return FALSE;

	return CBasePage::OnWizardFinish();

}  //*** CBaseWizardPage::OnWizardFinish()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseWizardPage::BApplyChanges
//
//	Routine Description:
//		Apply changes made on the page.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseWizardPage::BApplyChanges(void)
{
	return TRUE;

}  //*** CBaseWizardPage::BApplyChanges()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\basewpag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BaseWPag.h
//
//	Abstract:
//		Definition of the CBaseWizardPage class.
//
//	Implementation File:
//		BaseWPag.cpp
//
//	Author:
//		David Potter (davidp)	July 23, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEWPAG_H_
#define _BASEWPAG_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePage
#endif

#ifndef _BASEWIZ_H_
#include "BaseWiz.h"	// for CBaseWizard
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseWizardPage;

/////////////////////////////////////////////////////////////////////////////
// CBaseWizardPage property page
/////////////////////////////////////////////////////////////////////////////

class CBaseWizardPage : public CBasePage
{
	DECLARE_DYNCREATE(CBaseWizardPage)

// Construction
public:
	CBaseWizardPage(void);
	CBaseWizardPage(
		IN UINT				idd,
		IN const DWORD *	pdwHelpMap,
		IN UINT				nIDCaption = 0
		);

// Dialog Data
	//{{AFX_DATA(CBaseWizardPage)
	enum { IDD = 0 };
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBaseWizardPage)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnWizardFinish();
	//}}AFX_VIRTUAL

	virtual BOOL	BApplyChanges(void);

// Implementation
protected:
	BOOL			m_bBackPressed;

	BOOL			BBackPressed(void) const	{ return m_bBackPressed; }
	CBaseWizard *	Pwiz(void) const			{ ASSERT_KINDOF(CBaseWizard, Psht()); return (CBaseWizard *) Psht(); }
	void			EnableNext(IN BOOL bEnable = TRUE)	{ ASSERT_VALID(Pwiz()); Pwiz()->EnableNext(*this, bEnable); }

	// Generated message map functions
	//{{AFX_MSG(CBaseWizardPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CBaseWizardPage

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\basesht.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BaseSht.cpp
//
//	Abstract:
//		Implementation of the CBaseSheet class.
//
//	Author:
//		David Potter (davidp)	May 14, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "BaseSht.h"
#include "TraceTag.h"
#include "ExtDll.h"
#include "ExcOper.h"
#include "ClusItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag	g_tagBaseSheet(_T("UI"), _T("BASE SHEET"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CBaseSheet
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CBaseSheet, CPropertySheet)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CBaseSheet, CPropertySheet)
	//{{AFX_MSG_MAP(CBaseSheet)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseSheet::CBaseSheet
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pParentWnd	[IN OUT] Parent window for this property sheet.
//		iSelectPage	[IN] Page to show first.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseSheet::CBaseSheet(
	IN OUT CWnd *	pParentWnd,
	IN UINT			iSelectPage
	)
{
	CommonConstruct();
	m_pParentWnd = pParentWnd;

}  //*** CBaseSheet::CBaseSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseSheet::CBaseSheet
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		nIDCaption	[IN] String resource ID for the caption for the wizard.
//		pParentWnd	[IN OUT] Parent window for this property sheet.
//		iSelectPage	[IN] Page to show first.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseSheet::CBaseSheet(
	IN UINT			nIDCaption,
	IN OUT CWnd *	pParentWnd,
	IN UINT			iSelectPage
	)
	: CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
	CommonConstruct();

}  //*** CBaseSheet::CBaseSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseSheet::CommonConstruct
//
//	Routine Description:
//		Common Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseSheet::CommonConstruct(void)
{
	m_bReadOnly = FALSE;
	m_hicon = NULL;
	m_strObjTitle.Empty();

}  //*** CBaseSheet::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseSheet::~CBaseSheet
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseSheet::~CBaseSheet(void)
{
	CommonConstruct();

}  //*** CBaseSheet::~CBaseSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseSheet::BInit
//
//	Routine Description:
//		Initialize the property sheet.
//
//	Arguments:
//		iimgIcon	[IN] Index in the large image list for the image to use
//					  as the icon on each page.
//
//	Return Value:
//		TRUE		Property sheet initialized successfully.
//		FALSE		Error initializing property sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseSheet::BInit(IN IIMG iimgIcon)
{
	BOOL		bSuccess	= TRUE;
	CWaitCursor	wc;

	try
	{
		// Extract the icon to use in the upper left corner.
		m_hicon = GetClusterAdminApp()->PilLargeImages()->ExtractIcon(iimgIcon);
	}  // try
	catch (CException * pe)
	{
		pe->ReportError();
		pe->Delete();
		bSuccess = FALSE;
	}  // catch:  anything

	return bSuccess;

}  //*** CBaseSheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseSheet::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus not set yet.
//		FALSE		Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseSheet::OnInitDialog(void)
{
	BOOL	bFocusNotSet;
	HWND	hTabControl = NULL;

	// Call the base class method.
	bFocusNotSet = CPropertySheet::OnInitDialog();

	// Display the context help button on the title bar.
	ModifyStyle(0, WS_SYSMENU);
	ModifyStyleEx(0, WS_EX_CONTEXTHELP);

	//
	// Turn off the Multiline style so that we get the arrows ( <- -> ) instead of multiple rows of tabs.
	// There is a problem when extension pages that have long
	hTabControl = PropSheet_GetTabControl( *this );
	if ( hTabControl != 0 )
	{
		CTabCtrl	tc;

		if ( tc.Attach( hTabControl ) )
		{
			tc.ModifyStyle( TCS_MULTILINE, 0 );
		}

		tc.Detach();
	}

	return bFocusNotSet;

}  //*** CBaseSheet::OnInitDialog()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\casvc.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      CASvc.h
//
//  Description:
//      Definition of helper functions for accessing and controlling
//      services.
//
//  Maintained By:
//      David Potter (davidp)   December 23, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CASVC_H_
#define _CASVC_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

HCLUSTER
HOpenCluster(
    LPCTSTR pszClusterIn
    );

BOOL
BCanServiceBeStarted(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    );

BOOL
BIsServiceInstalled(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    );

BOOL
BIsServiceRunning(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    );

HRESULT
HrStartService(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    );

HRESULT
HrStopService(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    );

/////////////////////////////////////////////////////////////////////////////

#endif // _CASVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\cadmtype.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		CadmType.h
//
//	Abstract:
//		Type definitions for the Cluster Administrator program.
//
//	Author:
//		David Potter (davidp)	May 2, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CADMTYPE_H_
#define _CADMTYPE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Common Pragmas
/////////////////////////////////////////////////////////////////////////////

#pragma warning(disable : 4100)		// unreferenced formal parameters
#pragma warning(disable : 4702)		// unreachable code
#pragma warning(disable : 4711)		// function selected for automatic inline expansion

/////////////////////////////////////////////////////////////////////////////
// Cluster API type definitions.
/////////////////////////////////////////////////////////////////////////////

typedef	DWORD	ClusEnumType;

/////////////////////////////////////////////////////////////////////////////
// UI type definitions.
/////////////////////////////////////////////////////////////////////////////

typedef UINT	ID;
typedef UINT	IDM;
typedef UINT	IDS;
typedef IDS		COLID;
typedef DWORD	SC;
typedef int		CB;
typedef int		CCH;
typedef UINT	IIMG;

/////////////////////////////////////////////////////////////////////////////
// String Definitions
/////////////////////////////////////////////////////////////////////////////

#define CP_ANSI		1252

/////////////////////////////////////////////////////////////////////////////

#endif // _CADMTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\bitmap.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		Bitmap.cpp
//
//	Abstract:
//		Implementation of the CMyBitmap class.
//
//	Author:
//		David Potter (davidp)	June 12, 1996
//
//	Revision History:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Bitmap.h"
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag g_tagBitmap(_T("Bitmap"), _T("Bitmap"));
CTraceTag g_tagLoadBitmapResource(_T("Bitmap"), _T("LoadBitmapResource"));
#endif

/////////////////////////////////////////////////////////////////////////////
// CMyBitmap
/////////////////////////////////////////////////////////////////////////////

// Array used for restoring the System Palette when a using a Custom Palette Bitmap.
PALETTEENTRY CMyBitmap::s_rgpeSavedSystemPalette[nMaxSavedSystemPaletteEntries];

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMyBitmap::CMyBitmap
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		None.
//--
/////////////////////////////////////////////////////////////////////////////
CMyBitmap::CMyBitmap(void)
{
	m_hinst = NULL;

	m_pbiNormal = NULL;
	m_pbiHighlighted = NULL;
	m_pbBitmap = NULL;
	m_hPalette = NULL;
	m_nSavedSystemPalette = 0;
	SetCustomPalette(FALSE);

}  //*** CMyBitmap::CMyBitmap()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMyBitmap::~CMyBitmap
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		None.
//--
/////////////////////////////////////////////////////////////////////////////
CMyBitmap::~CMyBitmap(void)
{
	delete [] (PBYTE) PbiNormal();
	delete [] (PBYTE) PbiHighlighted();
	delete [] (PBYTE) PbBitmap();

	// If we saved the System Palette Entries, we have a Palette, and the
	// number of colors for the Palette() is enough to restore the System
	// Palette entries...
	if (m_nSavedSystemPalette
			&& (HPalette() != NULL)
			&& (NColors() >= m_nSavedSystemPalette))
	{
		HDC			hdcScreen;
		UINT		nRestoredEntries;
		HPALETTE	hOldPalette;

		Trace(g_tagBitmap, _T("Restoring Screen Palette HPalette()=0x%x..."), HPalette());
		Trace(g_tagBitmap, _T("Restoring Screen Palette Entries=%d"), m_nSavedSystemPalette);

		// Restore the System Palette Entries
		nRestoredEntries = ::SetPaletteEntries(HPalette(), 0, m_nSavedSystemPalette, s_rgpeSavedSystemPalette);

		Trace(g_tagBitmap, _T("Restored Screen Palette Entries=%d"), nRestoredEntries);

		// Get the Screen's HDC
		hdcScreen = ::GetDC(NULL);

		// Select the Palette into the Screen's HDC
		hOldPalette = ::SelectPalette(hdcScreen, HPalette(), FALSE);

		// Unrealize the Palette to insure all the colors are forced into the System Palette
		::UnrealizeObject(HPalette());

		// Force the local Palette's colors into the System Palette.
		::RealizePalette(hdcScreen);

		// Release the Screen's HDC
		::ReleaseDC(NULL, hdcScreen);

		// Invalidate the Screen completely so all windows are redrawn.
		::InvalidateRect(NULL, NULL, TRUE);
	}

	// Destroy the Handle to the locally created Custom Palette.
	if (HPalette() != NULL)
		::DeleteObject(HPalette());

}  //*** CMyBitmap::~CMyBitmap()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMyBitmap::Load
//
//	Purpose:
//		Loads a bitmap from the resource into memory.
//
//	Arguments:
//		idBitmap	id of the resource to load
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by LoadBitmapResource, CreatePallette,
//		CreatePALColorMapping, or new.
//--
/////////////////////////////////////////////////////////////////////////////
void CMyBitmap::Load(ID idBitmap)
{
	// Load the Bitmap Header Information, Color Mapping Information, and the Bitmap Image.
	LoadBitmapResource(
				idBitmap,
				Hinst(),
				MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)
				);

	ASSERT(PbiNormal() != NULL);
	ASSERT(PbBitmap() != NULL);

	// Start by initializing some internal variables...
	m_dx = PbiNormal()->bmiHeader.biWidth;
	m_dy = PbiNormal()->bmiHeader.biHeight;

	ASSERT(PbiHighlighted() == NULL);

	if (BCustomPalette())
	{
		Trace(g_tagBitmap, _T("Load() - Creating Logical Palette"));

		// Save the System Palette Entries for use in the Destructor.
		SaveSystemPalette();

		// Create a Global HPalette() for use in the Paint() routine.
		CreatePalette();

		// Re-create the PbiNormal() for DIB_PAL_COLORS in the Paint() routine.
		CreatePALColorMapping();

	}  // if:  using a custom pallette
	else
	{
		// Create and Initialize the PbiHighlighted() for 16 color bitmaps.
		ASSERT(NColors() <= 16);

		Trace(g_tagBitmap, _T("Load() - Allocating PbiHighlighted()"));

		m_pbiHighlighted = (BITMAPINFO *) new BYTE[CbBitmapInfo()];
		if (m_pbiHighlighted != NULL)
		{
			::CopyMemory(PbiHighlighted(), PbiNormal(), CbBitmapInfo());
		} // if: bitmapinfo allocated successfully

	}  // else:  not using a custom pallette

}  //*** CMyBitmap::Load()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMyBitmap::LoadBitmapResource
//
//	Purpose:
//		Load a bitmap resource into the CMyBitmap class.  This includes loading (a) bitmap
//		header information, (b) color mapping table, and (c) the actual bitmap.
//
//	Arguments:
//		idbBitmap	Resource id of the bitmap to load.
//		hinst		Handle to the Module Instance
//		langid		Language specific resource (possibly different bitmaps for localized strings [Japanese, etc.])
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		GetLastError from FindResourceEx, LoadResource, LockResource, 
//		Any exceptions thrown by new.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMyBitmap::LoadBitmapResource(ID idbBitmap, HINSTANCE hinst, LANGID langid)
{
	HRSRC				hrsrc = NULL;
	HGLOBAL				hglbl = NULL;
	LPBITMAPINFO		pBitmapInfo = NULL;
	LPBITMAPINFOHEADER	pBitmapInfoHeader = NULL;
	LPRGBQUAD			pRgbQuad = NULL;
	CB					cbBitmapData;
	BYTE *				pbImageBits;

	Trace(g_tagLoadBitmapResource, _T("LoadBitmapResource(%d) - Entering"), idbBitmap);

	ASSERT(idbBitmap != NULL);

	if (hinst == NULL)
		hinst = AfxGetApp()->m_hInstance;

	// We need to find the bitmap data which includes (a) header info, (b) color, and (c) the bitmap.
	hrsrc = ::FindResourceEx(hinst, RT_BITMAP, MAKEINTRESOURCE(idbBitmap), langid);
	if (hrsrc == NULL)
	{
		DWORD	dwError = ::GetLastError();
		CString	strError;

		if (dwError == ERROR_RESOURCE_NAME_NOT_FOUND)
			strError.Format(_T("Bitmap Resource %d Not Found.  NT Error %d Loading Bitmap [Lang=%d, SubLang=%d]"),
					idbBitmap, dwError, PRIMARYLANGID(langid), SUBLANGID(langid));
		else
			strError.Format(_T("NT Error %d Attempting to Load Bitmap Resource %d [Lang=%d, SubLang=%d]"),
					dwError, idbBitmap, PRIMARYLANGID(langid), SUBLANGID(langid));
		Trace(g_tagAlways, _T("LoadBitmapResource() - Error '%s'"), strError);
		ThrowStaticException(dwError);
	}  // if:  error finding the resource

	hglbl = ::LoadResource(hinst, hrsrc);
	if (hglbl == NULL)
		ThrowStaticException(::GetLastError());

	pBitmapInfo = (LPBITMAPINFO) ::LockResource(hglbl);
	if (pBitmapInfo == NULL)
		ThrowStaticException(::GetLastError());

	cbBitmapData = ::SizeofResource(hinst, hrsrc);
	ASSERT(cbBitmapData != 0);

	Trace(g_tagLoadBitmapResource, _T("Bitmap Location = 0x%x"), pBitmapInfo);
	Trace(g_tagLoadBitmapResource, _T("Bitmap Data Size = %d bytes"), cbBitmapData);

	pBitmapInfoHeader = (LPBITMAPINFOHEADER) &pBitmapInfo->bmiHeader;
	ASSERT(pBitmapInfoHeader != NULL);
	Trace(g_tagLoadBitmapResource, _T("Bitmap Info Header = 0x%x"), pBitmapInfoHeader);

	ASSERT(pBitmapInfoHeader->biSize == sizeof(BITMAPINFOHEADER));

	Trace(g_tagLoadBitmapResource, _T("biSize=%d"), pBitmapInfoHeader->biSize);
	Trace(g_tagLoadBitmapResource, _T("biWidth=%d"), pBitmapInfoHeader->biWidth);		// Width in Pixels
	Trace(g_tagLoadBitmapResource, _T("biHeight=%d"), pBitmapInfoHeader->biHeight);	// Height in Pixels
	Trace(g_tagLoadBitmapResource, _T("biPlanes=%d"), pBitmapInfoHeader->biPlanes);
	Trace(g_tagLoadBitmapResource, _T("biBitCount=%d"), pBitmapInfoHeader->biBitCount);
	Trace(g_tagLoadBitmapResource, _T("biCompression=%d"), pBitmapInfoHeader->biCompression);
	Trace(g_tagLoadBitmapResource, _T("biSizeImage=%d"), pBitmapInfoHeader->biSizeImage);
	Trace(g_tagLoadBitmapResource, _T("biXPelsPerMeter=%d"), pBitmapInfoHeader->biXPelsPerMeter);
	Trace(g_tagLoadBitmapResource, _T("biYPelsPerMeter=%d"), pBitmapInfoHeader->biYPelsPerMeter);
	Trace(g_tagLoadBitmapResource, _T("biClrUsed=%d"), pBitmapInfoHeader->biClrUsed);
	Trace(g_tagLoadBitmapResource, _T("biClrImportant=%d"), pBitmapInfoHeader->biClrImportant);

	pRgbQuad = (LPRGBQUAD) &pBitmapInfo->bmiColors;
	ASSERT(pRgbQuad != NULL);
	Trace(g_tagLoadBitmapResource, _T("Bitmap Rgb Quad = 0x%x"), pRgbQuad);

	m_nColors = NColorsFromBitCount(pBitmapInfoHeader->biBitCount);
	m_cbColorTable = m_nColors * sizeof(RGBQUAD);
	m_cbBitmapInfo = sizeof(BITMAPINFOHEADER) + CbColorTable();

	Trace(g_tagLoadBitmapResource, _T("NColors()=%d"), NColors());
	Trace(g_tagLoadBitmapResource, _T("CbColorTable()=%d"), CbColorTable());
	Trace(g_tagLoadBitmapResource, _T("CbBitmapInfo()=%d"), CbBitmapInfo());

	ASSERT(PbiNormal() == NULL);

	// Allocate the Normal Bitmap Information
	m_pbiNormal = (LPBITMAPINFO) new BYTE[CbBitmapInfo()];
	if (m_pbiNormal == NULL)
	{
		return;
	} // if: error allocating the bitmapinfo structure

	// Fill PbiNormal() with the Loaded Resource (a) Bitmap Information and Color Mapping Table.
	::CopyMemory(PbiNormal(), pBitmapInfo, CbBitmapInfo());

	m_cbImageSize = pBitmapInfoHeader->biSizeImage;
	if ((m_cbImageSize == 0) && (pBitmapInfoHeader->biCompression == BI_RGB))
		m_cbImageSize = cbBitmapData - CbBitmapInfo();

	Trace(g_tagLoadBitmapResource, _T("Allocating Bitmap of size CbImageSize()=%d"), CbImageSize());

	ASSERT(cbBitmapData == CbBitmapInfo() + CbImageSize());
	ASSERT(PbBitmap() == NULL);

	// Allocate memory for the Bitmap Image
	m_pbBitmap = new BYTE[CbImageSize()];
	if (m_pbBitmap == NULL)
	{
		return;
	} // if: error allocating the bitmap image

	pbImageBits = (BYTE *) pBitmapInfo + CbBitmapInfo();

	Trace(g_tagLoadBitmapResource, _T("Bitmap Location pbImageBits=0x%x"), pbImageBits);

	// Copy the Image Bits into the allocated memory.
	::CopyMemory(PbBitmap(), pbImageBits, CbImageSize());

}  //*** CMyBitmap::LoadBitmapResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMyBitmap::NColorsFromBitCount
//
//	Purpose:
//		Compute the number of colors given the number of bits to represent color.
//
//	Arguments:
//		nBitCount		The number of bits used for color representation.
//
//	Return Value:
//		nColors			Number of colors represented with nBitCount bits.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CMyBitmap::NColorsFromBitCount(int nBitCount) const
{
	int			nColors;

	switch (nBitCount)
	{
		default:
			nColors = 0;
			break;

		case 1:
			nColors = 2;
			break;

		case 4:
			nColors = 16;
			break;

		case 8:
			nColors = 256;
			break;
	}

	return nColors;

}  //*** CMyBitmap::NColorsFromBitCount()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMyBitmap::SaveSystemPalette
//
//	Purpose:
//		To save the System Palette Colors for use when a Custom Palette overwrites
//		the System Palette entries.  The Saved System Palette (s_rgpeSavedSystemPalette)
//		is used in the CMyBitmap's destructor.
//
//	Arguments:
//		None.
//
//	Return Values:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMyBitmap::SaveSystemPalette(void)
{
	HDC			hdcScreen;
	int			nPaletteEntries;
	int			nSavedEntries;

	// Get the Screen's HDC
	hdcScreen = ::GetDC(NULL);
	if (hdcScreen == NULL)
	{
		return;
	} // if: couldn't get the screen DC

	// Can only save the System Palette Colors when the Device's RC_PALETTE bit is set.
	if (::GetDeviceCaps(hdcScreen, RASTERCAPS) & RC_PALETTE)
	{
		// Get the Number of System Palette Entries
		nPaletteEntries = ::GetDeviceCaps(hdcScreen, SIZEPALETTE);

		Trace(g_tagBitmap, _T("SaveSystemPalette() - nPaletteEntries=%d"), nPaletteEntries);

		if ((nPaletteEntries > 0)
				&& (nPaletteEntries <= nMaxSavedSystemPaletteEntries))
		{
			// Get the Current System Palette Entries
			nSavedEntries = ::GetSystemPaletteEntries(hdcScreen, 0, nPaletteEntries, s_rgpeSavedSystemPalette);

			// Set the number of Saved System Palette Entries list for use in OnDestroy().
			if (nSavedEntries == nPaletteEntries)
			{
				Trace(g_tagBitmap, _T("SaveSystemPalette() - Saved System Palette Entries=%d"), nPaletteEntries);
				m_nSavedSystemPalette = nPaletteEntries;
			}
		}
	}

	// Release the Screen's HDC
	::ReleaseDC(NULL, hdcScreen);

}  //*** CMyBitmap::SaveSystemPalette()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMyBitmap::CreatePalette
//
//	Purpose:
//		Create a logical palette from the color mapping table embedded in the
//		bitmap resource.
//
//	Arguments:
//		None.
//
//	Return Values:
//		None.
//
//	Exceptions Thrown:
//		GetLastError from CreatePalette.
//		Any exceptions thrown by new.
//--
/////////////////////////////////////////////////////////////////////////////
void CMyBitmap::CreatePalette(void)
{
	LPLOGPALETTE		pLogicalPalette = NULL;
	CB					cbLogicalPalette;
	int					nColor;
	LPPALETTEENTRY		pPaletteEntry;

	Trace(g_tagBitmap, _T("CreatePalette() - Entering"));

	try
	{
		// Compute the size of the logical palette.
		cbLogicalPalette = sizeof(LOGPALETTE) + (NColors() * sizeof(PALETTEENTRY));

		Trace(g_tagBitmap, _T("CreatePalette() - cbLogicalPalette=%d"), cbLogicalPalette);

		// Allocate the Logical Palette Memory
		pLogicalPalette = (LPLOGPALETTE) new BYTE[cbLogicalPalette];
		if (pLogicalPalette == NULL)
		{
			ThrowStaticException(GetLastError());
		} // if: error allocating the Logical Palette Memory

		ASSERT(pLogicalPalette != NULL);
		ASSERT(PbiNormal() != NULL);

		pLogicalPalette->palVersion = 0x300;			// Windows 3.0
		pLogicalPalette->palNumEntries = (WORD) NColors();

		// Fill the Logical Palette's Color Information
		for (nColor=0; nColor<NColors(); nColor++)
		{
			pPaletteEntry = &(pLogicalPalette->palPalEntry[nColor]);

			pPaletteEntry->peRed = PbiNormal()->bmiColors[nColor].rgbRed;
			pPaletteEntry->peGreen = PbiNormal()->bmiColors[nColor].rgbGreen;
			pPaletteEntry->peBlue = PbiNormal()->bmiColors[nColor].rgbBlue;
			pPaletteEntry->peFlags = 0;
		}

		// Create the NT Palette for use in the Paint Routine.
		m_hPalette = ::CreatePalette(pLogicalPalette);
		if (m_hPalette == NULL)
			ThrowStaticException(::GetLastError());

		ASSERT(HPalette() != NULL);

		delete [] (PBYTE) pLogicalPalette;
	}  // try
	catch (CException *)
	{
		delete pLogicalPalette;
		throw;
	}  // catch:  anything

}  //*** CMyBitmap::CreatePalette()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMyBitmap::CreatePALColorMapping
//
//	Purpose:
//		Given BITMAPINFO in PbiNormal(), recreate the PbiNormal() into a
//		DIB_PAL_COLORS format.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by new.
//--
/////////////////////////////////////////////////////////////////////////////
void CMyBitmap::CreatePALColorMapping(void)
{
	LPBITMAPINFO			pNewBitmapInfo = NULL;
	CB						cbNewBitmapInfo;
	CB						cbNewBitmapHeaderInfo;
	BYTE *					pbColorTable;
	WORD					wColor;

	ASSERT(PbiNormal() != NULL);
	ASSERT(PbiNormal()->bmiHeader.biSize == sizeof(BITMAPINFOHEADER));
//	ASSERT(PbiNormal()->bmiHeader.biClrUsed == (UINT) NColors());

	try
	{
		Trace(g_tagBitmap, _T("CreatePALColorMapping() - Entering"));

		cbNewBitmapHeaderInfo = sizeof(BITMAPINFOHEADER);

		Trace(g_tagBitmap, _T("CreatePALColorMapping() - cbNewBitmapHeaderInfo=%d"), cbNewBitmapHeaderInfo);

		// New Bitmap Info is the Info Header plus the Color mapping information.
		cbNewBitmapInfo = cbNewBitmapHeaderInfo + (NColors() * sizeof(WORD));

		Trace(g_tagBitmap, _T("CreatePALColorMapping() - cbNewBitmapInfo=%d"), cbNewBitmapInfo);

		// Allocate the New Bitmap Information
		pNewBitmapInfo = (LPBITMAPINFO) new BYTE[cbNewBitmapInfo];

		ASSERT(pNewBitmapInfo != NULL);
		if (pNewBitmapInfo == NULL)
		{
			ThrowStaticException(GetLastError());
		} // if: error allocating the new bitmapinfo structure

		Trace(g_tagBitmap, _T("CreatePALColorMapping() - New Bitmap Info Location=0x%x"), pNewBitmapInfo);

		// Copy the Header Information to the allocated memory.
		::CopyMemory(pNewBitmapInfo, PbiNormal(), cbNewBitmapHeaderInfo);

		// Create the Color Lookup Table.
		pbColorTable = (BYTE *) (pNewBitmapInfo) + cbNewBitmapHeaderInfo;

		ASSERT(pbColorTable + (NColors() * sizeof(WORD)) == (BYTE *) (pNewBitmapInfo) + cbNewBitmapInfo);

		Trace(g_tagBitmap, _T("CreatePALColorMapping() - Filling %d Color Table at Location 0x%x"), NColors(), pbColorTable);

		// Fill the PAL Color Lookup Table
		for (wColor = 0 ; wColor < NColors() ; wColor++)
		{
			::CopyMemory(pbColorTable, &wColor, sizeof(WORD));
			pbColorTable += sizeof(WORD);
		}

		delete [] (PBYTE) PbiNormal();
		m_pbiNormal = pNewBitmapInfo;
		m_cbBitmapInfo = cbNewBitmapInfo;
		pNewBitmapInfo = NULL;
	}  // try
	catch (CException *)
	{
		delete pNewBitmapInfo;
		throw;
	}  // catch:  anything

}  //*** CMyBitmap::CreatePALColorMapping()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMyBitmap::Paint
//
//	Purpose:
//		Paints a sub-bitmap
//
//	Parameters:
//		hdc			HDC to paint
//		prect		Where to position the bitmap:
//						Only the upperleft corner is used
//		bHighlighted	Used to select the color map to use.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMyBitmap::Paint(HDC hdc, RECT * prect, BOOL bHighlighted)
{
	LPBITMAPINFO			pBitmapInfo;
	UINT					nColorUse;
	HPALETTE				hOldPalette = NULL;

	ASSERT(hdc != NULL);
	ASSERT(prect != NULL);

	Trace(g_tagBitmap, _T("bHighlighted = %d"), bHighlighted);

#ifdef _DEBUG
	{
		int				nPlanes;
		int				nBitsPerPixel;
		int				nBitCount;

		nPlanes = ::GetDeviceCaps(hdc, PLANES);
		nBitsPerPixel = ::GetDeviceCaps(hdc, BITSPIXEL);
		nBitCount = nPlanes * nBitsPerPixel;

		Trace(g_tagBitmap, _T("Paint() - nPlanes=%d"), nPlanes);
		Trace(g_tagBitmap, _T("Paint() - nBitsPerPixel=%d"), nBitsPerPixel);
		Trace(g_tagBitmap, _T("Paint() - nBitCount=%u"), nBitCount);
	}
#endif

	try
	{
		if (BCustomPalette())
		{
			ASSERT(PbiNormal() != NULL);
			ASSERT(HPalette() != NULL);

			// Select the Custom Palette into the HDC about to be drawn...
			hOldPalette = ::SelectPalette(hdc, HPalette(), FALSE);				// FALSE causes the current Screen Palette to be Overwritten
			if (hOldPalette == NULL)
				ThrowStaticException(::GetLastError());

			// Force the Palette colors into the System Palette
			if (::RealizePalette(hdc) == GDI_ERROR)
				ThrowStaticException(::GetLastError());

			pBitmapInfo = PbiNormal();
			nColorUse = DIB_PAL_COLORS;

#ifdef NEVER
			pBitmapInfo = PbiNormal();
			nColorUse = DIB_RGB_COLORS;
#endif
		}  // if:  using a custom palette
		else
		{
			ASSERT(NColors() <= 16);
			ASSERT(PbiNormal() != NULL);
			ASSERT(PbiHighlighted() != NULL);
			pBitmapInfo = (bHighlighted ? PbiHighlighted() : PbiNormal());
			nColorUse = DIB_RGB_COLORS;
		}  // else:  not using a custom palette

		::SetDIBitsToDevice(
					hdc,
					(int) prect->left,						// X coordinate on screen.
					(int) prect->top,						// Y coordinate on screen.
					(DWORD) Dx(),							// cx to paint
					(DWORD) Dy(),							// cy to paint
															// Note: (0,0) of the DIB is lower-left corner!?!
					0,										// In pbi, xLeft to paint
					0,										// In pbi, yLower to paint
					0,										// Start scan line
					Dy(),									// Number of scan lines
					PbBitmap(),								// The buffer description
					pBitmapInfo,							// Bitmap Information
					nColorUse								// DIB_RGB_COLORS or DIB_PAL_COLORS
					);
	}  // try
	catch (CException * pe)
	{
		pe->ReportError();
		pe->Delete();
	}  // catch:  CException

}  //*** CMyBitmap::Paint()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMyBitmap::LoadColors
//
//	Purpose:
//		Loads the color maps based on the system settings
//
//	Arguments:
//		pnColorNormal & pnColorHighlighted
//			Arrays of 16 elements:
//				-1			Do not remap this color
//				COLOR_xxx 	Remap this color to the system color.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMyBitmap::LoadColors(int * pnColorNormal, int * pnColorHighlighted)
{
	LoadColors(pnColorNormal, PbiNormal());
	LoadColors(pnColorHighlighted, PbiHighlighted());

}  //*** CMyBitmap::LoadColors(pnColorNormal, pnColorHighlighted)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMyBitmap::LoadColors
//
//	Purpose:
//		Similar to above LoadColors except only the PbiNormal() colors are altered.
//
//	Arguments:
//		pnColorNormal		Array of color mapping table.
//
//	Returns:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMyBitmap::LoadColors(int * pnColorNormal)
{
	LoadColors(pnColorNormal, PbiNormal());

}  //*** CMyBitmap::LoadColors(pnColorNormal)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMyBitmap::LoadColors
//
//	Purpose:
//		Loads one color map based on the system settings
//
//	Arguments:
//		pnColor
//			Arrays of 16 elements:
//				-1			Do not remap this color
//				COLOR_xxx 	Remap this color to the system color.
//		pbi
//		BITMAPINFO structure to adjust
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMyBitmap::LoadColors(int * pnColor, BITMAPINFO * pbi)
{
	int			inColor;
	COLORREF	cr;

	ASSERT(pbi != NULL);
	ASSERT(pbi->bmiHeader.biBitCount <= 4);
	ASSERT(NColors() <= 16);
	ASSERT(BCustomPalette() == FALSE);

	for (inColor = 0; inColor < 16; inColor++)
	{
		if (pnColor[inColor] == -1)
			continue;

		cr = GetSysColor(pnColor[inColor]);
		pbi->bmiColors[inColor].rgbRed = GetRValue(cr);
		pbi->bmiColors[inColor].rgbGreen = GetGValue(cr);
		pbi->bmiColors[inColor].rgbBlue = GetBValue(cr);
	}

}  //*** CMyBitmap::LoadColors(pnColor, pbi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\casvc.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2001 Microsoft Corporation
//
//  Module Name:
//      CASvc.cpp
//
//  Description:
//      Implementation of helper functions for accessing and controlling
//      services.
//
//  Maintained By:
//      David Potter (davidp)   December 23, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <winsvc.h>
#include "resource.h"
#define _RESOURCE_H_
#include "CASvc.h"
#include "ConstDef.h"
#include "ExcOper.h"
#include "TraceTag.h"
#include "CluAdmin.h"
#include <FileMgmt.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagService( _T("Service"), _T("SERVICE"), 0 );
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HOpenCluster
//
//  Description:
//      Open a cluster.  If it fails, ask if the cluster service should be
//      started.
//
//  Arguments:
//      pszClusterIn    -- Name of cluster.
//
//  Return Values:
//      hCluster        -- Cluster handle or NULL.
//
//--
/////////////////////////////////////////////////////////////////////////////
HCLUSTER
HOpenCluster(
    IN LPCTSTR  pszClusterIn
    )
{
    HCLUSTER    hCluster        = NULL;
    HRESULT     hr;
    DWORD       dwStatus;
    DWORD       dwClusterState;
    LPTSTR      pszRealCluster;
    TCHAR       szRealClusterName[ MAX_PATH ];
    CString     strMsg;
    CFrameWnd * pframeMain;

    ASSERT( pszClusterIn != NULL );

    pframeMain = PframeMain();
    ASSERT( pframeMain != NULL );

    if ( _tcscmp( pszClusterIn, _T(".") ) == 0 )
    {
        DWORD   nSize = sizeof( szRealClusterName ) / sizeof( TCHAR );
        pszRealCluster = NULL;
        GetComputerName( szRealClusterName, &nSize );
    } // if: connecting to the local machine
    else
    {
        pszRealCluster = (LPTSTR) pszClusterIn;
        _tcscpy( szRealClusterName, pszClusterIn );
    } // else: not connecting to the local machine

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage( IDS_SB_OPENING_CONNECTION, szRealClusterName );
        pframeMain->SetMessageText( strStatusBarText );
        pframeMain->UpdateWindow();
    } // Display a message on the status bar

    // Encapsulate wait cursor class.
    {
        CWaitCursor wc;

        Trace( g_tagService, _T("HOpenCluster() - Getting node cluster state on '%s'"), szRealClusterName );

        // Get the cluster state of the node.
        dwStatus = GetNodeClusterState( pszRealCluster, &dwClusterState );
        if ( dwStatus != ERROR_SUCCESS )
        {
            CNTException nte( dwStatus, IDS_CANNOT_START_CLUSTER_SERVICE, szRealClusterName, NULL, FALSE /*bAutoDelete*/ );
            nte.ReportError( MB_OK | MB_ICONSTOP );
            goto Cleanup;
        }

        Trace( g_tagService, _T("HOpenCluster() - Node cluster state on '%s' is 0x%08.8x"), szRealClusterName, dwClusterState );

    } // Encapsulate wait cursor class

    // Check to see make sure that clustering is installed and configured
    // on the specified node.
    if ( ( dwClusterState == ClusterStateNotInstalled )
      || ( dwClusterState == ClusterStateNotConfigured ) )
    {
        strMsg.FormatMessage( IDS_CANNOT_START_CLUSTER_SERVICE, szRealClusterName );
        AfxMessageBox( strMsg, MB_OK | MB_ICONSTOP );
        goto Cleanup;
    } // if: clustering not installed or configured

    // If the cluster service is not running, ask if it should be started.
    if ( dwClusterState == ClusterStateNotRunning )
    {
        ID      id;

        // Ask the user if the cluster service should be started.
        strMsg.FormatMessage( IDS_START_CLUSTER_SERVICE, szRealClusterName );
        id = AfxMessageBox( strMsg, MB_YESNO | MB_ICONEXCLAMATION );
        if ( id == IDYES )
        {
            // Display a message on the status bar.
            {
                CString     strStatusBarText;
                strStatusBarText.FormatMessage( IDS_SB_STARTING_CLUSTER_SERVICE, szRealClusterName );
                pframeMain->SetMessageText( strStatusBarText );
                pframeMain->UpdateWindow();
            } // Display a message on the status bar

            // Encapsulate wait cursor class.
            {
                CWaitCursor wc;

                // Start the service.
                hr = HrStartService( CLUSTER_SERVICE_NAME, szRealClusterName );
                if ( ! FAILED( hr ) && ( hr != S_FALSE ) )
                {
                    if ( hr == S_OK )
                    {
                        // Wait a second.  This is required to make sure that the
                        // cluster service is running and ready to receive RPC
                        // connections.
                        Sleep( 1000 );
                    } // if: user didn't cancel the start operation
                } // if: service started successfully
                else
                {
                    CNTException nte( hr, IDS_CANNOT_START_CLUSTER_SERVICE, szRealClusterName, NULL, FALSE /*bAutoDelete*/ );
                    nte.ReportError();
                    goto Cleanup;
                } // else: failed to start the service

            } // Encapsulate wait cursor class
        } // if: user approved starting the service

    } // if: cluster service not running

    // Encapsulate wait cursor class.
    {
        CWaitCursor wc;

        // Display a message on the status bar.
        {
            CString     strStatusBarText;
            strStatusBarText.FormatMessage( IDS_SB_OPENING_CONNECTION, szRealClusterName );
            pframeMain->SetMessageText( strStatusBarText );
            pframeMain->UpdateWindow();
        } // Display a message on the status bar

        Trace( g_tagService, _T("HOpenCluster() - Opening the cluster on '%s'"), szRealClusterName );

        // Open the cluster.
        hCluster = OpenCluster( pszRealCluster );
        if ( hCluster == NULL )
        {
            CNTException nte( GetLastError(), IDS_OPEN_NODE_ERROR, szRealClusterName, NULL, FALSE /*bAutoDelete*/ );

            dwStatus = nte.Sc();
            nte.ReportError();
            goto Cleanup;
        } // if: error opening the cluster

    } // Encapsulate wait cursor class

Cleanup:
    // Reset the message on the status bar.
    pframeMain->SetMessageText( AFX_IDS_IDLEMESSAGE );
    pframeMain->UpdateWindow();

    if ( dwStatus != ERROR_SUCCESS )
    {
        SetLastError( dwStatus );
    } // if: error occurred

    return hCluster;

} //*** HOpenCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  BCanServiceBeStarted
//
//  Description:
//      Find out if a service can be started on a specified node or not.
//
//  Arguments:
//      pszServiceNameIn    -- Name of service.
//      pszNodeIn           -- Name of node.
//
//  Return Values:
//      TRUE            -- Service can be started on the specified node.
//      FALSE           -- Service can not be started on the specified node.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
BCanServiceBeStarted(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    )
{
    BOOL            bCanBeStarted   = FALSE;
    DWORD           dwStatus        = ERROR_SUCCESS;
    SC_HANDLE       hSCManager      = NULL;
    SC_HANDLE       hService        = NULL;
    SERVICE_STATUS  ssServiceStatus;

    // Open the Service Control Manager.
    hSCManager = OpenSCManager( pszNodeIn, NULL /*lpDatabaseName*/, GENERIC_READ );
    if ( hSCManager == NULL )
    {
        dwStatus = GetLastError();
        Trace( g_tagService, _T("BCanServiceBeStarted() - Cannot access service control manager on node '%s'!  Error: %u."), pszNodeIn, dwStatus );
        goto Cleanup;
    } // if: error opening the Service Control Manager

    // Open the service.
    hService = OpenService( hSCManager, pszServiceNameIn, SERVICE_ALL_ACCESS );
    if ( hService == NULL )
    {
        dwStatus = GetLastError();
        Trace( g_tagService, _T("BCanServiceBeStarted() - Cannot open service %s. Error: %u."), pszServiceNameIn, dwStatus );
        if ( dwStatus != ERROR_SERVICE_DOES_NOT_EXIST )
        {
            bCanBeStarted = TRUE;
        } // if: error not Service Does Not Exist
        goto Cleanup;
    } // if: error opening the service

    // Query the service status.
    if ( QueryServiceStatus( hService, &ssServiceStatus ) )
    {
        if ( ssServiceStatus.dwCurrentState == SERVICE_STOPPED )
        {
            bCanBeStarted = TRUE;
        } // if: service is stopped
    } // if: service status queried successfully
    else
    {
        dwStatus = GetLastError();
    } // if: error querying service status

Cleanup:
    if ( hService != NULL )
    {
        CloseServiceHandle( hService );
    }

    if ( hSCManager != NULL )
    {
        CloseServiceHandle( hSCManager );
    }

    SetLastError( dwStatus );

    return bCanBeStarted;

} //*** BCanServiceBeStarted()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  BIsServiceInstalled
//
//  Routine Description:
//      Find out if a service is installed on a specified node or not.
//
//  Arguments:
//      pszServiceNameIn    -- Name of service.
//      pszNodeIn           -- Name of node.
//
//  Return Value:
//      TRUE            -- Service is running on the specified node.
//      FALSE           -- Service is not running on the specified node.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
BIsServiceInstalled(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    )
{
    BOOL        bInstalled  = FALSE;
    DWORD       dwStatus    = ERROR_SUCCESS;
    SC_HANDLE   hSCManager  = NULL;
    SC_HANDLE   hService    = NULL;

    // Open the Service Control Manager.
    hSCManager = OpenSCManager( pszNodeIn, NULL /*lpDatabaseName*/, GENERIC_READ );
    if ( hSCManager == NULL )
    {
        dwStatus = GetLastError();
        Trace( g_tagService, _T("BIsServiceInstalled() - Cannot access service control manager on node '%s'!  Error: %u."), pszNodeIn, dwStatus );
        goto Cleanup;
    } // if: error opening the Service Control Manager

    // Open the service.
    hService = OpenService( hSCManager, pszServiceNameIn, SERVICE_ALL_ACCESS );
    if ( hService == NULL )
    {
        dwStatus = GetLastError();
        Trace( g_tagService, _T("BIsServiceInstalled() - Cannot open service %s. Error: %u."), pszServiceNameIn, dwStatus );
        if ( dwStatus != ERROR_SERVICE_DOES_NOT_EXIST )
        {
            bInstalled = TRUE;
        } // if: error not Service Does Not Exist
    } // if: error opening the service
    else
    {
        bInstalled = TRUE;
    } // else: service opened successfully

Cleanup:
    if ( hService != NULL )
    {
        CloseServiceHandle( hService );
    }

    if ( hSCManager != NULL )
    {
        CloseServiceHandle( hSCManager );
    }

    SetLastError( dwStatus );

    return bInstalled;

} //*** BIsServiceInstalled()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  BIsServiceRunning
//
//  Description:
//      Find out if a service is running on a specified node or not.
//
//  Arguments:
//      pszServiceNameIn    -- Name of service.
//      pszNodeIn           -- Name of node.
//
//  Return Values:
//      TRUE            -- Service is running on the specified node.
//      FALSE           -- Service is not running on the specified node.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
BIsServiceRunning(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    )
{
    BOOL            bRunning    = FALSE;
    DWORD           dwStatus    = ERROR_SUCCESS;
    SC_HANDLE       hSCManager  = NULL;
    SC_HANDLE       hService    = NULL;
    SERVICE_STATUS  ssServiceStatus;

    // Open the Service Control Manager.
    hSCManager = OpenSCManager( pszNodeIn, NULL /*lpDatabaseName*/, GENERIC_READ );
    if ( hSCManager == NULL )
    {
        dwStatus = GetLastError();
        Trace( g_tagService, _T("BIsServiceRunning() - Cannot access service control manager on node '%s'!  Error: %u."), pszNodeIn, dwStatus );
        goto Cleanup;
    } // if: error opening the Service Control Manager

    // Open the service.
    hService = OpenService( hSCManager, pszServiceNameIn, SERVICE_ALL_ACCESS );
    if ( hService == NULL )
    {
        dwStatus = GetLastError();
        Trace( g_tagService, _T("BIsServiceRunning() - Cannot open service %s. Error: %u."), pszServiceNameIn, dwStatus );
        goto Cleanup;
    } // if: error opening the service

    // Query the service status.
    if ( QueryServiceStatus( hService, &ssServiceStatus ) )
    {
        if ( ssServiceStatus.dwCurrentState == SERVICE_RUNNING )
        {
            bRunning = TRUE;
        } // if: service is running
    } // if: service status queried successfully

Cleanup:
    if ( hService != NULL )
    {
        CloseServiceHandle( hService );
    }

    if ( hSCManager != NULL )
    {
        CloseServiceHandle( hSCManager );
    }

    SetLastError( dwStatus );

    return bRunning;

} //*** BIsServiceRunning()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrStartService
//
//  Description:
//      Start a service on a specified node.
//
//  Arguments:
//      pszServiceNameIn    -- Name of service.
//      pszNodeIn           -- Name of node.
//
//  Return Values:
//      S_OK                -- Service started successfully.
//      Any errors returned by SVCMGMT_IStartStopHelper::StartServiceHelper().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
HrStartService(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    )
{
    HRESULT                     hr              = S_OK;
    ISvcMgmtStartStopHelper *   psmssh          = NULL;
    BSTR                        bstrNode        = NULL;
    BSTR                        bstrServiceName = NULL;
    CFrameWnd *                 pframeMain;

    pframeMain = PframeMain();
    ASSERT( pframeMain != NULL );

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage( IDS_SB_STARTING_SERVICE, pszServiceNameIn, pszNodeIn );
        Trace( g_tagService, _T("HrStartService() - Starting the '%s' service on node '%s'."), pszServiceNameIn, pszNodeIn );
        pframeMain->SetMessageText( strStatusBarText );
        pframeMain->UpdateWindow();
    } // Display a message on the status bar

    // Make BSTRs for the arguments.
    bstrNode = SysAllocString( pszNodeIn );
    if ( bstrNode == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    bstrServiceName = SysAllocString( pszServiceNameIn );
    if ( bstrServiceName == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Create the service management object.
    hr = CoCreateInstance(
                CLSID_SvcMgmt,
                NULL,
                CLSCTX_INPROC_SERVER,
                __uuidof( ISvcMgmtStartStopHelper ),
                reinterpret_cast< void ** >( &psmssh )
                );
    if ( FAILED( hr ) )
    {
        Trace( g_tagService, _T("HrStartService() - Error creating IStartStopHelper interface.  Error: %u."), hr );
        goto Cleanup;
    }

    // Start the service.
    hr = psmssh->StartServiceHelper( AfxGetMainWnd()->m_hWnd, bstrNode, bstrServiceName, 0, NULL );
    if ( FAILED( hr ) )
    {
        Trace( g_tagService, _T("HrStartService() - Error from IStartStopHelper::StartServiceHelper() to start the '%s' service on node '%s'.  Error: %u."), pszServiceNameIn, pszNodeIn, hr );
        goto Cleanup;
    }

Cleanup:
    if ( bstrNode != NULL )
    {
        SysFreeString( bstrNode );
    }
    if ( bstrServiceName != NULL )
    {
        SysFreeString( bstrServiceName );
    }
    if ( psmssh != NULL )
    {
        psmssh->Release();
    }

    // Reset the message on the status bar.
    pframeMain->SetMessageText( AFX_IDS_IDLEMESSAGE );
    pframeMain->UpdateWindow();

    return hr;

} //*** HrStartService()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrStopService
//
//  Description:
//      Stop a service on a specified node.
//
//  Arguments:
//      pszServiceNameIn    -- Name of service.
//      pszNodeIn           -- Name of node.
//
//  Return Values:
//      S_OK                -- Service stopped successfully.
//      Any errors returned by SVCMGMT_IStartStopHelper::ControlServiceHelper().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
HrStopService(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    )
{
    HRESULT                     hr              = S_OK;
    ISvcMgmtStartStopHelper *   psmssh          = NULL;
    BSTR                        bstrNode        = NULL;
    BSTR                        bstrServiceName = NULL;
    CFrameWnd *                 pframeMain;

    pframeMain = PframeMain();
    ASSERT( pframeMain != NULL );

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage( IDS_SB_STOPPING_SERVICE, pszServiceNameIn, pszNodeIn );
        Trace( g_tagService, _T("HrStopService() - Stopping the '%s' service on node '%s'."), pszServiceNameIn, pszNodeIn );
        pframeMain->SetMessageText( strStatusBarText );
        pframeMain->UpdateWindow();
    } // Display a message on the status bar

    // Make BSTRs for the arguments.
    bstrNode = SysAllocString( pszNodeIn );
    if ( bstrNode == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    bstrServiceName = SysAllocString( pszServiceNameIn );
    if ( bstrServiceName == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Create the service management object.
    hr = CoCreateInstance(
                CLSID_SvcMgmt,
                NULL,
                CLSCTX_INPROC_SERVER,
                __uuidof( ISvcMgmtStartStopHelper ),
                reinterpret_cast< void ** >( &psmssh )
                );
    if ( FAILED( hr ) )
    {
        Trace( g_tagService, _T("HrStopService() - Error creating IStartStopHelper interface.  Error: %u."), hr );
        goto Cleanup;
    }

    // Start the service.
    hr = psmssh->ControlServiceHelper( AfxGetMainWnd()->m_hWnd, bstrNode, bstrServiceName, SERVICE_CONTROL_STOP );
    if ( FAILED( hr ) )
    {
        Trace( g_tagService, _T("HrStopService() - Error from IStartStopHelper::ControlServiceHelper() to stop the '%s' service on node '%s'.  Error: %u."), pszServiceNameIn, pszNodeIn, hr );
        goto Cleanup;
    }

Cleanup:
    if ( bstrNode != NULL )
    {
        SysFreeString( bstrNode );
    }
    if ( bstrServiceName != NULL )
    {
        SysFreeString( bstrServiceName );
    }
    if ( psmssh != NULL )
    {
        psmssh->Release();
    }

    // Reset the message on the status bar.
    pframeMain->SetMessageText( AFX_IDS_IDLEMESSAGE );
    pframeMain->UpdateWindow();

    return hr;

} //*** HrStopService()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\bitmap.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		Bitmap.h
//
//	Abstract:
//		Definition of the CMyBitmap class.
//
//	Implementation File:
//		Bitmap.cpp
//
//	Author:
//		David Potter (davidp)	June 12, 1996
//
//	Revision History:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BITMAP_H_
#define _BITMAP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CMyBitmap;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#define nMaxSavedSystemPaletteEntries		256

/////////////////////////////////////////////////////////////////////////////
// CMyBitmap
/////////////////////////////////////////////////////////////////////////////

class CMyBitmap
{
public:
//	static	int			s_rgnColorWindowNormal[16];
//	static	int			s_rgnColorWindowHighlighted[16];
//	static	int			s_rgnColorButtonNormal[16];
//	static	int			s_rgnColorButtonHighlighted[16];

	static PALETTEENTRY	s_rgpeSavedSystemPalette[];
	int					m_nSavedSystemPalette;

private:
	HINSTANCE		m_hinst;

	BITMAPINFO *	m_pbiNormal;
	BITMAPINFO *	m_pbiHighlighted;
	BYTE *			m_pbBitmap;

	int				m_dx;
	int				m_dy;

	int				m_nColors;
	CB				m_cbColorTable;
	CB				m_cbBitmapInfo;
	CB				m_cbImageSize;
	HPALETTE		m_hPalette;
	BOOL			m_bCustomPalette;

protected:
	HINSTANCE		Hinst(void) const			{ return m_hinst; }
	BITMAPINFO *	PbiNormal(void) const		{ return m_pbiNormal;}
	BITMAPINFO *	PbiHighlighted(void) const	{ return m_pbiHighlighted; }
	BYTE *			PbBitmap(void) const		{ return m_pbBitmap; }

	void			LoadColors(int * pnColor, BITMAPINFO * pbi);

	int				NColorsFromBitCount(int nBitCount) const;

	CB				CbColorTable(void) const	{ return m_cbColorTable; }
	CB				CbBitmapInfo(void) const	{ return m_cbBitmapInfo; }
	CB				CbImageSize(void) const		{ return m_cbImageSize; }
	HPALETTE		HPalette(void) const		{ return m_hPalette; }
	BOOL			BCustomPalette(void) const	{ return m_bCustomPalette; }

	void			LoadBitmapResource(ID idBitmap, HINSTANCE hinst, LANGID langid);

	void			SaveSystemPalette(void);
	void			CreatePalette(void);
	void			CreatePALColorMapping(void);

public:
	CMyBitmap(void);
	virtual ~CMyBitmap(void);

	int				Dx(void) const				{ return m_dx; }
	int				Dy(void) const				{ return m_dy; }

	int				NColors(void) const			{ return m_nColors; }

	void			SetHinst(HINSTANCE hinst)	{ ASSERT(hinst != NULL); m_hinst = hinst; }
	void			SetCustomPalette(BOOL bCustomPalette)		{ m_bCustomPalette = bCustomPalette; }

	void			Load(ID idBitmap);

	virtual	void	Paint(HDC hdc, RECT * prc, BOOL bSelected);

	void			LoadColors(int * pnColorNormal, int * pnColorHighlighted);
	void			LoadColors(int * pnColorNormal);

	RGBQUAD			RgbQuadColorNormal(int nColor) const
	{
		ASSERT(nColor >= 0 && nColor < NColors());
		return PbiNormal()->bmiColors[nColor];
	}
	void			SetRgbQuadColorNormal(RGBQUAD rgbQuad, int nColor)
	{
		ASSERT(nColor >= 0 && nColor < NColors());
		PbiNormal()->bmiColors[nColor] = rgbQuad;
	}

};  //*** class CMyBitmap

/////////////////////////////////////////////////////////////////////////////

#endif // _BITMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\cluadmin.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      CluAdmin.cpp
//
//  Abstract:
//      Implementation of the CClusterAdminApp class.
//      Defines the class behaviors for the application.
//
//  Author:
//      David Potter (davidp)   May 1, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "CASvc.h"
#include "MainFrm.h"
#include "SplitFrm.h"
#include "ClusDoc.h"
#include "TreeView.h"
#include "OpenClus.h"
#include "ClusMru.h"
#include "ExcOper.h"
#include "Notify.h"
#include "TraceTag.h"
#include "TraceDlg.h"
#include "Barf.h"
#include "BarfDlg.h"
#include "About.h"
#include "CmdLine.h"
#include "VerInfo.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

static LPCTSTR  g_pszProfileName = _T("Cluster Administrator");

#ifdef _DEBUG
CTraceTag   g_tagApp( _T("App"), _T("APP"), 0 );
CTraceTag   g_tagAppMenu( _T("Menu"), _T("APP"), 0 );
CTraceTag   g_tagAppNotify( _T("Notify"), _T("APP NOTIFY"), 0 );
CTraceTag   g_tagNotifyThread( _T("Notify"), _T("NOTIFY THREAD"), 0 );
CTraceTag   g_tagNotifyThreadReg( _T("Notify"), _T("NOTIFY THREAD (REG)"), 0 );
#endif


/////////////////////////////////////////////////////////////////////////////
// CClusterAdminApp
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// The one and only CClusterAdminApp object

CClusterAdminApp theApp;

IMPLEMENT_DYNAMIC( CClusterNotifyContext, CObject );
IMPLEMENT_DYNAMIC( CClusterAdminApp, CWinApp );

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP( CClusterAdminApp, CWinApp )
    //{{AFX_MSG_MAP(CClusterAdminApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
    ON_COMMAND(ID_FILE_NEW_CLUSTER, OnFileNewCluster)
    ON_COMMAND(ID_WINDOW_CLOSE_ALL, OnWindowCloseAll)
    ON_UPDATE_COMMAND_UI(ID_WINDOW_CLOSE_ALL, OnUpdateWindowCloseAll)
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
#ifdef _DEBUG
    ON_COMMAND(ID_DEBUG_TRACE_SETTINGS, OnTraceSettings)
    ON_COMMAND(ID_DEBUG_BARF_SETTINGS, OnBarfSettings)
    ON_COMMAND(ID_DEBUG_BARF_ALL, OnBarfAllSettings)
#endif // _DEBUG
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::CClusterAdminApp
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterAdminApp::CClusterAdminApp( void )
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
    m_pDocTemplate = NULL;
    m_hchangeNotifyPort = NULL;
    m_lcid = MAKELCID( MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ), SORT_DEFAULT );
    m_hOpenedCluster = NULL;
    m_nIdleCount = 0;

    m_punkClusCfgClient = NULL;

    FillMemory( m_rgiimg, sizeof( m_rgiimg ), 0xFF );

}  //*** CClusterAdminApp::CClusterAdminApp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::InitInstance
//
//  Routine Description:
//      Initialize this instance of the application.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Application successfully initialized.
//      FALSE       Failed to initialize the application.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAdminApp::InitInstance( void )
{
    BOOL                        bSuccess    = FALSE;
    CMainFrame *                pMainFrame  = NULL;
    CCluAdminCommandLineInfo    cmdInfo;

    // CG: The following block was added by the Splash Screen component.
    {
//      CCluAdminCommandLineInfo cmdInfo;
//      ParseCommandLine(cmdInfo);
    }

    // Initialize OLE libraries
    if ( ! AfxOleInit() )
    {
        AfxMessageBox( IDP_OLE_INIT_FAILED );
        return FALSE;
    }

    if ( CoInitializeSecurity(
                    NULL,
                    -1,
                    NULL,
                    NULL,
                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,
                    EOAC_NONE,
                    0
                    ) != S_OK )
    {
        return FALSE;
    } // if:

    // Construct the help path.
    {
        TCHAR szPath[ _MAX_PATH ];
        TCHAR szDrive[ _MAX_PATH ];
        TCHAR szDir[ _MAX_DIR ];
        int cchPath;
        VERIFY( ::GetSystemWindowsDirectory( szPath, _MAX_PATH ) );
        cchPath = lstrlen( szPath );
        if ( szPath[ cchPath - 1 ] != _T('\\') )
        {
            szPath[ cchPath++ ] = _T('\\');
            szPath[ cchPath ] = _T('\0');
        } // if: no backslash on the end of the path
        lstrcpy( &szPath[ cchPath ], _T("Help\\") );
        _tsplitpath( szPath, szDrive, szDir, NULL, NULL );
        _tmakepath( szPath, szDrive, szDir, _T("cluadmin"), _T(".hlp") );
        free( (void *) m_pszHelpFilePath );
        BOOL bEnable;
        bEnable = AfxEnableMemoryTracking( FALSE );
        m_pszHelpFilePath = _tcsdup( szPath );
        AfxEnableMemoryTracking( bEnable );
    }  // Construct the help path

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

    SetRegistryKey( IDS_REGKEY_COMPANY );           // Set the registry key for the program.

    //
    // Override the profile name because we don't want to localize it.
    //
    free( (void *) m_pszProfileName );
    m_pszProfileName = NULL;
    m_pszProfileName = (LPTSTR) malloc( ( lstrlen( g_pszProfileName ) + 1 ) * sizeof( TCHAR ) );
    if ( m_pszProfileName == NULL )
    {
        goto MemoryError;
    } // if: error allocating the profile name buffer
    lstrcpyn( const_cast< LPTSTR >( m_pszProfileName ), g_pszProfileName, lstrlen( g_pszProfileName ) + 1 );

    InitAllTraceTags();                         // Initialize all trace tags.
    InitBarf();                                 // Initialize Basic Artificial Resource Failure system.

    // Load version information.
#if 0
    {
        CVersionInfo    verinfo;
        DWORD           dwValue;

        // Initialize the version info.
        verinfo.Init();

        // Get the Locale ID.
        if ( verinfo.BQueryValue( _T("\\VarFileInfo\\Translation"), dwValue ) )
        {
            m_lcid = MAKELCID( dwValue, SORT_DEFAULT );
        } // if: locale ID is available
    }  // Load version information
#else
    // Get the locale ID from the system to support MUI.
    m_lcid = GetUserDefaultLCID();
#endif

    // Initialize global CImageList
    InitGlobalImageList();

#ifdef _AFXDLL
    Enable3dControls();             // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();       // Call this when linking to MFC statically
#endif

    LoadStdProfileSettings( 0 );    // Load standard INI file options (including MRU)

    // Create cluster MRU.
    m_pRecentFileList = new CRecentClusterList( 0, _T("Recent Cluster List"), _T("Cluster%d"), 4 );
    if ( m_pRecentFileList == NULL )
    {
        goto MemoryError;
    } // if: error allocating memory
    m_pRecentFileList->ReadList();

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    m_pDocTemplate = new CMultiDocTemplate(
                        IDR_CLUADMTYPE,
                        RUNTIME_CLASS( CClusterDoc ),
                        RUNTIME_CLASS( CSplitterFrame ), // custom MDI child frame
                        RUNTIME_CLASS( CClusterTreeView )
                        );
    if ( m_pDocTemplate == NULL )
    {
        goto MemoryError;
    } // if: error allocating memory
    AddDocTemplate( m_pDocTemplate );

    // create main MDI Frame window
    pMainFrame = new CMainFrame;
    if ( pMainFrame == NULL )
    {
        goto MemoryError;
    } // if: error allocating memory
    ASSERT( pMainFrame != NULL );
    if ( ! pMainFrame->LoadFrame( IDR_MAINFRAME ) )
    {
        goto Cleanup;
    }  // if:  error loading the frame
    m_pMainWnd = pMainFrame;

    // Parse command line for standard shell commands, DDE, file open
//  cmdInfo.m_nShellCommand = CCommandLineInfo::FileNothing;    // Don't want to do a FileNew.
    ParseCommandLine( cmdInfo );

    // If no commands were specified on the command line, restore the desktop.
    if ( cmdInfo.m_nShellCommand == CCommandLineInfo::FileNothing )
    {
        pMainFrame->PostMessage( WM_CAM_RESTORE_DESKTOP, cmdInfo.m_bReconnect );
    } // if: no commands specified on the command line

    // Create the cluster notification thread.
    if ( ! BInitNotifyThread() )
    {
        goto Cleanup;
    } // if: error creating the cluster notification thread

    // The main window has been initialized, so show and update it.
    {
        WINDOWPLACEMENT wp;

        // Set the placement of the window.
        if ( ReadWindowPlacement( &wp, REGPARAM_SETTINGS, 0 ) )
        {
            pMainFrame->SetWindowPlacement( &wp );
            m_nCmdShow = wp.showCmd; // set the show command.
        }  // if:  read from profile

        // Activate and update the frame window.
        pMainFrame->ActivateFrame( m_nCmdShow );
        pMainFrame->UpdateWindow();
    }  // The main window has been initialized, so show and update it

    // Dispatch commands specified on the command line
    if ( ! ProcessShellCommand( cmdInfo ) )
    {
        goto Cleanup;
    } // if: error processing the command line

    TraceMenu( g_tagAppMenu, AfxGetMainWnd()->GetMenu(), _T("InitInstance menu: ") );

    bSuccess = TRUE;

Cleanup:
    if ( m_pMainWnd != pMainFrame )
    {
        delete pMainFrame;
    } // if: main frame windows allocated but not saved yet
    return bSuccess;

MemoryError:
    CNTException    nte(
                        ERROR_NOT_ENOUGH_MEMORY,
                        0,              // idsOperation
                        NULL,           // pszOperArg1
                        NULL,           // pszOperArg2
                        FALSE           // bAutoDelete
                        );
    nte.ReportError();
    nte.Delete();
    goto Cleanup;

}  //*** CClusterAdminApp::InitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnIdle
//
//  Routine Description:
//      Process the command line or shell command.
//
//  Arguments:
//      LONG    [IN]    Number of time we have been called before the next
//                      message arrives in the queue
//
//  Return Value:
//      TRUE if more idle processing
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAdminApp::OnIdle(IN LONG lCount)
{
    BOOL bMore = CWinApp::OnIdle(lCount);

    //
    // Since the MFC framework processing many messages lCount was never getting
    // higher than 1.  Since this work should not be done everytime we are idle
    // I added my own counter that determines when the work is done.
    //
    if ((++m_nIdleCount % 200) == 0)
    {
        POSITION        posDoc;                 // position in the documents collection
        POSITION        posDel;                 // position in the to be deleted list
        POSITION        posRemove;              // position in the to be deleted list to remove
        CClusterDoc *   pdoc;
        CClusterItem *  pitem;
        CWaitCursor     cw;

        posDoc = PdocTemplate()->GetFirstDocPosition();
        while (posDoc != NULL)
        {
            pdoc = (CClusterDoc *) PdocTemplate()->GetNextDoc(posDoc);
            ASSERT_VALID(pdoc);
            try
            {
                posDel = pdoc->LpciToBeDeleted().GetHeadPosition();
                while (posDel != NULL)
                {
                    posRemove = posDel;         // save posDel to posRemove since the next call is going to inc posDel
                    pitem = (CClusterItem *) pdoc->LpciToBeDeleted().GetNext(posDel);
                    ASSERT_VALID(pitem);
                    if ((pitem != NULL) && ( pitem->NReferenceCount() == 1))
                    {
                        pdoc->LpciToBeDeleted().RemoveAt(posRemove);    // the saved position posRemove
                    } // if: the list's refence is the only one
                } // while:  more items in the to be deleted list
            }
            catch (CException * pe)
            {
                pe->Delete();
            }  // catch:  CException
        }  // while:  more items in the list

        m_nIdleCount = 0;
        bMore = FALSE;      // don't want any more calls until some new messages are received
    } // if: every 200th time...

    return bMore;

}  //*** CClusterAdminApp::OnIdle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::ProcessShellCommand
//
//  Routine Description:
//      Process the command line or shell command.
//
//  Arguments:
//      rCmdInfo    [IN OUT] Command line info.
//
//  Return Value:
//      0           Error.
//      !0          No error.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAdminApp::ProcessShellCommand(IN OUT CCluAdminCommandLineInfo & rCmdInfo)
{
    BOOL    bSuccess = TRUE;

    if (rCmdInfo.m_nShellCommand == CCommandLineInfo::FileOpen)
    {
        POSITION    pos;

        try
        {
            pos = rCmdInfo.LstrClusters().GetHeadPosition();
            while (pos != NULL)
            {
                OpenDocumentFile(rCmdInfo.LstrClusters().GetNext(pos));
            }  // while:  more clusters in the list
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
            bSuccess = FALSE;
        }  // catch:  CException
    }  // if:  we are opening clusters
    else
        bSuccess = CWinApp::ProcessShellCommand(rCmdInfo);

    return bSuccess;

}  //*** CClusterAdminApp::ProcessShellCommand()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::ExitInstance
//
//  Routine Description:
//      Exit this instance of the application.
//
//  Arguments:
//      None.
//
//  Return Value:
//      0       No errors.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CClusterAdminApp::ExitInstance(void)
{
    // Close the notification port.
    if (HchangeNotifyPort() != NULL)
    {
        ::CloseClusterNotifyPort(HchangeNotifyPort());
        m_hchangeNotifyPort = NULL;

        // Allow the notification port threads to clean themselves up.
        ::Sleep(100);
    }  // if:  notification port is open

    // Delete all the items in the notification key list.
    {
        POSITION    pos;

        pos = Cnkl().GetHeadPosition();
        while (pos != NULL)
            delete Cnkl().GetNext(pos);
        Cnkl().RemoveAll();
    }  // Delete all the items in the notification key list

    CleanupAllTraceTags();                          // Cleanup trace tags.
    CleanupBarf();                                  // Cleanup Basic Artificial Resource Failure system.

    // Release the ClusCfg client object.
    if ( m_punkClusCfgClient != NULL )
    {
        m_punkClusCfgClient->Release();
    }

    return CWinApp::ExitInstance();

}  //*** CClusterAdminApp::ExitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::InitGlobalImageList
//
//  Routine Description:
//      Initialize the global image list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::InitGlobalImageList(void)
{
    // Create small image list.
    VERIFY(PilSmallImages()->Create(
                (int) 16,       // cx
                16,             // cy
                TRUE,           // bMask
                17,             // nInitial
                4               // nGrow
                ));

    PilSmallImages()->SetBkColor(::GetSysColor(COLOR_WINDOW));

    // Load the images into the small image list.
    LoadImageIntoList(PilSmallImages(), IDB_FOLDER_16, IMGLI_FOLDER);
    LoadImageIntoList(PilSmallImages(), IDB_CLUSTER_16, IMGLI_CLUSTER);
    LoadImageIntoList(PilSmallImages(), IDB_CLUSTER_UNKNOWN_16, IMGLI_CLUSTER_UNKNOWN);
    LoadImageIntoList(PilSmallImages(), IDB_NODE_16, IMGLI_NODE);
    LoadImageIntoList(PilSmallImages(), IDB_NODE_DOWN_16, IMGLI_NODE_DOWN);
    LoadImageIntoList(PilSmallImages(), IDB_NODE_PAUSED_16, IMGLI_NODE_PAUSED);
    LoadImageIntoList(PilSmallImages(), IDB_NODE_UNKNOWN_16, IMGLI_NODE_UNKNOWN);
    LoadImageIntoList(PilSmallImages(), IDB_GROUP_16, IMGLI_GROUP);
    LoadImageIntoList(PilSmallImages(), IDB_GROUP_PARTIAL_ONLINE_16, IMGLI_GROUP_PARTIALLY_ONLINE);
    LoadImageIntoList(PilSmallImages(), IDB_GROUP_PENDING_16, IMGLI_GROUP_PENDING);
    LoadImageIntoList(PilSmallImages(), IDB_GROUP_OFFLINE_16, IMGLI_GROUP_OFFLINE);
    LoadImageIntoList(PilSmallImages(), IDB_GROUP_FAILED_16, IMGLI_GROUP_FAILED);
    LoadImageIntoList(PilSmallImages(), IDB_GROUP_UNKNOWN_16, IMGLI_GROUP_UNKNOWN);
    LoadImageIntoList(PilSmallImages(), IDB_RES_16, IMGLI_RES);
    LoadImageIntoList(PilSmallImages(), IDB_RES_OFFLINE_16, IMGLI_RES_OFFLINE);
    LoadImageIntoList(PilSmallImages(), IDB_RES_PENDING_16, IMGLI_RES_PENDING);
    LoadImageIntoList(PilSmallImages(), IDB_RES_FAILED_16, IMGLI_RES_FAILED);
    LoadImageIntoList(PilSmallImages(), IDB_RES_UNKNOWN_16, IMGLI_RES_UNKNOWN);
    LoadImageIntoList(PilSmallImages(), IDB_RESTYPE_16, IMGLI_RESTYPE);
    LoadImageIntoList(PilSmallImages(), IDB_RESTYPE_UNKNOWN_16, IMGLI_RESTYPE_UNKNOWN);
    LoadImageIntoList(PilSmallImages(), IDB_NETWORK_16, IMGLI_NETWORK);
    LoadImageIntoList(PilSmallImages(), IDB_NETWORK_PARTITIONED_16, IMGLI_NETWORK_PARTITIONED);
    LoadImageIntoList(PilSmallImages(), IDB_NETWORK_DOWN_16, IMGLI_NETWORK_DOWN);
    LoadImageIntoList(PilSmallImages(), IDB_NETWORK_UNKNOWN_16, IMGLI_NETWORK_UNKNOWN);
    LoadImageIntoList(PilSmallImages(), IDB_NETIFACE_16, IMGLI_NETIFACE);
    LoadImageIntoList(PilSmallImages(), IDB_NETIFACE_UNREACHABLE_16, IMGLI_NETIFACE_UNREACHABLE);
    LoadImageIntoList(PilSmallImages(), IDB_NETIFACE_FAILED_16, IMGLI_NETIFACE_FAILED);
    LoadImageIntoList(PilSmallImages(), IDB_NETIFACE_UNKNOWN_16, IMGLI_NETIFACE_UNKNOWN);

    // Create large image list.
    VERIFY(PilLargeImages()->Create(
                (int) 32,       // cx
                32,             // cy
                TRUE,           // bMask
                17,             // nInitial
                4               // nGrow
                ));
    PilLargeImages()->SetBkColor(::GetSysColor(COLOR_WINDOW));

    // Load the images into the large image list.
    LoadImageIntoList(PilLargeImages(), IDB_FOLDER_32, IMGLI_FOLDER);
    LoadImageIntoList(PilLargeImages(), IDB_CLUSTER_32, IMGLI_CLUSTER);
    LoadImageIntoList(PilLargeImages(), IDB_CLUSTER_UNKNOWN_32, IMGLI_CLUSTER_UNKNOWN);
    LoadImageIntoList(PilLargeImages(), IDB_NODE_32, IMGLI_NODE);
    LoadImageIntoList(PilLargeImages(), IDB_NODE_DOWN_32, IMGLI_NODE_DOWN);
    LoadImageIntoList(PilLargeImages(), IDB_NODE_PAUSED_32, IMGLI_NODE_PAUSED);
    LoadImageIntoList(PilLargeImages(), IDB_NODE_UNKNOWN_32, IMGLI_NODE_UNKNOWN);
    LoadImageIntoList(PilLargeImages(), IDB_GROUP_32, IMGLI_GROUP);
    LoadImageIntoList(PilLargeImages(), IDB_GROUP_PARTIAL_ONLINE_32, IMGLI_GROUP_PARTIALLY_ONLINE);
    LoadImageIntoList(PilLargeImages(), IDB_GROUP_PENDING_32, IMGLI_GROUP_PENDING);
    LoadImageIntoList(PilLargeImages(), IDB_GROUP_OFFLINE_32, IMGLI_GROUP_OFFLINE);
    LoadImageIntoList(PilLargeImages(), IDB_GROUP_FAILED_32, IMGLI_GROUP_FAILED);
    LoadImageIntoList(PilLargeImages(), IDB_GROUP_UNKNOWN_32, IMGLI_GROUP_UNKNOWN);
    LoadImageIntoList(PilLargeImages(), IDB_RES_32, IMGLI_RES);
    LoadImageIntoList(PilLargeImages(), IDB_RES_OFFLINE_32, IMGLI_RES_OFFLINE);
    LoadImageIntoList(PilLargeImages(), IDB_RES_PENDING_32, IMGLI_RES_PENDING);
    LoadImageIntoList(PilLargeImages(), IDB_RES_FAILED_32, IMGLI_RES_FAILED);
    LoadImageIntoList(PilLargeImages(), IDB_RES_UNKNOWN_32, IMGLI_RES_UNKNOWN);
    LoadImageIntoList(PilLargeImages(), IDB_RESTYPE_32, IMGLI_RESTYPE);
    LoadImageIntoList(PilLargeImages(), IDB_RESTYPE_UNKNOWN_32, IMGLI_RESTYPE_UNKNOWN);
    LoadImageIntoList(PilLargeImages(), IDB_NETWORK_32, IMGLI_NETWORK);
    LoadImageIntoList(PilLargeImages(), IDB_NETWORK_PARTITIONED_32, IMGLI_NETWORK_PARTITIONED);
    LoadImageIntoList(PilLargeImages(), IDB_NETWORK_DOWN_32, IMGLI_NETWORK_DOWN);
    LoadImageIntoList(PilLargeImages(), IDB_NETWORK_UNKNOWN_32, IMGLI_NETWORK_UNKNOWN);
    LoadImageIntoList(PilLargeImages(), IDB_NETIFACE_32, IMGLI_NETIFACE);
    LoadImageIntoList(PilLargeImages(), IDB_NETIFACE_UNREACHABLE_32, IMGLI_NETIFACE_UNREACHABLE);
    LoadImageIntoList(PilLargeImages(), IDB_NETIFACE_FAILED_32, IMGLI_NETIFACE_FAILED);
    LoadImageIntoList(PilLargeImages(), IDB_NETIFACE_UNKNOWN_32, IMGLI_NETIFACE_UNKNOWN);

}  //*** CClusterAdminApp::InitGlobalImageList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::LoadImageIntoList
//
//  Routine Description:
//      Load images into an image list.
//
//  Arguments:
//      pil         [IN OUT] Image list into which to load the image.
//      idbImage    [IN] Resource ID for the image bitmap.
//      imgli       [IN] Index into the index array.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::LoadImageIntoList(
    IN OUT CImageList * pil,
    IN ID               idbImage,
    IN UINT             imgli
    )
{
    CBitmap     bm;
    UINT        iimg;

    LoadImageIntoList(pil, idbImage, &iimg);
    if (m_rgiimg[imgli] == (UINT) -1)
        m_rgiimg[imgli] = iimg;
#ifdef DEBUG
    else
        ASSERT(m_rgiimg[imgli] == iimg);
#endif

}  //*** CClusterAdminApp::LoadImageIntoList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CClusterAdminApp::LoadImageIntoList
//
//  Routine Description:
//      Load images into an image list.
//
//  Arguments:
//      pil         [IN OUT] Image list into which to load the image.
//      idbImage    [IN] Resource ID for the image bitmap.
//      piimg       [OUT] Pointer to image index.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::LoadImageIntoList(
    IN OUT CImageList * pil,
    IN ID               idbImage,
    OUT UINT *          piimg
    )
{
    CBitmap     bm;
    UINT        iimg;
    COLORREF    crMaskColor = RGB(255,0,255);

    ASSERT(pil != NULL);
    ASSERT(idbImage != 0);

    if (piimg == NULL)
        piimg = &iimg;

    bm.LoadBitmap(idbImage);
    *piimg = pil->Add(&bm, crMaskColor);

}  //*** CClusterAdminApp::LoadImageIntoList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnRestoreDesktop
//
//  Routine Description:
//      Handler for the WM_CAM_RESTORE_DESKTOP message.
//      Restores the desktop from the saved parameters.
//
//  Arguments:
//      wparam      TRUE = reconnect, FALSE, don't reconnect.
//      lparam      Unused.
//
//  Return Value:
//      0
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CClusterAdminApp::OnRestoreDesktop(WPARAM wparam, LPARAM lparam)
{
    CString     strConnections;
    WPARAM      bReconnect = wparam;

    if (bReconnect)
    {
        // Read the connections the user had last time they exited.
        try
        {
            strConnections = GetProfileString(REGPARAM_CONNECTIONS, REGPARAM_CONNECTIONS);
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException

        // If there were any connections, restore them.
        if (strConnections.GetLength() > 0)
        {
            LPTSTR          pszConnections;
            LPTSTR          pszConnection;
            TCHAR           szSep[]         = _T(",");

            ASSERT(m_pMainWnd != NULL);

            try
            {
                pszConnections = strConnections.GetBuffer(1);
                pszConnection = _tcstok(pszConnections, szSep);
                while (pszConnection != NULL)
                {
                    // Open a connection to this cluster.
                    OpenDocumentFile(pszConnection);

                    // Find the next connection.
                    pszConnection = _tcstok(NULL, szSep);
                }  // while:  more connections
            }  // try
            catch (CException * pe)
            {
                pe->ReportError();
                pe->Delete();
            } // catch:  CException
            strConnections.ReleaseBuffer();
        }  // if:  connections saved previously
        else
            bReconnect = FALSE;
    }  // if:  reconnect is desired

    if (!bReconnect)
    {
        CWaitCursor wc;
        Sleep(1500);
    }  // if:  not reconnecting

    // If there were no previous connections and we are not minimized, do a standard file open.
    if (!bReconnect && !AfxGetMainWnd()->IsIconic())
        OnFileOpen();

    // Otherwise, restore the desktop.

    return 0;

}  //*** CClusterAdminApp::OnRestoreDesktop()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::SaveConnections
//
//  Routine Description:
//      Save the current connections so they can be restored later.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::SaveConnections(void)
{
    POSITION        pos;
    CClusterDoc *   pdoc;
    CString         strConnections;
    TCHAR           szSep[]         = _T("\0");

    pos = PdocTemplate()->GetFirstDocPosition();
    while (pos != NULL)
    {
        pdoc = (CClusterDoc *) PdocTemplate()->GetNextDoc(pos);
        ASSERT_VALID(pdoc);
        try
        {
            strConnections += szSep + pdoc->StrNode();
            szSep[0] = _T(',');  // Subsequent connections are preceded by a separator
        }
        catch (CException * pe)
        {
            pe->Delete();
        }  // catch:  CException

        // Save connection-specific settings as well.
        pdoc->SaveSettings();
    }  // while:  more items in the list
    WriteProfileString(REGPARAM_CONNECTIONS, REGPARAM_CONNECTIONS, strConnections);

}  //*** CClusterAdminApp::SaveConnections()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnFileOpen
//
//  Routine Description:
//      Prompt the user for the name of a cluster or server and then open it.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::OnFileOpen(void)
{
    COpenClusterDialog  dlg;
    ID                  idDlgStatus;
    CDocument *         pdoc     = NULL;
    HCLUSTER            hCluster = NULL;

    do
    {
        idDlgStatus = (ID) dlg.DoModal();
        if ( idDlgStatus != IDOK )
        {
            break;
        }

        switch ( dlg.m_nAction )
        {
            case OPEN_CLUSTER_DLG_CREATE_NEW_CLUSTER:
                OnFileNewCluster();
                break;

            case OPEN_CLUSTER_DLG_ADD_NODES:
            case OPEN_CLUSTER_DLG_OPEN_CONNECTION:
                if ( hCluster != NULL )
                {
                    CloseCluster( hCluster );
                } // if: previous cluster opened
                hCluster = HOpenCluster( dlg.m_strName );
                if ( hCluster == NULL )
                {
                    CNTException    nte( GetLastError(), IDS_OPEN_CLUSTER_ERROR, dlg.m_strName );
                    nte.ReportError();
                }  // if:  error opening the cluster
                else
                {
                    Trace( g_tagApp, _T("OnFileOpen() - Opening the cluster document on '%s'"), dlg.m_strName );
                    m_hOpenedCluster = hCluster;
                    pdoc = OpenDocumentFile( dlg.m_strName );
                    m_hOpenedCluster = NULL;
                    hCluster = NULL;
                }  // else:  cluster opened successfully

                if ( ( pdoc != NULL ) && ( dlg.m_nAction == OPEN_CLUSTER_DLG_ADD_NODES ) )
                {
                    NewNodeWizard(
                        dlg.m_strName,
                        FALSE           // fIgnoreErrors
                        );
                } // if: add a node to the cluster
                break;
        } // switch: dialog action
    }  while ( ( pdoc == NULL )
            && ( dlg.m_nAction != OPEN_CLUSTER_DLG_CREATE_NEW_CLUSTER ) );

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    }

}  //*** CClusterAdminApp::OnFileOpen()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OpenDocumentFile
//
//  Routine Description:
//      Open a cluster.
//
//  Arguments:
//      lpszFileName    The name of the cluster or a server in that cluster.
//
//  Return Value:
//      NULL            Invalid cluster or server name.
//      pOpenDocument   The document instance for the open cluster.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDocument * CClusterAdminApp::OpenDocumentFile(LPCTSTR lpszFileName)
{
    // find the highest confidence
    CDocTemplate::Confidence    bestMatch = CDocTemplate::noAttempt;
    CDocTemplate *              pBestTemplate = NULL;
    CDocument *                 pOpenDocument = NULL;

    {
        ASSERT_KINDOF(CDocTemplate, m_pDocTemplate);

        CDocTemplate::Confidence    match;
        ASSERT(pOpenDocument == NULL);
        match = m_pDocTemplate->MatchDocType(lpszFileName, pOpenDocument);
        if (match > bestMatch)
        {
            bestMatch = match;
            pBestTemplate = m_pDocTemplate;
        }
    }

    if (pOpenDocument != NULL)
    {
        POSITION    pos = pOpenDocument->GetFirstViewPosition();
        if (pos != NULL)
        {
            CView *     pView = pOpenDocument->GetNextView(pos); // get first one
            ASSERT_VALID(pView);
            CFrameWnd * pFrame = pView->GetParentFrame();
            if (pFrame != NULL)
                pFrame->ActivateFrame();
            else
                Trace(g_tagApp, _T("Error: Can not find a frame for document to activate."));
            CFrameWnd * pAppFrame;
            if (pFrame != (pAppFrame = (CFrameWnd*)AfxGetApp()->m_pMainWnd))
            {
                ASSERT_KINDOF(CFrameWnd, pAppFrame);
                pAppFrame->ActivateFrame();
            }
        }
        else
        {
            Trace(g_tagApp, _T("Error: Can not find a view for document to activate."));
        }
        return pOpenDocument;
    }

    if (pBestTemplate == NULL)
    {
        TCHAR szMsg[1024];
        AfxLoadString(AFX_IDP_FAILED_TO_OPEN_DOC, szMsg, sizeof(szMsg));
        AfxMessageBox(szMsg);
        return NULL;
    }

    return pBestTemplate->OpenDocumentFile(lpszFileName);

}  //*** CClusterAdminApp::OpenDocumentFile()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::AddToRecentFileList
//
//  Routine Description:
//      Adds a file to the Most Recently Used file list.  Overridden to
//      prevent the cluster name from being fully qualified as a file.
//
//  Arguments:
//      lpszPathName    [IN] The path of the file.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::AddToRecentFileList(LPCTSTR lpszPathName)
{
    ASSERT_VALID(this);
    ASSERT(lpszPathName != NULL);
    ASSERT(AfxIsValidString(lpszPathName));

    if (m_pRecentFileList != NULL)
    {
        // Don't fully qualify the path name.
        m_pRecentFileList->Add(lpszPathName);
    }

}  //*** CClusterAdminApp::AddToRecentFileList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::LoadClusCfgClient
//
//  Routine Description:
//      Makes sure that the ClusCfg client has been loaded.  This is
//      required because it can only be loaded once per process.
//
//      Note:  DavidP  21-AUG-2000  This is a hack, IMHO!
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::LoadClusCfgClient( void )
{
    HRESULT             hr;

    if ( m_punkClusCfgClient == NULL )
    {
        //
        // Get the service manager.
        //

        hr = CoCreateInstance(
                      CLSID_ServiceManager
                    , NULL
                    , CLSCTX_INPROC_SERVER
                    , IID_IUnknown
                    , reinterpret_cast< void ** >( &m_punkClusCfgClient )
                    );
        if ( FAILED( hr ) )
        {
            ThrowStaticException( hr, IDS_CREATE_CLUSCFGWIZ_OBJ_ERROR );
        } // if: error loading the ClusCfg client
    } // if: not loaded yet

} //*** CClusterAdminApp::LoadClusCfgClient()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnFileNewCluster
//
//  Routine Description:
//      Processes the ID_FILE_NEW_CLUSTER menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::OnFileNewCluster( void )
{
    HRESULT             hr;
    IClusCfgWizard *    piWiz;
    BOOL                fCommitted = FALSE;

    // Make sure the ClusCfg client has been loaded.
    LoadClusCfgClient();

    // Get an interface pointer for the wizard.
    hr = CoCreateInstance(
            CLSID_ClusCfgWizard,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IClusCfgWizard,
            (LPVOID *) &piWiz
            );
    if ( FAILED( hr ) )
    {
        CNTException nte( hr, IDS_CREATE_CLUSCFGWIZ_OBJ_ERROR, NULL, NULL, FALSE /*bAutoDelete*/ );
        nte.ReportError();
        return;
    }  // if:  error getting the interface pointer

    // Display the wizard.
    hr = piWiz->CreateCluster(
                    AfxGetMainWnd()->m_hWnd,
                    &fCommitted
                    );
    if ( FAILED( hr ) )
    {
        CNTException nte( hr, IDS_CREATE_CLUSTER_ERROR, NULL, NULL, FALSE /*bAutoDelete*/ );
        nte.ReportError();
    } // if: error adding cluster nodes

    if ( fCommitted )
    {
        BSTR bstrClusterName;
        hr = piWiz->get_ClusterName( &bstrClusterName );
        if ( FAILED( hr ) )
        {
            CNTException nte( hr, IDS_CREATE_CLUSTER_ERROR, NULL, NULL, FALSE /*bAutoDelete*/ );
            nte.ReportError();
        }
        else
        {
            if ( hr == S_OK )
            {
                HCLUSTER hCluster;

                ASSERT( bstrClusterName != NULL );

                // Open the cluster with the cluster name specified by the
                // wizard.  If it not successful, translate this to a NetBIOS
                // name in case that is more reliable.
                hCluster = OpenCluster( bstrClusterName );
                if ( hCluster == NULL )
                {
                    WCHAR   szClusterNetBIOSName[ MAX_COMPUTERNAME_LENGTH + 1 ];
                    DWORD   nSize = sizeof( szClusterNetBIOSName ) / sizeof( szClusterNetBIOSName[ 0 ] );

                    DnsHostnameToComputerName( bstrClusterName, szClusterNetBIOSName, &nSize );
                    SysFreeString( bstrClusterName );
                    bstrClusterName = SysAllocString( szClusterNetBIOSName );
                }
                else
                {
                    CloseCluster( hCluster );
                }
                OpenDocumentFile( bstrClusterName );
            } // if: retrieved cluster name successfully
            SysFreeString( bstrClusterName );
        } // else: retrieving cluster name didn't fail
    } // if: user didn't cancel the wizard

    piWiz->Release();

}  //*** CClusterAdminApp::OnFileNewCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnAppAbout
//
//  Routine Description:
//      Displays the about box.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::OnAppAbout(void)
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();

}  //*** CClusterAdminApp::OnAppAbout()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnUpdateWindowCloseAll
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_WINDOW_CLOSE_ALL
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::OnUpdateWindowCloseAll(CCmdUI * pCmdUI)
{
    pCmdUI->Enable(m_pDocTemplate->GetFirstDocPosition() != NULL);

}  //*** CClusterAdminApp::OnUpdateWindowCloseAll()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnWindowCloseAll
//
//  Routine Description:
//      Processes the ID_WINDOW_CLOSE_ALL menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::OnWindowCloseAll(void)
{
    CloseAllDocuments(FALSE /*bEndSession*/);

}  //*** CClusterAdminApp::OnWindowCloseAll()

#ifdef _DEBUG
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnTraceSettings
//
//  Routine Description:
//      Displays the Trace Settings dialog.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::OnTraceSettings(void)
{
    CTraceDialog    dlgTraceSettings;
    dlgTraceSettings.DoModal();

}  //*** CClusterAdminApp::OnTraceSettings()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnBarfSettings
//
//  Routine Description:
//      Displays the BARF Settings dialog.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::OnBarfSettings(void)
{
    DoBarfDialog();

}  //*** CClusterAdminApp::OnBarfSettings()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnBarfAllSettings
//
//  Routine Description:
//      Displays the BARF All Settings dialog.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::OnBarfAllSettings(void)
{
    BarfAll();

}  //*** CClusterAdminApp::OnBarfAllSettings()

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnClusterNotify
//
//  Routine Description:
//      Handler for the WM_CAM_CLUSTER_NOTIFY message.
//      Processes cluster notifications.
//
//  Arguments:
//      wparam      WPARAM.
//      LPARAM      LPARAM = CClusterNotify object describing the notification.
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CClusterAdminApp::OnClusterNotify(WPARAM wparam, LPARAM lparam)
{
    CClusterNotify *    pnotify = (CClusterNotify *) lparam;

    ASSERT(pnotify != NULL);
    ASSERT(pnotify->m_dwNotifyKey != NULL);

    // Send change notifications to the object that registered it.
    if (pnotify->m_pcnk != NULL)
    {
        // Find the notification key in our list of keys.  If it is not
        // found, ignore it.  Otherwise, ask the object that registered
        // the notification to handle it.
        if (Cnkl().Find(pnotify->m_pcnk) != NULL)
        {
            switch (pnotify->m_pcnk->m_cnkt)
            {
                case cnktDoc:
                    ASSERT_VALID(pnotify->m_pcnk->m_pdoc);
                    return pnotify->m_pcnk->m_pdoc->OnClusterNotify(pnotify);

                case cnktClusterItem:
                    ASSERT_VALID(pnotify->m_pcnk->m_pci);
                    ASSERT_VALID(pnotify->m_pcnk->m_pci->Pdoc());
                    return pnotify->m_pcnk->m_pci->OnClusterNotify(pnotify);
            }  // switch:  notification key type
        }  // if:  notification key found in the list
    }  // if:  non-NULL object pointer

    // Notification not handled.
    Trace(g_tagError, _T("*** Unhandled notification: key %08.8x, filter %x (%s) - '%s'"), pnotify->m_dwNotifyKey, pnotify->m_dwFilterType, PszNotificationName(pnotify->m_dwFilterType), pnotify->m_strName);
    delete pnotify;
    return 0;

}  //*** CClusterAdminApp::OnClusterNotify()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::BInitNotifyThread
//
//  Routine Description:
//      Initialize the cluster notification thread.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Thread initialized successfully.
//      FALSE       Thread NOT initialized successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAdminApp::BInitNotifyThread(void)
{
    try
    {
        // Create the notification port.
        m_hchangeNotifyPort = ::CreateClusterNotifyPort(
                                    (HCHANGE) INVALID_HANDLE_VALUE,     // hChange
                                    (HCLUSTER) INVALID_HANDLE_VALUE,    // hCluster
                                    0,                                  // dwFilter
                                    0                                   // dwNotifyKey
                                    );
        if (HchangeNotifyPort() == NULL)
            ThrowStaticException(GetLastError());

        // Construct the context object.
        Pcnctx()->m_hchangeNotifyPort = HchangeNotifyPort();
        Pcnctx()->m_hwndFrame = m_pMainWnd->m_hWnd;

        // Begin the thread.
        m_wtNotifyThread = AfxBeginThread(NotifyThreadProc, Pcnctx());
        if (WtNotifyThread() == NULL)
            ThrowStaticException(GetLastError());
    }  // try
    catch (CException * pe)
    {
        // Close the notify port.
        if (HchangeNotifyPort() != NULL)
        {
            ::CloseClusterNotifyPort(HchangeNotifyPort());
            m_hchangeNotifyPort = NULL;
        }  // if:  notify port is open

        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return TRUE;

}  //*** CClusterAdminApp::BInitNotifyThread()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::NotifyThreadProc (static)
//
//  Routine Description:
//      Notification thread procedure.
//
//  Arguments:
//      pParam      [IN OUT] Thread procedure parameter -- a notification
//                    context object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
UINT AFX_CDECL CClusterAdminApp::NotifyThreadProc(LPVOID pParam)
{
    DWORD                   dwStatus;
    WCHAR*                  pwszName;
    DWORD                   cchName;
    DWORD                   cchBuffer;
    DWORD_PTR               dwNotifyKey;
    DWORD                   dwFilterType;
    CClusterNotify *        pnotify = NULL;
    CClusterNotifyContext * pnctx   = (CClusterNotifyContext *) pParam;
#ifdef _DEBUG
    TCHAR *                 pszTracePrefix;
    CTraceTag *             ptag;
#endif

    ASSERT(pParam != NULL);
    ASSERT_KINDOF(CClusterNotifyContext, pnctx);
    ASSERT(pnctx->m_hchangeNotifyPort != NULL);
    ASSERT(pnctx->m_hwndFrame != NULL);

    pwszName = new WCHAR[1024];
    cchBuffer = 1024;

    ASSERT( pwszName != NULL );
    
    if ( pwszName == NULL )
    {
        AfxThrowMemoryException();
    } // if: memory exception

    for (;;)
    {
        cchName = cchBuffer;
        dwStatus = GetClusterNotify(
                        pnctx->m_hchangeNotifyPort,
                        &dwNotifyKey,
                        &dwFilterType,
                        pwszName,
                        &cchName,
                        INFINITE
                        );
                        
        if (dwStatus == ERROR_INVALID_HANDLE)
        {
            break;
        }

        if ( dwStatus == ERROR_MORE_DATA )
        {
            cchName++;              // add one for NULL
            
            ASSERT( cchName > cchBuffer ); 
            
            cchBuffer = cchName;

            // buffer was too small, reallocate
            delete [] pwszName;
            pwszName = new WCHAR[cchBuffer];

            ASSERT( pwszName != NULL );

            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: memory exception
            
            continue;
        }

        if (dwStatus != ERROR_SUCCESS)
        {
            TraceError(_T("CClusterAdminApp::NotifyThreadProc() %s"), dwStatus);
            continue;
        }  // if:  error getting notification

        try
        {
            pnotify = new CClusterNotify();
            ASSERT(pnotify != NULL);

            if (pnotify != NULL)
            {
                pnotify->m_dwNotifyKey = dwNotifyKey;
                pnotify->m_dwFilterType = dwFilterType;
                pnotify->m_strName = pwszName;
#ifdef _DEBUG
                pszTracePrefix = _T("");
                if (   (dwNotifyKey == NULL)
                    || (dwNotifyKey == 0xfeeefeee)
                    || (dwNotifyKey == 0xbaadf00d))
                {
                    ptag = &g_tagError;
                    pszTracePrefix = _T("*** NOTIFY THREAD ");
                }  // if:  bad notification key
                else if (dwFilterType & (CLUSTER_CHANGE_REGISTRY_NAME | CLUSTER_CHANGE_REGISTRY_ATTRIBUTES | CLUSTER_CHANGE_REGISTRY_VALUE))
                    ptag = &g_tagNotifyThreadReg;
                else
                    ptag = &g_tagNotifyThread;
                Trace(*ptag, _T("%sNotification - key %08.8x, filter %x (%s), %s"), pszTracePrefix, dwNotifyKey, dwFilterType, PszNotificationName(dwFilterType), pnotify->m_strName);
#endif
                if (!::PostMessage(
                            pnctx->m_hwndFrame,
                            WM_CAM_CLUSTER_NOTIFY,
                            NULL,
                            (LPARAM) pnotify
                            ))
                    delete pnotify;
            }  // if:  allocated object successfully
        }  // try
        catch (...)
        {
            if (pnotify != NULL)
            {
                delete pnotify;
                pnotify = NULL;
            }  // if:  notification record allocated
        }  // catch:  any exception
    }  // forever

    delete [] pwszName;

    return 0;

}  //*** CClusterAdminApp::NotifyThreadProc()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  BCreateFont
//
//  Routine Description:
//      Create a font.
//
//  Arguments:
//      rfont       [OUT] Font to create.
//      nPoints     [IN] Point size.
//      bBold       [IN] Flag specifying whether font is bold or not.
//
//  Return Value:
//      TRUE        Font created successfully.
//      FALSE       Error creating font.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL BCreateFont(OUT CFont & rfont, IN int nPoints, IN BOOL bBold)
{
    return rfont.CreateFont(
                    -nPoints,                           // nHeight
                    0,                                  // nWidth
                    0,                                  // nEscapement
                    0,                                  // nOrientation
                    (bBold ? FW_BOLD : FW_DONTCARE),    // nWeight
                    FALSE,                              // bItalic
                    FALSE,                              // bUnderline
                    FALSE,                              // cStrikeout
                    ANSI_CHARSET,                       // nCharSet
                    OUT_DEFAULT_PRECIS,                 // nOutPrecision
                    CLIP_DEFAULT_PRECIS,                // nClipPrecision
                    DEFAULT_QUALITY,                    // nQuality
                    DEFAULT_PITCH | FF_DONTCARE,        // nPitchAndFamily
                    _T("MS Shell Dlg")                  // lpszFaceName
                    );

}  //*** BCreateFont()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  NewNodeWizard
//
//  Routine Description:
//      Invoke the Add Nodes to Cluster Wizard.
//
//  Arguments:
//      pcszName        -- Name of cluster to add nodes to.
//      fIgnoreErrors   -- TRUE = don't display error messages.
//                          Defaults to FALSE.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void NewNodeWizard(
    LPCTSTR pcszName,
    BOOL    fIgnoreErrors   // = FALSE
    )
{
    HRESULT             hr;
    IClusCfgWizard *    pccwWiz;
    BSTR                bstrConnectName = NULL;
    BOOL                fCommitted = FALSE;

    // Make sure the ClusCfg client has been loaded.
    GetClusterAdminApp()->LoadClusCfgClient();

    // Get an interface pointer for the wizard.
    hr = CoCreateInstance(
            CLSID_ClusCfgWizard,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IClusCfgWizard,
            (void **) &pccwWiz
            );
    if ( FAILED( hr ) )
    {
        if ( ! fIgnoreErrors )
        {
            CNTException nte( hr, IDS_CREATE_CLUSCFGWIZ_OBJ_ERROR, NULL, NULL, FALSE /*bAutoDelete*/ );
            nte.ReportError();
        }
        return;
    } // if: error getting the interface pointer

    // TODO:    DavidP 24-AUG-2000
    // Get the FQDN of the cluster name.

    // Specify the name of the cluster we are going to add a node to.
    bstrConnectName = SysAllocString( pcszName );
    if ( bstrConnectName == NULL )
    {
        AfxThrowMemoryException();
    }
    hr = pccwWiz->put_ClusterName( bstrConnectName );
    if ( FAILED( hr ) )
    {
        if ( ! fIgnoreErrors )
        {
            CNTException nte( hr, IDS_ADD_NODES_TO_CLUSTER_ERROR, bstrConnectName, NULL, FALSE /*bAutoDelete*/ );
            nte.ReportError();
        }
    } // if: error setting the cluster name

    // Display the wizard.
    hr = pccwWiz->AddClusterNodes(
                    AfxGetMainWnd()->m_hWnd,
                    &fCommitted
                    );
    if ( FAILED( hr ) )
    {
        if ( ! fIgnoreErrors )
        {
            CNTException nte( hr, IDS_ADD_NODES_TO_CLUSTER_ERROR, bstrConnectName, NULL, FALSE /*bAutoDelete*/ );
            nte.ReportError();
        }
    } // if: error adding cluster nodes

    SysFreeString( bstrConnectName );
    pccwWiz->Release();

}  //*** NewNodeWizard()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\cluadmin.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      CluAdmin.h
//
//  Abstract:
//      Definition of the CClusterAdminApp class, which is the main
//      application class for the CLUADMIN application.
//
//  Author:
//      David Potter (davidp)   May 1, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUADMIN_H_
#define _CLUADMIN_H_

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#ifndef _UNICODE
    #error _UNICODE *must* be defined!
#endif

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESOURCE_H_
#include "resource.h"   // main symbols
#define _RESOURCE_H_
#endif

#ifndef _BARFCLUS_H_
#include "BarfClus.h"   // for BARF overrides of CLUSAPIs
#endif

#ifndef _NOTIFY_H_
#include "Notify.h"     // for CClusterNotifyContext, CClusterNotifyKeyList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterAdminApp;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CRecentClusterList;
class CCluAdminCommandLineInfo;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

enum ImageListIndex
{
    IMGLI_FOLDER = 0,
    IMGLI_CLUSTER,
    IMGLI_CLUSTER_UNKNOWN,
    IMGLI_NODE,
    IMGLI_NODE_DOWN,
    IMGLI_NODE_PAUSED,
    IMGLI_NODE_UNKNOWN,
    IMGLI_GROUP,
    IMGLI_GROUP_PARTIALLY_ONLINE,
    IMGLI_GROUP_PENDING,
    IMGLI_GROUP_OFFLINE,
    IMGLI_GROUP_FAILED,
    IMGLI_GROUP_UNKNOWN,
    IMGLI_RES,
    IMGLI_RES_OFFLINE,
    IMGLI_RES_PENDING,
    IMGLI_RES_FAILED,
    IMGLI_RES_UNKNOWN,
    IMGLI_RESTYPE,
    IMGLI_RESTYPE_UNKNOWN,
    IMGLI_NETWORK,
    IMGLI_NETWORK_PARTITIONED,
    IMGLI_NETWORK_DOWN,
    IMGLI_NETWORK_UNKNOWN,
    IMGLI_NETIFACE,
    IMGLI_NETIFACE_UNREACHABLE,
    IMGLI_NETIFACE_FAILED,
    IMGLI_NETIFACE_UNKNOWN,

    IMGLI_MAX
};

/////////////////////////////////////////////////////////////////////////////
// CClusterAdminApp:
// See CluAdmin.cpp for the implementation of this class
/////////////////////////////////////////////////////////////////////////////

class CClusterAdminApp : public CWinApp
{
    DECLARE_DYNAMIC( CClusterAdminApp );

public:
    CClusterAdminApp( void );

    CRecentClusterList *    PrclRecentClusterList( void)    { return (CRecentClusterList *) m_pRecentFileList; }

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClusterAdminApp)
    public:
    virtual BOOL InitInstance();
    virtual BOOL OnIdle(IN LONG lCount);
    virtual CDocument* OpenDocumentFile(LPCTSTR lpszFileName);
    virtual int ExitInstance();
    virtual void AddToRecentFileList(LPCTSTR lpszPathName);
    //}}AFX_VIRTUAL

// Implementation
#ifdef _CLUADMIN_USE_OLE_
    COleTemplateServer      m_server;
        // Server object for document creation
#endif

protected:
    CMultiDocTemplate *     m_pDocTemplate;
    CImageList              m_ilSmallImages;
    CImageList              m_ilLargeImages;
    HCHANGE                 m_hchangeNotifyPort;
    LCID                    m_lcid;
    CClusterNotifyKeyList   m_cnkl;
    CClusterNotifyContext   m_cnctx;
    CWinThread *            m_wtNotifyThread;
    HCLUSTER                m_hOpenedCluster;
    ULONG                   m_nIdleCount;

    // Indices of images in the image list.
    UINT                    m_rgiimg[IMGLI_MAX];

    IUnknown *              m_punkClusCfgClient;

    BOOL                    BInitNotifyThread(void);
    static UINT AFX_CDECL   NotifyThreadProc(LPVOID pParam);

    CClusterNotifyContext * Pcnctx(void)                        { return &m_cnctx; }
    CWinThread *            WtNotifyThread(void) const          { return m_wtNotifyThread; }

    BOOL                    ProcessShellCommand(IN OUT CCluAdminCommandLineInfo & rCmdInfo);
    void                    InitGlobalImageList(void);

public:
    CMultiDocTemplate *     PdocTemplate(void) const            { return m_pDocTemplate; }
    CImageList *            PilSmallImages(void)                { return &m_ilSmallImages; }
    CImageList *            PilLargeImages(void)                { return &m_ilLargeImages; }
    HCHANGE                 HchangeNotifyPort(void) const       { return m_hchangeNotifyPort; }
    LCID                    Lcid(void) const                    { return m_lcid; }
    CClusterNotifyKeyList & Cnkl(void)                          { return m_cnkl; }
    HCLUSTER                HOpenedCluster(void) const          { return m_hOpenedCluster; }

    // Indices of images in the image list.
    UINT                    Iimg(ImageListIndex imgli)          { return m_rgiimg[imgli]; }

    void                    LoadImageIntoList(
                                IN OUT CImageList * pil,
                                IN ID               idbImage,
                                IN UINT             imgli
                                );
    static void             LoadImageIntoList(
                                IN OUT CImageList * pil,
                                IN ID               idbImage,
                                OUT UINT *          piimg   = NULL
                                );

    void                    LoadClusCfgClient( void );

    void                    SaveConnections(void);
    afx_msg LRESULT         OnRestoreDesktop(WPARAM wparam, LPARAM lparam);
    afx_msg LRESULT         OnClusterNotify(WPARAM wparam, LPARAM lparam);

    //{{AFX_MSG(CClusterAdminApp)
    afx_msg void OnAppAbout();
    afx_msg void OnFileOpen();
    afx_msg void OnFileNewCluster();
    afx_msg void OnWindowCloseAll();
    afx_msg void OnUpdateWindowCloseAll(CCmdUI* pCmdUI);
    //}}AFX_MSG
#ifdef _DEBUG
    afx_msg void OnTraceSettings();
    afx_msg void OnBarfSettings();
    afx_msg void OnBarfAllSettings();
#endif
    DECLARE_MESSAGE_MAP()

};  //*** class CClusterAdminApp

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

BOOL BCreateFont(OUT CFont & rfont, IN int nPoints, IN BOOL bBold);
void NewNodeWizard( LPCTSTR pcszName, BOOL fIgnoreErrors = FALSE );

inline CClusterAdminApp * GetClusterAdminApp(void)
{
    ASSERT_KINDOF(CClusterAdminApp, AfxGetApp());
    return (CClusterAdminApp *) AfxGetApp();
}

inline CFrameWnd * PframeMain(void)
{
    return (CFrameWnd *) AfxGetMainWnd();
}

/////////////////////////////////////////////////////////////////////////////

#endif // _CLUADMIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\clusdoc.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ClusDoc.cpp
//
//  Abstract:
//      Implementation of the CClusterDoc class.
//
//  Author:
//      David Potter (davidp)   May 1, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <ClAdmWiz.h>
#include "CluAdmin.h"
#include "ConstDef.h"
#include "ClusDoc.h"
#include "Cluster.h"
#include "ExcOper.h"
#include "Notify.h"
#include "TraceTag.h"
#include "ListView.h"
#include "TreeView.h"
#include "GrpWiz.h"
#include "ResWiz.h"
#include "SplitFrm.h"
#include "YesToAll.h"
#include "ActGrp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagDoc(_T("Document"), _T("DOC"), 0);
CTraceTag   g_tagDocMenu(_T("Menu"), _T("DOC"), 0);
CTraceTag   g_tagDocNotify(_T("Notify"), _T("DOC NOTIFY"), 0);
CTraceTag   g_tagDocRegNotify(_T("Notify"), _T("DOC REG NOTIFY"), 0);
CTraceTag   g_tagDocRefresh(_T("Document"), _T("REFRESH"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterDoc
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CClusterDoc, CDocument)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CClusterDoc, CDocument)
    //{{AFX_MSG_MAP(CClusterDoc)
    ON_COMMAND(ID_FILE_NEW_GROUP, OnCmdNewGroup)
    ON_COMMAND(ID_FILE_NEW_RESOURCE, OnCmdNewResource)
    ON_COMMAND(ID_FILE_NEW_NODE, OnCmdNewNode)
    ON_COMMAND(ID_FILE_CONFIG_APP, OnCmdConfigApp)
    ON_COMMAND(ID_VIEW_REFRESH, OnCmdRefresh)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::CClusterDoc
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterDoc::CClusterDoc(void)
{
    m_hcluster = NULL;
    m_hkeyCluster = NULL;
    m_pciCluster = NULL;
    m_ptiCluster = NULL;

    m_hmenuCluster = NULL;
    m_hmenuNode = NULL;
    m_hmenuGroup = NULL;
    m_hmenuResource = NULL;
    m_hmenuResType = NULL;
    m_hmenuNetwork = NULL;
    m_hmenuNetIFace = NULL;
    m_hmenuCurrent = NULL;
    m_idmCurrentMenu = 0;

    m_bUpdateFrameNumber = TRUE;
    m_bInitializing = TRUE;
    m_bIgnoreErrors = FALSE;

    m_bClusterAvailable = FALSE;

    EnableAutomation();

}  //*** CClusterDoc::CClusterDoc()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::~CClusterDoc
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterDoc::~CClusterDoc(void)
{
    // Destroy any menus we loaded.
    if (m_hmenuCluster != NULL)
        DestroyMenu(m_hmenuCluster);
    if (m_hmenuNode != NULL)
        DestroyMenu(m_hmenuNode);
    if (m_hmenuGroup != NULL)
        DestroyMenu(m_hmenuGroup);
    if (m_hmenuResource != NULL)
        DestroyMenu(m_hmenuResource);
    if (m_hmenuResType != NULL)
        DestroyMenu(m_hmenuResType);
    if (m_hmenuNetwork != NULL)
        DestroyMenu(m_hmenuNetwork);
    if (m_hmenuNetIFace != NULL)
        DestroyMenu(m_hmenuNetIFace);

    delete m_pciCluster;

}  //*** CClusterDoc::~CClusterDoc()

/////////////////////////////////////////////////////////////////////////////
// CClusterDoc diagnostics

#ifdef _DEBUG
void CClusterDoc::AssertValid(void) const
{
    CDocument::AssertValid();
}

void CClusterDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnOpenDocument
//
//  Routine Description:
//      Open a cluster.
//
//  Arguments:
//      lpszPathName    [IN] Name of the cluster to open.
//
//  Return Value:
//      TRUE            Cluster opened successfully.
//      FALSE           Failed to open the cluster.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
    BOOL        bSuccess    = TRUE;
    CWaitCursor wc;

    ASSERT(Hcluster() == NULL);
    ASSERT(HkeyCluster() == NULL);

    // There better be a cluster name.
    ASSERT(lpszPathName != NULL);
    ASSERT(*lpszPathName != _T('\0'));

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage(IDS_SB_OPENING_CONNECTION, lpszPathName);
        PframeMain()->SetMessageText(strStatusBarText);
        PframeMain()->UpdateWindow();
    }  // Display a message on the status bar

    // If the application is minimized, don't display message boxes
    // on errors.
    m_bIgnoreErrors = AfxGetMainWnd()->IsIconic() == TRUE;

    try
    {
        OnOpenDocumentWorker(lpszPathName);
    }  // try
    catch (CException * pe)
    {
        if (!m_bIgnoreErrors)
            pe->ReportError();
        pe->Delete();
        if (HkeyCluster() != NULL)
        {
            ClusterRegCloseKey(HkeyCluster());
            m_hkeyCluster = NULL;
        }  // if:  cluster registry key is open
        if ((Hcluster() != NULL) && (Hcluster() != GetClusterAdminApp()->HOpenedCluster()))
        {
            CloseCluster(Hcluster());
            m_hcluster = NULL;
        }  // if:  cluster is open
        m_bClusterAvailable = FALSE;
        bSuccess = FALSE;
    }  // catch:  CException

    // Reset the message on the status bar.
    PframeMain()->SetMessageText(AFX_IDS_IDLEMESSAGE);
    PframeMain()->UpdateWindow();

    m_bInitializing = FALSE;

    return bSuccess;

}  //*** CClusterDoc::OnOpenDocument()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnOpenDocumentWorker
//
//  Routine Description:
//      Worker function for opening a cluster.
//
//  Arguments:
//      lpszPathName    [IN] Name of the cluster to open.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CString::operator=(), CCluster::new(),
//      CCluster::Init(), BuildBaseHierarchy(), or CollectClusterItems().
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::OnOpenDocumentWorker(LPCTSTR lpszPathName)
{
    // Set the node name to the path name.
    m_strNode = lpszPathName;

    // Delete the contents to start out with an empty document.
    DeleteContents();

    m_bClusterAvailable = TRUE;

    // Create a new cluster object.
    m_pciCluster = new CCluster;
    if ( m_pciCluster == NULL )
    {
        AfxThrowMemoryException();
    } // if: error allocating the cluster object
    PciCluster()->AddRef();
    PciCluster()->Init(this, lpszPathName, GetClusterAdminApp()->HOpenedCluster());

    // Build the base hierarchy.
    BuildBaseHierarchy();

    // Collect the items in the cluster and build the hierarchy.
    CollectClusterItems();

    // Collect network priority list.
    PciCluster()->CollectNetworkPriority(NULL);

    // Open new windows if there were more open when we exited.
    {
        int         iwin;
        int         cwin;
        CString     strSection;

        strSection = REGPARAM_CONNECTIONS _T("\\") + StrNode();
        cwin = AfxGetApp()->GetProfileInt(strSection, REGPARAM_WINDOW_COUNT, 1);
        for (iwin = 1 ; iwin < cwin ; iwin++)
            AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_WINDOW_NEW, NULL);
    }  // Open new windows if there were more open when we exited

    // Initialize the frame window.
    {
        POSITION            pos;
        CView *             pview;
        CSplitterFrame *    pframe;

        pos = GetFirstViewPosition();
        pview = GetNextView(pos);
        ASSERT_VALID(pview);
        pframe = (CSplitterFrame *) pview->GetParentFrame();
        ASSERT_KINDOF(CSplitterFrame, pframe);
        pframe->InitFrame(this);
    }  // Initialize the frame window

}  //*** CClusterDoc::OnOpenDocumentWorker()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnCloseDocument
//
//  Routine Description:
//      Close a cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::OnCloseDocument(void)
{
    TraceMenu(g_tagDocMenu, AfxGetMainWnd()->GetMenu(), _T("OnCloseDocument menu: "));
    m_bUpdateFrameNumber = FALSE;
    CDocument::OnCloseDocument();
    TraceMenu(g_tagDocMenu, AfxGetMainWnd()->GetMenu(), _T("Post-OnCloseDocument menu: "));

}  //*** CClusterDoc::OnCloseDocument()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::SaveSettings
//
//  Routine Description:
//      Save settings so they can be restored later.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::SaveSettings(void)
{
    int         cwin = 0;
    POSITION    pos;
    CView *     pview;
    CString     strSection;

    try
    {
        // Save the number of windows open on this document.
        strSection = REGPARAM_CONNECTIONS _T("\\") + StrNode();
        pos = GetFirstViewPosition();
        while (pos != NULL)
        {
            pview = GetNextView(pos);
            ASSERT_VALID(pview);
            if (pview->IsKindOf(RUNTIME_CLASS(CClusterTreeView)))
                cwin++;
        }  // while:  more views in the list
        AfxGetApp()->WriteProfileInt(strSection, REGPARAM_WINDOW_COUNT, cwin);
    }  // try
    catch (CException * pe)
    {
        pe->Delete();
    }  // catch:  CException

}  //*** CClusterDoc::SaveSettings()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::BuildBaseHierarchy
//
//  Routine Description:
//      Build the base hierarchy.  This hierarchy consists of tree items
//      for the hierarchy and list items for what is displayed in the list
//      view but does not contain any items for specific objects, other
//      than the cluster itself.
//
//  Arguments:
//      None.
//
//  Return Value:
//      dwStatus    Status of the operation: 0 if successful, !0 otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::BuildBaseHierarchy(void)
{
    ASSERT_VALID(PciCluster());
    ASSERT(PtiCluster() == NULL);

    // Create the root cluster item.
    {
        ASSERT_VALID(PciCluster());
        PciCluster()->ReadItem();
        m_ptiCluster = new CTreeItem(NULL, PciCluster());
        if ( m_ptiCluster == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating tree item
        m_ptiCluster->AddRef();
        ASSERT_VALID(PtiCluster());
        PciCluster()->AddTreeItem(PtiCluster());
        PtiCluster()->Init();
        PtiCluster()->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//      PtiCluster()->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
        PtiCluster()->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
        PtiCluster()->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);
    }  // Create the root cluster item

    // Add the Groups container item under the cluster.
    {
        CTreeItem * ptiGroups;

        // Create the Groups container item.
        ptiGroups = PtiCluster()->PtiAddChild(IDS_TREEITEM_GROUPS);
        ASSERT_VALID(ptiGroups);
        ptiGroups->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//      ptiGroups->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
        ptiGroups->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
        ptiGroups->PcoliAddColumn(IDS_COLTEXT_OWNER, COLI_WIDTH_OWNER);
        ptiGroups->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

    }  // Add the Groups container item under the cluster

    // Add the Resources container item under the cluster.
    {
        CTreeItem * ptiResources;

        // Create the Resources container item.
        ptiResources = PtiCluster()->PtiAddChild(IDS_TREEITEM_RESOURCES);
        ASSERT_VALID(ptiResources);
        ptiResources->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//      ptiResources->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
        ptiResources->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
        ptiResources->PcoliAddColumn(IDS_COLTEXT_OWNER, COLI_WIDTH_OWNER);
        ptiResources->PcoliAddColumn(IDS_COLTEXT_GROUP, COLI_WIDTH_GROUP);
        ptiResources->PcoliAddColumn(IDS_COLTEXT_RESTYPE, COLI_WIDTH_RESTYPE);
        ptiResources->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

    }  // Add the Resources container item under the cluster

    // Add the Cluster Configuration container item under the cluster.
    {
        CTreeItem * ptiClusCfg;

        // Create the Cluster Configuration container item.
        ptiClusCfg = PtiCluster()->PtiAddChild(IDS_TREEITEM_CLUSTER_CONFIG);
        ASSERT_VALID(ptiClusCfg);
        ptiClusCfg->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//      ptiClusCfg->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
        ptiClusCfg->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

        // Add the Resources Types container item under the Cluster Configuration container.
        {
            CTreeItem * ptiResTypes;

            // Create the Resources Types container item.
            ptiResTypes = ptiClusCfg->PtiAddChild(IDS_TREEITEM_RESTYPES);
            ASSERT_VALID(ptiResTypes);
            ptiResTypes->PcoliAddColumn(IDS_COLTEXT_DISPLAY_NAME, COLI_WIDTH_DISPLAY_NAME);
//          ptiResTypes->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//          ptiResTypes->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
            ptiResTypes->PcoliAddColumn(IDS_COLTEXT_RESDLL, COLI_WIDTH_RESDLL);
            ptiResTypes->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

        }  // Add the Resources Types container item under the Cluster Configuration container

        // Add the Networks container item under the Cluster Configuration container.
        {
            CTreeItem * ptiNetworks;

            // Create the Networks container item.
            ptiNetworks = ptiClusCfg->PtiAddChild(IDS_TREEITEM_NETWORKS);
            ASSERT_VALID(ptiNetworks);
            ptiNetworks->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//          ptiNetworks->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
            ptiNetworks->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
            ptiNetworks->PcoliAddColumn(IDS_COLTEXT_ROLE, COLI_WIDTH_NET_ROLE);
//          ptiNetworks->PcoliAddColumn(IDS_COLTEXT_ADDRESS, COLI_WIDTH_NET_ADDRESS);
            ptiNetworks->PcoliAddColumn(IDS_COLTEXT_MASK, COLI_WIDTH_NET_MASK);
            ptiNetworks->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

        }  // Add the Networks container item under the Cluster Configuration container

        // Add the Network Interfaces container item under the Cluster Configuration container.
        {
            CTreeItem * ptiNetworkInterfacess;

            // Create the Network Interfaces container item.
            ptiNetworkInterfacess = ptiClusCfg->PtiAddChild(IDS_TREEITEM_NETIFACES);
            ASSERT_VALID(ptiNetworkInterfacess);
            ptiNetworkInterfacess->PcoliAddColumn(IDS_COLTEXT_NODE, COLI_WIDTH_NODE);
            ptiNetworkInterfacess->PcoliAddColumn(IDS_COLTEXT_NETWORK, COLI_WIDTH_NETWORK);
//          ptiNetworkInterfacess->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
            ptiNetworkInterfacess->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
            ptiNetworkInterfacess->PcoliAddColumn(IDS_COLTEXT_ADAPTER, COLI_WIDTH_NET_ADAPTER);
            ptiNetworkInterfacess->PcoliAddColumn(IDS_COLTEXT_ADDRESS, COLI_WIDTH_NET_ADDRESS);
            ptiNetworkInterfacess->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

        }  // Add the Network Interfaces container item under the Cluster Configuration container

    }  // Add the Cluster Configuration container item under the cluster

}  //*** CClusterDoc::BuildBaseHierarchy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::CollectClusterItems
//
//  Routine Description:
//      Collect items in the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Status from ClusterOpenEnum or ClusterEnum.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::CollectClusterItems(void)
{
    DWORD           dwStatus;
    HCLUSENUM       hclusenum;
    ClusEnumType    cet;
    int             ienum;
    LPWSTR          pwszName = NULL;
    DWORD           cchName;
    DWORD           cchmacName;

    // Open the enumeration.
    hclusenum = ClusterOpenEnum(
                        Hcluster(),
                        ( CLUSTER_ENUM_NODE
                        | CLUSTER_ENUM_GROUP
                        | CLUSTER_ENUM_RESOURCE
                        | CLUSTER_ENUM_RESTYPE
                        | CLUSTER_ENUM_NETWORK
                        | CLUSTER_ENUM_NETINTERFACE
                        )
                        );
    if (hclusenum == NULL)
        ThrowStaticException(GetLastError(), IDS_OPEN_CLUSTER_ENUM_ERROR, StrName());

    try
    {
        // Allocate a buffer for object names.
        cchmacName = 128;
        pwszName = new WCHAR[cchmacName];
        if ( pwszName == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the name buffer

        // Loop through the enumeration and add each item to the appropriate list.
        for (ienum = 0 ; ; ienum++)
        {
            cchName = cchmacName;
            dwStatus = ClusterEnum(hclusenum, ienum, &cet, pwszName, &cchName);
            if (dwStatus == ERROR_MORE_DATA)
            {
                Trace(g_tagDoc, _T("OnOpenDocument() - name buffer too small.  Expanding from %d to %d"), cchmacName, cchName);
                delete [] pwszName;
                pwszName = NULL;
                cchmacName = cchName + 1;
                pwszName = new WCHAR[cchmacName];
                if ( pwszName == NULL )
                {
                    AfxThrowMemoryException();
                } // if: error allocating the name buffer
                cchName = cchmacName;
                dwStatus = ClusterEnum(hclusenum, ienum, &cet, pwszName, &cchName);
            }  // if:  name buffer was too small
            if (dwStatus == ERROR_NO_MORE_ITEMS)
                break;
            else if (dwStatus != ERROR_SUCCESS)
                ThrowStaticException(dwStatus, IDS_ENUM_CLUSTER_ERROR, StrName());

            switch (cet)
            {
                case CLUSTER_ENUM_NODE:
                    PciAddNewNode(pwszName);
                    break;

                case CLUSTER_ENUM_GROUP:
                    PciAddNewGroup(pwszName);
                    break;

                case CLUSTER_ENUM_RESOURCE:
                    PciAddNewResource(pwszName);
                    break;

                case CLUSTER_ENUM_RESTYPE:
                    PciAddNewResourceType(pwszName);
                    break;

                case CLUSTER_ENUM_NETWORK:
                    PciAddNewNetwork(pwszName);
                    break;

                case CLUSTER_ENUM_NETINTERFACE:
                    PciAddNewNetInterface(pwszName);
                    break;

                default:
                    Trace(g_tagDoc, _T("OnOpenDocument() - Unknown cluster enumeration type '%d'"), cet);
                    ASSERT(0);
                    break;

            }  // switch:  cet
        }  // for:  each item enumerated

        // Initialize all the cluster items.
        InitNodes();
        InitGroups();
        InitResourceTypes();
        InitResources();
        InitNetworks();
        InitNetInterfaces();

        // Deallocate our name buffer.
        delete [] pwszName;

        // Close the enumerator.
        ClusterCloseEnum(hclusenum);

    }  // try
    catch (CException *)
    {
        delete [] pwszName;
        ClusterCloseEnum(hclusenum);
        throw;
    }  // catch:  any exception

}  //*** CClusterDoc::CollectClusterItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::PciAddNewNode
//
//  Routine Description:
//      Add a new node to the list of nodes.
//
//  Arguments:
//      pszName     [IN] Name of the node.
//
//  Return Value:
//      pci         Cluster item for the new node.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNode * CClusterDoc::PciAddNewNode(IN LPCTSTR pszName)
{
    CClusterNode *  pciNewNode = NULL;
    CClusterNode *  pciRetNode = NULL;
    CClusterNode *  pciOldNode = NULL;
    CActiveGroups * pciActiveGroups = NULL;
    CTreeItem *     ptiActiveGroups = NULL;

    ASSERT(pszName != NULL);
    ASSERT(*pszName != NULL);
    ASSERT_VALID(PtiCluster());
    ASSERT(LpciNodes().PciNodeFromName(pszName) == NULL);

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage(IDS_SB_ADDING_NODE, pszName, StrNode());
        PframeMain()->SetMessageText(strStatusBarText);
        PframeMain()->UpdateWindow();
    }  // Display a message on the status bar

    try
    {
        // If there is an item with that name, delete it.
        pciOldNode = LpciNodes().PciNodeFromName(pszName);
        if (pciOldNode != NULL)
        {
            pciOldNode->Delete();
            pciOldNode = NULL;
        }  // if:  already an item with that name

        // Allocate a new node.
        pciNewNode = new CClusterNode;
        if ( pciNewNode == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the node

        // Add a reference while we are working on it to prevent a delete
        // notification from taking us out.
        pciNewNode->AddRef();

        // Initialize the node.
        pciNewNode->Init(this, pszName);
    }  // try
    catch (CNTException * pnte)
    {
        if (pnte->Sc() == RPC_S_CALL_FAILED)
        {
            if (!m_bIgnoreErrors)
                pnte->ReportError();
            delete pciNewNode;
            throw;
        }  // if:  RPC call failed error
        else if (pnte->Sc() != ERROR_FILE_NOT_FOUND)
        {
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                delete pciNewNode;
                throw;
            }  // if:  user doesn't want to ignore error
        }  // else if:  error is NOT node not found
        else
        {
            delete pciNewNode;
            pnte->Delete();
            return NULL;
        }  // else:  object not found
        pnte->Delete();
    }  // catch:  CNTException
    catch (CException * pe)
    {
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
        {
            delete pciNewNode;
            throw;
        }  // if:  user doesn't want to ignore error
        pe->Delete();
        if (pciNewNode == NULL)
            return NULL;
    }  // catch:  CException

    try
    {
        // Add the node to the list.
        {
            POSITION        posPci;
            POSITION        posCurPci;

            posPci = LpciNodes().GetHeadPosition();
            while (posPci != NULL)
            {
                posCurPci = posPci;
                pciOldNode = (CClusterNode *) LpciNodes().GetNext(posPci);
                ASSERT_VALID(pciOldNode);
                if (pciOldNode->StrName().CompareNoCase(pszName) > 0)
                {
                    LpciNodes().InsertBefore(posCurPci, pciNewNode);
                    break;
                }  // if:  new node before this node
                pciOldNode = NULL;
            }  // while:  more items in the list
            if (pciOldNode == NULL)
                LpciNodes().AddTail(pciNewNode);
        }  // Add the node to the list

        // Save this node as a return value now that we have added it to the list
        pciRetNode = pciNewNode;
        pciNewNode = NULL;

        // Insert the item in the tree.
        {
            CTreeItem *     ptiNode;
            CTreeItem *     ptiChild;

            ptiNode = PtiCluster()->PtiAddChildBefore(pciOldNode, pciRetNode);
            ASSERT_VALID(ptiNode);
            ptiNode->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);

            // Add the Active Groups container under the node.
            {
                CString     strName;

                // Create the Active Groups container cluster item.
                strName.LoadString(IDS_TREEITEM_ACTIVEGROUPS);
                pciActiveGroups = new CActiveGroups;
                if ( pciActiveGroups == NULL )
                {
                    AfxThrowMemoryException();
                } // if: Error allocating the active groups objct
                pciActiveGroups->Init(this, strName, pciRetNode);

                // Add the tree item for the container.
                ptiActiveGroups = ptiNode->PtiAddChild(pciActiveGroups, TRUE /*bTakeOwnership*/);
                ASSERT_VALID(ptiActiveGroups);
                ptiActiveGroups->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//              ptiActiveGroups->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
                ptiActiveGroups->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
                ptiActiveGroups->PcoliAddColumn(IDS_COLTEXT_OWNER, COLI_WIDTH_OWNER);
                ptiActiveGroups->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

            }  // Add the Active Groups container under the node.

            // Add the Active Resources container under the node.
            {
                ptiChild = ptiNode->PtiAddChild(IDS_TREEITEM_ACTIVERESOURCES);
                ASSERT_VALID(ptiChild);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//              ptiChild->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_OWNER, COLI_WIDTH_OWNER);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_GROUP, COLI_WIDTH_GROUP);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_RESTYPE, COLI_WIDTH_RESTYPE);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

            }  // Add the Active Resources container under the node.

            // Add the Network Interfaces container under the node.
            {
                ptiChild = ptiNode->PtiAddChild(IDS_TREEITEM_NETIFACES);
                ASSERT_VALID(ptiChild);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_NODE, COLI_WIDTH_NODE);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_NETWORK, COLI_WIDTH_NETWORK);
//              ptiChild->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_ADAPTER, COLI_WIDTH_NET_ADAPTER);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_ADDRESS, COLI_WIDTH_NET_ADDRESS);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);
            }  // Add the Network Interfaces container under the node

            // Add the Physical Devices container under the node.
            {
//              ptiChild = ptiNode->PtiAddChild(IDS_TREEITEM_PHYSDEVS);
//              ASSERT_VALID(ptiChild);
//              AddDefaultColumns(ptiChild);

            }  // Add the Physical Devices container under the node.
        }  // Insert the item in the tree
    }  // try
    catch (CException * pe)
    {
        // If the Active Groups container has been created, clean up the
        // reference to the node object we are creating.  If the tree
        // item hasn't been created yet, we still own the cluster item,
        // so delete that as well.
        if (pciActiveGroups != NULL)
        {
            pciActiveGroups->Cleanup();
            if (ptiActiveGroups == NULL)
                delete pciActiveGroups;
        }  // if:  Active Groups container created
        delete pciNewNode;
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
            throw;
        pe->Delete();
    }  // catch:  CException

    if (pciRetNode != NULL)
        pciRetNode->Release();

    return pciRetNode;

}  //*** CClusterDoc::PciAddNewNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::PciAddNewGroup
//
//  Routine Description:
//      Add a new group to the list of groups.
//
//  Arguments:
//      pszName     [IN] Name of the group.
//
//  Return Value:
//      pci         Cluster item for the new group.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGroup * CClusterDoc::PciAddNewGroup(IN LPCTSTR pszName)
{
    CGroup *    pciNewGroup = NULL;
    CGroup *    pciRetGroup = NULL;
    CGroup *    pciOldGroup = NULL;

    ASSERT(pszName != NULL);
    ASSERT(*pszName != NULL);

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage(IDS_SB_ADDING_GROUP, pszName, StrNode());
        PframeMain()->SetMessageText(strStatusBarText);
        PframeMain()->UpdateWindow();
    }  // Display a message on the status bar

    try
    {
        // If there is an item with that name, delete it.
        pciOldGroup = LpciGroups().PciGroupFromName(pszName);
        if (pciOldGroup != NULL)
        {
            Trace(g_tagGroup, _T("Deleting existing group '%s' (%x) before adding new instance"), pszName, pciOldGroup);
            pciOldGroup->Delete();
            pciOldGroup = NULL;
        }  // if:  already an item with that name

        // Allocate a new group.
        pciNewGroup = new CGroup;
        if ( pciNewGroup == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the group object

        // Add a reference while we are working on it to prevent a delete
        // notification from taking us out.
        pciNewGroup->AddRef();

        // Initialize the group and add it to the list.
        pciNewGroup->Init(this, pszName);
    }  // try
    catch (CNTException * pnte)
    {
        if (pnte->Sc() == RPC_S_CALL_FAILED)
        {
            if (!m_bIgnoreErrors)
                pnte->ReportError();
            delete pciNewGroup;
            throw;
        }  // if:  RPC call failed error
        else if (pnte->Sc() != ERROR_GROUP_NOT_FOUND)
        {
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                delete pciNewGroup;
                throw;
            }  // if:  user doesn't want to ignore error
        }  // else if:  error is NOT group not found
        else
        {
            delete pciNewGroup;
            pnte->Delete();
            return NULL;
        }  // else:  object not found
        pnte->Delete();
    }  // catch:  CNTException
    catch (CException * pe)
    {
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
        {
            delete pciNewGroup;
            throw;
        }  // if:  user doesn't want to ignore error
        pe->Delete();
        if (pciNewGroup == NULL)
            return NULL;
    }  // catch:  CException

    try
    {
        // Add the group to the list.
        {
            POSITION    posPci;
            POSITION    posCurPci;

            posPci = LpciGroups().GetHeadPosition();
            while (posPci != NULL)
            {
                posCurPci = posPci;
                pciOldGroup = (CGroup *) LpciGroups().GetNext(posPci);
                ASSERT_VALID(pciOldGroup);
                if (pciOldGroup->StrName().CompareNoCase(pszName) > 0)
                {
                    LpciGroups().InsertBefore(posCurPci, pciNewGroup);
                    break;
                }  // if:  new group before this group
                pciOldGroup = NULL;
            }  // while:  more items in the list
            if (pciOldGroup == NULL)
                LpciGroups().AddTail(pciNewGroup);
        }  // Add the group to the list

        // Save this group as a return value now that we have added it to the list
        pciRetGroup = pciNewGroup;
        pciNewGroup = NULL;

        // Insert the item in the tree.
        {
            CTreeItem *     ptiGroups;
            CTreeItem *     ptiGroup;

            // Find the Groups container tree item.
            ptiGroups = PtiCluster()->PtiChildFromName(IDS_TREEITEM_GROUPS);
            ASSERT_VALID(ptiGroups);

            // Add the item before the found item we inserted it into in the groups list.
            ptiGroup = ptiGroups->PtiAddChildBefore(pciOldGroup, pciRetGroup);
            ASSERT_VALID(ptiGroup);
            ptiGroup->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//          ptiGroup->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
            ptiGroup->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
            ptiGroup->PcoliAddColumn(IDS_COLTEXT_OWNER, COLI_WIDTH_OWNER);
            ptiGroup->PcoliAddColumn(IDS_COLTEXT_RESTYPE, COLI_WIDTH_RESTYPE);
            ptiGroup->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

        }  // Insert the item in the tree
    }  // try
    catch (CException * pe)
    {
        delete pciNewGroup;
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
            throw;
        pe->Delete();
    }  // catch:  CException

    if (pciRetGroup != NULL)
        pciRetGroup->Release();

    return pciRetGroup;

}  //*** CClusterDoc::PciAddNewGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::PciAddNewResource
//
//  Routine Description:
//      Add a new resource to the list of groups.
//
//  Arguments:
//      pszName     [IN] Name of the resource.
//
//  Return Value:
//      pci         Cluster item for the new resource.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResource * CClusterDoc::PciAddNewResource(IN LPCTSTR pszName)
{
    CResource * pciNewRes = NULL;
    CResource * pciRetRes = NULL;
    CResource * pciOldRes;

    ASSERT(pszName != NULL);
    ASSERT(*pszName != NULL);

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage(IDS_SB_ADDING_RESOURCE, pszName, StrNode());
        PframeMain()->SetMessageText(strStatusBarText);
        PframeMain()->UpdateWindow();
    }  // Display a message on the status bar

    try
    {
        // If there is an item with that name, delete it.
        pciOldRes = LpciResources().PciResFromName(pszName);
        if (pciOldRes != NULL)
        {
            if (pciOldRes->BInitializing())
                return pciOldRes;
            Trace(g_tagResource, _T("Deleting existing resource '%s' (%x) before adding new instance"), pszName, pciOldRes);
            pciOldRes->Delete();
            pciOldRes = NULL;
        }  // if:  already an item with that name

        // Allocate a new resource.
        pciNewRes = new CResource;
        if ( pciNewRes == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the resource object

        // Add a reference while we are working on it to prevent a delete
        // notification from taking us out.
        pciNewRes->AddRef();

        // Initialize the resource and add it to the list.
        pciNewRes->Init(this, pszName);
    }  // try
    catch (CNTException * pnte)
    {
        //DebugBreak();
        if (pnte->Sc() == RPC_S_CALL_FAILED)
        {
            if (!m_bIgnoreErrors)
                pnte->ReportError();
            delete pciNewRes;
            throw;
        }  // if:  RPC call failed error
        else if (pnte->Sc() != ERROR_RESOURCE_NOT_FOUND)
        {
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                delete pciNewRes;
                throw;
            }  // if:  user doesn't want to ignore error
        }  // else if:  error is NOT resource not found
        else
        {
            delete pciNewRes;
            pnte->Delete();
            return NULL;
        }  // else:  object not found
        pnte->Delete();
    }  // catch:  CNTException
    catch (CException * pe)
    {
        //DebugBreak();
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
        {
            delete pciNewRes;
            throw;
        }  // if:  user doesn't want to ignore error
        pe->Delete();
        if (pciNewRes == NULL)
            return NULL;
    }  // catch:  CException

    try
    {
        // Add the resource to the list.
        {
            POSITION    posPci;
            POSITION    posCurPci;
            CResource * pciOldRes   = NULL;

            posPci = LpciResources().GetHeadPosition();
            while (posPci != NULL)
            {
                posCurPci = posPci;
                pciOldRes = (CResource *) LpciResources().GetNext(posPci);
                ASSERT_VALID(pciOldRes);
                if (pciOldRes->StrName().CompareNoCase(pszName) > 0)
                {
                    LpciResources().InsertBefore(posCurPci, pciNewRes);
                    break;
                }  // if:  new resource before this resource
                pciOldRes = NULL;
            }  // while:  more items in the list
            if (pciOldRes == NULL)
                LpciResources().AddTail(pciNewRes);
        }  // Add the resource to the list

        // Save this resource as a return value now that we have added it to the list
        pciRetRes = pciNewRes;
        pciNewRes = NULL;

        // Insert the item in the tree.
        {
            CTreeItem *     ptiResources;

            // Find the Resources container tree item.
            ptiResources = PtiCluster()->PtiChildFromName(IDS_TREEITEM_RESOURCES);
            ASSERT_VALID(ptiResources);

            // Add the item to the list of children.
            VERIFY(ptiResources->PliAddChild(pciRetRes) != NULL);

        }  // Insert the item in the tree
    }  // try
    catch (CException * pe)
    {
        delete pciNewRes;
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
            throw;
        pe->Delete();
    }  // catch:  CException

    if (pciRetRes != NULL)
        pciRetRes->Release();

    return pciRetRes;

}  //*** CClusterDoc::PciAddNewResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::PciAddNewResourceType
//
//  Routine Description:
//      Add a new resource type to the list of groups.
//
//  Arguments:
//      pszName     [IN] Name of the resource type.
//
//  Return Value:
//      pci         Cluster item for the new resource type.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResourceType * CClusterDoc::PciAddNewResourceType(IN LPCTSTR pszName)
{
    CResourceType * pciNewResType = NULL;
    CResourceType * pciRetResType = NULL;
    CResourceType * pciOldResType;

    ASSERT(pszName != NULL);
    ASSERT(*pszName != NULL);
    ASSERT(LpciResourceTypes().PciResTypeFromName(pszName) == NULL);

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage(IDS_SB_ADDING_RESTYPE, pszName, StrNode());
        PframeMain()->SetMessageText(strStatusBarText);
        PframeMain()->UpdateWindow();
    }  // Display a message on the status bar

    try
    {
        // If there is an item with that name, delete it.
        pciOldResType = LpciResourceTypes().PciResTypeFromName(pszName);
        if (pciOldResType != NULL)
        {
            pciOldResType->Delete();
            pciOldResType = NULL;
        }  // if:  already an item with that name

        // Allocate a new resource type.
        pciNewResType = new CResourceType;
        if ( pciNewResType == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the resource type object

        // Add a reference while we are working on it to prevent a delete
        // notification from taking us out.
        pciNewResType->AddRef();

        // Initialize the resource type and add it to the list.
        pciNewResType->Init(this, pszName);
    }  // try
    catch (CNTException * pnte)
    {
        //DebugBreak();
        if (pnte->Sc() == RPC_S_CALL_FAILED)
        {
            if (!m_bIgnoreErrors)
                pnte->ReportError();
            delete pciNewResType;
            throw;
        }  // if:  RPC call failed error
        else if (pnte->Sc() != ERROR_FILE_NOT_FOUND)
        {
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                delete pciNewResType;
                throw;
            }  // if:  user doesn't want to ignore error
        }  // else if:  error is NOT resource type not found
        else
        {
            delete pciNewResType;
            pnte->Delete();
            return NULL;
        }  // else:  object not found
        pnte->Delete();
    }  // catch:  CNTException
    catch (CException * pe)
    {
        //DebugBreak();

        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
        {
            delete pciNewResType;
            throw;
        }  // if:  user doesn't want to ignore error
        pe->Delete();
        if (pciNewResType == NULL)
            return NULL;
    }  // catch:  CException

    try
    {
        // Add the resource type to the list.
        {
            POSITION        posPci;
            POSITION        posCurPci;
            CResourceType * pciOldResType   = NULL;

            posPci = LpciResourceTypes().GetHeadPosition();
            while (posPci != NULL)
            {
                posCurPci = posPci;
                pciOldResType = (CResourceType *) LpciResourceTypes().GetNext(posPci);
                ASSERT_VALID(pciOldResType);
                if (pciOldResType->StrName().CompareNoCase(pszName) > 0)
                {
                    LpciResourceTypes().InsertBefore(posCurPci, pciNewResType);
                    break;
                }  // if:  new resource type before this resource type
                pciOldResType = NULL;
            }  // while:  more items in the list
            if (pciOldResType == NULL)
                LpciResourceTypes().AddTail(pciNewResType);
        }  // Add the resource type to the list

        // Save this resource type as a return value now that we have added it to the list
        pciRetResType = pciNewResType;
        pciNewResType = NULL;

        // Insert the item in the tree.
        {
            CTreeItem *     ptiClusCfg;
            CTreeItem *     ptiResTypes;

            // Find the Resource Types container tree item.
            ptiClusCfg = PtiCluster()->PtiChildFromName(IDS_TREEITEM_CLUSTER_CONFIG);
            ASSERT_VALID(ptiClusCfg);
            ptiResTypes = ptiClusCfg->PtiChildFromName(IDS_TREEITEM_RESTYPES);
            ASSERT_VALID(ptiResTypes);

            // Add the item to the list of children.
            VERIFY(ptiResTypes->PliAddChild(pciRetResType) != NULL);

        }  // Insert the item in the tree
    }  // try
    catch (CException * pe)
    {
        delete pciNewResType;
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
            throw;
        pe->Delete();
    }  // catch:  CException

    if (pciRetResType != NULL)
        pciRetResType->Release();

    return pciRetResType;

}  //*** CClusterDoc::PciAddNewResourceType()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::PciAddNewNetwork
//
//  Routine Description:
//      Add a new network to the list of networks.
//
//  Arguments:
//      pszName     [IN] Name of the networks.
//
//  Return Value:
//      pci         Cluster item for the new network.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetwork * CClusterDoc::PciAddNewNetwork(IN LPCTSTR pszName)
{
    CNetwork *  pciNewNetwork = NULL;
    CNetwork *  pciRetNetwork = NULL;
    CNetwork *  pciOldNetwork = NULL;

    ASSERT(pszName != NULL);
    ASSERT(*pszName != NULL);
    ASSERT(LpciNetworks().PciNetworkFromName(pszName) == NULL);

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage(IDS_SB_ADDING_NETWORK, pszName, StrNode());
        PframeMain()->SetMessageText(strStatusBarText);
        PframeMain()->UpdateWindow();
    }  // Display a message on the status bar

    try
    {
        // If there is an item with that name, delete it.
        pciOldNetwork = LpciNetworks().PciNetworkFromName(pszName);
        if (pciOldNetwork != NULL)
        {
            Trace(g_tagNetwork, _T("Deleting existing network '%s' (%x) before adding new instance"), pszName, pciOldNetwork);
            pciOldNetwork->Delete();
            pciOldNetwork = NULL;
        }  // if:  already an item with that name

        // Allocate a new network.
        pciNewNetwork = new CNetwork;
        if ( pciNewNetwork == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the network object

        // Add a reference while we are working on it to prevent a delete
        // notification from taking us out.
        pciNewNetwork->AddRef();

        // Initialize the network.
        pciNewNetwork->Init(this, pszName);
    }  // try
    catch (CNTException * pnte)
    {
        if (pnte->Sc() == RPC_S_CALL_FAILED)
        {
            if (!m_bIgnoreErrors)
                pnte->ReportError();
            delete pciNewNetwork;
            throw;
        }  // if:  RPC call failed error
        ID id = IdProcessNewObjectError(pnte);
        if (id == IDNO)
        {
            delete pciNewNetwork;
            throw;
        }  // if:  user doesn't want to ignore error
        pnte->Delete();
    }  // catch:  CNTException
    catch (CException * pe)
    {
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
        {
            delete pciNewNetwork;
            throw;
        }  // if:  user doesn't want to ignore error
        pe->Delete();
        if (pciNewNetwork == NULL)
            return NULL;
    }  // catch:  CException

    try
    {
        // Add the network to the list.
        {
            POSITION    posPci;
            POSITION    posCurPci;

            posPci = LpciNetworks().GetHeadPosition();
            while (posPci != NULL)
            {
                posCurPci = posPci;
                pciOldNetwork = (CNetwork *) LpciNetworks().GetNext(posPci);
                ASSERT_VALID(pciOldNetwork);
                if (pciOldNetwork->StrName().CompareNoCase(pszName) > 0)
                {
                    LpciNetworks().InsertBefore(posCurPci, pciNewNetwork);
                    break;
                }  // if:  new network before this network
                pciOldNetwork = NULL;
            }  // while:  more items in the list
            if (pciOldNetwork == NULL)
                LpciNetworks().AddTail(pciNewNetwork);
        }  // Add the network to the list

        // Save this network as a return value now that we have added it to the list
        pciRetNetwork = pciNewNetwork;
        pciNewNetwork = NULL;

        // Insert the item in the tree.
        {
            CTreeItem *     ptiClusCfg;
            CTreeItem *     ptiNetworks;
            CTreeItem *     ptiNetwork;

            // Find the Networks container tree item.
            ptiClusCfg = PtiCluster()->PtiChildFromName(IDS_TREEITEM_CLUSTER_CONFIG);
            ASSERT_VALID(ptiClusCfg);
            ptiNetworks = ptiClusCfg->PtiChildFromName(IDS_TREEITEM_NETWORKS);
            ASSERT_VALID(ptiNetworks);

            // Add the item before the found item we inserted it into in the networks list.
            ptiNetwork = ptiNetworks->PtiAddChildBefore(pciOldNetwork, pciRetNetwork);
            ASSERT_VALID(ptiNetwork);
            ptiNetwork->PcoliAddColumn(IDS_COLTEXT_NODE, COLI_WIDTH_NODE);
            ptiNetwork->PcoliAddColumn(IDS_COLTEXT_NETWORK, COLI_WIDTH_NETWORK);
//          ptiNetwork->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
            ptiNetwork->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
            ptiNetwork->PcoliAddColumn(IDS_COLTEXT_ADAPTER, COLI_WIDTH_NET_ADAPTER);
            ptiNetwork->PcoliAddColumn(IDS_COLTEXT_ADDRESS, COLI_WIDTH_NET_ADDRESS);
            ptiNetwork->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

        }  // Insert the item in the tree
    }  // try
    catch (CException * pe)
    {
        delete pciNewNetwork;
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
            throw;
        pe->Delete();
    }  // catch:  CException

    if (pciRetNetwork != NULL)
        pciRetNetwork->Release();

    return pciRetNetwork;

}  //*** CClusterDoc::PciAddNewNetwork()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::PciAddNewNetInterface
//
//  Routine Description:
//      Add a new network interfaces to the list of network interfaces.
//
//  Arguments:
//      pszName     [IN] Name of the network interface.
//
//  Return Value:
//      pci         Cluster item for the new network interface.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetInterface * CClusterDoc::PciAddNewNetInterface(IN LPCTSTR pszName)
{
    CNetInterface * pciNewNetIFace = NULL;
    CNetInterface * pciRetNetIFace = NULL;
    CNetInterface * pciOldNetIFace;

    ASSERT(pszName != NULL);
    ASSERT(*pszName != NULL);
    ASSERT(LpciNetInterfaces().PciNetInterfaceFromName(pszName) == NULL);

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage(IDS_SB_ADDING_NETIFACE, pszName, StrNode());
        PframeMain()->SetMessageText(strStatusBarText);
        PframeMain()->UpdateWindow();
    }  // Display a message on the status bar

    try
    {
        // If there is an item with that name, delete it.
        pciOldNetIFace = LpciNetInterfaces().PciNetInterfaceFromName(pszName);
        if (pciOldNetIFace != NULL)
        {
            pciOldNetIFace->Delete();
            pciOldNetIFace = NULL;
        }  // if:  already an item with that name

        // Allocate a new network interface.
        pciNewNetIFace = new CNetInterface;
        if ( pciNewNetIFace == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the net interface object

        // Add a reference while we are working on it to prevent a delete
        // notification from taking us out.
        pciNewNetIFace->AddRef();

        // Initialize the network interface.
        pciNewNetIFace->Init(this, pszName);
    }  // try
    catch (CNTException * pnte)
    {
        if (pnte->Sc() == RPC_S_CALL_FAILED)
        {
            if (!m_bIgnoreErrors)
                pnte->ReportError();
            delete pciNewNetIFace;
            throw;
        }  // if:  RPC call failed error
        ID id = IdProcessNewObjectError(pnte);
        if (id == IDNO)
        {
            delete pciNewNetIFace;
            throw;
        }  // if:  user doesn't want to ignore error
        pnte->Delete();
    }  // catch:  CNTException
    catch (CException * pe)
    {
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
        {
            delete pciNewNetIFace;
            throw;
        }  // if:  user doesn't want to ignore error
        pe->Delete();
        if (pciNewNetIFace == NULL)
            return NULL;
    }  // catch:  CException

    try
    {
        // Add the network interface to the list.
        {
            POSITION        posPci;
            POSITION        posCurPci;
            CNetInterface * pciOldNetIFace  = NULL;

            posPci = LpciNetInterfaces().GetHeadPosition();
            while (posPci != NULL)
            {
                posCurPci = posPci;
                pciOldNetIFace = (CNetInterface *) LpciNetInterfaces().GetNext(posPci);
                ASSERT_VALID(pciOldNetIFace);
                if (pciOldNetIFace->StrName().CompareNoCase(pszName) > 0)
                {
                    LpciNetInterfaces().InsertBefore(posCurPci, pciNewNetIFace);
                    break;
                }  // if:  new network interfaces before this network interface
                pciOldNetIFace = NULL;
            }  // while:  more items in the list
            if (pciOldNetIFace == NULL)
                LpciNetInterfaces().AddTail(pciNewNetIFace);
        }  // Add the network interface to the list

        // Save this network interface as a return value now that we have added it to the list
        pciRetNetIFace = pciNewNetIFace;
        pciNewNetIFace = NULL;

        // Insert the item in the tree.
        {
            CTreeItem *     ptiClusCfg;
            CTreeItem *     ptiNetIFaces;

            // Find the Network Interfaces container tree item.
            ptiClusCfg = PtiCluster()->PtiChildFromName(IDS_TREEITEM_CLUSTER_CONFIG);
            ASSERT_VALID(ptiClusCfg);
            ptiNetIFaces = ptiClusCfg->PtiChildFromName(IDS_TREEITEM_NETIFACES);
            ASSERT_VALID(ptiNetIFaces);

            // Add the item to the list of children.
            VERIFY(ptiNetIFaces->PliAddChild(pciRetNetIFace) != NULL);

        }  // Insert the item in the tree
    }  // try
    catch (CException * pe)
    {
        delete pciNewNetIFace;
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
            throw;
        pe->Delete();
    }  // catch:  CException

    if (pciRetNetIFace != NULL)
        pciRetNetIFace->Release();

    return pciRetNetIFace;

}  //*** CClusterDoc::PciAddNewNetInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::InitNodes
//
//  Routine Description:
//      Read item data.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::InitNodes(void)
{
    POSITION        pos;
    CClusterNode *  pci;
    CNodeList &     rlpci = LpciNodes();
    CString         strStatusBarText;

    pos = rlpci.GetHeadPosition();
    while (pos != NULL)
    {
        pci = (CClusterNode *) rlpci.GetNext(pos);
        pci->AddRef();
        try
        {
            // Display a message on the status bar.
            {
                strStatusBarText.FormatMessage(IDS_SB_READING_NODE, pci->StrName(), StrNode());
                PframeMain()->SetMessageText(strStatusBarText);
                PframeMain()->UpdateWindow();
            }  // Display a message on the status bar

            pci->ReadItem();
        }  // try
        catch (CNTException * pnte)
        {
            strStatusBarText.Empty();
            if (pnte->Sc() == RPC_S_CALL_FAILED)
            {
                if (!m_bIgnoreErrors)
                    pnte->ReportError();
                pci->Release();
                throw;
            }  // if:  RPC call failed
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pnte->Delete();
        }  // catch:  CNTException
        catch (CException * pe)
        {
            strStatusBarText.Empty();
            ID id = IdProcessNewObjectError(pe);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pe->Delete();
        }  // catch:  CException
        pci->Release();
    }  // while:  more items in the list

}  //*** CClusterDoc::InitNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::InitGroups
//
//  Routine Description:
//      Read item data.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::InitGroups(void)
{
    POSITION        pos;
    CGroup *        pci;
    CGroupList &    rlpci = LpciGroups();
    CString         strStatusBarText;

    pos = rlpci.GetHeadPosition();
    while (pos != NULL)
    {
        pci = (CGroup *) rlpci.GetNext(pos);
        pci->AddRef();
        try
        {
            // Display a message on the status bar.
            {
                strStatusBarText.FormatMessage(IDS_SB_READING_GROUP, pci->StrName(), StrNode());
                PframeMain()->SetMessageText(strStatusBarText);
                PframeMain()->UpdateWindow();
            }  // Display a message on the status bar

            pci->ReadItem();
        }  // try
        catch (CNTException * pnte)
        {
            strStatusBarText.Empty();
            if (pnte->Sc() == RPC_S_CALL_FAILED)
            {
                if (!m_bIgnoreErrors)
                    pnte->ReportError();
                pci->Release();
                throw;
            }  // if:  RPC call failed
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pnte->Delete();
        }  // catch:  CNTException
        catch (CException * pe)
        {
            strStatusBarText.Empty();
            ID id = IdProcessNewObjectError(pe);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pe->Delete();
        }  // catch:  CException
        pci->Release();
    }  // while:  more items in the list

}  //*** CClusterDoc::InitGroups()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::InitResources
//
//  Routine Description:
//      Read item data.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::InitResources(void)
{
    POSITION        pos;
    CResource *     pci;
    CResourceList & rlpci = LpciResources();
    CString         strStatusBarText;

    pos = rlpci.GetHeadPosition();
    while (pos != NULL)
    {
        pci = (CResource *) rlpci.GetNext(pos);
        pci->AddRef();
        try
        {
            // Display a message on the status bar.
            {
                CString     strStatusBarText;
                strStatusBarText.FormatMessage(IDS_SB_READING_RESOURCE, pci->StrName(), StrNode());
                PframeMain()->SetMessageText(strStatusBarText);
                PframeMain()->UpdateWindow();
            }  // Display a message on the status bar

            pci->ReadItem();
        }  // try
        catch (CNTException * pnte)
        {
            strStatusBarText.Empty();
            if (pnte->Sc() == RPC_S_CALL_FAILED)
            {
                if (!m_bIgnoreErrors)
                    pnte->ReportError();
                pci->Release();
                throw;
            }  // if:  RPC call failed
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pnte->Delete();
        }  // catch:  CNTException
        catch (CException * pe)
        {
            strStatusBarText.Empty();
            ID id = IdProcessNewObjectError(pe);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pe->Delete();
        }  // catch:  CException
        pci->Release();
    }  // while:  more items in the list

}  //*** CClusterDoc::InitResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::InitResourceTypes
//
//  Routine Description:
//      Read item data.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::InitResourceTypes(void)
{
    POSITION            pos;
    CResourceType *     pci;
    CResourceTypeList & rlpci = LpciResourceTypes();
    CString             strStatusBarText;

    pos = rlpci.GetHeadPosition();
    while (pos != NULL)
    {
        pci = (CResourceType *) rlpci.GetNext(pos);
        pci->AddRef();
        try
        {
            // Display a message on the status bar.
            {
                CString     strStatusBarText;
                strStatusBarText.FormatMessage(IDS_SB_READING_RESTYPE, pci->StrName(), StrNode());
                PframeMain()->SetMessageText(strStatusBarText);
                PframeMain()->UpdateWindow();
            }  // Display a message on the status bar

            pci->ReadItem();
        }  // try
        catch (CNTException * pnte)
        {
            strStatusBarText.Empty();
            if (pnte->Sc() == RPC_S_CALL_FAILED)
            {
                if (!m_bIgnoreErrors)
                    pnte->ReportError();
                pci->Release();
                throw;
            }  // if:  RPC call failed
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pnte->Delete();
        }  // catch:  CNTException
        catch (CException * pe)
        {
            strStatusBarText.Empty();
            ID id = IdProcessNewObjectError(pe);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pe->Delete();
        }  // catch:  CException
        pci->Release();
    }  // while:  more items in the list

}  //*** CClusterDoc::InitResourceTypes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::InitNetworks
//
//  Routine Description:
//      Read item data.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::InitNetworks(void)
{
    POSITION        pos;
    CNetwork *      pci;
    CNetworkList &  rlpci = LpciNetworks();
    CString         strStatusBarText;

    pos = rlpci.GetHeadPosition();
    while (pos != NULL)
    {
        pci = (CNetwork *) rlpci.GetNext(pos);
        pci->AddRef();
        try
        {
            // Display a message on the status bar.
            {
                CString     strStatusBarText;
                strStatusBarText.FormatMessage(IDS_SB_READING_NETWORK, pci->StrName(), StrNode());
                PframeMain()->SetMessageText(strStatusBarText);
                PframeMain()->UpdateWindow();
            }  // Display a message on the status bar

            pci->ReadItem();
        }  // try
        catch (CNTException * pnte)
        {
            strStatusBarText.Empty();
            if (pnte->Sc() == RPC_S_CALL_FAILED)
            {
                if (!m_bIgnoreErrors)
                    pnte->ReportError();
                pci->Release();
                throw;
            }  // if:  RPC call failed
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pnte->Delete();
        }  // catch:  CNTException
        catch (CException * pe)
        {
            strStatusBarText.Empty();
            ID id = IdProcessNewObjectError(pe);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pe->Delete();
        }  // catch:  CException
        pci->Release();
    }  // while:  more items in the list

}  //*** CClusterDoc::InitNetworks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::InitNetInterfaces
//
//  Routine Description:
//      Read item data.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::InitNetInterfaces(void)
{
    POSITION            pos;
    CNetInterface *     pci;
    CNetInterfaceList & rlpci = LpciNetInterfaces();
    CString             strStatusBarText;

    pos = rlpci.GetHeadPosition();
    while (pos != NULL)
    {
        pci = (CNetInterface *) rlpci.GetNext(pos);
        pci->AddRef();
        try
        {
            // Display a message on the status bar.
            {
                CString     strStatusBarText;
                strStatusBarText.FormatMessage(IDS_SB_READING_NETIFACE, pci->StrName(), StrNode());
                PframeMain()->SetMessageText(strStatusBarText);
                PframeMain()->UpdateWindow();
            }  // Display a message on the status bar

            pci->ReadItem();
        }  // try
        catch (CNTException * pnte)
        {
            strStatusBarText.Empty();
            if (pnte->Sc() == RPC_S_CALL_FAILED)
            {
                if (!m_bIgnoreErrors)
                    pnte->ReportError();
                pci->Release();
                throw;
            }  // if:  RPC call failed
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pnte->Delete();
        }  // catch:  CNTException
        catch (CException * pe)
        {
            strStatusBarText.Empty();
            ID id = IdProcessNewObjectError(pe);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pe->Delete();
        }  // catch:  CException
        pci->Release();
    }  // while:  more items in the list

}  //*** CClusterDoc::InitNetInterfaces()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::IdProcessNewObjectError
//
//  Routine Description:
//      Processes errors that occur when adding a new object.  If this
//      occurs during initialization and errors have not already been set
//      to be ignored, display the YesToAll dialog.  If not during
//      initialization, add it to the error message queue to be displayed
//      later.
//
//  Arguments:
//      pe          [IN OUT] Exception object to process.
//
//  Return Value:
//      IDYES               Ignore error.
//      IDNO                Cancel the object creation.
//      IDC_YTA_YESTOALL    Ignore this error and all succeeding ones.
//
//--
/////////////////////////////////////////////////////////////////////////////
ID CClusterDoc::IdProcessNewObjectError(IN OUT CException * pe)
{
    ID id = IDYES;

    ASSERT(pe != NULL);

    if (m_bInitializing)
    {
        if (!m_bIgnoreErrors)
        {
            TCHAR   szErrorMsg[2048];

            CYesToAllDialog dlg(szErrorMsg);
            pe->GetErrorMessage(szErrorMsg, sizeof(szErrorMsg) / sizeof(TCHAR));
            id =  (ID)dlg.DoModal();
            if (id == IDC_YTA_YESTOALL)
                m_bIgnoreErrors = TRUE;
        }  // if:  not ignoring errors
    }  // if:  initializing the connection
    else
    {
        if (!m_bIgnoreErrors)
            pe->ReportError();
    }  // else:  called for a notification

    return id;

}  //*** CClusterDoc::IdProcessNewObjectError()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::AddDefaultColumns
//
//  Routine Description:
//      Add default columns to the item.
//
//  Arguments:
//      pti         [IN OUT] Pointer to the item to add the columns to.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::AddDefaultColumns(IN OUT CTreeItem * pti)
{
    ASSERT_VALID(pti);

    pti->DeleteAllColumns();
    pti->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//  pti->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
    pti->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

}  //*** CClusterDoc::AddDefaultColumns()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::DeleteContents
//
//  Routine Description:
//      Delete the contents of the document.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::DeleteContents(void)
{
    // Select the root item in all views.
    // This is done so that selection is done right up front when all data
    // is still available.
    if (PtiCluster() != NULL)
        PtiCluster()->SelectInAllViews();

    // Delete the tree hierarchy.
    if (m_ptiCluster != NULL)
    {
        // Delete the tree.
        m_ptiCluster->Delete();
        m_ptiCluster->Release();
        m_ptiCluster = NULL;
    }  // if:  there is a hierarchy

    // Delete all the lists.
    DeleteAllItemData(LpciResources());
    DeleteAllItemData(LpciGroups());
    DeleteAllItemData(LpciNetInterfaces());
    DeleteAllItemData(LpciNetworks());
    DeleteAllItemData(LpciNodes());
    DeleteAllItemData(LpciResourceTypes());
    LpciResources().RemoveAll();
    LpciGroups().RemoveAll();
    LpciNetInterfaces().RemoveAll();
    LpciNetworks().RemoveAll();
    LpciNodes().RemoveAll();
    LpciResourceTypes().RemoveAll();

    // Delete the top cluster item.
    if (m_pciCluster != NULL)
    {
        m_pciCluster->Delete();
        m_pciCluster->Release();
        m_pciCluster = NULL;
    }  // if:  there is a cluster item

    // Close the cluster registry key.
    if (HkeyCluster() != NULL)
    {
        ClusterRegCloseKey(HkeyCluster());
        m_hkeyCluster = NULL;
    }  // if:  cluster registry key is open

    // Close the cluster if it is open.
    if ((Hcluster() != NULL) && (Hcluster() != GetClusterAdminApp()->HOpenedCluster()))
    {
        CloseCluster(Hcluster());
        m_hcluster = NULL;
    }  // if:  cluster is open

    CDocument::DeleteContents();

    UpdateAllViews(NULL);

    // If there are any items left to be deleted, let's delete them now.
    {
        POSITION        pos;
        POSITION        posBeingChecked;
        CClusterItem *  pci;

        pos = LpciToBeDeleted().GetHeadPosition();
        while (pos != NULL)
        {
            posBeingChecked = pos;
            pci = LpciToBeDeleted().GetNext(pos);
            ASSERT_VALID(pci);

            ASSERT(pci->NReferenceCount() == 1);
            if (pci->NReferenceCount() == 1)
                LpciToBeDeleted().RemoveAt(posBeingChecked);
        }  // while:  more items in the list
        ASSERT(LpciToBeDeleted().GetCount() == 0);
    }  // Delete items in To Be Deleted list

}  //*** CClusterDoc::DeleteContents()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::SetPathName
//
//  Routine Description:
//      Set the name of the document.
//
//  Arguments:
//      lpszPathName    [IN] Name of the cluster.
//      bAddToMRU       [IN] TRUE = add to Most Recently Used list.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::SetPathName(IN LPCTSTR lpszPathName, IN BOOL bAddToMRU)
{
    CString     strTitle;

    m_strPathName = lpszPathName;
    ASSERT(!m_strPathName.IsEmpty());       // must be set to something
    m_bEmbedded = FALSE;
    ASSERT_VALID(this);

    // Set the document title to the cluster name.
    strTitle.FormatMessage(IDS_WINDOW_TITLE_FORMAT, m_strName, lpszPathName);
    SetTitle(strTitle);

    // add it to the file MRU list
    if (bAddToMRU)
        AfxGetApp()->AddToRecentFileList(m_strPathName);

    // Set the node name to the path name.
    m_strNode = lpszPathName;

    ASSERT_VALID(this);

}  //*** CClusterDoc::SetPathName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::UpdateTitle
//
//  Routine Description:
//      Update the title of the document.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::UpdateTitle(void)
{
    CString     strTitle;

    ASSERT_VALID(PciCluster());
    ASSERT_VALID(this);

    // Set the document title to the cluster name.
    m_strName = PciCluster()->StrName();
    strTitle.FormatMessage(IDS_WINDOW_TITLE_FORMAT, m_strName, m_strPathName);
    SetTitle(strTitle);

}  //*** CClusterDoc::UpdateTitle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnChangedViewList
//
//  Routine Description:
//      Called when the list of view changes by either having a view added
//      or removed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::OnChangedViewList(void)
{
    ASSERT_VALID(this);

    // Notify all frames to re-calculate their frame number.
    if (m_bUpdateFrameNumber)
    {
        POSITION            pos;
        CView *             pview;
        CSplitterFrame *    pframe;

        pos = GetFirstViewPosition();
        while (pos != NULL)
        {
            pview = GetNextView(pos);
            ASSERT_VALID(pview);
            if (pview->IsKindOf(RUNTIME_CLASS(CClusterTreeView)))
            {
                pframe = (CSplitterFrame *) pview->GetParentFrame();
                ASSERT_VALID(pframe);
                pframe->CalculateFrameNumber();
            }  // if:  tree view
        }  // while:  more views on the document
    }  // if:  updating frame numbers

    // Call the base class method.
    CDocument::OnChangedViewList();

}  //*** CClusterDoc::OnChangedViewList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnSelChanged
//
//  Routine Description:
//      Called by one of the cluster views when selection changes.
//      Changes the menu if the object type changed.
//
//  Arguments:
//      pciSelected     [IN] Currently selected item.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::OnSelChanged(IN CClusterItem * pciSelected)
{
    IDM     idmNewMenu;
    HMENU * phmenu;
    IDS     idsType;

    // Get the type of object being selected
    if (pciSelected == NULL)
        idsType = 0;
    else
    {
        ASSERT_VALID(pciSelected);
        idsType = pciSelected->IdsType();
    }  // else:  an item was selected

    // Get the ID of the menu required by the selected item.
    switch (idsType)
    {
        case IDS_ITEMTYPE_CLUSTER:
            idmNewMenu = IDM_CLUSTER;
            phmenu = &m_hmenuCluster;
            break;

        case IDS_ITEMTYPE_NODE:
            idmNewMenu = IDM_NODE;
            phmenu = &m_hmenuNode;
            break;

        case IDS_ITEMTYPE_GROUP:
            idmNewMenu = IDM_GROUP;
            phmenu = &m_hmenuGroup;
            break;

        case IDS_ITEMTYPE_RESOURCE:
            idmNewMenu = IDM_RESOURCE;
            phmenu = &m_hmenuResource;
            break;

        case IDS_ITEMTYPE_RESTYPE:
            idmNewMenu = IDM_RESTYPE;
            phmenu = &m_hmenuResType;
            break;

        case IDS_ITEMTYPE_NETWORK:
            idmNewMenu = IDM_NETWORK;
            phmenu = &m_hmenuNetwork;
            break;

        case IDS_ITEMTYPE_NETIFACE:
            idmNewMenu = IDM_NETIFACE;
            phmenu = &m_hmenuNetIFace;
            break;

        default:
            idmNewMenu = 0;
            phmenu = NULL;
            break;

    }  // switch:  pciSelected->IdsType()

    // If the menu ID changed, load the new one.
    if (m_idmCurrentMenu != idmNewMenu)
    {
        if (idmNewMenu == 0)
            m_hmenuCurrent = NULL;
        else
        {
            if (*phmenu == NULL)
                *phmenu = ::LoadMenu(AfxGetResourceHandle(), MAKEINTRESOURCE(idmNewMenu));
            m_hmenuCurrent = *phmenu;
        }  // else:  special menu required by item

        m_idmCurrentMenu = idmNewMenu;
    }  // if:  menu ID changed

    // Update the menu bar and redisplay it.
    if (((CMDIFrameWnd *) AfxGetMainWnd())->MDIGetActive() != NULL)
    {
#ifdef _DEBUG
        if (g_tagDocMenu.BAny())
        {
            TraceMenu(g_tagDocMenu, AfxGetMainWnd()->GetMenu(), _T("OnSelChanged menu: "));
            {
                CMDIFrameWnd *  pFrame = (CMDIFrameWnd *) AfxGetMainWnd();
                CMenu           menuDefault;

                menuDefault.Attach(pFrame->m_hMenuDefault);
                TraceMenu(g_tagDocMenu, &menuDefault, _T("Frame default menu before OnSelChanged: "));
                menuDefault.Detach();
            }  // trace default menu
        }  // if:  tag is active
#endif

        ((CFrameWnd *) AfxGetMainWnd())->OnUpdateFrameMenu(NULL);
        AfxGetMainWnd()->DrawMenuBar();

        TraceMenu(g_tagDocMenu, AfxGetMainWnd()->GetMenu(), _T("Post-OnSelChanged menu: "));
    }  // if:  active window present

}  //*** CClusterDoc::OnSelChanged()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::GetDefaultMenu
//
//  Routine Description:
//      Returns the menu to use.  Overridden to allow us to use multiple menus
//      with the same type of document.
//
//  Arguments:
//      None.
//
//  Return Value:
//      hmenu       The currently selected menu, or NULL for no default.
//
//--
/////////////////////////////////////////////////////////////////////////////
HMENU CClusterDoc::GetDefaultMenu(void)
{
    return m_hmenuCurrent;

}  //*** CClusterDoc::GetDefaultMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnCmdRefresh
//
//  Routine Description:
//      Processes the ID_VIEW_REFRESH menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::OnCmdRefresh(void)
{
    CWaitCursor     wc;

    try
    {
        Trace(g_tagDocRefresh, _T("(%s) Deleting old contents"), StrNode());

        {
            POSITION            pos;
            CSplitterFrame *    pframe;
            CView *             pview;

            // Get the active child frame window.
            pframe = (CSplitterFrame *) ((CFrameWnd *) AfxGetMainWnd())->GetActiveFrame();
            if ((pframe->IsKindOf(RUNTIME_CLASS(CSplitterFrame)))
                    && (pframe->PviewList()->PtiParent() != NULL))
            {
                // Tell the view to save its column information.
                pframe->PviewList()->SaveColumns();
            }  //  if:  MDI window exists

            pos = GetFirstViewPosition();
            while (pos != NULL)
            {
                pview = GetNextView(pos);
                if (pview->IsKindOf(RUNTIME_CLASS(CClusterTreeView)))
                {
                    // Save the current selection
                    ((CClusterTreeView *) pview)->SaveCurrentSelection();
                }  // if:  this is a tree view
            }  // while:  more views
        }  // Save the column information

        DeleteContents();

        Trace(g_tagDocRefresh, _T("(%s) %d items still to be deleted"), StrNode(), LpciToBeDeleted().GetCount());

        Trace(g_tagDocRefresh, _T("(%s) Creating new cluster object"), StrNode());

        m_bClusterAvailable = TRUE;
        m_bInitializing = TRUE;

        // Create a new cluster object.
        m_pciCluster = new CCluster;
        if ( m_pciCluster == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the cluster object
        PciCluster()->AddRef();
        PciCluster()->Init(this, GetPathName());

        Trace(g_tagDocRefresh, _T("(%s) Building base hierarchy"), StrNode());

        // Build the base hierarchy.
        BuildBaseHierarchy();

        Trace(g_tagDocRefresh, _T("(%s) Collecting cluster items"), StrNode());

        // Collect the items in the cluster and build the hierarchy.
        CollectClusterItems();
        PciCluster()->CollectNetworkPriority(NULL);

        Trace(g_tagDocRefresh, _T("(%s) Re-initializing the views"), StrNode());

        // Re-initialize the views.
        {
            POSITION    pos;
            CView *     pview;

            pos = GetFirstViewPosition();
            while (pos != NULL)
            {
                pview = GetNextView(pos);
                ASSERT_VALID(pview);
                pview->OnInitialUpdate();
            }  // while:  more items in the list
        }  // Re-initialize the views
    }  // try
    catch (CException * pe)
    {
        if (!m_bIgnoreErrors)
            pe->ReportError();
        pe->Delete();

        if (HkeyCluster() != NULL)
        {
            ClusterRegCloseKey(HkeyCluster());
            m_hkeyCluster = NULL;
        }  // if:  cluster registry key is open
        if (Hcluster() != NULL)
        {
            CloseCluster(Hcluster());
            m_hcluster = NULL;
        }  // if:  cluster is open
        m_bClusterAvailable = FALSE;
    }  // catch:  CException

    // Reset the message on the status bar.
    PframeMain()->SetMessageText(AFX_IDS_IDLEMESSAGE);
    PframeMain()->UpdateWindow();

    m_bInitializing = FALSE;

#ifdef GC_DEBUG
    gcCollect();
#endif

}  //*** CClusterDoc::OnCmdRefresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnCmdNewGroup
//
//  Routine Description:
//      Processes the ID_FILE_NEW_GROUP menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::OnCmdNewGroup(void)
{
    CCreateGroupWizard  wiz(this, AfxGetMainWnd());

    if (wiz.BInit())
    {
        if (wiz.DoModal() == ID_WIZFINISH)
        {
            CString     strMsg;

            strMsg.FormatMessage(IDS_CREATED_GROUP, wiz.StrName());
            AfxMessageBox(strMsg, MB_ICONINFORMATION);
        }  // if:  user pressed the FINISH button
    }  // if:  wizard initialized successfully

}  //*** CClusterDoc::OnCmdNewGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnCmdNewResource
//
//  Routine Description:
//      Processes the ID_FILE_NEW_RESOURCE menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::OnCmdNewResource(void)
{
    CCreateResourceWizard   wiz(this, AfxGetMainWnd());

    if (wiz.BInit())
    {
        if (wiz.DoModal() == ID_WIZFINISH)
        {
            CString     strMsg;

            strMsg.FormatMessage(IDS_CREATED_RESOURCE, wiz.StrName());
            AfxMessageBox(strMsg, MB_ICONINFORMATION);
        }  // if:  user pressed the FINISH button
    }  // if:  wizard initialized successfully

}  //*** CClusterDoc::OnCmdNewResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnCmdNewNode
//
//  Routine Description:
//      Processes the ID_FILE_NEW_NODE menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::OnCmdNewNode( void )
{
    NewNodeWizard( StrName(), m_bIgnoreErrors );
#if 0
    HRESULT             hr;
    IClusCfgWizard *    pccwWiz;
    BSTR                bstrConnectName = NULL;
    BOOL                fCommitted = FALSE;

    // Make sure the ClusCfg client has been loaded.
    GetClusterAdminApp()->LoadClusCfgClient();

    // Get an interface pointer for the wizard.
    hr = CoCreateInstance(
            CLSID_ClusCfgWizard,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IClusCfgWizard,
            (void **) &pccwWiz
            );
    if ( FAILED( hr ) )
    {
        CNTException nte( hr, IDS_CREATE_CLUSCFGWIZ_OBJ_ERROR, NULL, NULL, FALSE /*bAutoDelete*/ );
        if ( ! m_bIgnoreErrors )
        {
            nte.ReportError();
        }
        return;
    } // if: error getting the interface pointer

    // Specify the name of the cluster we are going to add a node to.
    bstrConnectName = SysAllocString( PciCluster()->StrFQDN() );
    if ( bstrConnectName == NULL )
    {
        AfxThrowMemoryException();
    }
    hr = pccwWiz->put_ClusterName( bstrConnectName );
    if ( FAILED( hr ) )
    {
        CNTException nte( hr, IDS_ADD_NODES_TO_CLUSTER_ERROR, bstrConnectName, NULL, FALSE /*bAutoDelete*/ );
        if ( ! m_bIgnoreErrors )
        {
            nte.ReportError();
        }
    } // if: error setting the cluster name

    // Display the wizard.
    hr = pccwWiz->AddClusterNodes(
                    AfxGetMainWnd()->m_hWnd,
                    &fCommitted
                    );
    if ( FAILED( hr ) )
    {
        CNTException nte( hr, IDS_ADD_NODES_TO_CLUSTER_ERROR, bstrConnectName, NULL, FALSE /*bAutoDelete*/ );
        if ( ! m_bIgnoreErrors )
        {
            nte.ReportError();
        }
    } // if: error adding cluster nodes

    SysFreeString( bstrConnectName );
    pccwWiz->Release();
#endif

}  //*** CClusterDoc::OnCmdNewNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnCmdConfigApp
//
//  Routine Description:
//      Processes the ID_FILE_CONFIG_APP menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::OnCmdConfigApp(void)
{
    HRESULT                     hr;
    IClusterApplicationWizard * piWiz;

    // Get an interface pointer for the wizard.
    hr = CoCreateInstance(
            __uuidof(ClusAppWiz),
            NULL,
            CLSCTX_INPROC_SERVER,
            __uuidof(IClusterApplicationWizard),
            (LPVOID *) &piWiz
            );
    if (FAILED(hr))
    {
        CNTException nte(hr, (IDS) 0);
        if (!m_bIgnoreErrors)
            nte.ReportError();
        return;
    }  // if:  error getting the interface pointer

    // Display the wizard.
    hr = piWiz->DoModalWizard(AfxGetMainWnd()->m_hWnd,
                              (ULONG_PTR)Hcluster(),
                              NULL);
    piWiz->Release();

    // Handle any errors.
    if (FAILED(hr))
    {
        CNTException nte(hr, (IDS) 0);
        if (!m_bIgnoreErrors)
            nte.ReportError();
    }  // if:  error from the wizard

}  //*** CClusterDoc::OnCmdConfigApp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnClusterNotify
//
//  Routine Description:
//      Handler for the WM_CAM_CLUSTER_NOTIFY message.
//      Processes cluster notifications.
//
//  Arguments:
//      pnotify     [IN OUT] Object describing the notification.
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CClusterDoc::OnClusterNotify( IN OUT CClusterNotify * pnotify )
{
    ASSERT( pnotify != NULL );

    BOOL            bOldIgnoreErrors = m_bIgnoreErrors;
    CClusterItem *  pciClusterItemPtr = NULL;

    m_bIgnoreErrors = TRUE;

    try
    {
        switch ( pnotify->m_dwFilterType )
        {
            case CLUSTER_CHANGE_CLUSTER_STATE:
                {
                    m_bClusterAvailable = FALSE;

                    // Update the state of all objects in the cluster.
                    ASSERT_VALID( PtiCluster() );
                    PtiCluster()->UpdateAllStatesInTree();
                    try
                    {
                        CString     strMsg;
                        ASSERT( pnotify->m_strName.GetLength() > 0 );
                        strMsg.FormatMessage( IDS_CLUSTER_NOT_AVAILABLE, pnotify->m_strName );
                        AfxMessageBox( strMsg, MB_ICONINFORMATION );
                    }  // try
                    catch ( CException * pe )
                    {
                        pe->Delete();
                    }  // catch:  CException
                    break;
                }

            case CLUSTER_CHANGE_CLUSTER_PROPERTY:
                {
                    ASSERT_VALID( PciCluster() );
                    Trace( g_tagDocNotify, _T("(%s) - Cluster properties changed - new name is '%s'"), StrNode(), pnotify->m_strName );
                    PciCluster()->ReadItem();
                    PciCluster()->CollectNetworkPriority( NULL );
                    break;
                }

            case CLUSTER_CHANGE_NODE_ADDED:
                {
                    CClusterNode *  pciNode;
                    Trace( g_tagNodeNotify, _T("(%s) - Adding node '%s'"), m_strPathName, pnotify->m_strName );
                    pciNode = PciAddNewNode( pnotify->m_strName );
                    if ( pciNode != NULL )
                    {
                        ASSERT_VALID( pciNode );
                        pciNode->AddRef();
                        // For calling Release later. This is done so that
                        // release is called even if ReadItem below throws an exception.
                        pciClusterItemPtr = pciNode;
                        pciNode->ReadItem();
                    }  // if:  node was added
                    break;
                }

            case CLUSTER_CHANGE_GROUP_ADDED:
                {
                    CGroup *    pciGroup;
                    Trace( g_tagGroupNotify, _T("(%s) - Adding group '%s'"), m_strPathName, pnotify->m_strName );
                    pciGroup = PciAddNewGroup( pnotify->m_strName );
                    if ( pciGroup != NULL )
                    {
                        ASSERT_VALID( pciGroup );
                        pciGroup->AddRef();
                        // For calling Release later. This is done so that
                        // release is called even if ReadItem below throws an exception.
                        pciClusterItemPtr = pciGroup;
                        pciGroup->ReadItem();
                    } // if:  group was added
                    break;
                }

            case CLUSTER_CHANGE_RESOURCE_ADDED:
                {
                    CResource * pciRes;
                    Trace( g_tagResNotify, _T("(%s) - Adding resource '%s'"), m_strPathName, pnotify->m_strName );
                    pciRes = PciAddNewResource( pnotify->m_strName );
                    if (pciRes != NULL)
                    {
                        ASSERT_VALID( pciRes );
                        pciRes->AddRef();
                        // For calling Release later. This is done so that
                        // release is called even if ReadItem below throws an exception.
                        pciClusterItemPtr = pciRes;
                        if ( ! pciRes->BInitializing() )
                        {
                            pciRes->ReadItem();
                        } // if: not initializing the resource
                    } // if:  resource was added
                    break;
                }

            case CLUSTER_CHANGE_RESOURCE_TYPE_ADDED:
                {
                    CResourceType * pciResType;
                    Trace( g_tagResTypeNotify, _T("(%s) - Adding resource Type '%s'"), m_strPathName, pnotify->m_strName );
                    pciResType = PciAddNewResourceType( pnotify->m_strName );
                    if ( pciResType != NULL )
                    {
                        ASSERT_VALID( pciResType );
                        pciResType->AddRef();
                        // For calling Release later. This is done so that
                        // release is called even if ReadItem below throws an exception.
                        pciClusterItemPtr = pciResType;
                        pciResType->ReadItem();
                    } // if:  resource type was added
                    break;
                }

            case CLUSTER_CHANGE_RESOURCE_TYPE_DELETED:
                {
                    ASSERT( pnotify->m_strName.GetLength() > 0 );
                    CResourceType * pciResType = LpciResourceTypes().PciResTypeFromName( pnotify->m_strName );
                    if ( pciResType != NULL )
                    {
                        ASSERT_VALID( pciResType );
                        Trace( g_tagResTypeNotify, _T("(%s) - Resource Type '%s' deleted"), m_strPathName, pnotify->m_strName );
                        pciResType->Delete();
                    }  // if:  resource type was found
                    else
                    {
                        Trace( g_tagDocNotify, _T("(%s) - Resource Type '%s' deleted (NOT FOUND)"), m_strPathName, pnotify->m_strName );
                    } // else: resource type not found
                    break;
                }

            case CLUSTER_CHANGE_RESOURCE_TYPE_PROPERTY:
                {
                    ASSERT( pnotify->m_strName.GetLength() > 0 );
                    CResourceType * pciResType = LpciResourceTypes().PciResTypeFromName( pnotify->m_strName );
                    if ( pciResType != NULL )
                    {
                        ASSERT_VALID( pciResType );
                        Trace( g_tagResTypeNotify, _T("(%s) - Resource Type '%s' property change"), m_strPathName, pnotify->m_strName );
                        pciResType->ReadItem();
                    } // if:  resource type was found
                    else
                    {
                        Trace( g_tagDocNotify, _T("(%s) - Resource Type '%s' deleted (NOT FOUND)"), m_strPathName, pnotify->m_strName );
                    } // else: resource type not found
                    break;
                }

            case CLUSTER_CHANGE_NETWORK_ADDED:
                {
                    CNetwork *  pciNetwork;
                    Trace( g_tagNetNotify, _T("(%s) - Adding network '%s'"), m_strPathName, pnotify->m_strName );
                    pciNetwork = PciAddNewNetwork( pnotify->m_strName );
                    if ( pciNetwork != NULL )
                    {
                        ASSERT_VALID( pciNetwork );
                        pciNetwork->AddRef();
                        // For calling Release later. This is done so that
                        // release is called even if ReadItem below throws an exception.
                        pciClusterItemPtr = pciNetwork;
                        pciNetwork->ReadItem();
                    } // if:  network was added
                    break;
                }

            case CLUSTER_CHANGE_NETINTERFACE_ADDED:
                {
                    CNetInterface * pciNetIFace;
                    Trace( g_tagNetIFaceNotify, _T("(%s) - Adding network interface '%s'"), m_strPathName, pnotify->m_strName );
                    pciNetIFace = PciAddNewNetInterface( pnotify->m_strName );
                    if ( pciNetIFace != NULL )
                    {
                        ASSERT_VALID( pciNetIFace );
                        pciNetIFace->AddRef();
                        // For calling Release later. This is done so that
                        // release is called even if ReadItem below throws an exception.
                        pciClusterItemPtr = pciNetIFace;
                        pciNetIFace->ReadItem();
                    } // if:  network interface was added
                    break;
                }

            case CLUSTER_CHANGE_QUORUM_STATE:
                Trace( g_tagDocNotify, _T("(%s) - Quorum state changed (%s)"), m_strPathName, pnotify->m_strName );
                break;

            case CLUSTER_CHANGE_REGISTRY_NAME:
                Trace( g_tagDocRegNotify, _T("(%s) - Registry namespace '%s' changed"), m_strPathName, pnotify->m_strName );
                ProcessRegNotification( pnotify );
                break;

            case CLUSTER_CHANGE_REGISTRY_ATTRIBUTES:
                Trace( g_tagDocRegNotify, _T("(%s) - Registry atributes for '%s' changed"), m_strPathName, pnotify->m_strName );
                ProcessRegNotification( pnotify );
                break;

            case CLUSTER_CHANGE_REGISTRY_VALUE:
                Trace( g_tagDocRegNotify, _T("(%s) - Registry value '%s' changed"), m_strPathName, pnotify->m_strName );
                ProcessRegNotification( pnotify );
                break;

            default:
                Trace( g_tagDocNotify, _T("(%s) - Unknown notification (%x) for '%s'"), m_strPathName, pnotify->m_dwFilterType, pnotify->m_strName );
        } // switch:  dwFilterType
    } // try
    catch ( CException * pe )
    {
        // Don't display anything on notification errors.
        // If it's really a problem, the user will see it when
        // refreshing the view.
        if ( ! m_bIgnoreErrors )
        {
            pe->ReportError();
        } // if: not ignoring errors
        pe->Delete();
    } // catch:  CException

    if ( pciClusterItemPtr != NULL )
    {
        pciClusterItemPtr->Release();
    } // if: cluster item pointer not released yet

    m_bIgnoreErrors = bOldIgnoreErrors;

    // Reset the message on the status bar.
    {
        CFrameWnd * pframe = PframeMain( );
        if ( pframe != NULL )
        {
            pframe->SetMessageText(AFX_IDS_IDLEMESSAGE);
            pframe->UpdateWindow();
        } // if: main frame window is available
    }

    delete pnotify;
    return 0;

} //*** CClusterDoc::OnClusterNotify()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::ProcessRegNotification
//
//  Routine Description:
//      Process registry notifications for the document.
//
//  Arguments:
//      pnotify     [IN] Object describing the notification.
//
//  Return Value:
//      pci         Cluster item that cares about the notification.
//      NULL        Unknown object.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::ProcessRegNotification(IN const CClusterNotify * pnotify)
{
    CCluster *  pci             = NULL;
    HKEY        hkey            = NULL;
    CString     strRootKeyName;

#define RESTYPE_KEY_NAME_PREFIX CLUSREG_KEYNAME_RESOURCE_TYPES _T("\\")

    try
    {
        // If there is no key name, update the cluster item.
        if (pnotify->m_strName.GetLength() == 0)
            pci = PciCluster();
        else
        {
            // Find the root key name.
            strRootKeyName = pnotify->m_strName.SpanExcluding(_T("\\"));

            // If the root key name is the same as the notification name
            // and it is for one of the object type keys, reread the lists
            // of extensions for that one type of object.
            if (strRootKeyName == pnotify->m_strName)
            {
                POSITION    pos;

                // Find the object based on its type.
                if (strRootKeyName == CLUSREG_KEYNAME_NODES)
                {
                    PciCluster()->ReadNodeExtensions();
                    pos = LpciNodes().GetHeadPosition();
                    while (pos != NULL)
                        ((CClusterNode *) LpciNodes().GetNext(pos))->ReadExtensions();
                }  // if:  node registry notification
                else if (strRootKeyName == CLUSREG_KEYNAME_GROUPS)
                {
                    PciCluster()->ReadGroupExtensions();
                    pos = LpciGroups().GetHeadPosition();
                    while (pos != NULL)
                        ((CGroup *) LpciGroups().GetNext(pos))->ReadExtensions();
                }  // else if:  group registry notification
                else if (strRootKeyName == CLUSREG_KEYNAME_RESOURCES)
                {
                    PciCluster()->ReadResourceExtensions();
                    pos = LpciResources().GetHeadPosition();
                    while (pos != NULL)
                        ((CResource *) LpciResources().GetNext(pos))->ReadExtensions();
                }  // else if:  resource registry notification
                else if (strRootKeyName == CLUSREG_KEYNAME_RESOURCE_TYPES)
                {
                    PciCluster()->ReadResTypeExtensions();
                    pos = LpciResourceTypes().GetHeadPosition();
                    while (pos != NULL)
                        ((CResourceType *) LpciResourceTypes().GetNext(pos))->ReadExtensions();
                    pos = LpciResources().GetHeadPosition();
                    while (pos != NULL)
                        ((CResource *) LpciResources().GetNext(pos))->ReadExtensions();
                }  // else if:  resource type registry notification
                else if (strRootKeyName == CLUSREG_KEYNAME_NETWORKS)
                {
                    PciCluster()->ReadNetworkExtensions();
                    pos = LpciNetworks().GetHeadPosition();
                    while (pos != NULL)
                        ((CNetwork *) LpciNetworks().GetNext(pos))->ReadExtensions();
                }  // else if:  network registry notification
                else if (strRootKeyName == CLUSREG_KEYNAME_NETINTERFACES)
                {
                    PciCluster()->ReadNetInterfaceExtensions();
                    pos = LpciNetInterfaces().GetHeadPosition();
                    while (pos != NULL)
                        ((CNetInterface *) LpciNetInterfaces().GetNext(pos))->ReadExtensions();
                }  // else if:  network interface registry notification
            }  // if:  root name and full name are the same
            else if (_tcsnicmp(pnotify->m_strName, RESTYPE_KEY_NAME_PREFIX, lstrlen(RESTYPE_KEY_NAME_PREFIX)) == 0)
            {
                int             idxSlash = pnotify->m_strName.Find(_T('\\'));
                CString         strResTypeName;
                CResource *     pciRes;
                CResourceType * pciResType;
                POSITION        pos;

                strResTypeName = pnotify->m_strName.Mid(idxSlash + 1, lstrlen(pnotify->m_strName) - lstrlen(RESTYPE_KEY_NAME_PREFIX));

                // Re-read the resource type extensions.
                pos = LpciResourceTypes().GetHeadPosition();
                while (pos != NULL)
                {
                    pciResType = (CResourceType *) LpciResourceTypes().GetNext(pos);
                    if (pciResType->StrName().CompareNoCase(strResTypeName) == 0)
                    {
                        pciResType->ReadExtensions();
                        break;
                    } // if: found the resource type
                } // while: more resource types

                // Re-read the resource extensions.
                pos = LpciResources().GetHeadPosition();
                while (pos != NULL)
                {
                    pciRes = (CResource *) LpciResources().GetNext(pos);
                    if (pciRes->StrResourceType() == strResTypeName)
                    {
                        pciRes->ReadExtensions();
                    } // if: found a resource of that type
                } // while: more resources
            } // else if: single resource type changed

            pci = PciCluster();
        } // else:  not the cluster object

        // If the cluster object can process it, have it re-read its info
        if (pci != NULL)
        {
            pci->MarkAsChanged();
            pci->ReadClusterExtensions();
        }  // if:  cluster object changed
    }  // try
    catch (...)
    {
    }

    if (hkey != NULL)
        ::ClusterRegCloseKey(hkey);

}  //*** CClusterDoc::ProcessRegNotification()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\clusitem.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ClusItem.inl
//
//	Abstract:
//		Inline function implementations for the CClusterItem class.
//
//	Author:
//		David Potter (davidp)	May 9, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSITEM_INL_
#define _CLUSITEM_INL_

/////////////////////////////////////////////////////////////////////////////
//	Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSITEM_H_
#include "ClusItem.h"	// for CClusterItem
#endif

#ifndef _CLUSDOC_H_
#include "ClusDoc.h"	// for CClusterDoc
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline Function Definitions
/////////////////////////////////////////////////////////////////////////////

inline HCLUSTER CClusterItem::Hcluster(void) const
{
	ASSERT_VALID(Pdoc());
	return Pdoc()->Hcluster();

}  //*** CClusterItem::Hcluster()

inline HKEY CClusterItem::HkeyCluster(void) const
{
	ASSERT_VALID(Pdoc());
	return Pdoc()->HkeyCluster();

}  //*** CClusterItem::HkeyCluster()

/////////////////////////////////////////////////////////////////////////////

#endif // _CLUSITEM_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\clusdoc.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ClusDoc.h
//
//  Abstract:
//      Definition of the CClusterDoc class.
//
//  Implementation File:
//      ClusDoc.cpp
//
//  Author:
//      David Potter (davidp)   May 1, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSDOC_H_
#define _CLUSDOC_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _NODE_H_
#include "Node.h"       // for CNodeList
#endif

#ifndef _GROUP_H_
#include "Group.h"      // for CGroupList
#endif

#ifndef _RES_H_
#include "Res.h"        // for CResourceList
#endif

#ifndef _RESTYPE_H_
#include "ResType.h"    // for CResourceTypeList
#endif

#ifndef _NETWORK_H_
#include "Network.h"    // for CNetworkList
#endif

#ifndef _NETIFACE_H_
#include "NetIFace.h"   // for CNetInterfaceList
#endif

#ifndef _TREEITEM_H_
#include "TreeItem.h"   // for CTreeItem
#endif

#ifndef _NOTIFY_H_
#include "Notify.h"     // for CClusterNotifyKeyList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterDoc;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterNotify;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CClusterDoc
/////////////////////////////////////////////////////////////////////////////

class CClusterDoc : public CDocument
{
    friend class CCluster;
    friend class CClusterTreeView;
    friend class CClusterListView;
    friend class CCreateResourceWizard;

protected: // create from serialization only
    CClusterDoc(void);
    DECLARE_DYNCREATE(CClusterDoc)

// Attributes
protected:
    CString             m_strName;
    CString             m_strNode;
    HCLUSTER            m_hcluster;
    HKEY                m_hkeyCluster;
    CCluster *          m_pciCluster;
    CTreeItem *         m_ptiCluster;

    CNodeList           m_lpciNodes;
    CGroupList          m_lpciGroups;
    CResourceList       m_lpciResources;
    CResourceTypeList   m_lpciResourceTypes;
    CNetworkList        m_lpciNetworks;
    CNetInterfaceList   m_lpciNetInterfaces;

    CClusterItemList    m_lpciToBeDeleted;

    BOOL                m_bClusterAvailable;

public:
    const CString &     StrName(void) const     { return m_strName; }
    const CString &     StrNode(void) const     { return m_strNode; }
    HCLUSTER            Hcluster(void) const    { return m_hcluster; }
    HKEY                HkeyCluster(void) const { return m_hkeyCluster; }
    CCluster *          PciCluster(void) const  { return m_pciCluster; }
    CTreeItem *         PtiCluster(void) const  { return m_ptiCluster; }

    CNodeList &         LpciNodes(void)         { return m_lpciNodes; }
    CGroupList &        LpciGroups(void)        { return m_lpciGroups; }
    CResourceTypeList & LpciResourceTypes(void) { return m_lpciResourceTypes; }
    CResourceList &     LpciResources(void)     { return m_lpciResources; }
    CNetworkList &      LpciNetworks(void)      { return m_lpciNetworks; }
    CNetInterfaceList & LpciNetInterfaces(void) { return m_lpciNetInterfaces; }

    CClusterItemList &  LpciToBeDeleted(void)   { return m_lpciToBeDeleted; }

    BOOL                BClusterAvailable(void) const   { return m_bClusterAvailable; }

// Operations
public:
    void                UpdateTitle(void);
    void                Refresh(void)           { OnCmdRefresh(); }

// Overrides
public:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClusterDoc)
    public:
    virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
    virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU = TRUE);
    virtual void DeleteContents();
    virtual void OnCloseDocument();
    virtual void OnChangedViewList();
    //}}AFX_VIRTUAL

    void                OnSelChanged(IN CClusterItem * pciSelected);
    LRESULT             OnClusterNotify(IN OUT CClusterNotify * pnotify);
    void                SaveSettings(void);

// Implementation
public:
    virtual ~CClusterDoc(void);
#ifdef _DEBUG
    virtual void        AssertValid(void) const;
    virtual void        Dump(CDumpContext& dc) const;
#endif

protected:
    void                OnOpenDocumentWorker(LPCTSTR lpszPathName);
    void                BuildBaseHierarchy(void);
    void                CollectClusterItems(void) ;
    ID                  IdProcessNewObjectError(IN OUT CException * pe);
    void                AddDefaultColumns(IN OUT CTreeItem * pti);

    CClusterNode *      PciAddNewNode(IN LPCTSTR pszName);
    CGroup *            PciAddNewGroup(IN LPCTSTR pszName);
    CResource *         PciAddNewResource(IN LPCTSTR pszName);
    CResourceType *     PciAddNewResourceType(IN LPCTSTR pszName);
    CNetwork *          PciAddNewNetwork(IN LPCTSTR pszName);
    CNetInterface *     PciAddNewNetInterface(IN LPCTSTR pszName);

    void                InitNodes(void);
    void                InitGroups(void);
    void                InitResources(void);
    void                InitResourceTypes(void);
    void                InitNetworks(void);
    void                InitNetInterfaces(void);

    BOOL                m_bUpdateFrameNumber;
    BOOL                m_bInitializing;
    BOOL                m_bIgnoreErrors;

    // This menu stuff allows the menu to change depending on what
    // kind of object is currently selected.
    HMENU               m_hmenuCluster;
    HMENU               m_hmenuNode;
    HMENU               m_hmenuGroup;
    HMENU               m_hmenuResource;
    HMENU               m_hmenuResType;
    HMENU               m_hmenuNetwork;
    HMENU               m_hmenuNetIFace;
    HMENU               m_hmenuCurrent;
    IDM                 m_idmCurrentMenu;
    virtual HMENU       GetDefaultMenu(void);

    void                ProcessRegNotification(IN const CClusterNotify * pnotify);

// Generated message map functions
protected:
    //{{AFX_MSG(CClusterDoc)
    afx_msg void OnCmdNewGroup();
    afx_msg void OnCmdNewResource();
    afx_msg void OnCmdNewNode();
    afx_msg void OnCmdConfigApp();
    afx_msg void OnCmdRefresh();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CClusterDoc

/////////////////////////////////////////////////////////////////////////////

#endif // _CLUSDOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\clusitem.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      ClusItem.h
//
//  Abstract:
//      Definition of the CClusterItem class.
//
//  Implementation File:
//      ClusItem.cpp
//
//  Author:
//      David Potter (davidp)   May 3, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSITEM_H_
#define _CLUSITEM_H_

/////////////////////////////////////////////////////////////////////////////
//  Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESOURCE_H_
#include "resource.h"
#define _RESOURCE_H_
#endif

#ifndef _BASECMDT_H_
#include "BaseCmdT.h"   // for CBaseCmdTarget
#endif

#ifndef _TREEITEM_H_
#include "TreeItem.h"   // for CTreeItemList;
#endif

#ifndef _LISTITEM_H_
#include "ListItem.h"   // for CListItemList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterItem;
class CClusterItemList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterDoc;
class CClusterNotify;
class CClusterNotifyKey;
class CClusPropList;
class CObjectProperty;
#ifdef _DEBUG
class CTraceTag;
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterItem command target
/////////////////////////////////////////////////////////////////////////////

class CClusterItem : public CBaseCmdTarget
{
    DECLARE_DYNCREATE(CClusterItem)

// Construction
public:
    CClusterItem(void);         // protected constructor used by dynamic creation
    CClusterItem(
        IN const CString *  pstrName,
        IN IDS              idsType = IDS_ITEMTYPE_CONTAINER,
        IN const CString *  pstrDescription = NULL
        );
    void                Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName);

protected:
    void                CommonConstruct(void);

// Attributes
protected:
    HKEY                m_hkey;
    CString             m_strName;
    CString             m_strType;
    CString             m_strDescription;
    IDS                 m_idsType;
    UINT                m_iimgObjectType;
    UINT                m_iimgState;

    CClusterDoc *       m_pdoc;
    IDM                 m_idmPopupMenu;
    BOOL                m_bDocObj;
    BOOL                m_bChanged;
    BOOL                m_bReadOnly;

    IDM                 IdmPopupMenu(void) const    { return m_idmPopupMenu; }

public:
    HKEY                Hkey(void) const            { return m_hkey; }
    const CString &     StrName(void) const         { return m_strName; }
    const CString &     StrType(void) const         { return m_strType; }
    const CString &     StrDescription(void) const  { return m_strDescription; }
    IDS                 IdsType(void) const         { return m_idsType; }
    UINT                IimgObjectType(void) const  { return m_iimgObjectType; }
    UINT                IimgState(void) const       { return m_iimgState; }

    CClusterDoc *       Pdoc(void) const            { return m_pdoc; }
    BOOL                BDocObj(void) const         { return m_bDocObj; }
    BOOL                BChanged(void) const        { return m_bChanged; }
    BOOL                BReadOnly(void) const       { return m_bReadOnly; }

    void                MarkAsChanged(IN BOOL bChanged = TRUE)  { m_bChanged = bChanged; }

#ifndef _DISPLAY_STATE_TEXT_IN_TREE
    void                GetTreeName(OUT CString & rstrName) const { rstrName = StrName(); }
#endif

    // Inline functions defined in ClusItem.inl because they reference
    // CClusterDoc, which isn't defined yet when this class is being defined.
    HCLUSTER            Hcluster(void) const;
    HKEY                HkeyCluster(void) const;

// Operations
public:
    void                Delete(void);
    void                RemoveItem(void);

    DWORD               DwReadValue(IN LPCTSTR pszValueName, IN LPCTSTR pszKeyName, OUT CString & rstrValue);
    DWORD               DwReadValue(IN LPCTSTR pszValueName, IN LPCTSTR pszKeyName, OUT CStringList & rlstrValue);
    DWORD               DwReadValue(IN LPCTSTR pszValueName, IN LPCTSTR pszKeyName, OUT DWORD * pdwValue);
    DWORD               DwReadValue(IN LPCTSTR pszValueName, IN LPCTSTR pszKeyName, OUT DWORD * pdwValue, IN DWORD dwDefault);
    DWORD               DwReadValue(IN LPCTSTR pszValueName, IN LPCTSTR pszKeyName, OUT LPBYTE * ppbValue);

    DWORD               DwReadValue(IN LPCTSTR pszValueName, OUT CString & rstrValue)
                            { return DwReadValue(pszValueName, NULL, rstrValue); }
    DWORD               DwReadValue(IN LPCTSTR pszValueName, OUT CStringList & rlstrValue)
                            { return DwReadValue(pszValueName, NULL, rlstrValue); }
    DWORD               DwReadValue(IN LPCTSTR pszValueName, OUT DWORD * pdwValue)
                            { return DwReadValue(pszValueName, NULL, pdwValue); }
    DWORD               DwReadValue(IN LPCTSTR pszValueName, OUT DWORD * pdwValue, IN DWORD dwDefault)
                            { return DwReadValue(pszValueName, NULL, pdwValue, dwDefault); }
    DWORD               DwReadValue(IN LPCTSTR pszValueName, OUT LPBYTE * ppbValue)
                            { return DwReadValue(pszValueName, NULL, ppbValue); }

    void                WriteValue(IN LPCTSTR pszValueName, IN LPCTSTR pszKeyName, IN const CString & rstrValue);
    void                WriteValue(IN LPCTSTR pszValueName, IN LPCTSTR pszKeyName, IN const CStringList & rlstrValue);
    void                WriteValue(IN LPCTSTR pszValueName, IN LPCTSTR pszKeyName, IN DWORD dwValue);
    void                WriteValue(
                                IN LPCTSTR          pszValueName,
                                IN LPCTSTR          pszKeyName, 
                                IN const LPBYTE     pbValue,
                                IN DWORD            cbValue,
                                IN OUT LPBYTE *     ppbPrevValue,
                                IN DWORD            cbPrevValue
                                );

    void                WriteValue(IN LPCTSTR pszValueName, IN const CString & rstrValue)
                            { WriteValue(pszValueName, NULL, rstrValue); }
    void                WriteValue(IN LPCTSTR pszValueName, IN const CStringList & rlstrValue)
                            { WriteValue(pszValueName, NULL, rlstrValue); }
    void                WriteValue(IN LPCTSTR pszValueName, IN DWORD dwValue)
                            { WriteValue(pszValueName, NULL, dwValue); }
    void                WriteValue(
                                IN LPCTSTR          pszValueName,
                                IN const LPBYTE     pbValue,
                                IN DWORD            cbValue,
                                IN OUT LPBYTE *     ppbPrevValue,
                                IN DWORD            cbPrevValue
                                )
                            { WriteValue(pszValueName, NULL, pbValue, cbValue, ppbPrevValue, cbPrevValue); }

    void                DeleteValue(IN LPCTSTR pszValueName, IN LPCTSTR pszKeyName = NULL);

    CMenu *             PmenuPopup(void);

    BOOL                BDifferent(IN const CStringList & rlstr1, IN const CStringList & rlstr2);
    BOOL                BDifferentOrdered(IN const CStringList & rlstr1, IN const CStringList & rlstr2);

// Overrides
public:
    virtual LPCTSTR     PszTitle(void) const        { return m_strName; }
    virtual void        Cleanup(void)               { return; }
    virtual void        ReadItem(void)              { return; }
    virtual void        WriteItem(void);
    virtual void        UpdateState(void);
    virtual void        Rename(IN LPCTSTR pszName)  { return; }
    virtual BOOL        BGetColumnData(IN COLID colid, OUT CString & rstrText);
    virtual BOOL        BCanBeEdited(void) const    { return FALSE; }
    virtual void        OnBeginLabelEdit(IN OUT CEdit * pedit) { return; }
    virtual BOOL        BDisplayProperties(IN BOOL bReadOnly = FALSE);
    virtual BOOL        BIsLabelEditValueValid(IN LPCTSTR pszName) { return TRUE; }

    // Drag & Drop
    virtual BOOL        BCanBeDragged(void) const   { return FALSE; }
    virtual BOOL        BCanBeDropTarget(IN const CClusterItem * pci) const { return FALSE; }
    virtual void        DropItem(IN OUT CClusterItem * pci)
    {
    }

    virtual const CStringList * PlstrExtensions(void) const;

#ifdef _DISPLAY_STATE_TEXT_IN_TREE
    virtual void        GetTreeName(OUT CString & rstrName) const;
#endif

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClusterItem)
    //}}AFX_VIRTUAL

    virtual LRESULT     OnClusterNotify(IN OUT CClusterNotify * pnotify);

protected:
    virtual const CObjectProperty * Pprops(void) const  { return NULL; }
    virtual DWORD                   Cprops(void) const  { return 0; }
    virtual DWORD                   DwParseProperties(IN const CClusPropList & rcpl);
    virtual DWORD                   DwParseUnknownProperty(
                                        IN LPCWSTR                          pwszName,
                                        IN const CLUSPROP_BUFFER_HELPER &   rvalue,
                                        IN DWORD                            cbBuf
                                        )       { return ERROR_SUCCESS; }
    virtual void                    SetCommonProperties(IN BOOL bValidateOnly = FALSE);
    virtual void                    BuildPropList(IN OUT CClusPropList & rcpl);
    virtual DWORD                   DwSetCommonProperties(IN const CClusPropList & rcpl, IN BOOL bValidateOnly = FALSE)
                                        { ASSERT(0); return ERROR_INVALID_FUNCTION; }

// Implementation
public:
    virtual ~CClusterItem(void);

protected:
    CClusterNotifyKey * m_pcnk;
    CTreeItemList       m_lptiBackPointers;
    CListItemList       m_lpliBackPointers;

public:
    const CClusterNotifyKey *   Pcnk(void) const    { return m_pcnk; }
    CTreeItemList &     LptiBackPointers(void)      { return m_lptiBackPointers; }
    CListItemList &     LpliBackPointers(void)      { return m_lpliBackPointers; }
    void                AddTreeItem(CTreeItem * pti);
    void                AddListItem(CListItem * pli);
    void                RemoveTreeItem(CTreeItem * pti);
    void                RemoveListItem(CListItem * pli);

#undef afx_msg
#define afx_msg virtual

    // Generated message map functions
    //{{AFX_MSG(CClusterItem)
    afx_msg void OnUpdateRename(CCmdUI* pCmdUI);
    afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
    afx_msg void OnCmdProperties();
    //}}AFX_MSG

#undef afx_msg
#define afx_msg

    DECLARE_MESSAGE_MAP()

};  //*** class CClusterItem

/////////////////////////////////////////////////////////////////////////////
// CClusterItemList
//
// Every time an item is added to or removed from the list, its reference
// count is updated.
/////////////////////////////////////////////////////////////////////////////

//class CClusterItemList : public CTypedPtrList<CObList, CClusterItem *>
class CClusterItemList : public CList<CClusterItem *, CClusterItem *>
{
public:
// Operations
    CClusterItem *  PciFromName(
                        IN LPCTSTR      pszName,
                        OUT POSITION *  ppos = NULL
                        );

    // add before head or after tail
    POSITION AddHead(CClusterItem * newElement)
    {
        ASSERT_VALID(newElement);
        POSITION pos = CList<CClusterItem *,CClusterItem *>::AddHead(newElement);
        if (pos != NULL)
            newElement->AddRef();
        return pos;
    }
    POSITION AddTail(CClusterItem * newElement)
    {
        ASSERT_VALID(newElement);
        POSITION pos = CList<CClusterItem *,CClusterItem *>::AddTail(newElement);
        if (pos != NULL)
            newElement->AddRef();
        return pos;
    }

    // inserting before or after a given position
    POSITION InsertBefore(POSITION position, CClusterItem * newElement)
    {
        ASSERT_VALID(newElement);
        POSITION pos = CList<CClusterItem *,CClusterItem *>::InsertBefore(position, newElement);
        if (pos != NULL)
            newElement->AddRef();
        return pos;
    }
    POSITION InsertAfter(POSITION position, CClusterItem * newElement)
    {
        ASSERT_VALID(newElement);
        POSITION pos = CList<CClusterItem *,CClusterItem *>::InsertAfter(position, newElement);
        if (pos != NULL)
            newElement->AddRef();
        return pos;
    }

//  void RemoveAll(void);

};  //*** class CClusterItemList

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

void AFXAPI DestructElements(CClusterItem ** pElements, int nCount);
void DeleteAllItemData(IN OUT CClusterItemList & rlp);

/////////////////////////////////////////////////////////////////////////////
//  Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
extern CTraceTag g_tagClusItemCreate;
extern CTraceTag g_tagClusItemDelete;
extern CTraceTag g_tagClusItemNotify;
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _CLUSITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\clusmru.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ClusMru.h
//
//	Abstract:
//		Definition of the CRecentClusterList class.
//
//	Author:
//		David Potter (davidp)	May 3, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSMRU_H_
#define _CLUSMRU_H_

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

/////////////////////////////////////////////////////////////////////////////
//	Include Files
/////////////////////////////////////////////////////////////////////////////

#if _MFC_VER < 0x0410
#ifndef __AFXPRIV_H__
#include "afxpriv.h"
#endif
#else
#ifndef __AFXADV_H__
#include "afxadv.h"
#endif
#endif

/////////////////////////////////////////////////////////////////////////////
// CRecentClusterList:
// See ClusMru.cpp for the implementation of this class
//

class CRecentClusterList : public CRecentFileList
{
public:
	// Constructors
	CRecentClusterList(
			UINT	nStart,
			LPCTSTR	lpszSection,
			LPCTSTR	lpszEntryFormat,
			int		nSize,
			int		nMaxDispLen = AFX_ABBREV_FILENAME_LEN
			)
		: CRecentFileList(nStart, lpszSection, lpszEntryFormat, nSize, nMaxDispLen) { }

	// Operations
	virtual void Add(LPCTSTR lpszPathName);
	BOOL GetDisplayName(CString& strName, int nIndex,
		LPCTSTR lpszCurDir, int nCurDir, BOOL bAtLeastName = TRUE) const;
	virtual void UpdateMenu(CCmdUI* pCmdUI);

};  //*** class CRecentClusterList

/////////////////////////////////////////////////////////////////////////////

#endif // _CLUSMRU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\clusitem.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c ) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ClusItem.cpp
//
//  Description:
//      Implementation of the CClusterItem class.
//
//  Maintained By:
//      David Potter (davidp )   May 6, 1996
//
//  Revision History:
//
//  Modified to fix bugs associated with open/close state of m_hkey.
//  m_hkey will be closed upon destruction of CClusterItem.
//  Roderick Sharper March 23, 1997.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "ClusItem.h"
#include "ClusDoc.h"
#include "ExcOper.h"
#include "TraceTag.h"
#include "TreeItem.inl"
#include "PropList.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag g_tagClusItemCreate( _T("Create"), _T("CLUSTER ITEM CREATE"), 0 );
CTraceTag g_tagClusItemDelete( _T("Delete"), _T("CLUSTER ITEM DELETE"), 0 );
CTraceTag g_tagClusItemNotify( _T("Notify"), _T("CLUSTER ITEM NOTIFY"), 0 );
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterItemList
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItemList::PciFromName
//
//  Routine Description:
//      Find a cluster item in the list by its name.
//
//  Arguments:
//      pszName     [IN] Name of item to look for.
//      ppos        [OUT] Position of the item in the list.
//
//  Return Value:
//      pci         Cluster item corresponding the the specified name.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterItem * CClusterItemList::PciFromName(
    IN LPCTSTR      pszName,
    OUT POSITION *  ppos    // = NULL
   )
{
    POSITION        posPci;
    POSITION        posCurPci;
    CClusterItem *  pci = NULL;

    ASSERT( pszName != NULL );

    posPci = GetHeadPosition( );
    while ( posPci != NULL )
    {
        posCurPci = posPci;
        pci = GetNext( posPci );
        ASSERT_VALID( pci );

        if ( pci->StrName( ).CompareNoCase( pszName ) == 0 )
        {
            if ( ppos != NULL )
            {
                *ppos = posCurPci;
            } // if
            break;
        }  // if:  found a match

        pci = NULL;
    }  // while:  more resources in the list

    return pci;

}  //*** CClusterItemList::PciFromName( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItemList::RemoveAll
//
//  Routine Description:
//      Remove all items from the list, decrementing the reference count
//      on each one first.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Note:
//      This routine is not virtual, so calls to the base class will
//      not go through this routine.  Also, it does not call the base
//      class method.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef NEVER
void CClusterItemList::RemoveAll( void )
{
    ASSERT_VALID( this );

    // destroy elements
    CNode * pNode;
    for ( pNode = m_pNodeHead ; pNode != NULL ; pNode = pNode->pNext )
    {
//      ((CClusterItem *) pNode->data)->Release( );
        DestructElements( (CClusterItem**) &pNode->data, 1 );
    }  // for:  each node in the list

    // Call the base class method.
    CObList::RemoveAll( );

}  //*** CClusterItemList::RemoveAll( )
#endif


//***************************************************************************


/////////////////////////////////////////////////////////////////////////////
// CClusterItem
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE( CClusterItem, CBaseCmdTarget )

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP( CClusterItem, CBaseCmdTarget )
    //{{AFX_MSG_MAP(CClusterItem)
    ON_UPDATE_COMMAND_UI(ID_FILE_RENAME, OnUpdateRename)
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
    ON_COMMAND(ID_FILE_PROPERTIES, OnCmdProperties)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::CClusterItem
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterItem::CClusterItem( void )
{
    CommonConstruct( );

}  //*** CClusterItem::CClusterItem( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::CClusterItem
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pstrName        [IN] Name of the item.
//      idsType         [IN] Type ID of the item.
//      pstrDescription [IN] Description of the item.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterItem::CClusterItem(
    IN const CString *  pstrName,
    IN IDS              idsType,
    IN const CString *  pstrDescription
    )
{
    CommonConstruct( );

    if ( pstrName != NULL )
    {
        m_strName = *pstrName;
    } // if

    if ( idsType == 0 )
    {
        idsType = IDS_ITEMTYPE_CONTAINER;
    } // if
    m_idsType = idsType;
    m_strType.LoadString( IdsType( ) );

    if ( pstrDescription != NULL )
    {
        m_strDescription = *pstrDescription;
    } // if

    Trace( g_tagClusItemCreate, _T("CClusterItem( ) - Creating '%s' (%s )"), m_strName, m_strType );

}  //*** CClusterItem::CClusterItem( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::CommonConstruct( void )
{
    m_hkey = NULL;
    m_idsType = IDS_ITEMTYPE_CONTAINER;
    m_strType.LoadString( IDS_ITEMTYPE_CONTAINER );
    m_iimgObjectType = 0;
    m_iimgState = GetClusterAdminApp( )->Iimg( IMGLI_FOLDER );
    m_pdoc = NULL;
    m_idmPopupMenu = 0;
    m_bDocObj = TRUE;
    m_bChanged = FALSE;
    m_bReadOnly = FALSE;
    m_pcnk = NULL;

}  //*** CClusterItem::CommonConstruct( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::~CClusterItem
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterItem::~CClusterItem( void )
{
    Trace( g_tagClusItemDelete, _T("~CClusterItem( ) - Deleting cluster item '%s'"), StrName( ) );

    // Empty the lists.
    DeleteAllItemData( LptiBackPointers( ) );
    DeleteAllItemData( LpliBackPointers( ) );
    LptiBackPointers( ).RemoveAll( );
    LpliBackPointers( ).RemoveAll( );

    // Close the registry key.
    if ( Hkey( ) != NULL )
    {
        ClusterRegCloseKey( Hkey( ) );
        m_hkey = NULL;
    } // if

    // Remove the notification key and delete it.
    if ( BDocObj( ) )
    {
        POSITION    pos;

        pos = GetClusterAdminApp( )->Cnkl( ).Find( m_pcnk );
        if ( pos != NULL )
        {
            GetClusterAdminApp( )->Cnkl( ).RemoveAt( pos );
        } // if
        Trace( g_tagClusItemNotify, _T("~CClusterItem( ) - Deleting notification key (%08.8x ) for '%s'"), m_pcnk, StrName( ) );
        delete m_pcnk;
        m_pcnk = NULL;
    }  // if:  object resides in the document

    Trace( g_tagClusItemDelete, _T("~CClusterItem( ) - Done deleting cluster item '%s'"), StrName( ) );

}  //*** CClusterItem::~CClusterItem( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::Delete
//
//  Routine Description:
//      Delete the item.  If the item still has references, add it to the
//      document's pending delete list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::Delete( void )
{
    // Add a reference so that we don't delete ourselves while
    // still doing cleanup.
    AddRef( );

    // Cleanup this object.
    Cleanup( );

    // Remove the item from all lists and views.
    CClusterItem::RemoveItem( );

    // If there are still references to this object, add it to the delete
    // pending list.  Check for greater than 1 because we added a reference
    // at the beginning of this method.
    if ( ( Pdoc( ) != NULL ) && ( NReferenceCount( ) > 1 ) )
    {
        if ( Pdoc( )->LpciToBeDeleted( ).Find( this ) == NULL )
        {
            Pdoc( )->LpciToBeDeleted( ).AddTail( this );
        } // if
    }  // if:  object still has references to it

    // Release the reference we added at the beginning.  This will
    // cause the object to be deleted if we were the last reference.
    Release( );

}  //*** CClusterItem::Delete( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::Init
//
//  Routine Description:
//      Initialize the item.
//
//  Arguments:
//      pdoc        [IN OUT] Document to which this item belongs.
//      lpszName    [IN] Name of the item.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CNotifyKey::new( ) or
//      CNotifyKeyList::AddTail( ).
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::Init( IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName )
{
    ASSERT_VALID( pdoc );
    ASSERT( lpszName != NULL );

    // Save parameters.
    m_pdoc = pdoc;
    m_strName = lpszName;

    Trace( g_tagClusItemCreate, _T("Init( ) - Initializing '%s' (%s )"), m_strName, m_strType );

    // Find the notification key for this item in the document's list.
    // If one is not found, allocate one.
    if ( BDocObj( ) )
    {
        POSITION            pos;
        CClusterNotifyKey * pcnk    = NULL;

        pos = GetClusterAdminApp( )->Cnkl( ).GetHeadPosition( );
        while ( pos != NULL )
        {
            pcnk = GetClusterAdminApp( )->Cnkl( ).GetNext( pos );
            if ( ( pcnk->m_cnkt == cnktClusterItem )
              && ( pcnk->m_pci == this )
               )
                break;
            pcnk = NULL;
        }  // while:  more items in the list

        // If a key was not found, allocate a new one.
        if ( pcnk == NULL )
        {
            pcnk = new CClusterNotifyKey( this, lpszName );
            if ( pcnk == NULL )
            {
                ThrowStaticException( GetLastError( ) );
            } // if: error allocating the notify key
            try
            {
                GetClusterAdminApp( )->Cnkl( ).AddTail( pcnk );
                Trace( g_tagClusItemNotify, _T("Init( ) - Creating notification key (%08.8x ) for '%s'"), pcnk, StrName( ) );
            }  // try
            catch ( ... )
            {
                delete pcnk;
                throw;
            }  // catch:  anything
        }  // if:  key wasn't found

        m_pcnk = pcnk;
    }  // if:  object resides in the document

}  //*** CClusterItem::Init( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::PlstrExtensions
//
//  Routine Description:
//      Return the list of admin extensions.
//
//  Arguments:
//      None.
//
//  Return Value:
//      plstr       List of extensions.
//      NULL        No extension associated with this object.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CStringList * CClusterItem::PlstrExtensions( void ) const
{
    return NULL;

}  //*** CClusterItem::PlstrExtensions( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::RemoveItem
//
//  Routine Description:
//      Remove the item from all lists and views.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::RemoveItem( void )
{
    // Remove the item from each tree item.
    {
        POSITION    posPti;
        CTreeItem * pti;

        posPti = LptiBackPointers( ).GetHeadPosition( );
        while ( posPti != NULL )
        {
            pti = LptiBackPointers( ).GetNext( posPti );
            ASSERT_VALID( pti );
            ASSERT_VALID( pti->PtiParent( ) );
            Trace( g_tagClusItemDelete, _T("RemoveItem( ) - Deleting tree item backptr from '%s' in '%s' - %d left"), StrName( ), pti->PtiParent( )->StrName( ), LptiBackPointers( ).GetCount( ) - 1 );
            pti->RemoveItem( );
        }  // while:  more items in the list
    }  // Remove the item from each tree item

    // Remove the item from each list item.
    {
        POSITION    posPli;
        CListItem * pli;

        posPli = LpliBackPointers( ).GetHeadPosition( );
        while ( posPli != NULL )
        {
            pli = LpliBackPointers( ).GetNext( posPli );
            ASSERT_VALID( pli );
            ASSERT_VALID( pli->PtiParent( ) );
            Trace( g_tagClusItemDelete, _T("RemoveItem( ) - Deleting list item backptr from '%s' in '%s' - %d left"), StrName( ), pli->PtiParent( )->StrName( ), LpliBackPointers( ).GetCount( ) - 1 );
            pli->PtiParent( )->RemoveChild( pli->Pci( ) );
        }  // while:  more items in the list
    }  // Remove the item from each tree item

}  //*** CClusterItem::RemoveItem( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::WriteItem
//
//  Routine Description:
//      Write the item parameters to the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by WriteItem( ).
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::WriteItem( void )
{
}  //*** CClusterItem::WriteItem( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::DwParseProperties
//
//  Routine Description:
//      Parse the properties of the resource.  This is in a separate function
//      from BInit so that the optimizer can do a better job.
//
//  Arguments:
//      rcpl            [IN] Cluster property list to parse.
//
//  Return Value:
//      ERROR_SUCCESS   Properties were parsed successfully.
//
//  Exceptions Thrown:
//      Any exceptions from CString::operator=( ).
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterItem::DwParseProperties( IN const CClusPropList & rcpl )
{
    DWORD                           cProps;
    DWORD                           cprop;
    DWORD                           cbProps;
    const CObjectProperty *         pprop;
    CLUSPROP_BUFFER_HELPER          props;
    CLUSPROP_PROPERTY_NAME const *  pName;

    ASSERT( rcpl.PbPropList( ) != NULL );

    props.pb = rcpl.PbPropList( );
    cbProps = rcpl.CbPropList( );

    // Loop through each property.
    for ( cProps = *(props.pdw++ ) ; cProps > 0 ; cProps-- )
    {
        pName = props.pName;
        ASSERT( pName->Syntax.dw == CLUSPROP_SYNTAX_NAME );
        props.pb += sizeof( *pName ) + ALIGN_CLUSPROP( pName->cbLength );

        // Decrement the counter by the size of the name.
        ASSERT( cbProps > sizeof( *pName ) + ALIGN_CLUSPROP( pName->cbLength ) );
        cbProps -= sizeof( *pName ) + ALIGN_CLUSPROP( pName->cbLength );

        ASSERT( cbProps > sizeof( *props.pValue ) + ALIGN_CLUSPROP( props.pValue->cbLength ) );

        // Parse known properties.
        for ( pprop = Pprops( ), cprop = Cprops( ) ; cprop > 0 ; pprop++, cprop-- )
        {
            if ( lstrcmpiW( pName->sz, pprop->m_pwszName ) == 0 )
            {
                ASSERT( props.pSyntax->wFormat == pprop->m_propFormat );
                switch ( pprop->m_propFormat )
                {
                    case CLUSPROP_FORMAT_SZ:
                        ASSERT( ( props.pValue->cbLength == ( lstrlenW( props.pStringValue->sz ) + 1 ) * sizeof( WCHAR ) )
                             || ( (props.pValue->cbLength == 0 ) && ( props.pStringValue->sz[ 0 ] == L'\0' ) ) );
                        *pprop->m_valuePrev.pstr = props.pStringValue->sz;
                        break;
                    case CLUSPROP_FORMAT_DWORD:
                    case CLUSPROP_FORMAT_LONG:
                        ASSERT( props.pValue->cbLength == sizeof( DWORD ) );
                        *pprop->m_valuePrev.pdw = props.pDwordValue->dw;
                        break;
                    case CLUSPROP_FORMAT_BINARY:
                    case CLUSPROP_FORMAT_MULTI_SZ:
                        *pprop->m_valuePrev.ppb = props.pBinaryValue->rgb;
                        *pprop->m_valuePrev.pcb = props.pBinaryValue->cbLength;
                        break;
                    default:
                        ASSERT( 0 );  // don't know how to deal with this type
                }  // switch:  property format

                // Exit the loop since we found the parameter.
                break;
            }  // if:  found a match
        }  // for:  each property

        // If the property wasn't known, ask the derived class to parse it.
        if ( cprop == 0 )
        {
            DWORD       dwStatus;

            dwStatus = DwParseUnknownProperty( pName->sz, props, cbProps );
            if ( dwStatus != ERROR_SUCCESS )
            {
                return dwStatus;
            } // if
        }  // if:  property not parsed

        // Advance the buffer pointer past the value in the value list.
        while ( ( props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK )
             && ( cbProps > 0 ) )
        {
            ASSERT( cbProps > sizeof( *props.pValue ) + ALIGN_CLUSPROP( props.pValue->cbLength ) );
            cbProps -= sizeof( *props.pValue ) + ALIGN_CLUSPROP( props.pValue->cbLength );
            props.pb += sizeof( *props.pValue ) + ALIGN_CLUSPROP( props.pValue->cbLength );
        }  // while:  more values in the list

        // Advance the buffer pointer past the value list endmark.
        ASSERT( cbProps >= sizeof( *props.pSyntax ) );
        cbProps -= sizeof( *props.pSyntax );
        props.pb += sizeof( *props.pSyntax ); // endmark
    }  // for:  each property

    return ERROR_SUCCESS;

}  //*** CClusterItem::DwParseProperties( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::SetCommonProperties
//
//  Routine Description:
//      Set the common properties for this object in the cluster database.
//
//  Arguments:
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by WriteItem( ).
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::SetCommonProperties( IN BOOL bValidateOnly )
{
    DWORD           dwStatus    = ERROR_SUCCESS;
    CClusPropList   cpl;
    CWaitCursor     wc;

    // Save data.
    {
        // Build the property list and set the data.
        try
        {
            BuildPropList( cpl );
            dwStatus = DwSetCommonProperties( cpl, bValidateOnly );
        }  // try
        catch ( CMemoryException * pme )
        {
            pme->Delete( );
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        }  // catch:  CMemoryException

        // Handle errors.
        if ( dwStatus != ERROR_SUCCESS )
        {
            if ( dwStatus != ERROR_RESOURCE_PROPERTIES_STORED )
            {
                ThrowStaticException( dwStatus, IDS_APPLY_PARAM_CHANGES_ERROR );
            } // if
        }  // if:  error setting properties

        if ( ! bValidateOnly && ( dwStatus == ERROR_SUCCESS ) )
        {
            DWORD                   cprop;
            const CObjectProperty * pprop;

            // Save new values as previous values.

            for ( pprop = Pprops( ), cprop = Cprops( ) ; cprop > 0 ; pprop++, cprop-- )
            {
                switch ( pprop->m_propFormat )
                {
                    case CLUSPROP_FORMAT_SZ:
                        ASSERT( pprop->m_value.pstr != NULL );
                        ASSERT( pprop->m_valuePrev.pstr != NULL );
                        *pprop->m_valuePrev.pstr = *pprop->m_value.pstr;
                        break;
                    case CLUSPROP_FORMAT_DWORD:
                        ASSERT( pprop->m_value.pdw != NULL );
                        ASSERT( pprop->m_valuePrev.pdw != NULL );
                        *pprop->m_valuePrev.pdw = *pprop->m_value.pdw;
                        break;
                    case CLUSPROP_FORMAT_BINARY:
                    case CLUSPROP_FORMAT_MULTI_SZ:
                        ASSERT( pprop->m_value.ppb != NULL );
                        ASSERT( *pprop->m_value.ppb != NULL );
                        ASSERT( pprop->m_value.pcb != NULL );
                        ASSERT( pprop->m_valuePrev.ppb != NULL );
                        ASSERT( *pprop->m_valuePrev.ppb != NULL );
                        ASSERT( pprop->m_valuePrev.pcb != NULL );
                        delete [] *pprop->m_valuePrev.ppb;
                        *pprop->m_valuePrev.ppb = new BYTE[ *pprop->m_value.pcb ];
                        if ( *pprop->m_valuePrev.ppb == NULL )
                        {
                            ThrowStaticException( GetLastError( ) );
                        } // if: error allocating data buffer
                        CopyMemory( *pprop->m_valuePrev.ppb, *pprop->m_value.ppb, *pprop->m_value.pcb );
                        *pprop->m_valuePrev.pcb = *pprop->m_value.pcb;
                        break;
                    default:
                        ASSERT( 0 );  // don't know how to deal with this type
                }  // switch:  property format
            }  // for:  each property
        }  // if:  not just validating and properties set successfully

        if ( dwStatus == ERROR_RESOURCE_PROPERTIES_STORED )
        {
            ThrowStaticException( dwStatus );
        } // if
    }  // Save data

}  //*** CClusterItem::SetCommonProperties( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::BuildPropList
//
//  Routine Description:
//      Build the property list.
//
//  Arguments:
//      rcpl        [IN OUT] Cluster property list.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusPropList::ScAddProp( ).
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::BuildPropList(
    IN OUT CClusPropList & rcpl
    )
{
    DWORD                   cprop;
    const CObjectProperty * pprop;

    for ( pprop = Pprops( ), cprop = Cprops( ) ; cprop > 0 ; pprop++, cprop-- )
    {
        switch ( pprop->m_propFormat )
        {
            case CLUSPROP_FORMAT_SZ:
                rcpl.ScAddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.pstr,
                        *pprop->m_valuePrev.pstr
                        );
                break;
            case CLUSPROP_FORMAT_DWORD:
                rcpl.ScAddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.pdw,
                        *pprop->m_valuePrev.pdw
                        );
                break;
            case CLUSPROP_FORMAT_BINARY:
            case CLUSPROP_FORMAT_MULTI_SZ:
                rcpl.ScAddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.ppb,
                        *pprop->m_value.pcb,
                        *pprop->m_valuePrev.ppb,
                        *pprop->m_valuePrev.pcb
                        );
                break;
            default:
                ASSERT( 0 );  // don't know how to deal with this type
                return;
        }  // switch:  property format
    }  // for:  each property

}  //*** CClusterItem::BuildPropList( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::UpdateState
//
//  Routine Description:
//      Update the current state of the item.
//      Default implementation.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::UpdateState( void )
{
    // Update the state of all the tree items pointing to us.
    {
        POSITION    pos;
        CTreeItem * pti;

        pos = LptiBackPointers( ).GetHeadPosition( );
        while ( pos != NULL )
        {
            pti = LptiBackPointers( ).GetNext( pos );
            ASSERT_VALID( pti );
            pti->UpdateUIState( );
        }  // while:  more items in the list
    }  // Update the state of all the tree items pointing to us

    // Update the state of all the list items pointing to us.
    {
        POSITION    pos;
        CListItem * pli;

        pos = LpliBackPointers( ).GetHeadPosition( );
        while ( pos != NULL )
        {
            pli = LpliBackPointers( ).GetNext( pos );
            ASSERT_VALID( pli );
            pli->UpdateUIState( );
        }  // while:  more items in the list
    }  // Update the state of all the tree items pointing to us

}  //*** CClusterItem::UpdateState( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::DwReadValue
//
//  Routine Description:
//      Read a REG_SZ value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      pszKeyName      [IN] Name of the key where the value resides.
//      rstrValue       [OUT] String in which to return the value.
//
//  Return Value:
//      dwStatus    ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterItem::DwReadValue(
    IN LPCTSTR      pszValueName,
    IN LPCTSTR      pszKeyName,
    OUT CString &   rstrValue
    )
{
    DWORD       dwStatus;
    LPWSTR      pwszValue   = NULL;
    DWORD       dwValueLen;
    DWORD       dwValueType;
    HKEY        hkey        = NULL;
    CWaitCursor wc;

    ASSERT( pszValueName != NULL );
    ASSERT( Hkey( ) != NULL );

    rstrValue.Empty( );

    try
    {
        // Open a new key if needed.
        if ( pszKeyName != NULL )
        {
            dwStatus = ClusterRegOpenKey( Hkey( ), pszKeyName, KEY_READ, &hkey );
            if ( dwStatus != ERROR_SUCCESS )
            {
                return dwStatus;
            } // if
        }  // if:  need to open a subkey
        else
        {
            hkey = Hkey( );
        } // else

        // Get the size of the value.
        dwValueLen = 0;
        dwStatus = ClusterRegQueryValue(
                        hkey,
                        pszValueName,
                        &dwValueType,
                        NULL,
                        &dwValueLen
                        );
        if ( ( dwStatus == ERROR_SUCCESS ) || ( dwStatus == ERROR_MORE_DATA ) )
        {
            ASSERT( dwValueType == REG_SZ );

            // Allocate enough space for the data.
            pwszValue = rstrValue.GetBuffer( dwValueLen / sizeof( WCHAR ) );
            ASSERT( pwszValue != NULL );
            dwValueLen += 1 * sizeof( WCHAR );    // Don't forget the final null-terminator.

            // Read the value.
            dwStatus = ClusterRegQueryValue(
                            hkey,
                            pszValueName,
                            &dwValueType,
                            (LPBYTE ) pwszValue,
                            &dwValueLen
                            );
            if ( dwStatus == ERROR_SUCCESS )
            {
                ASSERT( dwValueType == REG_SZ );
            }  // if:  value read successfully
            rstrValue.ReleaseBuffer( );
        }  // if:  got the size successfully
    }  // try
    catch ( CMemoryException * pme )
    {
        pme->Delete( );
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException

    if ( pszKeyName != NULL )
    {
        ClusterRegCloseKey( hkey );
    } // if

    return dwStatus;

}  //*** CClusterItem::DwReadValue( LPCTSTR, CString& )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::DwReadValue
//
//  Routine Description:
//      Read a REG_MULTI_SZ value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      pszKeyName      [IN] Name of the key where the value resides.
//      rlstrValue      [OUT] String list in which to return the values.
//
//  Return Value:
//      dwStatus    ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterItem::DwReadValue(
    IN LPCTSTR          pszValueName,
    IN LPCTSTR          pszKeyName,
    OUT CStringList &   rlstrValue
    )
{
    DWORD               dwStatus;
    LPWSTR              pwszValue   = NULL;
    LPWSTR              pwszCurValue;
    DWORD               dwValueLen;
    DWORD               dwValueType;
    HKEY                hkey        = NULL;
    CWaitCursor         wc;

    ASSERT( pszValueName != NULL );
    ASSERT( Hkey( ) != NULL );

    rlstrValue.RemoveAll( );

    try
    {
        // Open a new key if needed.
        if ( pszKeyName != NULL )
        {
            dwStatus = ClusterRegOpenKey( Hkey( ), pszKeyName, KEY_READ, &hkey );
            if ( dwStatus != ERROR_SUCCESS )
            {
                return dwStatus;
            } // if
        }  // if:  need to open a subkey
        else
            hkey = Hkey( );

        // Get the size of the value.
        dwValueLen = 0;
        dwStatus = ClusterRegQueryValue(
                        hkey,
                        pszValueName,
                        &dwValueType,
                        NULL,
                        &dwValueLen
                        );
        if ( ( dwStatus == ERROR_SUCCESS ) || ( dwStatus == ERROR_MORE_DATA ) )
        {
            ASSERT( dwValueType == REG_MULTI_SZ );

            // Allocate enough space for the data.
            dwValueLen += 1 * sizeof( WCHAR );    // Don't forget the final null-terminator.
            pwszValue = new WCHAR[ dwValueLen / sizeof( WCHAR ) ];
            if ( pwszValue == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the value

            // Read the value.
            dwStatus = ClusterRegQueryValue(
                            hkey,
                            pszValueName,
                            &dwValueType,
                            (LPBYTE) pwszValue,
                            &dwValueLen
                            );
            if ( dwStatus == ERROR_SUCCESS )
            {
                ASSERT( dwValueType == REG_MULTI_SZ );

                // Add each string from the value into the string list.
                for ( pwszCurValue = pwszValue
                        ; *pwszCurValue != L'\0'
                        ; pwszCurValue += lstrlenW( pwszCurValue ) + 1
                        )
                {
                    rlstrValue.AddTail( pwszCurValue );
                } // for
            }  // if:  read the value successfully
        }  // if:  got the size successfully
    }  // try
    catch ( CMemoryException * pme )
    {
        pme->Delete( );
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException

    delete [] pwszValue;
    if ( pszKeyName != NULL )
    {
        ClusterRegCloseKey( hkey );
    } // if

    return dwStatus;

}  //*** CClusterItem::DwReadValue( LPCTSTR, CStringList& )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::DwReadValue
//
//  Routine Description:
//      Read a REG_DWORD value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      pszKeyName      [IN] Name of the key where the value resides.
//      pdwValue        [OUT] DWORD in which to return the value.
//
//  Return Value:
//      dwStatus    ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterItem::DwReadValue(
    IN LPCTSTR      pszValueName,
    IN LPCTSTR      pszKeyName,
    OUT DWORD *     pdwValue
    )
{
    DWORD       dwStatus;
    DWORD       dwValue;
    DWORD       dwValueLen;
    DWORD       dwValueType;
    HKEY        hkey;
    CWaitCursor wc;

    ASSERT( pszValueName != NULL );
    ASSERT( pdwValue != NULL );
    ASSERT( Hkey( ) != NULL );

    // Open a new key if needed.
    if ( pszKeyName != NULL )
    {
        dwStatus = ClusterRegOpenKey( Hkey( ), pszKeyName, KEY_READ, &hkey );
        if ( dwStatus != ERROR_SUCCESS )
        {
            return dwStatus;
        } // if
    }  // if:  need to open a subkey
    else
    {
        hkey = Hkey( );
    } // else

    // Read the value.
    dwValueLen = sizeof( dwValue );
    dwStatus = ClusterRegQueryValue(
                    hkey,
                    pszValueName,
                    &dwValueType,
                    (LPBYTE) &dwValue,
                    &dwValueLen
                    );
    if ( dwStatus == ERROR_SUCCESS )
    {
        ASSERT( dwValueType == REG_DWORD );
        ASSERT( dwValueLen == sizeof( dwValue ) );
        *pdwValue = dwValue;
    }  // if:  value read successfully

    if ( pszKeyName != NULL )
    {
        ClusterRegCloseKey( hkey );
    } // if

    return dwStatus;

}  //*** CClusterItem::DwReadValue( LPCTSTR, DWORD* )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::DwReadValue
//
//  Routine Description:
//      Read a REG_DWORD value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      pszKeyName      [IN] Name of the key where the value resides.
//      pdwValue        [OUT] DWORD in which to return the value.
//      dwDefault       [IN] Default value if parameter not set.
//
//  Return Value:
//      dwStatus    ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterItem::DwReadValue(
    IN LPCTSTR      pszValueName,
    IN LPCTSTR      pszKeyName,
    OUT DWORD *     pdwValue,
    IN DWORD        dwDefault
    )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    // Read the value.
    dwStatus = DwReadValue( pszValueName, pszKeyName, pdwValue );
    if ( dwStatus == ERROR_FILE_NOT_FOUND )
    {
        *pdwValue = dwDefault;
        dwStatus = ERROR_SUCCESS;
    }  // if:  value not set

    return dwStatus;

}  //*** CClusterItem::DwReadValue( LPCTSTR, DWORD*, DWORD )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::DwReadValue
//
//  Routine Description:
//      Read a REG_BINARY value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      pszKeyName      [IN] Name of the key where the value resides.
//      ppbValue        [OUT] Pointer in which to return the data.  Caller
//                          is responsible for deallocating the data.
//
//  Return Value:
//      dwStatus    ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterItem::DwReadValue(
    IN LPCTSTR      pszValueName,
    IN LPCTSTR      pszKeyName,
    OUT LPBYTE *    ppbValue
    )
{
    DWORD               dwStatus;
    DWORD               dwValueLen;
    DWORD               dwValueType;
    LPBYTE              pbValue     = NULL;
    HKEY                hkey;
    CWaitCursor         wc;

    ASSERT( pszValueName != NULL );
    ASSERT( ppbValue != NULL );
    ASSERT( Hkey( ) != NULL );

    delete [] *ppbValue;
    *ppbValue = NULL;

    // Open a new key if needed.
    if ( pszKeyName != NULL )
    {
        dwStatus = ClusterRegOpenKey( Hkey( ), pszKeyName, KEY_READ, &hkey );
        if ( dwStatus != ERROR_SUCCESS )
        {
            return dwStatus;
        } // if
    }  // if:  need to open a subkey
    else
    {
        hkey = Hkey( );
    } // else

    // Get the length of the value.
    dwValueLen = 0;
    dwStatus = ClusterRegQueryValue(
                    hkey,
                    pszValueName,
                    &dwValueType,
                    NULL,
                    &dwValueLen
                    );
    if ( ( dwStatus != ERROR_SUCCESS )
      && ( dwStatus != ERROR_MORE_DATA ) )
    {
        if ( pszKeyName != NULL )
        {
            ClusterRegCloseKey( hkey );
        } // if
        return dwStatus;
    }  // if:  error getting the length

    ASSERT( dwValueType == REG_BINARY );

    // Allocate a buffer,
    try
    {
        pbValue = new BYTE[ dwValueLen ];
        if ( pbValue == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the buffer
    }  // try
    catch ( CMemoryException * )
    {
        if ( pszKeyName != NULL )
        {
            ClusterRegCloseKey( hkey );
        } // if
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        return dwStatus;
    }  // catch:  CMemoryException

    // Read the value.
    dwStatus = ClusterRegQueryValue(
                    hkey,
                    pszValueName,
                    &dwValueType,
                    pbValue,
                    &dwValueLen
                    );
    if ( dwStatus == ERROR_SUCCESS )
    {
        *ppbValue = pbValue;
    } // if
    else
    {
        delete [] pbValue;
    } // else

    if ( pszKeyName != NULL )
    {
        ClusterRegCloseKey( hkey );
    } // if

    return dwStatus;

}  //*** CClusterItem::DwReadValue( LPCTSTR, LPBYTE* )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::WriteValue
//
//  Routine Description:
//      Write a REG_SZ value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      pszKeyName      [IN] Name of the key where the value resides.
//      rstrValue       [IN] Value data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException( dwStatus )
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::WriteValue(
    IN LPCTSTR          pszValueName,
    IN LPCTSTR          pszKeyName,
    IN const CString &  rstrValue
    )
{
    DWORD       dwStatus;
    HKEY            hkey;
    CWaitCursor wc;

    ASSERT( pszValueName != NULL );
    ASSERT( Hkey( ) != NULL );

    // Open a new key if needed.
    if ( pszKeyName != NULL )
    {
        dwStatus = ClusterRegOpenKey( Hkey( ), pszKeyName, KEY_ALL_ACCESS, &hkey );
        if ( dwStatus != ERROR_SUCCESS )
        {
            ThrowStaticException( dwStatus );
        } // if
    }  // if:  need to open a subkey
    else
    {
        hkey = Hkey( );
    } // else

    // Write the value.
    dwStatus = ClusterRegSetValue(
                    hkey,
                    pszValueName,
                    REG_SZ,
                    (CONST BYTE *) (LPCTSTR) rstrValue,
                    ( rstrValue.GetLength( ) + 1 ) * sizeof( WCHAR )
                    );
    if ( pszKeyName != NULL )
    {
        ClusterRegCloseKey( hkey );
    } // if
    if ( dwStatus != ERROR_SUCCESS )
    {
        ThrowStaticException( dwStatus );
    } // if

}  //*** CClusterItem::WriteValue( LPCTSTR, CString& )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::WriteValue
//
//  Routine Description:
//      Write a REG_MULTI_SZ value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      pszKeyName      [IN] Name of the key where the value resides.
//      rlstrValue      [IN] Value data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException( dwStatus )
//      Any exceptions thrown by new.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::WriteValue(
    IN LPCTSTR              pszValueName,
    IN LPCTSTR              pszKeyName,
    IN const CStringList &  rlstrValue
    )
{
    DWORD           dwStatus;
    LPWSTR          pwszValue   = NULL;
    LPWSTR          pwszCurValue;
    POSITION        posStr;
    DWORD           cbValueLen;
    HKEY            hkey;
    CWaitCursor wc;

    ASSERT( pszValueName != NULL );
    ASSERT( Hkey( ) != NULL );

    // Get the size of the value.
    posStr = rlstrValue.GetHeadPosition( );
    cbValueLen = 0;
    while ( posStr != NULL )
    {
        cbValueLen += ( rlstrValue.GetNext( posStr ).GetLength( ) + 1 ) * sizeof( TCHAR );
    }  // while:  more items in the list
    cbValueLen += 1 * sizeof( WCHAR );    // Extra NULL at the end.

    // Allocate the value buffer.
    pwszValue = new WCHAR[cbValueLen / sizeof( WCHAR )];
    if ( pwszValue == NULL )
    {
        ThrowStaticException( GetLastError( ) );
    } // if

    // Copy the strings to the values.
    posStr = rlstrValue.GetHeadPosition( );
    for ( pwszCurValue = pwszValue ; posStr != NULL ; pwszCurValue += lstrlenW( pwszCurValue ) + 1 )
    {
        lstrcpyW( pwszCurValue, rlstrValue.GetNext( posStr ) );
    }  // for:  each item in the list
    pwszCurValue[0] = L'\0';

    // Open a new key if needed.
    if ( pszKeyName != NULL )
    {
        dwStatus = ClusterRegOpenKey( Hkey( ), pszKeyName, KEY_ALL_ACCESS, &hkey );
        if ( dwStatus != ERROR_SUCCESS )
        {
            delete [] pwszValue;
            ThrowStaticException( dwStatus );
        }  // if:  error opening the key
    }  // if:  need to open a subkey
    else
    {
        hkey = Hkey( );
    } // else

    // Write the value.
    dwStatus = ClusterRegSetValue(
                    hkey,
                    pszValueName,
                    REG_MULTI_SZ,
                    (CONST BYTE *) pwszValue,
                    cbValueLen - ( 1 * sizeof( WCHAR ) )
                    );
    delete [] pwszValue;
    if ( pszKeyName != NULL )
    {
        ClusterRegCloseKey( hkey );
    } // if
    if ( dwStatus != ERROR_SUCCESS )
    {
        ThrowStaticException( dwStatus );
    } // if

}  //*** CClusterItem::WriteValue( LPCTSTR, CStringList& )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::WriteValue
//
//  Routine Description:
//      Write a REG_DWORD value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      pszKeyName      [IN] Name of the key where the value resides.
//      dwValue         [IN] Value data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException( dwStatus )
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::WriteValue(
    IN LPCTSTR      pszValueName,
    IN LPCTSTR      pszKeyName,
    IN DWORD        dwValue
    )
{
    DWORD       dwStatus;
    HKEY        hkey;
    CWaitCursor wc;

    ASSERT( pszValueName != NULL );
    ASSERT( Hkey( ) != NULL );

    // Open a new key if needed.
    if ( pszKeyName != NULL )
    {
        dwStatus = ClusterRegOpenKey( Hkey( ), pszKeyName, KEY_ALL_ACCESS, &hkey );
        if ( dwStatus != ERROR_SUCCESS )
        {
            ThrowStaticException( dwStatus );
        } // if
    }  // if:  need to open a subkey
    else
        hkey = Hkey( );

    // Write the value.
    dwStatus = ClusterRegSetValue(
                    hkey,
                    pszValueName,
                    REG_DWORD,
                    (CONST BYTE *) &dwValue,
                    sizeof( dwValue )
                    );
    if ( pszKeyName != NULL )
    {
        ClusterRegCloseKey( hkey );
    } // if
    if ( dwStatus != ERROR_SUCCESS )
    {
        ThrowStaticException( dwStatus );
    } // if

}  //*** CClusterItem::WriteValue( LPCTSTR, DWORD )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::WriteValue
//
//  Routine Description:
//      Write a REG_BINARY value for this item if it hasn't changed.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      pszKeyName      [IN] Name of the key where the value resides.
//      pbValue         [IN] Value data.
//      cbValue         [IN] Size of value data.
//      ppbPrevValue    [IN OUT] Previous value.
//      cbPrevValue     [IN] Size of the previous data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException( dwStatus )
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::WriteValue(
    IN LPCTSTR          pszValueName,
    IN LPCTSTR          pszKeyName,
    IN const LPBYTE     pbValue,
    IN DWORD            cbValue,
    IN OUT LPBYTE *     ppbPrevValue,
    IN DWORD            cbPrevValue
    )
{
    DWORD               dwStatus;
    LPBYTE              pbPrevValue = NULL;
    HKEY                hkey;
    CWaitCursor         wc;

    ASSERT( pszValueName != NULL );
    ASSERT( pbValue != NULL );
    ASSERT( ppbPrevValue != NULL );
    ASSERT( cbValue > 0 );
    ASSERT( Hkey( ) != NULL );

    // See if the data has changed.
    if ( cbValue == cbPrevValue )
    {
        DWORD       ib;

        for ( ib = 0 ; ib < cbValue ; ib++ )
        {
            if ( pbValue[ ib ] != (*ppbPrevValue )[ ib ] )
            {
                break;
            } // if
        }  // for:  each byte in the value
        if ( ib == cbValue )
        {
            return;
        } // if
    }  // if:  lengths are the same

    // Allocate a new buffer for the previous data pointer.
    pbPrevValue = new BYTE[ cbValue ];
    if ( pbPrevValue == NULL )
    {
        ThrowStaticException( GetLastError( ) );
    } // if: error allocating previous data buffer
    CopyMemory( pbPrevValue, pbValue, cbValue );

    // Open a new key if needed.
    if ( pszKeyName != NULL )
    {
        dwStatus = ClusterRegOpenKey( Hkey( ), pszKeyName, KEY_ALL_ACCESS, &hkey );
        if ( dwStatus != ERROR_SUCCESS )
        {
            delete [] pbPrevValue;
            ThrowStaticException( dwStatus );
        }  // if:  error opening the key
    }  // if:  need to open a subkey
    else
    {
        hkey = Hkey( );
    } // else

    // Write the value if it hasn't changed.
    dwStatus = ClusterRegSetValue(
                    hkey,
                    pszValueName,
                    REG_BINARY,
                    pbValue,
                    cbValue
                    );
    if ( pszKeyName != NULL )
    {
        ClusterRegCloseKey( hkey );
    } // if
    if ( dwStatus == ERROR_SUCCESS )
    {
        delete [] *ppbPrevValue;
        *ppbPrevValue = pbPrevValue;
    }  // if:  set was successful
    else
    {
        delete [] pbPrevValue;
        ThrowStaticException( dwStatus );
    }  // else:  error setting the value

}  //*** CClusterItem::WriteValue( LPCTSTR, const LPBYTE )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::DeleteValue
//
//  Routine Description:
//      Delete the value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to delete.
//      pszKeyName      [IN] Name of the key where the value resides.
//      rstrValue       [IN] Value data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException( dwStatus )
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::DeleteValue(
    IN LPCTSTR      pszValueName,
    IN LPCTSTR      pszKeyName
    )
{
    DWORD       dwStatus;
    HKEY        hkey;
    CWaitCursor wc;

    ASSERT( pszValueName != NULL );
    ASSERT( Hkey( ) != NULL );

    // Open a new key if needed.
    if ( pszKeyName != NULL )
    {
        dwStatus = ClusterRegOpenKey( Hkey( ), pszKeyName, KEY_ALL_ACCESS, &hkey );
        if ( dwStatus != ERROR_SUCCESS )
        {
            ThrowStaticException( dwStatus );
        } // if
    }  // if:  need to open a subkey
    else
    {
        hkey = Hkey( );
    } // else

    // Delete the value.
    dwStatus = ClusterRegDeleteValue( hkey, pszValueName );
    if ( pszKeyName != NULL )
    {
        ClusterRegCloseKey( hkey );
    } // if
    if ( dwStatus != ERROR_SUCCESS )
    {
        ThrowStaticException( dwStatus );
    } // if

}  //*** CClusterItem::DeleteValue( LPCTSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::BDifferent
//
//  Routine Description:
//      Compare two string lists.
//
//  Arguments:
//      rlstr1      [IN] First string list.
//      rlstr2      [IN] Second string list.
//
//  Return Value:
//      TRUE        Lists are different.
//      FALSE       Lists are the same.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterItem::BDifferent(
    IN const CStringList &  rlstr1,
    IN const CStringList &  rlstr2
    )
{
    BOOL    bDifferent;

    if ( rlstr1.GetCount( ) == rlstr2.GetCount( ) )
    {
        POSITION    posStr;

        bDifferent = FALSE;
        posStr = rlstr1.GetHeadPosition( );
        while ( posStr != NULL )
        {
            if ( rlstr2.Find( rlstr1.GetNext( posStr ) ) == 0 )
            {
                bDifferent = TRUE;
                break;
            }  // if:  string wasn't found
        }  // while:  more items in the list
    }  // if:  lists are the same size
    else
    {
        bDifferent = TRUE;
    } // else

    return bDifferent;

}  //*** CClusterItem::BDifferent( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::BDifferentOrdered
//
//  Routine Description:
//      Compare two string lists.
//
//  Arguments:
//      rlstr1      [IN] First string list.
//      rlstr2      [IN] Second string list.
//
//  Return Value:
//      TRUE        Lists are different.
//      FALSE       Lists are the same.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterItem::BDifferentOrdered(
    IN const CStringList &  rlstr1,
    IN const CStringList &  rlstr2
    )
{
    BOOL    bDifferent;

    if ( rlstr1.GetCount( ) == rlstr2.GetCount( ) )
    {
        POSITION    posStr1;
        POSITION    posStr2;

        bDifferent = FALSE;
        posStr1 = rlstr1.GetHeadPosition( );
        posStr2 = rlstr2.GetHeadPosition( );
        while ( posStr1 != NULL )
        {
            if ( posStr2 == NULL )
            {
                bDifferent = TRUE;
                break;
            }  // if:  fewer strings in second list
            if ( rlstr1.GetNext( posStr1 ) != rlstr2.GetNext( posStr2 ) )
            {
                bDifferent = TRUE;
                break;
            }  // if:  strings are different
        }  // while:  more items in the list
        if ( posStr2 != NULL )
        {
            bDifferent = TRUE;
        } // if
    }  // if:  lists are the same size
    else
    {
        bDifferent = TRUE;
    } // else

    return bDifferent;

}  //*** CClusterItem::BDifferentOrdered( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::BGetColumnData
//
//  Routine Description:
//      Returns a string with the column data for a
//
//  Arguments:
//      colid           [IN] Column ID.
//      rstrText        [OUT] String in which to return the text for the column.
//
//  Return Value:
//      TRUE        Column data returned.
//      FALSE       Column ID not recognized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterItem::BGetColumnData( IN COLID colid, OUT CString & rstrText )
{
    BOOL    bSuccess;

    switch ( colid )
    {
        case IDS_COLTEXT_NAME:
            rstrText = StrName( );
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_TYPE:
            rstrText = StrType( );
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_DESCRIPTION:
            rstrText = StrDescription( );
            bSuccess = TRUE;
            break;
        default:
            bSuccess = FALSE;
            rstrText = _T("");
            break;
    }  // switch:  colid

    return bSuccess;

}  //*** CClusterItem::BGetColumnData( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::GetTreeName
//
//  Routine Description:
//      Returns a string to be used in a tree control.
//
//  Arguments:
//      rstrName    [OUT] String in which to return the name.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
void CClusterItem::GetTreeName( OUT CString & rstrName ) const
{
    rstrName = StrName( );

}  //*** CClusterItem::GetTreeName( )
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::PmenuPopup
//
//  Routine Description:
//      Returns a popup menu.
//
//  Arguments:
//      None.
//
//  Return Value:
//      pmenu       A popup menu for the item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CMenu * CClusterItem::PmenuPopup( void )
{
    CMenu * pmenu   = NULL;

    if ( IdmPopupMenu( ) != NULL )
    {
        // Update the state of the item before we construct its menu.
        UpdateState( );

        // Load the menu.
        pmenu = new CMenu;
        if ( pmenu == NULL )
        {
            return NULL;
        } // if
        if ( ! pmenu->LoadMenu( IdmPopupMenu( ) ) )
        {
            delete pmenu;
            pmenu = NULL;
        }  // if:  error loading the menu
    }  // if:  there is a menu for this item

    return pmenu;

}  //*** CClusterItem::PmenuPopup( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::AddTreeItem
//
//  Routine Description:
//      Add a tree item to the list item back pointer list.
//
//  Arguments:
//      pti         [IN] Tree item to add.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::AddTreeItem( CTreeItem * pti )
{
    POSITION    pos;

    ASSERT_VALID( pti );

    // Find the item in the list.
    pos = LptiBackPointers( ).Find( pti );

    // If it wasn't found, add it.
    if ( pos == NULL )
    {
        LptiBackPointers( ).AddTail( pti );
        Trace( g_tagClusItemCreate, _T("AddTreeItem( ) - Adding tree item backptr from '%s' in '%s' - %d in list"), StrName( ), ( pti->PtiParent( ) == NULL ? _T("<ROOT>") : pti->PtiParent( )->StrName( ) ), LptiBackPointers( ).GetCount( ) );
    }  // if:  item found in list

}  //*** CClusterItem::AddTreeItem( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::AddListItem
//
//  Routine Description:
//      Add a list item to the list item back pointer list.
//
//  Arguments:
//      pli         [IN] List item to add.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::AddListItem( CListItem * pli )
{
    POSITION    pos;

    ASSERT_VALID( pli );

    // Find the item in the list.
    pos = LpliBackPointers( ).Find( pli );

    // If it wasn't found, add it.
    if ( pos == NULL )
    {
        LpliBackPointers( ).AddTail( pli );
        Trace( g_tagClusItemCreate, _T("AddListItem( ) - Adding list item backptr from '%s' in '%s' - %d in list"), StrName( ), ( pli->PtiParent( ) == NULL ? _T("<ROOT>") : pli->PtiParent( )->StrName( ) ), LpliBackPointers( ).GetCount( ) );
    }  // if:  item found in list

}  //*** CClusterItem::AddListItem( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::RemoveTreeItem
//
//  Routine Description:
//      Remove a tree item from the tree item back pointer list.
//
//  Arguments:
//      pti         [IN] Tree item to remove.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::RemoveTreeItem( CTreeItem * pti )
{
    POSITION    pos;

    ASSERT_VALID( pti );

    // Find the item in the list.
    pos = LptiBackPointers( ).Find( pti );

    // If it was found, remove it.
    if ( pos != NULL )
    {
        LptiBackPointers( ).RemoveAt( pos );
        Trace( g_tagClusItemDelete, _T("RemoveTreeItem( ) - Deleting tree item backptr from '%s' in '%s' - %d left"), StrName( ), ( pti->PtiParent( ) == NULL ? _T("<ROOT>") : pti->PtiParent( )->StrName( ) ), LptiBackPointers( ).GetCount( ) );
    }  // if:  item found in list

}  //*** CClusterItem::RemoveTreeItem( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::RemoveListItem
//
//  Routine Description:
//      Remove a list item from the list item back pointer list.
//
//  Arguments:
//      pli         [IN] List item to remove.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::RemoveListItem( CListItem * pli )
{
    POSITION    pos;

    ASSERT_VALID( pli );

    // Find the item in the list.
    pos = LpliBackPointers( ).Find( pli );

    // If it was found, remove it.
    if ( pos != NULL )
    {
        LpliBackPointers( ).RemoveAt( pos );
        Trace( g_tagClusItemDelete, _T("RemoveListItem( ) - Deleting list item backptr from '%s' in '%s' - %d left"), StrName( ), ( pli->PtiParent( ) == NULL ? _T("<ROOT>") : pli->PtiParent( )->StrName( ) ), LpliBackPointers( ).GetCount( ) );
    }  // if:  item found in list

}  //*** CClusterItem::RemoveListItem( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::CClusterItem
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_RENAME
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::OnUpdateRename( CCmdUI * pCmdUI )
{
    pCmdUI->Enable( BCanBeEdited( ) );

}  //*** CClusterItem::OnUpdateRename( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::OnUpdateProperties
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_PROPERTIES
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::OnUpdateProperties( CCmdUI * pCmdUI )
{
    pCmdUI->Enable( FALSE );

}  //*** CClusterItem::OnUpdateProperties( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::OnCmdProperties
//
//  Routine Description:
//      Processes the ID_FILE_PROPERTIES menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::OnCmdProperties( void )
{
    BDisplayProperties( );

}  //*** CClusterItem::OnCmdProperties( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::BDisplayProperties
//
//  Routine Description:
//      Display properties for the object.
//
//  Arguments:
//      bReadOnly   [IN] Don't allow edits to the object properties.
//
//  Return Value:
//      TRUE    OK pressed.
//      FALSE   OK not pressed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterItem::BDisplayProperties( IN BOOL bReadOnly )
{
    AfxMessageBox( TEXT("Properties are not available."), MB_OK | MB_ICONWARNING );
    return FALSE;

}  //*** CClusterItem::BDisplayProperties( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::OnClusterNotify
//
//  Routine Description:
//      Handler for the WM_CAM_CLUSTER_NOTIFY message.
//      Processes cluster notifications for this object.
//
//  Arguments:
//      pnotify     [IN OUT] Object describing the notification.
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CClusterItem::OnClusterNotify( IN OUT CClusterNotify * pnotify )
{
    return 0;

}  //*** CClusterItem::OnClusterNotify( )


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DestructElements
//
//  Routine Description:
//      Destroys CClusterItem* elements.
//
//  Arguments:
//      pElements   Array of pointers to elements to destruct.
//      nCount      Number of elements to destruct.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
extern void AFXAPI DestructElements( CClusterItem ** pElements, int nCount )
{
    ASSERT( nCount == 0
         || AfxIsValidAddress( pElements, nCount * sizeof( CClusterItem * ) ) );

    // call the destructor(s )
    for ( ; nCount--; pElements++ )
    {
        ASSERT_VALID( *pElements );
        (*pElements)->Release( );
    }  // for:  each item in the array

}  //*** DestructElements( CClusterItem** )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DeleteAllItemData
//
//  Routine Description:
//      Deletes all item data in a CList.
//
//  Arguments:
//      rlp     [IN OUT] List whose data is to be deleted.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DeleteAllItemData( IN OUT CClusterItemList & rlp )
{
    POSITION        pos;
    CClusterItem *  pci;

    // Delete all the items in the Contained list.
    pos = rlp.GetHeadPosition( );
    while ( pos != NULL )
    {
        pci = rlp.GetNext( pos );
        ASSERT_VALID( pci );
//      Trace( g_tagClusItemDelete, _T("DeleteAllItemData(rlpci ) - Deleting cluster item '%s'"), pci->StrName( ) );
        pci->Delete( );
    }  // while:  more items in the list

}  //*** DeleteAllItemData( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\clusprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ClusProp.cpp
//
//  Abstract:
//      Definition of the cluster property sheet and pages.
//
//  Author:
//      David Potter (davidp)   May 13, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSPROP_H_
#define _CLUSPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePPag.h"   // for CBasePropertyPage
#endif

#ifndef _BASESHT_H_
#include "BasePSht.h"   // for CBasePropertySheet
#endif

#ifndef _NETWORK_H_
#include "Network.h"    // for CNetworkList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterGeneralPage;
class CClusterQuorumPage;
class CClusterNetPriorityPage;
class CClusterPropSheet;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CCluster;
class CResource;

/////////////////////////////////////////////////////////////////////////////
// CClusterGeneralPage dialog
/////////////////////////////////////////////////////////////////////////////

class CClusterGeneralPage : public CBasePropertyPage
{
    DECLARE_DYNCREATE(CClusterGeneralPage)

// Construction
public:
    CClusterGeneralPage(void);
    ~CClusterGeneralPage(void);

    virtual BOOL        BInit(IN OUT CBaseSheet * psht);

// Dialog Data
    //{{AFX_DATA(CClusterGeneralPage)
    enum { IDD = IDD_PP_CLUSTER_GENERAL };
    CEdit   m_editName;
    CEdit   m_editDesc;
    CString m_strName;
    CString m_strDesc;
    CString m_strVendorID;
    CString m_strVersion;
    //}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CClusterGeneralPage)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnKillActive();
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
//  BOOL                m_bSecurityChanged;

    CClusterPropSheet * PshtCluster(void)               { return (CClusterPropSheet *) Psht(); }
    CCluster *          PciCluster(void)                { return (CCluster *) Pci(); }
//  BOOL                BSecurityChanged(void) const    { return m_bSecurityChanged; }

    // Generated message map functions
    //{{AFX_MSG(CClusterGeneralPage)
    virtual BOOL OnInitDialog();
//  afx_msg void OnBnClickedPermissions();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CClusterGeneralPage

/////////////////////////////////////////////////////////////////////////////
// CClusterQuorumPage dialog
/////////////////////////////////////////////////////////////////////////////

class CClusterQuorumPage : public CBasePropertyPage
{
    DECLARE_DYNCREATE(CClusterQuorumPage)

// Construction
public:
    CClusterQuorumPage(void);
    ~CClusterQuorumPage(void);

    virtual BOOL        BInit(IN OUT CBaseSheet * psht);

// Dialog Data
    //{{AFX_DATA(CClusterQuorumPage)
    enum { IDD = IDD_PP_CLUSTER_QUORUM };
    CEdit   m_editRootPath;
    CEdit   m_editMaxLogSize;
    CComboBox   m_cboxPartition;
    CComboBox   m_cboxQuorumResource;
    CString m_strQuorumResource;
    CString m_strPartition;
    DWORD   m_nMaxLogSize;
    CString m_strRootPath;
    //}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CClusterQuorumPage)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    struct SPartitionItemData
    {
        TCHAR   szDeviceName[ _MAX_PATH ];
        TCHAR   szPartitionName[ _MAX_PATH ];
        TCHAR   szBaseRootPath[ _MAX_PATH ];
    };

    BOOL                    m_bControlsInitialized;
    PBYTE                   m_pbDiskInfo;
    DWORD                   m_cbDiskInfo;
    CString                 m_strCurrentPartition;
    CString                 m_strCurrentRootPath;
    SPartitionItemData *    m_ppid;

    BOOL                BControlsInitialized(void) const    { return m_bControlsInitialized; }
    CClusterPropSheet * PshtCluster(void) const             { return (CClusterPropSheet *) Psht(); }
    CCluster *          PciCluster(void) const              { return (CCluster *) Pci(); }

    void                ClearResourceList(void);
    void                ClearPartitionList(void);
    void                FillResourceList(void);
    void                FillPartitionList(IN OUT CResource * pciRes);
    BOOL                BGetDiskInfo(IN OUT CResource & rpciRes);

    void
    SplitDeviceName(
        LPCTSTR pszDeviceNameIn,
        LPTSTR  pszPartitionNameOut,
        LPTSTR  pszRootPathOut
        );

    // Generated message map functions
    //{{AFX_MSG(CClusterQuorumPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnDblClkQuorumResource();
    afx_msg void OnChangeQuorumResource();
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CClusterQuorumPage

/////////////////////////////////////////////////////////////////////////////
// CClusterNetPriorityPage dialog
/////////////////////////////////////////////////////////////////////////////

class CClusterNetPriorityPage : public CBasePropertyPage
{
    DECLARE_DYNCREATE(CClusterNetPriorityPage)

// Construction
public:
    CClusterNetPriorityPage(void);

// Dialog Data
    //{{AFX_DATA(CClusterNetPriorityPage)
    enum { IDD = IDD_PP_CLUSTER_NET_PRIORITY };
    CButton m_pbProperties;
    CButton m_pbDown;
    CButton m_pbUp;
    CListBox    m_lbList;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CClusterNetPriorityPage)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    BOOL                m_bControlsInitialized;
    CNetworkList        m_lpciNetworkPriority;

    BOOL                BControlsInitialized(void) const    { return m_bControlsInitialized; }
    CClusterPropSheet * PshtCluster(void) const             { return (CClusterPropSheet *) Psht(); }
    CCluster *          PciCluster(void) const              { return (CCluster *) Pci(); }
    CNetworkList &      LpciNetworkPriority(void)           { return m_lpciNetworkPriority; }

    void                FillList(void);
    void                ClearNetworkList(void);
    void                DisplayProperties(void);

    // Generated message map functions
    //{{AFX_MSG(CClusterNetPriorityPage)
    afx_msg void OnSelChangeList();
    virtual BOOL OnInitDialog();
    afx_msg void OnUp();
    afx_msg void OnDown();
    afx_msg void OnProperties();
    afx_msg void OnDestroy();
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    afx_msg void OnDblClkList();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CClusterNetPriorityPage

/////////////////////////////////////////////////////////////////////////////
// CClusterPropSheet
/////////////////////////////////////////////////////////////////////////////

class CClusterPropSheet : public CBasePropertySheet
{
    DECLARE_DYNAMIC(CClusterPropSheet)

// Construction
public:
    CClusterPropSheet(
        IN OUT CWnd *       pParentWnd = NULL,
        IN UINT             iSelectPage = 0
        );
    virtual BOOL                BInit(
                                    IN OUT CClusterItem *   pciCluster,
                                    IN IIMG                 iimgIcon
                                    );

// Attributes
protected:
    CBasePropertyPage *         m_rgpages[3];

    // Pages
    CClusterGeneralPage         m_pageGeneral;
    CClusterQuorumPage          m_pageQuorum;
    CClusterNetPriorityPage     m_pageNetPriority;

    CClusterGeneralPage &       PageGeneral(void)       { return m_pageGeneral; }
    CClusterQuorumPage &        PageQuorum(void)        { return m_pageQuorum; }
    CClusterNetPriorityPage &   PageNetPriority(void)   { return m_pageNetPriority; }

public:
    CCluster *                  PciCluster(void)        { return (CCluster *) Pci(); }

// Operations

// Overrides
protected:
    virtual CBasePropertyPage** Ppages(void);
    virtual int                 Cpages(void);

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClusterPropSheet)
    //}}AFX_VIRTUAL

// Implementation
public:

    // Generated message map functions
protected:
    //{{AFX_MSG(CClusterPropSheet)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CClusterPropSheet

/////////////////////////////////////////////////////////////////////////////

#endif // _CLUSPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\clusmru.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ClusMru.cpp
//
//	Abstract:
//		Implementation of the CRecentClusterList class.
//
//	Author:
//		David Potter (davidp)	May 3, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClusMru.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRecentClusterList

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRecentClusterList::Add
//
//	Routine Description:
//		Add an item to the list of recently used cluster names.
//		Implemented to remove file-ness of base class' method.
//
//	Arguments:
//		lpszPathName	Name of the cluster or server to add.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRecentClusterList::Add(LPCTSTR lpszPathName)
{
	ASSERT(m_arrNames != NULL);
	ASSERT(lpszPathName != NULL);
	ASSERT(AfxIsValidString(lpszPathName));

	// update the MRU list, if an existing MRU string matches file name
	for (int iMRU = 0; iMRU < m_nSize-1; iMRU++)
	{
		if (lstrcmpi(m_arrNames[iMRU], lpszPathName) == 0)
			break;      // iMRU will point to matching entry
	}
	// move MRU strings before this one down
	for (; iMRU > 0; iMRU--)
	{
		ASSERT(iMRU > 0);
		ASSERT(iMRU < m_nSize);
		m_arrNames[iMRU] = m_arrNames[iMRU-1];
	}
	// place this one at the beginning
	m_arrNames[0] = lpszPathName;

}  //*** CRecentClusterList::Add()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRecentClusterList::GetDisplayName
//
//	Routine Description:
//		Get the display name of a particular item.
//		Implemented to remove file-ness of base class' method.
//
//	Arguments:
//		strName			[OUT] String in which to return the display name.
//		nIndex			[IN] Index of item in array.
//		lpszCurDir		[IN] Must be NULL.
//		nCurDir			[IN] Must be 0.
//		bAtLeastName	[IN] Not used.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CRecentClusterList::GetDisplayName(
	CString &	strName,
	int			nIndex,
	LPCTSTR		lpszCurDir,
	int			nCurDir,
	BOOL		bAtLeastName
	) const
{
	ASSERT(lpszCurDir == NULL);
	ASSERT(nCurDir == 0);

	if (m_arrNames[nIndex].IsEmpty())
		return FALSE;

	strName = m_arrNames[nIndex];
	return TRUE;

}  //*** CRecentClusterList::GetDisplayName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CRecentClusterList::UpdateMenu
//
//	Routine Description:
//		Update the menu with the MRU items.
//		Implemented to remove file-ness of base class' method and to use
//		our version of GetDisplayName, since it isn't virtual.
//
//	Arguments:
//		pCmdUI		[IN OUT] Command routing object.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRecentClusterList::UpdateMenu(CCmdUI * pCmdUI)
{
	ASSERT(m_arrNames != NULL);

	CMenu* pMenu = pCmdUI->m_pMenu;
	if (m_strOriginal.IsEmpty() && pMenu != NULL)
		pMenu->GetMenuString(pCmdUI->m_nID, m_strOriginal, MF_BYCOMMAND);

	if (m_arrNames[0].IsEmpty())
	{
		// no MRU files
		if (!m_strOriginal.IsEmpty())
			pCmdUI->SetText(m_strOriginal);
		pCmdUI->Enable(FALSE);
		return;
	}

	if (pCmdUI->m_pMenu == NULL)
		return;

	for (int iMRU = 0; iMRU < m_nSize; iMRU++)
		pCmdUI->m_pMenu->DeleteMenu(pCmdUI->m_nID + iMRU, MF_BYCOMMAND);

	CString strName;
	CString strTemp;
	for (iMRU = 0; iMRU < m_nSize; iMRU++)
	{
		if (!GetDisplayName(strName, iMRU, NULL, 0))
			break;

		// double up any '&' characters so they are not underlined
		LPCTSTR lpszSrc = strName;
		LPTSTR lpszDest = strTemp.GetBuffer(strName.GetLength()*2);
		while (*lpszSrc != 0)
		{
			if (*lpszSrc == '&')
				*lpszDest++ = '&';
			if (_istlead(*lpszSrc))
				*lpszDest++ = *lpszSrc++;
			*lpszDest++ = *lpszSrc++;
		}
		*lpszDest = 0;
		strTemp.ReleaseBuffer();

		// insert mnemonic + the file name
		TCHAR buf[10];
		wsprintf(buf, _T("&%d "), (iMRU+1+m_nStart) % 10);
		pCmdUI->m_pMenu->InsertMenu(pCmdUI->m_nIndex++,
			MF_STRING | MF_BYPOSITION, pCmdUI->m_nID++,
			CString(buf) + strTemp);
	}

	// update end menu count
	pCmdUI->m_nIndex--; // point to last menu added
	pCmdUI->m_nIndexMax = pCmdUI->m_pMenu->GetMenuItemCount();

	pCmdUI->m_bEnableChanged = TRUE;    // all the added items are enabled

}  //*** CRecentFileList::UpdateMenu()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\clusprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ClusProp.cpp
//
//  Abstract:
//      Implementation of the cluster property sheet and pages.
//
//  Author:
//      David Potter (davidp)   May 13, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClusProp.h"
#include "Cluster.h"
#include "Res.h"
#include "ClusDoc.h"
#include "ClusItem.inl"
//#include "EditAcl.h"
#include "DDxDDv.h"
#include "ExcOper.h"
#include "HelpData.h"   // g_rghelpmapClusterGeneral
#include "WaitDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterPropSheet
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CClusterPropSheet, CBasePropertySheet)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CClusterPropSheet, CBasePropertySheet)
    //{{AFX_MSG_MAP(CClusterPropSheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterPropSheet::CClusterPropSheet
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pci         [IN OUT] Cluster item whose properties are to be displayed.
//      pParentWnd  [IN OUT] Parent window for this property sheet.
//      iSelectPage [IN] Page to show first.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterPropSheet::CClusterPropSheet(
    IN OUT CWnd *       pParentWnd,
    IN UINT             iSelectPage
    )
    : CBasePropertySheet(pParentWnd, iSelectPage)
{
    m_rgpages[0] = &PageGeneral();
    m_rgpages[1] = &PageQuorum();
    m_rgpages[2] = &PageNetPriority();

}  //*** CClusterPropSheet::CClusterPropSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterPropSheet::BInit
//
//  Routine Description:
//      Initialize the property sheet.
//
//  Arguments:
//      pci         [IN OUT] Cluster item whose properties are to be displayed.
//      iimgIcon    [IN] Index in the large image list for the image to use
//                    as the icon on each page.
//
//  Return Value:
//      TRUE        Property sheet initialized successfully.
//      FALSE       Error initializing property sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterPropSheet::BInit(
    IN OUT CClusterItem *   pci,
    IN IIMG                 iimgIcon
    )
{
    // Call the base class method.
    if (!CBasePropertySheet::BInit(pci, iimgIcon))
        return FALSE;

    // Set the read-only flag if the handles are invalid.
    if ((PciCluster()->Hcluster() == NULL)
            || (PciCluster()->Hkey() == NULL))
        m_bReadOnly = TRUE;

    return TRUE;

}  //*** CClusterPropSheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterPropSheet::Ppages
//
//  Routine Description:
//      Returns the array of pages to add to the property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Page array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage ** CClusterPropSheet::Ppages(void)
{
    return m_rgpages;

}  //*** CClusterPropSheet::Ppages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterPropSheet::Cpages
//
//  Routine Description:
//      Returns the count of pages in the array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Count of pages in the array.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CClusterPropSheet::Cpages(void)
{
    return sizeof(m_rgpages) / sizeof(CBasePropertyPage *);

}  //*** CClusterPropSheet::Cpages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterGeneralPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CClusterGeneralPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CClusterGeneralPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CClusterGeneralPage)
//  ON_BN_CLICKED(IDC_PP_CLUS_PERMISSIONS, OnBnClickedPermissions)
    //}}AFX_MSG_MAP
    ON_EN_CHANGE(IDC_PP_CLUS_NAME, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_CLUS_DESC, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGeneralPage::CClusterGeneralPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterGeneralPage::CClusterGeneralPage(void)
    : CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_CLUSTER_GENERAL)
{
    //{{AFX_DATA_INIT(CClusterGeneralPage)
    m_strName = _T("");
    m_strDesc = _T("");
    m_strVendorID = _T("");
    m_strVersion = _T("");
    //}}AFX_DATA_INIT

//  m_bSecurityChanged = FALSE;

}  //*** CClusterGeneralPage::CClusterGeneralPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGeneralPage::~CClusterGeneralPage
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterGeneralPage::~CClusterGeneralPage(void)
{
}  //*** CClusterGeneralPage::~CClusterGeneralPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGeneralPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      psht        [IN OUT] Property sheet to which this page belongs.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterGeneralPage::BInit(IN OUT CBaseSheet * psht)
{
    BOOL        bSuccess;
    CWaitCursor wc;

    ASSERT_KINDOF(CClusterPropSheet, psht);

    bSuccess = CBasePropertyPage::BInit(psht);

    try
    {
        m_strName = PciCluster()->StrName();
        m_strDesc = PciCluster()->StrDescription();
        m_strVendorID = PciCluster()->Cvi().szVendorId;
        m_strVersion.Format( IDS_OP_VERSION_NUMBER_FORMAT, PciCluster()->Cvi().MajorVersion );
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        m_bReadOnly = TRUE;
    }  // catch:  CException

    return bSuccess;

}  //*** CClusterGeneralPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGeneralPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterGeneralPage::DoDataExchange(CDataExchange * pDX)
{
    CWaitCursor wc;
    CString     strClusName;

    CBasePropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CClusterGeneralPage)
    DDX_Control(pDX, IDC_PP_CLUS_NAME, m_editName);
    DDX_Control(pDX, IDC_PP_CLUS_DESC, m_editDesc);
    DDX_Text(pDX, IDC_PP_CLUS_DESC, m_strDesc);
    DDX_Text(pDX, IDC_PP_CLUS_VENDOR_ID, m_strVendorID);
    DDX_Text(pDX, IDC_PP_CLUS_VERSION, m_strVersion);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        CLRTL_NAME_STATUS cnStatus;

        //
        // get the name from the control into a temp variable
        //
        DDX_Text(pDX, IDC_PP_CLUS_NAME, strClusName);

        if (   (strClusName != m_strName)
            && !ClRtlIsNetNameValid(strClusName, &cnStatus, FALSE /*CheckIfExists*/))
        {
            CString     strMsg;
            UINT        idsError;

            switch (cnStatus)
            {
                case NetNameTooLong:
                    idsError = IDS_INVALID_CLUSTER_NAME_TOO_LONG;
                    break;
                case NetNameInvalidChars:
                    idsError = IDS_INVALID_CLUSTER_NAME_INVALID_CHARS;
                    break;
                case NetNameInUse:
                    idsError = IDS_INVALID_CLUSTER_NAME_IN_USE;
                    break;
                case NetNameDNSNonRFCChars:
                    idsError = IDS_INVALID_CLUSTER_NAME_INVALID_DNS_CHARS;
                    break;
                case NetNameSystemError:
                {
                    DWORD scError = GetLastError();
                    CNTException nte(scError, IDS_ERROR_VALIDATING_NETWORK_NAME, (LPCWSTR) strClusName);
                    nte.ReportError();
                    pDX->Fail();
                }
                default:
                    idsError = IDS_INVALID_CLUSTER_NAME;
                    break;
            }  // switch:  cnStatus

            strMsg.LoadString(idsError);

            if ( idsError == IDS_INVALID_CLUSTER_NAME_INVALID_DNS_CHARS )
            {
                int id = AfxMessageBox(strMsg, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION );

                if ( id == IDNO )                   
                {
                    strMsg.Empty();
                    pDX->Fail();
                }
            }
            else                
            {
                AfxMessageBox(strMsg, MB_ICONEXCLAMATION);
                strMsg.Empty(); // exception prep
                pDX->Fail();
            }

            m_strName = strClusName;
        }  // if:  cluster name has changed and an invalid network name was specified
    }  // if:  getting data from the dialog
    else
    {
        //
        // populate the control with data from the member variable
        //
        DDX_Text(pDX, IDC_PP_CLUS_NAME, m_strName);
    }  // else:  setting data to the dialog

}  //*** CClusterGeneralPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGeneralPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterGeneralPage::OnInitDialog(void)
{
    // Call the base class method.
    CBasePropertyPage::OnInitDialog();

    // Set limits on the edit controls.
    m_editName.SetLimitText(MAX_CLUSTERNAME_LENGTH);

    // If read-only, set all controls to be either disabled or read-only.
    if (BReadOnly())
    {
        m_editName.SetReadOnly(TRUE);
        m_editDesc.SetReadOnly(TRUE);
    }  // if:  sheet is read-only

    return FALSE;   // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CClusterGeneralPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGeneralPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterGeneralPage::OnSetActive(void)
{
    return CBasePropertyPage::OnSetActive();

}  //*** CClusterGeneralPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGeneralPage::OnKillActive
//
//  Routine Description:
//      Handler for the PSN_KILLACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page focus successfully killed.
//      FALSE   Error killing page focus.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterGeneralPage::OnKillActive(void)
{
    return CBasePropertyPage::OnKillActive();

}  //*** CClusterGeneralPage::OnKillActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGeneralPage::OnApply
//
//  Routine Description:
//      Handler for the PSN_APPLY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterGeneralPage::OnApply(void)
{
    // Set the data from the page in the cluster item.
    try
    {
        CWaitCursor wc;

        PciCluster()->SetDescription(m_strDesc);
        PciCluster()->SetName(m_strName);
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CBasePropertyPage::OnApply();

}  //*** CClusterGeneralPage::OnApply()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGeneralPage::OnBnClickedPermissions
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Permissions push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterGeneralPage::OnBnClickedPermissions(void)
{
    LONG                    lResult;
    BOOL                    bSecDescModified;
    PSECURITY_DESCRIPTOR    psec = NULL;
    CString                 strServer;
    CResource *             pciRes = NULL;
    CWaitCursor             wc;

    // Find the cluster name resource.
    {
        POSITION    pos;

        pos = PciCluster()->Pdoc()->LpciResources().GetHeadPosition();
        while (pos != NULL)
        {
            pciRes = (CResource *) PciCluster()->Pdoc()->LpciResources().GetNext(pos);
            ASSERT_VALID(pciRes);

            if (   (pciRes->StrRealResourceType().CompareNoCase(CLUS_RESTYPE_NAME_NETNAME))
                && pciRes->BCore() )
                break;
            pciRes = NULL;
        }  // while:  more resources in the list
        ASSERT(pciRes != NULL);
    }  // Find the cluster name resource

    strServer.Format(_T("\\\\%s"), PciCluster()->StrName());

    lResult = EditClusterAcl(
                    m_hWnd,
                    strServer,
                    PciCluster()->StrName(),
                    pciRes->StrOwner(),
                    m_psec,
                    &bSecDescModified,
                    &psec
                    );

    if (bSecDescModified)
    {
        delete [] m_psec;
        m_psec = psec;
        m_bSecurityChanged = TRUE;
        SetModified(TRUE);
    }  // if:  data changed

}  //*** CClusterGeneralPage::OnBnClickedPermissions()
*/

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterQuorumPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CClusterQuorumPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CClusterQuorumPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CClusterQuorumPage)
    ON_CBN_DBLCLK(IDC_PP_CLUS_QUORUM_RESOURCE, OnDblClkQuorumResource)
    ON_CBN_SELCHANGE(IDC_PP_CLUS_QUORUM_RESOURCE, OnChangeQuorumResource)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
    ON_CBN_SELCHANGE(IDC_PP_CLUS_QUORUM_PARTITION, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_CLUS_QUORUM_ROOT_PATH, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::CClusterQuorumPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterQuorumPage::CClusterQuorumPage(void)
    : CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_CLUSTER_QUORUM)
{
    //{{AFX_DATA_INIT(CClusterQuorumPage)
    m_strQuorumResource = _T("");
    m_strPartition = _T("");
    m_strRootPath = _T("");
    m_nMaxLogSize = 0;
    //}}AFX_DATA_INIT

    m_pbDiskInfo = NULL;
    m_cbDiskInfo = 0;

    m_bControlsInitialized = FALSE;
    m_ppid = NULL;

}  //*** CClusterQuorumPage::CClusterQuorumPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::~CClusterQuorumPage
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterQuorumPage::~CClusterQuorumPage(void)
{
    delete [] m_pbDiskInfo;

}  //*** CClusterQuorumPage::~CClusterQuorumPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::OnDestroy
//
//  Routine Description:
//      Handler for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterQuorumPage::OnDestroy(void)
{
    // If the controls have been initialized, clear the resource combobox.
    if ( BControlsInitialized() )
    {
        ClearResourceList();
        ClearPartitionList();
    }

    delete [] m_pbDiskInfo;
    m_pbDiskInfo = NULL;
    m_cbDiskInfo = 0;

    // Call the base class method.
    CBasePropertyPage::OnDestroy();

}  //*** CClusterQuorumPage::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      psht        [IN OUT] Property sheet to which this page belongs.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterQuorumPage::BInit(IN OUT CBaseSheet * psht)
{
    BOOL        bSuccess;
    CWaitCursor wc;

    ASSERT_KINDOF(CClusterPropSheet, psht);

    bSuccess = CBasePropertyPage::BInit(psht);

    try
    {
        // Get the current quorum resource.
        m_strQuorumResource = PciCluster()->StrQuorumResource();

        SplitDeviceName(
            PciCluster()->StrQuorumPath(),
            m_strPartition.GetBuffer( _MAX_PATH ),
            m_strRootPath.GetBuffer( _MAX_PATH )
            );

        m_strPartition.ReleaseBuffer();
        m_strRootPath.ReleaseBuffer();

        m_nMaxLogSize = (PciCluster()->NMaxQuorumLogSize() + 1023) / 1024;

        m_strCurrentPartition = m_strPartition;
        m_strCurrentRootPath = m_strRootPath;
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        m_bReadOnly = TRUE;
    }  // catch:  CException

    return bSuccess;

}  //*** CClusterQuorumPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterQuorumPage::DoDataExchange(CDataExchange * pDX)
{
    CWaitCursor wc;

    CBasePropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CClusterQuorumPage)
    DDX_Control(pDX, IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE, m_editMaxLogSize);
    DDX_Control(pDX, IDC_PP_CLUS_QUORUM_ROOT_PATH, m_editRootPath);
    DDX_Control(pDX, IDC_PP_CLUS_QUORUM_PARTITION, m_cboxPartition);
    DDX_Control(pDX, IDC_PP_CLUS_QUORUM_RESOURCE, m_cboxQuorumResource);
    DDX_CBString(pDX, IDC_PP_CLUS_QUORUM_RESOURCE, m_strQuorumResource);
    DDX_CBString(pDX, IDC_PP_CLUS_QUORUM_PARTITION, m_strPartition);
    DDX_Text(pDX, IDC_PP_CLUS_QUORUM_ROOT_PATH, m_strRootPath);
    DDX_Text(pDX, IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE, m_nMaxLogSize);
    //}}AFX_DATA_MAP

    if ( ! pDX->m_bSaveAndValidate )
    {
        // Fill the quorum resource combobox with resource names.
        FillResourceList();
    } // if: setting data to the dialog

    m_bControlsInitialized = TRUE;

    if (pDX->m_bSaveAndValidate || !BReadOnly())
        DDX_Number(pDX, IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE, m_nMaxLogSize, 1, 0xffffffff / 1024);

    if (pDX->m_bSaveAndValidate)
    {
        DDV_RequiredText(pDX, IDC_PP_CLUS_QUORUM_RESOURCE, IDC_PP_CLUS_QUORUM_RESOURCE_LABEL, m_strQuorumResource);
        DDV_RequiredText(pDX, IDC_PP_CLUS_QUORUM_PARTITION, IDC_PP_CLUS_QUORUM_PARTITION_LABEL, m_strPartition);
        DDV_RequiredText(pDX, IDC_PP_CLUS_QUORUM_ROOT_PATH, IDC_PP_CLUS_QUORUM_ROOT_PATH_LABEL, m_strRootPath);
    }  // if:  getting data from the dialog

}  //*** CClusterQuorumPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterQuorumPage::OnInitDialog(void)
{
    // Call the base class method.
    CBasePropertyPage::OnInitDialog();

    // If read-only, set all controls to be either disabled or read-only.
    if (BReadOnly())
    {
        m_cboxQuorumResource.EnableWindow(FALSE);
        m_cboxPartition.EnableWindow(FALSE);
        m_editRootPath.SetReadOnly();
        m_editMaxLogSize.SetReadOnly();
    }  // if:  sheet is read-only
    else
    {
        m_editRootPath.SetLimitText(MAX_PATH);
    }

    return FALSE;   // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CClusterQuorumPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::OnApply
//
//  Routine Description:
//      Handler for the PSN_APPLY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterQuorumPage::OnApply(void)
{
    CWaitCursor wc;
    CString     strQuorumPath;
    CString     strTemp;
    DWORD       nLen;
    CResource * pciRes = NULL;
    int         nSelected;
    int         nCount;
    CLUSTER_RESOURCE_STATE crs = ClusterResourceStateUnknown;

    //
    // Get the currently selected resource from the combo box.
    //
    nSelected = m_cboxQuorumResource.GetCurSel();
    nCount = m_cboxQuorumResource.GetCount();

    if ( CB_ERR != nSelected && 0 < nCount )
    {
        pciRes = (CResource *) m_cboxQuorumResource.GetItemDataPtr(nSelected);
    }

    //
    // If we successfully retrieved a resource make sure it's online.
    //
    if ( NULL != pciRes )
    {
        crs = pciRes->Crs();
    
        if ( ClusterResourceOnline != crs )
        {
            //
            // Prompt the user whether or not they'd like to online the resource.
            //
            strTemp.FormatMessage( IDS_ONLINE_QUORUM_RESOURCE_PROMPT, pciRes->StrName() );
            if ( IDYES == AfxMessageBox( strTemp, MB_YESNO | MB_ICONQUESTION ) )
            {
                CWaitForResourceOnlineDlg  dlg( pciRes, AfxGetMainWnd() );
                pciRes->OnCmdBringOnline();
        
                dlg.DoModal();
                
                crs = pciRes->Crs();
            }
            else
            {
                return FALSE;
            }
        } // if: resource !online 

    } // if: pciRes !NULL
    else
    {
        // No resource was selected - this should never happen. 
        AfxMessageBox( IDS_SELECT_QUORUM_RESOURCE_ERROR, MB_OK | MB_ICONEXCLAMATION );
        return FALSE;
    }
    
    // Set the data from the page in the cluster item.
    if ( ClusterResourceOnline == crs )
    {
        try {
            strTemp = _T("");
    
            if( m_ppid != NULL && !m_strRootPath.IsEmpty() )
            {
                nLen = _tcslen( m_ppid->szDeviceName );
    
                //
                // Concatenate the strings before calling SetQuorumResource, but make sure that 
                // there is only one backslash between them.
                //
                strTemp = m_ppid->szDeviceName;
    
                if( ( m_ppid->szDeviceName[nLen-1] != _T('\\') ) && ( m_strRootPath[0] != _T('\\') ) )
                {
                    strTemp += _T('\\');
                }
                else if( ( m_ppid->szDeviceName[nLen-1] == _T('\\') ) && ( m_strRootPath[0] == _T('\\') ) )
                {
                    strTemp.SetAt( nLen-1, _T('\0') );
                }
            } // if: neither string is empty
    
            strQuorumPath.Format( _T("%s%s"), strTemp, m_strRootPath );
    
            PciCluster()->SetQuorumResource(
                                m_strQuorumResource,
                                strQuorumPath,
                                (m_nMaxLogSize * 1024)
                                );
    
            m_strCurrentPartition = m_strPartition;
            m_strCurrentRootPath = m_strRootPath;
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
            strQuorumPath.Empty();
            return FALSE;
        }  // catch:  CException

    } // if: the resource is online

    return CBasePropertyPage::OnApply();

}  //*** CClusterQuorumPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::OnDblClkQuorumResource
//
//  Routine Description:
//      Handler for the CBN_DBLCLK message on the Quorum Resource combo box.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterQuorumPage::OnDblClkQuorumResource(void)
{
    int         nSelected;
    CResource * pciRes;

    // Get the selected resource.
    nSelected = m_cboxQuorumResource.GetCurSel();
    ASSERT(nSelected != CB_ERR);

    // Get the resource object.
    pciRes = (CResource *) m_cboxQuorumResource.GetItemDataPtr(nSelected);
    ASSERT_VALID(pciRes);
    ASSERT_KINDOF(CResource, pciRes);

    // Display properties for the resource.
    pciRes->OnCmdProperties();

}  //*** CClusterQuorumPage::OnDblClkQuorumResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::OnChangeQuorumResource
//
//  Routine Description:
//      Handler for the CBN_SELCHANGE message on the Quorum Resource combobox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterQuorumPage::OnChangeQuorumResource(void)
{
    int                     nSelected;
    CResource *             pciRes;

    OnChangeCtrl();

    // Get the selected resource.
    nSelected = m_cboxQuorumResource.GetCurSel();
    ASSERT(nSelected != CB_ERR);

    // Get the resource object.
    pciRes = (CResource *) m_cboxQuorumResource.GetItemDataPtr(nSelected);
    ASSERT_VALID(pciRes);
    ASSERT_KINDOF(CResource, pciRes);

    // If the resource really did change and is the same as the currently
    // saved resource, set the partition to the currently saved partition.
    // Otherwise, clear the partition setting and use the first one.
    if (pciRes->StrName() != m_strQuorumResource)
    {
        if (pciRes->StrName() == PciCluster()->StrQuorumResource())
        {
            m_strPartition = m_strCurrentPartition;
            m_strRootPath = m_strCurrentRootPath;
        }  // if:  changed to previously set quorum resource
        else
        {
            m_strPartition = _T("");
            //m_strRootPath = _T("\\") CLUS_NAME_DEFAULT_FILESPATH;
        }  // else:  changed to new quorum resource
        m_strQuorumResource = pciRes->StrName();
    }  // if:  resource really did change

    UpdateData(FALSE /*bSaveAndValidate*/);

}  //*** CClusterQuorumPage::OnChangeQuorumResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::ClearResourceList
//
//  Routine Description:
//      Clear the resource list and release references to pointers.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterQuorumPage::ClearResourceList(void)
{
    int         cItems;
    int         iItem;
    CResource * pciRes;

    cItems = m_cboxQuorumResource.GetCount();
    for (iItem = 0 ; iItem < cItems ; iItem++)
    {
        pciRes = (CResource *) m_cboxQuorumResource.GetItemDataPtr(iItem);
        ASSERT_VALID(pciRes);
        ASSERT_KINDOF(CResource, pciRes);
        pciRes->Release();
    }  // for:  each item in the list

    m_cboxQuorumResource.ResetContent();

}  //*** CClusterQuorumPage::ClearResourceList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::FillResourceList
//
//  Routine Description:
//      Fill the quorum resource combobox with all resources and select
//      the quorum resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterQuorumPage::FillResourceList(void)
{
    POSITION    pos;
    int         nIndex;
    CResource * pciRes;
    CResource * pciSelected = NULL;
    CWaitCursor wc;

    // Clear the list.
    ClearResourceList();

    pos = PciCluster()->Pdoc()->LpciResources().GetHeadPosition();
    while (pos != NULL)
    {
        // Get the next resource.
        pciRes = (CResource *) PciCluster()->Pdoc()->LpciResources().GetNext(pos);
        ASSERT_VALID(pciRes);
        ASSERT_KINDOF(CResource, pciRes);

        // If it is quorum capable, add it to the list.
        try
        {
            if (pciRes->BQuorumCapable())
            {
                nIndex = m_cboxQuorumResource.AddString(pciRes->StrName());
                ASSERT(nIndex != CB_ERR);
                m_cboxQuorumResource.SetItemDataPtr(nIndex, pciRes);
                pciRes->AddRef();
                if (m_strQuorumResource == pciRes->StrName())
                    pciSelected = pciRes;
            }  // if:  resource can be a quorum resource
        }  // try
        catch (...)
        {
            // Ignore all errors because there is really nothing we can do.
            // Displaying a message isn't really very useful.
        }  // catch:  Anything
    }  // while:  more items in the list

    // Select the current quorum resource in the list.
    {
        int     istr;

        istr = m_cboxQuorumResource.FindStringExact(-1, m_strQuorumResource);
        ASSERT(istr != CB_ERR);
        VERIFY(m_cboxQuorumResource.SetCurSel(istr) != CB_ERR);
    }  // Select the current quorum resource in the list

    // Check if the current quorum device is in the list of quorum capable resources
    if (pciSelected != NULL)
    {
        // Fill the partition list.
        FillPartitionList(pciSelected);
    }
    else
    {
        // There is nothing we can do in this case. There is something seriously wrong
        // with the cluster.
        CNTException nte(
                        ERROR_QUORUM_DISK_NOT_FOUND,
                        IDS_GET_QUORUM_DEVICES_ERROR
                        );
        nte.ReportError();
    } // else: the current quorum device is not in the list of quorum capable resources

}  //*** CClusterQuorumPage::FillResourceList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::ClearPartitionList
//
//  Routine Description:
//      Clear the partition list and release references to pointers.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterQuorumPage::ClearPartitionList(void)
{
    int                     cItems;
    int                     iItem;
    SPartitionItemData *    ppid = NULL;

    cItems = m_cboxPartition.GetCount();
    for ( iItem = 0 ; iItem < cItems ; iItem++ )
    {
        ppid = (SPartitionItemData *) m_cboxPartition.GetItemDataPtr( iItem );
        delete ppid;
    }  // for:  each item in the list

    m_cboxPartition.ResetContent();

}  //*** CClusterQuorumPage::ClearPartitionList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::FillPartitionList
//
//  Routine Description:
//      Fill the partition combobox with all partitions available on the
//      currently selected quorum resource.
//
//  Arguments:
//      pciRes      [IN OUT] Currently selected quorum resource.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterQuorumPage::FillPartitionList(IN OUT CResource * pciRes)
{
    CString                 strPartitionInfo;
    CLUSPROP_BUFFER_HELPER  buf;
    DWORD                   cbData;
    DWORD                   cbBuf;
    int                     nIndex;
    SPartitionItemData *    ppid = NULL;
    CWaitCursor             wc;

    ASSERT_VALID(pciRes);

    // Clear the list.
    ClearPartitionList();

    // Get disk info for this resource.
    if (BGetDiskInfo(*pciRes))
    {
        buf.pb = m_pbDiskInfo;
        cbBuf = m_cbDiskInfo;

        while (buf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
        {
            // Calculate the size of the value.
            cbData = sizeof(*buf.pValue) + ALIGN_CLUSPROP(buf.pValue->cbLength);
            ASSERT(cbData <= cbBuf);

            // Parse the value.
            if (buf.pSyntax->dw == CLUSPROP_SYNTAX_PARTITION_INFO)
            {
                // Add the partition to the combobox if it is a usable partition
                // and it hasn't been added already.
                if (   (buf.pPartitionInfoValue->dwFlags & CLUSPROP_PIFLAG_USABLE)
                    && (m_cboxPartition.FindString(-1, buf.pPartitionInfoValue->szDeviceName) == CB_ERR))
                {
                    try
                    {
                        // Construct the name to display to the user
                        // and add the item to the combobox.
                        strPartitionInfo.Format(
                                ( buf.pPartitionInfoValue->szVolumeLabel[ 0 ] ? _T("%ls (%ls) ") : _T("%ls ") ),
                                buf.pPartitionInfoValue->szDeviceName,
                                buf.pPartitionInfoValue->szVolumeLabel
                                );
                        nIndex = m_cboxPartition.AddString( strPartitionInfo );
                        ASSERT( nIndex != CB_ERR );

                        // Construct a partition item data structure,
                        // which consists of the device name, a partition
                        // name, and a root path name.
                        ppid = new SPartitionItemData;
                        if ( ppid == NULL )
                        {
                            AfxThrowMemoryException();
                        }
                        ASSERT( ( _tcslen( buf.pPartitionInfoValue->szDeviceName ) + 1 ) * sizeof( TCHAR ) <= sizeof( ppid->szDeviceName ) );
                        _tcscpy( ppid->szDeviceName, buf.pPartitionInfoValue->szDeviceName );
                        SplitDeviceName(
                            buf.pPartitionInfoValue->szDeviceName,
                            ppid->szPartitionName,
                            ppid->szBaseRootPath
                            );
                        m_cboxPartition.SetItemDataPtr( nIndex, ppid );
                    }  // try
                    catch (...)
                    {
                        // Ignore all errors because there is really nothing we can do.
                        // Displaying a message isn't really very useful.
                    }  // catch:  Anything
                }  // if:  partition not added yet
            }  // if:  partition info

            // Advance the buffer pointer
            buf.pb += cbData;
            cbBuf -= cbData;
        }  // while:  more values
    }  // if:  got disk info successfully

    // Select the current partition in the list.
    if (m_strPartition.GetLength() > 0)
    {
        nIndex = m_cboxPartition.SelectString( -1, m_strPartition );
    }  // if:  there is a current partition
    else
    {
        if (m_cboxPartition.GetCount() > 0)
        {
            nIndex = m_cboxPartition.SetCurSel( 0 );
        }  // if:  combobox has any entries
        else
        {
            nIndex = -1;
        } // else: no entries in the list
    }  // else:  no current selection
    if ( nIndex != -1 )
    {
        size_t  cchBaseRootPath;
        LPTSTR  pszRootPath;

        // Save the item data.
        // If the base root path is contained in the root path,
        // remove the base root path from the root path.
        m_ppid = (SPartitionItemData *) m_cboxPartition.GetItemDataPtr( nIndex );
        if ( m_ppid != NULL )
        {
            m_strPartition = m_ppid->szPartitionName;
            cchBaseRootPath = _tcslen( m_ppid->szBaseRootPath );
            if ( ( cchBaseRootPath > 0 )
              && ( _tcsncmp( m_strRootPath, m_ppid->szBaseRootPath, cchBaseRootPath ) == 0 ) )
            {
                pszRootPath = m_strRootPath.GetBuffer( 1 );
                _tcscpy( pszRootPath, &pszRootPath[ cchBaseRootPath ] );
                m_strRootPath.ReleaseBuffer();
            } // if: root path contains base root path
        } // if: ppid retrieved successfully
    } // if: an item is selected
    else if ( m_cboxPartition.GetCount() > 0 )
    {
        ASSERT( nIndex != CB_ERR );
    } // else if: combobox is not empty

}  //*** CClusterQuorumPage::FillPartitionList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::SplitDeviceName
//
//  Routine Description:
//      Split a device name into a partition name and a root path.  It is
//      expected that the output buffers are at least of size _MAX_PATH.
//
//  Arguments:
//      pszDeviceNameIn     Device name to split.
//      pszPartitionNameOut Partition name buffer to fill.
//      pszRootPathOut      Root path buffer to fill.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CClusterQuorumPage::SplitDeviceName(
    LPCTSTR pszDeviceNameIn,
    LPTSTR  pszPartitionNameOut,
    LPTSTR  pszRootPathOut
    )
{
    //
    // Construct the partition name and base root path from the device name.
    //

    //
    // If we have a UNC path it will end up looking like \\<X>\<Y>\.  If
    // it begins with "\\?\UNC\" we do a special case and pull out "\?\UNC".
    // We then search for the second '\' beyond that to end the partition name,
    // at which point we start grabbing the root path.
    //
    // If we have it pointing to a directory the partition should look like "c:"
    // and the root path should look like "winnt\cluster\MSCS"
    //

    if ( ( pszDeviceNameIn[ 0 ] == _T('\\') )
      && ( pszDeviceNameIn[ 1 ] == _T('\\') ) )
    {
        int cSlashes = 0;

        //
        // pszDeviceNameIn contains a UNC path.  Skip over any \\?\UNC\ prefix
        //
        if ( _tcsnicmp( pszDeviceNameIn, _T("\\\\?\\UNC\\"), 8 ) == 0 )
        {
            pszDeviceNameIn += 8;
        }        
        else
        {
            pszDeviceNameIn += 2;
        }

        //
        // Make sure out partition looks like a UNC path on output.
        //
        _sntprintf( pszPartitionNameOut, 2, _T("\\\\") );
        pszPartitionNameOut += 2;

        // Copy the server and share name to the partition string.
        for ( ; *pszDeviceNameIn != _T('\0') ; pszPartitionNameOut++, pszDeviceNameIn++ )
        {
            if ( *pszDeviceNameIn == _T('\\') )
            {
                cSlashes++;
                if ( cSlashes == 2 )
                {
                    break;
                } // if: found the slash after the share name
            } // if: found a slash
            *pszPartitionNameOut = *pszDeviceNameIn;
        } // for: each character in the device name

        // Copy the rest of the path to the root path string.
        if ( *pszDeviceNameIn == _T('\0') )
        {
            _tcscpy( pszRootPathOut, _T("\\") );
        } // if: no root path
        else
        {
            pszDeviceNameIn++;
            _tcscpy( pszRootPathOut, pszDeviceNameIn );
        } // else: root path specified
    } // if: UNC path
    else
    {
        _tsplitpath( pszDeviceNameIn, pszPartitionNameOut, pszRootPathOut, NULL, NULL );
    } // else: not a UNC path

} //*** CClusterQuorumPage::FillPartitionItemData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::BGetDiskInfo
//
//  Routine Description:
//      Get information about the currently selected disk.
//
//  Arguments:
//      rpciRes     [IN OUT] Disk resource to get info about.
//
//  Return Value:
//      TRUE        The operation was successful.
//      FALSE       The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterQuorumPage::BGetDiskInfo( IN OUT CResource & rpciRes )
{
    DWORD   dwStatus    = ERROR_SUCCESS;
    DWORD   cbDiskInfo  = sizeof( CLUSPROP_DWORD )
                            + sizeof( CLUSPROP_SCSI_ADDRESS )
                            + sizeof( CLUSPROP_DISK_NUMBER )
                            + sizeof( CLUSPROP_PARTITION_INFO )
                            + sizeof( CLUSPROP_SYNTAX );
    PBYTE   pbDiskInfo  = NULL;

    try
    {
        // Get disk info.
        pbDiskInfo = new BYTE[ cbDiskInfo ];
        if ( pbDiskInfo == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating memory
        dwStatus = ClusterResourceControl(
                        rpciRes.Hresource(),
                        NULL,
                        CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                        NULL,
                        0,
                        pbDiskInfo,
                        cbDiskInfo,
                        &cbDiskInfo
                        );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            delete [] pbDiskInfo;
            pbDiskInfo = new BYTE[ cbDiskInfo] ;
            if ( pbDiskInfo == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating memory
            dwStatus = ClusterResourceControl(
                            rpciRes.Hresource(),
                            NULL,
                            CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                            NULL,
                            0,
                            pbDiskInfo,
                            cbDiskInfo,
                            &cbDiskInfo
                            );
        }  // if:  buffer is too small
    }  // try
    catch ( CMemoryException * pme )
    {
        pme->Delete();
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException

    if ( dwStatus != ERROR_SUCCESS )
    {
        CNTException nte(
                        dwStatus,
                        IDS_GET_DISK_INFO_ERROR,
                        rpciRes.StrName(),
                        NULL,
                        FALSE /*bAutoDelete*/
                        );
        delete [] pbDiskInfo;
        nte.ReportError();
        nte.Delete();
        return FALSE;
    }  // if:  error getting disk info

    delete [] m_pbDiskInfo;
    m_pbDiskInfo = pbDiskInfo;
    m_cbDiskInfo = cbDiskInfo;

    return TRUE;

}  //*** CClusterQuorumPage::BGetDiskInfo()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterNetPriorityPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CClusterNetPriorityPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CClusterNetPriorityPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CClusterNetPriorityPage)
    ON_LBN_SELCHANGE(IDC_PP_CLUS_PRIORITY_LIST, OnSelChangeList)
    ON_BN_CLICKED(IDC_PP_CLUS_PRIORITY_UP, OnUp)
    ON_BN_CLICKED(IDC_PP_CLUS_PRIORITY_DOWN, OnDown)
    ON_BN_CLICKED(IDC_PP_CLUS_PRIORITY_PROPERTIES, OnProperties)
    ON_WM_DESTROY()
    ON_WM_CONTEXTMENU()
    ON_LBN_DBLCLK(IDC_PP_CLUS_PRIORITY_LIST, OnDblClkList)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_FILE_PROPERTIES, OnProperties)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::CClusterNetPriorityPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNetPriorityPage::CClusterNetPriorityPage(void)
    : CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_CLUSTER_NET_PRIORITY)
{
    //{{AFX_DATA_INIT(CClusterNetPriorityPage)
    //}}AFX_DATA_INIT

    m_bControlsInitialized = FALSE;

}  //*** CClusterNetPriorityPage::CClusterNetPriorityPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::OnDestroy
//
//  Routine Description:
//      Handler for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::OnDestroy(void)
{
    // If the controls have been initialized, clear the list box.
    if (BControlsInitialized())
        ClearNetworkList();

    // Call the base class method.
    CBasePropertyPage::OnDestroy();

}  //*** CClusterNetPriorityPage::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::DoDataExchange(CDataExchange* pDX)
{
    CBasePropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CClusterNetPriorityPage)
    DDX_Control(pDX, IDC_PP_CLUS_PRIORITY_PROPERTIES, m_pbProperties);
    DDX_Control(pDX, IDC_PP_CLUS_PRIORITY_DOWN, m_pbDown);
    DDX_Control(pDX, IDC_PP_CLUS_PRIORITY_UP, m_pbUp);
    DDX_Control(pDX, IDC_PP_CLUS_PRIORITY_LIST, m_lbList);
    //}}AFX_DATA_MAP

    m_bControlsInitialized = TRUE;

    if (pDX->m_bSaveAndValidate)
    {
        int         nIndex;
        int         cItems;
        CNetwork *  pciNet;

        ASSERT(!BReadOnly());

        // Save the list.
        LpciNetworkPriority().RemoveAll();

        cItems = m_lbList.GetCount();
        for (nIndex = 0 ; nIndex < cItems ; nIndex++)
        {
            pciNet = (CNetwork *) m_lbList.GetItemDataPtr(nIndex);
            ASSERT_VALID(pciNet);
            LpciNetworkPriority().AddTail(pciNet);
        }  // for:  each item in the list box
    }  // if:  saving data from the dialog

}  //*** CClusterNetPriorityPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterNetPriorityPage::OnInitDialog(void)
{
    CBasePropertyPage::OnInitDialog();

    if (BReadOnly())
    {
        m_lbList.EnableWindow(FALSE);
        m_pbUp.EnableWindow(FALSE);
        m_pbDown.EnableWindow(FALSE);
    }  // if:  object is read only

    try
    {
        // Duplicate the network priority list.
        {
            POSITION    pos;
            CNetwork *  pciNet;

            pos = PciCluster()->LpciNetworkPriority().GetHeadPosition();
            while (pos != NULL)
            {
                pciNet = (CNetwork *) PciCluster()->LpciNetworkPriority().GetNext(pos);
                ASSERT_VALID(pciNet);
                m_lpciNetworkPriority.AddTail(pciNet);
            }  // while:  more networks in the list
        }  // Duplicate the network priority list
    } // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    // Fill the list.
    FillList();

    // Set button states.
    OnSelChangeList();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CClusterNetPriorityPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::OnApply
//
//  Routine Description:
//      Handler for the PSN_APPLY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterNetPriorityPage::OnApply(void)
{
    ASSERT(!BReadOnly());

    try
    {
        PciCluster()->SetNetworkPriority(LpciNetworkPriority());
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CPropertyPage::OnApply();

}  //*** CClusterNetPriorityPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::OnSelChangeList
//
//  Routine Description:
//      Handler for the LBN_SELCHANGE message on the list box.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::OnSelChangeList(void)
{
    BOOL    bEnableUp;
    BOOL    bEnableDown;
    BOOL    bEnableProperties;
    int     isel;
    int     cItems;

    isel = m_lbList.GetCurSel();
    cItems = m_lbList.GetCount();

    // Enable buttons only if there is a selection and there
    // is more than one item in the list.
    if (BReadOnly() || (isel == LB_ERR) || (cItems <= 1))
    {
        bEnableUp = FALSE;
        bEnableDown = FALSE;
    }  // if:  no selection or only 0 or 1 items in the list
    else
    {
        bEnableUp = (isel > 0);
        bEnableDown = (isel < cItems - 1);
    }  // else:  buttons allowed to be enabled

    bEnableProperties = (isel != LB_ERR);

    m_pbUp.EnableWindow(bEnableUp);
    m_pbDown.EnableWindow(bEnableDown);
    m_pbProperties.EnableWindow(bEnableProperties);

}  //*** CClusterNetPriorityPage::OnSelChangeList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::OnUp
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Up push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::OnUp(void)
{
    int         isel;
    CNetwork *  pciNet;

    isel = m_lbList.GetCurSel();
    ASSERT(isel != LB_ERR);

    pciNet = (CNetwork *) m_lbList.GetItemDataPtr(isel);
    ASSERT_VALID(pciNet);

    VERIFY(m_lbList.DeleteString(isel) != LB_ERR);
    isel = m_lbList.InsertString(isel - 1, pciNet->StrName());
    ASSERT(isel != LB_ERR);
    VERIFY(m_lbList.SetItemDataPtr(isel, pciNet) != LB_ERR);
    VERIFY(m_lbList.SetCurSel(isel) != LB_ERR);

    OnSelChangeList();
    m_lbList.SetFocus();

    SetModified(TRUE);

}  //*** CClusterNetPriorityPage::OnUp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::OnDown
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Down push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::OnDown(void)
{
    int         isel;
    CNetwork *  pciNet;

    isel = m_lbList.GetCurSel();
    ASSERT(isel != LB_ERR);

    pciNet = (CNetwork *) m_lbList.GetItemDataPtr(isel);
    ASSERT_VALID(pciNet);

    VERIFY(m_lbList.DeleteString(isel) != LB_ERR);
    isel = m_lbList.InsertString(isel + 1, pciNet->StrName());
    ASSERT(isel != LB_ERR);
    VERIFY(m_lbList.SetItemDataPtr(isel, pciNet) != LB_ERR);
    VERIFY(m_lbList.SetCurSel(isel) != LB_ERR);

    OnSelChangeList();
    m_lbList.SetFocus();

    SetModified(TRUE);

}  //*** CClusterNetPriorityPage::OnDown()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::OnProperties
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Properties push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::OnProperties(void)
{
    DisplayProperties();

}  //*** CClusterNetPriorityPage::OnProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::FillList
//
//  Routine Description:
//      Fill the network list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::FillList(void)
{
    int         nIndex;
    POSITION    pos;
    CNetwork *  pciNet;
    CWaitCursor wc;

    ClearNetworkList();
    PciCluster()->CollectNetworkPriority(NULL);

    pos = LpciNetworkPriority().GetHeadPosition();
    while (pos != NULL)
    {
        pciNet = (CNetwork *) LpciNetworkPriority().GetNext(pos);
        ASSERT_VALID(pciNet);

        try
        {
            nIndex = m_lbList.AddString(pciNet->StrName());
            ASSERT(nIndex != LB_ERR);
            m_lbList.SetItemDataPtr(nIndex, pciNet);
            pciNet->AddRef();
        }  // try
        catch (...)
        {
            // Ignore all errors because there is really nothing we can do.
            // Displaying a message isn't really very useful.
        }  // catch:  Anything
    }  // while:  more items in the list

}  // CClusterNetPriorityPage::FillList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::ClearNetworkList
//
//  Routine Description:
//      Clear the network list and release references to pointers.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::ClearNetworkList(void)
{
    int         cItems;
    int         iItem;
    CNetwork *  pciNet;

    cItems = m_lbList.GetCount();
    for (iItem = 0 ; iItem < cItems ; iItem++)
    {
        pciNet = (CNetwork *) m_lbList.GetItemDataPtr(iItem);
        ASSERT_VALID(pciNet);
        ASSERT_KINDOF(CNetwork, pciNet);
        pciNet->Release();
    }  // for:  each item in the list

    m_lbList.ResetContent();

}  //*** CClusterNetPriorityPage::ClearNetworkList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::DisplayProperties
//
//  Routine Description:
//      Display properties of the item with the focus.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::DisplayProperties()
{
    int         isel;
    CNetwork *  pciNet;

    isel = m_lbList.GetCurSel();
    ASSERT(isel != LB_ERR);

    if (isel != LB_ERR)
    {
        // Get the network pointer.
        pciNet = (CNetwork *) m_lbList.GetItemDataPtr(isel);
        ASSERT_VALID(pciNet);

        // Set properties of that item.
        if (pciNet->BDisplayProperties())
        {
            // Remove the item.  If it is still used for internal cluster
            // communications, add it back in.
            VERIFY(m_lbList.DeleteString(isel) != LB_ERR);
            if (pciNet->Cnr() & ClusterNetworkRoleInternalUse)
            {
                isel = m_lbList.InsertString(isel, pciNet->StrName());
                ASSERT(isel != LB_ERR);
                VERIFY(m_lbList.SetItemDataPtr(isel, pciNet) != LB_ERR);
                VERIFY(m_lbList.SetCurSel(isel) != LB_ERR);
            }  // if:  still used for internal cluster communications
            else
                pciNet->Release();

            // Make sure only appropriate buttons are enabled.
            OnSelChangeList();
        }  // if:  properties changed
        m_lbList.SetFocus();
    }  // if:  found an item with focus

}  //*** CClusterNetPriorityPage::DisplayProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::OnContextMenu( CWnd * pWnd, CPoint point )
{
    BOOL            bHandled    = FALSE;
    CMenu *         pmenu       = NULL;
    CListBox *      pListBox    = (CListBox *) pWnd;
    CString         strMenuName;
    CWaitCursor     wc;

    // If focus is not in the list box, don't handle the message.
    if ( pWnd == &m_lbList )
    {
        // Create the menu to display.
        try
        {
            pmenu = new CMenu;
            if ( pmenu == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating memory
            if ( pmenu->CreatePopupMenu() )
            {
                UINT    nFlags  = MF_STRING;

                // If there are no items in the list, disable the menu item.
                if ( pListBox->GetCount() == 0 )
                {
                    nFlags |= MF_GRAYED;
                } // if: no items in the list

                // Add the Properties item to the menu.
                strMenuName.LoadString( IDS_MENU_PROPERTIES );
                if ( pmenu->AppendMenu( nFlags, ID_FILE_PROPERTIES, strMenuName ) )
                {
                    bHandled = TRUE;
                }  // if:  successfully added menu item
            }  // if:  menu created successfully
        }  // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
    }  // if:  focus is on the list control

    if ( bHandled )
    {
        // Display the menu.
        if ( ! pmenu->TrackPopupMenu(
                        TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                        point.x,
                        point.y,
                        this
                        ) )
        {
        }  // if:  unsuccessfully displayed the menu
    }  // if:  there is a menu to display
    else
    {
        CBasePropertyPage::OnContextMenu( pWnd, point );
    } // else: no menu to display

    delete pmenu;

}  //*** CClusterNetPriorityPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::OnDblClkList
//
//  Routine Description:
//      Handler method for the NM_DBLCLK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::OnDblClkList()
{
    DisplayProperties();

}  //*** CClusterNetPriorityPage::OnDblClkList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\cluster.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      Cluster.cpp
//
//  Abstract:
//      Implementation of the CCluster class.
//
//  Author:
//      David Potter (davidp)   May 13, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "Cluster.h"
#include "CASvc.h"
#include "ClusDoc.h"
#include "ClusProp.h"
#include "ExcOper.h"
#include "ClusItem.inl"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagCluster( _T("Document"), _T("CLUSTER"), 0 );
#endif

/////////////////////////////////////////////////////////////////////////////
// CCluster
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE( CCluster, CClusterItem )

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP( CCluster, CClusterItem )
    //{{AFX_MSG_MAP(CCluster)
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::CCluster
//
//  Routine Description:
//      Default construtor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCluster::CCluster( void ) : CClusterItem( NULL, IDS_ITEMTYPE_CLUSTER )
{
    m_idmPopupMenu = IDM_CLUSTER_POPUP;

    ZeroMemory( &m_cvi, sizeof( m_cvi ) );
    m_nMaxQuorumLogSize = 0;

    m_plpciNetworkPriority = NULL;

    // Set the object type and state images.
    m_iimgObjectType = GetClusterAdminApp()->Iimg( IMGLI_CLUSTER );
    m_iimgState = m_iimgObjectType;

    // Setup the property array.
    {
        m_rgProps[epropDefaultNetworkRole].Set(CLUSREG_NAME_CLUS_DEFAULT_NETWORK_ROLE, m_nDefaultNetworkRole, m_nDefaultNetworkRole);
        m_rgProps[epropDescription].Set(CLUSREG_NAME_CLUS_DESC, m_strDescription, m_strDescription);
        m_rgProps[epropEnableEventLogReplication].Set(CLUSREG_NAME_CLUS_EVTLOG_PROPAGATION, m_bEnableEventLogReplication, m_bEnableEventLogReplication);
        m_rgProps[epropQuorumArbitrationTimeMax].Set(CLUSREG_NAME_QUORUM_ARBITRATION_TIMEOUT, m_nQuorumArbitrationTimeMax, m_nQuorumArbitrationTimeMax);
        m_rgProps[epropQuorumArbitrationTimeMin].Set(CLUSREG_NAME_QUORUM_ARBITRATION_EQUALIZER, m_nQuorumArbitrationTimeMin, m_nQuorumArbitrationTimeMin);
    } // Setup the property array

}  //*** CCluster::CCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::~CCluster
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCluster::~CCluster( void )
{
    Cleanup();

}  //*** CCluster::~CCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::Cleanup
//
//  Routine Description:
//      Cleanup the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::Cleanup( void )
{
    // Delete the NetworkPriority list.
    if ( m_plpciNetworkPriority != NULL )
    {
        m_plpciNetworkPriority->RemoveAll();
        delete m_plpciNetworkPriority;
        m_plpciNetworkPriority = NULL;
    }  // if:  NetworkPriority list exists

    m_hkey = NULL;

}  //*** CCluster::Cleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::Init
//
//  Routine Description:
//      Initialize the item.
//
//  Arguments:
//      pdoc            [IN OUT] Document to which this item belongs.
//      lpszName        [IN] Name of the item.
//      hOpenedCluster  [IN] Handle to cluster to use that is already open.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from OpenCluster(), GetClusterKey(), or
//                          CreateClusterNotifyPort().
//      Any exceptions thrown by CCluster::ReadClusterInfo().
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::Init(
    IN OUT CClusterDoc *    pdoc,
    IN LPCTSTR              lpszName,
    IN HCLUSTER             hOpenedCluster // = NULL
    )
{
    CWaitCursor wc;
    TCHAR       szClusterName[ MAX_PATH ];

    ASSERT( Hkey() == NULL );
    ASSERT( lstrlen( lpszName ) < sizeof( szClusterName ) / sizeof( TCHAR ) );

    try
    {
        // If connecting the local machine, get its name.
        if ( lstrcmp( lpszName, _T(".") ) == 0 )
        {
            DWORD   nSize = sizeof( szClusterName ) / sizeof( TCHAR );
            GetComputerName( szClusterName, &nSize );
        }  // if:  connecting to the local machine
        else
        {
            lstrcpy( szClusterName, lpszName );
        }  // else:  not connecting to the local machine

        // Open the cluster.
        if ( hOpenedCluster == NULL )
        {
            pdoc->m_hcluster = HOpenCluster( lpszName );
            if ( pdoc->m_hcluster == NULL )
            {
                ThrowStaticException( GetLastError(), IDS_OPEN_CLUSTER_ERROR, szClusterName );
            } // if: error opening the cluster
        }  // if:  no opened cluster passed in
        else
        {
            pdoc->m_hcluster = hOpenedCluster;
        } // if: cluster already opened

        // Get the cluster registry key.
        pdoc->m_hkeyCluster = GetClusterKey( pdoc->m_hcluster, MAXIMUM_ALLOWED );
        if ( pdoc->m_hkeyCluster == NULL )
        {
            ThrowStaticException( GetLastError(), IDS_GET_CLUSTER_KEY_ERROR, szClusterName );
        } // if: error opening the cluster key

        // Call the base class method.  We can use Hcluster() after calling this.
        CClusterItem::Init( pdoc, szClusterName );

        // Get the cluster registry key.
        m_hkey = pdoc->m_hkeyCluster;

        // Register this cluster with the notification port.
        {
            HCHANGE     hchange;

            // We want these notifications to go to the document, not us.
            ASSERT( Pcnk() != NULL );
            m_pcnk->m_cnkt = cnktDoc;
            m_pcnk->m_pdoc = pdoc;
            Trace( g_tagClusItemNotify, _T("CCluster::Init() - Registering for cluster notifications (%08.8x)"), Pcnk() );

            // Create the notification port.
            hchange = CreateClusterNotifyPort(
                            GetClusterAdminApp()->HchangeNotifyPort(),
                            Hcluster(),
                            (CLUSTER_CHANGE_NODE_ADDED
                                | CLUSTER_CHANGE_GROUP_ADDED
                                | CLUSTER_CHANGE_RESOURCE_ADDED
                                | CLUSTER_CHANGE_RESOURCE_TYPE_ADDED
                                | CLUSTER_CHANGE_RESOURCE_TYPE_DELETED
                                | CLUSTER_CHANGE_RESOURCE_TYPE_PROPERTY
                                | CLUSTER_CHANGE_NETWORK_ADDED
                                | CLUSTER_CHANGE_NETINTERFACE_ADDED
                                | CLUSTER_CHANGE_QUORUM_STATE
                                | CLUSTER_CHANGE_CLUSTER_STATE
                                | CLUSTER_CHANGE_CLUSTER_PROPERTY
                                | CLUSTER_CHANGE_REGISTRY_NAME
                                | CLUSTER_CHANGE_REGISTRY_ATTRIBUTES
                                | CLUSTER_CHANGE_REGISTRY_VALUE
                                | CLUSTER_CHANGE_REGISTRY_SUBTREE),
                            (DWORD_PTR) Pcnk()
                            );
            if ( hchange == NULL )
            {
                ThrowStaticException( GetLastError(), IDS_CLUSTER_NOTIF_REG_ERROR, szClusterName );
            } // if: error creating the notify port
            ASSERT( hchange == GetClusterAdminApp()->HchangeNotifyPort() );
        }  // Register this cluster with the notification port

        // Get the name of the cluster as recorded by the cluster.
        ReadClusterInfo();

        // Allocate lists.
        m_plpciNetworkPriority = new CNetworkList;
        if ( m_plpciNetworkPriority == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the network list

        // Read the initial state.
        UpdateState();
    }  // try
    catch ( CException * )
    {
        if ( pdoc->m_hkeyCluster != NULL )
        {
            ClusterRegCloseKey( pdoc->m_hkeyCluster );
            pdoc->m_hkeyCluster = NULL;
            m_hkey = NULL;
        }  // if:  registry key opened
        if ( ( pdoc->m_hcluster != NULL ) && ( pdoc->m_hcluster != hOpenedCluster ) )
        {
            CloseCluster( Hcluster() );
            pdoc->m_hcluster = NULL;
        }  // if:  group opened
        m_bReadOnly = TRUE;
        throw;
    }  // catch:  CException

}  //*** CCluster::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ReadItem
//
//  Routine Description:
//      Read the item parameters from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue() or
//                              CClusterItem::ReadItem().
//      Any exceptions thrown by CCluster::ReadExtensions().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ReadItem( void )
{
    DWORD       dwStatus;
    DWORD       dwRetStatus = ERROR_SUCCESS;
    CWaitCursor wc;

    ASSERT( Hcluster() != NULL );
    ASSERT( Hkey() != NULL );

    if ( Hcluster() != NULL )
    {
        m_rgProps[epropDefaultNetworkRole].m_value.pdw = &m_nDefaultNetworkRole;
        m_rgProps[epropDescription].m_value.pstr = &m_strDescription;
        m_rgProps[epropEnableEventLogReplication].m_value.pb = &m_bEnableEventLogReplication;
        m_rgProps[epropQuorumArbitrationTimeMax].m_value.pdw = &m_nQuorumArbitrationTimeMax;
        m_rgProps[epropQuorumArbitrationTimeMin].m_value.pdw = &m_nQuorumArbitrationTimeMin;

        // Call the base class method.
        try
        {
            CClusterItem::ReadItem();
        }  // try
        catch ( CNTException * pnte )
        {
            dwRetStatus = pnte->Sc();
            pnte->Delete();
        }  // catch:  CNTException

        // Get the name of the cluster as recorded by the cluster.
        ReadClusterInfo();

        // Read and parse the common properties.
        {
            CClusPropList   cpl;

            Trace( g_tagCluster, _T("(%x) - CCluster::ReadItem() - Getting common properties"), this );
            dwStatus = cpl.ScGetClusterProperties(
                                Hcluster(),
                                CLUSCTL_CLUSTER_GET_COMMON_PROPERTIES
                                );
            if (dwStatus == ERROR_SUCCESS)
            {
                Trace( g_tagCluster, _T("(%x) - CCluster::ReadItem() - Parsing common properties"), this );
                dwStatus = DwParseProperties(cpl);
            } // if: properties read successfully
            if (dwStatus != ERROR_SUCCESS)
            {
                Trace( g_tagError, _T("(%x) - CCluster::ReadItem() - Error 0x%08.8x getting or parsing common properties"), this, dwStatus );

                // PROCNUM_OUT_OF_RANGE occurs when the server side
                // (clussvc.exe) doesn't support the ClusterControl( )
                // API.  In this case, read the data using the cluster
                // registry APIs.
                if ( dwStatus == RPC_S_PROCNUM_OUT_OF_RANGE )
                {
                    if ( Hkey() != NULL )
                    {
                        // Read the Description
                        dwStatus = DwReadValue( CLUSREG_NAME_CLUS_DESC, m_strDescription );
                        if ( ( dwStatus != ERROR_SUCCESS )
                          && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
                        {
                            dwRetStatus = dwStatus;
                        } // if: error reading the value
                    } // if: key is available
                } // if: must be talking to an NT4 node
                else
                {
                    dwRetStatus = dwStatus;
                } // else: not talking to an NT4 node
            } // if: error reading or parsing properties
        } // Read and parse the common properties

        // Get quorum resource information.
        {
            LPWSTR      pwszQResName    = NULL;
            LPWSTR      pwszQuorumPath  = NULL;
            DWORD       cchQResName;
            DWORD       cchQuorumPath;

            // Get the size of the resource name.
            cchQResName = 0;
            cchQuorumPath = 0;
            dwStatus = GetClusterQuorumResource(
                                Hcluster(),
                                NULL,
                                &cchQResName,
                                NULL,
                                &cchQuorumPath,
                                &m_nMaxQuorumLogSize
                                );
            if ( ( dwStatus == ERROR_SUCCESS ) || ( dwStatus == ERROR_MORE_DATA ) )
            {
                // Allocate enough space for the data.
                cchQResName++;  // Don't forget the final null-terminator.
                pwszQResName = new WCHAR[ cchQResName ];
                cchQuorumPath++;
                pwszQuorumPath = new WCHAR[ cchQuorumPath ];
                ASSERT( pwszQResName != NULL && pwszQuorumPath != NULL );


                // Read the resource name.
                dwStatus = GetClusterQuorumResource(
                                    Hcluster(),
                                    pwszQResName,
                                    &cchQResName,
                                    pwszQuorumPath,
                                    &cchQuorumPath,
                                    &m_nMaxQuorumLogSize
                                    );
            }  // if:  got the size successfully
            if ( dwStatus != ERROR_SUCCESS )
            {
                dwRetStatus = dwStatus;
            } // if: error occurred
            else
            {
                m_strQuorumResource = pwszQResName;
                m_strQuorumPath = pwszQuorumPath;
                ASSERT( m_strQuorumPath[ m_strQuorumPath.GetLength() - 1 ] == _T('\\') );
            }  // else:  quorum resource info retrieved successfully

            delete [] pwszQResName;
            delete [] pwszQuorumPath;
        }  // Get the quorum resource name

        // Read the FQDN for the cluster.
        {
            DWORD   cbReturned;
            DWORD   cbFQDN;
            LPWSTR  pszFQDN = NULL;

            pszFQDN = m_strFQDN.GetBuffer( 256 );
            cbFQDN = 256 * sizeof( WCHAR );
            dwStatus = ClusterControl(
                            Hcluster(),
                            NULL,
                            CLUSCTL_CLUSTER_GET_FQDN,
                            NULL,
                            NULL,
                            pszFQDN,
                            cbFQDN,
                            &cbReturned
                            );
            if ( dwStatus == ERROR_MORE_DATA )
            {
                cbFQDN = cbReturned + sizeof( WCHAR );
                pszFQDN = m_strFQDN.GetBuffer( ( cbReturned / sizeof( WCHAR ) ) + 1 );
                dwStatus = ClusterControl(
                                Hcluster(),
                                NULL,
                                CLUSCTL_CLUSTER_GET_FQDN,
                                NULL,
                                NULL,
                                pszFQDN,
                                cbFQDN,
                                &cbReturned
                                );
            } // if: buffer not large enough
            if ( dwStatus != ERROR_SUCCESS )
            {
                // Handle the case where the API doesn't exist (e.g. NT4).
                // also
                // Handle the case where the control code is not known (e.g. Win2K)
                if (   ( dwStatus == RPC_S_PROCNUM_OUT_OF_RANGE )
                    || ( dwStatus == ERROR_INVALID_FUNCTION ) )
                {
                    lstrcpy( pszFQDN, StrName() );
                    m_strFQDN.ReleaseBuffer();
                }
                else
                {
                    dwRetStatus = dwStatus;
                }
            }
            else
            {
                m_strFQDN.ReleaseBuffer();
            } // else:  data retrieved successfully
        } // if:  no error yet

    }  // if:  cluster is available

    // If any errors occurred, throw an exception.
    if ( dwRetStatus != ERROR_SUCCESS )
    {
        ThrowStaticException( dwRetStatus, IDS_READ_CLUSTER_PROPS_ERROR, StrName() );
    } // if: error occurred

    // Read extension lists.
    ReadClusterExtensions();
    ReadNodeExtensions();
    ReadGroupExtensions();
    ReadResourceExtensions();
    ReadResTypeExtensions();
    ReadNetworkExtensions();
    ReadNetInterfaceExtensions();

    // Read the initial state.
    UpdateState();

    MarkAsChanged( FALSE );

}  //*** CCluster::ReadItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::PlstrExtensions
//
//  Routine Description:
//      Return the list of admin extensions.
//
//  Arguments:
//      None.
//
//  Return Value:
//      plstr       List of extensions.
//      NULL        No extension associated with this object.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CStringList * CCluster::PlstrExtensions( void ) const
{
    return &LstrClusterExtensions();

}  //*** CCluster::PlstrExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ReadClusterInfo
//
//  Routine Description:
//      Get the name of the cluster as recorded by the cluster and the
//      version of the cluster software.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by new.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ReadClusterInfo( void )
{
    DWORD       dwStatus;
    LPWSTR      pwszName    = NULL;
    DWORD       cchName     = 128;
    CWaitCursor wc;

    try
    {
        pwszName = new WCHAR[ cchName ];
        if ( pwszName == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the name buffer
        m_cvi.dwVersionInfoSize = sizeof( m_cvi );
        dwStatus = GetClusterInformation( Hcluster(), pwszName, &cchName, &m_cvi );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            delete [] pwszName;
            cchName++;
            pwszName = new WCHAR[ cchName ];
            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the name buffer
            dwStatus = GetClusterInformation( Hcluster(), pwszName, &cchName, &m_cvi );
        }  // if:  buffer is too small
        if ( dwStatus == ERROR_SUCCESS )
        {
            Pdoc()->m_strName = pwszName;
        } // if: error occurred
        else
        {
            TraceError( _T("CCluster::Init() calling GetClusterInformation"), dwStatus );
        } // else: no error occurred
        m_strName = pwszName;
        delete [] pwszName;
    }  // try
    catch (CException *)
    {
        delete [] pwszName;
        throw;
    }  // catch:  CException

}  //*** CCluster::ReadClusterInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ReadClusterExtensions
//
//  Routine Description:
//      Read the extension list for the cluster object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ReadClusterExtensions( void )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hkey() != NULL );

    if ( Hkey() != NULL )
    {
        // Read the Cluster extension string.
        dwStatus = DwReadValue( CLUSREG_NAME_ADMIN_EXT, m_lstrClusterExtensions );
        if ( ( dwStatus != ERROR_SUCCESS )
          && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
        {
            ThrowStaticException( dwStatus );
        } // if: error reading the value
    }  // if:  key is available
    else
    {
        m_lstrClusterExtensions.RemoveAll();
    } // else: key is not available

}  //*** CCluster::ReadClusterExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ReadNodeExtensions
//
//  Routine Description:
//      Read the extension list for all nodes.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ReadNodeExtensions( void )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hkey() != NULL );

    if ( Hkey() != NULL )
    {
        // Read the Nodes extension string.
        dwStatus = DwReadValue( CLUSREG_NAME_ADMIN_EXT, CLUSREG_KEYNAME_NODES, m_lstrNodeExtensions );
        if ( ( dwStatus != ERROR_SUCCESS )
          && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
        {
            ThrowStaticException( dwStatus );
        } // if: error reading the value
    }  // if:  key is available
    else
    {
        m_lstrNodeExtensions.RemoveAll();
    } // else: key is not available

}  //*** CCluster::ReadNodeExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ReadGroupExtensions
//
//  Routine Description:
//      Read the extension list for all groups.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ReadGroupExtensions( void )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hkey() != NULL );

    if ( Hkey() != NULL )
    {
        // Read the Groups extension string.
        dwStatus = DwReadValue( CLUSREG_NAME_ADMIN_EXT, CLUSREG_KEYNAME_GROUPS, m_lstrGroupExtensions );
        if ( ( dwStatus != ERROR_SUCCESS )
          && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
        {
            ThrowStaticException( dwStatus );
        } // if: error reading the value
    }  // if:  key is available
    else
    {
        m_lstrGroupExtensions.RemoveAll();
    } // else: key is not available

}  //*** CCluster::ReadGroupExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ReadResourceExtensions
//
//  Routine Description:
//      Read the extension list for all resources.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ReadResourceExtensions( void )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hkey() != NULL );

    if ( Hkey() != NULL )
    {
        // Read the Resources extension string.
        dwStatus = DwReadValue( CLUSREG_NAME_ADMIN_EXT, CLUSREG_KEYNAME_RESOURCES, m_lstrResourceExtensions );
        if ( ( dwStatus != ERROR_SUCCESS )
          && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
        {
            ThrowStaticException( dwStatus );
        } // if: error reading the value
    }  // if:  key is available
    else
    {
        m_lstrResourceExtensions.RemoveAll();
    } // else: key is not available

}  //*** CCluster::ReadResourceExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ReadResTypeExtensions
//
//  Routine Description:
//      Read the extension list for all resouce types.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ReadResTypeExtensions( void )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hkey() != NULL );

    if ( Hkey() != NULL )
    {
        // Read the Resource Types extension string.
        dwStatus = DwReadValue( CLUSREG_NAME_ADMIN_EXT, CLUSREG_KEYNAME_RESOURCE_TYPES, m_lstrResTypeExtensions );
        if ( ( dwStatus != ERROR_SUCCESS )
          && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
        {
            ThrowStaticException( dwStatus );
        } // if: error reading the value
    }  // if: key is available
    else
    {
        m_lstrResTypeExtensions.RemoveAll();
    } // else: key is not available

}  //*** CCluster::ReadResTypeExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ReadNetworkExtensions
//
//  Routine Description:
//      Read the extension list for all networks.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ReadNetworkExtensions( void )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hkey() != NULL );

    if ( Hkey() != NULL )
    {
        // Read the Networks extension string.
        dwStatus = DwReadValue( CLUSREG_NAME_ADMIN_EXT, CLUSREG_KEYNAME_NETWORKS, m_lstrNetworkExtensions );
        if ( ( dwStatus != ERROR_SUCCESS )
          && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
        {
            ThrowStaticException( dwStatus );
        } // if: error reading the value
    }  // if:  key is available
    else
    {
        m_lstrNetworkExtensions.RemoveAll();
    } // else: key is not available

}  //*** CCluster::ReadNetworkExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::ReadNetInterfaceExtensions
//
//  Routine Description:
//      Read the extension list for all network interfaces.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::ReadNetInterfaceExtensions( void )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hkey() != NULL );

    if ( Hkey() != NULL )
    {
        // Read the Network Intefaces extension string.
        dwStatus = DwReadValue( CLUSREG_NAME_ADMIN_EXT, CLUSREG_KEYNAME_NETINTERFACES, m_lstrNetInterfaceExtensions );
        if ( ( dwStatus != ERROR_SUCCESS )
          && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
        {
            ThrowStaticException( dwStatus );
        } // if: error reading the value
    }  // if:  key is available
    else
    {
        m_lstrNetInterfaceExtensions.RemoveAll();
    } // else: key is not available

}  //*** CCluster::ReadNetInterfaceExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::CollecNetworkPriority
//
//  Routine Description:
//      Construct the network priority list.
//
//  Arguments:
//      plpci           [IN OUT] List to fill.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from ClusterOpenEnum() or ClusterEnum().
//      Any exceptions thrown by new or CList::AddTail().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::CollectNetworkPriority( IN OUT CNetworkList * plpci )
{
    DWORD           dwStatus;
    HCLUSENUM       hclusenum;
    int             ienum;
    LPWSTR          pwszName = NULL;
    DWORD           cchName;
    DWORD           cchmacName;
    DWORD           dwRetType;
    CNetwork *      pciNet;
    CWaitCursor     wc;

    ASSERT_VALID( Pdoc() );
    ASSERT( Hcluster() != NULL );

    if ( plpci == NULL )
    {
        plpci = m_plpciNetworkPriority;
    } // if: no list specified

    ASSERT( plpci != NULL );

    // Remove the previous contents of the list.
    plpci->RemoveAll();

    if ( Hcluster() != NULL )
    {
        // Open the enumeration.
        hclusenum = ClusterOpenEnum( Hcluster(), (DWORD) CLUSTER_ENUM_INTERNAL_NETWORK );
        if ( hclusenum == NULL )
        {
            ThrowStaticException( GetLastError(), IDS_ENUM_NETWORK_PRIORITY_ERROR, StrName() );
        } // if: error opening the enmeration

        try
        {
            // Allocate a name buffer.
            cchmacName = 128;
            pwszName = new WCHAR[ cchmacName ];
            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the name buffer

            // Loop through the enumeration and add each network to the list.
            for ( ienum = 0 ; ; ienum++ )
            {
                // Get the next item in the enumeration.
                cchName = cchmacName;
                dwStatus = ClusterEnum( hclusenum, ienum, &dwRetType, pwszName, &cchName );
                if ( dwStatus == ERROR_MORE_DATA )
                {
                    delete [] pwszName;
                    cchmacName = ++cchName;
                    pwszName = new WCHAR[ cchmacName ];
                    if ( pwszName == NULL )
                    {
                        AfxThrowMemoryException();
                    } // if: error allocating the name buffer
                    dwStatus = ClusterEnum( hclusenum, ienum, &dwRetType, pwszName, &cchName );
                }  // if:  name buffer was too small
                if ( dwStatus == ERROR_NO_MORE_ITEMS )
                {
                    break;
                } // if: done with the enumeraiton
                else if ( dwStatus != ERROR_SUCCESS )
                {
                    ThrowStaticException( dwStatus, IDS_ENUM_NETWORK_PRIORITY_ERROR, StrName() );
                } // else if: error getting the next enumeration value

                ASSERT( dwRetType == CLUSTER_ENUM_INTERNAL_NETWORK );

                // Find the item in the list of networks on the document.
                pciNet = Pdoc()->LpciNetworks().PciNetworkFromName( pwszName );
                ASSERT_VALID( pciNet );

                // Add the network to the list.
                if ( pciNet != NULL )
                {
                    plpci->AddTail( pciNet );
                }  // if:  found network in list

            }  // for:  each item in the group

            ClusterCloseEnum( hclusenum );

        }  // try
        catch ( CException * )
        {
            delete [] pwszName;
            ClusterCloseEnum( hclusenum );
            throw;
        }  // catch:  any exception
    }  // if:  cluster is available

    delete [] pwszName;

}  //*** CCluster::CollecNetworkPriority()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::OnUpdateProperties
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_PROPERTIES
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::OnUpdateProperties( CCmdUI * pCmdUI )
{
    pCmdUI->Enable(TRUE);

}  //*** CCluster::OnUpdateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::BDisplayProperties
//
//  Routine Description:
//      Display properties for the object.
//
//  Arguments:
//      bReadOnly   [IN] Don't allow edits to the object properties.
//
//  Return Value:
//      TRUE    OK pressed.
//      FALSE   OK not pressed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCluster::BDisplayProperties( IN BOOL bReadOnly )
{
    BOOL                bChanged = FALSE;
    CClusterPropSheet   sht( AfxGetMainWnd() );

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // If the object has changed, read it.
    if ( BChanged() )
    {
        ReadItem();
    } // if: object changed

    // Display the property sheet.
    try
    {
        sht.SetReadOnly( bReadOnly );
        if ( sht.BInit( this, IimgObjectType() ) )
        {
            bChanged = ( ( sht.DoModal() == IDOK ) && ! bReadOnly );
        } // if: initialized successfully
    }  // try
    catch ( CException * pe )
    {
        pe->Delete();
    }  // catch:  CException

    Release();
    return bChanged;

}  //*** CCluster::BDisplayProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::SetName
//
//  Routine Description:
//      Set the name of the cluster.
//
//  Arguments:
//      pszName         [IN] New name of the cluster.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by WriteItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::SetName( IN LPCTSTR pszName )
{
    Rename( pszName );

}  //*** CCluster::SetName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::SetDescription
//
//  Routine Description:
//      Set the description in the cluster database.
//
//  Arguments:
//      pszDesc     [IN] Description to set.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by WriteItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::SetDescription( IN LPCTSTR pszDesc )
{
    ASSERT( Hkey() != NULL );

    if ( ( Hkey() != NULL ) && ( m_strDescription != pszDesc ) )
    {
        WriteValue( CLUSREG_NAME_CLUS_DESC, NULL, pszDesc );
        m_strDescription = pszDesc;
    }  // if:  a change occured

}  //*** CCluster::SetDescription()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::SetQuorumResource
//
//  Routine Description:
//      Set the quorum resource for the cluster.
//
//  Arguments:
//      pszResource     [IN] Name of resource to make the quorum resource.
//      pszQuorumPath   [IN] Path for storing cluster files.
//      nMaxLogSize     [IN] Maximum size of the quorum log.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    IDS_SET_QUORUM_RESOURCE_ERROR - errors from
//                          SetClusterQuorumResource().
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::SetQuorumResource(
    IN LPCTSTR  pszResource,
    IN LPCTSTR  pszQuorumPath,
    IN DWORD    nMaxLogSize
    )
{
    DWORD       dwStatus;
    CResource * pciRes;
    CString     strRes( pszResource );  // Required if built non-Unicode
    CWaitCursor wc;

    ASSERT( pszResource != NULL );

    if ( ( StrQuorumResource() != pszResource )
      || ( StrQuorumPath() != pszQuorumPath )
      || ( NMaxQuorumLogSize() != nMaxLogSize ) )
    {
        // Find the resource.
        pciRes = Pdoc()->LpciResources().PciResFromName( pszResource );
        ASSERT_VALID( pciRes );
        ASSERT( pciRes->Hresource() != NULL );

        if ( pciRes->Hresource() != NULL )
        {
            // Change the quorum resource.
            dwStatus = SetClusterQuorumResource( pciRes->Hresource(), pszQuorumPath, nMaxLogSize );
            if ( dwStatus != ERROR_SUCCESS )
            {
                ThrowStaticException( dwStatus, IDS_SET_QUORUM_RESOURCE_ERROR, pciRes->StrName() );
            } // if: error setting the quorum resource

            m_strQuorumResource = pszResource;
            m_strQuorumPath = pszQuorumPath;
            m_nMaxQuorumLogSize = nMaxLogSize;
        }  // if:  resource is available
    }  // if:  the quorum resource changed

}  //*** CCluster::SetQuorumResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::SetNetworkPriority
//
//  Routine Description:
//      Set the network priority list.
//
//  Arguments:
//      rlpci       [IN] List of networks in priority order.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by HNETWORK::new.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::SetNetworkPriority( IN const CNetworkList & rlpci )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hcluster() != NULL );

    if ( Hcluster() != NULL )
    {
        BOOL        bChanged    = TRUE;

        // Determine if the list has changed.
        if ( rlpci.GetCount() == LpciNetworkPriority().GetCount() )
        {
            POSITION    posOld;
            POSITION    posNew;
            CNetwork *  pciOldNet;
            CNetwork *  pciNewNet;

            bChanged = FALSE;

            posOld = LpciNetworkPriority().GetHeadPosition();
            posNew = rlpci.GetHeadPosition();
            while ( posOld != NULL )
            {
                pciOldNet = (CNetwork *) LpciNetworkPriority().GetNext( posOld );
                ASSERT_VALID( pciOldNet );

                ASSERT( posNew != NULL );
                pciNewNet = (CNetwork *) rlpci.GetNext( posNew );
                ASSERT_VALID( pciNewNet );

                if ( pciOldNet->StrName() != pciNewNet->StrName() )
                {
                    bChanged = TRUE;
                    break;
                }  // if:  name is not the same
            }  // while:  more items in the old list
        }  // if:  same number of items in the list

        if ( bChanged )
        {
            HNETWORK *  phnetwork   = NULL;

            try
            {
                DWORD       ipci;
                POSITION    posPci;
                CNetwork *  pciNet;

                // Allocate an array for all the node handles.
                phnetwork = new HNETWORK[ (DWORD) rlpci.GetCount() ];
                if ( phnetwork == NULL )
                {
                    ThrowStaticException( GetLastError() );
                } // if: error allocating network handle array

                // Copy the handle of all the networks in the networks list to the handle aray.
                posPci = rlpci.GetHeadPosition();
                for ( ipci = 0 ; posPci != NULL ; ipci++ )
                {
                    pciNet = (CNetwork *) rlpci.GetNext( posPci );
                    ASSERT_VALID( pciNet );
                    phnetwork[ ipci ] = pciNet->Hnetwork();
                }  // while:  more networks in the list

                // Set the property.
                dwStatus = SetClusterNetworkPriorityOrder( Hcluster(), (DWORD) rlpci.GetCount(), phnetwork );
                if ( dwStatus != ERROR_SUCCESS )
                {
                    ThrowStaticException( dwStatus, IDS_SET_NET_PRIORITY_ERROR, StrName() );
                } // if: error setting network priority

                // Update the PCI list.
                m_plpciNetworkPriority->RemoveAll();
                posPci = rlpci.GetHeadPosition();
                while ( posPci != NULL )
                {
                    pciNet = (CNetwork *) rlpci.GetNext( posPci );
                    m_plpciNetworkPriority->AddTail( pciNet );
                }  // while:  more items in the list
            } // try
            catch ( CException * )
            {
                delete [] phnetwork;
                throw;
            }  // catch:  CException

            delete [] phnetwork;

        }  // if:  list changed
    }  // if:  key is available

}  //*** CCluster::SetNetworkPriority(CNetworkList*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::Rename
//
//  Routine Description:
//      Change the name of the cluster..
//
//  Arguments:
//      pszName         [IN] New name to give to the cluster.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors returned from SetClusterName().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::Rename( IN LPCTSTR pszName )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hcluster() != NULL );

    if ( StrName() != pszName )
    {
        // Set the name.
        dwStatus = SetClusterName( Hcluster(), pszName );
        if ( dwStatus != ERROR_SUCCESS )
        {
            if ( dwStatus == ERROR_RESOURCE_PROPERTIES_STORED )
            {
                AfxMessageBox( IDS_RESTART_CLUSTER_NAME, MB_OK | MB_ICONEXCLAMATION );
            } // if: properties stored but not in use yet
            else
            {
                ThrowStaticException( dwStatus, IDS_RENAME_CLUSTER_ERROR, StrName(), pszName );
            } // else: error occurred
        }  // if:  error occurred setting cluster name
        m_strName = pszName;
    }  // if:  the name changed

}  //*** CCluster::Rename()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::BIsLabelEditValueValid
//
//  Routine Description:
//      Validate the label edit value as a cluster name
//
//  Arguments:
//      pszName         [IN] New name to give to the cluster.
//
//  Return Value:
//      TRUE    name is valid
//      FALSE   name is invalid
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCluster::BIsLabelEditValueValid( IN LPCTSTR pszName )
{
    BOOL    bSuccess = TRUE;

    if ( StrName() != pszName )
    {
        CLRTL_NAME_STATUS   cnStatus;
        UINT                idsError;

        // Validate the name.
        if ( ! ClRtlIsNetNameValid( pszName, &cnStatus, FALSE /*CheckIfExists*/ ) )
        {
            switch ( cnStatus )
            {
                case NetNameTooLong:
                    idsError = IDS_INVALID_CLUSTER_NAME_TOO_LONG;
                    break;
                case NetNameInvalidChars:
                    idsError = IDS_INVALID_CLUSTER_NAME_INVALID_CHARS;
                    break;
                case NetNameInUse:
                    idsError = IDS_INVALID_CLUSTER_NAME_IN_USE;
                    break;
                case NetNameDNSNonRFCChars:
                    idsError = IDS_INVALID_CLUSTER_NAME_INVALID_DNS_CHARS;
                    break;
                case NetNameSystemError:
                {
                    DWORD scError = GetLastError();
                    ThrowStaticException( scError, IDS_ERROR_VALIDATING_NETWORK_NAME, pszName );
                }
                default:
                    idsError = IDS_INVALID_CLUSTER_NAME;
                    break;
            } // switch:  cnStatus

            if ( idsError == IDS_INVALID_CLUSTER_NAME_INVALID_DNS_CHARS )
            {
                int id = AfxMessageBox(IDS_INVALID_CLUSTER_NAME_INVALID_DNS_CHARS, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION );

                if ( id == IDNO )                   
                {
                    bSuccess = FALSE;
                }
            }
            else
            {
                bSuccess = FALSE;
            }
        } // if:  error validating the name
    }  // if:  the name changed

    return bSuccess;
}  //*** CCluster::BIsLabelEditValueValid()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::OnBeginLabelEdit
//
//  Routine Description:
//      Prepare an edit control in a view for editing the cluster name.
//
//  Arguments:
//      pedit       [IN OUT] Edit control to prepare.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::OnBeginLabelEdit( IN OUT CEdit * pedit )
{
    ASSERT_VALID(pedit);

    pedit->SetLimitText( MAX_CLUSTERNAME_LENGTH );
    pedit->ModifyStyle( 0 /*dwRemove*/, ES_UPPERCASE | ES_OEMCONVERT /*dwAdd*/ );

}  //*** CCluster::OnBeginLabelEdit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluster::UpdateState
//
//  Routine Description:
//      Update the current state of the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluster::UpdateState( void )
{
    // NOTENOTE: not referneced
    //CClusterAdminApp *    papp = GetClusterAdminApp();

    CString             strTitle;

    GetClusterAdminApp();

    Trace( g_tagCluster, _T("(%s) - Updating state"), StrName() );

    // Update the title of the document.
    ASSERT_VALID( Pdoc() );
    try
    {
        Pdoc()->UpdateTitle();
    }  // try
    catch ( CException * pe )
    {
        pe->Delete();
    }  // catch:  CException

    // Call the base class method.
    CClusterItem::UpdateState();

}  //*** CCluster::UpdateState()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\cmdline.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		CmdLine.cpp
//
//	Abstract:
//		Implementation of the CCluAdminCommandLineInfo class.
//
//	Author:
//		David Potter (davidp)	March 31, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CmdLine.h"
#include "TraceTag.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#if CLUSTER_BETA
//
// cheesy prototype for turning auth on or off
//

extern "C" VOID ClusapiSetRPCAuthentication(BOOL Authenticate);

#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag	g_tagCmdLine(_T("App"), _T("CmdLine"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CCluAdminCommandLineInfo
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCluAdminCommandLineInfo::CCluAdminCommandLineInfo
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCluAdminCommandLineInfo::CCluAdminCommandLineInfo(void)
{
	m_nShellCommand = CCommandLineInfo::FileNothing;	// Don't want to do a FileNew.
	m_bReconnect = TRUE;

}  //*** CCluAdminCommandLineInfo::CCluAdminCommandLineInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CCluAdminCommandLineInfo::ParseParam
//
//	Routine Description:
//		Parse a command line parameter.
//
//	Arguments:
//		pszParam		[IN] Parameter to parse.
//		bFlag			[IN] TRUE = parameter is a flag.
//		bLast			[IN] TRUE = parameter is the last parameter on the command line.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCluAdminCommandLineInfo::ParseParam(
	const TCHAR *	pszParam,
	BOOL			bFlag,
	BOOL			bLast
	)
{
	if (bFlag)
	{
		CString	str1;
		CString	str2;
		CString	str3;

		str1.LoadString(IDS_CMDLINE_NORECONNECT);
		str2.LoadString(IDS_CMDLINE_NORECON);
		str3.LoadString(IDS_CMDLINE_NORPCAUTH);

		if (   (str1.CompareNoCase(pszParam) == 0)
			|| (str2.CompareNoCase(pszParam) == 0))
			m_bReconnect = FALSE;

#if CLUSTER_BETA
		else if (str3.CompareNoCase(pszParam) == 0)
			ClusapiSetRPCAuthentication(FALSE);
#endif

	}  // if:  this is a flag parameter
	else
	{
		m_lstrClusters.AddTail(pszParam);
		m_nShellCommand = CCommandLineInfo::FileOpen;
		m_bReconnect = FALSE;
	}  // else:  this is not a flag parameter

}  //*** CCluAdminCommandLineInfo::ParseParam()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\cmdline.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		CmdLine.h
//
//	Abstract:
//		Definition of the CCluAdminCommandLineInfo class.
//
//	Implementation File:
//		CmdLine.cpp
//
//	Author:
//		David Potter (davidp)	March 31, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CMDLINE_H_
#define _CMDLINE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CCluAdminCommandLineInfo;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CCluAdminCommandLineInfo
/////////////////////////////////////////////////////////////////////////////

class CCluAdminCommandLineInfo : public CCommandLineInfo
{
public:
	CCluAdminCommandLineInfo(void);

// Attributes
public:
	CStringList		m_lstrClusters;
	BOOL			m_bReconnect;

	CStringList &	LstrClusters(void) { return m_lstrClusters; }

// Operations
public:

// Overrides
public:
	virtual void ParseParam(IN const TCHAR * pszParam, IN BOOL bFlag, IN BOOL bLast);

// Implementation
public:

protected:

};  //*** class CCluAdminCommandLineInfo

/////////////////////////////////////////////////////////////////////////////

#endif // _CMDLINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\colitem.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ColItem.cpp
//
//	Abstract:
//		Implementation of the CColumnItem class.
//
//	Author:
//		David Potter (davidp)	May 7, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ColItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CColumnItem

IMPLEMENT_DYNCREATE(CColumnItem, CObject)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CColumnItem::CColumnItem
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CColumnItem::CColumnItem(void)
{
	m_colid = 0;
	m_nDefaultWidth = COLI_WIDTH_DEFAULT;
	m_nWidth = COLI_WIDTH_DEFAULT;

}  //*** CColumnItem::CColumnItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CColumnItem::CColumnItem
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		rstrText		[IN] Text that appears on the column header.
//		colid			[IN] Column ID for identifying data relating to this column.
//		nDefaultWidth	[IN] Default width of the column.  Defaults to COLI_WIDTH_DEFAULT if -1.
//		nWidth			[IN] Initial width of the column.  Defaults to nDefaultWidth if -1.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CColumnItem::CColumnItem(
	IN const CString &	rstrText,
	IN COLID			colid,
	IN int				nDefaultWidth,	// = -1
	IN int				nWidth			// = -1
	)
{
	ASSERT(colid != 0);
	ASSERT(nDefaultWidth > 0);
	ASSERT((nWidth > 0) || (nWidth == -1));

	if (nDefaultWidth == -1)
		nDefaultWidth = COLI_WIDTH_DEFAULT;
	if (nWidth == -1)
		nWidth = nDefaultWidth;

	m_strText = rstrText;
	m_colid = colid;
	m_nDefaultWidth = nDefaultWidth;
	m_nWidth = nWidth;

}  //*** CColumnItem::CColumnItem(pci)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CColumnItem::~CColumnItem
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CColumnItem::~CColumnItem(void)
{
}  //*** CColumnItem::~CColumnItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CColumnItem::PcoliClone
//
//	Routine Description:
//		Clone the item.
//
//	Arguments:
//		None.
//
//	Return Value:
//		pcoli		The newly created item that is a clone of this item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CColumnItem * CColumnItem::PcoliClone(void)
{
	CColumnItem *	pcoli	= NULL;

	pcoli = new CColumnItem(StrText(), NDefaultWidth(), NWidth());
	return pcoli;

}  //*** CColumnItem::PcoliClone()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DeleteAllItemData
//
//	Routine Description:
//		Deletes all item data in a CList.
//
//	Arguments:
//		rlp		[IN OUT] Reference to the list whose data is to be deleted.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DeleteAllItemData(IN OUT CColumnItemList & rlp)
{
	POSITION		pos;
	CColumnItem *	pcoli;

	// Delete all the items in the Contained list.
	pos = rlp.GetHeadPosition();
	while (pos != NULL)
	{
		pcoli = rlp.GetNext(pos);
		ASSERT_VALID(pcoli);
		delete pcoli;
	}  // while:  more items in the list

}  //*** DeleteAllItemData()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\cluster.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      Cluster.h
//
//  Abstract:
//      Definition of the CCluster class.
//
//  Author:
//      David Potter (davidp)   May 13, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSTER_H_
#define _CLUSTER_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_
#include "ClusItem.h"   // for CClusterItem
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"   // for CObjectProperty, CClusPropList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CCluster;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CResource;
class CNetworkList;

/////////////////////////////////////////////////////////////////////////////
// CCluster command target
/////////////////////////////////////////////////////////////////////////////

class CCluster : public CClusterItem
{
    DECLARE_DYNCREATE(CCluster)

    CCluster(void);         // protected constructor used by dynamic creation
    void            Init(
                        IN OUT CClusterDoc *    pdoc,
                        IN LPCTSTR              lpszName,
                        IN HCLUSTER             hOpenedCluster = NULL
                        );

// Attributes
protected:
    CLUSTERVERSIONINFO      m_cvi;
    CString                 m_strFQDN;
    CString                 m_strQuorumResource;
    CString                 m_strQuorumPath;
    DWORD                   m_nMaxQuorumLogSize;
    DWORD                   m_nDefaultNetworkRole;
    DWORD                   m_nQuorumArbitrationTimeMax;
    DWORD                   m_nQuorumArbitrationTimeMin;
    BOOL                    m_bEnableEventLogReplication;
    CStringList             m_lstrClusterExtensions;
    CStringList             m_lstrNodeExtensions;
    CStringList             m_lstrGroupExtensions;
    CStringList             m_lstrResourceExtensions;
    CStringList             m_lstrResTypeExtensions;
    CStringList             m_lstrNetworkExtensions;
    CStringList             m_lstrNetInterfaceExtensions;

    CNetworkList *          m_plpciNetworkPriority;

    enum
    {
        epropDefaultNetworkRole = 0,
        epropDescription,
        epropEnableEventLogReplication,
        epropQuorumArbitrationTimeMax,
        epropQuorumArbitrationTimeMin,
        epropMAX
    };

    CObjectProperty     m_rgProps[epropMAX];

public:
    virtual const CStringList * PlstrExtensions(void) const;
    const CLUSTERVERSIONINFO &  Cvi(void) const                 { return m_cvi; }

    const CString &         StrFQDN(void) const                 { return m_strFQDN; }
    const CString &         StrQuorumResource(void) const       { return m_strQuorumResource; }
    const CString &         StrQuorumPath(void) const           { return m_strQuorumPath; }
    DWORD                   NMaxQuorumLogSize(void) const       { return m_nMaxQuorumLogSize; }

    const CStringList &     LstrClusterExtensions(void) const   { return m_lstrClusterExtensions; }
    const CStringList &     LstrNodeExtensions(void) const      { return m_lstrNodeExtensions; }
    const CStringList &     LstrGroupExtensions(void) const     { return m_lstrGroupExtensions; }
    const CStringList &     LstrResourceExtensions(void) const  { return m_lstrResourceExtensions; }
    const CStringList &     LstrResTypeExtensions(void) const   { return m_lstrResTypeExtensions; }
    const CStringList &     LstrNetworkExtensions(void) const   { return m_lstrNetworkExtensions; }
    const CStringList &     LstrNetInterfaceExtensions(void) const  { return m_lstrNetInterfaceExtensions; }

    const CNetworkList &    LpciNetworkPriority(void) const     { ASSERT(m_plpciNetworkPriority != NULL); return *m_plpciNetworkPriority; }

// Operations
public:
    void                SetName(IN LPCTSTR pszName);
    void                SetDescription(IN LPCTSTR pszDesc);
    void                SetQuorumResource(
                            IN LPCTSTR  pszResource,
                            IN LPCTSTR  pszQuorumPath,
                            IN DWORD    nMaxLogSize
                            );
    void                SetNetworkPriority(IN const CNetworkList & rlpci);

    void                CollectNetworkPriority(IN OUT CNetworkList * plpci);

    void                ReadClusterInfo(void);
    void                ReadClusterExtensions(void);
    void                ReadNodeExtensions(void);
    void                ReadGroupExtensions(void);
    void                ReadResourceExtensions(void);
    void                ReadResTypeExtensions(void);
    void                ReadNetworkExtensions(void);
    void                ReadNetInterfaceExtensions(void);

// Overrides
    virtual void        Cleanup(void);
    virtual void        ReadItem(void);
    virtual void        UpdateState(void);
    virtual void        Rename(IN LPCTSTR pszName);
    virtual BOOL        BCanBeEdited(void) const    { return TRUE; }
    virtual void        OnBeginLabelEdit(IN OUT CEdit * pedit);
    virtual BOOL        BDisplayProperties(IN BOOL bReadOnly = FALSE);
    virtual BOOL        BIsLabelEditValueValid(IN LPCTSTR pszName);

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCluster)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CCluster(void);

protected:
    // Generated message map functions
    //{{AFX_MSG(CCluster)
    afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

};  //*** class CCluster

/////////////////////////////////////////////////////////////////////////////

#endif // _CLUSTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\dlghelps.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DlgHelpS.cpp
//
//	Abstract:
//		Stub for implementation of dialog help classes.
//
//	Author:
//		David Potter (davidp)	February 18, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DlgHelp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\colitem.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ColItem.h
//
//	Abstract:
//		Definition of the CColumnItem class.
//
//	Author:
//		David Potter (davidp)	May 7, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _COLITEM_H_
#define _COLITEM_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFXTEMPL_H__
#include "afxtempl.h"	// for CList
#endif

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define COLI_WIDTH_DEFAULT		75
#define COLI_WIDTH_NAME			125
#define COLI_WIDTH_DISPLAY_NAME	190
#define COLI_WIDTH_TYPE			75
#define COLI_WIDTH_STATE		100
#define COLI_WIDTH_DESCRIPTION	125
#define COLI_WIDTH_OWNER		COLI_WIDTH_NAME
#define COLI_WIDTH_GROUP		COLI_WIDTH_NAME
#define COLI_WIDTH_RESTYPE		100
#define COLI_WIDTH_RESDLL		100
#define COLI_WIDTH_NET_ROLE		100
#define COLI_WIDTH_NET_PRIORITY	75
#define COLI_WIDTH_NODE			75
#define COLI_WIDTH_NETWORK		100
#define COLI_WIDTH_NET_ADAPTER	75
#define COLI_WIDTH_NET_ADDRESS	75
#define COLI_WIDTH_NET_MASK		75

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CColumnItem;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef CList<CColumnItem *, CColumnItem *>	CColumnItemList;

/////////////////////////////////////////////////////////////////////////////
// CColumnItem

class CColumnItem : public CObject
{
	DECLARE_DYNCREATE(CColumnItem)
	CColumnItem(void);			// protected constructor used by dynamic creation
	CColumnItem(
		IN const CString &	rstrText,
		IN COLID			colid,
		IN int				nDefaultWidth = -1,
		IN int				nWidth = -1
		);

// Attributes
protected:
	CString			m_strText;
	COLID			m_colid;
	int				m_nDefaultWidth;
	int				m_nWidth;

public:
	CString &		StrText(void)				{ return m_strText; }
	COLID			Colid(void) const			{ return m_colid; }
	int				NDefaultWidth(void) const	{ return m_nDefaultWidth; }
	int				NWidth(void) const			{ return m_nWidth; }

	void			SetWidth(IN int nWidth)		{ m_nWidth = nWidth; }

// Operations
public:
	CColumnItem *	PcoliClone(void);

// Implementation
public:
	virtual ~CColumnItem(void);

protected:

};  //*** class CColumnItem

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

void DeleteAllItemData(IN OUT CColumnItemList & rlp);

/////////////////////////////////////////////////////////////////////////////

#endif // _COLITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\dataobj.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DataObj.cpp
//
//	Abstract:
//		Implementation of the CDataObject class, which is the IDataObject
//		class used to transfer data between CluAdmin and the extension DLL
//		handlers.
//
//	Author:
//		David Potter (davidp)	June 4, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <CluAdmEx.h>
#include "DataObj.h"
#include "ClusItem.h"
#include "ClusItem.inl"
#include "Res.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

// Object type map.
static IDS	g_rgidsObjectType[]	=
{
	NULL,
	IDS_ITEMTYPE_CLUSTER,
	IDS_ITEMTYPE_NODE,
	IDS_ITEMTYPE_GROUP,
	IDS_ITEMTYPE_RESOURCE,
	IDS_ITEMTYPE_RESTYPE,
	IDS_ITEMTYPE_NETWORK,
	IDS_ITEMTYPE_NETIFACE
};
#define RGIDS_OBJECT_TYPE_SIZE	sizeof(g_rgidsObjectType) / sizeof(IDS)

/////////////////////////////////////////////////////////////////////////////
// CDataObject
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CDataObject, CObject)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::CDataObject
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDataObject::CDataObject(void)
{
	m_pci = NULL;
	m_lcid = NULL;
	m_hfont = NULL;
	m_hicon = NULL;

	m_pfGetResNetName = NULL;

	m_pModuleState = AfxGetModuleState();
	ASSERT(m_pModuleState != NULL);

}  //*** CDataObject::CDataObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::~CDataObject
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDataObject::~CDataObject(void)
{
	m_pModuleState = NULL;

}  //*** CDataObject::~CDataObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::Init
//
//	Routine Description:
//		Second-phase constructor.
//
//	Arguments:
//		pci			[IN OUT] Cluster item for which a property sheet is being displayed.
//		lcid		[IN] Locale ID of resources to be loaded by extension.
//		hfont		[IN] Font to use for property page text.
//		hicon		[IN] Icon for upper left icon control.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDataObject::Init(
	IN OUT CClusterItem *	pci,
	IN LCID					lcid,
	IN HFONT				hfont,
	IN HICON				hicon
	)
{
	ASSERT_VALID(pci);

	// Save parameters.
	m_pci = pci;
	m_lcid = lcid;
	m_hfont = hfont;
	m_hicon = hicon;

}  //*** CDataObject::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::InterfaceSupportsErrorInfo [ISupportsErrorInfo]
//
//	Routine Description:
//		Determines whether the interface supports error info (???).
//
//	Arguments:
//		riid		[IN] Reference to the interface ID.
//
//	Return Value:
//		S_OK		Interface supports error info.
//		S_FALSE		Interface does not support error info.
//
//	Exceptions Thrown:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDataObject::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID * rgiid[] = 
	{
		&IID_IGetClusterDataInfo,
		&IID_IGetClusterObjectInfo,
		&IID_IGetClusterNodeInfo,
		&IID_IGetClusterGroupInfo,
		&IID_IGetClusterResourceInfo,
	};
	int		iiid;

	for (iiid = 0 ; iiid < sizeof(rgiid) / sizeof(rgiid[0]) ; iiid++)
	{
		if (InlineIsEqualGUID(*rgiid[iiid], riid))
			return S_OK;
	}
	return S_FALSE;

}  //*** CDataObject::InterfaceSupportsErrorInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::GetLocale [IGetClusterUIInfo]
//
//	Routine Description:
//		Get the locale ID for the extension to use.
//
//	Arguments:
//		None.
//
//	Return Value:
//		LCID
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(LCID) CDataObject::GetLocale(void)
{
	return Lcid();

}  //*** CDataObject::GetLocale()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::GetFont [IGetClusterUIInfo]
//
//	Routine Description:
//		Get the font to use for property pages and wizard pages.
//
//	Arguments:
//		None.
//
//	Return Value:
//		HFONT
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(HFONT) CDataObject::GetFont(void)
{
	return Hfont();

}  //*** CDataObject::GetFont()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::GetIcon [IGetClusterUIInfo]
//
//	Routine Description:
//		Get the icon to use in the upper left corner of property pages
//		and wizard pages.
//
//	Arguments:
//		None.
//
//	Return Value:
//		HICON
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(HICON) CDataObject::GetIcon(void)
{
	return Hicon();

}  //*** CDataObject::GetIcon()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::GetClusterName [IGetClusterDataInfo]
//
//	Routine Description:
//		Get the name of the cluster in which this object exists.
//
//	Arguments:
//		lpszName		[OUT] String in which to return the name.
//		pcchName		[IN OUT] Maximum length of lpszName buffer on
//							input.  Set to the total number of characters
//							upon return, including terminating null character.
//							If no lpszName buffer is not specified, the
//							status returned will be NOERROR.  If an lpszName
//							buffer is specified but it is too small, the
//							number of characters will be returned in pcchName
//							and an ERROR_MORE_DATA status will be returned.
//
//	Return Value:
//		NOERROR			Data (or size) copied successfully.
//		E_INVALIDARG	Invalid arguments specified.
//		ERROR_MORE_DATA	Buffer is too small.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDataObject::GetClusterName(
	OUT BSTR		lpszName,
	IN OUT LONG *	pcchName
	)
{
	LONG	cchName = 0;
	LPWSTR	pszReturn;

	AFX_MANAGE_STATE(m_pModuleState);
	ASSERT_VALID(Pci());
	ASSERT_VALID(Pci()->Pdoc());

	// Validate parameters.
	if (pcchName == NULL)
		return E_INVALIDARG;

	try
	{
		// Save the length to copy.
		cchName = *pcchName;
		*pcchName = Pci()->Pdoc()->StrName().GetLength() + 1;
	} // try
	catch (...)
	{
		return E_INVALIDARG;
	}  // catch:  anything

	// If only the length is being requested, return it now.
	if (lpszName == NULL)
		return NOERROR;

	// If a buffer is specified and it is too small, return an error.
	if (cchName < *pcchName)
		return ERROR_MORE_DATA;

	// Copy the data.
	pszReturn = lstrcpyW(lpszName, Pci()->Pdoc()->StrName());
	if (pszReturn == NULL)
		return E_INVALIDARG;

	return NOERROR;

}  //*** CDataObject::GetClusterName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::GetClusterHandle [IGetClusterDataInfo]
//
//	Routine Description:
//		Get the cluster handle for these objects.
//
//	Arguments:
//		None.
//
//	Return Value:
//		HCLUSTER
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(HCLUSTER) CDataObject::GetClusterHandle(void)
{
	AFX_MANAGE_STATE(m_pModuleState);
	ASSERT_VALID(Pci());
	return Pci()->Hcluster();

}  //*** CDataObject::GetClusterHandle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::GetObjectCount [IGetClusterDataInfo]
//
//	Routine Description:
//		Get the number of selected objects.
//
//	Arguments:
//		None.
//
//	Return Value:
//		cObj
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(LONG) CDataObject::GetObjectCount(void)
{
	// We only support one selected object at a time for now.
	return 1;

}  //*** CDataObject::GetObjectCount()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::GetObjectName [IGetClusterObjectInfo]
//
//	Routine Description:
//		Get the name of the specified object.
//
//	Arguments:
//		lObjIndex		[IN] Zero-based index of the object.
//		lpszName		[OUT] String in which to return the name.
//		pcchName		[IN OUT] Maximum length of lpszName buffer on
//							input.  Set to the total number of characters
//							upon return, including terminating null character.
//							If no lpszName buffer is not specified, the
//							status returned will be NOERROR.  If an lpszName
//							buffer is specified but it is too small, the
//							number of characters will be returned in pcchName
//							and an ERROR_MORE_DATA status will be returned.
//
//	Return Value:
//		NOERROR			Data (or size) copied successfully.
//		E_INVALIDARG	Invalid arguments specified.
//		ERROR_MORE_DATA	Buffer is too small.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDataObject::GetObjectName(
	IN LONG			lObjIndex,
	OUT BSTR		lpszName,
	IN OUT LONG *	pcchName
	)
{
	LONG	cchName = 0;
	LPWSTR	pszReturn;

	AFX_MANAGE_STATE(m_pModuleState);
	ASSERT_VALID(Pci());

	// Validate parameters.
	// We only support one selected object at a time for now.
	if ((lObjIndex != 0) || (pcchName == NULL))
		return E_INVALIDARG;

	// Save the length to copy.
	try
	{
		cchName = *pcchName;
		*pcchName = Pci()->StrName().GetLength() + 1;
	} // try
	catch (...)
	{
		return E_INVALIDARG;
	}  // catch:  anything

	// If only the length is being requested, return it now.
	if (lpszName == NULL)
		return NOERROR;

	// If a buffer is specified and it is too small, return an error.
	if (cchName < *pcchName)
		return ERROR_MORE_DATA;

	// Copy the data.
	pszReturn = lstrcpyW(lpszName, Pci()->StrName());
	if (pszReturn == NULL)
		return E_INVALIDARG;

	return NOERROR;

}  //*** CDataObject::GetObjectName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::GetObjectType [IGetClusterObjectInfo]
//
//	Routine Description:
//		Get the cluster database registry key for the specified object.
//
//	Arguments:
//		lObjIndex	[IN] Zero-based index of the object.
//
//	Return Value:
//		-1			Invalid argument.  Call GetLastError for more information.
//		CLUADMEX_OBJECT_TYPE
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(CLUADMEX_OBJECT_TYPE) CDataObject::GetObjectType(
	IN LONG		lObjIndex
	)
{
	int			iids;

	AFX_MANAGE_STATE(m_pModuleState);
	ASSERT_VALID(Pci());

	// Validate parameters.
	// We only support one selected object at a time for now.
	if (lObjIndex != 0)
	{
		SetLastError((DWORD) E_INVALIDARG);
		return (CLUADMEX_OBJECT_TYPE) -1;
	}  // if:  invalid argument

	// Get the object type.
	for (iids = 0 ; iids < RGIDS_OBJECT_TYPE_SIZE ; iids++)
	{
		if (g_rgidsObjectType[iids] == Pci()->IdsType())
			return (CLUADMEX_OBJECT_TYPE) iids;
	}  // for:  each entry in the table

	return CLUADMEX_OT_NONE;

}  //*** CDataObject::GetObjectType()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::GetNodeHandle [IGetClusterNodeInfo]
//
//	Routine Description:
//		Get the handle for the specified node.
//
//	Arguments:
//		lObjIndex		[IN] Zero-based index of the object.
//
//	Return Value:
//		HNODE
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(HNODE) CDataObject::GetNodeHandle(
	IN LONG		lObjIndex
	)
{
	CClusterNode *	pciNode = (CClusterNode *) Pci();

	AFX_MANAGE_STATE(m_pModuleState);
	ASSERT_VALID(Pci());

	// Validate parameters.
	// We only support one selected object at a time for now.
	if ((lObjIndex != 0)
			|| (Pci()->IdsType() != IDS_ITEMTYPE_NODE))
	{
		SetLastError((DWORD) E_INVALIDARG);
		return NULL;
	}  // if:  invalid argument

	ASSERT_KINDOF(CClusterNode, pciNode);

	return pciNode->Hnode();

}  //*** CDataObject::GetNodeHandle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::GetGroupHandle [IGetClusterGroupInfo]
//
//	Routine Description:
//		Get the handle for the specified group.
//
//	Arguments:
//		lObjIndex		[IN] Zero-based index of the object.
//
//	Return Value:
//		HGROUP
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(HGROUP) CDataObject::GetGroupHandle(
	IN LONG		lObjIndex
	)
{
	CGroup *	pciGroup = (CGroup *) Pci();

	AFX_MANAGE_STATE(m_pModuleState);
	ASSERT_VALID(Pci());

	// Validate parameters.
	// We only support one selected object at a time for now.
	if ((lObjIndex != 0)
			|| (Pci()->IdsType() != IDS_ITEMTYPE_GROUP))
	{
		SetLastError((DWORD) E_INVALIDARG);
		return NULL;
	}  // if:  invalid argument

	ASSERT_KINDOF(CGroup, pciGroup);

	return pciGroup->Hgroup();

}  //*** CDataObject::GetGroupHandle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::GetResourceHandle [IGetClusterResourceInfo]
//
//	Routine Description:
//		Get the handle for the specified resource.
//
//	Arguments:
//		lObjIndex		[IN] Zero-based index of the object.
//
//	Return Value:
//		HRESOURCE
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(HRESOURCE) CDataObject::GetResourceHandle(
	IN LONG		lObjIndex
	)
{
	CResource *	pciRes = (CResource *) Pci();

	AFX_MANAGE_STATE(m_pModuleState);
	ASSERT_VALID(Pci());

	// Validate parameters.
	// We only support one selected object at a time for now.
	if ((lObjIndex != 0)
			|| (Pci()->IdsType() != IDS_ITEMTYPE_RESOURCE))
	{
		SetLastError((DWORD) E_INVALIDARG);
		return NULL;
	}  // if:  invalid argument

	ASSERT_KINDOF(CResource, pciRes);

	return pciRes->Hresource();

}  //*** CDataObject::GetResourceHandle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::GetResourceTypeName [IGetClusterResourceInfo]
//
//	Routine Description:
//		Returns the name of the resource type of the specified resource.
//
//	Arguments:
//		lObjIndex		[IN] Zero-based index of the object.
//		lpszResTypeName	[OUT] String in which to return the resource type name.
//		pcchResTypeName	[IN OUT] Maximum length of lpszResTypeName buffer on
//							input.  Set to the total number of characters
//							upon return, including terminating null character.
//							If no lpszResTypeName buffer is not specified, the
//							status returned will be NOERROR.  If an lpszResTypeName
//							buffer is specified but it is too small, the
//							number of characters will be returned in pcchResTypeName
//							and an ERROR_MORE_DATA status will be returned.
//
//	Return Value:
//		NOERROR			Data (or size) copied successfully.
//		E_INVALIDARG	Invalid arguments specified.
//		ERROR_MORE_DATA	Buffer is too small.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CDataObject::GetResourceTypeName(
	IN LONG			lObjIndex,
	OUT BSTR		lpszResTypeName,
	IN OUT LONG *	pcchResTypeName
	)
{
	LONG			cchResTypeName = 0;
	CResource *		pciRes = (CResource *) Pci();
	CString const *	pstrResourceTypeName;
	LPWSTR			pszReturn;

	AFX_MANAGE_STATE(m_pModuleState);
	ASSERT_VALID(Pci());

	// Validate parameters.
	// We only support one selected object at a time for now.
	if ((lObjIndex != 0)
			|| (pcchResTypeName == NULL)
			|| (Pci()->IdsType() != IDS_ITEMTYPE_RESOURCE))
	{
		return E_INVALIDARG;
	}  // if:  invalid argument

	ASSERT_KINDOF(CResource, pciRes);

	// Get a pointer to the name to copy.
	if (pciRes->PciResourceType() != NULL)
	{
		ASSERT_VALID(pciRes->PciResourceType());
		pstrResourceTypeName = &pciRes->PciResourceType()->StrName();
	}  // if:  valid resource type pointer
	else
		pstrResourceTypeName = &pciRes->StrResourceType();

	// Save the length to copy.
	try
	{
		cchResTypeName = *pcchResTypeName;
		*pcchResTypeName = pstrResourceTypeName->GetLength() + 1;
	} // try
	catch (...)
	{
		return E_INVALIDARG;
	}  // catch:  anything

	// If only the length is being requested, return it now.
	if (lpszResTypeName == NULL)
		return NOERROR;

	// If a buffer is specified and it is too small, return an error.
	if (cchResTypeName < *pcchResTypeName)
		return ERROR_MORE_DATA;

	// Copy the data.
	pszReturn = lstrcpyW(lpszResTypeName, *pstrResourceTypeName);
	if (pszReturn == NULL)
		return E_INVALIDARG;

	return NOERROR;

}  //*** CDataObject::GetResourceTypeName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::GetResourceNetworkName [IGetClusterResourceInfo]
//
//	Routine Description:
//		Returns the name of the network name of the first Network Name
//		resource on which the specified resource depends.
//
//	Arguments:
//		lObjIndex		[IN] Zero-based index of the object.
//		lpszNetName		[OUT] String in which to return the network name.
//		pcchNetName		[IN OUT] Points to a variable that specifies the
//							maximum size, in characters, of the buffer.  This
//							value should be large enough to contain
//							MAX_COMPUTERNAME_LENGTH + 1 characters.  Upon
//							return it contains the actual number of characters
//							copied.
//
//	Return Value:
//		TRUE			Data (or size) copied successfully.
//		FALSE			Error getting information.  GetLastError() returns:
//							E_INVALIDARG	Invalid arguments specified.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(BOOL) CDataObject::GetResourceNetworkName(
	IN LONG			lObjIndex,
	OUT BSTR		lpszNetName,
	IN OUT ULONG *	pcchNetName
	)
{
	BOOL			bSuccess = FALSE;
	CResource *		pciRes = (CResource *) Pci();

	AFX_MANAGE_STATE(m_pModuleState);
	ASSERT_VALID(Pci());

	try
	{
		// Validate parameters.
		// We only support one selected object at a time for now.
		if ((lObjIndex != 0)
				|| (pcchNetName == NULL)
				|| (*pcchNetName < MAX_COMPUTERNAME_LENGTH)
				|| (Pci()->IdsType() != IDS_ITEMTYPE_RESOURCE))
		{
			SetLastError((DWORD) E_INVALIDARG);
			return FALSE;
		}  // if:  invalid argument

		ASSERT_KINDOF(CResource, pciRes);

		// If there is a function for getting this information, call it.
		// Otherwise, handle it ourselves.
		if (PfGetResNetName() != NULL)
			bSuccess = (*PfGetResNetName())(lpszNetName, pcchNetName, m_pvGetResNetNameContext);
		else
			bSuccess = pciRes->BGetNetworkName(lpszNetName, pcchNetName);
	} // try
	catch (...)
	{
		bSuccess = FALSE;
		SetLastError((DWORD) E_INVALIDARG);
	}  // catch:  anything

	return bSuccess;

}  //*** CDataObject::GetResourceNetworkName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::GetNetworkHandle [IGetClusterNetworkInfo]
//
//	Routine Description:
//		Get the handle for the specified network.
//
//	Arguments:
//		lObjIndex		[IN] Zero-based index of the object.
//
//	Return Value:
//		HNETWORK
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(HNETWORK) CDataObject::GetNetworkHandle(
	IN LONG		lObjIndex
	)
{
	CNetwork *	pciNetwork = (CNetwork *) Pci();

	AFX_MANAGE_STATE(m_pModuleState);
	ASSERT_VALID(Pci());

	// Validate parameters.
	// We only support one selected object at a time for now.
	if ((lObjIndex != 0)
			|| (Pci()->IdsType() != IDS_ITEMTYPE_NETWORK))
	{
		SetLastError((DWORD) E_INVALIDARG);
		return NULL;
	}  // if:  invalid argument

	ASSERT_KINDOF(CNetwork, pciNetwork);

	return pciNetwork->Hnetwork();

}  //*** CDataObject::GetNetworkHandle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CDataObject::GetNetInterfaceHandle [IGetClusterNetInterfaceInfo]
//
//	Routine Description:
//		Get the handle for the specified network interface.
//
//	Arguments:
//		lObjIndex		[IN] Zero-based index of the object.
//
//	Return Value:
//		HNETINTERFACE
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(HNETINTERFACE) CDataObject::GetNetInterfaceHandle(
	IN LONG		lObjIndex
	)
{
	CNetInterface *	pciNetIFace = (CNetInterface *) Pci();

	AFX_MANAGE_STATE(m_pModuleState);
	ASSERT_VALID(Pci());

	// Validate parameters.
	// We only support one selected object at a time for now.
	if ((lObjIndex != 0)
			|| (Pci()->IdsType() != IDS_ITEMTYPE_NETIFACE))
	{
		SetLastError((DWORD) E_INVALIDARG);
		return NULL;
	}  // if:  invalid argument

	ASSERT_KINDOF(CNetwork, pciNetIFace);

	return pciNetIFace->Hnetiface();

}  //*** CDataObject::GetNetInterfaceHandle()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\excopers.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ExcOperS.cpp
//
//	Abstract:
//		Stub for implementation of exception classes.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ExcOper.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\delres.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      DelRes.cpp
//
//  Abstract:
//      Implementation of the CDeleteResourcesDlg class.
//
//  Author:
//      David Potter (davidp)   August 7, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "DelRes.h"
#include "Res.h"
#include "HelpData.h"   // for g_rghelpmapDeleteResource

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDeleteResourcesDlg class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CDeleteResourcesDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CDeleteResourcesDlg)
    ON_NOTIFY(NM_DBLCLK, IDC_DR_RESOURCES_LIST, OnDblClkResourcesList)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_DR_RESOURCES_LIST, OnColumnClick)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
    ON_BN_CLICKED(IDYES, CBaseDialog::OnOK)
    ON_BN_CLICKED(IDNO, CBaseDialog::OnCancel)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDeleteResourcesDlg::CDeleteResourcesDlg
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pciRes      [IN] Resource being deleted.
//      plpci       [IN] List of resources which are dependent on pciRes.
//      pParent     [IN OUT] Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDeleteResourcesDlg::CDeleteResourcesDlg(
    IN CResource *              pciRes,
    IN const CResourceList *    plpci,
    IN OUT CWnd *               pParent /*=NULL*/
    )
    : CBaseDialog(IDD, g_aHelpIDs_IDD_DELETE_RESOURCES, pParent)
{
    //{{AFX_DATA_INIT(CDeleteResourcesDlg)
    //}}AFX_DATA_INIT

    ASSERT_VALID(pciRes);
    ASSERT(plpci != NULL);

    m_pciRes = pciRes;
    m_plpci = plpci;

}  //*** CDeleteResourcesDlg::CDeleteResourcesDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDeleteResourcesDlg::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDeleteResourcesDlg::DoDataExchange(CDataExchange * pDX)
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDeleteResourcesDlg)
    DDX_Control(pDX, IDC_DR_RESOURCES_LIST, m_lcResources);
    //}}AFX_DATA_MAP

}  //*** CDeleteResourcesDlg::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDeleteResourcesDlg::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CDeleteResourcesDlg::OnInitDialog(void)
{
    int     nitem;

    CBaseDialog::OnInitDialog();

    // Change list view control extended styles.
    {
        DWORD   dwExtendedStyle;

        dwExtendedStyle = (DWORD)m_lcResources.SendMessage(LVM_GETEXTENDEDLISTVIEWSTYLE);
        m_lcResources.SendMessage(
            LVM_SETEXTENDEDLISTVIEWSTYLE,
            0,
            dwExtendedStyle
                | LVS_EX_FULLROWSELECT
                | LVS_EX_HEADERDRAGDROP
            );
    }  // Change list view control extended styles

    // Set the image list for the list control to use.
    m_lcResources.SetImageList(GetClusterAdminApp()->PilSmallImages(), LVSIL_SMALL);

    // Add the columns.
    {
        CString         strColumn;
        try
        {
            strColumn.LoadString(IDS_COLTEXT_NAME);
            m_lcResources.InsertColumn(0, strColumn, LVCFMT_LEFT, COLI_WIDTH_NAME * 3 / 2);
            strColumn.LoadString(IDS_COLTEXT_RESTYPE);
            m_lcResources.InsertColumn(1, strColumn, LVCFMT_LEFT, COLI_WIDTH_RESTYPE * 3 / 2);
        }  // try
        catch (CException * pe)
        {
            pe->Delete();
        }  // catch:  CException
    }  // Add the columns

    // Add the resource being deleted to the list.
    nitem = m_lcResources.InsertItem(0, PciRes()->StrName(), PciRes()->IimgObjectType());
    m_lcResources.SetItemText(nitem, 1, PciRes()->StrRealResourceTypeDisplayName());
    m_lcResources.SetItemData(nitem, (DWORD_PTR) PciRes());
    m_pciRes->AddRef();

    // Add the items.
    {
        POSITION        pos;
        int             iitem;
        CResource *     pciRes;

        pos = Plpci()->GetHeadPosition();
        for (iitem = 1 ; pos != NULL ; iitem++)
        {
            pciRes = (CResource *) Plpci()->GetNext(pos);
            ASSERT_VALID(pciRes);
            if (pciRes != PciRes())
            {
                nitem = m_lcResources.InsertItem(iitem, pciRes->StrName(), pciRes->IimgObjectType());
                m_lcResources.SetItemText(nitem, 1, pciRes->StrRealResourceTypeDisplayName());
                m_lcResources.SetItemData(nitem, (DWORD_PTR) pciRes);
                pciRes->AddRef();
            }  // if:  not resource being deleted
        }  // while:  more items in the list
    }  // Add the items

    // Sort the items.
    m_nSortColumn = 0;
    m_nSortDirection = 0;
    m_lcResources.SortItems(CompareItems, (LPARAM) this);

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CDeleteResourcesDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDeleteResourcesDlg::OnDestroy
//
//  Routine Description:
//      Handler method for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDeleteResourcesDlg::OnDestroy(void)
{
    // Dereference all the cluster item pointers.
    if (m_lcResources.m_hWnd != NULL)
    {
        int             ili = -1;
        CClusterItem *  pci;

        while ((ili = m_lcResources.GetNextItem(ili, LVNI_ALL)) != -1)
        {
            pci = (CClusterItem *) m_lcResources.GetItemData(ili);
            ASSERT_VALID(pci);
            ASSERT_KINDOF(CClusterItem, pci);

            pci->Release();
        }  // while:  more items in the list control
    }  // if:  list control has been instantiated

    CBaseDialog::OnDestroy();

}  //*** CDeleteResourcesDlg::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDeleteResourcesDlg::OnDblClkDependsList
//
//  Routine Description:
//      Handler method for the NM_DBLCLK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDeleteResourcesDlg::OnDblClkResourcesList(NMHDR * pNMHDR, LRESULT * pResult)
{
    int             iitem;
    CResource *     pciRes;

    // Get the item with the focus.
    iitem = m_lcResources.GetNextItem(-1, LVNI_FOCUSED);
    ASSERT(iitem != -1);

    if (iitem != -1)
    {
        // Get the resource pointer.
        pciRes = (CResource *) m_lcResources.GetItemData(iitem);
        ASSERT_VALID(pciRes);

        // Get properties of that item.
        pciRes->BDisplayProperties(FALSE /*bReadOnly*/);
    }  // if:  found an item with focus

    *pResult = 0;

}  //*** CDeleteResourcesDlg::OnDblClkResourcesList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDeleteResourcesDlg::OnColumnClick
//
//  Routine Description:
//      Handler method for the LVN_COLUMNCLICK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CDeleteResourcesDlg::OnColumnClick(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW * pNMListView = (NM_LISTVIEW *) pNMHDR;

    if (m_lcResources.GetItemCount() != 0)
    {
        // Save the current sort column and direction.
        if (pNMListView->iSubItem == m_nSortColumn)
            m_nSortDirection ^= -1;
        else
        {
            m_nSortColumn = pNMListView->iSubItem;
            m_nSortDirection = 0;
        }  // else:  different column

        // Sort the list.
        m_lcResources.SortItems(CompareItems, (LPARAM) this);
    }  // if:  there are items in the list

    *pResult = 0;

}  //*** CDeleteResourcesDlg::OnColumnClick()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CDeleteResourcesDlg::CompareItems [static]
//
//  Routine Description:
//      Callback function for the CListCtrl::SortItems method.
//
//  Arguments:
//      lparam1     First item to compare.
//      lparam2     Second item to compare.
//      lparamSort  Sort parameter.
//
//  Return Value:
//      -1          First parameter comes before second.
//      0           First and second parameters are the same.
//      1           First parameter comes after second.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CALLBACK CDeleteResourcesDlg::CompareItems(
    LPARAM  lparam1,
    LPARAM  lparam2,
    LPARAM  lparamSort
    )
{
    CResource *         pciRes1 = (CResource *) lparam1;
    CResource *         pciRes2 = (CResource *) lparam2;
    CDeleteResourcesDlg *   pdlg    = (CDeleteResourcesDlg *) lparamSort;
    const CString *     pstr1;
    const CString *     pstr2;
    int                 nResult;

    ASSERT_VALID(pciRes1);
    ASSERT_VALID(pciRes2);
    ASSERT_VALID(pdlg);

    // Get the strings from the list items.
    if (pdlg->m_nSortColumn == 1)
    {
        pstr1 = &pciRes1->StrRealResourceTypeDisplayName();
        pstr2 = &pciRes2->StrRealResourceTypeDisplayName();
    }  //  if:  sorting on name column
    else
    {
        pstr1 = &pciRes1->StrName();
        pstr2 = &pciRes2->StrName();
    }  // else:  sorting on resource type column

    // Compare the two strings.
    // Use CompareString() so that it will sort properly on localized builds.
    nResult = CompareString(
                LOCALE_USER_DEFAULT,
                0,
                *pstr1,
                pstr1->GetLength(),
                *pstr2,
                pstr2->GetLength()
                );
    if ( nResult == CSTR_LESS_THAN )
    {
        nResult = -1;
    }
    else if ( nResult == CSTR_EQUAL )
    {
        nResult = 0;
    }
    else if ( nResult == CSTR_GREATER_THAN )
    {
        nResult = 1;
    }
    else
    {
        // An error occurred.  Ignore it.
        nResult = 0;
    }

    // Return the result based on the direction we are sorting.
    if (pdlg->m_nSortDirection != 0)
        nResult = -nResult;

    return nResult;

}  //*** CDeleteResourcesDlg::CompareItems()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\delres.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		DelRes.cpp
//
//	Abstract:
//		Definition of the CDeleteResourcesDlg dialog.
//
//	Implementation File:
//		DelRes.h
//
//	Author:
//		David Potter (davidp)	August 7, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DELRES_H_
#define _DELRES_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESOURCE_H_
#include "resource.h"
#define _RESOURCE_H_
#endif

#ifndef _BASEDLG_H_
#include "BaseDlg.h"	// for CBaseDialog
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDeleteResourcesDlg;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CResource;
class CResourceList;

/////////////////////////////////////////////////////////////////////////////
// CDeleteResourcesDlg class
/////////////////////////////////////////////////////////////////////////////

class CDeleteResourcesDlg : public CBaseDialog
{
// Construction
public:
	CDeleteResourcesDlg(
		IN CResource *				pciRes,
		IN const CResourceList *	plpci,
		IN OUT CWnd *				pParent = NULL
		);

// Dialog Data
	//{{AFX_DATA(CDeleteResourcesDlg)
	enum { IDD = IDD_DELETE_RESOURCES };
	CListCtrl	m_lcResources;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDeleteResourcesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CResource *				m_pciRes;
	const CResourceList *	m_plpci;
	int						m_nSortDirection;
	int						m_nSortColumn;

	const CResource *		PciRes(void) const		{ return m_pciRes; }
	const CResourceList *	Plpci(void) const		{ return m_plpci; }

	static int CALLBACK		CompareItems(LPARAM lparam1, LPARAM lparam2, LPARAM lparamSort);

	// Generated message map functions
	//{{AFX_MSG(CDeleteResourcesDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnDblClkResourcesList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CDeleteResourcesDlg

/////////////////////////////////////////////////////////////////////////////

#endif // _DELRES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\dataobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		DataObj.h
//
//	Abstract:
//		Definition of the CDataObject class, which is the IDataObject
//		class used to transfer data between CluAdmin and the extension DLL
//		handlers.
//
//	Author:
//		David Potter (davidp)	June 4, 1996
//
//	Implementation File:
//		DataObj.cpp
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DATAOBJ_H_
#define _DATAOBJ_H_

/////////////////////////////////////////////////////////////////////////////
//	Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include "CluAdmEx.h"
#endif

#ifndef __cluadmid_h__
#include "CluAdmID.h"
#endif

#ifndef _RESOURCE_H_
#include "resource.h"
#define _RESOURCE_H_
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Declarations
/////////////////////////////////////////////////////////////////////////////

typedef BOOL (*PFGETRESOURCENETWORKNAME)(
					OUT BSTR lpszNetName,
					IN OUT DWORD * pcchNetName,
					IN OUT PVOID pvContext
					);

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CDataObject;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterItem;

/////////////////////////////////////////////////////////////////////////////
//
//	class CDataObject
//
//	Purpose:
//		Encapsulates the IDataObject interface for exchanging data with
//		extension DLL handlers.
//
/////////////////////////////////////////////////////////////////////////////
class CDataObject :
	public CObject,
	public IGetClusterUIInfo,
	public IGetClusterDataInfo,
	public IGetClusterObjectInfo,
	public IGetClusterNodeInfo,
	public IGetClusterGroupInfo,
	public IGetClusterResourceInfo,
	public IGetClusterNetworkInfo,
	public IGetClusterNetInterfaceInfo,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CDataObject, &CLSID_CoCluAdminData>
{
	DECLARE_DYNAMIC(CDataObject)

public:
	// Constructors
	CDataObject(void);			// protected constructor used by dynamic creation
	virtual ~CDataObject(void);

	// Second-phase constructor.
	void				Init(
							IN OUT CClusterItem *	pci,
							IN LCID					lcid,
							IN HFONT				hfont,
							IN HICON				hicon
							);

BEGIN_COM_MAP(CDataObject)
	COM_INTERFACE_ENTRY(IGetClusterUIInfo)
	COM_INTERFACE_ENTRY(IGetClusterDataInfo)
	COM_INTERFACE_ENTRY(IGetClusterObjectInfo)
	COM_INTERFACE_ENTRY(IGetClusterNodeInfo)
	COM_INTERFACE_ENTRY(IGetClusterGroupInfo)
	COM_INTERFACE_ENTRY(IGetClusterResourceInfo)
	COM_INTERFACE_ENTRY(IGetClusterNetworkInfo)
	COM_INTERFACE_ENTRY(IGetClusterNetInterfaceInfo)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CDataObject) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CDataObject, _T("CLUADMIN.Data"), _T("CLUADMIN.Data"), IDS_CLUADMIN_DESC, THREADFLAGS_BOTH)

// Attributes
protected:
	CClusterItem *		m_pci;			// Cluster item for which a prop sheet is being displayed.
	LCID				m_lcid;			// Locale ID of resources to be loaded by extension.
	HFONT				m_hfont;		// Font for all text.
	HICON				m_hicon;		// Icon for upper left corner.

	PFGETRESOURCENETWORKNAME	m_pfGetResNetName;	// Pointer to static function for getting net name for resource.
	PVOID				m_pvGetResNetNameContext;	// Context for m_pfGetResNetName;

	CClusterItem *		Pci(void)			{ return m_pci; }
	LCID				Lcid(void)			{ return m_lcid; }
	HFONT				Hfont(void)			{ return m_hfont; }
	HICON				Hicon(void)			{ return m_hicon; }

public:
	PFGETRESOURCENETWORKNAME	PfGetResNetName(void) const	{ return m_pfGetResNetName; }
	void				SetPfGetResNetName(PFGETRESOURCENETWORKNAME pfGetResNetName, PVOID pvContext)
	{
		m_pfGetResNetName = pfGetResNetName;
		m_pvGetResNetNameContext = pvContext;
	}

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDataObject)
	//}}AFX_VIRTUAL

// ISupportsErrorInfo
public:
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IGetClusterUIInfo
public:
	STDMETHOD_(LCID, GetLocale)(void);
	STDMETHOD_(HFONT, GetFont)(void);
	STDMETHOD_(HICON, GetIcon)(void);

// IGetClusterDataInfo
public:
	STDMETHOD(GetClusterName)(
		OUT BSTR				lpszName,
		IN OUT LONG *			plMaxLength
		);
	STDMETHOD_(HCLUSTER, GetClusterHandle)(void);
	STDMETHOD_(LONG, GetObjectCount)(void);

// IGetClusterObjectInfo
public:
	STDMETHOD(GetObjectName)(
		IN LONG					lObjIndex,
		OUT BSTR				lpszName,
		IN OUT LONG *			plMaxLength
		);
	STDMETHOD_(CLUADMEX_OBJECT_TYPE, GetObjectType)(
		IN LONG					lObjIndex
		);

// IGetClusterNodeInfo
public:
	STDMETHOD_(HNODE, GetNodeHandle)(
		IN LONG					lObjIndex
		);

// IGetClusterGroupInfo
public:
	STDMETHOD_(HGROUP, GetGroupHandle)(
		IN LONG					lObjIndex
		);

// IGetClusterResourceInfo
public:
	STDMETHOD_(HRESOURCE, GetResourceHandle)(
		IN LONG					lObjIndex
		);
	STDMETHOD(GetResourceTypeName)(
		IN LONG					lObjIndex,
		OUT BSTR				lpszResourceTypeName,
		IN OUT LONG *			pcchName
		);
	STDMETHOD_(BOOL, GetResourceNetworkName)(
		IN LONG					lobjIndex,
		OUT BSTR				lpszNetName,
		IN OUT ULONG *			pcchNetName
		);

// IGetClusterNetworkInfo
public:
	STDMETHOD_(HNETWORK, GetNetworkHandle)(
		IN LONG					lObjIndex
		);

// IGetClusterNetInterfaceInfo
public:
	STDMETHOD_(HNETINTERFACE, GetNetInterfaceHandle)(
		IN LONG					lObjIndex
		);

// Implementation
protected:
	AFX_MODULE_STATE *			m_pModuleState;			// Required for resetting our state during callbacks.

};  //*** class CDataObject

/////////////////////////////////////////////////////////////////////////////

#endif // _DATAOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\constdef.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ConstDef.h
//
//	Abstract:
//		Definitions of constants used in the Cluster Administrator program.
//
//	Author:
//		David Potter (davidp)	December 23, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CONSTDEF_H_
#define _CONSTDEF_H_

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

// Service Names

// Resource Names
#define RESNAME_NETWORK_NAME			_T("Network Name")

// Property Names
#define REGPARAM_CONNECTIONS			_T("Connections")
#define REGPARAM_COLUMNS				_T("Columns")
#define REGPARAM_SELECTION				_T("Selection")
#define REGPARAM_SETTINGS				_T("Settings")
#define REGPARAM_WINDOW_POS				_T("WindowPos")
#define REGPARAM_SPLITTER_BAR_POS		_T("SplitterBarPos")
#define REGPARAM_WINDOW_COUNT			_T("WindowCount")
#define REGPARAM_SHOW_TOOL_BAR			_T("ShowToolBar")
#define REGPARAM_SHOW_STATUS_BAR		_T("ShowStatusBar")
#define REGPARAM_EXPANDED				_T("Expanded")
#define REGPARAM_VIEW					_T("View")

#define REGPARAM_PARAMETERS				_T("Parameters")

#define REGPARAM_NAME					_T("Name")

/////////////////////////////////////////////////////////////////////////////
// User Window Messages
/////////////////////////////////////////////////////////////////////////////

#define WM_CAM_RESTORE_DESKTOP		(WM_USER + 1)
#define WM_CAM_CLUSTER_NOTIFY		(WM_USER + 2)
#define WM_CAM_UNLOAD_EXTENSION		(WM_USER + 3)

/////////////////////////////////////////////////////////////////////////////

#endif // _CONSTDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\editacl.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      EditAcl.cpp
//
//  Abstract:
//      Implementation of ACL editor methods.
//
//  Author:
//      David Potter (davidp)   October 9, 1996
//          From \nt\private\window\shell\lmui\ntshrui\acl.cxx
//          by BruceFo
//
//  Revision History:
//      Rodsh   04-Apr-1997 Modified to handle deletion of Registry SD. 
//      Rodsh   09-Apr-1997 Modified to ensure that at least one user 
//                              is granted access to cluster. 
//      Rodsh   29-Apr-1997 Modified to prevent the selection of local accounts 
//                              in the permissions of dialog
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <lmerr.h>

extern "C"
{
#include <sedapi.h>
}

#include "EditAcl.h"
#include "AclHelp.h"
#include "TraceTag.h"
#include "ExcOper.h"

#include "resource.h"
#define _RESOURCE_H_

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////
// Global Variables
//////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag g_tagEditClusterAcl(_T("ACL"), _T("Cluster ACL Editor"), 0);
#endif

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

#define ARRAYLEN(a) (sizeof(a) / sizeof((a)[0]))


enum MAP_DIRECTION 
{
    SPECIFIC_TO_GENERIC = 0,
    GENERIC_TO_SPECIFIC = 1
};

const DWORD CLUSTER_INACCESSIBLE    = 1L;
const DWORD LOCAL_ACCOUNTS_FILTERED = 2L;

BOOL MapBitsInSD(PSECURITY_DESCRIPTOR pSecDesc, MAP_DIRECTION direction);
BOOL MapBitsInACL(PACL paclACL, MAP_DIRECTION direction);
BOOL MapSpecificBitsInAce(PACCESS_ALLOWED_ACE pAce);
BOOL MapGenericBitsInAce(PACCESS_ALLOWED_ACE pAce);

typedef
DWORD
(*SedDiscretionaryAclEditorType)(
        HWND                         Owner,
        HANDLE                       Instance,
        LPWSTR                       Server,
        PSED_OBJECT_TYPE_DESCRIPTOR  ObjectType,
        PSED_APPLICATION_ACCESSES    ApplicationAccesses,
        LPWSTR                       ObjectName,
        PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
        ULONG                        CallbackContext,
        PSECURITY_DESCRIPTOR         SecurityDescriptor,
        BOOLEAN                      CouldntReadDacl,
        BOOLEAN                      CantWriteDacl,
        LPDWORD                      SEDStatusReturn,
        DWORD                        Flags
        );

// NOTE: the SedDiscretionaryAclEditor string is used in GetProcAddress to
// get the correct entrypoint. Since GetProcAddress is not UNICODE, this string
// must be ANSI.
#define ACLEDIT_DLL_STRING                 TEXT("acledit.dll")
#define ACLEDIT_HELPFILENAME               TEXT("ntshrui.hlp")
#define SEDDISCRETIONARYACLEDITOR_STRING   ("SedDiscretionaryAclEditor")

//
// Declare the callback routine based on typedef in sedapi.h.
//

DWORD
SedCallback(
    HWND                    hwndParent,
    HANDLE                  hInstance,
    ULONG                   ulCallbackContext,
    PSECURITY_DESCRIPTOR    pSecDesc,
    PSECURITY_DESCRIPTOR    pSecDescNewObjects,
    BOOLEAN                 fApplyToSubContainers,
    BOOLEAN                 fApplyToSubObjects,
    LPDWORD                 StatusReturn
    );

//
// Structure for callback function's usage. A pointer to this is passed as
// ulCallbackContext. The callback functions sets bSecDescModified to TRUE
// and makes a copy of the security descriptor. The caller of EditClusterAcl
// is responsible for deleting the memory in pSecDesc if bSecDescModified is
// TRUE. This flag will be FALSE if the user hit CANCEL in the ACL editor.
//
struct CLUSTER_ACL_CALLBACK_INFO
{
    BOOL                    bSecDescModified;
    PSECURITY_DESCRIPTOR    pSecDesc;
    LPCTSTR                 pszClusterNameNode;
};

//
// Local function prototypes
//

VOID
InitializeClusterGenericMapping(
    IN OUT PGENERIC_MAPPING pClusterGenericMapping
    );

DWORD 
MakeEmptySecDesc(
    OUT PSECURITY_DESCRIPTOR * ppSecDesc 
    );

PWSTR
GetResourceString(
    IN DWORD dwId
    );

PWSTR
NewDup(
    IN const WCHAR* psz
    );

//
// The following two arrays define the permission names for NT Files.  Note
// that each index in one array corresponds to the index in the other array.
// The second array will be modifed to contain a string pointer pointing to
// a loaded string corresponding to the IDS_* in the first array.
//
DWORD g_dwClusterPermNames[] =
{
    IDS_ACLEDIT_PERM_GEN_NO_ACCESS,
    IDS_ACLEDIT_PERM_GEN_ALL
} ;


SED_APPLICATION_ACCESS g_SedAppAccessClusterPerms[] =
{
  { SED_DESC_TYPE_RESOURCE, GENERIC_EXECUTE,0, NULL },
  { SED_DESC_TYPE_RESOURCE, GENERIC_ALL,    0, NULL }
};



//+-------------------------------------------------------------------------
//
//  Function:   EditClusterAcl
//
//  Synopsis:   Invokes the generic ACL editor, specifically for clusters
//
//  Arguments:  [hwndParent] - Parent window handle
//              [pszServerName] - Name of server on which the object resides.
//              [pszClusterName] - Fully qualified name of resource we will
//                  edit, basically a cluster name.
//              [pszClusterNameNode] - Name of node on which the cluster name
//                  resource is online (used for local account check).
//              [pSecDesc] - The initial security descriptor. If NULL, we will
//                  create a default that is "World all" access.
//              [pbSecDescModified] - Set to TRUE if the security descriptor
//                  was modified (i.e., the user hit "OK"), or FALSE if not
//                  (i.e., the user hit "Cancel")
//              [ppSecDesc] - *ppSecDesc points to a new security descriptor
//                  if *pbSecDescModified is TRUE. This memory must be freed
//                  by the caller.
//
//  History:
//      ChuckC   10-Aug-1992    Created. Culled from NTFS ACL code.
//      Yi-HsinS 09-Oct-1992    Added ulHelpContextBase
//      BruceFo  4-Apr-95       Stole and used in ntshrui.dll
//      DavidP   10-Oct-1996    Modified for use with CLUADMIN
//      Rodsh    04-12-1997     Added calls to function to map to/from specific/generic
//
//--------------------------------------------------------------------------

LONG
EditClusterAcl(
    IN HWND                     hwndParent,
    IN LPCTSTR                  pszServerName,
    IN LPCTSTR                  pszClusterName,
    IN LPCTSTR                  pszClusterNameNode,
    IN PSECURITY_DESCRIPTOR     pSecDesc,
    OUT BOOL *                  pbSecDescModified,
    OUT PSECURITY_DESCRIPTOR *  ppSecDesc
    )
{
    ASSERT(pszClusterName != NULL);
    ASSERT(pszClusterNameNode != NULL);
    Trace(g_tagEditClusterAcl, _T("EditClusterAcl, cluster %ws"), pszClusterName);

    ASSERT((pSecDesc == NULL) || IsValidSecurityDescriptor(pSecDesc));
    ASSERT(pbSecDescModified != NULL);
    ASSERT(ppSecDesc != NULL);

    *pbSecDescModified = FALSE;

    LONG err = 0 ;
    PWSTR pszPermName;

    do // error breakout
    {
        /*
         * if pSecDesc is NULL, this is new cluster or a cluster with no
         * security descriptor.
         * we go and create a new (default) security descriptor.
         */
        if( NULL == pSecDesc )
        {
            Trace(g_tagEditClusterAcl, _T("Security Descriptor is NULL.  Deny everyone Access") );
            LONG err = MakeEmptySecDesc( &pSecDesc );
            if (err != NERR_Success)
            {
                err = GetLastError();
                Trace(g_tagEditClusterAcl, _T("makeEmptySecDesc failed, 0x%08lx"), err);
                break;
            }
            
        }
        ASSERT(IsValidSecurityDescriptor(pSecDesc));

        /* Retrieve the resource strings appropriate for the type of object we
         * are looking at
         */

        CString strTypeName;
        CString strDefaultPermName;

        try
        {
            strTypeName.LoadString(IDS_ACLEDIT_TITLE);
            strDefaultPermName.LoadString(IDS_ACLEDIT_PERM_GEN_ALL);
        }  // try
        catch (CMemoryException * pme)
        {
            pme->Delete();
        }

        /*
         * other misc stuff we need pass to security editor
         */
        SED_OBJECT_TYPE_DESCRIPTOR sedObjDesc ;
        SED_HELP_INFO sedHelpInfo ;
        GENERIC_MAPPING ClusterGenericMapping ;

        // setup mappings
        InitializeClusterGenericMapping( &ClusterGenericMapping ) ;

        WCHAR szHelpFile[50] = ACLEDIT_HELPFILENAME;
        sedHelpInfo.pszHelpFileName = szHelpFile;

        sedHelpInfo.aulHelpContext[HC_MAIN_DLG] =                HC_UI_SHELL_BASE + HC_NTSHAREPERMS ;
        sedHelpInfo.aulHelpContext[HC_ADD_USER_DLG] =            HC_UI_SHELL_BASE + HC_SHAREADDUSER ;
        sedHelpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_GG_DLG] = HC_UI_SHELL_BASE + HC_SHAREADDUSER_GLOBALGROUP ;
        sedHelpInfo.aulHelpContext[HC_ADD_USER_SEARCH_DLG] =     HC_UI_SHELL_BASE + HC_SHAREADDUSER_FINDUSER ;

        // These are not used, set to zero
        sedHelpInfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG]          = 0 ;
        sedHelpInfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] = 0 ;

        // setup the object description
        sedObjDesc.Revision                    = SED_REVISION1 ;
        sedObjDesc.IsContainer                 = TRUE ;
        sedObjDesc.AllowNewObjectPerms         = FALSE ;
        sedObjDesc.MapSpecificPermsToGeneric   = TRUE;
        sedObjDesc.GenericMapping              = &ClusterGenericMapping ;
        sedObjDesc.GenericMappingNewObjects    = NULL;
        sedObjDesc.ObjectTypeName              = (LPWSTR) (LPCWSTR) strTypeName ;
        sedObjDesc.HelpInfo                    = &sedHelpInfo ;
        sedObjDesc.ApplyToSubContainerTitle    = NULL ;
        sedObjDesc.ApplyToObjectsTitle         = NULL ;
        sedObjDesc.ApplyToSubContainerConfirmation         = NULL ;
        sedObjDesc.SpecialObjectAccessTitle    = NULL ;
        sedObjDesc.SpecialNewObjectAccessTitle = NULL ;

        /* Now we need to load the global arrays with the permission names
         * from the resource file.
         */
        UINT cArrayItems  = ARRAYLEN(g_SedAppAccessClusterPerms);
        PSED_APPLICATION_ACCESS aSedAppAccess = g_SedAppAccessClusterPerms ;

        /* Loop through each permission title retrieving the text from the
         * resource file and setting the pointer in the array.
         */

        for ( UINT i = 0 ; i < cArrayItems ; i++ )
        {
            pszPermName = GetResourceString(g_dwClusterPermNames[i]) ;
            if (NULL == pszPermName)
            {
                Trace(g_tagEditClusterAcl, _T("GetResourceString failed"));
                break ;
            }
            aSedAppAccess[i].PermissionTitle = pszPermName;
        }
        if (i < cArrayItems)
        {
            Trace(g_tagEditClusterAcl, _T("failed to get all cluster permission names"));
            break ;
        }

        SED_APPLICATION_ACCESSES sedAppAccesses ;
        sedAppAccesses.Count           = cArrayItems ;
        sedAppAccesses.AccessGroup     = aSedAppAccess ;
        sedAppAccesses.DefaultPermName = (LPWSTR) (LPCWSTR) strDefaultPermName;
        /*
         * pass this along so when the call back function is called,
         * we can set it.
         */
        CLUSTER_ACL_CALLBACK_INFO callbackinfo ;
        callbackinfo.pSecDesc           = NULL;
        callbackinfo.bSecDescModified   = FALSE;
        callbackinfo.pszClusterNameNode = pszClusterNameNode;

        //
        // Now, load up the ACL editor and invoke it. We don't keep it around
        // because our DLL is loaded whenever the system is, so we don't want
        // the netui*.dll's hanging around as well...
        //

        HINSTANCE hInstanceAclEditor = NULL;
        SedDiscretionaryAclEditorType pSedDiscretionaryAclEditor = NULL;

        hInstanceAclEditor = LoadLibrary(ACLEDIT_DLL_STRING);
        if (NULL == hInstanceAclEditor)
        {
            err = GetLastError();
            Trace(g_tagEditClusterAcl, _T("LoadLibrary of acledit.dll failed, 0x%08lx"), err);
            break;
        }

        pSedDiscretionaryAclEditor = (SedDiscretionaryAclEditorType)
            GetProcAddress(hInstanceAclEditor,SEDDISCRETIONARYACLEDITOR_STRING);
        if ( pSedDiscretionaryAclEditor == NULL )
        {
            err = GetLastError();
            Trace(g_tagEditClusterAcl, _T("GetProcAddress of SedDiscretionaryAclEditor failed, 0x%08lx"), err);
            break;
        }

        MapBitsInSD( pSecDesc, SPECIFIC_TO_GENERIC );

        DWORD dwSedReturnStatus ;

        ASSERT(pSedDiscretionaryAclEditor != NULL);
        err = (*pSedDiscretionaryAclEditor)(
                                hwndParent,
                                AfxGetInstanceHandle(),
                                (LPTSTR) pszServerName,
                                &sedObjDesc,
                                &sedAppAccesses,
                                (LPTSTR) pszClusterName,
                                SedCallback,
                                (ULONG) &callbackinfo,
                                pSecDesc,
                                FALSE,  // always can read
                                FALSE,  // If we can read, we can write
                                (LPDWORD) &dwSedReturnStatus,
                                0 ) ;

        MapBitsInSD( pSecDesc, GENERIC_TO_SPECIFIC );

        if (!FreeLibrary(hInstanceAclEditor))
        {
            LONG err2 = GetLastError();
            Trace(g_tagEditClusterAcl, _T("FreeLibrary of acledit.dll failed, 0x%08lx"), err2);
            // not fatal: continue...
        }

        if (0 != err)
        {
            Trace(g_tagEditClusterAcl, _T("SedDiscretionaryAclEditor failed, 0x%08lx"), err);
            break ;
        }

        *pbSecDescModified = callbackinfo.bSecDescModified ;

        if (*pbSecDescModified)
        {
            *ppSecDesc = callbackinfo.pSecDesc;
            MapBitsInSD( *ppSecDesc, GENERIC_TO_SPECIFIC );
            Trace(g_tagEditClusterAcl, _T("After calling acl editor, *ppSecDesc = 0x%08lx"), *ppSecDesc);
            ASSERT(IsValidSecurityDescriptor(*ppSecDesc));
        }

    } while (FALSE) ;

    //
    // Free memory...
    //

    UINT cArrayItems  = ARRAYLEN(g_SedAppAccessClusterPerms);
    PSED_APPLICATION_ACCESS aSedAppAccess = g_SedAppAccessClusterPerms ;
    for ( UINT i = 0 ; i < cArrayItems ; i++ )
    {
        pszPermName = aSedAppAccess[i].PermissionTitle;
        if (NULL == pszPermName)
        {
            // if we hit a NULL, that's it!
            break ;
        }

        delete[] pszPermName;
    }

    ASSERT(!*pbSecDescModified || IsValidSecurityDescriptor(*ppSecDesc));

    if (0 != err)
    {
        CString     strMsg;

        try
        {
            strMsg.LoadString(IDS_NOACLEDITOR);
            AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
        }  // try
        catch (CException * pe)
        {
            pe->Delete();
        }  // catch:  CException
    }

    return err;

}  //*** EditClusterAcl()



BOOL BClusterAccessible(PSECURITY_DESCRIPTOR pSD)
{
/*++

Routine Description:

    Determines if the SD has at least one entry in its ACL with Access to the cluster

    Added this function in order to validate Security Descriptors after the ACL editor has been called.
    Rod Sharper 03/27/97

Arguments:

    pSD - Security Descriptor to be checked.

Return Value:

    TRUE if at least one ACE is in the ACL with access to the cluster, False otherwise.

--*/
    PACL    paclDACL        = NULL;
    BOOL    bHasDACL        = FALSE;
    BOOL    bDaclDefaulted  = FALSE;
    BOOL    bPermissionFound= FALSE;
    BOOL    bRtn            = FALSE;

    ACL_SIZE_INFORMATION        asiAclSize;
    DWORD                       dwBufLength;
    DWORD                       dwACL_Index = 0L;
    ACCESS_ALLOWED_ACE          *paaAllowedAce;

    bRtn = IsValidSecurityDescriptor(pSD);
    ASSERT(bRtn);
    if( !bRtn )
        return FALSE;

    bRtn = GetSecurityDescriptorDacl(pSD,
                                    (LPBOOL)&bHasDACL,
                                    (PACL *)&paclDACL,
                                    (LPBOOL)&bDaclDefaulted);
    ASSERT(bRtn);
    if( !bRtn )
        return FALSE;
 
    if (NULL == paclDACL)
        return FALSE;

    bRtn = IsValidAcl(paclDACL);
    ASSERT(bRtn);
    if( !bRtn )
        return FALSE;

    dwBufLength = sizeof(asiAclSize);

    bRtn = GetAclInformation(paclDACL,
                            (LPVOID)&asiAclSize,
                            (DWORD)dwBufLength,
                            (ACL_INFORMATION_CLASS)AclSizeInformation);
    ASSERT(bRtn);
    if( !bRtn )
        return FALSE;

    // Search the ACL for an ACE containing permission to access the cluster
    //
    bPermissionFound = FALSE;
    while( dwACL_Index < asiAclSize.AceCount && !bPermissionFound )
    {
        if (!GetAce(paclDACL,
                            dwACL_Index,
                            (LPVOID *)&paaAllowedAce))
        {
            ASSERT(FALSE);      
            return FALSE; 
        }
        if( paaAllowedAce->Mask == GENERIC_ALL )
            bPermissionFound = TRUE;

        dwACL_Index++;
    }
    
    return bPermissionFound;

}  //*** BClusterAccessible()



BOOL BLocalAccountsInSD(PSECURITY_DESCRIPTOR pSD, LPCTSTR pszClusterNameNode)
{
/*++

Routine Description:

    Determines if any ACEs for local accounts are in DACL stored in from 
    Security Descriptor (pSD) after the ACL editor has been called

    Added this function in order to prevent users from selecting local accounts in 
    permissions dialog.
    Rod Sharper 04/29/97

Arguments:

    pSD - Security Descriptor to be checked.

Return Value:

    TRUE if at least one ACE was removed from the DACL, False otherwise.

--*/
    PACL                    paclDACL            = NULL;
    BOOL                    bHasDACL            = FALSE;
    BOOL                    bDaclDefaulted      = FALSE;
    BOOL                    bLocalAccountInACL  = FALSE;
    BOOL                    bRtn                = FALSE;

    ACL_SIZE_INFORMATION    asiAclSize;
    DWORD                   dwBufLength;
    DWORD                   dwACL_Index = 0L;
    ACCESS_ALLOWED_ACE *    paaAllowedAce;
    TCHAR                   szUserName[128];
    TCHAR                   szDomainName[128];
    DWORD                   cbUser  = 128;
    DWORD                   cbDomain    = 128;
    SID_NAME_USE            SidType;
    PUCHAR                  pnSubAuthorityCount;
    PULONG                  pnSubAuthority0;
    PULONG                  pnSubAuthority1;

    bRtn = IsValidSecurityDescriptor(pSD);
    ASSERT(bRtn);
    if( !bRtn )
        return FALSE;

    bRtn = GetSecurityDescriptorDacl(
                                    pSD,
                                    (LPBOOL)&bHasDACL,
                                    (PACL *)&paclDACL,
                                    (LPBOOL)&bDaclDefaulted);
    ASSERT(bRtn);
    if( !bRtn )
        return FALSE;
 
    if (NULL == paclDACL)
        return FALSE;

    bRtn = IsValidAcl(paclDACL);
    ASSERT(bRtn);
    if( !bRtn )
        return FALSE;

    dwBufLength = sizeof(asiAclSize);

    bRtn = GetAclInformation(
                            paclDACL,
                            (LPVOID)&asiAclSize,
                            (DWORD)dwBufLength,
                            (ACL_INFORMATION_CLASS)AclSizeInformation);
    ASSERT(bRtn);
    if( !bRtn )
        return FALSE;

    // Search the ACL for local account ACEs 
    //
    PSID pSID;
    while( dwACL_Index < asiAclSize.AceCount )
    {
        if (!GetAce(paclDACL, dwACL_Index, (LPVOID *)&paaAllowedAce))
        {
            ASSERT(FALSE);
            return FALSE; 
        }
        if((((PACE_HEADER)paaAllowedAce)->AceType) == ACCESS_ALLOWED_ACE_TYPE)
        {
            //
            //Get SID from ACE
            //

            pSID=(PSID)&((PACCESS_ALLOWED_ACE)paaAllowedAce)->SidStart;
    
            cbUser      = 128;
            cbDomain    = 128;
            if (LookupAccountSid(NULL,
                                 pSID,
                                 szUserName,
                                 &cbUser,
                                 szDomainName,
                                 &cbDomain,
                                 &SidType))
            {
                if (lstrcmpi(szDomainName, _T("BUILTIN")) == 0)
                {
                    pnSubAuthorityCount = GetSidSubAuthorityCount( pSID );
                    if ( (pnSubAuthorityCount != NULL) && (*pnSubAuthorityCount == 2) )
                    {
                        // Check to see if this is the local Administrators group.
                        pnSubAuthority0 = GetSidSubAuthority( pSID, 0 );
                        pnSubAuthority1 = GetSidSubAuthority( pSID, 1 );
                        if (   (pnSubAuthority0 == NULL)
                            || (pnSubAuthority1 == NULL)
                            || (   (*pnSubAuthority0 != SECURITY_BUILTIN_DOMAIN_RID)
                                && (*pnSubAuthority1 != SECURITY_BUILTIN_DOMAIN_RID))
                            || (   (*pnSubAuthority0 != DOMAIN_ALIAS_RID_ADMINS)
                                && (*pnSubAuthority1 != DOMAIN_ALIAS_RID_ADMINS)))
                        {
                            bLocalAccountInACL = TRUE;
                            break;
                        }  // if:  not the local Administrators group
                    }  // if:  exactly 2 sub-authorities
                    else
                    {
                        bLocalAccountInACL = TRUE;
                        break;
                    }  // else:  unexpected # of sub-authorities
                }  // if:  built-in user or group
                else if (  (lstrcmpi(szDomainName, pszClusterNameNode) == 0)
                        && (SidType != SidTypeDomain) )
                {
                    // The domain name is the name of the node on which the
                    // cluster name resource is online, so this is a local
                    // user or group.
                    bLocalAccountInACL = TRUE;
                    break;
                }  // else if:  domain is cluster name resource node and not a Domain SID
            }  // if:  LookupAccountSid succeeded
            else
            {
                // If LookupAccountSid failed, assume that the SID is for
                // a user or group that is local to a machine to which we
                // don't have access.
                bLocalAccountInACL = TRUE;
                break;
            }  // else:  LookupAccountSid failed
        }
        dwACL_Index++;
    }

    return bLocalAccountInACL;

}  //*** BLocalAccountsInSD()


//+-------------------------------------------------------------------------
//
//  Function:   SedCallback
//
//  Synopsis:   Security Editor callback for the Cluster ACL Editor
//
//  Arguments:  See sedapi.h
//
//  History:
//        ChuckC   10-Aug-1992  Created
//        BruceFo  4-Apr-95     Stole and used in ntshrui.dll
//        DavidP   10-Oct-1996  Modified for use with CLUADMIN
//        Rodsh    29-Apr-1996  Modified to detect local accounts in the SD
//        
//--------------------------------------------------------------------------

DWORD
SedCallback(
    HWND                    hwndParent,
    HANDLE                  hInstance,
    ULONG                   ulCallbackContext,
    PSECURITY_DESCRIPTOR    pSecDesc,
    PSECURITY_DESCRIPTOR    pSecDescNewObjects,
    BOOLEAN                 fApplyToSubContainers,
    BOOLEAN                 fApplyToSubObjects,
    LPDWORD                 StatusReturn
    )
{
    CLUSTER_ACL_CALLBACK_INFO * pCallbackInfo = (CLUSTER_ACL_CALLBACK_INFO *)ulCallbackContext;

    Trace(g_tagEditClusterAcl, _T("SedCallback, got pSecDesc = 0x%08lx"), pSecDesc);

    ASSERT(pCallbackInfo != NULL);
    ASSERT(IsValidSecurityDescriptor(pSecDesc));

    if ( BLocalAccountsInSD(pSecDesc, pCallbackInfo->pszClusterNameNode) )
    {
        CString strMsg;
        strMsg.LoadString(IDS_LOCAL_ACCOUNTS_SPECIFIED);
        AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
        return LOCAL_ACCOUNTS_FILTERED;
    }  // if:  local users or groups were specified


    if ( BClusterAccessible(pSecDesc) )
    {
        delete[] (BYTE*)pCallbackInfo->pSecDesc;
        pCallbackInfo->pSecDesc         = CopySecurityDescriptor(pSecDesc);
        pCallbackInfo->bSecDescModified = TRUE;

        ASSERT(IsValidSecurityDescriptor(pCallbackInfo->pSecDesc));
        Trace(g_tagEditClusterAcl, _T("SedCallback, return pSecDesc = 0x%08lx"), pCallbackInfo->pSecDesc);

        return NOERROR;
    }  // if:  at least one Full Control entry is specified
    else
    {
        CString strMsg;
        strMsg.LoadString(IDS_NO_ACCESS_GRANTED);
        AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
        return CLUSTER_INACCESSIBLE;
    }  // else:  this change would make cluster inaccessible

}  //*** SedCallback()


//+-------------------------------------------------------------------------
//
//  Function:   InitializeClusterGenericMapping
//
//  Synopsis:   Initializes the passed generic mapping structure for clusters.
//
//  Arguments:  [pClusterGenericMapping] - Pointer to GENERIC_MAPPING to init.
//
//  History:
//        ChuckC   10-Aug-1992  Created. Culled from NTFS ACL code.
//        BruceFo  4-Apr-95     Stole and used in ntshrui.dll
//        DavidP   10-Oct-1996  Modified for use with CLUADMIN
//
//--------------------------------------------------------------------------

VOID
InitializeClusterGenericMapping(
    IN OUT PGENERIC_MAPPING pClusterGenericMapping
    )
{
    Trace(g_tagEditClusterAcl, _T("InitializeClusterGenericMapping"));

    pClusterGenericMapping->GenericRead     = GENERIC_READ;
    pClusterGenericMapping->GenericWrite    = GENERIC_WRITE;
    pClusterGenericMapping->GenericExecute  = GENERIC_EXECUTE;
    pClusterGenericMapping->GenericAll      = GENERIC_ALL;
 
}  //*** InitializeClusterGenericMapping()


//-------------------------------------------------------------------------
//
//  Function:   MakeEmptySecDesc
//
//  Synopsis:   Create a Security Descriptor with an empty DACL.  The object 
//              associated with this SD will deny access to everyone.
//
//  Arguments:  [ppSecDesc] - *ppSecDesc points to an empty security descriptor 
//              on exit. Caller is responsible for freeing it.
//
//  Returns:    NERR_Success if OK, api error otherwise.
//
//  History:
//        RodSh    26-Mar-1997  Created.
//
//
//--------------------------------------------------------------------------
DWORD MakeEmptySecDesc( OUT PSECURITY_DESCRIPTOR * ppSecDesc )
{
    LONG                    err             = NERR_Success;
    PSECURITY_DESCRIPTOR    pSecDesc        = NULL;
    PACL                    pAcl            = NULL;
    DWORD                   cbAcl           = 0L;   
    PSID                    pSid            = NULL;
    PSID                    pEveryoneSid    = NULL;
    PSID                    pAdminSid       = NULL;
    PACCESS_ALLOWED_ACE     pAce            = NULL;
    PULONG                  pSubAuthority   = NULL;
    *ppSecDesc                              = NULL;

    SID_IDENTIFIER_AUTHORITY SidIdentifierNtAuth        = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierEveryoneAuth  = SECURITY_WORLD_SID_AUTHORITY;


    do        // error breakout
    {
        //
        // Create the admins SID.
        //
        pAdminSid = LocalAlloc(LMEM_FIXED, GetSidLengthRequired( 2 ));
        if (pAdminSid == NULL) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        if (!InitializeSid(pAdminSid, &SidIdentifierNtAuth, 2)) {
            err = GetLastError();
            break;
        }
        ASSERT(IsValidSid(pAdminSid));

        //
        // Set the sub-authorities
        //

        pSubAuthority  = GetSidSubAuthority( pAdminSid, 0 );
        *pSubAuthority = SECURITY_BUILTIN_DOMAIN_RID;

        pSubAuthority  = GetSidSubAuthority( pAdminSid, 1 );
        *pSubAuthority = DOMAIN_ALIAS_RID_ADMINS;

        //
        // Create the SID which will deny everyone access.
        //
        pEveryoneSid = (PSID)LocalAlloc( LMEM_FIXED, GetSidLengthRequired( 1 ) );
        if (pEveryoneSid == NULL) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if ( !InitializeSid( pEveryoneSid, &SidIdentifierEveryoneAuth, 1 ) ) {
            err = GetLastError();
            break;
        }

        ASSERT(IsValidSid(pEveryoneSid));

        //
        // Set the sub-authorities
        //
        pSubAuthority = GetSidSubAuthority( pEveryoneSid, 0 );
        *pSubAuthority = SECURITY_WORLD_RID;

        //
        // Set up the DACL that will allow admins with the above SID all access
        // It should be large enough to hold all ACEs.
        //


        cbAcl = sizeof(ACL)
              + (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD))
              + GetLengthSid(pEveryoneSid)
              ;

        try
        {
            pAcl = (PACL) new BYTE[cbAcl];
            if ( pAcl == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the ACL buffer
        }  // try
        catch (CMemoryException * pme)
        {
            err = ERROR_OUTOFMEMORY;
            Trace(g_tagEditClusterAcl, _T("new ACL failed"));
            pme->Delete();
            break;
        }  // catch:  CMemoryException

        if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION2))
        {
            err = GetLastError();
            Trace(g_tagEditClusterAcl, _T("InitializeAcl failed, 0x%08lx"), err);
            break;
        }

        ASSERT(IsValidAcl(pAcl));

        if ( !AddAccessAllowedAce( pAcl,
                               ACL_REVISION,
                               CLUSAPI_NO_ACCESS, // Deny everyone full control
                               pEveryoneSid )) 
        {
            err = GetLastError();
            Trace(g_tagEditClusterAcl, _T("AddAccessAllowedAce failed, 0x%08lx"), err);
            break;
        }
        GetAce(pAcl, 0, (PVOID *)&pAce);
        pAce->Header.AceFlags |= CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;

        //
        // Create the security descriptor and put the DACL in it.
        //

        try
        {
            pSecDesc = (PSECURITY_DESCRIPTOR) new BYTE[SECURITY_DESCRIPTOR_MIN_LENGTH];
            if ( pSecDesc == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the security descriptor buffer
        }  // try
        catch (CMemoryException * pme)
        {
            err = ERROR_OUTOFMEMORY;
            Trace(g_tagEditClusterAcl, _T("new SECURITY_DESCRIPTOR failed"));
            pme->Delete();
            break;
        }  // catch:  CMemoryException

        if (!InitializeSecurityDescriptor(
                    pSecDesc,
                    SECURITY_DESCRIPTOR_REVISION1))
        {
            err = GetLastError();
            Trace(g_tagEditClusterAcl, _T("InitializeSecurityDescriptor failed, 0x%08lx"), err);
            break;
        }

        
        if (!SetSecurityDescriptorDacl(
                    pSecDesc,
                    TRUE,
                    pAcl,
                    FALSE))
        {
            err = GetLastError();
            Trace(g_tagEditClusterAcl, _T("SetSecurityDescriptorDacl failed, 0x%08lx"), err);
            break;
        }

        ASSERT(IsValidSecurityDescriptor(pSecDesc));

        //
        // Set owner for the descriptor
        //
        if (!SetSecurityDescriptorOwner(pSecDesc,
                                        pAdminSid,
                                        FALSE)) {
            err = GetLastError();
            break;
        }

        //
        // Set group for the descriptor
        //
        if (!SetSecurityDescriptorGroup(pSecDesc,
                                        pAdminSid,
                                        FALSE)) {
            err = GetLastError();
            break;
        }

        // Make the security descriptor self-relative

        DWORD dwLen = GetSecurityDescriptorLength(pSecDesc);
        Trace(g_tagEditClusterAcl, _T("SECURITY_DESCRIPTOR length = %d"), dwLen);

        PSECURITY_DESCRIPTOR pSelfSecDesc = NULL;
        try
        {
            pSelfSecDesc = (PSECURITY_DESCRIPTOR) new BYTE[dwLen];
            if ( pSelfSecDesc == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the security descriptor buffer
        }  // try
        catch (CMemoryException * pme)
        {
            err = ERROR_OUTOFMEMORY;
            Trace(g_tagEditClusterAcl, _T("new SECURITY_DESCRIPTOR (2) failed"));
            pme->Delete();
            break;
        }  // catch:  CMemoryException

        DWORD cbSelfSecDesc = dwLen;
        if (!MakeSelfRelativeSD(pSecDesc, pSelfSecDesc, &cbSelfSecDesc))
        {
            err = GetLastError();
            Trace(g_tagEditClusterAcl, _T("MakeSelfRelativeSD failed, 0x%08lx"), err);
            break;
        }

        ASSERT(IsValidSecurityDescriptor(pSelfSecDesc));

        //
        // all done: set the security descriptor
        //

        *ppSecDesc = pSelfSecDesc;

    } while (FALSE) ;

    if (NULL != pAdminSid)
    {
        FreeSid(pAdminSid);
    }
    if (NULL != pEveryoneSid)
    {
        FreeSid(pEveryoneSid);
    }
    delete[] (BYTE*)pAcl;
    delete[] (BYTE*)pSecDesc;

    ASSERT(IsValidSecurityDescriptor(*ppSecDesc));

    return err;
}


//+-------------------------------------------------------------------------
//
//  Function:   DeleteDefaultSecDesc
//
//  Synopsis:   Delete a security descriptor that was created by
//              CreateDefaultSecDesc
//
//  Arguments:  [pSecDesc] - security descriptor to delete
//
//  Returns:    nothing
//
//  History:
//        BruceFo  4-Apr-95     Created
//        DavidP   10-Oct-1996  Modified for use with CLUADMIN
//
//--------------------------------------------------------------------------

VOID
DeleteDefaultSecDesc(
    IN PSECURITY_DESCRIPTOR pSecDesc
    )
{
    Trace(g_tagEditClusterAcl, _T("DeleteDefaultSecDesc"));

    delete[] (BYTE*)pSecDesc;

}  //*** DeleteDefaultSecDesc()


//+-------------------------------------------------------------------------
//
//  Member:     CopySecurityDescriptor, public
//
//  Synopsis:   Copy an NT security descriptor. The security descriptor must
//              be in self-relative (not absolute) form. Delete the result
//              using "delete[] (BYTE*)pSecDesc".
//
//  History:    19-Apr-95   BruceFo     Created
//              10-Oct-1996 DavidP      Modified for use with CLUADMIN
//
//--------------------------------------------------------------------------

PSECURITY_DESCRIPTOR
CopySecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecDesc
    )
{
    Trace(g_tagEditClusterAcl, _T("CopySecurityDescriptor, pSecDesc = 0x%08lx"), pSecDesc);

    if (NULL == pSecDesc)
    {
        return NULL;
    }

    ASSERT(IsValidSecurityDescriptor(pSecDesc));

    DWORD dwLen = GetSecurityDescriptorLength(pSecDesc);
    PSECURITY_DESCRIPTOR pSelfSecDesc = NULL;
    try
    {
        pSelfSecDesc = (PSECURITY_DESCRIPTOR) new BYTE[dwLen];
        if ( pSelfSecDesc == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the security descriptor buffer
    }
    catch (CMemoryException * pme)
    {
        Trace(g_tagEditClusterAcl, _T("new SECURITY_DESCRIPTOR (2) failed"));
        pme->Delete();
        return NULL;    // actually, should probably return an error
    }  // catch:  CMemoryException

    DWORD cbSelfSecDesc = dwLen;
    if (!MakeSelfRelativeSD(pSecDesc, pSelfSecDesc, &cbSelfSecDesc))
    {
        Trace(g_tagEditClusterAcl, _T("MakeSelfRelativeSD failed, 0x%08lx"), GetLastError());

        // assume it failed because it was already self-relative
        CopyMemory(pSelfSecDesc, pSecDesc, dwLen);
    }

    ASSERT(IsValidSecurityDescriptor(pSelfSecDesc));

    return pSelfSecDesc;

}  //*** CopySecurityDescriptor()


//+---------------------------------------------------------------------------
//
//  Function:   GetResourceString
//
//  Synopsis:   Load a resource string, are return a "new"ed copy
//
//  Arguments:  [dwId] -- a resource string ID
//
//  Returns:    new memory copy of a string
//
//  History:    5-Apr-95    BruceFo Created
//              10-Oct-1996 DavidP  Modified for CLUADMIN
//
//----------------------------------------------------------------------------

PWSTR
GetResourceString(
    IN DWORD dwId
    )
{
    CString str;

    if (str.LoadString(dwId))
        return NewDup(str);
    else
        return NULL;

}  //*** GetResourceString()


//+---------------------------------------------------------------------------
//
//  Function:   NewDup
//
//  Synopsis:   Duplicate a string using '::new'
//
//  History:    28-Dec-94   BruceFo   Created
//              10-Oct-1996 DavidP    Modified for CLUADMIN
//
//----------------------------------------------------------------------------

PWSTR
NewDup(
    IN const WCHAR* psz
    )
{
    PWSTR pszRet = NULL;

    if (NULL == psz)
    {
        Trace(g_tagEditClusterAcl, _T("Illegal string to duplicate: NULL"));
        return NULL;
    }

    try
    {
        pszRet = new WCHAR[wcslen(psz) + 1];
        if ( pszRet == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating memory
    }
    catch (CMemoryException * pme)
    {
        Trace(g_tagEditClusterAcl, _T("OUT OF MEMORY"));
        pme->Delete();
        return NULL;
    }  // catch:  CMemoryException

    wcscpy(pszRet, psz);
    return pszRet;

}  //*** NewDup()


//+-------------------------------------------------------------------------
//
//  Function:   MapBitsInSD
//
//  Synopsis:   Maps Specific bits to Generic bit when MAP_DIRECTION is SPECIFIC_TO_GENERIC 
//              Maps Generic bits to Specific bit when MAP_DIRECTION is GENERIC_TO_SPECIFIC

//
//  Arguments:  [pSecDesc] - SECURITY_DESCIRPTOR to be modified
//              [direction] - indicates whether bits are mapped from specific to generic 
//                            or generic to specific.
//  Author:
//      Roderick Sharper (rodsh) April 12, 1997
//
//  History:
//
//--------------------------------------------------------------------------

BOOL MapBitsInSD(PSECURITY_DESCRIPTOR pSecDesc, MAP_DIRECTION direction)
{
    PACL    paclDACL        = NULL;
    BOOL    bHasDACL        = FALSE;
    BOOL    bDaclDefaulted  = FALSE;
    BOOL    bRtn            = FALSE;

    if (!IsValidSecurityDescriptor(pSecDesc))
        return FALSE; 


    if (!GetSecurityDescriptorDacl(pSecDesc,
                 (LPBOOL)&bHasDACL,
                 (PACL *)&paclDACL,
                 (LPBOOL)&bDaclDefaulted))
        return FALSE; 

 
    if (paclDACL)
        bRtn = MapBitsInACL(paclDACL, direction);

 return bRtn;
}


//+-------------------------------------------------------------------------
//
//  Function:   MapBitsInACL
//
//  Synopsis:   Maps Specific bits to Generic bit when MAP_DIRECTION is SPECIFIC_TO_GENERIC 
//              Maps Generic bits to Specific bit when MAP_DIRECTION is GENERIC_TO_SPECIFIC
//
//
//  Arguments:  [paclACL] - ACL (Access Control List) to be modified
//              [direction] - indicates whether bits are mapped from specific to generic 
//                            or generic to specific.
//  Author:
//      Roderick Sharper (rodsh) April 12, 1997
//
//  History:
//
//--------------------------------------------------------------------------

BOOL MapBitsInACL(PACL paclACL, MAP_DIRECTION direction)
{
    ACL_SIZE_INFORMATION        asiAclSize;
    BOOL                        bRtn = FALSE;
    DWORD                       dwBufLength;
    DWORD                       dwACL_Index;
    ACCESS_ALLOWED_ACE   *paaAllowedAce;

    if (!IsValidAcl(paclACL))
        return FALSE; 

    dwBufLength = sizeof(asiAclSize);

    if (!GetAclInformation(paclACL,
             (LPVOID)&asiAclSize,
             (DWORD)dwBufLength,
             (ACL_INFORMATION_CLASS)AclSizeInformation))
        return FALSE; 

    for (dwACL_Index = 0; dwACL_Index < asiAclSize.AceCount;  dwACL_Index++)
    {
        if (!GetAce(paclACL,
            dwACL_Index,
            (LPVOID *)&paaAllowedAce))
        return FALSE; 

        if( direction == SPECIFIC_TO_GENERIC )
            bRtn = MapSpecificBitsInAce( paaAllowedAce );
        else if( direction == GENERIC_TO_SPECIFIC )
            bRtn = MapGenericBitsInAce( paaAllowedAce );
        else
            bRtn = FALSE;
    }

    return bRtn;
}


//+-------------------------------------------------------------------------
//
//  Function:   MapSpecificBitsInAce  
//
//  Synopsis:   Maps specific bits in ACE to generic bits
//
//  Arguments:  [paaAllowedAce] - ACE (Access Control Entry) to be modified
//              [direction]     - indicates whether bits are mapped from specific to generic 
//                                or generic to specific.
//  Author:
//      Roderick Sharper (rodsh) April 12, 1997
//
//  History:
//
//--------------------------------------------------------------------------

BOOL MapSpecificBitsInAce(PACCESS_ALLOWED_ACE paaAllowedAce)
{
    ACCESS_MASK amMask = paaAllowedAce->Mask;
    BOOL bRtn = FALSE;

    DWORD dwGenericBits;
    DWORD dwSpecificBits;

    dwSpecificBits            = (amMask & SPECIFIC_RIGHTS_ALL);
    dwGenericBits             = 0;

    switch( dwSpecificBits )
    {
        case CLUSAPI_READ_ACCESS:   dwGenericBits = GENERIC_READ;   // GENERIC_READ  == 0x80000000L 
                                    bRtn = TRUE;
                                    break;

        case CLUSAPI_CHANGE_ACCESS: dwGenericBits = GENERIC_WRITE;  // GENERIC_WRITE == 0x40000000L 
                                    bRtn = TRUE;
                                    break;
        
        case CLUSAPI_NO_ACCESS:     dwGenericBits = GENERIC_EXECUTE;// GENERIC_EXECUTE == 0x20000000L 
                                    bRtn = TRUE;
                                    break;
        
        case CLUSAPI_ALL_ACCESS:    dwGenericBits = GENERIC_ALL;    // GENERIC_ALL   == 0x10000000L
                                    bRtn = TRUE;
                                    break;
        
        default:    dwGenericBits = 0x00000000L;    // Invalid,assign no rights. 
                                    bRtn = FALSE;
                                    break;
    }

    amMask = dwGenericBits;
    paaAllowedAce->Mask = amMask;

    return bRtn;
}

//+-------------------------------------------------------------------------
//
//  Function:   MapGenericBitsInAce  
//
//  Synopsis:   Maps generic bits in ACE to specific bits
//
//  Arguments:  [paaAllowedAce] - ACE (Access Control Entry) to be modified
//              [direction]     - indicates whether bits are mapped from specific to generic 
//                                or generic to specific.
//  Author:
//      Roderick Sharper (rodsh) April 12, 1997
//
//  History:
//
//--------------------------------------------------------------------------

BOOL MapGenericBitsInAce  (PACCESS_ALLOWED_ACE paaAllowedAce)
{
    #define GENERIC_RIGHTS_ALL_THE_BITS  0xF0000000L

    ACCESS_MASK amMask = paaAllowedAce->Mask;
    BOOL bRtn = FALSE;

    DWORD dwGenericBits;
    DWORD dwSpecificBits;

    dwSpecificBits            = 0;
    dwGenericBits             = (amMask & GENERIC_RIGHTS_ALL_THE_BITS);

        switch( dwGenericBits )
    {
        case GENERIC_ALL:       dwSpecificBits = CLUSAPI_ALL_ACCESS;    // CLUSAPI_ALL_ACCESS       == 3 
                                bRtn = TRUE;
                                break;
                                
        case GENERIC_EXECUTE:   dwSpecificBits = CLUSAPI_NO_ACCESS;     // CLUSAPI_NO_ACCESS        == 4
                                bRtn = TRUE;
                                break;

        case GENERIC_WRITE:     dwSpecificBits = CLUSAPI_CHANGE_ACCESS; // CLUSAPI_CHANGE_ACCESS    == 2
                                bRtn = TRUE;
                                break;
                                
        case GENERIC_READ:      dwSpecificBits = CLUSAPI_READ_ACCESS;   // CLUSAPI_READ_ACCESS      == 1
                                bRtn = TRUE;
                                break;
        
        default:                dwSpecificBits = 0x00000000L;           // Invalid, assign no rights. 
                                bRtn = FALSE;
                                break;
    }                       

    amMask = dwSpecificBits;
    paaAllowedAce->Mask = amMask;

    return bRtn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\editacl.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		EditAcl.h
//
//	Abstract:
//		Definition of ACL editor methods.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//          From \nt\private\window\shell\lmui\ntshrui\acl.cxx
//          by BruceFo
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EDITACL_H_
#define _EDITACL_H_

LONG
EditClusterAcl(
	IN HWND 					hwndParent,
	IN LPCTSTR					pszServerName,
	IN LPCTSTR					pszClusterName,
	IN LPCTSTR					pszClusterNameNode,
	IN PSECURITY_DESCRIPTOR 	pSecDesc,
	OUT BOOL *					pfSecDescModified,
	OUT PSECURITY_DESCRIPTOR *	ppSecDesc
	);

LONG
CreateDefaultSecDesc(
	OUT PSECURITY_DESCRIPTOR* ppSecDesc
	);

VOID
DeleteDefaultSecDesc(
	IN PSECURITY_DESCRIPTOR pSecDesc
	);

PSECURITY_DESCRIPTOR
CopySecurityDescriptor(
	IN PSECURITY_DESCRIPTOR pSecDesc
	);

//
// Cluster General Permissions
//

#define CLUSTER_RIGHTS_NO_ACCESS	(0)
#define CLUSTER_RIGHTS_READ			(STANDARD_RIGHTS_READ		|\
										CLUSAPI_READ_ACCESS)
#define CLUSTER_RIGHTS_CHANGE		(STANDARD_RIGHTS_WRITE		|\
										CLUSAPI_CHANGE_ACCESS)
#define CLUSTER_RIGHTS_ALL			(STANDARD_RIGHTS_ALL		|\
										CLUSAPI_ALL_ACCESS)

/////////////////////////////////////////////////////////////////////////////

#endif // _EDITACL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\extmenu.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ExtMenu.cpp
//
//  Abstract:
//      Implementation of the CExtMenuItem class.
//
//  Author:
//      David Potter (davidp)   August 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ExtMenu.h"

/////////////////////////////////////////////////////////////////////////////
// CExtMenuItem
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC( CExtMenuItem, CObject );

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtMenuItem::CExtMenuItem
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtMenuItem::CExtMenuItem( void )
{
    CommonConstruct();

}  //*** CExtMenuItem::CExtMenuItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtMenuItem::CExtMenuItem
//
//  Routine Description:
//      Constructor.  Caller must check range on ID and flags.
//
//  Arguments:
//      lpszName            [IN] Name of item.
//      lpszStatusBarText   [IN] Text to appear on the status bar when the
//                            item is highlighted.
//      nExtCommandID       [IN] Extension's ID for the command.
//      nCommandID          [IN] ID for the command when menu item is invoked.
//      nMenuItemID         [IN] Index in the menu of the item.
//      uFlags              [IN] Menu flags.
//      bMakeDefault        [IN] TRUE = Make this item the default item.
//      piCommand           [IN OUT] Command interface.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtMenuItem::CExtMenuItem(
    IN LPCTSTR                  lpszName,
    IN LPCTSTR                  lpszStatusBarText,
    IN ULONG                    nExtCommandID,
    IN ULONG                    nCommandID,
    IN ULONG                    nMenuItemID,
    IN ULONG                    uFlags,
    IN BOOL                     bMakeDefault,
    IN OUT IWEInvokeCommand *   piCommand
    )
{
    CommonConstruct();

    ASSERT( piCommand != NULL );

    m_strName = lpszName;
    m_strStatusBarText = lpszStatusBarText;
    m_nExtCommandID = nExtCommandID;
    m_nCommandID = nCommandID;
    m_nMenuItemID = nMenuItemID;
    m_uFlags = uFlags;
    m_bDefault = bMakeDefault;
    m_piCommand = piCommand;

    // will throw its own exception if it fails
    if ( uFlags & MF_POPUP )
    {
        m_plSubMenuItems = new CExtMenuItemList;
        if ( m_plSubMenuItems == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating memory
    } // if: popup menu

    ASSERT_VALID( this );

}  //*** CExtMenuItem::CExtMenuItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtMenuItem::~CExtMenuItem
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtMenuItem::~CExtMenuItem( void )
{
    delete m_plSubMenuItems;

    // Nuke data so it can't be used again
    CommonConstruct();

}  //*** CExtMenuItem::~CExtMenuItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtMenuItem::CommonConstruct
//
//  Routine Description:
//      Common object construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtMenuItem::CommonConstruct( void )
{
    m_strName.Empty();
    m_strStatusBarText.Empty();
    m_nExtCommandID = (ULONG) -1;
    m_nCommandID = (ULONG) -1;
    m_nMenuItemID = (ULONG) -1;
    m_uFlags = (ULONG) -1;
    m_bDefault = FALSE;
    m_piCommand = NULL;

    m_plSubMenuItems = NULL;
    m_hmenuPopup = NULL;

}  //*** CExtMenuItem::CommonConstruct()

#ifdef _DEBUG
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtMenuItem::AssertValid
//
//  Routine Description:
//      Assert that the object is valid.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtMenuItem::AssertValid( void )
{
    CObject::AssertValid();

    if ( ( m_nExtCommandID == -1 )
      || ( m_nCommandID == -1 )
      || ( m_nMenuItemID == -1 )
      || ( m_uFlags == -1 )
      || ( ( ( m_uFlags & MF_POPUP ) == 0 ) && ( m_plSubMenuItems != NULL ) )
      || ( ( ( m_uFlags & MF_POPUP ) != 0 ) && ( m_plSubMenuItems == NULL ) )
        )
    {
        ASSERT( FALSE );
    }

}  //*** CExtMenuItem::AssertValid()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\extdll.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		ExtDll.h
//
//	Abstract:
//		Definition of the extension classes.
//
//	Implementation File:
//		ExtDll.cpp
//
//	Author:
//		David Potter (davidp)	May 31, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXTDLL_H_
#define _EXTDLL_H_

/////////////////////////////////////////////////////////////////////////////
//	Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>	// for extension DLL definitions
#endif

#ifndef __cluadmid_h__
#include "CluAdmID.h"
#endif

#ifndef _DATAOBJ_H_
#include "DataObj.h"	// for CDataObject
#endif

#ifndef _TRACETAG_H_
#include "TraceTag.h"	// for CTraceTag, Trace
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtension;
class CExtensionDll;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterItem;
class CBaseSheet;
class CBasePropertySheet;
class CBaseWizard;
class CExtMenuItem;
class CExtMenuItemList;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#define CAEXT_MENU_FIRST_ID		35000

typedef CList<CComObject<CExtensionDll> *, CComObject<CExtensionDll> *> CExtDllList;

/////////////////////////////////////////////////////////////////////////////
// Global Variable Definitions
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
extern CTraceTag g_tagExtDll;
extern CTraceTag g_tagExtDllRef;
#endif

/////////////////////////////////////////////////////////////////////////////
//
//	class CExtensions
//
//	Purpose:
//		Encapsulates access to a list of extension DLLs.
//
/////////////////////////////////////////////////////////////////////////////
class CExtensions : public CObject
{
	friend class CExtensionDll;

	DECLARE_DYNAMIC(CExtensions);

// Attributes
private:
	const CStringList *	m_plstrExtensions;	// List of extensions.
	CClusterItem *		m_pci;				// Cluster item being administered.
	HFONT				m_hfont;			// Font for dialog text.
	HICON				m_hicon;			// Icon for upper left corner.

protected:
	const CStringList *	PlstrExtensions(void) const	{ return m_plstrExtensions; }
	CClusterItem *		Pci(void) const				{ return m_pci; }
	HFONT				Hfont(void) const			{ return m_hfont; }
	HICON				Hicon(void) const			{ return m_hicon; }

// Operations
public:
	CExtensions(void);
	virtual ~CExtensions(void);

	void				Init(
							IN const CStringList &	rlstrExtensions,
							IN OUT CClusterItem *	pci,
							IN HFONT				hfont,
							IN HICON				hicon
							);
	void				UnloadExtensions(void);

	// IWEExtendPropertySheet interface routines.
	void				CreatePropertySheetPages(
							IN OUT CBasePropertySheet *	psht,
							IN const CStringList &		rlstrExtensions,
							IN OUT CClusterItem *		pci,
							IN HFONT					hfont,
							IN HICON					hicon
							);

	// IWEExtendWizard interface routines.
	void				CreateWizardPages(
							IN OUT CBaseWizard *	psht,
							IN const CStringList &	rlstrExtensions,
							IN OUT CClusterItem *	pci,
							IN HFONT				hfont,
							IN HICON				hicon
							);

	// IWEExtendContextMenu interface routines.
	void				AddContextMenuItems(
							IN OUT CMenu *				pmenu,
							IN const CStringList &		rlstrExtensions,
							IN OUT CClusterItem *		pci
							);
	BOOL				BExecuteContextMenuItem(IN ULONG nCommandID);

	BOOL				BGetCommandString(IN ULONG nCommandID, OUT CString & rstrMessage);
	void				SetPfGetResNetName(PFGETRESOURCENETWORKNAME pfGetResNetName, PVOID pvContext)
	{
		if (Pdo() != NULL)
			Pdo()->SetPfGetResNetName(pfGetResNetName, pvContext);
	}

// Implementation
private:
	CComObject<CDataObject> *	m_pdoData;			// Data object for exchanging data.
	CExtDllList *				m_plextdll;			// List of extension DLLs.
	CBaseSheet *				m_psht;				// Property sheet for IWEExtendPropertySheet.
	CMenu *						m_pmenu;			// Menu for IWEExtendContextMenu.
	CExtMenuItemList *			m_plMenuItems;

	ULONG						m_nFirstCommandID;
	ULONG						m_nNextCommandID;
	ULONG						m_nFirstMenuID;
	ULONG						m_nNextMenuID;

protected:
	CComObject<CDataObject> *	Pdo(void)						{ return m_pdoData; }
	CExtDllList *				Plextdll(void) const			{ return m_plextdll; }
	CBaseSheet *				Psht(void) const				{ return m_psht; }
	CMenu *						Pmenu(void) const				{ return m_pmenu; }
	CExtMenuItemList *			PlMenuItems(void) const			{ return m_plMenuItems; }
	CExtMenuItem *				PemiFromCommandID(ULONG nCommandID) const;
#ifdef _DEBUG
	CExtMenuItem *				PemiFromExtCommandID(ULONG nExtCommandID) const;
#endif
	ULONG						NFirstCommandID(void) const		{ return m_nFirstCommandID; }
	ULONG						NNextCommandID(void) const		{ return m_nNextCommandID; }
	ULONG						NFirstMenuID(void) const		{ return m_nFirstMenuID; }
	ULONG						NNextMenuID(void) const			{ return m_nNextMenuID; }

public:
	afx_msg void				OnUpdateCommand(CCmdUI * pCmdUI);
	BOOL						OnCmdMsg(UINT nID, int nCode, void * pExtra, AFX_CMDHANDLERINFO * pHandlerInfo);

};  //*** class CExtensions

/////////////////////////////////////////////////////////////////////////////
//
//	class CExtensionDll
//
//	Purpose:
//		Encapsulates access to an extension DLL.
//
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CExtensionDll :
	public CObject,
	public IWCPropertySheetCallback,
	public IWCWizardCallback,
	public IWCContextMenuCallback,
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CExtensionDll, &CLSID_CoCluAdmin>
{
	friend class CExtensions;

	DECLARE_DYNAMIC(CExtensionDll);

// Attributes
private:
	CString						m_strCLSID;		// Name of extension DLL.

protected:
	const CString &				StrCLSID(void) const		{ return m_strCLSID; }
	CClusterItem *				Pci(void) const				{ return Pext()->Pci(); }

// Operations
public:
	CExtensionDll(void);
	virtual ~CExtensionDll(void);

BEGIN_COM_MAP(CExtensionDll)
	COM_INTERFACE_ENTRY(IWCPropertySheetCallback)
	COM_INTERFACE_ENTRY(IWCWizardCallback)
	COM_INTERFACE_ENTRY(IWCContextMenuCallback)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//DECLARE_NOT_AGGREGATABLE(CExtensionDll) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CExtensionDll, _T("CLUADMIN.Extensions"), _T("CLUADMIN.Extensions"), IDS_CLUADMIN_DESC, THREADFLAGS_BOTH)

	void						Init(
									IN const CString &		rstrExtension,
									IN OUT CExtensions *	pext
									);
	IUnknown *					LoadInterface(IN const REFIID riid);
	void						UnloadExtension(void);

	// IWEExtendPropertySheet interface routines.
	void						CreatePropertySheetPages(void);

	// IWEExtendWizard interface routines.
	void						CreateWizardPages(void);

	// IWEExtendContextMenu interface routines.
	void						AddContextMenuItems(void);

// ISupportsErrorInfo
public:
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IWCPropertySheetCallback
public:
	STDMETHOD(AddPropertySheetPage)(
					IN LONG *		hpage	// really should be HPROPSHEETPAGE
					);

// IWCWizardCallback
public:
	STDMETHOD(AddWizardPage)(
					IN LONG *		hpage	// really should be HPROPSHEETPAGE
					);
	STDMETHOD(EnableNext)(
					IN LONG *		hpage,
					IN BOOL			bEnable
					);

// IWCContextMenuCallback
public:
	STDMETHOD(AddExtensionMenuItem)(
					IN BSTR		lpszName,
					IN BSTR		lpszStatusBarText,
					IN ULONG	nCommandID,
					IN ULONG	nSubmenuCommandID,
					IN ULONG	uFlags
					);

// Implementation
private:
	CExtensions *				m_pext;
	CLSID						m_clsid;
	IWEExtendPropertySheet *	m_piExtendPropSheet;	// Pointer to an IWEExtendPropertySheet interface.
	IWEExtendWizard *			m_piExtendWizard;		// Pointer to an IWEExtendWizard interface.
	IWEExtendContextMenu *		m_piExtendContextMenu;	// Pointer to an IWEExtendContextMenu interface.
	IWEInvokeCommand *			m_piInvokeCommand;		// Pointer to an IWEInvokeCommand interface.

	AFX_MODULE_STATE *			m_pModuleState;			// Required for resetting our state during callbacks.

protected:
	CExtensions *				Pext(void) const				{ ASSERT_VALID(m_pext); return m_pext; }
	const CLSID &				Rclsid(void) const				{ return m_clsid; }
	IWEExtendPropertySheet *	PiExtendPropSheet(void) const	{ return m_piExtendPropSheet; }
	IWEExtendWizard *			PiExtendWizard(void) const		{ return m_piExtendWizard; }
	IWEExtendContextMenu *		PiExtendContextMenu(void) const	{ return m_piExtendContextMenu; }
	IWEInvokeCommand *			PiInvokeCommand(void) const		{ return m_piInvokeCommand; }

	CComObject<CDataObject> *	Pdo(void) const					{ return Pext()->Pdo(); }
	CBaseSheet *				Psht(void) const				{ return Pext()->Psht(); }
	CMenu *						Pmenu(void) const				{ return Pext()->Pmenu(); }
	CExtMenuItemList *			PlMenuItems(void) const			{ return Pext()->PlMenuItems(); }
	ULONG						NFirstCommandID(void) const		{ return Pext()->NFirstCommandID(); }
	ULONG						NNextCommandID(void) const		{ return Pext()->NNextCommandID(); }
	ULONG						NFirstMenuID(void) const		{ return Pext()->NFirstMenuID(); }
	ULONG						NNextMenuID(void) const			{ return Pext()->NNextMenuID(); }

	void ReleaseInterface(
			IN OUT IUnknown ** ppi
#ifdef _DEBUG
			, IN LPCTSTR szClassName
#endif
			)
	{
		ASSERT(ppi != NULL);
		if (*ppi != NULL)
		{
#ifdef _DEBUG
			ULONG ulNewRefCount;

			Trace(g_tagExtDllRef, _T("Releasing %s"), szClassName);
			ulNewRefCount =
#endif
			(*ppi)->Release();
			*ppi = NULL;
#ifdef _DEBUG
			Trace(g_tagExtDllRef, _T("  Reference count = %d"), ulNewRefCount);
			Trace(g_tagExtDllRef, _T("ReleaseInterface() - %s = %08.8x"), szClassName, *ppi);
#endif
		}  // if:  interface specified
	}
	void ReleaseInterface(IN OUT IWEExtendPropertySheet ** ppi)
	{
		ReleaseInterface(
			(IUnknown **) ppi
#ifdef _DEBUG
			, _T("IWEExtendPropertySheet")
#endif
			);
	}
	void ReleaseInterface(IN OUT IWEExtendWizard ** ppi)
	{
		ReleaseInterface(
			(IUnknown **) ppi
#ifdef _DEBUG
			, _T("IWEExtendWizard")
#endif
			);
	}
	void ReleaseInterface(IN OUT IWEExtendContextMenu ** ppi)
	{
		ReleaseInterface(
			(IUnknown **) ppi
#ifdef _DEBUG
			, _T("IWEExtendContextMenu")
#endif
			);
	}
	void ReleaseInterface(IN OUT IWEInvokeCommand ** ppi)
	{
		ReleaseInterface(
			(IUnknown **) ppi
#ifdef _DEBUG
			, _T("IWEInvokeCommand")
#endif
			);
	}

};  //*** class CExtensionDll

/////////////////////////////////////////////////////////////////////////////

#endif // _EXTDLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\grpprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-2000 Microsoft Corporation
//
//	Module Name:
//		GrpProp.cpp
//
//	Abstract:
//		Implementation of the group property sheet and pages.
//
//	Author:
//		David Potter (davidp)	May 14, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "GrpProp.h"
#include "Group.h"
#include "ModNodes.h"
#include "DDxDDv.h"
#include "ClusDoc.h"
#include "HelpData.h"	// for g_rghelpmap*

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGroupPropSheet
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CGroupPropSheet, CBasePropertySheet)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CGroupPropSheet, CBasePropertySheet)
	//{{AFX_MSG_MAP(CGroupPropSheet)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupPropSheet::CGroupPropSheet
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pci			[IN OUT] Cluster item whose properties are to be displayed.
//		pParentWnd	[IN OUT] Parent window for this property sheet.
//		iSelectPage	[IN] Page to show first.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGroupPropSheet::CGroupPropSheet(
	IN OUT CWnd *	pParentWnd,
	IN UINT			iSelectPage
	)
	: CBasePropertySheet(pParentWnd, iSelectPage)
{
	m_rgpages[0] = &PageGeneral();
	m_rgpages[1] = &PageFailover();
	m_rgpages[2] = &PageFailback();

}  //*** CGroupPropSheet::CGroupPropSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupPropSheet::BInit
//
//	Routine Description:
//		Initialize the property sheet.
//
//	Arguments:
//		pci			[IN OUT] Cluster item whose properties are to be displayed.
//		iimgIcon	[IN] Index in the large image list for the image to use
//					  as the icon on each page.
//
//	Return Value:
//		TRUE		Property sheet initialized successfully.
//		FALSE		Error initializing property sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupPropSheet::BInit(
	IN OUT CClusterItem *	pci,
	IN IIMG					iimgIcon
	)
{
	// Call the base class method.
	if (!CBasePropertySheet::BInit(pci, iimgIcon))
		return FALSE;

	// Set the read-only flag.
	m_bReadOnly = PciGroup()->BReadOnly()
					|| (PciGroup()->Cgs() == ClusterGroupStateUnknown);

	return TRUE;

}  //*** CGroupPropSheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupPropSheet::Ppages
//
//	Routine Description:
//		Returns the array of pages to add to the property sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Page array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage ** CGroupPropSheet::Ppages(void)
{
	return m_rgpages;

}  //*** CGroupPropSheet::Ppages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupPropSheet::Cpages
//
//	Routine Description:
//		Returns the count of pages in the array.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Count of pages in the array.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CGroupPropSheet::Cpages(void)
{
	return sizeof(m_rgpages) / sizeof(CBasePropertyPage *);

}  //*** CGroupPropSheet::Cpages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CGroupGeneralPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CGroupGeneralPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CGroupGeneralPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CGroupGeneralPage)
	ON_BN_CLICKED(IDC_PP_GROUP_PREF_OWNERS_MODIFY, OnModifyPreferredOwners)
	ON_LBN_DBLCLK(IDC_PP_GROUP_PREF_OWNERS, OnDblClkPreferredOwners)
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
	ON_EN_CHANGE(IDC_PP_GROUP_NAME, CBasePropertyPage::OnChangeCtrl)
	ON_EN_CHANGE(IDC_PP_GROUP_DESC, CBasePropertyPage::OnChangeCtrl)
	ON_COMMAND(ID_FILE_PROPERTIES, OnProperties)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupGeneralPage::CGroupGeneralPage
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGroupGeneralPage::CGroupGeneralPage(void)
	: CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_GROUP_GENERAL)
{
	//{{AFX_DATA_INIT(CGroupGeneralPage)
	m_strName = _T("");
	m_strDesc = _T("");
	m_strState = _T("");
	m_strNode = _T("");
	//}}AFX_DATA_INIT

}  //*** CGroupGeneralPage::CGroupGeneralPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupGeneralPage::BInit
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		psht		[IN OUT] Property sheet to which this page belongs.
//
//	Return Value:
//		TRUE		Page initialized successfully.
//		FALSE		Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupGeneralPage::BInit(IN OUT CBaseSheet * psht)
{
	BOOL	bSuccess;

	ASSERT_KINDOF(CGroupPropSheet, psht);

	bSuccess = CBasePropertyPage::BInit(psht);
	if (bSuccess)
	{
		try
		{
			m_strName = PciGroup()->StrName();
			m_strDesc = PciGroup()->StrDescription();
			m_strNode = PciGroup()->StrOwner();

			// Duplicate the preferred owners list.
			{
				POSITION		pos;
				CClusterNode *	pciNode;

				pos = PciGroup()->LpcinodePreferredOwners().GetHeadPosition();
				while (pos != NULL)
				{
					pciNode = (CClusterNode *) PciGroup()->LpcinodePreferredOwners().GetNext(pos);
					ASSERT_VALID(pciNode);
					m_lpciPreferredOwners.AddTail(pciNode);
				}  // while:  more nodes in the list
			}  // Duplicate the possible owners list

			PciGroup()->GetStateName(m_strState);
		}  // try
		catch (CException * pe)
		{
			pe->ReportError();
			pe->Delete();
			bSuccess = FALSE;
		}  // catch:  CException
	}  // if:  base class method was successful

	return bSuccess;

}  //*** CGroupGeneralPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupGeneralPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupGeneralPage::DoDataExchange(CDataExchange * pDX)
{
	CBasePropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGroupGeneralPage)
	DDX_Control(pDX, IDC_PP_GROUP_PREF_OWNERS_MODIFY, m_pbPrefOwnersModify);
	DDX_Control(pDX, IDC_PP_GROUP_PREF_OWNERS, m_lbPrefOwners);
	DDX_Control(pDX, IDC_PP_GROUP_DESC, m_editDesc);
	DDX_Control(pDX, IDC_PP_GROUP_NAME, m_editName);
	DDX_Text(pDX, IDC_PP_GROUP_NAME, m_strName);
	DDX_Text(pDX, IDC_PP_GROUP_DESC, m_strDesc);
	DDX_Text(pDX, IDC_PP_GROUP_CURRENT_STATE, m_strState);
	DDX_Text(pDX, IDC_PP_GROUP_CURRENT_NODE, m_strNode);
	//}}AFX_DATA_MAP

	if (pDX->m_bSaveAndValidate)
	{
		if (!BReadOnly())
		{
			try
			{
				PciGroup()->ValidateCommonProperties(
								m_strDesc,
								PciGroup()->NFailoverThreshold(),
								PciGroup()->NFailoverPeriod(),
								PciGroup()->CgaftAutoFailbackType(),
								PciGroup()->NFailbackWindowStart(),
								PciGroup()->NFailbackWindowEnd()
								);
			}  // try
			catch (CException * pe)
			{
				pe->ReportError();
				pe->Delete();
				pDX->Fail();
			}  // catch:  CException
		}  // if:  not read only
	}  // if:  saving data from dialog
	else
	{
		FillPrefOwners();
	}  // else:  setting data to dialog

}  //*** CGroupGeneralPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupGeneralPage::FillPrefOwners
//
//	Routine Description:
//		Fill the Preferred Owners list box.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupGeneralPage::FillPrefOwners(void)
{
	POSITION		posPci;
	CClusterNode *	pciNode;
	int				iitem;

	m_lbPrefOwners.ResetContent();

	posPci = LpciPreferredOwners().GetHeadPosition();
	while (posPci != NULL)
	{
		pciNode = (CClusterNode *) LpciPreferredOwners().GetNext(posPci);
		iitem = m_lbPrefOwners.AddString(pciNode->StrName());
		if (iitem >= 0)
			m_lbPrefOwners.SetItemDataPtr(iitem, pciNode);
	}  // for:  each string in the list

}  //*** CGroupGeneralPage::FillPrefOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupGeneralPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Focus needs to be set.
//		FALSE	Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupGeneralPage::OnInitDialog(void)
{
	CBasePropertyPage::OnInitDialog();

	// If read-only, set all controls to be either disabled or read-only.
	if (BReadOnly())
	{
		m_editName.SetReadOnly(TRUE);
		m_editDesc.SetReadOnly(TRUE);
		m_pbPrefOwnersModify.EnableWindow(FALSE);
	}  // if:  sheet is read-only

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CGroupGeneralPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupGeneralPage::OnApply
//
//	Routine Description:
//		Handler for when the Apply button is pressed.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupGeneralPage::OnApply(void)
{
	// Set the data from the page in the cluster item.
	try
	{
		CWaitCursor	wc;

		PciGroup()->SetName(m_strName);
		PciGroup()->SetCommonProperties(
						m_strDesc,
						PciGroup()->NFailoverThreshold(),
						PciGroup()->NFailoverPeriod(),
						PciGroup()->CgaftAutoFailbackType(),
						PciGroup()->NFailbackWindowStart(),
						PciGroup()->NFailbackWindowEnd()
						);
		PciGroup()->SetPreferredOwners(m_lpciPreferredOwners);
	}  // try
	catch (CException * pe)
	{
		pe->ReportError();
		pe->Delete();
		return FALSE;
	}  // catch:  CException

	return CBasePropertyPage::OnApply();

}  //*** CGroupGeneralPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupGeneralPage::OnProperties
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the Properties button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupGeneralPage::OnProperties(void)
{
	int				iitem;
	CClusterNode *	pciNode;

	// Get the item with the focus.
	iitem = m_lbPrefOwners.GetCurSel();
	ASSERT(iitem >= 0);

	if (iitem >= 0)
	{
		// Get the node pointer.
		pciNode = (CClusterNode *) m_lbPrefOwners.GetItemDataPtr(iitem);
		ASSERT_VALID(pciNode);

		// Set properties of that item.
		if (pciNode->BDisplayProperties())
		{
		}  // if:  properties changed
	}  // if:  found an item with focus

}  //*** CGroupGeneralPage::OnProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupGeneralPage::OnContextMenu
//
//	Routine Description:
//		Handler for the WM_CONTEXTMENU method.
//
//	Arguments:
//		pWnd		Window in which the user right clicked the mouse.
//		point		Position of the cursor, in screen coordinates.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupGeneralPage::OnContextMenu( CWnd * pWnd, CPoint point )
{
	BOOL			bHandled	= FALSE;
	CMenu *			pmenu		= NULL;
	CListBox *		pListBox	= (CListBox *) pWnd;
	CString			strMenuName;
	CWaitCursor		wc;

	// If focus is not in the list control, don't handle the message.
	if ( pWnd == &m_lbPrefOwners )
	{
		// Create the menu to display.
		try
		{
			pmenu = new CMenu;
            if ( pmenu == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the menu

			if ( pmenu->CreatePopupMenu() )
			{
				UINT	nFlags	= MF_STRING;

				// If there are no items in the list, disable the menu item.
				if ( pListBox->GetCount() == 0 )
                {
					nFlags |= MF_GRAYED;
                } // if: no items in the list

				// Add the Properties item to the menu.
				strMenuName.LoadString( IDS_MENU_PROPERTIES );
				if ( pmenu->AppendMenu( nFlags, ID_FILE_PROPERTIES, strMenuName ) )
				{
					bHandled = TRUE;
					if ( pListBox->GetCurSel() == -1 )
                    {
						pListBox->SetCurSel( 0 );
                    } // if: no item selected
				}  // if:  successfully added menu item
			}  // if:  menu created successfully
		}  // try
		catch ( CException * pe )
		{
			pe->ReportError();
			pe->Delete();
		}  // catch:  CException
	}  // if:  focus is on the list control

	if ( bHandled )
	{
		// Display the menu.
		if ( ! pmenu->TrackPopupMenu(
						TPM_LEFTALIGN | TPM_RIGHTBUTTON,
						point.x,
						point.y,
						this
						) )
		{
		}  // if:  unsuccessfully displayed the menu
	}  // if:  there is a menu to display
	else
    {
		CBasePropertyPage::OnContextMenu( pWnd, point );
    } // else: no menu to display

	delete pmenu;

}  //*** CGroupGeneralPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupGeneralPage::OnModifyPreferredOwners
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the Modify Preferred Owners button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupGeneralPage::OnModifyPreferredOwners(void)
{
	CModifyNodesDlg	dlg(
						IDD_MODIFY_PREFERRED_OWNERS,
						g_aHelpIDs_IDD_MODIFY_PREFERRED_OWNERS,
						m_lpciPreferredOwners,
						PciGroup()->Pdoc()->LpciNodes(),
						LCPS_SHOW_IMAGES | LCPS_ALLOW_EMPTY | LCPS_CAN_BE_ORDERED | LCPS_ORDERED
						);

	if (dlg.DoModal() == IDOK)
	{
		SetModified(TRUE);
		FillPrefOwners();
	}  // if:  OK button pressed

}  //*** CGroupGeneralPage::OnModifyPreferredOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupGeneralPage::OnDblClkPreferredOwners
//
//	Routine Description:
//		Handler for the LBN_DBLCLK message on the Preferred Owners listbox.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupGeneralPage::OnDblClkPreferredOwners(void)
{
	OnProperties();

}  //*** CGroupGeneralPage::OnDblClkPreferredOwners()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CGroupFailoverPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CGroupFailoverPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CGroupFailoverPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CGroupFailoverPage)
	//}}AFX_MSG_MAP
	ON_EN_CHANGE(IDC_PP_GROUP_FAILOVER_THRESH, CBasePropertyPage::OnChangeCtrl)
	ON_EN_CHANGE(IDC_PP_GROUP_FAILOVER_PERIOD, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailoverPage::CGroupFailoverPage
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGroupFailoverPage::CGroupFailoverPage(void)
	: CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_GROUP_FAILOVER)
{
	//{{AFX_DATA_INIT(CGroupFailoverPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

}  //*** CGroupFailoverPage::CGroupFailoverPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailoverPage::BInit
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		psht		[IN OUT] Property sheet to which this page belongs.
//
//	Return Value:
//		TRUE		Page initialized successfully.
//		FALSE		Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailoverPage::BInit(IN OUT CBaseSheet * psht)
{
	BOOL	fSuccess;

	ASSERT_KINDOF(CGroupPropSheet, psht);

	fSuccess = CBasePropertyPage::BInit(psht);

	m_nThreshold= PciGroup()->NFailoverThreshold();
	m_nPeriod= PciGroup()->NFailoverPeriod();

	return fSuccess;

}  //*** CBasePropertyPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailoverPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupFailoverPage::DoDataExchange(CDataExchange* pDX)
{
	CBasePropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGroupFailoverPage)
	DDX_Control(pDX, IDC_PP_GROUP_FAILOVER_THRESH, m_editThreshold);
	DDX_Control(pDX, IDC_PP_GROUP_FAILOVER_PERIOD, m_editPeriod);
	//}}AFX_DATA_MAP

	if (pDX->m_bSaveAndValidate)
	{
		if (!BReadOnly())
		{
			DDX_Number(
				pDX,
				IDC_PP_GROUP_FAILOVER_THRESH,
				m_nThreshold,
				CLUSTER_GROUP_MINIMUM_FAILOVER_THRESHOLD,
				CLUSTER_GROUP_MAXIMUM_FAILOVER_THRESHOLD
				);
			DDX_Number(
				pDX,
				IDC_PP_GROUP_FAILOVER_PERIOD,
				m_nPeriod,
				CLUSTER_GROUP_MINIMUM_FAILOVER_PERIOD,
				CLUSTER_GROUP_MAXIMUM_FAILOVER_PERIOD
				);

			try
			{
				PciGroup()->ValidateCommonProperties(
								PciGroup()->StrDescription(),
								m_nThreshold,
								m_nPeriod,
								PciGroup()->CgaftAutoFailbackType(),
								PciGroup()->NFailbackWindowStart(),
								PciGroup()->NFailbackWindowEnd()
								);
			}  // try
			catch (CException * pe)
			{
				pe->ReportError();
				pe->Delete();
				pDX->Fail();
			}  // catch:  CException
		}  // if:  not read only
	}  // if:  saving data from dialog
	else
	{
		DDX_Number(
			pDX,
			IDC_PP_GROUP_FAILOVER_THRESH,
			m_nThreshold,
			CLUSTER_GROUP_MINIMUM_FAILOVER_THRESHOLD,
			CLUSTER_GROUP_MAXIMUM_FAILOVER_THRESHOLD
			);
		DDX_Number(
			pDX,
			IDC_PP_GROUP_FAILOVER_PERIOD,
			m_nPeriod,
			CLUSTER_GROUP_MINIMUM_FAILOVER_PERIOD,
			CLUSTER_GROUP_MAXIMUM_FAILOVER_PERIOD
			);
	}  // else:  setting data to dialog

}  //*** CGroupFailoverPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailoverPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Focus needs to be set.
//		FALSE	Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailoverPage::OnInitDialog(void)
{
	CBasePropertyPage::OnInitDialog();

	// If read-only, set all controls to be either disabled or read-only.
	if (BReadOnly())
	{
		m_editPeriod.SetReadOnly(TRUE);
		m_editThreshold.SetReadOnly(TRUE);
	}  // if:  sheet is read-only

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CGroupFailoverPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailoverPage::OnApply
//
//	Routine Description:
//		Handler for when the Apply button is pressed.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailoverPage::OnApply(void)
{
	// Set the data from the page in the cluster item.
	try
	{
		CWaitCursor	wc;

		PciGroup()->SetCommonProperties(
						PciGroup()->StrDescription(),
						m_nThreshold,
						m_nPeriod,
						PciGroup()->CgaftAutoFailbackType(),
						PciGroup()->NFailbackWindowStart(),
						PciGroup()->NFailbackWindowEnd()
						);
	}  // try
	catch (CException * pe)
	{
		pe->ReportError();
		pe->Delete();
		return FALSE;
	}  // catch:  CException

	return CBasePropertyPage::OnApply();

}  //*** CGroupFailoverPage::OnApply()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CGroupFailbackPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CGroupFailbackPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CGroupFailbackPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CGroupFailbackPage)
	ON_BN_CLICKED(IDC_PP_GROUP_AUTOFB_PREVENT, OnClickedPreventFailback)
	ON_BN_CLICKED(IDC_PP_GROUP_AUTOFB_ALLOW, OnClickedAllowFailback)
	ON_BN_CLICKED(IDC_PP_GROUP_FB_IMMED, OnClickedFailbackImmediate)
	ON_BN_CLICKED(IDC_PP_GROUP_FB_WINDOW, OnClickedFailbackInWindow)
	//}}AFX_MSG_MAP
	ON_EN_CHANGE(IDC_PP_GROUP_FBWIN_START, CBasePropertyPage::OnChangeCtrl)
	ON_EN_CHANGE(IDC_PP_GROUP_FBWIN_END, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailbackPage::CGroupFailbackPage
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGroupFailbackPage::CGroupFailbackPage(void)
	: CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_GROUP_FAILBACK)
{
	//{{AFX_DATA_INIT(CGroupFailbackPage)
	//}}AFX_DATA_INIT

	m_nStart = CLUSTER_GROUP_FAILBACK_WINDOW_NONE;
	m_nEnd = CLUSTER_GROUP_FAILBACK_WINDOW_NONE;

}  //*** CGroupFailbackPage::CGroupFailbackPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailbackPage::BInit
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		psht		[IN OUT] Property sheet to which this page belongs.
//
//	Return Value:
//		TRUE		Page initialized successfully.
//		FALSE		Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailbackPage::BInit(IN OUT CBaseSheet * psht)
{
	BOOL	bSuccess;

	ASSERT_KINDOF(CGroupPropSheet, psht);

	bSuccess = CBasePropertyPage::BInit(psht);

	m_cgaft = PciGroup()->CgaftAutoFailbackType();
	m_nStart = PciGroup()->NFailbackWindowStart();
	m_nEnd = PciGroup()->NFailbackWindowEnd();
	m_bNoFailbackWindow = ((m_cgaft == ClusterGroupPreventFailback)
								|| (m_nStart == CLUSTER_GROUP_FAILBACK_WINDOW_NONE)
								|| (m_nEnd == CLUSTER_GROUP_FAILBACK_WINDOW_NONE));

	return bSuccess;

}  //*** CGroupFailbackPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailbackPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupFailbackPage::DoDataExchange(CDataExchange * pDX)
{
	CBasePropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGroupFailbackPage)
	DDX_Control(pDX, IDC_PP_GROUP_AUTOFB_PREVENT, m_rbPreventFailback);
	DDX_Control(pDX, IDC_PP_GROUP_AUTOFB_ALLOW, m_rbAllowFailback);
	DDX_Control(pDX, IDC_PP_GROUP_FB_IMMED, m_rbFBImmed);
	DDX_Control(pDX, IDC_PP_GROUP_FB_WINDOW, m_rbFBWindow);
	DDX_Control(pDX, IDC_PP_GROUP_FB_WINDOW_LABEL1, m_staticFBWindow1);
	DDX_Control(pDX, IDC_PP_GROUP_FB_WINDOW_LABEL2, m_staticFBWindow2);
	DDX_Control(pDX, IDC_PP_GROUP_FBWIN_START, m_editStart);
	DDX_Control(pDX, IDC_PP_GROUP_FBWIN_START_SPIN, m_spinStart);
	DDX_Control(pDX, IDC_PP_GROUP_FBWIN_END, m_editEnd);
	DDX_Control(pDX, IDC_PP_GROUP_FBWIN_END_SPIN, m_spinEnd);
	//}}AFX_DATA_MAP

	if (pDX->m_bSaveAndValidate)
	{
		if (!BReadOnly())
		{
			if ((m_cgaft == ClusterGroupAllowFailback) && !m_bNoFailbackWindow)
			{
				DDX_Number(pDX, IDC_PP_GROUP_FBWIN_START, m_nStart, 0, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_START);
				DDX_Number(pDX, IDC_PP_GROUP_FBWIN_END, m_nEnd, 0, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_END);
				if (m_nStart == m_nEnd)
				{
					AfxMessageBox(IDS_SAME_START_AND_END, MB_OK | MB_ICONEXCLAMATION);
					pDX->Fail();
				}  // if:  values are the same
			}  // if:  failback is allowed and failback window desired

			try
			{
				PciGroup()->ValidateCommonProperties(
								PciGroup()->StrDescription(),
								PciGroup()->NFailoverThreshold(),
								PciGroup()->NFailoverPeriod(),
								m_cgaft,
								m_nStart,
								m_nEnd
								);
			}  // try
			catch (CException * pe)
			{
				pe->ReportError();
				pe->Delete();
				pDX->Fail();
			}  // catch:  CException
		}  // if:  not read only
	}  // if:  saving data
	else
	{
		if (m_cgaft == ClusterGroupPreventFailback)
		{
			m_rbPreventFailback.SetCheck(BST_CHECKED);
			m_rbAllowFailback.SetCheck(BST_UNCHECKED);
			OnClickedPreventFailback();
		}  // if:  failbacks are not allowed
		else
		{
			m_rbPreventFailback.SetCheck(BST_UNCHECKED);
			m_rbAllowFailback.SetCheck(BST_CHECKED);
			OnClickedAllowFailback();
		}  // else:  failbacks are allowed
		m_rbFBImmed.SetCheck(m_bNoFailbackWindow ? BST_CHECKED : BST_UNCHECKED);
		m_rbFBWindow.SetCheck(m_bNoFailbackWindow ? BST_UNCHECKED : BST_CHECKED);

		// Set up the Start and End window controls.
		DDX_Number(pDX, IDC_PP_GROUP_FBWIN_START, m_nStart, 0, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_START);
		DDX_Number(pDX, IDC_PP_GROUP_FBWIN_END, m_nEnd, 0, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_END);
		m_spinStart.SetRange(0, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_START);
		m_spinEnd.SetRange(0, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_END);
		if (m_nStart == CLUSTER_GROUP_FAILBACK_WINDOW_NONE)
			m_editStart.SetWindowText(TEXT(""));
		if (m_nEnd == CLUSTER_GROUP_FAILBACK_WINDOW_NONE)
			m_editEnd.SetWindowText(TEXT(""));
	}  // else:  not saving data

}  //*** CGroupFailbackPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailbackPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Focus needs to be set.
//		FALSE	Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailbackPage::OnInitDialog(void)
{
	CBasePropertyPage::OnInitDialog();

	// If read-only, set all controls to be either disabled or read-only.
	if (BReadOnly())
	{
		m_rbPreventFailback.EnableWindow(FALSE);
		m_rbAllowFailback.EnableWindow(FALSE);
		m_rbFBImmed.EnableWindow(FALSE);
		m_rbFBWindow.EnableWindow(FALSE);
		m_staticFBWindow1.EnableWindow(FALSE);
		m_staticFBWindow2.EnableWindow(FALSE);
		m_spinStart.EnableWindow(FALSE);
		m_spinEnd.EnableWindow(FALSE);
		m_editStart.SetReadOnly(TRUE);
		m_editEnd.SetReadOnly(TRUE);
	}  // if:  sheet is read-only

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CGroupFailbackPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailbackPage::OnApply
//
//	Routine Description:
//		Handler for when the Apply button is pressed.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailbackPage::OnApply(void)
{
	// Set the data from the page in the cluster item.
	try
	{
		CWaitCursor	wc;

		if (m_bNoFailbackWindow)
		{
			m_nStart = CLUSTER_GROUP_FAILBACK_WINDOW_NONE;
			m_nEnd = CLUSTER_GROUP_FAILBACK_WINDOW_NONE;
		}  // if:  no failback window
		PciGroup()->SetCommonProperties(
						PciGroup()->StrDescription(),
						PciGroup()->NFailoverThreshold(),
						PciGroup()->NFailoverPeriod(),
						m_cgaft,
						m_nStart,
						m_nEnd
						);
	}  // try
	catch (CException * pe)
	{
		pe->ReportError();
		pe->Delete();
		return FALSE;
	}  // catch:  CException

	return CBasePropertyPage::OnApply();

}  //*** CGroupFailbackPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailbackPage::OnClickedPreventFailback
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the Prevent Failback radio button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupFailbackPage::OnClickedPreventFailback(void)
{
	// Disable the Failback Window controls.
	m_rbFBImmed.EnableWindow(FALSE);
	m_rbFBWindow.EnableWindow(FALSE);
	m_staticFBWindow1.EnableWindow(FALSE);
	m_staticFBWindow2.EnableWindow(FALSE);

	OnClickedFailbackImmediate();

	// Call the base class method if the state changed.
	if (m_cgaft != ClusterGroupPreventFailback)
	{
		CBasePropertyPage::OnChangeCtrl();
		m_cgaft = ClusterGroupPreventFailback;
	}  // if:  state changed

}  //*** CGroupFailbackPage::OnClickedPreventFailback()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailbackPage::OnClickedAllowFailback
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the Allow Failback radio button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupFailbackPage::OnClickedAllowFailback(void)
{
	// Enable the Failback Window controls.
	m_rbFBImmed.EnableWindow(TRUE);
	m_rbFBWindow.EnableWindow(TRUE);
	m_staticFBWindow1.EnableWindow(TRUE);
	m_staticFBWindow2.EnableWindow(TRUE);

	if (m_bNoFailbackWindow)
		OnClickedFailbackImmediate();
	else
		OnClickedFailbackInWindow();

	// Call the base class method if the state changed.
	if (m_cgaft != ClusterGroupAllowFailback)
	{
		CBasePropertyPage::OnChangeCtrl();
		m_cgaft = ClusterGroupAllowFailback;
	}  // if:  state changed

}  //*** CGroupFailbackPage::OnClickedAllowFailback()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailbackPage::OnClickedFailbackImmediate
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the Failback Immediately radio button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupFailbackPage::OnClickedFailbackImmediate(void)
{
	// Disable the Failback Window controls.
	m_editStart.EnableWindow(FALSE);
	m_spinStart.EnableWindow(FALSE);
	m_editEnd.EnableWindow(FALSE);
	m_spinEnd.EnableWindow(FALSE);

	// Call the base class method if the state changed.
	if (!m_bNoFailbackWindow)
		CBasePropertyPage::OnChangeCtrl();

	m_bNoFailbackWindow = TRUE;

}  //*** CGroupFailbackPage::OnClickedFailbackImmediate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroupFailbackPage::OnClickedFailbackInWindow
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the Failback In Window radio button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupFailbackPage::OnClickedFailbackInWindow(void)
{
	// Enable the Failback Window controls.
	m_editStart.EnableWindow(TRUE);
	m_spinStart.EnableWindow(TRUE);
	m_editEnd.EnableWindow(TRUE);
	m_spinEnd.EnableWindow(TRUE);

	if (m_bNoFailbackWindow)
	{
		// Set the values of the edit controls.
		if (m_nStart == CLUSTER_GROUP_FAILBACK_WINDOW_NONE)
			SetDlgItemInt(IDC_PP_GROUP_FBWIN_START, 0, FALSE);
		if (m_nEnd == CLUSTER_GROUP_FAILBACK_WINDOW_NONE)
			SetDlgItemInt(IDC_PP_GROUP_FBWIN_END, 0, FALSE);

		// Call the base class method.
		CBasePropertyPage::OnChangeCtrl();
	}  // if:  state changed

	m_bNoFailbackWindow = FALSE;

}  //*** CGroupFailbackPage::OnClickedFailbackInWindow()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\extdll.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ExtDll.cpp
//
//  Abstract:
//      Implementation of the extension DLL classes.
//
//  Author:
//      David Potter (davidp)   May 31, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <CluAdmEx.h>
#include "CluAdmID.h"
#include "ExtDll.h"
#include "CluAdmin.h"
#include "ExtMenu.h"
#include "TraceTag.h"
#include "ExcOper.h"
#include "ClusItem.h"
#include "BaseSht.h"
#include "BasePSht.h"
#include "BaseWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagExtDll(_T("UI"), _T("EXTENSION DLL"), 0);
CTraceTag   g_tagExtDllRef(_T("UI"), _T("EXTENSION DLL References"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CExtensions
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CExtensions, CObject);

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::CExtensions
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtensions::CExtensions(void)
{
    m_pci   = NULL;
    m_hfont = NULL;
    m_hicon = NULL;

    m_pdoData = NULL;
    m_plextdll = NULL;
    m_psht = NULL;
    m_pmenu = NULL;
    m_plMenuItems = NULL;

    m_nFirstCommandID = (ULONG) -1;
    m_nNextCommandID = (ULONG) -1;
    m_nFirstMenuID = (ULONG) -1;
    m_nNextMenuID = (ULONG) -1;

}  //*** CExtensions::CExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::~CExtensions
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtensions::~CExtensions(void)
{
    UnloadExtensions();

}  //*** CExtensions::~CExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::Init
//
//  Routine Description:
//      Common initialize for all interfaces.
//
//  Arguments:
//      rlstrExtensions [IN] List of extension CLSID strings.
//      pci             [IN OUT] Cluster item to be administered.
//      hfont           [IN] Font for dialog text.
//      hicon           [IN] Icon for upper left corner.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by new.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensions::Init(
    IN const CStringList &  rlstrExtensions,
    IN OUT CClusterItem *   pci,
    IN HFONT                hfont,
    IN HICON                hicon
    )
{
    CWaitCursor     wc;

    ASSERT( rlstrExtensions.GetCount() > 0 );

    UnloadExtensions();

    // Save parameters.
    m_plstrExtensions = &rlstrExtensions;
    m_pci = pci;
    m_hfont = hfont;
    m_hicon = hicon;

    // Allocate a new Data Object.
    m_pdoData = new CComObject< CDataObject >;
    if ( m_pdoData == NULL )
    {
        AfxThrowMemoryException();
    } // if: error allocating memory
    m_pdoData->AddRef();

    // Construct the Data Object.
    Pdo()->Init( pci, GetClusterAdminApp()->Lcid(), hfont, hicon );

    // Allocate the extension list.
    m_plextdll = new CExtDllList;
    if ( m_plextdll == NULL )
    {
        AfxThrowMemoryException();
    } // if: error allocating memory
    ASSERT( Plextdll() != NULL );

    // Loop through the extensions and load each one.
    {
        CComObject<CExtensionDll> * pextdll = NULL;
        POSITION                    posName;

        Trace( g_tagExtDll, _T("CExtensions::Init() - %d extensions"), rlstrExtensions.GetCount() );
        posName = rlstrExtensions.GetHeadPosition();
        while ( posName != NULL )
        {
            // Allocate an extension DLL object and add it to the list.
            pextdll = new CComObject< CExtensionDll >;
            if ( pextdll == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating memory
            pextdll->AddRef();
            Plextdll()->AddTail( pextdll );
            try
            {
                pextdll->Init( rlstrExtensions.GetNext( posName ), this );
            }  // try
            catch ( CException * pe )
            {
                POSITION    pos;

                pe->ReportError();
                pe->Delete();

                pos = Plextdll()->Find(pextdll);
                ASSERT( pos != NULL );
                Plextdll()->RemoveAt( pos );
                delete pextdll;
            }  // catch:  anything
        }  // while:  more items in the list
    }  // Loop through the extensions and load each one

}  //*** CExtensions::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::UnloadExtensions
//
//  Routine Description:
//      Unload the extension DLL.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensions::UnloadExtensions(void)
{
    // Delete all the extension DLL objects.
    if (Plextdll() != NULL)
    {
        POSITION                    pos;
        CComObject<CExtensionDll> * pextdll;

        pos = Plextdll()->GetHeadPosition();
        while (pos != NULL)
        {
            pextdll = Plextdll()->GetNext(pos);
            pextdll->AddRef(); // See comment below.
            pextdll->UnloadExtension();
            if (pextdll->m_dwRef != 2)
            {
                Trace(g_tagError, _T("CExtensions::UnloadExtensions() - Extension DLL has ref count = %d"), pextdll->m_dwRef);
            }

            // We added a reference above.  Combined with the reference that
            // was added when the object was created, we typically will need
            // to release two references.  However, due to bogus code
            // generated by earlier versions of the custom AppWizard where the
            // extension was releasing the interface but not zeroing out its
            // pointer in the error case, we may not need to release the
            // second reference.
            if (pextdll->Release() != 0)
            {
                pextdll->Release();
            } // if: more references to release
        }  // while:  more items in the list
        delete m_plextdll;
        m_plextdll = NULL;
    }  // if:  there is a list of extensions

    if (m_pdoData != NULL)
    {
        if (m_pdoData->m_dwRef != 1)
        {
            Trace(g_tagError, _T("CExtensions::UnloadExtensions() - Data Object has ref count = %d"), m_pdoData->m_dwRef);
        }
        m_pdoData->Release();
        m_pdoData = NULL;
    }  // if:  data object allocated

    m_pci = NULL;
    m_hfont = NULL;
    m_hicon = NULL;

    // Delete all menu items.
    if (PlMenuItems() != NULL)
    {
        POSITION        pos;
        CExtMenuItem *  pemi;

        pos = PlMenuItems()->GetHeadPosition();
        while (pos != NULL)
        {
            pemi = PlMenuItems()->GetNext(pos);
            delete pemi;
        }  // while:  more items in the list
        delete m_plMenuItems;
        m_plMenuItems = NULL;
    }  // if:  there is a list of menu items

}  //*** CExtensions::UnloadExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::CreatePropertySheetPages
//
//  Routine Description:
//      Add pages to a property sheet.
//
//  Arguments:
//      psht            [IN OUT] Property sheet to which pages are to be added.
//      rlstrExtensions [IN] List of extension CLSID strings.
//      pci             [IN OUT] Cluster item to be administered.
//      hfont           [IN] Font for dialog text.
//      hicon           [IN] Icon for upper left corner.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CExtensionDll::AddPages().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensions::CreatePropertySheetPages(
    IN OUT CBasePropertySheet * psht,
    IN const CStringList &      rlstrExtensions,
    IN OUT CClusterItem *       pci,
    IN HFONT                    hfont,
    IN HICON                    hicon
    )
{
    POSITION                    pos;
    CComObject<CExtensionDll> * pextdll;

    ASSERT_VALID(psht);

    m_psht = psht;

    // Initialize for all extensions.
    Init(rlstrExtensions, pci, hfont, hicon);
    ASSERT(Plextdll() != NULL);

    pos = Plextdll()->GetHeadPosition();
    while (pos != NULL)
    {
        pextdll = Plextdll()->GetNext(pos);
        ASSERT_VALID(pextdll);
        try
        {
            pextdll->CreatePropertySheetPages();
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CNTException
    }  // while:  more items in the list

}  //*** CExtensions::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::CreateWizardPages
//
//  Routine Description:
//      Add pages to a wizard.
//
//  Arguments:
//      psht            [IN OUT] Property sheet to which pages are to be added.
//      rlstrExtensions [IN] List of extension CLSID strings.
//      pci             [IN OUT] Cluster item to be administered.
//      hfont           [IN] Font for dialog text.
//      hicon           [IN] Icon for upper left corner.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CExtensionDll::AddPages().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensions::CreateWizardPages(
    IN OUT CBaseWizard *    psht,
    IN const CStringList &  rlstrExtensions,
    IN OUT CClusterItem *   pci,
    IN HFONT                hfont,
    IN HICON                hicon
    )
{
    POSITION                    pos;
    CComObject<CExtensionDll> * pextdll;

    ASSERT_VALID(psht);

    m_psht = psht;

    // Initialize for all extensions.
    Init(rlstrExtensions, pci, hfont, hicon);
    ASSERT(Plextdll() != NULL);

    pos = Plextdll()->GetHeadPosition();
    while (pos != NULL)
    {
        pextdll = Plextdll()->GetNext(pos);
        ASSERT_VALID(pextdll);
        try
        {
            pextdll->CreateWizardPages();
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CNTException
    }  // while:  more items in the list

}  //*** CExtensions::CreateWizardPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::AddContextMenuItems
//
//  Routine Description:
//      Query the extension DLL for new menu items to be added to the context
//      menu.
//
//  Arguments:
//      pmenu           [IN OUT] Menu to which items are to be added.
//      rlstrExtensions [IN] List of extension CLSID strings.
//      pci             [IN OUT] Cluster item to be administered.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CExtensionDll::AddContextMenuItems() or
//          CExtMenuItemList::new().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensions::AddContextMenuItems(
    IN OUT CMenu *          pmenu,
    IN const CStringList &  rlstrExtensions,
    IN OUT CClusterItem *   pci
    )
{
    POSITION                        pos;
    CComObject< CExtensionDll > *   pextdll;

    ASSERT(m_pmenu == NULL);
    ASSERT_VALID(pmenu);

    // Initialize for all extensions.
    Init( rlstrExtensions, pci, NULL, NULL );
    ASSERT( Plextdll() != NULL );

    m_pmenu = pmenu;
    m_nFirstCommandID = CAEXT_MENU_FIRST_ID;
    m_nNextCommandID = m_nFirstCommandID;
    m_nFirstMenuID = 0;
    m_nNextMenuID = m_nFirstMenuID;

    // Create the list of menu items.
    ASSERT( m_plMenuItems == NULL );
    m_plMenuItems = new CExtMenuItemList;
    if ( m_plMenuItems == NULL )
    {
        AfxThrowMemoryException();
    } // if: error allocating memory

    pos = Plextdll()->GetHeadPosition();
    while ( pos != NULL )
    {
        pextdll = Plextdll()->GetNext( pos );
        ASSERT_VALID( pextdll );
        try
        {
            pextdll->AddContextMenuItems();
        }  // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CNTException
    }  // while:  more items in the list

}  //*** CExtensions::AddContextMenuItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::BExecuteContextMenuItem
//
//  Routine Description:
//      Execute a command associated with a menu item added to a context menu
//      by the extension DLL.
//
//  Arguments:
//      nCommandID      [IN] Command ID for the menu item chosen by the user.
//
//  Return Value:
//      TRUE            Context menu item was executed.
//      FALSE           Context menu item was not executed.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CExceptionDll::BExecuteContextMenuItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtensions::BExecuteContextMenuItem(IN ULONG nCommandID)
{
    BOOL            bHandled    = FALSE;
    HRESULT         hr;
    CExtMenuItem *  pemi;

    // Find the item in our list.
    pemi = PemiFromCommandID(nCommandID);
    if (pemi != NULL)
    {
        Pdo()->AddRef();
        hr = pemi->PiCommand()->InvokeCommand(pemi->NExtCommandID(), Pdo()->GetUnknown());
        if (hr == NOERROR)
            bHandled = TRUE;
    }  // if:  found an item for the command ID

    return bHandled;

}  //*** CExtensions::BExecuteContextMenuItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::BGetCommandString
//
//  Routine Description:
//      Get a command string from a menu ID.
//
//  Arguments:
//      nCommandID      [IN] Command ID for the menu item.
//      rstrMessage     [OUT] String in which to return the message.
//
//  Return Value:
//      TRUE            String is being returned.
//      FALSE           No string is being returned.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CExtensionDll::BGetCommandString().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtensions::BGetCommandString(
    IN ULONG        nCommandID,
    OUT CString &   rstrMessage
    )
{
    BOOL            bHandled    = FALSE;
    CExtMenuItem *  pemi;

    // Find the item in our list.
    pemi = PemiFromCommandID(nCommandID);
    if (pemi != NULL)
    {
        rstrMessage = pemi->StrStatusBarText();
        bHandled = TRUE;
    }  // if:  found an item for the command ID

    return bHandled;

}  //*** CExtensions::BGetCommandString()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::OnUpdateCommand
//
//  Routine Description:
//      Determines whether extension DLL menu items should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CExtensionDll::BOnUpdateCommand().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensions::OnUpdateCommand(CCmdUI * pCmdUI)
{
    CExtMenuItem *  pemi;

    ASSERT(Plextdll() != NULL);

    // Find the item in our list.
    Trace(g_tagExtDll, _T("OnUpdateCommand() - ID = %d"), pCmdUI->m_nID);
    pemi = PemiFromCommandID(pCmdUI->m_nID);
    if (pemi != NULL)
    {
        Trace(g_tagExtDll, _T("OnUpdateCommand() - Found a match with '%s' ExtID = %d"), pemi->StrName(), pemi->NExtCommandID());
        pCmdUI->Enable();
    }  // if:  found an item for the command ID

}  //*** CExtensions::OnUpdateCommand()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.  Attempts to pass them on to a selected
//      item first.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtensions::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    return BExecuteContextMenuItem(nID);

}  //*** CExtensions::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::PemiFromCommandID
//
//  Routine Description:
//      Find the menu item for the specified command ID.
//
//  Arguments:
//      nCommandID      [IN] Command ID for the menu item.
//
//  Return Value:
//      pemi            Menu item or NULL if not found.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtMenuItem * CExtensions::PemiFromCommandID(IN ULONG nCommandID) const
{
    POSITION        pos;
    CExtMenuItem *  pemi;
    CExtMenuItem *  pemiReturn = NULL;

    if (PlMenuItems() != NULL)
    {
        pos = PlMenuItems()->GetHeadPosition();
        while (pos != NULL)
        {
            pemi = PlMenuItems()->GetNext(pos);
            ASSERT_VALID(pemi);
            if (pemi->NCommandID() == nCommandID)
            {
                pemiReturn = pemi;
                break;
            }  // if:  match was found
        }  // while:  more items in the list
    }  // if:  item list exists

    return pemiReturn;

}  //*** CExtensions::PemiFromCommandID()

#ifdef _DEBUG
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensions::PemiFromExtCommandID
//
//  Routine Description:
//      Find the menu item for the specified extension command ID.
//
//  Arguments:
//      nExtCommandID   [IN] Extension command ID for the menu item.
//
//  Return Value:
//      pemi            Menu item or NULL if not found.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtMenuItem * CExtensions::PemiFromExtCommandID(IN ULONG nExtCommandID) const
{
    POSITION        pos;
    CExtMenuItem *  pemi;
    CExtMenuItem *  pemiReturn = NULL;

    if (PlMenuItems() != NULL)
    {
        pos = PlMenuItems()->GetHeadPosition();
        while (pos != NULL)
        {
            pemi = PlMenuItems()->GetNext(pos);
            ASSERT_VALID(pemi);
            if (pemi->NExtCommandID() == nExtCommandID)
            {
                pemiReturn = pemi;
                break;
            }  // if:  match was found
        }  // while:  more items in the list
    }  // if:  item list exists

    return pemiReturn;

}  //*** CExtensions::PemiFromExtCommandID()
#endif


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CComObject<CExtensionDll>
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CExtensionDll, CObject);

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CoCluAdmin, CExtensionDll)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::CExtensionDll
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtensionDll::CExtensionDll(void)
{
    m_piExtendPropSheet = NULL;
    m_piExtendWizard = NULL;
    m_piExtendContextMenu = NULL;
    m_piInvokeCommand = NULL;

    m_pext = NULL;

    m_pModuleState = AfxGetModuleState();
    ASSERT(m_pModuleState != NULL);

}  //*** CExtensionDll::CExtensionDll()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::~CExtensionDll
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtensionDll::~CExtensionDll(void)
{
    UnloadExtension();
    m_pModuleState = NULL;

}  //*** CExtensionDll::~CExtensionDll()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::Init
//
//  Routine Description:
//      Initialize this class in preparation for accessing the extension.
//
//  Arguments:
//      rstrCLSID       [IN] CLSID of the extension in string form.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    0 (error converting CLSID from string)
//      Any exceptions thrown by CString::operater=().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensionDll::Init(
    IN const CString &      rstrCLSID,
    IN OUT CExtensions *    pext
    )
{
    HRESULT     hr;
    CWaitCursor wc;

    ASSERT_VALID(pext);

    Trace(g_tagExtDll, _T("Init() - CLSID = %s"), rstrCLSID);

    // Save parameters.
    ASSERT(StrCLSID().IsEmpty() || (StrCLSID() == rstrCLSID));
    m_strCLSID = rstrCLSID;
    m_pext = pext;

    // Convert the CLSID string to a CLSID.
    hr = ::CLSIDFromString((LPWSTR) (LPCTSTR) rstrCLSID, &m_clsid);
    if (hr != S_OK)
        ThrowStaticException(hr, IDS_CLSIDFROMSTRING_ERROR, rstrCLSID);

}  //*** CExtensionDll::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::LoadInterface
//
//  Routine Description:
//      Load an extension DLL.
//
//  Arguments:
//      riid            [IN] Interface ID.
//
//  Return Value:
//      piUnk           IUnknown interface pointer for interface.
//
//  Exceptions Thrown:
//      CNTException    IDS_EXT_CREATE_INSTANCE_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
IUnknown * CExtensionDll::LoadInterface(IN const REFIID riid)
{
    HRESULT     hr;
    IUnknown *  piUnk;
    CWaitCursor wc;

    // Load the inproc server and get the IShellExtInit interface pointer.
    Trace(g_tagExtDllRef, _T("LoadInterface() - Getting interface pointer"));
    hr = ::CoCreateInstance(
                Rclsid(),
                NULL,
                CLSCTX_INPROC_SERVER,
                riid,
                (LPVOID *) &piUnk
                );
    if ((hr != S_OK)
            && (hr != REGDB_E_CLASSNOTREG)
            && (hr != E_NOINTERFACE)
            )
        ThrowStaticException(hr, IDS_EXT_CREATE_INSTANCE_ERROR, StrCLSID());

    return piUnk;

}  //*** CExtensionDll::LoadInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::UnloadExtension
//
//  Routine Description:
//      Unload the extension DLL.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensionDll::UnloadExtension(void)
{
    // Release the interface pointers in the opposite order in which they
    // were obtained.
    ReleaseInterface(&m_piExtendPropSheet);
    ReleaseInterface(&m_piExtendWizard);
    ReleaseInterface(&m_piExtendContextMenu);
    ReleaseInterface(&m_piInvokeCommand);

    m_strCLSID.Empty();

}  //*** CExtensionDll::UnloadExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::CreatePropertySheetPages
//
//  Routine Description:
//      Add pages to a property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    IDS_EXT_ADD_PAGES_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensionDll::CreatePropertySheetPages(void)
{
    HRESULT     hr;

    ASSERT_VALID(Pext());
    ASSERT(m_piExtendPropSheet == NULL);

    // Load the interface.
    m_piExtendPropSheet = (interface IWEExtendPropertySheet *) LoadInterface(IID_IWEExtendPropertySheet);
    if (m_piExtendPropSheet == NULL)
        return;
    ASSERT(m_piExtendPropSheet != NULL);

    // Add pages from the extension.
    GetUnknown()->AddRef(); // Add a reference because extension is going to release.
    Pdo()->AddRef();
    try
    {
        hr = PiExtendPropSheet()->CreatePropertySheetPages(Pdo()->GetUnknown(), this);
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch

    if ((hr != NOERROR) && (hr != E_NOTIMPL))
        ThrowStaticException(hr, IDS_EXT_ADD_PAGES_ERROR, StrCLSID());

}  //*** CExtensionDll::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::CreateWizardPages
//
//  Routine Description:
//      Add pages to a wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    IDS_EXT_ADD_PAGES_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensionDll::CreateWizardPages(void)
{
    HRESULT     hr;

    ASSERT_VALID(Pext());
    ASSERT(m_piExtendWizard == NULL);
    ASSERT_VALID(Psht());

    // Load the interface.
    m_piExtendWizard = (interface IWEExtendWizard *) LoadInterface(IID_IWEExtendWizard);
    if (m_piExtendWizard == NULL)
        return;
    ASSERT(m_piExtendWizard != NULL);

    // Add pages from the extension.
    GetUnknown()->AddRef(); // Add a reference because extension is going to release.
    Pdo()->AddRef();
    try
    {
        hr = PiExtendWizard()->CreateWizardPages(Pdo()->GetUnknown(), this);
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch

    if ((hr != NOERROR) && (hr != E_NOTIMPL))
        ThrowStaticException(hr, IDS_EXT_ADD_PAGES_ERROR, StrCLSID());

}  //*** CExtensionDll::CreateWizardPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::AddContextMenuItems
//
//  Routine Description:
//      Ask the extension DLL to add items to the menu.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    IDS_EXT_QUERY_CONTEXT_MENU_ERROR
//
//--
/////////////////////////////////////////////////////////////////////////////
void CExtensionDll::AddContextMenuItems(void)
{
    HRESULT     hr;

    ASSERT_VALID(Pext());
    ASSERT_VALID(Pmenu());
    ASSERT(m_piExtendContextMenu == NULL);

    // Load the interface.
    m_piExtendContextMenu = (interface IWEExtendContextMenu *) LoadInterface(IID_IWEExtendContextMenu);
    if (m_piExtendContextMenu == NULL)
        return;
    ASSERT(m_piExtendContextMenu != NULL);

    hr = PiExtendContextMenu()->QueryInterface(IID_IWEInvokeCommand, (LPVOID *) &m_piInvokeCommand);
    if (hr != NOERROR)
    {
        PiExtendContextMenu()->Release();
        m_piExtendContextMenu = NULL;
        ThrowStaticException(hr, IDS_EXT_QUERY_CONTEXT_MENU_ERROR, StrCLSID());
    }  // if:  error getting the InvokeCommand interface

    GetUnknown()->AddRef(); // Add a reference because extension is going to release.
    Pdo()->AddRef();
    Trace(g_tagExtDll, _T("CExtensionDll::AddContextMenuItem() - Adding context menu items from '%s'"), StrCLSID());
    try
    {
        hr = PiExtendContextMenu()->AddContextMenuItems(Pdo()->GetUnknown(), this);
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch
    if (hr != NOERROR)
        ThrowStaticException(hr, IDS_EXT_QUERY_CONTEXT_MENU_ERROR, StrCLSID());

    // Add a separator after the extension's items.
    Trace(g_tagExtDll, _T("CExtensionDll::AddContextMenuItem() - Adding separator"));
    try
    {
        hr = AddExtensionMenuItem(NULL, NULL, (ULONG) -1, 0, MF_SEPARATOR);
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch
    if (hr != NOERROR)
        ThrowStaticException(hr, IDS_EXT_QUERY_CONTEXT_MENU_ERROR, StrCLSID());

}  //*** CExtensionDll::AddContextMenuItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::InterfaceSupportsErrorInfo [ISupportsErrorInfo]
//
//  Routine Description:
//      Determines whether the interface supports error info (???).
//
//  Arguments:
//      riid        [IN] Reference to the interface ID.
//
//  Return Value:
//      S_OK        Interface supports error info.
//      S_FALSE     Interface does not support error info.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtensionDll::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID * rgiid[] =
    {
        &IID_IWCPropertySheetCallback,
        &IID_IWCWizardCallback,
        &IID_IWCContextMenuCallback,
    };
    int     iiid;

    for (iiid = 0 ; iiid < sizeof(rgiid) / sizeof(rgiid[0]) ; iiid++)
    {
        if (InlineIsEqualGUID(*rgiid[iiid], riid))
            return S_OK;
    }
    return S_FALSE;

}  //*** CExtensionDll::InterfaceSupportsErrorInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::AddPropertySheetPage [IWCPropertySheetCallback]
//
//  Routine Description:
//      Add a page to the property sheet.
//
//  Arguments:
//      hpage           [IN] Page to add.
//
//  Return Value:
//      NOERROR         Page added successfully.
//      E_INVALIDARG    NULL hpage.
//      Any hresult returned from CBasePropertySheet::HrAddPage().
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtensionDll::AddPropertySheetPage(
    IN LONG *   hpage
    )
{
    HRESULT     hr = NOERROR;

    AFX_MANAGE_STATE(m_pModuleState);

    ASSERT(hpage != NULL);
    ASSERT_VALID(Psht());

    // Do this for the release build.
    if ((hpage == NULL)
            || (Psht() == NULL))
        hr = E_INVALIDARG;
    else
        hr = Psht()->HrAddPage((HPROPSHEETPAGE) hpage);

    return hr;

}  //*** CExtensionDll::AddPropertySheetPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::AddWizardPage [IWCWizardCallback]
//
//  Routine Description:
//      Add a page to the wizard.
//
//  Arguments:
//      hpage           [IN] Page to add.
//
//  Return Value:
//      NOERROR         Page added successfully.
//      E_INVALIDARG    NULL hpage.
//      Any hresult returned from CBaseSheet::HrAddPage().
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtensionDll::AddWizardPage(
    IN LONG *   hpage
    )
{
    HRESULT     hr = NOERROR;

    AFX_MANAGE_STATE(m_pModuleState);

    ASSERT(hpage != NULL);
    ASSERT_VALID(Psht());

    // Do this for the release build.
    if ((hpage == NULL) || (Psht() == NULL))
        hr = E_INVALIDARG;
    else
        hr = Psht()->HrAddPage((HPROPSHEETPAGE) hpage);

    return hr;

}  //*** CExtensionDll::AddWizardPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::EnableNext [IWCWizardCallback]
//
//  Routine Description:
//      Enable or disable the NEXT button.  If it is the last page, the
//      FINISH button will be enabled or disabled.
//
//  Arguments:
//      hpage           [IN] Page for which the button is being enabled or
//                          disabled.
//      bEnable         [IN] TRUE = Enable the button, FALSE = disable.
//
//  Return Value:
//      NOERROR         Success.
//      E_INVALIDARG    Unknown hpage specified.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtensionDll::EnableNext(
    IN LONG *   hpage,
    IN BOOL     bEnable
    )
{
    HRESULT         hr              = NOERROR;
    CBaseWizard *   pwiz;
    DWORD           dwWizButtons;

    AFX_MANAGE_STATE(m_pModuleState);

    ASSERT(hpage != NULL);
    ASSERT_VALID(Psht());
    ASSERT_KINDOF(CBaseWizard, Psht());

    pwiz = (CBaseWizard *) Psht();

    // If this is the last extension page, enable/disable the FINISH button.
    {
        POSITION    pos;
        BOOL        bMatch  = FALSE;

        pos = pwiz->Lhpage().GetHeadPosition();
        while (pos != NULL)
        {
            if (pwiz->Lhpage().GetNext(pos) == hpage)
            {
                bMatch = TRUE;
                break;
            }  // if:  found a match
        }  // while:  more items in the list
        if (!bMatch)
            return E_INVALIDARG;
        if (pos == NULL)
            dwWizButtons = PSWIZB_BACK | (bEnable ? PSWIZB_FINISH : PSWIZB_DISABLEDFINISH);
        else
            dwWizButtons = PSWIZB_BACK | (bEnable ? PSWIZB_NEXT : 0);
    }  // If this is the last extension page, set the FINISH button

    // Set wizard buttons.
    pwiz->SetWizardButtons(dwWizButtons);

    return hr;

}  //*** CExtensionDll::EnableNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtensionDll::AddExtensionMenuItem [IWCContextMenuCallback]
//
//  Routine Description:
//      Add a page to the wizard.
//
//  Arguments:
//      lpszName            [IN] Name of item.
//      lpszStatusBarText   [IN] Text to appear on the status bar when the
//                              item is highlighted.
//      nCommandID          [IN] ID for the command when menu item is invoked.
//                              Must not be -1.
//      nSubmenuCommandID   [IN] ID for a submenu.
//      uFlags              [IN] Menu flags.  The following are not supportd:
//                              MF_OWNERDRAW, MF_POPUP
//
//  Return Value:
//      NOERROR             Item added successfully.
//      E_INVALIDARG        MF_OWNERDRAW or MF_POPUP were specified.
//      E_OUTOFMEMORY       Error allocating the item.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtensionDll::AddExtensionMenuItem(
    IN BSTR     lpszName,
    IN BSTR     lpszStatusBarText,
    IN ULONG    nCommandID,
    IN ULONG    nSubmenuCommandID,
    IN ULONG    uFlags
    )
{
    HRESULT         hr      = NOERROR;
    CExtMenuItem *  pemi    = NULL;

    AFX_MANAGE_STATE( m_pModuleState );

    ASSERT_VALID( Pext() );
    ASSERT( ! ( uFlags & (MF_OWNERDRAW | MF_POPUP) ) );
    ASSERT_VALID( Pmenu() );

    // Do this for the release build.
    if ( ( uFlags & (MF_OWNERDRAW | MF_POPUP) ) != 0 )
    {
        hr = E_INVALIDARG;
    } // if: trying to add invalid type of menu item
    else
    {
        ASSERT( Pext()->PemiFromExtCommandID( nCommandID ) == NULL );

        try
        {
            Trace( g_tagExtDll, _T("CExtensionDll::AddExtensionMenuItem() - Adding menu item '%s', ExtID = %d"), lpszName, nCommandID );

            // Allocate a new item.
            pemi = new CExtMenuItem(
                            OLE2CT( lpszName ),
                            OLE2CT( lpszStatusBarText ),
                            nCommandID,
                            NNextCommandID(),
                            NNextMenuID(),
                            uFlags,
                            FALSE, /*bMakeDefault*/
                            PiInvokeCommand()
                            );
            if ( pemi == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating memory

            // Insert the item in the menu.
            if ( ! Pmenu()->InsertMenu( NNextMenuID(), MF_BYPOSITION | uFlags, NNextCommandID(), pemi->StrName() ) )
            {
                ThrowStaticException( ::GetLastError(), IDS_INSERT_MENU_ERROR, pemi->StrName() );
            } // if: error inserting the menu item

            // Add the item to the tail of the list.
            Pext()->PlMenuItems()->AddTail( pemi );
            pemi = NULL;

            // Update the counters.
            Pext()->m_nNextCommandID++;
            Pext()->m_nNextMenuID++;
        }  // try
        catch ( CNTException * pnte )
        {
            hr = pnte->Sc();
            pnte->ReportError();
            pnte->Delete();
        }  // catch:  CException
        catch ( CException * pe )
        {
            hr = E_OUTOFMEMORY;
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
    }  // else:  we can add the item

    delete pemi;
    return hr;

}  //*** CExtensionDll::AddExtensionMenuItem()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\extmenu.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ExtMenu.h
//
//	Abstract:
//		Definition of the CExtMenuItem class.
//
//	Implementation File:
//		ExtMenu.cpp
//
//	Author:
//		David Potter (davidp)	August 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXTMENU_H_
#define _EXTMENU_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtMenuItem;
class CExtMenuItemList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

interface IWEInvokeCommand;

/////////////////////////////////////////////////////////////////////////////
//
//	class CExtMenuItem
//
//	Purpose:
//		Represents one extension DLL's menu item.
//
/////////////////////////////////////////////////////////////////////////////
class CExtMenuItem : public CObject
{
	DECLARE_DYNAMIC(CExtMenuItem);

// Construction
public:
	CExtMenuItem(void);
	CExtMenuItem(
				IN LPCTSTR				lpszName,
				IN LPCTSTR				lpszStatusBarText,
				IN ULONG				nExtCommandID,
				IN ULONG				nCommandID,
				IN ULONG				nMenuItemID,
				IN ULONG				uFlags,
				IN BOOL					bMakeDefault,
				IN IWEInvokeCommand *	piCommand
				);
	virtual ~CExtMenuItem(void);

protected:
	void				CommonConstruct(void);

// Attributes
protected:
	CString				m_strName;
	CString				m_strStatusBarText;
	ULONG				m_nExtCommandID;
	ULONG				m_nCommandID;
	ULONG				m_nMenuItemID;
	ULONG				m_uFlags;
	BOOL				m_bDefault;
	IWEInvokeCommand *	m_piCommand;

public:
	const CString &		StrName(void) const				{ return m_strName; }
	const CString &		StrStatusBarText(void) const	{ return m_strStatusBarText; }
	ULONG				NExtCommandID(void) const		{ return m_nExtCommandID; }
	ULONG				NCommandID(void) const			{ return m_nCommandID; }
	ULONG				NMenuItemID(void) const			{ return m_nMenuItemID; }
	ULONG				UFlags(void) const				{ return m_uFlags; }
	BOOL				BDefault(void) const			{ return m_bDefault; }
	IWEInvokeCommand *	PiCommand(void)					{ return m_piCommand; }

// Operations
public:
	void				SetPopupMenuHandle(HMENU hmenu)	{ m_hmenuPopup = hmenu; }

#ifdef _DEBUG
	// Use MFC's standard object validity technique
	virtual void AssertValid(void);
#endif

// Implementation
protected:
	HMENU				m_hmenuPopup;
	CExtMenuItemList *	m_plSubMenuItems;

public:
	HMENU				HmenuPopup(void) const			{ return m_hmenuPopup; }
	CExtMenuItemList *	PlSubMenuItems(void) const		{ return m_plSubMenuItems; }

};  //*** class CExtMenuItem

/////////////////////////////////////////////////////////////////////////////
//
// class CExtMenuItemList
//
/////////////////////////////////////////////////////////////////////////////

class CExtMenuItemList : public CTypedPtrList<CObList, CExtMenuItem *>
{
};  //*** class CExtMenuItemList

/////////////////////////////////////////////////////////////////////////////

#endif // _EXTMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\helpdata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		HelpData.cpp
//
//	Abstract:
//		Data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"

// Define help IDs.
#include "HelpIDs.h"

// Declare arrays.  If we don't do this the arrays don't get instantiated
// in the executable image.
#include "HelpArr.h"

// Define the arrays.
#define INITHELPARRAYS
#include "HelpArr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\group.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      Group.cpp
//
//  Abstract:
//      Implementation of the CGroup class.
//
//  Author:
//      David Potter (davidp)	May 3, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "Group.h"
#include "ClusItem.inl"
#include "GrpProp.h"
#include "ExcOper.h"
#include "TraceTag.h"
#include "Cluster.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagGroup(_T("Document"), _T("GROUP"), 0);
CTraceTag   g_tagGroupRead(_T("Document"), _T("GROUP READ"), 0);
CTraceTag   g_tagGroupDrag(_T("Drag&Drop"), _T("GROUP DRAG"), 0);
CTraceTag   g_tagGroupMenu(_T("Menu"), _T("GROUP MENU"), 0);
CTraceTag   g_tagGroupNotify(_T("Notify"), _T("GROUP NOTIFY"), 0);
CTraceTag   g_tagGroupRegNotify(_T("Notify"), _T("GROUP REG NOTIFY"), 0);
#endif


/////////////////////////////////////////////////////////////////////////////
// CGroup
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CGroup, CClusterItem)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CGroup, CClusterItem)
    //{{AFX_MSG_MAP(CGroup)
    ON_UPDATE_COMMAND_UI(ID_FILE_BRING_ONLINE, OnUpdateBringOnline)
    ON_UPDATE_COMMAND_UI(ID_FILE_TAKE_OFFLINE, OnUpdateTakeOffline)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP, OnUpdateMoveGroup)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_1, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_DELETE, OnUpdateDelete)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_2, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_3, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_4, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_5, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_6, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_7, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_8, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_9, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_10, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_11, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_12, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_13, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_14, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_15, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_GROUP_16, OnUpdateMoveGroupRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
    ON_COMMAND(ID_FILE_BRING_ONLINE, OnCmdBringOnline)
    ON_COMMAND(ID_FILE_TAKE_OFFLINE, OnCmdTakeOffline)
    ON_COMMAND(ID_FILE_MOVE_GROUP, OnCmdMoveGroup)
    ON_COMMAND(ID_FILE_DELETE, OnCmdDelete)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::CGroup
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGroup::CGroup(void) : CClusterItem(NULL, IDS_ITEMTYPE_GROUP)
{
    CommonConstruct();

}  //*** CGroup::CGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::CGroup
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      bDocObj		[IN] TRUE = object is part of the document.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGroup::CGroup(IN BOOL bDocObj) : CClusterItem(NULL, IDS_ITEMTYPE_GROUP)
{
    CommonConstruct();
    m_bDocObj = bDocObj;

}  //*** CGroup::CGroup(bDocObj)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::CommonConstruct(void)
{
    m_idmPopupMenu = IDM_GROUP_POPUP;
    m_hgroup = NULL;
    m_nFailoverThreshold = CLUSTER_GROUP_DEFAULT_FAILOVER_THRESHOLD;
    m_nFailoverPeriod = CLUSTER_GROUP_DEFAULT_FAILOVER_PERIOD;
    m_cgaftAutoFailbackType = CLUSTER_GROUP_DEFAULT_AUTO_FAILBACK_TYPE;
    m_nFailbackWindowStart = CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_START;
    m_nFailbackWindowEnd = CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_END;

    m_pciOwner = NULL;

    m_plpcires = NULL;
    m_plpcinodePreferredOwners = NULL;

    // Set the object type image.
    m_iimgObjectType = GetClusterAdminApp()->Iimg(IMGLI_GROUP);

    // Setup the property array.
    {
        m_rgProps[epropName].Set(CLUSREG_NAME_GRP_NAME, m_strName, m_strName);
        m_rgProps[epropDescription].Set(CLUSREG_NAME_GRP_DESC, m_strDescription, m_strDescription);
        m_rgProps[epropFailoverThreshold].Set(CLUSREG_NAME_GRP_FAILOVER_THRESHOLD, m_nFailoverThreshold, m_nFailoverThreshold);
        m_rgProps[epropFailoverPeriod].Set(CLUSREG_NAME_GRP_FAILOVER_PERIOD, m_nFailoverPeriod, m_nFailoverPeriod);
        m_rgProps[epropAutoFailbackType].Set(CLUSREG_NAME_GRP_FAILBACK_TYPE, (DWORD &) m_cgaftAutoFailbackType, (DWORD &) m_cgaftAutoFailbackType);
        m_rgProps[epropFailbackWindowStart].Set(CLUSREG_NAME_GRP_FAILBACK_WIN_START, m_nFailbackWindowStart, m_nFailbackWindowStart);
        m_rgProps[epropFailbackWindowEnd].Set(CLUSREG_NAME_GRP_FAILBACK_WIN_END, m_nFailbackWindowEnd, m_nFailbackWindowEnd);
    }  // Setup the property array

#ifdef _CLUADMIN_USE_OLE_
    EnableAutomation();
#endif

    // To keep the application running as long as an OLE automation
    //	object is active, the constructor calls AfxOleLockApp.

//  AfxOleLockApp();

}  //*** CGroup::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::~CGroup
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGroup::~CGroup(void)
{
	// Cleanup this object.
	Cleanup();

	delete m_plpcires;
	delete m_plpcinodePreferredOwners;

	// Close the group handle.
	if (Hgroup() != NULL)
		CloseClusterGroup(Hgroup());

	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.

//	AfxOleUnlockApp();

}  //*** CGroup::~CGroup

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::Cleanup
//
//	Routine Description:
//		Cleanup the item.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::Cleanup(void)
{
	// Delete the resource list.
	if (m_plpcires != NULL)
		m_plpcires->RemoveAll();

	// Delete the PreferredOwners list.
	if (m_plpcinodePreferredOwners != NULL)
		m_plpcinodePreferredOwners->RemoveAll();

	// If we are active on a node, remove ourselves from that active list.
	if (PciOwner() != NULL)
	{
		if (BDocObj())
			PciOwner()->RemoveActiveGroup(this);
		PciOwner()->Release();
		m_pciOwner = NULL;
	}  // if:  there is an owner

	// Remove the item from the group list.
	if (BDocObj())
	{
		POSITION	posPci;

		posPci = Pdoc()->LpciGroups().Find(this);
		if (posPci != NULL)
		{
			Pdoc()->LpciGroups().RemoveAt(posPci);
		}  // if:  found in the document's list
	}  // if:  this is a document object

}  //*** CGroup::Cleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::Create
//
//	Routine Description:
//		Create a group.
//
//	Arguments:
//		pdoc				[IN OUT] Document to which this item belongs.
//		lpszName			[IN] Name of the group.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		CNTException	Errors from CreateClusterResource.
//		Any exceptions thrown by CResource::Init(), CResourceList::new(),
//		or CNodeList::new().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::Create(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName)
{
	DWORD		dwStatus;
	HGROUP		hgroup;
	CString		strName(lpszName);	// Required if built non-Unicode
	CWaitCursor	wc;

	ASSERT(Hgroup() == NULL);
	ASSERT(Hkey() == NULL);
	ASSERT_VALID(pdoc);
	ASSERT(lpszName != NULL);

	// Create the group.
	hgroup = CreateClusterGroup(pdoc->Hcluster(), strName);
	if (hgroup == NULL)
	{
		dwStatus = GetLastError();
		ThrowStaticException(dwStatus, IDS_CREATE_GROUP_ERROR, lpszName);
	}  // if:  error creating the cluster group

	CloseClusterGroup(hgroup);

	// Open the group.
	Init(pdoc, lpszName);

}  //*** CGroup::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::Init
//
//	Routine Description:
//		Initialize the item.
//
//	Arguments:
//		pdoc		[IN OUT] Document to which this item belongs.
//		lpszName	[IN] Name of the item.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		CNTException	Errors from OpenClusterGroup() or GetClusterGroupKey().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName)
{
	DWORD	dwStatus = ERROR_SUCCESS;
	LONG	lResult;
	CString	strName(lpszName);	// Required if built non-Unicode
	CWaitCursor	wc;

	ASSERT(Hgroup() == NULL);
	ASSERT(Hkey() == NULL);

	// Call the base class method.
	CClusterItem::Init(pdoc, lpszName);

	try
	{
		// Open the group.
		m_hgroup = OpenClusterGroup(Hcluster(), strName);
		if (Hgroup() == NULL)
		{
			dwStatus = GetLastError();
			ThrowStaticException(dwStatus, IDS_OPEN_GROUP_ERROR, lpszName);
		}  // if:  error opening the cluster group

		// Get the group registry key.
		m_hkey = GetClusterGroupKey(Hgroup(), MAXIMUM_ALLOWED);
		if (Hkey() == NULL)
			ThrowStaticException(GetLastError(), IDS_GET_GROUP_KEY_ERROR, lpszName);

		if (BDocObj())
		{
			ASSERT(Pcnk() != NULL);
			Trace(g_tagClusItemNotify, _T("CGroup::Init() - Registering for group notifications (%08.8x) for '%s'"), Pcnk(), StrName());

			// Register for group notifications.
			lResult = RegisterClusterNotify(
								GetClusterAdminApp()->HchangeNotifyPort(),
								(CLUSTER_CHANGE_GROUP_STATE
									| CLUSTER_CHANGE_GROUP_DELETED
									| CLUSTER_CHANGE_GROUP_PROPERTY),
								Hgroup(),
								(DWORD_PTR) Pcnk()
								);
			if (lResult != ERROR_SUCCESS)
			{
				dwStatus = lResult;
				ThrowStaticException(dwStatus, IDS_GROUP_NOTIF_REG_ERROR, lpszName);
			}  // if:  error registering for group notifications

			// Register for registry notifications.
			if (Hkey() != NULL)
			{
				lResult = RegisterClusterNotify(
									GetClusterAdminApp()->HchangeNotifyPort(),
									(CLUSTER_CHANGE_REGISTRY_NAME
										| CLUSTER_CHANGE_REGISTRY_ATTRIBUTES
										| CLUSTER_CHANGE_REGISTRY_VALUE
										| CLUSTER_CHANGE_REGISTRY_SUBTREE),
									Hkey(),
									(DWORD_PTR) Pcnk()
									);
				if (lResult != ERROR_SUCCESS)
				{
					dwStatus = lResult;
					ThrowStaticException(dwStatus, IDS_GROUP_NOTIF_REG_ERROR, lpszName);
				}  // if:  error registering for registry notifications
			}  // if:  there is a key
		}  // if:  document object

		// Allocate lists.
		m_plpcires = new CResourceList;
        if ( m_plpcires == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating resource list
		m_plpcinodePreferredOwners = new CNodeList;
        if ( m_plpcinodePreferredOwners == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating preferred owners list

		// Read the initial state.
		UpdateState();
	}  // try
	catch (CException *)
	{
		if (Hkey() != NULL)
		{
			ClusterRegCloseKey(Hkey());
			m_hkey = NULL;
		}  // if:  registry key opened
		if (Hgroup() != NULL)
		{
			CloseClusterGroup(Hgroup());
			m_hgroup = NULL;
		}  // if:  group opened
		m_bReadOnly = TRUE;
		throw;
	}  // catch:  CException

}  //*** CGroup::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::ReadItem
//
//	Routine Description:
//		Read the item parameters from the cluster database.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		CNTException		Errors from CClusterItem::DwReadValue() or
//								CGroup::ConstructList().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::ReadItem(void)
{
	DWORD		dwStatus;
	DWORD		dwRetStatus	= ERROR_SUCCESS;
	CWaitCursor	wc;

	ASSERT_VALID(this);

	if (Hgroup() != NULL)
	{
		m_rgProps[epropDescription].m_value.pstr = &m_strDescription;
		m_rgProps[epropFailoverThreshold].m_value.pdw = &m_nFailoverThreshold;
		m_rgProps[epropFailoverPeriod].m_value.pdw = &m_nFailoverPeriod;
		m_rgProps[epropAutoFailbackType].m_value.pdw = (DWORD *) &m_cgaftAutoFailbackType;
		m_rgProps[epropFailbackWindowStart].m_value.pdw = &m_nFailbackWindowStart;
		m_rgProps[epropFailbackWindowEnd].m_value.pdw = &m_nFailbackWindowEnd;

		// Call the base class method.
		CClusterItem::ReadItem();

		Trace(g_tagGroupRead, _T("ReadItem() - Name before reading properties: '%s'"), StrName());

		// Read and parse the common properties.
		{
			CClusPropList	cpl;

			dwStatus = cpl.ScGetGroupProperties(
								Hgroup(),
								CLUSCTL_GROUP_GET_COMMON_PROPERTIES
								);
			if (dwStatus == ERROR_SUCCESS)
				dwStatus = DwParseProperties(cpl);
			if (dwStatus != ERROR_SUCCESS)
				dwRetStatus = dwStatus;
		}  // Read and parse the common properties

		// Read and parse the read-only common properties.
		if (dwRetStatus == ERROR_SUCCESS)
		{
			CClusPropList	cpl;

			dwStatus = cpl.ScGetGroupProperties(
								Hgroup(),
								CLUSCTL_GROUP_GET_RO_COMMON_PROPERTIES
								);
			if (dwStatus == ERROR_SUCCESS)
				dwStatus = DwParseProperties(cpl);
			if (dwStatus != ERROR_SUCCESS)
				dwRetStatus = dwStatus;
		}  // if:  no error yet

		Trace(g_tagGroupRead, _T("ReadItem() - Name after reading properties: '%s'"), StrName());

		// Read extension lists.
		ReadExtensions();

		if (dwRetStatus == ERROR_SUCCESS)
		{
			// Read the list of preferred owners.
			ASSERT(m_plpcinodePreferredOwners != NULL);
			ConstructList(*m_plpcinodePreferredOwners, CLUSTER_GROUP_ENUM_NODES);
		}  // if:  no error reading properties
	}  // if:  group is available

	// Read the initial state.
	UpdateState();

	// Construct the list of resources contained in the group.
//	ASSERT(m_plpcires != NULL);
//	ConstructList(*m_plpcires, CLUSTER_GROUP_ENUM_CONTAINS);

	// If any errors occurred, throw an exception.
	if (dwRetStatus != ERROR_SUCCESS)
	{
		m_bReadOnly = TRUE;
		if (   (dwRetStatus != ERROR_GROUP_NOT_AVAILABLE)
			&& (dwRetStatus != ERROR_KEY_DELETED))
			ThrowStaticException(dwRetStatus, IDS_READ_GROUP_PROPS_ERROR, StrName());
	}  // if:  error reading properties

	MarkAsChanged(FALSE);

}  //*** CGroup::ReadItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::PlstrExtensions
//
//	Routine Description:
//		Return the list of admin extensions.
//
//	Arguments:
//		None.
//
//	Return Value:
//		plstr		List of extensions.
//		NULL		No extension associated with this object.
//
//	Exceptions Thrown:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CStringList * CGroup::PlstrExtensions(void) const
{
	return &Pdoc()->PciCluster()->LstrGroupExtensions();

}  //*** CGroup::PlstrExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::ReadExtensions
//
//	Routine Description:
//		Read extension lists.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::ReadExtensions(void)
{
}  //*** CGroup::ReadExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::ConstructList
//
//	Routine Description:
//		Construct a list of node items which are enumerable on the group.
//
//	Arguments:
//		rlpci			[OUT] List to fill.
//		dwType			[IN] Type of objects.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		CNTException	Errors from ClusterGroupOpenEnum or ClusterGroupEnum.
//		Any exceptions thrown by new or CList::AddTail.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::ConstructList(
	OUT CNodeList &	rlpci,
	IN DWORD		dwType
	)
{
	DWORD			dwStatus;
	HGROUPENUM		hgrpenum;
	int				ienum;
	LPWSTR			pwszName = NULL;
	DWORD			cchName;
	DWORD			cchmacName;
	DWORD			dwRetType;
	CClusterNode *	pciNode;
	CWaitCursor		wc;

	ASSERT_VALID(Pdoc());
	ASSERT(Hgroup() != NULL);

	Trace(g_tagGroup, _T("(%s) (%s (%x)) - Constructing node list"), Pdoc()->StrNode(), StrName(), this);

	// Remove the previous contents of the list.
	rlpci.RemoveAll();

	if (Hgroup() != NULL)
	{
		// Open the enumeration.
		hgrpenum = ClusterGroupOpenEnum(Hgroup(), dwType);
		if (hgrpenum == NULL)
			ThrowStaticException(GetLastError(), IDS_ENUM_PREFERRED_OWNERS_ERROR, StrName());

		try
		{
			// Allocate a name buffer.
			cchmacName = 128;
			pwszName = new WCHAR[cchmacName];
            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating name buffer

			// Loop through the enumeration and add each node to the list.
			for (ienum = 0 ; ; ienum++)
			{
				// Get the next item in the enumeration.
				cchName = cchmacName;
				dwStatus = ClusterGroupEnum(hgrpenum, ienum, &dwRetType, pwszName, &cchName);
				if (dwStatus == ERROR_MORE_DATA)
				{
					delete [] pwszName;
					cchmacName = ++cchName;
					pwszName = new WCHAR[cchmacName];
                    if ( pwszName == NULL )
                    {
                        AfxThrowMemoryException();
                    } // if: error allocating name buffer
					dwStatus = ClusterGroupEnum(hgrpenum, ienum, &dwRetType, pwszName, &cchName);
				}  // if:  name buffer was too small
				if (dwStatus == ERROR_NO_MORE_ITEMS)
					break;
				else if (dwStatus != ERROR_SUCCESS)
					ThrowStaticException(dwStatus, IDS_ENUM_PREFERRED_OWNERS_ERROR, StrName());

				ASSERT(dwRetType == dwType);

				// Find the item in the list of nodes on the document.
				pciNode = Pdoc()->LpciNodes().PciNodeFromName(pwszName);
				ASSERT_VALID(pciNode);

				// Add the node to the list.
				if (pciNode != NULL)
				{
					rlpci.AddTail(pciNode);
				}  // if:  found node in list

			}  // for:  each item in the group

			delete [] pwszName;
			ClusterGroupCloseEnum(hgrpenum);

		}  // try
		catch (CException *)
		{
			delete [] pwszName;
			ClusterGroupCloseEnum(hgrpenum);
			throw;
		}  // catch:  any exception
	}  // if:  resource is available

}  //*** CGroup::ConstructList(CNodeList&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::ConstructList
//
//	Routine Description:
//		Construct a list of resource items which are enumerable on the group.
//
//	Arguments:
//		rlpci			[OUT] List to fill.
//		dwType			[IN] Type of objects.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		CNTException	Errors from ClusterGroupOpenEnum or ClusterGroupEnum.
//		Any exceptions thrown by new or CList::AddTail.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::ConstructList(
	OUT CResourceList &	rlpci,
	IN DWORD			dwType
	)
{
	DWORD			dwStatus;
	HGROUPENUM		hgrpenum;
	int				ienum;
	LPWSTR			pwszName = NULL;
	DWORD			cchName;
	DWORD			cchmacName;
	DWORD			dwRetType;
	CResource *		pciRes;
	CWaitCursor		wc;

	ASSERT_VALID(Pdoc());
	ASSERT(Hgroup() != NULL);

	Trace(g_tagGroup, _T("(%s) (%s (%x)) - Constructing resource list"), Pdoc()->StrNode(), StrName(), this);

	// Remove the previous contents of the list.
	rlpci.RemoveAll();

	if (Hgroup() != NULL)
	{
		// Open the enumeration.
		hgrpenum = ClusterGroupOpenEnum(Hgroup(), dwType);
		if (hgrpenum == NULL)
			ThrowStaticException(GetLastError(), IDS_ENUM_CONTAINS_ERROR, StrName());

		try
		{
			// Allocate a name buffer.
			cchmacName = 128;
			pwszName = new WCHAR[cchmacName];
            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating name buffer

			// Loop through the enumeration and add each resource to the list.
			for (ienum = 0 ; ; ienum++)
			{
				// Get the next item in the enumeration.
				cchName = cchmacName;
				dwStatus = ClusterGroupEnum(hgrpenum, ienum, &dwRetType, pwszName, &cchName);
				if (dwStatus == ERROR_MORE_DATA)
				{
					delete [] pwszName;
					cchmacName = ++cchName;
					pwszName = new WCHAR[cchmacName];
                    if ( pwszName == NULL )
                    {
                        AfxThrowMemoryException();
                    } // if: error allocating name buffer
					dwStatus = ClusterGroupEnum(hgrpenum, ienum, &dwRetType, pwszName, &cchName);
				}  // if:  name buffer was too small
				if (dwStatus == ERROR_NO_MORE_ITEMS)
					break;
				else if (dwStatus != ERROR_SUCCESS)
					ThrowStaticException(dwStatus, IDS_ENUM_CONTAINS_ERROR, StrName());

				ASSERT(dwRetType == dwType);

				// Find the item in the list of resources on the document.
				pciRes = Pdoc()->LpciResources().PciResFromName(pwszName);
				ASSERT_VALID(pciRes);

				// Add the resource to the list.
				if (pciRes != NULL)
				{
					rlpci.AddTail(pciRes);
				}  // if:  found resource in list

			}  // for:  each item in the group

			delete [] pwszName;
			ClusterGroupCloseEnum(hgrpenum);

		}  // try
		catch (CException *)
		{
			delete [] pwszName;
			ClusterGroupCloseEnum(hgrpenum);
			throw;
		}  // catch:  any exception
	}  // if:  resource is available

}  //*** CGroup::ConstructList(CResourceList&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::ConstructPossibleOwnersList
//
//	Routine Description:
//		Construct the list of nodes on which this group can run.
//
//	Arguments:
//		rlpciNodes	[OUT] List of nodes on which group can run.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::ConstructPossibleOwnersList(OUT CNodeList & rlpciNodes)
{
	POSITION		posNode;
	POSITION		posRes;
	POSITION		posResNode;
	POSITION		posCurResNode	= NULL;
	CClusterNode *	pciNode;
	CClusterNode *	pciResNode;
	CResource *		pciRes;
	CWaitCursor	wc;

	ASSERT_VALID(Pdoc());

	// Remove the previous contents of the list.
	rlpciNodes.RemoveAll();

	posNode = Pdoc()->LpciNodes().GetHeadPosition();
	while (posNode != NULL)
	{
		pciNode = (CClusterNode *) Pdoc()->LpciNodes().GetNext(posNode);
		ASSERT_VALID(pciNode);

		if (Lpcires().GetCount() != 0)
		{
			posRes = Lpcires().GetHeadPosition();
			while (posRes != NULL)
			{
				pciRes = (CResource *) Lpcires().GetNext(posRes);
				ASSERT_VALID(pciRes);

				posResNode = pciRes->LpcinodePossibleOwners().GetHeadPosition();
				while (posResNode != NULL)
				{
					posCurResNode = posResNode;
					pciResNode = (CClusterNode *) pciRes->LpcinodePossibleOwners().GetNext(posResNode);
					ASSERT_VALID(pciResNode);
					if (pciNode->StrName() == pciResNode->StrName())
						break;
					posCurResNode = NULL;
				}  // while:  more possible owners in the list

				// If the node wasn't found, the group can't run here.
				if (posCurResNode == NULL)
					break;
			}  // while:  more resources in the list
		}  // if:  group has resources

		// If the node was found on a resource, the group can run here.
		if (posCurResNode != NULL)
		{
			rlpciNodes.AddTail(pciNode);
		}  // if:  node found on a resource
	}  // while:  more nodes in the document

}  //*** CGroup::ConstructPossibleOwnersList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::DeleteGroup
//
//	Routine Description:
//		Delete the group.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		CNTException		Any errors from DeleteClusterGroup.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::DeleteGroup(void)
{
	CWaitCursor	wc;

	if (Hgroup() != NULL)
	{
		DWORD		dwStatus;
		CWaitCursor	wc;

		// Delete the group itself.
		dwStatus = DeleteClusterGroup(Hgroup());
		if (dwStatus != ERROR_SUCCESS)
			ThrowStaticException(dwStatus, IDS_DELETE_GROUP_ERROR, StrName());

		UpdateState();
	}  // if:  group has been opened/created

}  //*** CGroup::DeleteGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::AddResource
//
//	Routine Description:
//		Add a resource to the list of resources contained in this group.
//
//	Arguments:
//		pciRes		[IN OUT] New resource.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::AddResource(IN OUT CResource * pciRes)
{
	POSITION	posPci;

	ASSERT_VALID(pciRes);
	Trace(g_tagGroup, _T("(%s) (%s (%x)) - Adding resource '%s'"), Pdoc()->StrNode(), StrName(), this, pciRes->StrName());

	// Make sure the resource is not already in the list.
	VERIFY((posPci = Lpcires().Find(pciRes)) == NULL);

	if (posPci == NULL)
	{
		POSITION	posPtiGroup;
		CTreeItem *	ptiGroup;

		// Loop through each tree item to update the group's list of resources.
		posPtiGroup = LptiBackPointers().GetHeadPosition();
		while (posPtiGroup != NULL)
		{
			ptiGroup = LptiBackPointers().GetNext(posPtiGroup);
			ASSERT_VALID(ptiGroup);

			// Add the new resource.
			VERIFY(ptiGroup->PliAddChild(pciRes) != NULL);
		}  // while:  more tree items for this group

		m_plpcires->AddTail(pciRes);

	}  // if:  resource not in the list yet

}  //*** CGroup::AddResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::RemoveResource
//
//	Routine Description:
//		Remove a resource from the list of resources contained in this group.
//
//	Arguments:
//		pciRes		[IN OUT] Resource that no is no longer contained in this group.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::RemoveResource(IN OUT CResource * pciRes)
{
	POSITION	posPci;

	ASSERT_VALID(pciRes);
	Trace(g_tagGroup, _T("(%s) (%s (%x)) - Removing resource '%s'"), Pdoc()->StrNode(), StrName(), this, pciRes->StrName());

	// Make sure the resource is in the list.
	posPci = Lpcires().Find(pciRes);

	if (posPci != NULL)
	{
		POSITION	posPtiGroup;
		CTreeItem *	ptiGroup;

		// Loop through each tree item to update the group's list of resources.
		posPtiGroup = LptiBackPointers().GetHeadPosition();
		while (posPtiGroup != NULL)
		{
			ptiGroup = LptiBackPointers().GetNext(posPtiGroup);
			ASSERT_VALID(ptiGroup);

			// Remove the resource.
			ptiGroup->RemoveChild(pciRes);
		}  // while:  more tree items for this group

		m_plpcires->RemoveAt(posPci);

	}  // if:  resource in the list

}  //*** CGroup::RemoveResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::SetName
//
//	Routine Description:
//		Set the name of this group.
//
//	Arguments:
//		pszName		[IN] New name of the group.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		CNTException	IDS_RENAME_GROUP_ERROR - errors from
//							SetClusterGroupName().
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::SetName(IN LPCTSTR pszName)
{
	Rename(pszName);

}  //*** CGroup::SetName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::SetPreferredOwners
//
//	Routine Description:
//		Set the list of preferred owners of this group in the cluster database.
//
//	Arguments:
//		rlpci		[IN] List of preferred owners (nodes).
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by CStringList::AddTail() or
//		CNodeList::AddTail().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::SetPreferredOwners(IN const CNodeList & rlpci)
{
	DWORD		dwStatus;
	CWaitCursor	wc;

	ASSERT(Hgroup() != NULL);

	if (Hgroup() != NULL)
	{
		BOOL		bChanged	= TRUE;

		// Determine if the list has changed.
		if (rlpci.GetCount() == LpcinodePreferredOwners().GetCount())
		{
			POSITION		posOld;
			POSITION		posNew;
			CClusterNode *	pciOldNode;
			CClusterNode *	pciNewNode;

			bChanged = FALSE;

			posOld = LpcinodePreferredOwners().GetHeadPosition();
			posNew = rlpci.GetHeadPosition();
			while (posOld != NULL)
			{
				pciOldNode = (CClusterNode *) LpcinodePreferredOwners().GetNext(posOld);
				ASSERT_VALID(pciOldNode);

				ASSERT(posNew != NULL);
				pciNewNode = (CClusterNode *) rlpci.GetNext(posNew);
				ASSERT_VALID(pciNewNode);

				if (pciOldNode->StrName() != pciNewNode->StrName())
				{
					bChanged = TRUE;
					break;
				}  // if:  name is not the same
			}  // while:  more items in the old list
		}  // if:  same number of items in the list

		if (bChanged)
		{
			HNODE *		phnode	= NULL;

			try
			{
				DWORD			ipci;
				POSITION		posPci;
				CClusterNode *	pciNode;

				// Allocate an array for all the node handles.
				phnode = new HNODE[(DWORD)rlpci.GetCount()];
				if (phnode == NULL)
				{
					ThrowStaticException(GetLastError());
				} // if: error allocating the node handle array

				// Copy the handle of all the nodes in the node list to the handle aray.
				posPci = rlpci.GetHeadPosition();
				for (ipci = 0 ; posPci != NULL ; ipci++)
				{
					pciNode = (CClusterNode *) rlpci.GetNext(posPci);
					ASSERT_VALID(pciNode);
					phnode[ipci] = pciNode->Hnode();
				}  // while:  more nodes in the list

				// Set the property.
				dwStatus = SetClusterGroupNodeList(Hgroup(), (DWORD)rlpci.GetCount(), phnode);
				if (dwStatus != ERROR_SUCCESS)
					ThrowStaticException(dwStatus, IDS_SET_GROUP_NODE_LIST_ERROR, StrName());

				// Update the PCI list.
				m_plpcinodePreferredOwners->RemoveAll();
				posPci = rlpci.GetHeadPosition();
				while (posPci != NULL)
				{
					pciNode = (CClusterNode *) rlpci.GetNext(posPci);
					m_plpcinodePreferredOwners->AddTail(pciNode);
				}  // while:  more items in the list
			} // try
			catch (CException *)
			{
				delete [] phnode;
				throw;
			}  // catch:  CException

			delete [] phnode;

		}  // if:  list changed
	}  // if:  key is available

}  //*** CGroup::SetPreferredOwners(CNodeList*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::SetCommonProperties
//
//	Routine Description:
//		Set the common properties for this resource in the cluster database.
//
//	Arguments:
//		rstrDesc		[IN] Description string.
//		nThreshold		[IN] Failover threshold.
//		nPeriod			[IN] Failover period.
//		cgaft			[IN] Auto Failback Type.
//		nStart			[IN] Start of failback window.
//		nEnd			[IN] End of failback window.
//		bValidateOnly	[IN] Only validate the data.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by CClusterItem::SetCommonProperties().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::SetCommonProperties(
	IN const CString &	rstrDesc,
	IN DWORD			nThreshold,
	IN DWORD			nPeriod,
	IN CGAFT			cgaft,
	IN DWORD			nStart,
	IN DWORD			nEnd,
	IN BOOL				bValidateOnly
	)
{
	CNTException	nte(ERROR_SUCCESS, 0, NULL, NULL, FALSE /*bAutoDelete*/);

	m_rgProps[epropDescription].m_value.pstr = (CString *) &rstrDesc;
	m_rgProps[epropFailoverThreshold].m_value.pdw = &nThreshold;
	m_rgProps[epropFailoverPeriod].m_value.pdw = &nPeriod;
	m_rgProps[epropAutoFailbackType].m_value.pdw = (DWORD *) &cgaft;
	m_rgProps[epropFailbackWindowStart].m_value.pdw = &nStart;
	m_rgProps[epropFailbackWindowEnd].m_value.pdw = &nEnd;

	try
	{
		CClusterItem::SetCommonProperties(bValidateOnly);
	}  // try
	catch (CNTException * pnte)
	{
		nte.SetOperation(
					pnte->Sc(),
					pnte->IdsOperation(),
					pnte->PszOperArg1(),
					pnte->PszOperArg2()
					);
	}  // catch:  CNTException

	m_rgProps[epropDescription].m_value.pstr = &m_strDescription;
	m_rgProps[epropFailoverThreshold].m_value.pdw = &m_nFailoverThreshold;
	m_rgProps[epropFailoverPeriod].m_value.pdw = &m_nFailoverPeriod;
	m_rgProps[epropAutoFailbackType].m_value.pdw = (DWORD *) &m_cgaftAutoFailbackType;
	m_rgProps[epropFailbackWindowStart].m_value.pdw = &m_nFailbackWindowStart;
	m_rgProps[epropFailbackWindowEnd].m_value.pdw = &m_nFailbackWindowEnd;

	if (nte.Sc() != ERROR_SUCCESS)
		ThrowStaticException(
						nte.Sc(),
						nte.IdsOperation(),
						nte.PszOperArg1(),
						nte.PszOperArg2()
						);

}  //*** CGroup::SetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::DwSetCommonProperties
//
//	Routine Description:
//		Set the common properties for this group in the cluster database.
//
//	Arguments:
//		rcpl			[IN] Property list to set.
//		bValidateOnly	[IN] Only validate the data.
//
//	Return Value:
//		Any status returned by ClusterGroupControl().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CGroup::DwSetCommonProperties(
	IN const CClusPropList &	rcpl,
	IN BOOL						bValidateOnly
	)
{
	DWORD		dwStatus;
	CWaitCursor	wc;


	ASSERT(Hgroup());

	if ((rcpl.PbPropList() != NULL) && (rcpl.CbPropList() > 0))
	{
		DWORD	cbProps;
		DWORD	dwControl;

		if (bValidateOnly)
			dwControl = CLUSCTL_GROUP_VALIDATE_COMMON_PROPERTIES;
		else
			dwControl = CLUSCTL_GROUP_SET_COMMON_PROPERTIES;

		// Set private properties.
		dwStatus = ClusterGroupControl(
						Hgroup(),
						NULL,	// hNode
						dwControl,
						rcpl.PbPropList(),
						rcpl.CbPropList(),
						NULL,	// lpOutBuffer
						0,		// nOutBufferSize
						&cbProps
						);
	}  // if:  there is data to set
	else
		dwStatus = ERROR_SUCCESS;

	return dwStatus;

}  //*** CGroup::DwSetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroup::UpdateState
//
//  Routine Description:
//      Update the current state of the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::UpdateState(void)
{
    CClusterAdminApp *  papp        = GetClusterAdminApp();
    WCHAR *             pwszOwner   = NULL;

    // This should probably be limited by MAX_COMPUTERNAME_LENGTH (31) for now, but
    // if/when we go to DNS names we'll need at most 255 bytes for the name.
    WCHAR               rgwszOwner[256];
    DWORD               cchOwner    = sizeof(rgwszOwner) / sizeof(WCHAR);

    Trace(g_tagGroup, _T("(%s) (%s (%x)) - Updating state"), Pdoc()->StrNode(), StrName(), this);

    // Get the current state of the group.
    if (Hgroup() == NULL)
        m_cgs = ClusterGroupStateUnknown;
    else
    {
        CWaitCursor wc;

        m_cgs = GetClusterGroupState(Hgroup(), rgwszOwner, &cchOwner);
        pwszOwner = rgwszOwner;
    }  // else:  group is available

    // Save the current state image index.
    switch (Cgs())
    {
        case ClusterGroupStateUnknown:
            m_iimgState = papp->Iimg(IMGLI_GROUP_UNKNOWN);
            pwszOwner = NULL;
            break;
        case ClusterGroupOnline:
            m_iimgState = papp->Iimg(IMGLI_GROUP);
            break;
        case ClusterGroupPartialOnline:
            m_iimgState = papp->Iimg(IMGLI_GROUP_PARTIALLY_ONLINE);
            break;
        case ClusterGroupPending:
            m_iimgState = papp->Iimg(IMGLI_GROUP_PENDING);
            break;
        case ClusterGroupOffline:
            m_iimgState = papp->Iimg(IMGLI_GROUP_OFFLINE);
            break;
        case ClusterGroupFailed:
            m_iimgState = papp->Iimg(IMGLI_GROUP_FAILED);
            break;
        default:
            Trace(g_tagGroup, _T("(%s) (%s (%x)) - UpdateState: Unknown state '%d' for group '%s'"), Pdoc()->StrNode(), StrName(), this, Cgs(), StrName());
            m_iimgState = (UINT) -1;
            break;
    }  // switch:  Cgs()

    SetOwnerState(pwszOwner);

    // Update the state of all resources owned by this group.
    if (m_plpcires != NULL)
    {
        POSITION	posRes;
        CResource *	pciRes;

        posRes = Lpcires().GetHeadPosition();
        while (posRes != NULL)
        {
            pciRes = (CResource *) Lpcires().GetNext(posRes);
            ASSERT_VALID(pciRes);
            pciRes->UpdateState();
        }  // while:  more items in the list
    }  // if:  resource list exists

    // Call the base class method.
    CClusterItem::UpdateState();

}  //*** CGroup::UpdateState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::SetOwnerState
//
//	Routine Description:
//		Set a new owner for this group.
//
//	Arguments:
//		pszNewOwner		[IN] Name of the new owner.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::SetOwnerState(IN LPCTSTR pszNewOwner)
{
	CClusterNode *	pciOldOwner	= PciOwner();
	CClusterNode *	pciNewOwner;

	Trace(g_tagGroup, _T("(%s) (%s (%x)) - Setting owner to '%s'"), Pdoc()->StrNode(), StrName(), this, pszNewOwner);

	if (pszNewOwner == NULL)
		pciNewOwner = NULL;
	else
		pciNewOwner = Pdoc()->LpciNodes().PciNodeFromName(pszNewOwner);
	if (pciNewOwner != pciOldOwner)
	{
#ifdef _DEBUG
		if (g_tagGroup.BAny())
		{
			CString		strMsg;
			CString		strMsg2;

			strMsg.Format(_T("(%s) (%s (%x)) - Changing owner from "), Pdoc()->StrNode(), StrName(), this);
			if (pciOldOwner == NULL)
				strMsg += _T("nothing ");
			else
			{
				strMsg2.Format(_T("'%s' "), pciOldOwner->StrName());
				strMsg += strMsg2;
			}  // else:  previous owner
			if (pciNewOwner == NULL)
				strMsg += _T("to nothing");
			else
			{
				strMsg2.Format(_T("to '%s'"), pciNewOwner->StrName());
				strMsg += strMsg2;
			}  // else:  new owner
			Trace(g_tagGroup, strMsg);
		}  // if:  trace tag turned on
#endif
		m_strOwner = pszNewOwner;
		m_pciOwner = pciNewOwner;

		// Update reference counts.
		if (pciOldOwner != NULL)
			pciOldOwner->Release();
		if (pciNewOwner != NULL)
			pciNewOwner->AddRef();

		if (BDocObj())
		{
			if (pciOldOwner != NULL)
				pciOldOwner->RemoveActiveGroup(this);
			if (pciNewOwner != NULL)
				pciNewOwner->AddActiveGroup(this);
		}  // if:  this is a document object
	}  // if:  owner changed
	else if ((pszNewOwner != NULL) && (StrOwner() != pszNewOwner))
		m_strOwner = pszNewOwner;

}  //*** CGroup::SetOwnerState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::OnFinalRelease
//
//	Routine Description:
//		Called when the last OLE reference to or from the object is released.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnFinalRelease(void)
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CClusterItem::OnFinalRelease();

}  //*** CGroup::OnFinalRelease()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::BGetColumnData
//
//	Routine Description:
//		Returns a string with the column data.
//
//	Arguments:
//		colid			[IN] Column ID.
//		rstrText		[OUT] String in which to return the text for the column.
//
//	Return Value:
//		TRUE		Column data returned.
//		FALSE		Column ID not recognized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroup::BGetColumnData(IN COLID colid, OUT CString & rstrText)
{
	BOOL	bSuccess;

	switch (colid)
	{
		case IDS_COLTEXT_OWNER:
			rstrText = StrOwner();
			bSuccess = TRUE;
			break;
		case IDS_COLTEXT_STATE:
			GetStateName(rstrText);
			bSuccess = TRUE;
			break;
		default:
			bSuccess = CClusterItem::BGetColumnData(colid, rstrText);
			break;
	}  // switch:  colid

	return bSuccess;

}  //*** CGroup::BGetColumnData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::GetTreeName
//
//	Routine Description:
//		Returns a string to be used in a tree control.
//
//	Arguments:
//		rstrName	[OUT] String in which to return the name.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
void CGroup::GetTreeName(OUT CString & rstrName) const
{
	CString		strState;

	GetStateName(strState);
	rstrName.Format(_T("%s (%s)"), StrName(), strState);

}  //*** CGroup::GetTreeName()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::GetStateName
//
//	Routine Description:
//		Returns a string with the name of the current state.
//
//	Arguments:
//		rstrState	[OUT] String in which to return the name of the current state.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::GetStateName(OUT CString & rstrState) const
{
	switch (Cgs())
	{
		case ClusterGroupStateUnknown:
			rstrState.LoadString(IDS_UNKNOWN);
			break;
		case ClusterGroupOnline:
			rstrState.LoadString(IDS_ONLINE);
			break;
		case ClusterGroupPartialOnline:
			rstrState.LoadString(IDS_PARTIAL_ONLINE);
			break;
		case ClusterGroupPending:
			rstrState.LoadString(IDS_PENDING);
			break;
		case ClusterGroupOffline:
			rstrState.LoadString(IDS_OFFLINE);
			break;
		case ClusterGroupFailed:
			rstrState.LoadString(IDS_FAILED);
			break;
		default:
			rstrState.Empty();
			break;
	}  // switch:  Cgs()

}  //*** CGroup::GetStateName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::BCanBeEdited
//
//	Routine Description:
//		Determines if the resource can be renamed.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Resource can be renamed.
//		FALSE		Resource cannot be renamed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroup::BCanBeEdited(void) const
{
	BOOL	bCanBeEdited;

	if (   (Cgs() == ClusterGroupStateUnknown)
		|| BReadOnly())
		bCanBeEdited  = FALSE;
	else
		bCanBeEdited = TRUE;

	return bCanBeEdited;

}  //*** CGroup::BCanBeEdited()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::Rename
//
//	Routine Description:
//		Rename the group.
//
//	Arguments:
//		pszName			[IN] New name to give to the group.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		CNTException	Errors returned from SetClusterGroupName().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::Rename(IN LPCTSTR pszName)
{
	DWORD		dwStatus;
	CWaitCursor	wc;

	ASSERT(Hgroup() != NULL);

	if (StrName() != pszName)
	{
		dwStatus = SetClusterGroupName(Hgroup(), pszName);
		if (dwStatus != ERROR_SUCCESS)
			ThrowStaticException(dwStatus, IDS_RENAME_GROUP_ERROR, StrName(), pszName);
		m_strName = pszName;
	}  // if:  the name changed

}  //*** CGroup::Rename()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::Move
//
//	Routine Description:
//		Move the group to another node.
//
//	Arguments:
//		pciNode			[IN] Node to move the group to.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::Move(IN const CClusterNode * pciNode)
{
	DWORD		dwStatus;
	CWaitCursor	wc;

	ASSERT_VALID(pciNode);

	// Do this in case this object is deleted while we are operating on it.
	AddRef();

	if (pciNode->StrName() == StrOwner())
	{
		CString	strMsg;
		strMsg.FormatMessage(IDS_CANT_MOVE_GROUP_TO_SAME_NODE, StrName(), StrOwner());
		AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
	}  // if:  trying to move to the same node
	else
	{
		// Move the group.
		dwStatus = MoveClusterGroup(Hgroup(), pciNode->Hnode());
		if ((dwStatus != ERROR_SUCCESS)
				&& (dwStatus != ERROR_IO_PENDING))
		{
			CNTException	nte(dwStatus, IDS_MOVE_GROUP_ERROR, StrName(), NULL, FALSE /*bAutoDelete*/);
			nte.ReportError();
		}  // if:  error moving the group
	}  // else:  trying to move to a different node

	Release();

}  //*** CGroup::Move()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::BCanBeDropTarget
//
//	Routine Description:
//		Determine if the specified item can be dropped on this item.
//
//	Arguments:
//		pci			[IN OUT] Item to be dropped on this item.
//
//	Return Value:
//		TRUE		Can be drop target.
//		FALSE		Can NOT be drop target.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroup::BCanBeDropTarget(IN const CClusterItem * pci) const
{
	BOOL	bCan;

	// This group can be a drop target only if the specified item
	// is a resource and it is not already a member of this group.

	if (pci->IdsType() == IDS_ITEMTYPE_RESOURCE)
	{
		CResource *	pciRes = (CResource *) pci;
		ASSERT_KINDOF(CResource, pciRes);
		if (pciRes->StrGroup() != StrName())
			bCan = TRUE;
		else
			bCan = FALSE;
		Trace(g_tagGroupDrag, _T("(%s) BCanBeDropTarget() - Dragging resource '%s' (%x) (group = '%s' (%x)) over group '%s' (%x)"), Pdoc()->StrNode(), pciRes->StrName(), pciRes, pciRes->StrGroup(), pciRes->PciGroup(), StrName(), this);
	}  // if:  resource item
	else
		bCan = FALSE;

	return bCan;

}  //*** CGroup::BCanBeDropTarget()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::DropItem
//
//	Routine Description:
//		Process an item being dropped on this item.
//
//	Arguments:
//		pci			[IN OUT] Item dropped on this item.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::DropItem(IN OUT CClusterItem * pci)
{
	if (BCanBeDropTarget(pci))
	{
		POSITION	pos;
		UINT		imenu;
		UINT		idMenu;
		CGroup *	pciGroup;
		CResource *	pciRes;

		// Calculate the ID of this group.
		pos = Pdoc()->LpciGroups().GetHeadPosition();
		for (imenu = 0, idMenu = ID_FILE_MOVE_RESOURCE_1
				; pos != NULL
				; idMenu++)
		{
			pciGroup = (CGroup *) Pdoc()->LpciGroups().GetNext(pos);
			ASSERT_VALID(pciGroup);
			if (pciGroup == this)
				break;
		}  // for:  each group
		ASSERT(imenu < (UINT) Pdoc()->LpciGroups().GetCount());

		// Change the group of the specified resource.
		pciRes = (CResource *) pci;
		ASSERT_KINDOF(CResource, pci);
		ASSERT_VALID(pciRes);
		pciRes->OnCmdMoveResource(idMenu);
	}  // if:  item can be dropped on this item
	else if (pci->IdsType() == IDS_ITEMTYPE_RESOURCE)
	{
		CString		strMsg;

#ifdef _DEBUG
		CResource *	pciRes = (CResource *) pci;

		ASSERT_KINDOF(CResource, pci);
		ASSERT_VALID(pciRes);
		ASSERT(pciRes->StrGroup() == StrName());
#endif // _DEBUG

		strMsg.FormatMessage(
					IDS_CANT_MOVE_RES_TO_GROUP,
					pci->StrName(),
					StrName()
					);

		AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
	}  // else if:  dropped item is a resource
	else
		CClusterItem::DropItem(pci);

}  //*** CGroup::DropItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::OnCmdMsg
//
//	Routine Description:
//		Processes command messages.
//
//	Arguments:
//		nID				[IN] Command ID.
//		nCode			[IN] Notification code.
//		pExtra			[IN OUT] Used according to the value of nCode.
//		pHandlerInfo	[OUT] ???
//
//	Return Value:
//		TRUE			Message has been handled.
//		FALSE			Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroup::OnCmdMsg(
	UINT					nID,
	int						nCode,
	void *					pExtra,
	AFX_CMDHANDLERINFO *	pHandlerInfo
	)
{
	BOOL		bHandled	= FALSE;

	// If this is a MOVE_GROUP command, process it here.
	if ((ID_FILE_MOVE_GROUP_1 <= nID) && (nID <= ID_FILE_MOVE_GROUP_16))
	{
		Trace(g_tagGroup, _T("(%s) OnCmdMsg() %s (%x) - ID = %d, code = %d"), Pdoc()->StrNode(), StrName(), this, nID, nCode);
		if (nCode == 0)
		{
			OnCmdMoveGroup(nID);
			bHandled = TRUE;
		}  // if:  code = 0
	}  // if:  move resource

	if (!bHandled)
		bHandled = CClusterItem::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

	return bHandled;

}  //*** CGroup::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::OnUpdateBringOnline
//
//	Routine Description:
//		Determines whether menu items corresponding to ID_FILE_BRING_ONLINE
//		should be enabled or not.
//
//	Arguments:
//		pCmdUI		[IN OUT] Command routing object.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnUpdateBringOnline(CCmdUI * pCmdUI)
{
	if (   (Cgs() != ClusterGroupOnline)
		&& (Cgs() != ClusterGroupPending)
		&& (Cgs() != ClusterGroupStateUnknown))
		pCmdUI->Enable(TRUE);
	else
		pCmdUI->Enable(FALSE);

}  //*** CGroup::OnUpdateBringOnline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::OnUpdateTakeOffline
//
//	Routine Description:
//		Determines whether menu items corresponding to ID_FILE_TAKE_OFFLINE
//		should be enabled or not.
//
//	Arguments:
//		pCmdUI		[IN OUT] Command routing object.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnUpdateTakeOffline(CCmdUI * pCmdUI)
{
	if (   (Cgs() == ClusterGroupOnline)
		|| (Cgs() == ClusterGroupPartialOnline))
		pCmdUI->Enable(TRUE);
	else
		pCmdUI->Enable(FALSE);

}  //*** CGroup::OnUpdateTakeOffline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::OnUpdateMoveGroup
//
//	Routine Description:
//		Determines whether menu items corresponding to ID_FILE_MOVE_GROUP
//		should be enabled or not.
//
//	Arguments:
//		pCmdUI		[IN OUT] Command routing object.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnUpdateMoveGroup(CCmdUI * pCmdUI)
{
	if (   (pCmdUI->m_pSubMenu == NULL)
		&& (pCmdUI->m_pParentMenu == NULL))
	{
		if (   (Cgs() == ClusterGroupStateUnknown)
			|| (Cgs() == ClusterGroupPending)
			|| (Pdoc()->LpciNodes().GetCount() < 2))
			pCmdUI->Enable(FALSE);
		else
			pCmdUI->Enable(TRUE);
	}  // if:  nested menu is being displayed
	else
	{
		BOOL	bEnabled;
		CString	strMenuName;

		if (pCmdUI->m_pMenu != NULL)
		{
			pCmdUI->m_pMenu->GetMenuString(0, strMenuName, MF_BYPOSITION);
			Trace(g_tagGroupMenu, _T("(%s) pMenu(0) = '%s'"), Pdoc()->StrNode(), strMenuName);
			pCmdUI->m_pMenu->GetMenuString(pCmdUI->m_nIndex, strMenuName, MF_BYPOSITION);
			Trace(g_tagGroupMenu, _T("(%s) pMenu(%d) = '%s'"), Pdoc()->StrNode(), pCmdUI->m_nIndex, strMenuName);
		}  // if:  main menu

		if (pCmdUI->m_pSubMenu != NULL)
		{
			pCmdUI->m_pSubMenu->GetMenuString(0, strMenuName, MF_BYPOSITION);
			Trace(g_tagGroupMenu, _T("(%s) pSubMenu(0) = '%s'"), Pdoc()->StrNode(), strMenuName);
			pCmdUI->m_pSubMenu->GetMenuString(pCmdUI->m_nIndex, strMenuName, MF_BYPOSITION);
			Trace(g_tagGroupMenu, _T("(%s) pSubMenu(%d) = '%s'"), Pdoc()->StrNode(), pCmdUI->m_nIndex, strMenuName);
		}  // if:  submenu

		// Handle the menu item based on whether it is on the main menu
		// or on the submenu.

		if (pCmdUI->m_pSubMenu == NULL)
		{
			bEnabled = OnUpdateMoveGroupItem(pCmdUI);
			pCmdUI->Enable(bEnabled);
		}  // if:  on the main menu
		else
		{
			bEnabled = OnUpdateMoveGroupSubMenu(pCmdUI);
		}  // else:  on the submenu

		// Enable or disable the Move menu.
		pCmdUI->m_pMenu->EnableMenuItem(
							pCmdUI->m_nIndex,
							MF_BYPOSITION
							| (bEnabled ? MF_ENABLED : MF_GRAYED)
							);
	}  // else:  top-level menu is being displayed

}  //*** CGroup::OnUpdateMoveGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::OnUpdateMoveGroupItem
//
//	Routine Description:
//		Determines whether menu items corresponding to ID_FILE_MOVE_GROUP
//		that are not popups should be enabled or not.
//
//	Arguments:
//		pCmdUI		[IN OUT] Command routing object.
//
//	Return Value:
//		TRUE		Item should be enabled.
//		FALSE		Item should be disabled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroup::OnUpdateMoveGroupItem(CCmdUI * pCmdUI)
{
	BOOL	bEnabled;

	// If there are more than two nodes, make the menu item a submenu.
	if (   (Cgs() == ClusterGroupStateUnknown)
		|| (Cgs() == ClusterGroupPending)
		|| (Pdoc()->LpciNodes().GetCount() < 2))
		bEnabled = FALSE;
	else if (Pdoc()->LpciNodes().GetCount() == 2)
		bEnabled = TRUE;
	else
	{
		UINT			idMenu;
		POSITION		pos;
		CClusterNode *	pciNode;
		CString			strMenuName;
		CMenu			menuMove;
		CMenu *			pmenu	= pCmdUI->m_pMenu;

		// Load the Move submenu.
		VERIFY(menuMove.LoadMenu(IDM_MOVE_GROUP) != 0);
		ASSERT(menuMove.GetMenuItemCount() == 2);

		// Add all the nodes in the cluster to the end of the menu.
		pos = Pdoc()->LpciNodes().GetHeadPosition();
		for (idMenu = ID_FILE_MOVE_GROUP_1
				; pos != NULL
				; idMenu++)
		{
			pciNode = (CClusterNode *) Pdoc()->LpciNodes().GetNext(pos);
			ASSERT_VALID(pciNode);
			VERIFY(menuMove.AppendMenu(
								MF_BYPOSITION | MF_STRING,
								idMenu,
								pciNode->StrName()
								));
		}  // for:  each node

		// Get the name of the menu.
		pmenu->GetMenuString(pCmdUI->m_nIndex, strMenuName, MF_BYPOSITION);

		Trace(g_tagGroupMenu, _T("(%s) Making item '%s' a submenu"), Pdoc()->StrNode(), strMenuName);

		// Modify this menu item.
		VERIFY(pmenu->ModifyMenu(
							pCmdUI->m_nIndex,
							MF_BYPOSITION | MF_STRING | MF_POPUP,
							(UINT_PTR) menuMove.m_hMenu,
							strMenuName
							));

		// Detach the menu from the class since we don't own it anymore.
		menuMove.Detach();

		bEnabled = TRUE;
	}  // else:  more than two nodes in the cluster

	return bEnabled;

}  //*** CGroup::OnUpdateMoveGroupItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::OnUpdateMoveGroupSubMenu
//
//	Routine Description:
//		Determines whether menu items corresponding to ID_FILE_MOVE_GROUP
//		that are on popups should be enabled or not.
//
//	Arguments:
//		pCmdUI		[IN OUT] Command routing object.
//
//	Return Value:
//		TRUE		Item should be enabled.
//		FALSE		Item should be disabled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroup::OnUpdateMoveGroupSubMenu(CCmdUI * pCmdUI)
{
	BOOL	bEnabled;

	// If there are not more than two nodes, make the menu item a normal item.
	if (Pdoc()->LpciNodes().GetCount() > 2)
		bEnabled = TRUE;
	else
	{
		CString			strMenuName;
		CMenu *			pmenu	= pCmdUI->m_pMenu;

		// Get the name of the menu.
		pmenu->GetMenuString(pCmdUI->m_nIndex, strMenuName, MF_BYPOSITION);

		Trace(g_tagGroupMenu, _T("(%s) Making item '%s' a non-submenu"), Pdoc()->StrNode(), strMenuName);

		// Modify this menu item.
		// We should be able to just modify the menu, but for some reason
		// this doesn't work.  So, instead, we will remove the previous item
		// and add a new item.
#ifdef NEVER
		VERIFY(pmenu->ModifyMenu(
							pCmdUI->m_nIndex,
							MF_BYPOSITION | MF_STRING,
							ID_FILE_MOVE_GROUP,
							strMenuName
							));
#else
		VERIFY(pmenu->DeleteMenu(pCmdUI->m_nIndex, MF_BYPOSITION));
		VERIFY(pmenu->InsertMenu(
							pCmdUI->m_nIndex,
							MF_BYPOSITION | MF_STRING,
							ID_FILE_MOVE_GROUP,
							strMenuName
							));
#endif

		if (   (Cgs() == ClusterGroupStateUnknown)
			|| (Cgs() == ClusterGroupPending)
			|| (Pdoc()->LpciNodes().GetCount() < 2))
			bEnabled = FALSE;
		else
			bEnabled = TRUE;

		AfxGetMainWnd()->DrawMenuBar();
	}  // else:  not more than two nodes in the cluster

	return bEnabled;

}  //*** CGroup::OnUpdateMoveGroupSubMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::OnUpdateMoveGroupRest
//
//	Routine Description:
//		Determines whether menu items corresponding to ID_FILE_MOVE_GROUP_1
//		through ID_FILE_MOVE_GROUP_16 should be enabled or not.
//
//	Arguments:
//		pCmdUI		[IN OUT] Command routing object.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnUpdateMoveGroupRest(CCmdUI * pCmdUI)
{
	if (   (Cgs() == ClusterGroupStateUnknown)
		|| (Cgs() == ClusterGroupPending))
		pCmdUI->Enable(FALSE);
	else
		pCmdUI->Enable(TRUE);

}  //*** CGroup::OnUpdateMoveGroupRest()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::OnUpdateDelete
//
//	Routine Description:
//		Determines whether menu items corresponding to ID_FILE_DELETE
//		should be enabled or not.
//
//	Arguments:
//		pCmdUI		[IN OUT] Command routing object.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnUpdateDelete(CCmdUI * pCmdUI)
{
	if (   (Cgs() != ClusterGroupStateUnknown)
		&& (Cgs() != ClusterGroupPending)
		&& Lpcires().IsEmpty())
		pCmdUI->Enable(TRUE);
	else
		pCmdUI->Enable(FALSE);

}  //*** CGroup::OnUpdateDelete()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::OnCmdBringOnline
//
//	Routine Description:
//		Processes the ID_FILE_BRING_ONLINE menu command.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnCmdBringOnline(void)
{
	DWORD		dwStatus;
	CWaitCursor	wc;

	ASSERT(Hgroup() != NULL);

	// Do this in case this object is deleted while we are operating on it.
	AddRef();

	dwStatus = OnlineClusterGroup(Hgroup(), NULL);
	if ((dwStatus != ERROR_SUCCESS)
			&& (dwStatus != ERROR_IO_PENDING))
	{
		CNTException	nte(dwStatus, IDS_BRING_GROUP_ONLINE_ERROR, StrName(), NULL, FALSE /*bAutoDelete*/);
		nte.ReportError();
	}  // if:  error bringing the group online

	UpdateState();

	Release();

}  //*** CGroup::OnCmdBringOnline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::OnCmdTakeOffline
//
//	Routine Description:
//		Processes the ID_FILE_TAKE_OFFLINE menu command.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnCmdTakeOffline(void)
{
	DWORD		dwStatus;
	CWaitCursor	wc;

	ASSERT(Hgroup() != NULL);

	// Do this in case this object is deleted while we are operating on it.
	AddRef();

	dwStatus = OfflineClusterGroup(Hgroup());
	if ((dwStatus != ERROR_SUCCESS)
			&& (dwStatus != ERROR_IO_PENDING))
	{
		CNTException	nte(dwStatus, IDS_TAKE_GROUP_OFFLINE_ERROR, StrName(), NULL, FALSE /*bAUtoDelete*/);
		nte.ReportError();
	}  // if:  error taking the group offline

	UpdateState();

	Release();

}  //*** CGroup::OnCmdTakeOffline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::OnCmdMoveGroup
//
//	Routine Description:
//		Processes the ID_FILE_MOVE_GROUP menu command.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnCmdMoveGroup(void)
{
	OnCmdMoveGroup((UINT) -1);

}  //*** CGroup::OnCmdMoveGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::OnCmdMoveGroup
//
//	Routine Description:
//		Processes the ID_FILE_MOVE_GROUP_1 through ID_FILE_MOVE_GROUP_16 menu
//		commands.
//
//	Arguments:
//		nID				[IN] Command ID.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnCmdMoveGroup(IN UINT nID)
{
	DWORD			dwStatus;
	HNODE			hnode;
	CClusterNode *	pciNode;
	CWaitCursor		wc;

	ASSERT(Hgroup() != NULL);

	// Do this in case this object is deleted while we are operating on it.
	AddRef();

	do // do-while to prevent goto's
	{
		// Get the handle of the node to move the group to.
		if ((int) nID >= 0)
		{
			int			ipci;

			ipci = (int) (nID - ID_FILE_MOVE_GROUP_1);
			ASSERT(ipci < Pdoc()->LpciNodes().GetCount());
			if (ipci < Pdoc()->LpciNodes().GetCount())
			{
				POSITION		pos;

				// Get the node.
				pos = Pdoc()->LpciNodes().FindIndex(ipci);
				ASSERT(pos);
				pciNode = (CClusterNode *) Pdoc()->LpciNodes().GetAt(pos);
				ASSERT_VALID(pciNode);

				hnode = pciNode->Hnode();
			}  // if:  valid node index
			else
				break;
		}  // if:  non-default ID specified
		else
		{
			hnode = NULL;
			pciNode = NULL;
		}  // else:  default ID specified

		// Move the group.
		dwStatus = MoveClusterGroup(Hgroup(), hnode);
		if ((dwStatus != ERROR_SUCCESS)
				&& (dwStatus != ERROR_IO_PENDING))
		{
			CNTException	nte(dwStatus, IDS_MOVE_GROUP_ERROR, StrName(), NULL, FALSE /*bAutoDelete*/);
			nte.ReportError();
		}  // if:  error moving the group

		UpdateState();
	}  while (0); // do-while to prevent goto's

	Release();

}  //*** CGroup::OnCmdMoveGroup(nID)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::OnCmdDelete
//
//	Routine Description:
//		Processes the ID_FILE_DELETE menu command.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnCmdDelete(void)
{
	ASSERT(Hgroup() != NULL);

	// Do this in case this object is deleted while we are operating on it.
	AddRef();

	do // do-while to prevent goto's
	{
		// Verify that the user really wants to delete this resource.
		{
			CString		strMsg;

			strMsg.FormatMessage(IDS_VERIFY_DELETE_GROUP, StrName());
			if (AfxMessageBox(strMsg, MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
				break;
		}  // Verify that the user really wants to delete this resource

		try
		{
			DeleteGroup();
		}  // try
		catch (CNTException * pnte)
		{
			if (pnte->Sc() != ERROR_GROUP_NOT_AVAILABLE)
				pnte->ReportError();
			pnte->Delete();
		}  // catch:  CNTException
		catch (CException * pe)
		{
			pe->ReportError();
			pe->Delete();
		}  // catch:  CException
	}  while (0); // do-while to prevent goto's

	Release();

}  //*** CGroup::OnCmdDelete()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::OnUpdateProperties
//
//	Routine Description:
//		Determines whether menu items corresponding to ID_FILE_PROPERTIES
//		should be enabled or not.
//
//	Arguments:
//		pCmdUI		[IN OUT] Command routing object.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroup::OnUpdateProperties(CCmdUI * pCmdUI)
{
	pCmdUI->Enable(TRUE);

}  //*** CGroup::OnUpdateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::BDisplayProperties
//
//	Routine Description:
//		Display properties for the object.
//
//	Arguments:
//		bReadOnly	[IN] Don't allow edits to the object properties.
//
//	Return Value:
//		TRUE	OK pressed.
//		FALSE	OK not pressed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroup::BDisplayProperties(IN BOOL bReadOnly)
{
	BOOL			bChanged = FALSE;
	CGroupPropSheet	sht(AfxGetMainWnd());

	// Do this in case this object is deleted while we are operating on it.
	AddRef();

	// If the object has changed, read it.
	if (BChanged())
		ReadItem();

	// Display the property sheet.
	try
	{
		sht.SetReadOnly(bReadOnly);
		if (sht.BInit(this, IimgObjectType()))
			bChanged = ((sht.DoModal() == IDOK) && !bReadOnly);
	}  // try
	catch (CException * pe)
	{
		pe->Delete();
	}  // catch:  CException

	Release();
	return bChanged;

}  //*** CGroup::BDisplayProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGroup::OnClusterNotify
//
//	Routine Description:
//		Handler for the WM_CAM_CLUSTER_NOTIFY message.
//		Processes cluster notifications for this object.
//
//	Arguments:
//		pnotify		[IN OUT] Object describing the notification.
//
//	Return Value:
//		Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CGroup::OnClusterNotify(IN OUT CClusterNotify * pnotify)
{
	ASSERT(pnotify != NULL);
	ASSERT_VALID(this);

	try
	{
		switch (pnotify->m_dwFilterType)
		{
			case CLUSTER_CHANGE_GROUP_STATE:
				Trace(g_tagGroupNotify, _T("(%s) - Group '%s' (%x) state changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
				UpdateState();
				break;

			case CLUSTER_CHANGE_GROUP_DELETED:
				Trace(g_tagGroupNotify, _T("(%s) - Group '%s' (%x) deleted (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
				if (Pdoc()->BClusterAvailable())
					Delete();
				break;

			case CLUSTER_CHANGE_GROUP_PROPERTY:
				Trace(g_tagGroupNotify, _T("(%s) - Group '%s' (%x) properties changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
				if (Pdoc()->BClusterAvailable())
					ReadItem();
				break;

			case CLUSTER_CHANGE_REGISTRY_NAME:
				Trace(g_tagGroupRegNotify, _T("(%s) - Registry namespace '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
				MarkAsChanged();
				break;

			case CLUSTER_CHANGE_REGISTRY_ATTRIBUTES:
				Trace(g_tagGroupRegNotify, _T("(%s) - Registry attributes for '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName());
				MarkAsChanged();
				break;

			case CLUSTER_CHANGE_REGISTRY_VALUE:
				Trace(g_tagGroupRegNotify, _T("(%s) - Registry value at '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
				MarkAsChanged();
				break;

			default:
				Trace(g_tagGroupNotify, _T("(%s) - Unknown group notification (%x) for '%s' (%x) (%s)"), Pdoc()->StrNode(), pnotify->m_dwFilterType, StrName(), this, pnotify->m_strName);
		}  // switch:  dwFilterType
	}  // try
	catch (CException * pe)
	{
		// Don't display anything on notification errors.
		// If it's really a problem, the user will see it when
		// refreshing the view.
		//pe->ReportError();
		pe->Delete();
	}  // catch:  CException

	delete pnotify;
	return 0;

}  //*** CGroup::OnClusterNotify()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DeleteAllItemData
//
//	Routine Description:
//		Deletes all item data in a CList.
//
//	Arguments:
//		rlp		[IN OUT] List whose data is to be deleted.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef NEVER
void DeleteAllItemData(IN OUT CGroupList & rlp)
{
	POSITION	pos;
	CGroup *	pci;

	// Delete all the items in the list.
	pos = rlp.GetHeadPosition();
	while (pos != NULL)
	{
		pci = rlp.GetNext(pos);
		ASSERT_VALID(pci);
//		Trace(g_tagClusItemDelete, _T("DeleteAllItemData(rlpcigrp) - Deleting group cluster item '%s' (%x)"), pci->StrName(), pci);
		pci->Delete();
	}  // while:  more items in the list

}  //*** DeleteAllItemData()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\helpdata.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		HelpData.h
//
//	Abstract:
//		Definitions for data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _HELPDATA_H_
#define _HELPDATA_H_

#include "HelpArr.h"

/////////////////////////////////////////////////////////////////////////////

#endif // _HELPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\group.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		Group.h
//
//	Abstract:
//		Definition of the CGroup class.
//
//	Implementation File:
//		Group.cpp
//
//	Author:
//		David Potter (davidp)	May 3, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _GROUP_H_
#define _GROUP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CGroup;
class CGroupList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterDoc;
class CClusterNode;
class CNodeList;
class CResourceList;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_
#include "ClusItem.h"	// for CClusterItem
#endif

#ifndef _RES_H_
#include "Res.h"		// for CResourceList
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CObjectProperty, CClusPropList
#endif

/////////////////////////////////////////////////////////////////////////////
// CGroup command target
/////////////////////////////////////////////////////////////////////////////

class CGroup : public CClusterItem
{
	DECLARE_DYNCREATE(CGroup)

// Construction
public:
	CGroup(void);			// protected constructor used by dynamic creation
	CGroup(IN BOOL bDocObj);
	void					Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName);
	void					Create(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName);

protected:
	void					CommonConstruct(void);

// Attributes
protected:
	HGROUP					m_hgroup;
    CLUSTER_GROUP_STATE		m_cgs;
	CString					m_strOwner;
	CClusterNode *			m_pciOwner;
	CResourceList *			m_plpcires;

	DWORD					m_nFailoverThreshold;
	DWORD					m_nFailoverPeriod;
	CGAFT					m_cgaftAutoFailbackType;
	DWORD					m_nFailbackWindowStart;
	DWORD					m_nFailbackWindowEnd;

	CNodeList *				m_plpcinodePreferredOwners;

	enum
	{
		epropName = 0,
		epropDescription,
		epropFailoverThreshold,
		epropFailoverPeriod,
		epropAutoFailbackType,
		epropFailbackWindowStart,
		epropFailbackWindowEnd,
		epropMAX
	};

	CObjectProperty		m_rgProps[epropMAX];

public:
	HGROUP					Hgroup(void) const				{ return m_hgroup; }
	CLUSTER_GROUP_STATE		Cgs(void) const					{ return m_cgs; }
	const CString &			StrOwner(void) const			{ return m_strOwner; }
	CClusterNode *			PciOwner(void) const			{ return m_pciOwner; }
	const CResourceList &	Lpcires(void) const				{ ASSERT(m_plpcires != NULL); return *m_plpcires; }

	DWORD					NFailoverThreshold(void) const		{ return m_nFailoverThreshold; }
	DWORD					NFailoverPeriod(void) const			{ return m_nFailoverPeriod; }
	CGAFT					CgaftAutoFailbackType(void) const	{ return m_cgaftAutoFailbackType; }
	DWORD					NFailbackWindowStart(void) const	{ return m_nFailbackWindowStart; }
	DWORD					NFailbackWindowEnd(void) const		{ return m_nFailbackWindowEnd; }

	const CNodeList &		LpcinodePreferredOwners(void) const	{ ASSERT(m_plpcinodePreferredOwners != NULL); return *m_plpcinodePreferredOwners; }

	void					GetStateName(OUT CString & rstrState) const;

// Operations
public:
	void					Move(IN const CClusterNode * pciNode);
	void					DeleteGroup(void);
	void					ReadExtensions(void);
	void					SetOwnerState(IN LPCTSTR pszNewOwner);

	void					AddResource(IN OUT CResource * pciResource);
	void					RemoveResource(IN OUT CResource * pciResource);

	void					SetName(IN LPCTSTR pszName);
	void					SetPreferredOwners(IN const CNodeList & rlpci);
	void					SetCommonProperties(
								IN const CString &	rstrDesc,
								IN DWORD			nThreshold,
								IN DWORD			nPeriod,
								IN CGAFT			cgaft,
								IN DWORD			nStart,
								IN DWORD			nEnd,
								IN BOOL				bValidateOnly
								);
	void					SetCommonProperties(
								IN const CString &	rstrDesc,
								IN DWORD			nThreshold,
								IN DWORD			nPeriod,
								IN CGAFT			cgaft,
								IN DWORD			nStart,
								IN DWORD			nEnd
								)
	{
		SetCommonProperties(rstrDesc, nThreshold, nPeriod, cgaft, nStart, nEnd, FALSE /*bValidateOnly*/);
	}
	void					ValidateCommonProperties(
								IN const CString &	rstrDesc,
								IN DWORD			nThreshold,
								IN DWORD			nPeriod,
								IN CGAFT			cgaft,
								IN DWORD			nStart,
								IN DWORD			nEnd
								)
	{
		SetCommonProperties(rstrDesc, nThreshold, nPeriod, cgaft, nStart, nEnd, TRUE /*bValidateOnly*/);
	}

	void					ConstructList(OUT CNodeList & rlpci, IN DWORD dwType);
	void					ConstructList(OUT CResourceList & rlpci, IN DWORD dwType);
	void					ConstructPossibleOwnersList(OUT CNodeList & rlpciNodes);

// Overrides
public:
	virtual void			Cleanup(void);
	virtual	void			ReadItem(void);
	virtual	void			UpdateState(void);
	virtual void			Rename(IN LPCTSTR pszName);
	virtual	BOOL			BGetColumnData(IN COLID colid, OUT CString & rstrText);
	virtual BOOL			BCanBeEdited(void) const;
	virtual BOOL			BDisplayProperties(IN BOOL bReadOnly = FALSE);

	// Drag & Drop
	virtual BOOL			BCanBeDragged(void) const	{ return TRUE; }
	virtual BOOL			BCanBeDropTarget(IN const CClusterItem * pci) const;
	virtual void			DropItem(IN OUT CClusterItem * pci);

	virtual const CStringList *	PlstrExtensions(void) const;

#ifdef _DISPLAY_STATE_TEXT_IN_TREE
	virtual void			GetTreeName(OUT CString & rstrName) const;
#endif

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGroup)
	public:
	virtual void OnFinalRelease();
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	//}}AFX_VIRTUAL

	virtual LRESULT			OnClusterNotify(IN OUT CClusterNotify * pnotify);

protected:
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }
	virtual DWORD					DwSetCommonProperties(IN const CClusPropList & rcpl, IN BOOL bValidateOnly = FALSE);

// Implementation
public:
	virtual ~CGroup(void);

public:
	// Generated message map functions
	//{{AFX_MSG(CGroup)
	afx_msg void OnUpdateBringOnline(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTakeOffline(CCmdUI* pCmdUI);
	afx_msg void OnUpdateMoveGroup(CCmdUI* pCmdUI);
	afx_msg void OnUpdateMoveGroupRest(CCmdUI* pCmdUI);
	afx_msg void OnUpdateDelete(CCmdUI* pCmdUI);
	afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
	afx_msg void OnCmdBringOnline();
	afx_msg void OnCmdTakeOffline();
	afx_msg void OnCmdMoveGroup();
	afx_msg void OnCmdDelete();
	//}}AFX_MSG
	afx_msg BOOL OnUpdateMoveGroupItem(CCmdUI* pCmdUI);
	afx_msg BOOL OnUpdateMoveGroupSubMenu(CCmdUI* pCmdUI);
	afx_msg void OnCmdMoveGroup(IN UINT nID);

	DECLARE_MESSAGE_MAP()
#ifdef _CLUADMIN_USE_OLE_
	DECLARE_OLECREATE(CGroup)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CGroup)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
#endif // _CLUADMIN_USE_OLE_

};  //*** class CGroup

/////////////////////////////////////////////////////////////////////////////
// CGroupList
/////////////////////////////////////////////////////////////////////////////

class CGroupList : public CClusterItemList
{
public:
	CGroup *		PciGroupFromName(
						IN LPCTSTR		pszName,
						OUT POSITION *	ppos = NULL
						)
	{
		return (CGroup *) PciFromName(pszName, ppos);
	}

};  //*** class CGroupList

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

//void DeleteAllItemData(IN OUT CGroupList & rlp);

#ifdef _DEBUG
class CTraceTag;
extern CTraceTag g_tagGroup;
extern CTraceTag g_tagGroupNotify;
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _GROUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\grpprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		GrpProp.cpp
//
//	Abstract:
//		Definition of the group property sheet and pages.
//
//	Author:
//		David Potter (davidp)	May 14, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _GRPPROP_H_
#define _GRPPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePPag.h"	// for CBasePropertyPage
#endif

#ifndef _BASESHT_H_
#include "BasePSht.h"	// for CBasePropertySheet
#endif

#ifndef _GROUP_H_
#include "Group.h"		// for CGroup
#endif

#ifndef _NODE_H_
#include "Node.h"		// for CNodeList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CGroupGeneralPage;
class CGroupFailoverPage;
class CGroupFailbackPage;
class CGroupPropSheet;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CGroupGeneralPage dialog
/////////////////////////////////////////////////////////////////////////////

class CGroupGeneralPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CGroupGeneralPage)

// Construction
public:
	CGroupGeneralPage(void);
	virtual	BOOL			BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CGroupGeneralPage)
	enum { IDD = IDD_PP_GROUP_GENERAL };
	CEdit	m_editDesc;
	CButton	m_pbPrefOwnersModify;
	CListBox	m_lbPrefOwners;
	CEdit	m_editName;
	CString	m_strName;
	CString	m_strDesc;
	CString	m_strState;
	CString	m_strNode;
	//}}AFX_DATA

	CNodeList				m_lpciPreferredOwners;

	const CNodeList &		LpciPreferredOwners(void) const	{ return m_lpciPreferredOwners; }

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGroupGeneralPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CGroupPropSheet *		PshtGroup(void)	{ return (CGroupPropSheet *) Psht(); }
	CGroup *				PciGroup(void)	{ return (CGroup *) Pci(); }

	void					FillPrefOwners(void);

	// Generated message map functions
	//{{AFX_MSG(CGroupGeneralPage)
	afx_msg void OnModifyPreferredOwners();
	virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnDblClkPreferredOwners();
	//}}AFX_MSG
	afx_msg void OnProperties();
	DECLARE_MESSAGE_MAP()

};  //*** class CGroupGeneralPage

/////////////////////////////////////////////////////////////////////////////
// CGroupFailoverPage dialog
/////////////////////////////////////////////////////////////////////////////

class CGroupFailoverPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CGroupFailoverPage)

// Construction
public:
	CGroupFailoverPage(void);
	virtual	BOOL			BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CGroupFailoverPage)
	enum { IDD = IDD_PP_GROUP_FAILOVER };
	CEdit	m_editThreshold;
	CEdit	m_editPeriod;
	//}}AFX_DATA
	DWORD	m_nThreshold;
	DWORD	m_nPeriod;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGroupFailoverPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CGroupPropSheet *		PshtGroup(void)	{ return (CGroupPropSheet *) Psht(); }
	CGroup *				PciGroup(void)	{ return (CGroup *) Pci(); }

	// Generated message map functions
	//{{AFX_MSG(CGroupFailoverPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CGroupFailoverPage

/////////////////////////////////////////////////////////////////////////////
// CGroupFailbackPage dialog
/////////////////////////////////////////////////////////////////////////////

class CGroupFailbackPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CGroupFailbackPage)

// Construction
public:
	CGroupFailbackPage(void);
	virtual	BOOL			BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CGroupFailbackPage)
	enum { IDD = IDD_PP_GROUP_FAILBACK };
	CButton	m_rbPreventFailback;
	CButton	m_rbAllowFailback;
	CButton	m_rbFBImmed;
	CButton	m_rbFBWindow;
	CStatic	m_staticFBWindow1;
	CStatic	m_staticFBWindow2;
	CEdit	m_editStart;
	CSpinButtonCtrl	m_spinStart;
	CEdit	m_editEnd;
	CSpinButtonCtrl	m_spinEnd;
	//}}AFX_DATA
	CGAFT	m_cgaft;
	BOOL	m_bNoFailbackWindow;
	DWORD	m_nStart;
	DWORD	m_nEnd;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGroupFailbackPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CGroupPropSheet *		PshtGroup(void)	{ return (CGroupPropSheet *) Psht(); }
	CGroup *				PciGroup(void)	{ return (CGroup *) Pci(); }

	// Generated message map functions
	//{{AFX_MSG(CGroupFailbackPage)
	afx_msg void OnClickedPreventFailback(void);
	afx_msg void OnClickedAllowFailback(void);
	afx_msg void OnClickedFailbackImmediate(void);
	afx_msg void OnClickedFailbackInWindow(void);
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CGroupFailbackPage

/////////////////////////////////////////////////////////////////////////////
// CGroupPropSheet
/////////////////////////////////////////////////////////////////////////////

class CGroupPropSheet : public CBasePropertySheet
{
	DECLARE_DYNAMIC(CGroupPropSheet)

// Construction
public:
	CGroupPropSheet(
		IN OUT CWnd *	pParentWnd = NULL,
		IN UINT			iSelectPage = 0
		);
	virtual BOOL					BInit(
										IN OUT CClusterItem *	pciCluster,
										IN IIMG					iimgIcon
										);

// Attributes
protected:
	CBasePropertyPage *				m_rgpages[3];

	// Pages
	CGroupGeneralPage				m_pageGeneral;
	CGroupFailoverPage				m_pageFailover;
	CGroupFailbackPage				m_pageFailback;

	CGroupGeneralPage &				PageGeneral(void)		{ return m_pageGeneral; }
	CGroupFailoverPage &			PageFailover(void)		{ return m_pageFailover; }
	CGroupFailbackPage &			PageFailback(void)		{ return m_pageFailback; }

public:
	CGroup *						PciGroup(void) const	{ return (CGroup *) Pci(); }

	virtual CBasePropertyPage **	Ppages(void);
	virtual int						Cpages(void);

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGroupPropSheet)
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGroupPropSheet)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CGroupPropSheet

/////////////////////////////////////////////////////////////////////////////

#endif // _GRPPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\guids.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		Guids.cpp
//
//	Abstract:
//		Implements GUIDS for the application.
//
//	Author:
//		David Potter (davidp)	June 4, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#define INC_OLE2

#include "stdafx.h"
#include <initguid.h>
#include "DataObj.h"
#include "CluAdmID.h"

#define IID_DEFINED
#include "CluAdmID_i.c"

CComModule _Module;

#pragma warning(disable : 4701) // local variable may be used without having been initialized
#include <atlimpl.cpp>
#pragma warning(default : 4701)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\helparr.h ===
#define IDH_DISABLEHELP ((DWORD)-1)

#ifdef INITHELPARRAYS


const DWORD g_aHelpIDs_IDD_ABOUTBOX[]=
{
	IDC_ABOUT_ICON, IDH_DISABLEHELP,
	IDC_ABOUT_PRODUCT_TITLE,IDH_ABOUT_PRODUCT_TITLE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_BROWSE_CLUSTERS[]=
{
	IDC_BC_CLUSTER_LABEL, IDH_BC_CLUSTER,
	IDC_BC_CLUSTER,IDH_BC_CLUSTER,
	IDC_BC_LIST,IDH_BC_LIST,
	IDOK, IDH_DISABLEHELP,
	IDCANCEL, IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_DELETE_RESOURCES[]=
{
	IDC_DR_LABEL_1, IDH_DR_RESOURCES_LIST,
	IDC_DR_RESOURCES_LIST,IDH_DR_RESOURCES_LIST,
	IDC_DR_LABEL_2, IDH_DISABLEHELP,
	IDYES,IDH_YES_DEL_RES,
	IDNO,IDH_NO_DEL_RES,
	0, 0
};

const DWORD g_aHelpIDs_IDD_MODIFY_DEPENDENCIES[]=
{
	IDC_LCP_LEFT_LABEL, IDH_LCP_LEFT_LIST,
	IDC_LCP_LEFT_LIST,IDH_LCP_LEFT_LIST,
	IDC_LCP_ADD,IDH_LCP_ADD,
	IDC_LCP_REMOVE,IDH_LCP_REMOVE,
	IDC_LCP_RIGHT_LABEL, IDH_LCP_RIGHT_LIST,
	IDC_LCP_RIGHT_LIST,IDH_LCP_RIGHT_LIST,
	IDOK, IDH_DISABLEHELP,
	IDCANCEL, IDH_DISABLEHELP,
	IDC_LCP_PROPERTIES,IDH_LCP_PROPERTIES,
	0, 0
};

const DWORD g_aHelpIDs_IDD_MODIFY_POSSIBLE_OWNERS[]=
{
	IDC_LCP_LEFT_LABEL, IDH_POSSIBLE_LCP_LEFT_LIST,
	IDC_LCP_LEFT_LIST,IDH_POSSIBLE_LCP_LEFT_LIST,
	IDC_LCP_ADD,IDH_POSSIBLE_LCP_ADD,
	IDC_LCP_REMOVE,IDH_POSIBLE_LCP_REMOVE,
	IDC_LCP_RIGHT_LABEL, IDH_POSSIBLE_LCP_RIGHT_LIST,
	IDC_LCP_RIGHT_LIST,IDH_POSSIBLE_LCP_RIGHT_LIST,
	IDOK, IDH_DISABLEHELP,
	IDCANCEL, IDH_DISABLEHELP,
	IDC_LCP_PROPERTIES,IDH_POSSIBLE_LCP_PROPERTIES,
	0, 0
};

const DWORD g_aHelpIDs_IDD_MODIFY_PREFERRED_OWNERS[]=
{
	IDC_LCP_LEFT_LABEL, IDH_PREF_LCP_LEFT_LIST,
	IDC_LCP_LEFT_LIST,IDH_PREF_LCP_LEFT_LIST,
	IDC_LCP_ADD,IDH_POSSIBLE_LCP_ADD,
	IDC_LCP_REMOVE, IDH_POSIBLE_LCP_REMOVE,
	IDC_LCP_RIGHT_LABEL, IDH_PREF_LCP_RIGHT_LIST,
	IDC_LCP_RIGHT_LIST,IDH_PREF_LCP_RIGHT_LIST,
	IDC_LCP_MOVE_UP,IDH_LCP_MOVE_UP,
	IDC_LCP_MOVE_DOWN,IDH_LCP_MOVE_DOWN,
	IDOK, IDH_DISABLEHELP,
	IDCANCEL, IDH_DISABLEHELP,
	IDC_LCP_PROPERTIES,IDH_LCP_PROPERTIES,
	0, 0
};

const DWORD g_aHelpIDs_IDD_MOVE_RESOURCES[]=
{
	IDC_MR_LABEL_1, IDH_MR_RESOURCES_LIST,
	IDC_MR_RESOURCES_LIST,IDH_MR_RESOURCES_LIST,
	IDC_MR_LABEL_2, IDH_DISABLEHELP,
	IDYES,IDH_YES_MOVE_RES,
	IDNO,IDH_NO_MOVE_RES,
	0, 0
};

const DWORD g_aHelpIDs_IDD_OPEN_CLUSTER[]=
{
	IDC_OCD_NAME_LABEL, IDH_OCD_NAME,
	IDC_OCD_NAME,IDH_OCD_NAME,
	IDC_OCD_BROWSE,IDH_OCD_BROWSE,
	IDOK, IDH_DISABLEHELP,
	IDCANCEL, IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_CLUSTER_GENERAL[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_CLUS_NAME_LABEL, IDH_PP_CLUS_NAME,
	IDC_PP_CLUS_NAME,IDH_PP_CLUS_NAME,
	IDC_PP_CLUS_DESC_LABEL, IDH_PP_CLUS_DESC,
	IDC_PP_CLUS_DESC,IDH_PP_CLUS_DESC,
	IDC_PP_CLUS_INFO_LINE, IDH_DISABLEHELP,
	IDC_PP_CLUS_VENDOR_ID,IDH_PP_CLUS_VENDOR_ID,
	IDC_PP_CLUS_VERSION,IDH_PP_CLUS_VERSION,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_CLUSTER_NET_PRIORITY[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_CLUS_PRIORITY_LIST_LABEL, IDH_PP_CLUS_PRIORITY_LIST,
	IDC_PP_CLUS_PRIORITY_LIST,IDH_PP_CLUS_PRIORITY_LIST,
	IDC_PP_CLUS_PRIORITY_UP,IDH_PP_CLUS_PRIORITY_UP,
	IDC_PP_CLUS_PRIORITY_DOWN,IDH_PP_CLUS_PRIORITY_DOWN,
	IDC_PP_CLUS_PRIORITY_PROPERTIES,IDH_PP_CLUS_PRIORITY_PROPERTIES,
	IDC_PP_CLUS_PRIORITY_NOTE, IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_CLUSTER_QUORUM[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_CLUS_QUORUM_RESOURCE_LABEL, IDH_PP_CLUS_QUORUM_RESOURCE,
	IDC_PP_CLUS_QUORUM_RESOURCE,IDH_PP_CLUS_QUORUM_RESOURCE,
	IDC_PP_CLUS_QUORUM_LOGGING_GROUP,IDH_PP_CLUS_QUORUM_LOGGING_GROUP,
	IDC_PP_CLUS_QUORUM_PARTITION_LABEL, IDH_PP_CLUS_QUORUM_PARTITION,
	IDC_PP_CLUS_QUORUM_PARTITION,IDH_PP_CLUS_QUORUM_PARTITION,
	IDC_PP_CLUS_QUORUM_ROOT_PATH_LABEL, IDH_PP_CLUS_QUORUM_ROOT_PATH,
	IDC_PP_CLUS_QUORUM_ROOT_PATH,IDH_PP_CLUS_QUORUM_ROOT_PATH,
	IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE_LABEL, IDH_PP_CLUS_QUORUM_MAX_LOG_SIZE,
	IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE,IDH_PP_CLUS_QUORUM_MAX_LOG_SIZE,
	IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE_LABEL2, IDH_PP_CLUS_QUORUM_MAX_LOG_SIZE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_GROUP_FAILBACK[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_GROUP_AUTOFB_PREVENT,IDH_PP_GROUP_AUTOFB_PREVENT,
	IDC_PP_GROUP_AUTOFB_ALLOW,IDH_PP_GROUP_AUTOFB_ALLOW,
	IDC_PP_GROUP_FB_IMMED,IDH_PP_GROUP_FB_IMMED,
	IDC_PP_GROUP_FB_WINDOW,IDH_PP_GROUP_FB_WINDOW,
	IDC_PP_GROUP_FBWIN_START,IDH_PP_GROUP_FBWIN_START,
	IDC_PP_GROUP_FB_WINDOW_LABEL1, IDH_DISABLEHELP,
	IDC_PP_GROUP_FBWIN_END,IDH_PP_GROUP_FBWIN_END,
	IDC_PP_GROUP_FB_WINDOW_LABEL2, IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_GROUP_FAILOVER[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_GROUP_FAILOVER_THRESH_LABEL, IDH_PP_GROUP_FAILOVER_THRESH,
	IDC_PP_GROUP_FAILOVER_THRESH,IDH_PP_GROUP_FAILOVER_THRESH,
	IDC_PP_GROUP_FAILOVER_PERIOD_LABEL, IDH_PP_GROUP_FAILOVER_PERIOD,
	IDC_PP_GROUP_FAILOVER_PERIOD,IDH_PP_GROUP_FAILOVER_PERIOD,
	IDC_PP_GROUP_FAILOVER_PERIOD_LABEL2, IDH_PP_GROUP_FAILOVER_PERIOD,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_GROUP_GENERAL[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_GROUP_NAME_LABEL, IDH_PP_GROUP_NAME,
	IDC_PP_GROUP_NAME,IDH_PP_GROUP_NAME,
	IDC_PP_GROUP_DESC_LABEL, IDH_PP_GROUP_DESC,
	IDC_PP_GROUP_DESC,IDH_PP_GROUP_DESC,
	IDC_PP_GROUP_PREF_OWNERS_LABEL, IDH_PP_GROUP_PREF_OWNERS,
	IDC_PP_GROUP_PREF_OWNERS,IDH_PP_GROUP_PREF_OWNERS,
	IDC_PP_GROUP_PREF_OWNERS_MODIFY,IDH_PP_GROUP_PREF_OWNERS_MODIFY,
	IDC_PP_GROUP_INFO_LINE, IDH_DISABLEHELP,
	IDC_PP_GROUP_CURRENT_STATE_LABEL, IDH_PP_GROUP_CURRENT_STATE,
	IDC_PP_GROUP_CURRENT_STATE,IDH_PP_GROUP_CURRENT_STATE,
	IDC_PP_GROUP_CURRENT_NODE_LABEL, IDH_PP_GROUP_CURRENT_NODE,
	IDC_PP_GROUP_CURRENT_NODE,IDH_PP_GROUP_CURRENT_NODE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_NET_GENERAL[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_NET_NAME_LABEL, IDH_PP_NET_NAME,
	IDC_PP_NET_NAME,IDH_PP_NET_NAME,
	IDC_PP_NET_DESC_LABEL, IDH_PP_NET_DESC,
	IDC_PP_NET_DESC,IDH_PP_NET_DESC, 
	IDC_PP_NET_ROLE_ENABLE_NETWORK,IDH_PP_NET_ROLE_ENABLE_NETWORK,
	IDC_PP_NET_ROLE_ALL_COMM,IDH_PP_NET_ROLE_ALL_COMM,
	IDC_PP_NET_ROLE_INTERNAL_ONLY,IDH_PP_NET_ROLE_INTERNAL_ONLY,
	IDC_PP_NET_ROLE_CLIENT_ONLY,IDH_PP_NET_ROLE_CLIENT_ONLY,
	IDC_PP_NET_CURRENT_STATE_LABEL, IDH_PP_NET_CURRENT_STATE,
	IDC_PP_NET_CURRENT_STATE,IDH_PP_NET_CURRENT_STATE,
	IDC_PP_NET_ADDRESS_MASK_LABEL, IDH_PP_NET_ADDRESS_MASK,
	IDC_PP_NET_ADDRESS_MASK,IDH_PP_NET_ADDRESS_MASK,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_NETIFACE_GENERAL[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_NETIFACE_NODE_LABEL, IDH_PP_NETIFACE_NODE,
	IDC_PP_NETIFACE_NODE,IDH_PP_NETIFACE_NODE,
	IDC_PP_NETIFACE_NETWORK_LABEL, IDH_PP_NETIFACE_NETWORK,
	IDC_PP_NETIFACE_NETWORK,IDH_PP_NETIFACE_NETWORK,
	IDC_PP_NETIFACE_DESC_LABEL, IDH_PP_NETIFACE_DESC,
	IDC_PP_NETIFACE_DESC,IDH_PP_NETIFACE_DESC,
	IDC_PP_NETIFACE_NAME_LABEL, IDH_PP_NETIFACE_NAME,
	IDC_PP_NETIFACE_NAME,IDH_PP_NETIFACE_NAME,
	IDC_PP_NETIFACE_CURRENT_STATE_LABEL, IDH_PP_NETIFACE_CURRENT_STATE,
	IDC_PP_NETIFACE_CURRENT_STATE,IDH_PP_NETIFACE_CURRENT_STATE,
	IDC_PP_NETIFACE_ADAPTER_LABEL, IDH_PP_NETIFACE_ADAPTER,
	IDC_PP_NETIFACE_ADAPTER,IDH_PP_NETIFACE_ADAPTER,
	IDC_PP_NETIFACE_ADDRESS_LABEL, IDH_PP_NETIFACE_ADDRESS,
	IDC_PP_NETIFACE_ADDRESS,IDH_PP_NETIFACE_ADDRESS,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_NODE_GENERAL[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_NODE_NAME_LABEL, IDH_PP_NODE_NAME,
	IDC_PP_NODE_NAME,IDH_PP_NODE_NAME,
	IDC_PP_NODE_DESC_LABEL, IDH_PP_NODE_DESC,
	IDC_PP_NODE_DESC,IDH_PP_NODE_DESC,
	IDC_PP_NODE_CURRENT_STATE_LABEL, IDH_PP_NODE_CURRENT_STATE,
	IDC_PP_NODE_CURRENT_STATE,IDH_PP_NODE_CURRENT_STATE,
	IDC_PP_NODE_CSD_VERSION,IDH_PP_NODE_CSD_VERSION,
	IDC_PP_NODE_VERSION,IDH_PP_NODE_VERSION,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_RES_ADVANCED[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_RES_DONT_RESTART,IDH_PP_RES_DONT_RESTART,
	IDC_PP_RES_RESTART_GROUP, IDH_PP_RES_RESTART,
	IDC_PP_RES_RESTART,IDH_PP_RES_RESTART,
	IDC_PP_RES_AFFECT_THE_GROUP,IDH_PP_RES_AFFECT_THE_GROUP,
	IDC_PP_RES_RESTART_THRESH_LABEL, IDH_PP_RES_RESTART_THRESHOLD,
	IDC_PP_RES_RESTART_THRESHOLD,IDH_PP_RES_RESTART_THRESHOLD,
	IDC_PP_RES_RESTART_PERIOD_LABEL, IDH_PP_RES_RESTART_PERIOD,
	IDC_PP_RES_RESTART_PERIOD,IDH_PP_RES_RESTART_PERIOD,
	IDC_PP_RES_RESTART_PERIOD_LABEL2, IDH_PP_RES_RESTART_PERIOD,
	IDC_PP_RES_LOOKS_ALIVE_GROUP,IDH_PP_RES_LOOKS_ALIVE_GROUP,
	IDC_PP_RES_DEFAULT_LOOKS_ALIVE,IDH_PP_RES_DEFAULT_LOOKS_ALIVE,
	IDC_PP_RES_SPECIFY_LOOKS_ALIVE,IDH_PP_RES_SPECIFY_LOOKS_ALIVE,
	IDC_PP_RES_LOOKS_ALIVE,IDH_PP_RES_LOOKS_ALIVE,
	IDC_PP_RES_SPECIFY_LOOKS_ALIVE_LABEL, IDH_PP_RES_LOOKS_ALIVE,
	IDC_PP_RES_IS_ALIVE_GROUP,IDH_PP_RES_IS_ALIVE_GROUP,
	IDC_PP_RES_DEFAULT_IS_ALIVE,IDH_PP_RES_DEFAULT_IS_ALIVE,	
	IDC_PP_RES_SPECIFY_IS_ALIVE,IDH_PP_RES_SPECIFY_IS_ALIVE,
	IDC_PP_RES_IS_ALIVE,IDH_PP_RES_IS_ALIVE,
	IDC_PP_RES_IS_ALIVE_LABEL, IDH_PP_RES_IS_ALIVE,
	IDC_PP_RES_PENDING_TIMEOUT_LABEL, IDH_PP_RES_PENDING_TIMEOUT,
	IDC_PP_RES_PENDING_TIMEOUT,IDH_PP_RES_PENDING_TIMEOUT,
	IDC_PP_RES_PENDING_TIMEOUT_LABEL2, IDH_PP_RES_PENDING_TIMEOUT,
	0, 0
};


const DWORD g_aHelpIDs_IDD_PP_RES_DEPENDS[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_RES_NOTE, IDH_DISABLEHELP,
	IDC_PP_RES_DEPENDS_LIST_LABEL, IDH_PP_RES_DEPENDS_LIST,
	IDC_PP_RES_DEPENDS_LIST,IDH_PP_RES_DEPENDS_LIST,
	IDC_PP_RES_MODIFY,IDH_PP_RES_MODIFY,
	IDC_PP_RES_PROPERTIES,IDH_PP_RES_PROPERTIES,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_RES_GENERAL[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_RES_NAME_LABEL, IDH_PP_RES_NAME,
	IDC_PP_RES_NAME,IDH_PP_RES_NAME,
	IDC_PP_RES_DESC_LABEL, IDH_PP_RES_DESC,
	IDC_PP_RES_DESC,IDH_PP_RES_DESC,
	IDC_PP_RES_POSSIBLE_OWNERS_LABEL, IDH_PP_RES_POSSIBLE_OWNERS,
	IDC_PP_RES_POSSIBLE_OWNERS,IDH_PP_RES_POSSIBLE_OWNERS,
	IDC_PP_RES_POSSIBLE_OWNERS_MODIFY,IDH_PP_RES_POSSIBLE_OWNERS_MODIFY,
	IDC_PP_RES_SEPARATE_MONITOR,IDH_PP_RES_SEPARATE_MONITOR,
	IDC_PP_RES_INFO_LINE, IDH_DISABLEHELP,
	IDC_PP_RES_RESOURCE_TYPE_LABEL, IDH_PP_RES_RESOURCE_TYPE,
	IDC_PP_RES_RESOURCE_TYPE,IDH_PP_RES_RESOURCE_TYPE,
	IDC_PP_RES_GROUP_LABEL, IDH_PP_RES_GROUP,
	IDC_PP_RES_GROUP,IDH_PP_RES_GROUP,
	IDC_PP_RES_CURRENT_STATE_LABEL, IDH_PP_RES_CURRENT_STATE,
	IDC_PP_RES_CURRENT_STATE,IDH_PP_RES_CURRENT_STATE,
	IDC_PP_RES_CURRENT_NODE_LABEL, IDH_PP_RES_CURRENT_NODE,
	IDC_PP_RES_CURRENT_NODE,IDH_PP_RES_CURRENT_NODE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PP_RESTYPE_GENERAL[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_RESTYPE_DISPLAY_NAME_LABEL, IDH_PP_RESTYPE_DISPLAY_NAME,
	IDC_PP_RESTYPE_DISPLAY_NAME,IDH_PP_RESTYPE_DISPLAY_NAME,
	IDC_PP_RESTYPE_DESC_LABEL, IDH_PP_RESTYPE_DESC, 
	IDC_PP_RESTYPE_DESC,IDH_PP_RESTYPE_DESC,
	IDC_PP_RESTYPE_POSSIBLE_OWNERS_LABEL, IDH_PP_RESTYPE_POSSIBLE_OWNERS,
	IDC_PP_RESTYPE_POSSIBLE_OWNERS,IDH_PP_RESTYPE_POSSIBLE_OWNERS,
	IDC_PP_RESTYPE_POLLINT_GROUP,IDH_PP_RESTYPE_POLLINT_GROUP,
	IDC_PP_RESTYPE_LOOKS_ALIVE_LABEL, IDH_PP_RESTYPE_LOOKS_ALIVE,
	IDC_PP_RESTYPE_LOOKS_ALIVE,IDH_PP_RESTYPE_LOOKS_ALIVE,
	IDC_PP_RESTYPE_LOOKS_ALIVE_LABEL2, IDH_PP_RESTYPE_LOOKS_ALIVE,
	IDC_PP_RESTYPE_IS_ALIVE_LABEL, IDH_PP_RESTYPE_IS_ALIVE, 
	IDC_PP_RESTYPE_IS_ALIVE,IDH_PP_RESTYPE_IS_ALIVE,
	IDC_PP_RESTYPE_IS_ALIVE_LABEL2, IDH_PP_RESTYPE_IS_ALIVE,
	IDC_PP_RESTYPE_NAME_LABEL, IDH_PP_RESTYPE_NAME,
	IDC_PP_RESTYPE_NAME,IDH_PP_RESTYPE_NAME,
	IDC_PP_RESTYPE_RESDLL_LABEL, IDH_PP_RESTYPE_RESDLL,
	IDC_PP_RESTYPE_RESDLL,IDH_PP_RESTYPE_RESDLL,
	IDC_PP_RESTYPE_QUORUM_CAPABLE_LABEL, IDH_PP_RESTYPE_QUORUM_CAPABLE,
	IDC_PP_RESTYPE_QUORUM_CAPABLE,IDH_PP_RESTYPE_QUORUM_CAPABLE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_DEPENDENCIES[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_LCP_NOTE, IDH_DISABLEHELP,
	IDC_LCP_LEFT_LABEL, IDH_LCP_LEFT_LIST,
	IDC_LCP_LEFT_LIST,IDH_LCP_LEFT_LIST,
	IDC_LCP_ADD,IDH_LCP_ADD,
	IDC_LCP_REMOVE,IDH_LCP_REMOVE,
	IDC_LCP_RIGHT_LABEL, IDH_LCP_RIGHT_LIST,
	IDC_LCP_RIGHT_LIST,IDH_LCP_RIGHT_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_GROUP_NAME[]=
{
	IDC_WIZ_GRAPHIC, IDH_DISABLEHELP,
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_WIZ_GROUP_WIZ_DESC, IDH_DISABLEHELP,
	IDC_WIZ_GROUP_NAME_LABEL, IDH_WIZ_GROUP_NAME,
	IDC_WIZ_GROUP_NAME,IDH_WIZ_GROUP_NAME,
	IDC_WIZ_GROUP_DESC_LABEL, IDH_WIZ_GROUP_DESC,
	IDC_WIZ_GROUP_DESC,IDH_WIZ_GROUP_DESC,
	IDC_WIZ_GROUP_CLICK_NEXT, IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_POSSIBLE_OWNERS[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_LCP_NOTE, IDH_DISABLEHELP,
	IDC_LCP_LEFT_LABEL, IDH_POSSIBLE_LCP_LEFT_LIST,
	IDC_LCP_LEFT_LIST,IDH_POSSIBLE_LCP_LEFT_LIST,
	IDC_LCP_ADD,IDH_POSSIBLE_LCP_ADD,
	IDC_LCP_REMOVE,IDH_POSIBLE_LCP_REMOVE,
	IDC_LCP_RIGHT_LABEL, IDH_POSSIBLE_LCP_RIGHT_LIST,
	IDC_LCP_RIGHT_LIST,IDH_POSSIBLE_LCP_RIGHT_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_PREFERRED_OWNERS[]=
{
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_LCP_NOTE, IDH_DISABLEHELP,
	IDC_LCP_LEFT_LABEL, IDH_PREF_LCP_LEFT_LIST,
	IDC_LCP_LEFT_LIST,IDH_PREF_LCP_LEFT_LIST,
	IDC_LCP_ADD,IDH_POSSIBLE_LCP_ADD,
	IDC_LCP_REMOVE, IDH_POSIBLE_LCP_REMOVE,
	IDC_LCP_RIGHT_LABEL, IDH_WIZ_PRE_LCP_RIGHT_LIST,
	IDC_LCP_RIGHT_LIST,IDH_WIZ_PRE_LCP_RIGHT_LIST,
	IDC_LCP_MOVE_UP,IDH_LCP_MOVE_UP,
	IDC_LCP_MOVE_DOWN,IDH_LCP_MOVE_DOWN,
	0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_RESOURCE_NAME[]=
{
	IDC_WIZ_GRAPHIC, IDH_DISABLEHELP,
	IDC_PP_ICON, IDH_DISABLEHELP,
	IDC_PP_TITLE, IDH_DISABLEHELP,
	IDC_WIZ_RES_NAME_LABEL, IDH_WIZ_RES_NAME,
	IDC_WIZ_RES_NAME,IDH_WIZ_RES_NAME,
	IDC_WIZ_RES_DESC_LABEL, IDH_WIZ_RES_DESC,
	IDC_WIZ_RES_DESC,IDH_WIZ_RES_DESC,
	IDC_WIZ_RES_RESTYPE_LABEL, IDH_WIZ_RES_RESTYPE,
	IDC_WIZ_RES_RESTYPE,IDH_WIZ_RES_RESTYPE,
	IDC_WIZ_RES_GROUP_LABEL, IDH_WIZ_RES_GROUP,
	IDC_WIZ_RES_GROUP,IDH_WIZ_RES_GROUP,
	IDC_WIZ_RES_SEPARATE_MONITOR,IDH_WIZ_RES_SEPARATE_MONITOR,
	IDC_WIZ_RES_CLICK_NEXT, IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_YESTOALL[]=
{
	IDC_YTA_MESSAGE, IDH_YTA_MESSAGE,
	IDC_YTA_QUESTION, IDH_YTA_MESSAGE,
	IDYES,IDH_YES_YTA,
	IDC_YTA_YESTOALL,IDH_YTA_YESTOALL,
	IDNO,IDH_NO_YTA,
	0, 0
};


#else

extern const DWORD g_aHelpIDs_IDD_ABOUTBOX[];
extern const DWORD g_aHelpIDs_IDD_OPEN_CLUSTER[];
extern const DWORD g_aHelpIDs_IDD_DELETE_RESOURCES[];
extern const DWORD g_aHelpIDs_IDD_MOVE_RESOURCES[];
extern const DWORD g_aHelpIDs_IDD_MODIFY_PREFERRED_OWNERS[];
extern const DWORD g_aHelpIDs_IDD_MODIFY_POSSIBLE_OWNERS[];
extern const DWORD g_aHelpIDs_IDD_MODIFY_DEPENDENCIES[];
extern const DWORD g_aHelpIDs_IDD_YESTOALL[];
extern const DWORD g_aHelpIDs_IDD_BROWSE_CLUSTERS[];
extern const DWORD g_aHelpIDs_IDD_PP_CLUSTER_GENERAL[];
extern const DWORD g_aHelpIDs_IDD_PP_CLUSTER_QUORUM[];
extern const DWORD g_aHelpIDs_IDD_PP_CLUSTER_NET_PRIORITY[];
extern const DWORD g_aHelpIDs_IDD_PP_NODE_GENERAL[];
extern const DWORD g_aHelpIDs_IDD_PP_GROUP_GENERAL[];
extern const DWORD g_aHelpIDs_IDD_PP_GROUP_FAILOVER[];
extern const DWORD g_aHelpIDs_IDD_PP_GROUP_FAILBACK[];
extern const DWORD g_aHelpIDs_IDD_PP_RES_GENERAL[];
extern const DWORD g_aHelpIDs_IDD_PP_RES_DEPENDS[];
extern const DWORD g_aHelpIDs_IDD_PP_RES_ADVANCED[];
extern const DWORD g_aHelpIDs_IDD_PP_RESTYPE_GENERAL[];
extern const DWORD g_aHelpIDs_IDD_PP_NETIFACE_GENERAL[];
extern const DWORD g_aHelpIDs_IDD_WIZ_GROUP_NAME[];
extern const DWORD g_aHelpIDs_IDD_WIZ_PREFERRED_OWNERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_RESOURCE_NAME[];
extern const DWORD g_aHelpIDs_IDD_WIZ_POSSIBLE_OWNERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_DEPENDENCIES[];
extern const DWORD g_aHelpIDs_IDD_PP_NET_GENERAL[];

#endif // INITHELPARRAYS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\helpids.h ===
#define	IDH_ABOUT_PRODUCT_TITLE	700001000
#define	IDH_BC_CLUSTER	700001025
#define	IDH_BC_LIST	700001026
#define	IDH_DR_RESOURCES_LIST	700001050
#define	IDH_LCP_ADD	700001076
#define	IDH_LCP_LEFT_LIST	700001075
#define	IDH_LCP_MOVE_DOWN	700001130
#define	IDH_LCP_MOVE_UP	700001129
#define	IDH_LCP_PROPERTIES	700001079
#define	IDH_LCP_REMOVE	700001077
#define	IDH_LCP_RIGHT_LIST	700001078
#define	IDH_MR_RESOURCES_LIST	700001150
#define	IDH_NO_DEL_RES	700001052
#define	IDH_NO_MOVE_RES	700001152
#define	IDH_NO_YTA	700001653
#define	IDH_OCD_BROWSE	700001176
#define	IDH_OCD_NAME	700001175
#define	IDH_POSIBLE_LCP_REMOVE	700001102
#define	IDH_POSSIBLE_LCP_ADD	700001101
#define	IDH_POSSIBLE_LCP_LEFT_LIST	700001100
#define	IDH_POSSIBLE_LCP_PROPERTIES	700001104
#define	IDH_POSSIBLE_LCP_RIGHT_LIST	700001103
#define	IDH_PP_CLUS_DESC	700001201
#define	IDH_PP_CLUS_NAME	700001200
#define	IDH_PP_CLUS_PRIORITY_DOWN	700001227
#define	IDH_PP_CLUS_PRIORITY_LIST	700001225
#define	IDH_PP_CLUS_PRIORITY_PROPERTIES	700001228
#define	IDH_PP_CLUS_PRIORITY_UP	700001226
#define	IDH_PP_CLUS_QUORUM_LOGGING_GROUP	700001251
#define	IDH_PP_CLUS_QUORUM_MAX_LOG_SIZE	700001254
#define	IDH_PP_CLUS_QUORUM_PARTITION	700001252
#define	IDH_PP_CLUS_QUORUM_RESOURCE	700001250
#define	IDH_PP_CLUS_QUORUM_ROOT_PATH	700001253
#define	IDH_PP_CLUS_VENDOR_ID	700001202
#define	IDH_PP_CLUS_VERSION	700001203
#define	IDH_PP_GROUP_AUTOFB_ALLOW	700001276
#define	IDH_PP_GROUP_AUTOFB_PREVENT	700001275
#define	IDH_PP_GROUP_CURRENT_NODE	700001330
#define	IDH_PP_GROUP_CURRENT_STATE	700001329
#define	IDH_PP_GROUP_DESC	700001326
#define	IDH_PP_GROUP_FAILOVER_PERIOD	700001301
#define	IDH_PP_GROUP_FAILOVER_THRESH	700001300
#define	IDH_PP_GROUP_FB_IMMED	700001277
#define	IDH_PP_GROUP_FB_WINDOW	700001278
#define	IDH_PP_GROUP_FBWIN_END	700001280
#define	IDH_PP_GROUP_FBWIN_START	700001279
#define	IDH_PP_GROUP_NAME	700001325
#define	IDH_PP_GROUP_PREF_OWNERS	700001327
#define	IDH_PP_GROUP_PREF_OWNERS_MODIFY	700001328
#define	IDH_PP_NET_ADDRESS_MASK	700001357
#define	IDH_PP_NET_CURRENT_STATE	700001356
#define	IDH_PP_NET_DESC	700001351
#define	IDH_PP_NET_NAME	700001350
#define	IDH_PP_NET_ROLE_ALL_COMM	700001353
#define	IDH_PP_NET_ROLE_CLIENT_ONLY	700001355
#define	IDH_PP_NET_ROLE_ENABLE_NETWORK	700001352
#define	IDH_PP_NET_ROLE_INTERNAL_ONLY	700001354
#define	IDH_PP_NETIFACE_ADAPTER	700001380
#define	IDH_PP_NETIFACE_ADDRESS	700001381
#define	IDH_PP_NETIFACE_CURRENT_STATE	700001379
#define	IDH_PP_NETIFACE_DESC	700001377
#define	IDH_PP_NETIFACE_NAME	700001378
#define	IDH_PP_NETIFACE_NETWORK	700001376
#define	IDH_PP_NETIFACE_NODE	700001375
#define	IDH_PP_NODE_CSD_VERSION	700001404
#define	IDH_PP_NODE_CURRENT_STATE	700001402
#define	IDH_PP_NODE_DESC	700001401
#define	IDH_PP_NODE_NAME	700001400
#define	IDH_PP_NODE_VERSION	700001403
#define	IDH_PP_RES_AFFECT_THE_GROUP	700001437
#define	IDH_PP_RES_CURRENT_NODE	700001483
#define	IDH_PP_RES_CURRENT_STATE	700001482
#define	IDH_PP_RES_DEFAULT_IS_ALIVE	700001431
#define	IDH_PP_RES_DEFAULT_LOOKS_ALIVE	700001427
#define	IDH_PP_RES_DEPENDS_LIST	700001450
#define	IDH_PP_RES_DESC	700001476
#define	IDH_PP_RES_DONT_RESTART	700001435
#define	IDH_PP_RES_GROUP	700001481
#define	IDH_PP_RES_IS_ALIVE	700001433
#define	IDH_PP_RES_IS_ALIVE_GROUP	700001430
#define	IDH_PP_RES_LOOKS_ALIVE	700001429
#define	IDH_PP_RES_LOOKS_ALIVE_GROUP	700001426
#define	IDH_PP_RES_MODIFY	700001451
#define	IDH_PP_RES_NAME	700001475
#define	IDH_PP_RES_PENDING_TIMEOUT	700001434
#define	IDH_PP_RES_POSSIBLE_OWNERS	700001477
#define	IDH_PP_RES_POSSIBLE_OWNERS_MODIFY	700001478
#define	IDH_PP_RES_PROPERTIES	700001452
#define	IDH_PP_RES_RESOURCE_TYPE	700001480
#define	IDH_PP_RES_RESTART	700001436
#define	IDH_PP_RES_RESTART_PERIOD	700001425
#define	IDH_PP_RES_RESTART_THRESHOLD	700001438
#define	IDH_PP_RES_SEPARATE_MONITOR	700001479
#define	IDH_PP_RES_SPECIFY_IS_ALIVE	700001432
#define	IDH_PP_RES_SPECIFY_LOOKS_ALIVE	700001428
#define	IDH_PP_RESTYPE_DESC	700001501
#define	IDH_PP_RESTYPE_DISPLAY_NAME	700001500
#define	IDH_PP_RESTYPE_IS_ALIVE	700001505
#define	IDH_PP_RESTYPE_LOOKS_ALIVE	700001504
#define	IDH_PP_RESTYPE_NAME	700001506
#define	IDH_PP_RESTYPE_POLLINT_GROUP	700001503
#define	IDH_PP_RESTYPE_POSSIBLE_OWNERS	700001502
#define	IDH_PP_RESTYPE_QUORUM_CAPABLE	700001508
#define	IDH_PP_RESTYPE_RESDLL	700001507
#define	IDH_PREF_LCP_LEFT_LIST	700001125
#define	IDH_PREF_LCP_RIGHT_LIST	700001128
#define	IDH_WIZ_GROUP_DESC	700001551
#define	IDH_WIZ_GROUP_NAME	700001550
#define	IDH_WIZ_PRE_LCP_RIGHT_LIST	700001605
#define	IDH_WIZ_RES_DESC	700001626
#define	IDH_WIZ_RES_GROUP	700001628
#define	IDH_WIZ_RES_NAME	700001625
#define	IDH_WIZ_RES_RESTYPE	700001627
#define	IDH_WIZ_RES_SEPARATE_MONITOR	700001629
#define	IDH_YES_DEL_RES	700001051
#define	IDH_YES_MOVE_RES	700001151
#define	IDH_YES_YTA	700001651
#define	IDH_YTA_MESSAGE	700001650
#define	IDH_YTA_YESTOALL	700001652
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\grpwiz.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      GrpWiz.cpp
//
//  Abstract:
//      Implementation of the CCreateGroupWizard class and all pages
//      specific to a group wizard.
//
//  Author:
//      David Potter (davidp)   July 22, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "GrpWiz.h"
#include "ClusDoc.h"
#include "DDxDDv.h"
#include "HelpData.h"   // for g_rghelpmapGroupWizName

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCreateGroupWizard
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CCreateGroupWizard, CBaseWizard)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CCreateGroupWizard, CBaseWizard)
    //{{AFX_MSG_MAP(CCreateGroupWizard)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateGroupWizard::CCreateGroupWizard
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pdoc        [IN OUT] Document in which group is to be created.
//      pParentWnd  [IN OUT] Parent window for this property sheet.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCreateGroupWizard::CCreateGroupWizard(
    IN OUT CClusterDoc *    pdoc,
    IN OUT CWnd *           pParentWnd
    )
    : CBaseWizard(IDS_NEW_GROUP_TITLE, pParentWnd)

{
    ASSERT_VALID(pdoc);
    m_pdoc = pdoc;

    m_pciGroup = NULL;
    m_bCreated = FALSE;

    m_rgpages[0].m_pwpage = &m_pageName;
    m_rgpages[0].m_dwWizButtons = PSWIZB_NEXT;
    m_rgpages[1].m_pwpage = &m_pageOwners;
    m_rgpages[1].m_dwWizButtons = PSWIZB_BACK | PSWIZB_FINISH;

}  //*** CCreateGroupWizard::CCreateGroupWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateGroupWizard::~CCreateGroupWizard
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCreateGroupWizard::~CCreateGroupWizard(void)
{
    if (m_pciGroup != NULL)
        m_pciGroup->Release();

}  //*** CCreateGroupWizard::~CCreateGroupWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateGroupWizard::BInit
//
//  Routine Description:
//      Initialize the wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Wizard initialized successfully.
//      FALSE   Wizard not initialized successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCreateGroupWizard::BInit(void)
{
    // Call the base class method.
    CClusterAdminApp *  papp = GetClusterAdminApp();
    if (!CBaseWizard::BInit(papp->Iimg(IMGLI_GROUP)))
        return FALSE;

    return TRUE;

}  //*** CCreateGroupWizard::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateGroupWizard::OnCancel
//
//  Routine Description:
//      Called after the wizard has been dismissed when the Cancel button
//      has been pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCreateGroupWizard::OnCancel(void)
{
    if (BCreated())
    {
        ASSERT_VALID(PciGroup());
        try
        {
            PciGroup()->DeleteGroup();
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
        catch (...)
        {
        }  // catch:  anything
        m_bCreated = FALSE;
    }  // if:  we created the object

}  //*** CCreateGroupWizard::OnCancel()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateGroupWizard::Ppages
//
//  Routine Description:
//      Returns the array of pages to add to the property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Page array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWizPage * CCreateGroupWizard::Ppages(void)
{
    return m_rgpages;

}  //*** CCreateGroupWizard::Ppages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateGroupWizard::Cpages
//
//  Routine Description:
//      Returns the count of pages in the array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Count of pages in the array.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CCreateGroupWizard::Cpages(void)
{
    return sizeof(m_rgpages) / sizeof(CWizPage);

}  //*** CCreateGroupWizard::Cpages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateGroupWizard::BSetName
//
//  Routine Description:
//      Set the name of the group, creating it if necessary.
//
//  Arguments:
//      rstrName        [IN] Name of the group.
//
//  Return Value:
//      TRUE            Name set successfully.
//      FALSE           Error setting the name.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCreateGroupWizard::BSetName( IN const CString & rstrName )
{
    BOOL        bSuccess = TRUE;
    CWaitCursor wc;

    try
    {
        if ( ! BCreated() )
        {
            // Allocate an item and create the group.
            if ( PciGroup() == NULL )
            {
                m_pciGroup = new CGroup( FALSE );
                if ( m_pciGroup == NULL )
                {
                    AfxThrowMemoryException();
                } // if: error allocating memory
                m_pciGroup->AddRef();
            }  // if:  no group yet
            PciGroup()->Create( Pdoc(), rstrName );
            PciGroup()->ReadItem();
            m_strName = rstrName;
            m_bCreated = TRUE;
        }  // if:  object not created yet
        else
        {
            ASSERT_VALID( PciGroup() );
            PciGroup()->SetName( rstrName );
            m_strName = rstrName;
        }  // else:  object already exists
    }  // try
    catch ( CException * pe )
    {
        pe->ReportError();
        pe->Delete();
        try
        {
            PciGroup()->DeleteGroup();
        }  // try
        catch (...)
        {
        }  // catch:  Anything
        bSuccess = FALSE;
    }  // catch:  CException

    return bSuccess;

}  //*** CCreateGroupWizard::BSetName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateGroupWizard::BSetDescription
//
//  Routine Description:
//      Set the description of the group.
//
//  Arguments:
//      rstrDesc        [IN] Description of the group.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CCreateGroupWizard::BSetDescription(IN const CString & rstrDesc)
{
    BOOL        bSuccess = TRUE;
    CWaitCursor wc;

    try
    {
        ASSERT(BCreated());
        ASSERT_VALID(PciGroup());
        PciGroup()->SetCommonProperties(
                        rstrDesc,
                        PciGroup()->NFailoverThreshold(),
                        PciGroup()->NFailoverPeriod(),
                        PciGroup()->CgaftAutoFailbackType(),
                        PciGroup()->NFailbackWindowStart(),
                        PciGroup()->NFailbackWindowEnd()
                        );
        m_strDescription = rstrDesc;
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        bSuccess = FALSE;
    }  // catch:  CException

    return bSuccess;

}  //*** CCreateGroupWizard::BSetDescription()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNewGroupNamePage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNewGroupNamePage, CBaseWizardPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNewGroupNamePage, CBaseWizardPage)
    //{{AFX_MSG_MAP(CNewGroupNamePage)
    ON_EN_CHANGE(IDC_WIZ_GROUP_NAME, OnChangeGroupName)
    ON_EN_KILLFOCUS(IDC_WIZ_GROUP_NAME, OnKillFocusGroupName)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupNamePage::CNewGroupNamePage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNewGroupNamePage::CNewGroupNamePage(void)
    : CBaseWizardPage(IDD, g_aHelpIDs_IDD_WIZ_GROUP_NAME)
{
    //{{AFX_DATA_INIT(CNewGroupNamePage)
    m_strName = _T("");
    m_strDesc = _T("");
    //}}AFX_DATA_INIT

}  //*** CNewGroupNamePage::CNewGroupNamePage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupNamePage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewGroupNamePage::DoDataExchange(CDataExchange * pDX)
{
    CBaseWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewGroupNamePage)
    DDX_Control(pDX, IDC_WIZ_GROUP_DESC, m_editDesc);
    DDX_Control(pDX, IDC_WIZ_GROUP_NAME, m_editName);
    DDX_Text(pDX, IDC_WIZ_GROUP_NAME, m_strName);
    DDX_Text(pDX, IDC_WIZ_GROUP_DESC, m_strDesc);
    //}}AFX_DATA_MAP

    DDV_RequiredText(pDX, IDC_WIZ_GROUP_NAME, IDC_WIZ_GROUP_NAME_LABEL, m_strName);

}  //*** CNewGroupNamePage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupNamePage::BApplyChanges
//
//  Routine Description:
//      Apply changes from this page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Changes applied successfully.
//      FALSE       Error applying changes.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewGroupNamePage::BApplyChanges(void)
{
    CWaitCursor wc;

    ASSERT(Pwiz() != NULL);

    // Get the data from the dialog.
    if (!UpdateData(TRUE /*bSaveAndValidate*/))
        return FALSE;

    // Save the data in the sheet.
    if (!PwizGroup()->BSetName(m_strName)
            || !PwizGroup()->BSetDescription(m_strDesc))
        return FALSE;

    return TRUE;

}  //*** CNewGroupNamePage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupNamePage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewGroupNamePage::OnSetActive(void)
{
    BOOL    bSuccess;

    bSuccess = CBaseWizardPage::OnSetActive();
    if (bSuccess)
    {
        if (m_strName.IsEmpty())
            EnableNext(FALSE);
    }  // if:  successful thus far

    return bSuccess;

}  //*** CNewGroupNamePage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupNamePage::OnChangeGroupName
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Group Name edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewGroupNamePage::OnChangeGroupName(void)
{
    if (m_editName.GetWindowTextLength() == 0)
        EnableNext(FALSE);
    else
        EnableNext(TRUE);

}  //*** CNewGroupNamePage::OnChangeGroupName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupNamePage::OnKillFocusGroupName
//
//  Routine Description:
//      Handler for the WM_KILLFOCUS message on the Group Name edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewGroupNamePage::OnKillFocusGroupName(void)
{
    CString     strName;

    m_editName.GetWindowText(strName);
    SetObjectTitle(strName);

}  //*** CNewGroupNamePage::OnKillFocusGroupName()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNewGroupOwnersPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNewGroupOwnersPage, CListCtrlPairWizPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CNewGroupOwnersPage, CListCtrlPairWizPage)
    //{{AFX_MSG_MAP(CNewGroupOwnersPage)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupOwnersPage::CNewGroupOwnersPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNewGroupOwnersPage::CNewGroupOwnersPage(void)
    : CListCtrlPairWizPage(
            IDD,
            g_aHelpIDs_IDD_WIZ_PREFERRED_OWNERS,
            LCPS_SHOW_IMAGES | LCPS_ALLOW_EMPTY | LCPS_CAN_BE_ORDERED | LCPS_ORDERED,
            GetColumn,
            BDisplayProperties
            )
{
    //{{AFX_DATA_INIT(CNewGroupOwnersPage)
    //}}AFX_DATA_INIT

}  //*** CNewGroupOwnersPage::CNewGroupOwnersPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupOwnersPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewGroupOwnersPage::DoDataExchange(CDataExchange * pDX)
{
    // Initialize the lists before the list pair control is updated.
    if (!pDX->m_bSaveAndValidate)
    {
        if (!BInitLists())
            pDX->Fail();
    }  // if:  setting data to the dialog

    CListCtrlPairWizPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewGroupOwnersPage)
    DDX_Control(pDX, IDC_LCP_NOTE, m_staticNote);
    //}}AFX_DATA_MAP

}  //*** CNewGroupOwnersPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupOwnersPage::BInitLists
//
//  Routine Description:
//      Initialize the lists.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewGroupOwnersPage::BInitLists(void)
{
    BOOL        bSuccess = TRUE;

    ASSERT_VALID(PciGroup());

    try
    {
        SetLists(&PciGroup()->LpcinodePreferredOwners(), &PciGroup()->Pdoc()->LpciNodes());
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        bSuccess = FALSE;
    }  // catch:  CException

    return bSuccess;

}  //*** CNewGroupOwnersPage::BInitLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupOwnersPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewGroupOwnersPage::OnInitDialog(void)
{
    // Add columns.
    try
    {
        NAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    // Call the base class method.
    CListCtrlPairWizPage::OnInitDialog();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CNewGroupOwnersPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupOwnersPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewGroupOwnersPage::BApplyChanges(void)
{
    BOOL        bSuccess;
    CWaitCursor wc;

    // Set the data from the page in the cluster item.
    try
    {
        PciGroup()->SetPreferredOwners((CNodeList &) Plcp()->LpobjRight());
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    bSuccess = CListCtrlPairWizPage::BApplyChanges();
    if (bSuccess)
    {
        POSITION        pos;
        CClusterNode *  pciNode;;

        // If the group is not owned by the first node in the preferred
        // owners list, move the group to the first node.
        pos = Plcp()->LpobjRight().GetHeadPosition();
        if (pos != NULL)
        {
            pciNode = (CClusterNode *) Plcp()->LpobjRight().GetNext(pos);
            if (pciNode->StrName() != PciGroup()->StrOwner())
            {
                try
                {
                    PciGroup()->Move(pciNode);
                }  // try
                catch (CException * pe)
                {
                    pe->ReportError();
                    pe->Delete();
                }  // catch:  CException
            }  // if:  not on first preferred owner node
        }  // if:  there is a preferred owner
    }  // if:  changes applied successfully

    return bSuccess;

}  //*** CNewGroupOwnersPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupOwnersPage::GetColumn [static]
//
//  Routine Description:
//      Returns a column for an item.
//
//  Arguments:
//      pobj        [IN OUT] Object for which the column is to be displayed.
//      iItem       [IN] Index of the item in the list.
//      icol        [IN] Column number whose text is to be retrieved.
//      pdlg        [IN OUT] Dialog to which object belongs.
//      rstr        [OUT] String in which to return column text.
//      piimg       [OUT] Image index for the object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CALLBACK CNewGroupOwnersPage::GetColumn(
    IN OUT CObject *    pobj,
    IN int              iItem,
    IN int              icol,
    IN OUT CDialog *    pdlg,
    OUT CString &       rstr,
    OUT int *           piimg
    )
{
    CClusterNode *  pciNode = (CClusterNode *) pobj;
    int             colid;

    ASSERT_VALID(pciNode);
    ASSERT((0 <= icol) && (icol <= 1));

    switch (icol)
    {
        // Sorting by resource name.
        case 0:
            colid = IDS_COLTEXT_NAME;
            break;

        default:
            ASSERT(0);
            colid = IDS_COLTEXT_NAME;
            break;
    }  // switch:  pdlg->NSortColumn()

    pciNode->BGetColumnData(colid, rstr);
    if (piimg != NULL)
        *piimg = pciNode->IimgObjectType();

}  //*** CNewGroupOwnersPage::GetColumn()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewGroupOwnersPage::BDisplayProperties [static]
//
//  Routine Description:
//      Display the properties of the specified object.
//
//  Arguments:
//      pobj    [IN OUT] Cluster item whose properties are to be displayed.
//
//  Return Value:
//      TRUE    Properties where accepted.
//      FALSE   Properties where cancelled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK CNewGroupOwnersPage::BDisplayProperties(IN OUT CObject * pobj)
{
    CClusterItem *  pci = (CClusterItem *) pobj;

    ASSERT_KINDOF(CClusterItem, pobj);

    return pci->BDisplayProperties();

}  //*** CNewGroupOwnersPage::BDisplayProperties();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\lcpair.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      LCPair.cpp
//
//  Abstract:
//      Implementation of the CListCtrlPair class.
//
//  Author:
//      David Potter (davidp)   August 8, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "LCPair.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CListCtrlPair
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CListCtrlPair, CCmdTarget)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CListCtrlPair, CCmdTarget)
    //{{AFX_MSG_MAP(CListCtrlPair)
    //}}AFX_MSG_MAP
    ON_BN_CLICKED(IDC_LCP_ADD, OnAdd)
    ON_BN_CLICKED(IDC_LCP_REMOVE, OnRemove)
    ON_BN_CLICKED(IDC_LCP_PROPERTIES, OnProperties)
    ON_NOTIFY(NM_DBLCLK, IDC_LCP_LEFT_LIST, OnDblClkLeftList)
    ON_NOTIFY(NM_DBLCLK, IDC_LCP_RIGHT_LIST, OnDblClkRightList)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LCP_LEFT_LIST, OnItemChangedLeftList)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LCP_RIGHT_LIST, OnItemChangedRightList)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_LCP_LEFT_LIST, OnColumnClickLeftList)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_LCP_RIGHT_LIST, OnColumnClickRightList)
    ON_COMMAND(ID_FILE_PROPERTIES, OnProperties)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::CListCtrlPair
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPair::CListCtrlPair(void)
{
    CommonConstruct();

}  //*** CListCtrlPair::CListCtrlPair()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::CListCtrlPair
//
//  Routine Description:
//      Cconstructor.
//
//  Arguments:
//      pdlg            [IN OUT] Dialog to which controls belong.
//      plpobjRight     [IN OUT] List for the right list control.
//      plpobjLeft      [IN] List for the left list control.
//      dwStyle         [IN] Style:
//                          LCPS_SHOW_IMAGES    Show images to left of items.
//                          LCPS_ALLOW_EMPTY    Allow right list to be empty.
//      pfnGetColumn    [IN] Function pointer for retrieving columns.
//      pfnDisplayProps [IN] Function pointer for displaying properties.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPair::CListCtrlPair(
    IN OUT CDialog *            pdlg,
    IN OUT CClusterItemList *   plpobjRight,
    IN const CClusterItemList * plpobjLeft,
    IN DWORD                    dwStyle,
    IN PFNLCPGETCOLUMN          pfnGetColumn,
    IN PFNLCPDISPPROPS          pfnDisplayProps
    )
{
    ASSERT(pfnGetColumn != NULL);
    ASSERT(pfnDisplayProps != NULL);

    CommonConstruct();

    m_pdlg = pdlg;

    if (plpobjRight != NULL)
        m_plpobjRight = plpobjRight;
    if (plpobjLeft != NULL)
        m_plpobjLeft = plpobjLeft;

    m_dwStyle = dwStyle;

    m_pfnGetColumn = pfnGetColumn;
    m_pfnDisplayProps = pfnDisplayProps;

}  //*** CListCtrlPair::CListCtrlPair()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::CommonConstruct(void)
{
    m_pdlg = NULL;
    m_plpobjLeft = NULL;
    m_plpobjRight = NULL;
    m_dwStyle = LCPS_ALLOW_EMPTY;
    m_pfnGetColumn = NULL;
    m_plcFocusList = NULL;

    // Set the sort info.
    SiLeft().m_nDirection = -1;
    SiLeft().m_nColumn = -1;
    SiRight().m_nDirection = -1;
    SiRight().m_nColumn = -1;

}  //*** CListCtrlPair::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::NAddColumn
//
//  Routine Description:
//      Add a column to the list of columns displayed in each list control.
//
//  Arguments:
//      idsText     [IN] String resource ID for text to display on column.
//      nWidth      [IN] Initial width of the column.
//
//  Return Value:
//      icol        Index of the column.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CArray::Add.
//--
/////////////////////////////////////////////////////////////////////////////
int CListCtrlPair::NAddColumn(IN IDS idsText, IN int nWidth)
{
    CColumn     col;

    ASSERT(idsText != 0);
    ASSERT(nWidth > 0);
    ASSERT(LpobjRight().GetCount() == 0);

    col.m_idsText = idsText;
    col.m_nWidth = nWidth;

    return (int)m_aColumns.Add(col);

}  //*** CListCtrlPair::NAddColumn()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::DoDataExchange(CDataExchange * pDX)
{
    DDX_Control(pDX, IDC_LCP_RIGHT_LIST, m_lcRight);
    DDX_Control(pDX, IDC_LCP_LEFT_LIST, m_lcLeft);
    DDX_Control(pDX, IDC_LCP_ADD, m_pbAdd);
    DDX_Control(pDX, IDC_LCP_REMOVE, m_pbRemove);
    if (BPropertiesButton())
        DDX_Control(pDX, IDC_LCP_PROPERTIES, m_pbProperties);

    if (pDX->m_bSaveAndValidate)
    {
        // Verify that the list is not empty.
        if (!BAllowEmpty() && (m_lcRight.GetItemCount() == 0))
        {
            CString     strMsg;
            CString     strLabel;
            TCHAR *     pszLabel;
            TCHAR       szStrippedLabel[1024];
            int         iSrc;
            int         iDst;
            TCHAR       ch;

            DDX_Text(pDX, IDC_LCP_RIGHT_LABEL, strLabel);

            // Remove ampersands (&) and colons (:).
            pszLabel = strLabel.GetBuffer(1);
            for (iSrc = 0, iDst = 0 ; pszLabel[iSrc] != _T('\0') ; iSrc++)
            {
                ch = pszLabel[iSrc];
                if ((ch != _T('&')) && (ch != _T(':')))
                    szStrippedLabel[iDst++] = ch;
            }  // for:  each character in the label
            szStrippedLabel[iDst] = _T('\0');

            strMsg.FormatMessage(IDS_EMPTY_RIGHT_LIST, szStrippedLabel);
            ::AfxMessageBox(strMsg, MB_OK | MB_ICONWARNING);

            strMsg.Empty();
            pDX->Fail();
        }  // if:  list is empty and isn't allowed to be
    }  // if:  saving data from the dialog
    else
    {
        // Fill the lists.
        if (m_plpobjRight != NULL)
            FillList(m_lcRight, LpobjRight());
        if (m_plpobjLeft != NULL)
            FillList(m_lcLeft, LpobjLeft());
    }  // else:  setting data to the dialog

}  //*** CListCtrlPair::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPair::OnInitDialog(void)
{
    ASSERT_VALID(Pdlg());
    ASSERT(PlpobjRight() != NULL);
    ASSERT(PlpobjLeft() != NULL);

    Pdlg()->UpdateData(FALSE /*bSaveAndValidate*/);

    if (BShowImages())
    {
        CClusterAdminApp *  papp    = GetClusterAdminApp();

        m_lcLeft.SetImageList(papp->PilSmallImages(), LVSIL_SMALL);
        m_lcRight.SetImageList(papp->PilSmallImages(), LVSIL_SMALL);
    }  // if:  showing images
    
    // Disable buttons by default.
    m_pbAdd.EnableWindow(FALSE);
    m_pbRemove.EnableWindow(FALSE);
    if (BPropertiesButton())
        m_pbProperties.EnableWindow(FALSE);

    // Set the right list to sort.  Set both to show selection always.
    m_lcRight.ModifyStyle(0, LVS_SHOWSELALWAYS | LVS_SORTASCENDING, 0);
    m_lcLeft.ModifyStyle(0, LVS_SHOWSELALWAYS, 0);

    // Change list view control extended styles.
    {
        DWORD   dwExtendedStyle;

        // Left control.
        dwExtendedStyle = (DWORD)m_lcLeft.SendMessage(LVM_GETEXTENDEDLISTVIEWSTYLE);
        m_lcLeft.SendMessage(
            LVM_SETEXTENDEDLISTVIEWSTYLE,
            0,
            dwExtendedStyle
                | LVS_EX_FULLROWSELECT
                | LVS_EX_HEADERDRAGDROP
            );

        // Right control.
        dwExtendedStyle = (DWORD)m_lcRight.SendMessage(LVM_GETEXTENDEDLISTVIEWSTYLE);
        m_lcRight.SendMessage(
            LVM_SETEXTENDEDLISTVIEWSTYLE,
            0,
            dwExtendedStyle
                | LVS_EX_FULLROWSELECT
                | LVS_EX_HEADERDRAGDROP
            );
    }  // Change list view control extended styles

    try
    {
        // Duplicate lists.
        DuplicateLists();

        // Insert all the columns.
        {
            int         icol;
            int         ncol;
            int         nUpperBound = (int)m_aColumns.GetUpperBound();
            CString     strColText;

            ASSERT(nUpperBound >= 0);

            for (icol = 0 ; icol <= nUpperBound ; icol++)
            {
                strColText.LoadString(m_aColumns[icol].m_idsText);
                ncol = m_lcLeft.InsertColumn(icol, strColText, LVCFMT_LEFT, m_aColumns[icol].m_nWidth, 0);
                ASSERT(ncol == icol);
                ncol = m_lcRight.InsertColumn(icol, strColText, LVCFMT_LEFT, m_aColumns[icol].m_nWidth, 0);
                ASSERT(ncol == icol);
            }  // for:  each column
        }  // Insert all the columns
    }  // try
    catch (CException * pe)
    {
        pe->Delete();
    }  // catch:  CException

    Pdlg()->UpdateData(FALSE /*bSaveAndValidate*/);

    // If read-only, set all controls to be either disabled or read-only.
    if (BReadOnly())
    {
        m_lcRight.EnableWindow(FALSE);
        m_lcLeft.EnableWindow(FALSE);
    }  // if:  sheet is read-only

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CListCtrlPair::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPair::OnSetActive(void)
{
    UINT    nSelCount;

    // Set the focus to the left list.
    m_lcLeft.SetFocus();
    m_plcFocusList = &m_lcLeft;

    // Enable/disable the Properties button.
    nSelCount = m_lcLeft.GetSelectedCount();
    if (BPropertiesButton())
        m_pbProperties.EnableWindow(nSelCount == 1);

    // Enable or disable the other buttons.
    if (!BReadOnly())
    {
        m_pbAdd.EnableWindow(nSelCount > 0);
        nSelCount = m_lcRight.GetSelectedCount();
        m_pbRemove.EnableWindow(nSelCount > 0);
    }  // if:  not read-only page

    return TRUE;

}  //*** CListCtrlPair::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::BSaveChanges
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the OK button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Changes saved successfully.
//      FALSE       Error saving changes.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPair::BSaveChanges(void)
{
    POSITION        pos;
    CClusterItem *  pci;

    ASSERT(!BIsStyleSet(LCPS_DONT_OUTPUT_RIGHT_LIST));
    ASSERT(!BReadOnly());

    // Update the data first.
    if (!Pdlg()->UpdateData(TRUE /*bSaveAndValidate*/))
        return FALSE;

    // Copy the Nodes list.
    PlpobjRight()->RemoveAll();
    pos = LpobjRight().GetHeadPosition();
    while (pos != NULL)
    {
        pci = LpobjRight().GetNext(pos);
        ASSERT_VALID(pci);
        VERIFY(PlpobjRight()->AddTail(pci) != NULL);
    }  // while:  more items in the list

    return TRUE;

}  //*** CListCtrlPair::BSaveChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnAdd
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Add button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::OnAdd(void)
{
    ASSERT(!BReadOnly());

    // Move selected items from the left list to the right list.
    MoveItems(m_lcRight, LpobjRight(), m_lcLeft, LpobjLeft());

}  //*** CListCtrlPair::OnAdd()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnRemove
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Remove button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::OnRemove(void)
{
    ASSERT(!BReadOnly());

    // Move selected items from the right list to the left list.
    MoveItems(m_lcLeft, LpobjLeft(), m_lcRight, LpobjRight());

}  //*** CListCtrlPair::OnRemove()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnProperties
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Properties button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::OnProperties(void)
{
    int         iitem;
    CObject *   pobj;

    ASSERT(m_plcFocusList != NULL);
    ASSERT(m_pfnDisplayProps != NULL);

    // Get the index of the item with the focus.
    iitem = m_plcFocusList->GetNextItem(-1, LVNI_FOCUSED);
    ASSERT(iitem != -1);

    // Get a pointer to the selected item.
    pobj = (CObject *) m_plcFocusList->GetItemData(iitem);
    ASSERT_VALID(pobj);

    if ((*m_pfnDisplayProps)(pobj))
    {
        // Update this item.
        {
            CString     strText;
            int         iimg;
            int         icol;

            ASSERT(m_pfnGetColumn != NULL);
            ASSERT(Pdlg() != NULL);
            (*m_pfnGetColumn)(pobj, iitem, 0, Pdlg(), strText, &iimg);
            m_plcFocusList->SetItem(iitem, 0, LVIF_TEXT | LVIF_IMAGE, strText, iimg, 0, 0, 0);

            for (icol = 1 ; icol <= m_aColumns.GetUpperBound() ; icol++)
            {
                (*m_pfnGetColumn)(pobj, iitem, icol, Pdlg(), strText, NULL);
                m_plcFocusList->SetItemText(iitem, icol, strText);
            }  // for:  each column
        }  // Update this item
    }  // if:  properties changed

}  //*** CListCtrlPair::OnProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPair::OnContextMenu(CWnd * pWnd, CPoint point)
{
    BOOL            bHandled    = FALSE;
    CMenu *         pmenu       = NULL;
    CListCtrl *     pListCtrl   = (CListCtrl *) pWnd;
    CString         strMenuName;
    CWaitCursor     wc;

    // If focus is not in the list control, don't handle the message.
    if ( ( pWnd != &m_lcRight ) && ( pWnd != &m_lcLeft ) )
    {
        return FALSE;
    } // if: focus not in list control

    // Create the menu to display.
    try
    {
        pmenu = new CMenu;
        if ( pmenu == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the memory

        if ( pmenu->CreatePopupMenu() )
        {
            UINT    nFlags  = MF_STRING;

            // If there are no items in the list, disable the menu item.
            if ( pListCtrl->GetItemCount() == 0 )
            {
                nFlags |= MF_GRAYED;
            } // if: no items in the list

            // Add the Properties item to the menu.
            strMenuName.LoadString( IDS_MENU_PROPERTIES );
            if ( pmenu->AppendMenu( nFlags, ID_FILE_PROPERTIES, strMenuName ) )
            {
                m_plcFocusList = pListCtrl;
                bHandled = TRUE;
            }  // if:  successfully added menu item
        }  // if:  menu created successfully
    }  // try
    catch ( CException * pe )
    {
        pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    if ( bHandled )
    {
        // Display the menu.
        if ( ! pmenu->TrackPopupMenu(
                        TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                        point.x,
                        point.y,
                        Pdlg()
                        ) )
        {
        }  // if:  unsuccessfully displayed the menu
    }  // if:  there is a menu to display

    delete pmenu;
    return bHandled;

}  //*** CListCtrlPair::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnDblClkLeftList
//
//  Routine Description:
//      Handler method for the NM_DBLCLK message for the left list.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::OnDblClkLeftList(NMHDR * pNMHDR, LRESULT * pResult)
{
    ASSERT(!BReadOnly());

    m_plcFocusList = &m_lcLeft;
    OnAdd();
    *pResult = 0;

}  //*** CListCtrlPair::OnDblClkLeftList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnDblClkRightList
//
//  Routine Description:
//      Handler method for the NM_DBLCLK message for the right list.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::OnDblClkRightList(NMHDR * pNMHDR, LRESULT * pResult)
{
    ASSERT(!BReadOnly());

    m_plcFocusList = &m_lcRight;
    OnRemove();
    *pResult = 0;

}  //*** CListCtrlPair::OnDblClkRightList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnItemChangedLeftList
//
//  Routine Description:
//      Handler method for the LVN_ITEMCHANGED message in the left list.
//
//  Arguments:
//      pNMHDR      [IN OUT] WM_NOTIFY structure.
//      pResult     [OUT] LRESULT in which to return the result of this operation.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::OnItemChangedLeftList(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW * pNMListView = (NM_LISTVIEW *) pNMHDR;

    m_plcFocusList = &m_lcLeft;

    // If the selection changed, enable/disable the Add button.
    if ((pNMListView->uChanged & LVIF_STATE)
            && ((pNMListView->uOldState & LVIS_SELECTED)
                    || (pNMListView->uNewState & LVIS_SELECTED))
            && !BReadOnly())
    {
        UINT    cSelected = m_plcFocusList->GetSelectedCount();

        // If there is a selection, enable the Add button.  Otherwise disable it.
        m_pbAdd.EnableWindow((cSelected == 0) ? FALSE : TRUE);
        if (BPropertiesButton())
            m_pbProperties.EnableWindow((cSelected == 1) ? TRUE : FALSE);
    }  // if:  selection changed

    *pResult = 0;

}  //*** CListCtrlPair::OnItemChangedLeftList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnItemChangedRightList
//
//  Routine Description:
//      Handler method for the LVN_ITEMCHANGED message in the right list.
//
//  Arguments:
//      pNMHDR      [IN OUT] WM_NOTIFY structure.
//      pResult     [OUT] LRESULT in which to return the result of this operation.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::OnItemChangedRightList(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW *   pNMListView = (NM_LISTVIEW *) pNMHDR;

    m_plcFocusList = &m_lcRight;

    // If the selection changed, enable/disable the Remove button.
    if ((pNMListView->uChanged & LVIF_STATE)
            && ((pNMListView->uOldState & LVIS_SELECTED)
                    || (pNMListView->uNewState & LVIS_SELECTED))
            && !BReadOnly())
    {
        UINT    cSelected = m_plcFocusList->GetSelectedCount();

        // If there is a selection, enable the Remove button.  Otherwise disable it.
        m_pbRemove.EnableWindow((cSelected == 0) ? FALSE : TRUE);
        if (BPropertiesButton())
            m_pbProperties.EnableWindow((cSelected == 1) ? TRUE : FALSE);
    }  // if:  selection changed

    *pResult = 0;

}  //*** CListCtrlPair::OnItemChangedRightList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnColumnClickLeftList
//
//  Routine Description:
//      Handler method for the LVN_COLUMNCLICK message on the left list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::OnColumnClickLeftList(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW *   pNMListView = (NM_LISTVIEW *) pNMHDR;

    ASSERT(m_pfnGetColumn != NULL);

    m_plcFocusList = &m_lcLeft;

    // Save the current sort column and direction.
    if (pNMListView->iSubItem == SiLeft().m_nColumn)
        SiLeft().m_nDirection ^= -1;
    else
    {
        SiLeft().m_nColumn = pNMListView->iSubItem;
        SiLeft().m_nDirection = 0;
    }  // else:  different column

    // Sort the list.
    m_psiCur = &SiLeft();
    VERIFY(m_lcLeft.SortItems(CompareItems, (LPARAM) this));

    *pResult = 0;

}  //*** CListCtrlPair::OnColumnClickLeftList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnColumnClickRightList
//
//  Routine Description:
//      Handler method for the LVN_COLUMNCLICK message on the right list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::OnColumnClickRightList(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW *   pNMListView = (NM_LISTVIEW *) pNMHDR;

    ASSERT(m_pfnGetColumn != NULL);

    m_plcFocusList = &m_lcRight;

    // Save the current sort column and direction.
    if (pNMListView->iSubItem == SiRight().m_nColumn)
        SiRight().m_nDirection ^= -1;
    else
    {
        SiRight().m_nColumn = pNMListView->iSubItem;
        SiRight().m_nDirection = 0;
    }  // else:  different column

    // Sort the list.
    m_psiCur = &SiRight();
    VERIFY(m_lcRight.SortItems(CompareItems, (LPARAM) this));

    *pResult = 0;

}  //*** CListCtrlPair::OnColumnClickRightList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::CompareItems [static]
//
//  Routine Description:
//      Callback function for the CListCtrl::SortItems method.
//
//  Arguments:
//      lparam1     First item to compare.
//      lparam2     Second item to compare.
//      lparamSort  Sort parameter.
//
//  Return Value:
//      -1          First parameter comes before second.
//      0           First and second parameters are the same.
//      1           First parameter comes after second.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CALLBACK CListCtrlPair::CompareItems(
    LPARAM  lparam1,
    LPARAM  lparam2,
    LPARAM  lparamSort
    )
{
    CObject *           pobj1   = (CObject *) lparam1;
    CObject *           pobj2   = (CObject *) lparam2;
    CListCtrlPair *     plcp    = (CListCtrlPair *) lparamSort;
    int                 icol    = plcp->PsiCur()->m_nColumn;
    int                 nResult;
    CString             str1;
    CString             str2;

    ASSERT_VALID(pobj1);
    ASSERT_VALID(pobj2);
    ASSERT(plcp != NULL);
    ASSERT(plcp->PsiCur()->m_nColumn >= 0);
    ASSERT(icol >= 0);

    (*plcp->m_pfnGetColumn)(pobj1, 0, icol, plcp->Pdlg(), str1, NULL);
    (*plcp->m_pfnGetColumn)(pobj2, 0, icol, plcp->Pdlg(), str2, NULL);

    // Compare the two strings.
    // Use CompareString() so that it will sort properly on localized builds.
    nResult = CompareString(
                LOCALE_USER_DEFAULT,
                0,
                str1,
                str1.GetLength(),
                str2,
                str2.GetLength()
                );
    if ( nResult == CSTR_LESS_THAN )
    {
        nResult = -1;
    }
    else if ( nResult == CSTR_EQUAL )
    {
        nResult = 0;
    }
    else if ( nResult == CSTR_GREATER_THAN )
    {
        nResult = 1;
    }
    else
    {
        // An error occurred.  Ignore it.
        nResult = 0;
    }

    // Return the result based on the direction we are sorting.
    if (plcp->PsiCur()->m_nDirection != 0)
        nResult = -nResult;

    return nResult;

}  //*** CListCtrlPair::CompareItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::SetLists
//
//  Routine Description:
//      Set the lists for the list control pair.
//
//  Arguments:
//      plpobjRight     [IN OUT] List for the right list box.
//      plpobjLeft      [IN] List for the left list box.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::SetLists(
    IN OUT CClusterItemList *   plpobjRight,
    IN const CClusterItemList * plpobjLeft
    )
{
    if (plpobjRight != NULL)
        m_plpobjRight = plpobjRight;
    if (plpobjLeft != NULL)
        m_plpobjLeft = plpobjLeft;

    DuplicateLists();

}  //*** CListCtrlPair::SetLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::SetLists
//
//  Routine Description:
//      Set the lists for the list control pair where the right list should
//      not be modified.
//
//  Arguments:
//      plpobjRight     [IN] List for the right list box.
//      plpobjLeft      [IN] List for the left list box.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::SetLists(
    IN const CClusterItemList * plpobjRight,
    IN const CClusterItemList * plpobjLeft
    )
{
    m_dwStyle |= LCPS_DONT_OUTPUT_RIGHT_LIST;
    SetLists((CClusterItemList *) plpobjRight, plpobjLeft);

}  //*** CListCtrlPair::SetLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::DuplicateLists
//
//  Routine Description:
//      Duplicate the lists so that we have local copies.
//
//  Arguments:
//      rlc         [IN OUT] List control to fill.
//      rlpobj      [IN] List to use to fill the control.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::DuplicateLists(void)
{
    LpobjRight().RemoveAll();
    LpobjLeft().RemoveAll();

    if ((PlpobjRight() == NULL) || (PlpobjLeft() == NULL))
        return;

    // Duplicate the right list.
    {
        POSITION        pos;
        CClusterItem *  pci;

        pos = PlpobjRight()->GetHeadPosition();
        while (pos != NULL)
        {
            // Get the item pointer.
            pci = PlpobjRight()->GetNext(pos);
            ASSERT_VALID(pci);

            // Add it to our list.
            LpobjRight().AddTail(pci);
        }  // while:  more items in the list
    }  // Duplicate the right list

    // Duplicate the left list.
    {
        POSITION        pos;
        CClusterItem *  pci;

        pos = PlpobjLeft()->GetHeadPosition();
        while (pos != NULL)
        {
            // Get the item pointer.
            pci = PlpobjLeft()->GetNext(pos);
            ASSERT_VALID(pci);

            // If the item is not already in the other list,
            // add it to the left list.
            if (LpobjRight().Find(pci) == NULL)
                LpobjLeft().AddTail(pci);
        }  // while:  more items in the list
    }  // Duplicate the left list

}  //*** CListCtrlPair::DuplicateLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::FillList
//
//  Routine Description:
//      Fill a list control.
//
//  Arguments:
//      rlc         [IN OUT] List control to fill.
//      rlpobj      [IN] List to use to fill the control.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::FillList(
    IN OUT CListCtrl &          rlc,
    IN const CClusterItemList & rlpobj
    )
{
    POSITION    pos;
    CObject *   pobj;
    int         iItem;

    // Initialize the control.
    VERIFY(rlc.DeleteAllItems());

    rlc.SetItemCount((int)rlpobj.GetCount());

    // Add the items to the list.
    pos = rlpobj.GetHeadPosition();
    for (iItem = 0 ; pos != NULL ; iItem++)
    {
        pobj = rlpobj.GetNext(pos);
        ASSERT_VALID(pobj);
        NInsertItemInListCtrl(iItem, pobj, rlc);
    }  // for:  each string in the list

    // If there are any items, set the focus on the first one.
    if (rlc.GetItemCount() != 0)
        rlc.SetItemState(0, LVIS_FOCUSED, LVIS_FOCUSED);

}  //*** CListCtrlPair::FillList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::NInsertItemInListCtrl
//
//  Routine Description:
//      Insert an item in a list control.
//
//  Arguments:
//      iitem       [IN] Index of the item in the list.
//      pobj        [IN OUT] Item to add.
//      rlc         [IN OUT] List control in which to insert the item.
//
//  Return Value:
//      iRetItem    Index of the new item in the list control.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CListCtrlPair::NInsertItemInListCtrl(
    IN int              iitem,
    IN OUT CObject *    pobj,
    IN OUT CListCtrl &  rlc
    )
{
    int         iRetItem;
    CString     strText;
    int         iimg;
    int         icol;

    ASSERT(m_pfnGetColumn != NULL);
    ASSERT(Pdlg() != NULL);

    // Insert the first column.
    (*m_pfnGetColumn)(pobj, iitem, 0, Pdlg(), strText, &iimg);
    iRetItem = rlc.InsertItem(
                    LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM,    // nMask
                    iitem,                                  // nItem
                    strText,                                // lpszItem
                    0,                                      // nState
                    0,                                      // nStateMask
                    iimg,                                   // nImage
                    (LPARAM) pobj                           // lParam
                    );
    ASSERT(iRetItem != -1);

    for (icol = 1 ; icol <= m_aColumns.GetUpperBound() ; icol++)
    {
        (*m_pfnGetColumn)(pobj, iRetItem, icol, Pdlg(), strText, NULL);
        rlc.SetItemText(iRetItem, icol, strText);
    }  // for:  each column

    return iRetItem;

}  //*** CListCtrlPair::NInsertItemInListCtrl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::MoveItems
//
//  Routine Description:
//      Move an item from one list to the other.
//
//  Arguments:
//      rlcDst      [IN OUT] Destination list control.
//      rlpobjDst   [IN OUT] Destination list.
//      rlcSrc      [IN OUT] Source list control.
//      rlpobjSrc   [IN OUT] Source list.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPair::MoveItems(
    IN OUT CListCtrl &          rlcDst,
    IN OUT CClusterItemList &   rlpobjDst,
    IN OUT CListCtrl &          rlcSrc,
    IN OUT CClusterItemList &   rlpobjSrc
    )
{
    int             iSrcItem;
    int             iDstItem;
    int             nItem   = -1;
    CClusterItem *  pci;
    POSITION        pos;

    ASSERT(!BReadOnly());

    iDstItem = rlcDst.GetItemCount();
    while ((iSrcItem = rlcSrc.GetNextItem(-1, LVNI_SELECTED)) != -1)
    {
        // Get the item pointer.
        pci = (CClusterItem *) rlcSrc.GetItemData(iSrcItem);
        ASSERT_VALID(pci);

        // Remove the item from the source list.
        pos = rlpobjSrc.Find(pci);
        ASSERT(pos != NULL);
        rlpobjSrc.RemoveAt(pos);

        // Add the item to the destination list.
        rlpobjDst.AddTail(pci);

        // Remove the item from the source list control and
        // add it to the destination list control.
        VERIFY(rlcSrc.DeleteItem(iSrcItem));
        nItem = NInsertItemInListCtrl(iDstItem++, pci, rlcDst);
        rlcDst.SetItemState(
            nItem,
            LVIS_SELECTED | LVIS_FOCUSED,
            LVIS_SELECTED | LVIS_FOCUSED
            );
    }  // while:  more items

    ASSERT(nItem != -1);

    rlcDst.EnsureVisible(nItem, FALSE /*bPartialOK*/);
    rlcDst.SetFocus();

    // Indicate that the data has changed.
    Pdlg()->GetParent()->SendMessage(PSM_CHANGED, (WPARAM)Pdlg()->m_hWnd);

}  //*** CListCtrlPair::MoveItems()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\lcprdlg.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      LCPrDlg.cpp
//
//  Abstract:
//      Implementation of the CListCtrlPairDlg dialog template class.
//
//  Author:
//      David Potter (davidp)   August 12, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "LCPrDlg.h"
#include "OLCPair.h"
#include "HelpData.h"   // for g_rghelpmap*

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CListCtrlPairDlg
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CListCtrlPairDlg, CBaseDialog)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CListCtrlPairDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CListCtrlPairDlg)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::CListCtrlPairDlg
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPairDlg::CListCtrlPairDlg(void)
{
    CommonConstruct();

}  //*** CListCtrlPairDlg::CListCtrlPairDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::CListCtrlPairDlg
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      idd             [IN] Resource ID for the dialog template.
//      pdwHelpMap      [IN] Control-to-Help ID mapping array.
//      plpciRight      [IN OUT] List for the right list control.
//      plpciLeft       [IN] List for the left list control.
//      dwStyle         [IN] Style:
//                          LCPS_SHOW_IMAGES    Show images to left of items.
//                          LCPS_ALLOW_EMPTY    Allow right list to be empty.
//                          LCPS_ORDERED        Ordered right list.
//                          LCPS_CAN_BE_ORDERED List can be ordered (hides
//                              Up/Down buttons if LCPS_ORDERED not specified).
//      pfnGetColumn    [IN] Function pointer for getting column data.
//      pfnDisplayProps [IN] Function pointer for displaying properties.
//      pParent         [IN OUT] Parent window.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPairDlg::CListCtrlPairDlg(
    IN UINT                     idd,
    IN const DWORD *            pdwHelpMap,
    IN OUT CClusterItemList *   plpobjRight,
    IN const CClusterItemList * plpobjLeft,
    IN DWORD                    dwStyle,
    IN PFNLCPGETCOLUMN          pfnGetColumn,
    IN PFNLCPDISPPROPS          pfnDisplayProps,
    IN OUT CWnd *               pParent         //=NULL
    )
    : CBaseDialog(idd, pdwHelpMap, pParent)
{
    ASSERT(pfnGetColumn != NULL);
    ASSERT(pfnDisplayProps != NULL);

    CommonConstruct();

    if (plpobjRight != NULL)
        m_plpobjRight = plpobjRight;
    if (plpobjLeft != NULL)
        m_plpobjLeft = plpobjLeft;

    m_dwStyle = dwStyle;
    m_pfnGetColumn = pfnGetColumn;
    m_pfnDisplayProps = pfnDisplayProps;

    if (dwStyle & LCPS_ORDERED)
        ASSERT(m_dwStyle & LCPS_CAN_BE_ORDERED);

}  //*** CListCtrlPairDlg::CListCtrlPairDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairDlg::CommonConstruct(void)
{
    m_plpobjRight = NULL;
    m_plpobjLeft = NULL;
    m_dwStyle = 0;
    m_pfnGetColumn = NULL;

    m_plcp = NULL;

}  //*** CListCtrlPairDlg::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::~CListCtrlPairDlg
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPairDlg::~CListCtrlPairDlg(void)
{
    delete m_plcp;

}  //*** CListCtrlPairDlg::~CListCtrlPairDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::NAddColumn
//
//  Routine Description:
//      Add a column to the list of columns displayed in each list control.
//
//  Arguments:
//      idsText     [IN] String resource ID for text to display on column.
//      nWidth      [IN] Initial width of the column.
//
//  Return Value:
//      icol        Index of the column.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CArray::Add.
//--
/////////////////////////////////////////////////////////////////////////////
int CListCtrlPairDlg::NAddColumn(IN IDS idsText, IN int nWidth)
{
    CListCtrlPair::CColumn  col;

    ASSERT(idsText != 0);
    ASSERT(nWidth > 0);
    ASSERT(Plcp() == NULL);

    col.m_idsText = idsText;
    col.m_nWidth = nWidth;

    return (int)m_aColumns.Add(col);

}  //*** CListCtrlPair::NAddColumn()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairDlg::DoDataExchange(CDataExchange * pDX)
{
    CBaseDialog::DoDataExchange(pDX);
    Plcp()->DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CListCtrlPairDlg)
    //}}AFX_DATA_MAP

}  //*** CListCtrlPairDlg::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPairDlg::OnInitDialog( void )
{
    // Initialize the ListCtrlPair control.
    if ( BCanBeOrdered() )
    {
        m_plcp = new COrderedListCtrlPair(
                        this,
                        m_plpobjRight,
                        m_plpobjLeft,
                        m_dwStyle,
                        m_pfnGetColumn,
                        m_pfnDisplayProps
                        );
    } // if: list can be ordered
    else
    {
        m_plcp = new CListCtrlPair(
                        this,
                        m_plpobjRight,
                        m_plpobjLeft,
                        m_dwStyle,
                        m_pfnGetColumn,
                        m_pfnDisplayProps
                        );
    } // else: list cannot be ordered
    if ( m_plcp == NULL )
    {
        AfxThrowMemoryException();
    } // if: Error allocating memory

    // Add columns if there are any.
    {
        int     icol;

        for ( icol = 0 ; icol <= m_aColumns.GetUpperBound() ; icol++ )
        {
            Plcp()->NAddColumn( m_aColumns[ icol ].m_idsText, m_aColumns[ icol ].m_nWidth );
        } // for: each column
    }  // Add columns if there are any

    CBaseDialog::OnInitDialog();
    Plcp()->OnInitDialog();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CListCtrlPairDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::OnOK
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the OK button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairDlg::OnOK(void)
{
    if (Plcp()->BSaveChanges())
        CBaseDialog::OnOK();

}  //*** CListCtrlPairDlg::OnOK()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.  Attempts to pass them on to a selected
//      item first.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPairDlg::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    BOOL    bHandled;

    ASSERT(Plcp() != NULL);

    bHandled = Plcp()->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    if (!bHandled)
        bHandled = CBaseDialog::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    return bHandled;

}  //*** CListCtrlPairDlg::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairDlg::OnContextMenu(CWnd * pWnd, CPoint point)
{
    ASSERT(Plcp() != NULL);

    if (!Plcp()->OnContextMenu(pWnd, point))
        CBaseDialog::OnContextMenu(pWnd, point);

}  //*** CListCtrlPairDlg::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::SetLists
//
//  Routine Description:
//      Set the lists for the list control pair.
//
//  Arguments:
//      plpobjRight     [IN OUT] List for the right list box.
//      plpobjLeft      [IN] List for the left list box.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairDlg::SetLists(
    IN OUT CClusterItemList *   plpobjRight,
    IN const CClusterItemList * plpobjLeft
    )
{
    if (plpobjRight != NULL)
        m_plpobjRight = plpobjRight;
    if (plpobjLeft != NULL)
        m_plpobjLeft = plpobjLeft;
    if (Plcp() != NULL)
        Plcp()->SetLists(plpobjRight, plpobjLeft);

}  //*** CListCtrlPairDlg::SetLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairDlg::SetLists
//
//  Routine Description:
//      Set the lists for the list control pair where the right list should
//      not be modified.
//
//  Arguments:
//      plpobjRight     [IN] List for the right list box.
//      plpobjLeft      [IN] List for the left list box.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairDlg::SetLists(
    IN const CClusterItemList * plpobjRight,
    IN const CClusterItemList * plpobjLeft
    )
{
    if (plpobjRight != NULL)
        m_plpobjRight = (CClusterItemList *) plpobjRight;
    if (plpobjLeft != NULL)
        m_plpobjLeft = plpobjLeft;
    m_dwStyle |= LCPS_DONT_OUTPUT_RIGHT_LIST;
    if (Plcp() != NULL)
        Plcp()->SetLists(plpobjRight, plpobjLeft);

}  //*** CListCtrlPairDlg::SetLists()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\grpwiz.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		GrpWiz.h
//
//	Abstract:
//		Definition of the CCreateGroupWizard class and all pages specific
//		to a group wizard.
//
//	Implementation File:
//		GrpWiz.cpp
//
//	Author:
//		David Potter (davidp)	July 22, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _GRPWIZ_H_
#define _GRPWIZ_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEWIZ_H_
#include "BaseWiz.h"	// for CBaseWizard
#endif

#ifndef _BASEWPAG_H_
#include "BaseWPag.h"	// for CBaseWizardPage
#endif

#ifndef _LCPRPAGE_H_
#include "LCPrWPag.h"	// for CListCtrlPairWizPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNewGroupNamePage;
class CCreateGroupWizard;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CGroup;
class CClusterDoc;

/////////////////////////////////////////////////////////////////////////////
// CNewGroupNamePage property page
/////////////////////////////////////////////////////////////////////////////

class CNewGroupNamePage : public CBaseWizardPage
{
	DECLARE_DYNCREATE(CNewGroupNamePage)

// Construction
public:
	CNewGroupNamePage(void);

// Dialog Data
	//{{AFX_DATA(CNewGroupNamePage)
	enum { IDD = IDD_WIZ_GROUP_NAME };
	CEdit	m_editDesc;
	CEdit	m_editName;
	CString	m_strName;
	CString	m_strDesc;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNewGroupNamePage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL			BApplyChanges(void);

// Implementation
protected:
	CCreateGroupWizard *	PwizGroup(void) const	{ return (CCreateGroupWizard *) Pwiz(); }

	// Generated message map functions
	//{{AFX_MSG(CNewGroupNamePage)
	afx_msg void OnChangeGroupName();
	afx_msg void OnKillFocusGroupName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNewGroupNamePage

/////////////////////////////////////////////////////////////////////////////
// CNewGroupOwnersPage dialog
/////////////////////////////////////////////////////////////////////////////

class CNewGroupOwnersPage : public CListCtrlPairWizPage
{
	DECLARE_DYNCREATE(CNewGroupOwnersPage)

// Construction
public:
	CNewGroupOwnersPage(void);

// Dialog Data
	//{{AFX_DATA(CNewGroupOwnersPage)
	enum { IDD = IDD_WIZ_PREFERRED_OWNERS };
	CStatic	m_staticNote;
	//}}AFX_DATA

// Callback functions
	static void CALLBACK	GetColumn(
								IN OUT CObject *	pobj,
								IN int				iItem,
								IN int				icol,
								IN OUT CDialog *	pdlg,
								OUT CString &		rstr,
								OUT int *			piimg
								);
	static BOOL	CALLBACK	BDisplayProperties(IN OUT CObject * pobj);

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNewGroupOwnersPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL			BApplyChanges(void);

// Implementation
protected:
	CCreateGroupWizard *	PwizGroup(void) const	{ return (CCreateGroupWizard *) Pwiz(); }
	CGroup *				PciGroup(void) const;

	BOOL					BInitLists(void);

	// Generated message map functions
	//{{AFX_MSG(CNewGroupOwnersPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNewGroupOwnersPage

/////////////////////////////////////////////////////////////////////////////
// CCreateGroupWizard
/////////////////////////////////////////////////////////////////////////////

class CCreateGroupWizard : public CBaseWizard
{
	friend class CNewGroupNamePage;
	friend class CNewGroupOwnersPage;

	DECLARE_DYNAMIC(CCreateGroupWizard)

// Construction
public:
	CCreateGroupWizard(IN OUT CClusterDoc * pdoc, IN OUT CWnd * pParentWnd);
	BOOL				BInit(void);

// Attributes
protected:
	CWizPage			m_rgpages[2];

	CClusterDoc *		m_pdoc;
	CString				m_strName;
	CString				m_strDescription;
	CStringList			m_lstrPreferredOwners;

public:
	CClusterDoc *		Pdoc(void) const				{ return m_pdoc; }
	const CString &		StrName(void) const				{ return m_strName; }
	const CString &		StrDescription(void) const		{ return m_strDescription; }
	const CStringList &	LstrPreferredOwners(void) const	{ return m_lstrPreferredOwners; }

// Operations
public:
	BOOL				BSetName(IN const CString & rstrName);
	BOOL				BSetDescription(IN const CString & rstrDescription);

// Overrides
protected:
	virtual void		OnCancel(void);
	virtual CWizPage *	Ppages(void);
	virtual int			Cpages(void);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCreateGroupWizard)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CCreateGroupWizard(void);

protected:
	CNewGroupNamePage	m_pageName;
	CNewGroupOwnersPage	m_pageOwners;
	CStringList			m_lstrAllNodes;
	CGroup *			m_pciGroup;
	BOOL				m_bCreated;

	const CStringList &	LstrAllNodes(void) const		{ return m_lstrAllNodes; }
	CGroup *			PciGroup(void) const			{ return m_pciGroup; }
	BOOL				BCreated(void) const			{ return m_bCreated; }


	// Generated message map functions
protected:
	//{{AFX_MSG(CCreateGroupWizard)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CCreateGroupWizard

/////////////////////////////////////////////////////////////////////////////
// Inline Function Definitions
/////////////////////////////////////////////////////////////////////////////

inline CGroup * CNewGroupOwnersPage::PciGroup(void) const
{
	ASSERT_VALID(PwizGroup());
	return PwizGroup()->PciGroup();
}

/////////////////////////////////////////////////////////////////////////////

#endif // _GRPWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\lcpair.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		LCPair.h
//
//	Abstract:
//		Definition of the CListCtrlPair dialog.
//
//	Implementation File:
//		LCPair.cpp
//
//	Author:
//		David Potter (davidp)	August 8, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _LCPAIR_H_
#define _LCPAIR_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSITEM_H_
#include "ClusItem.h"	// for CClusterItemList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CListCtrlPair;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef void (*PFNLCPGETCOLUMN)(
				IN OUT CObject *	pobj,
				IN int				iItem,
				IN int				icol,
				IN OUT CDialog *	pdlg,
				OUT CString &		rstr,
				OUT int *			piimg
				);
typedef int (*PFNLCPDISPPROPS)(
				IN OUT CObject *	pobj
				);

/////////////////////////////////////////////////////////////////////////////
// CListCtrlPair command target
/////////////////////////////////////////////////////////////////////////////

class CListCtrlPair : public CCmdTarget
{
	DECLARE_DYNAMIC(CListCtrlPair)
	friend class CListCtrlPairDlg;
	friend class CListCtrlPairPage;
	friend class CListCtrlPairWizPage;

// Construction
public:
	CListCtrlPair(void);		// protected constructor used by dynamic creation
	CListCtrlPair(
		IN OUT CDialog *			pdlg,
		IN OUT CClusterItemList *	rlpobjRight,
		IN const CClusterItemList *	rlpobjLeft,
		IN DWORD					dwStyle,
		IN PFNLCPGETCOLUMN			pfnGetColumn,
		IN PFNLCPDISPPROPS			pfnDisplayProps
		);

	void CommonConstruct(void);

// Attributes
protected:
	CDialog *					m_pdlg;
	CClusterItemList *			m_plpobjRight;
	const CClusterItemList *	m_plpobjLeft;
	IDS							m_idsRightLabel;
	IDS							m_idsLeftLabel;
	DWORD						m_dwStyle;

#define LCPS_SHOW_IMAGES			0x1
#define LCPS_ALLOW_EMPTY			0x2
#define LCPS_CAN_BE_ORDERED			0x4
#define LCPS_ORDERED				0x8
#define LCPS_DONT_OUTPUT_RIGHT_LIST	0x10
#define LCPS_READ_ONLY				0x20
#define LCPS_PROPERTIES_BUTTON		0x40
#define LCPS_MAX					0x40

	PFNLCPGETCOLUMN	m_pfnGetColumn;
	PFNLCPDISPPROPS	m_pfnDisplayProps;

	BOOL			BIsStyleSet(IN DWORD dwStyle) const	{ return (m_dwStyle & dwStyle) == dwStyle; }
	void			ModifyStyle(IN DWORD dwRemove, IN DWORD dwAdd)
	{
		ASSERT((dwRemove & dwAdd) == 0);
		if (dwRemove != 0)
			m_dwStyle &= ~dwRemove;
		if (dwAdd != 0)
			m_dwStyle |= dwAdd;
	}

public:
	CDialog *		Pdlg(void) const				{ return m_pdlg; }
	CClusterItemList *			PlpobjRight(void) const			{ return m_plpobjRight; }
	const CClusterItemList *	PlpobjLeft(void) const			{ return m_plpobjLeft; }
	IDS				IdsRightLabel(void) const		{ return m_idsRightLabel; }
	IDS				IdsLeftLabel(void) const		{ return m_idsLeftLabel; }
	DWORD			DwStyle(void) const				{ return m_dwStyle; }
	BOOL			BShowImages(void) const			{ return BIsStyleSet(LCPS_SHOW_IMAGES); }
	BOOL			BAllowEmpty(void) const			{ return BIsStyleSet(LCPS_ALLOW_EMPTY); }
	BOOL			BCanBeOrdered(void) const		{ return BIsStyleSet(LCPS_CAN_BE_ORDERED); }
	BOOL			BOrdered(void) const			{ return BIsStyleSet(LCPS_ORDERED); }
	BOOL			BReadOnly(void) const			{ return BIsStyleSet(LCPS_READ_ONLY); }
	BOOL			BPropertiesButton(void) const	{ return BIsStyleSet(LCPS_PROPERTIES_BUTTON); }

	void			SetDlg(CDialog * pdlg)		{ ASSERT_VALID(pdlg); m_pdlg = pdlg; }

	void			SetLists(IN OUT CClusterItemList * plpobjRight, IN const CClusterItemList * plpobjLeft);
	void			SetLists(IN const CClusterItemList * plpobjRight, IN const CClusterItemList * plpobjLeft);

// Operations
public:
	int				NAddColumn(IN IDS idsText, IN int nWidth);
	int				NInsertItemInListCtrl(
								IN int				iitem,
								IN OUT CObject *	pobj,
								IN OUT CListCtrl &	rlc
								);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListCtrlPair)
	//}}AFX_VIRTUAL
	virtual BOOL	OnSetActive(void);
	virtual void	DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	CClusterItemList	m_lpobjRight;
	CClusterItemList	m_lpobjLeft;
	CListCtrl			m_lcRight;
	CListCtrl			m_lcLeft;
	CListCtrl *			m_plcFocusList;
	CButton				m_pbAdd;
	CButton				m_pbRemove;
	CButton				m_pbProperties;

public:
	CClusterItemList &	LpobjRight(void)		{ return m_lpobjRight; }
	CClusterItemList &	LpobjLeft(void)			{ return m_lpobjLeft; }

protected:
	void			DuplicateLists(void);
	void			FillList(IN OUT CListCtrl & rlc, IN const CClusterItemList & rlpobj);
	void			MoveItems(
						IN OUT CListCtrl &			rlcDst,
						IN OUT CClusterItemList &	rlpobjDst,
						IN OUT CListCtrl &			rlcSrc,
						IN OUT CClusterItemList &	rlpobjSrc
						);

	// Column structure and collection.
	struct CColumn
	{
		IDS			m_idsText;
		int			m_nWidth;
	};
	typedef CArray<CColumn, CColumn&> CColumnArray;
	CColumnArray	m_aColumns;

	// Sort information.
	struct SortInfo
	{
		int		m_nDirection;
		int		m_nColumn;
	};
	
	static int CALLBACK		CompareItems(LPARAM lparam1, LPARAM lparam2, LPARAM lparamSort);

	SortInfo				m_siLeft;
	SortInfo				m_siRight;
	SortInfo *				m_psiCur;

	SortInfo &				SiLeft(void)		{ return m_siLeft; }
	SortInfo &				SiRight(void)		{ return m_siRight; }
	SortInfo *				PsiCur(void) const	{ return m_psiCur; }

	// Generated message map functions
	//{{AFX_MSG(CListCtrlPair)
	//}}AFX_MSG
public:
	virtual BOOL OnInitDialog(void);
	virtual BOOL BSaveChanges(void);
protected:
	afx_msg BOOL OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnAdd(void);
	afx_msg void OnRemove(void);
	afx_msg void OnProperties(void);
	afx_msg void OnDblClkLeftList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblClkRightList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemChangedLeftList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemChangedRightList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClickLeftList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClickRightList(NMHDR* pNMHDR, LRESULT* pResult);

	DECLARE_MESSAGE_MAP()

};  //*** class CListCtrlPair

/////////////////////////////////////////////////////////////////////////////

#endif // _LCPAIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\lcprdlg.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		LCPrDlg.h
//
//	Abstract:
//		Definition of the CListCtrlPairDlg dialog class.
//
//	Implementation File:
//		LCPrDlg.cpp
//
//	Author:
//		David Potter (davidp)	August 8, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _LCPRDLG_H_
#define _LCPRDLG_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEDLG_H_
#include "BaseDlg.h"	// for CBaseDialog
#endif

#ifndef _LCPAIR_H_
#include "LCPair.h"		// for PFNLCPGETCOLUMN, CListCtrlPair
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CListCtrlPairDlg;

/////////////////////////////////////////////////////////////////////////////
// CListCtrlPairDlg dialog
/////////////////////////////////////////////////////////////////////////////

class CListCtrlPairDlg : public CBaseDialog
{
	DECLARE_DYNCREATE(CListCtrlPairDlg)

// Construction
public:
	CListCtrlPairDlg(void);
	CListCtrlPairDlg(
		IN UINT						idd,
		IN const DWORD *			pdwHelpMap,
		IN OUT CClusterItemList *	plpobjRight,
		IN const CClusterItemList *	plpobjLeft,
		IN DWORD					dwStyle,
		IN PFNLCPGETCOLUMN			pfnGetColumn,
		IN PFNLCPDISPPROPS			pfnDisplayProps,
		IN OUT CWnd *				pParent			= NULL
		);
	~CListCtrlPairDlg(void);

	void CommonConstruct(void);

// Attributes
protected:
	CClusterItemList *			m_plpobjRight;
	const CClusterItemList *	m_plpobjLeft;
	DWORD						m_dwStyle;
	PFNLCPGETCOLUMN				m_pfnGetColumn;
	PFNLCPDISPPROPS				m_pfnDisplayProps;

	BOOL						BIsStyleSet(IN DWORD dwStyle) const	{ return (m_dwStyle & dwStyle) == dwStyle; }

	CListCtrlPair::CColumnArray	m_aColumns;

public:
	BOOL				BOrdered(void) const		{ return BIsStyleSet(LCPS_ORDERED); }
	BOOL				BCanBeOrdered(void) const	{ return BIsStyleSet(LCPS_CAN_BE_ORDERED); }
	int					NAddColumn(IN IDS idsText, IN int nWidth);

	void				SetLists(IN OUT CClusterItemList * plpobjRight, IN const CClusterItemList * plpobjLeft);
	void				SetLists(IN const CClusterItemList * plpobjRight, IN const CClusterItemList * plpobjLeft);

// Dialog Data
	//{{AFX_DATA(CListCtrlPairDlg)
	enum { IDD = 0 };
	//}}AFX_DATA

protected:
	CListCtrlPair *		m_plcp;

public:
	CListCtrlPair *		Plcp(void) const		{ return m_plcp; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListCtrlPairDlg)
	public:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	BOOL				m_bInitDone;

	BOOL				BInitDone(void) const	{ return m_bInitDone; }

	// Generated message map functions
	//{{AFX_MSG(CListCtrlPairDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CListCtrlPairDlg

/////////////////////////////////////////////////////////////////////////////

#endif // _LCPRDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\lcprwpag.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      LCPrWPag.cpp
//
//  Abstract:
//      Implementation of the CListCtrlPairWizPage dialog template class.
//
//  Author:
//      David Potter (davidp)   August 31, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "LCPrWPag.h"
#include "OLCPair.h"
#include "HelpData.h"   // for g_rghelpmap*

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CListCtrlPairWizPage
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CListCtrlPairWizPage, CBaseWizardPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CListCtrlPairWizPage, CBaseWizardPage)
    //{{AFX_MSG_MAP(CListCtrlPairWizPage)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::CListCtrlPairWizPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPairWizPage::CListCtrlPairWizPage(void)
{
    m_plpobjRight = NULL;
    m_plpobjLeft = NULL;
    m_dwStyle = 0;
    m_pfnGetColumn = NULL;

    m_plcp = NULL;

}  //*** CListCtrlPairWizPage::CListCtrlPairWizPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::CListCtrlPairWizPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      idd             [IN] Resource ID for the dialog template.
//      pdwHelpMap      [IN] Control-to-Help ID mapping array.
//      dwStyle         [IN] Style:
//                          LCPS_SHOW_IMAGES    Show images to left of items.
//                          LCPS_ALLOW_EMPTY    Allow right list to be empty.
//                          LCPS_ORDERED        Ordered right list.
//                          LCPS_CAN_BE_ORDERED List can be ordered (hides
//                              Up/Down puttons if LCPS_ORDERED not specified).
//      pfnGetColumn    [IN] Function pointer for getting column data.
//      pfnDisplayProps [IN] Function pointer for displaying properties.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPairWizPage::CListCtrlPairWizPage(
    IN UINT             idd,
    IN const DWORD *    pdwHelpMap,
    IN DWORD            dwStyle,
    IN PFNLCPGETCOLUMN  pfnGetColumn,
    IN PFNLCPDISPPROPS  pfnDisplayProps
    )
    : CBaseWizardPage(idd, pdwHelpMap)
{
    ASSERT(pfnGetColumn != NULL);
    ASSERT(pfnDisplayProps != NULL);

    m_plpobjRight = NULL;
    m_plpobjLeft = NULL;
    m_dwStyle = dwStyle;
    m_pfnGetColumn = pfnGetColumn;
    m_pfnDisplayProps = pfnDisplayProps;

    m_plcp = NULL;

    if (dwStyle & LCPS_ORDERED)
        ASSERT(m_dwStyle & LCPS_CAN_BE_ORDERED);

}  //*** CListCtrlPairWizPage::CListCtrlPairWizPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::~CListCtrlPairWizPage
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPairWizPage::~CListCtrlPairWizPage(void)
{
    delete m_plcp;

}  //*** CListCtrlPairWizPage::~CListCtrlPairWizPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::NAddColumn
//
//  Routine Description:
//      Add a column to the list of columns displayed in each list control.
//
//  Arguments:
//      idsText     [IN] String resource ID for text to display on column.
//      nWidth      [IN] Initial width of the column.
//
//  Return Value:
//      icol        Index of the column.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CArray::Add.
//--
/////////////////////////////////////////////////////////////////////////////
int CListCtrlPairWizPage::NAddColumn(IN IDS idsText, IN int nWidth)
{
    CListCtrlPair::CColumn  col;

    ASSERT(idsText != 0);
    ASSERT(nWidth > 0);
    ASSERT(Plcp() == NULL);

    col.m_idsText = idsText;
    col.m_nWidth = nWidth;

    return (int)m_aColumns.Add(col);

}  //*** CListCtrlPair::NAddColumn()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairWizPage::DoDataExchange(CDataExchange * pDX)
{
    CBaseWizardPage::DoDataExchange(pDX);
    Plcp()->DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CListCtrlPairDlg)
    //}}AFX_DATA_MAP

}  //*** CListCtrlPairWizPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPairWizPage::OnInitDialog( void )
{
    if ( BReadOnly() )
    {
        m_dwStyle |= LCPS_READ_ONLY;
    } // if: page is read only

    // Initialize the ListCtrlPair control.
    if ( BCanBeOrdered() )
    {
        m_plcp = new COrderedListCtrlPair(
                        this,
                        m_plpobjRight,
                        m_plpobjLeft,
                        m_dwStyle,
                        m_pfnGetColumn,
                        m_pfnDisplayProps
                        );
    } // if: list can be ordered
    else
    {
        m_plcp = new CListCtrlPair(
                        this,
                        m_plpobjRight,
                        m_plpobjLeft,
                        m_dwStyle,
                        m_pfnGetColumn,
                        m_pfnDisplayProps
                        );
    } // else: list cannot be ordered
    if ( m_plcp == NULL )
    {
        AfxThrowMemoryException();
    } // if: error allocating memory

    // Add columns if there are any.
    {
        int     icol;

        for ( icol = 0 ; icol <= m_aColumns.GetUpperBound() ; icol++ )
        {
            Plcp()->NAddColumn( m_aColumns[ icol ].m_idsText, m_aColumns[ icol ].m_nWidth );
        } // for: each column
    }  // Add columns if there are any

    CBaseWizardPage::OnInitDialog();
    Plcp()->OnInitDialog();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CListCtrlPairWizPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPairWizPage::OnSetActive(void)
{
    BOOL    bSuccess;

    bSuccess = CBaseWizardPage::OnSetActive();
    if (bSuccess)
        bSuccess = Plcp()->OnSetActive();

    return bSuccess;

}  //*** CListCtrlPairWizPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.  Attempts to pass them on to a selected
//      item first.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPairWizPage::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    BOOL    bHandled;

    ASSERT(Plcp() != NULL);

    bHandled = Plcp()->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    if (!bHandled)
        bHandled = CBaseWizardPage::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    return bHandled;

}  //*** CListCtrlPairWizPage::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairWizPage::OnContextMenu(CWnd * pWnd, CPoint point)
{
    ASSERT(Plcp() != NULL);

    if (!Plcp()->OnContextMenu(pWnd, point))
        CBaseWizardPage::OnContextMenu(pWnd, point);

}  //*** CListCtrlPairWizPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::SetLists
//
//  Routine Description:
//      Set the lists for the list control pair.
//
//  Arguments:
//      plpobjRight     [IN OUT] List for the right list box.
//      plpobjLeft      [IN] List for the left list box.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairWizPage::SetLists(
    IN OUT CClusterItemList *   plpobjRight,
    IN const CClusterItemList * plpobjLeft
    )
{
    if (plpobjRight != NULL)
        m_plpobjRight = plpobjRight;
    if (plpobjLeft != NULL)
        m_plpobjLeft = plpobjLeft;
    if (Plcp() != NULL)
        Plcp()->SetLists(plpobjRight, plpobjLeft);

}  //*** CListCtrlPairWizPage::SetLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairWizPage::SetLists
//
//  Routine Description:
//      Set the lists for the list control pair where the right list should
//      not be modified.
//
//  Arguments:
//      plpobjRight     [IN] List for the right list box.
//      plpobjLeft      [IN] List for the left list box.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairWizPage::SetLists(
    IN const CClusterItemList * plpobjRight,
    IN const CClusterItemList * plpobjLeft
    )
{
    if (plpobjRight != NULL)
        m_plpobjRight = (CClusterItemList *) plpobjRight;
    if (plpobjLeft != NULL)
        m_plpobjLeft = plpobjLeft;
    m_dwStyle |= LCPS_DONT_OUTPUT_RIGHT_LIST;
    if (Plcp() != NULL)
        Plcp()->SetLists(plpobjRight, plpobjLeft);

}  //*** CListCtrlPairWizPage::SetLists()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\lcprpage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      LCPrPage.cpp
//
//  Abstract:
//      Implementation of the CListCtrlPairPage dialog template class.
//
//  Author:
//      David Potter (davidp)   August 12, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "LCPrPage.h"
#include "OLCPair.h"
#include "HelpData.h"   // for g_rghelpmap*

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CListCtrlPairPage
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CListCtrlPairPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CListCtrlPairPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CListCtrlPairPage)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::CListCtrlPairPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPairPage::CListCtrlPairPage(void)
{
    CommonConstruct();

}  //*** CListCtrlPairPage::CListCtrlPairPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::CListCtrlPairPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      idd             [IN] Resource ID for the dialog template.
//      pdwHelpMap      [IN] Control-to-Help ID mapping array.
//      dwStyle         [IN] Style:
//                          LCPS_SHOW_IMAGES    Show images to left of items.
//                          LCPS_ALLOW_EMPTY    Allow right list to be empty.
//                          LCPS_ORDERED        Ordered right list.
//                          LCPS_CAN_BE_ORDERED List can be ordered (hides
//                              Up/Down puttons if LCPS_ORDERED not specified).
//      pfnGetColumn    [IN] Function pointer for getting column data.
//      pfnDisplayProps [IN] Function pointer for displaying properties.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPairPage::CListCtrlPairPage(
    IN UINT             idd,
    IN const DWORD *    pdwHelpMap,
    IN DWORD            dwStyle,
    IN PFNLCPGETCOLUMN  pfnGetColumn,
    IN PFNLCPDISPPROPS  pfnDisplayProps
    )
    : CBasePropertyPage(idd, pdwHelpMap)
{
    ASSERT(pfnGetColumn != NULL);
    ASSERT(pfnDisplayProps != NULL);

    CommonConstruct();

    m_dwStyle = dwStyle;
    m_pfnGetColumn = pfnGetColumn;
    m_pfnDisplayProps = pfnDisplayProps;

}  //*** CListCtrlPairPage::CListCtrlPairPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairPage::CommonConstruct(void)
{
    m_plpobjRight = NULL;
    m_plpobjLeft = NULL;
    m_dwStyle = 0;
    m_pfnGetColumn = NULL;

    m_plcp = NULL;

}  //*** CListCtrlPairPage::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::~CListCtrlPairPage
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListCtrlPairPage::~CListCtrlPairPage(void)
{
    delete m_plcp;

}  //*** CListCtrlPairPage::~CListCtrlPairPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::NAddColumn
//
//  Routine Description:
//      Add a column to the list of columns displayed in each list control.
//
//  Arguments:
//      idsText     [IN] String resource ID for text to display on column.
//      nWidth      [IN] Initial width of the column.
//
//  Return Value:
//      icol        Index of the column.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CArray::Add.
//--
/////////////////////////////////////////////////////////////////////////////
int CListCtrlPairPage::NAddColumn(IN IDS idsText, IN int nWidth)
{
    CListCtrlPair::CColumn  col;

    ASSERT(idsText != 0);
    ASSERT(nWidth > 0);
    ASSERT(Plcp() == NULL);

    col.m_idsText = idsText;
    col.m_nWidth = nWidth;

    return (int)m_aColumns.Add(col);

}  //*** CListCtrlPair::NAddColumn()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairPage::DoDataExchange(CDataExchange * pDX)
{
    CBasePropertyPage::DoDataExchange(pDX);
    Plcp()->DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CListCtrlPairDlg)
    //}}AFX_DATA_MAP

}  //*** CListCtrlPairPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPairPage::OnInitDialog( void )
{
    if ( BReadOnly() )
    {
        m_dwStyle |= LCPS_READ_ONLY;
    } // if: page is read only

    // Initialize the ListCtrlPair control.
    if ( BCanBeOrdered() )
    {
        m_plcp = new COrderedListCtrlPair(
                        this,
                        m_plpobjRight,
                        m_plpobjLeft,
                        m_dwStyle,
                        m_pfnGetColumn,
                        m_pfnDisplayProps
                        );
    } // if: list can be ordered
    else
    {
        m_plcp = new CListCtrlPair(
                        this,
                        m_plpobjRight,
                        m_plpobjLeft,
                        m_dwStyle,
                        m_pfnGetColumn,
                        m_pfnDisplayProps
                        );
    } // else: list cannot be ordered
    if ( m_plcp == NULL )
    {
        AfxThrowMemoryException();
    } // if: error allocating memory

    // Add columns if there are any.
    {
        int     icol;

        for ( icol = 0 ; icol <= m_aColumns.GetUpperBound() ; icol++ )
        {
            Plcp()->NAddColumn( m_aColumns[ icol ].m_idsText, m_aColumns[ icol ].m_nWidth );
        } // for: each column
    }  // Add columns if there are any

    CBasePropertyPage::OnInitDialog();
    Plcp()->OnInitDialog();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CListCtrlPairPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPairPage::OnSetActive(void)
{
    BOOL    bSuccess;

    bSuccess = CBasePropertyPage::OnSetActive();
    if (bSuccess)
        bSuccess = Plcp()->OnSetActive();

    return bSuccess;

}  //*** CListCtrlPairPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.  Attempts to pass them on to a selected
//      item first.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListCtrlPairPage::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    BOOL    bHandled;

    ASSERT(Plcp() != NULL);

    bHandled = Plcp()->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    if (!bHandled)
        bHandled = CBasePropertyPage::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    return bHandled;

}  //*** CListCtrlPairPage::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairPage::OnContextMenu(CWnd * pWnd, CPoint point)
{
    ASSERT(Plcp() != NULL);

    if (!Plcp()->OnContextMenu(pWnd, point))
        CBasePropertyPage::OnContextMenu(pWnd, point);

}  //*** CListCtrlPairPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::SetLists
//
//  Routine Description:
//      Set the lists for the list control pair.
//
//  Arguments:
//      plpobjRight     [IN OUT] List for the right list box.
//      plpobjLeft      [IN] List for the left list box.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairPage::SetLists(
    IN OUT CClusterItemList *   plpobjRight,
    IN const CClusterItemList * plpobjLeft
    )
{
    if (plpobjRight != NULL)
        m_plpobjRight = plpobjRight;
    if (plpobjLeft != NULL)
        m_plpobjLeft = plpobjLeft;
    if (Plcp() != NULL)
        Plcp()->SetLists(plpobjRight, plpobjLeft);

}  //*** CListCtrlPairPage::SetLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPairPage::SetLists
//
//  Routine Description:
//      Set the lists for the list control pair where the right list should
//      not be modified.
//
//  Arguments:
//      plpobjRight     [IN] List for the right list box.
//      plpobjLeft      [IN] List for the left list box.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListCtrlPairPage::SetLists(
    IN const CClusterItemList * plpobjRight,
    IN const CClusterItemList * plpobjLeft
    )
{
    if (plpobjRight != NULL)
        m_plpobjRight = (CClusterItemList *) plpobjRight;
    if (plpobjLeft != NULL)
        m_plpobjLeft = plpobjLeft;
    m_dwStyle |= LCPS_DONT_OUTPUT_RIGHT_LIST;
    if (Plcp() != NULL)
        Plcp()->SetLists(plpobjRight, plpobjLeft);

}  //*** CListCtrlPairPage::SetLists()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\lcprpage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		LCPrPage.h
//
//	Abstract:
//		Definition of the CListCtrlPairPage dialog class.
//
//	Implementation File:
//		LCPrPage.cpp
//
//	Author:
//		David Potter (davidp)	August 12, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _LCPRPAGE_H_
#define _LCPRPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePPag.h"	// for CBasePropertyPage
#endif

#ifndef _LCPAIR_H_
#include "LCPair.h"		// for PFNLCPGETCOLUMN, CListCtrlPair
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CListCtrlPairPage;

/////////////////////////////////////////////////////////////////////////////
// CListCtrlPairPage dialog
/////////////////////////////////////////////////////////////////////////////

class CListCtrlPairPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CListCtrlPairPage)

// Construction
public:
	CListCtrlPairPage(void);
	CListCtrlPairPage(
		IN UINT				idd,
		IN const DWORD *	pdwHelpMap,
		IN DWORD			dwStyle,
		IN PFNLCPGETCOLUMN	pfnGetColumn,
		IN PFNLCPDISPPROPS	pfnDisplayProps
		);
	~CListCtrlPairPage(void);

	void CommonConstruct();

// Attributes
protected:
	CClusterItemList *			m_plpobjRight;
	const CClusterItemList *	m_plpobjLeft;
	DWORD						m_dwStyle;
	PFNLCPGETCOLUMN				m_pfnGetColumn;
	PFNLCPDISPPROPS				m_pfnDisplayProps;

	BOOL						BIsStyleSet(IN DWORD dwStyle) const	{ return (m_dwStyle & dwStyle) == dwStyle; }

	CListCtrlPair::CColumnArray	m_aColumns;

public:
	BOOL				BOrdered(void) const		{ return BIsStyleSet(LCPS_ORDERED); }
	BOOL				BCanBeOrdered(void) const	{ return BIsStyleSet(LCPS_CAN_BE_ORDERED); }
	int					NAddColumn(IN IDS idsText, IN int nWidth);

	void				SetLists(IN OUT CClusterItemList * plpobjRight, IN const CClusterItemList * plpobjLeft);
	void				SetLists(IN const CClusterItemList * plpobjRight, IN const CClusterItemList * plpobjLeft);

// Dialog Data
	//{{AFX_DATA(CListCtrlPairPage)
	enum { IDD = 0 };
	//}}AFX_DATA

protected:
	CListCtrlPair *		m_plcp;

public:
	CListCtrlPair *		Plcp(void) const		{ return m_plcp; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListCtrlPairPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CListCtrlPairPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CListCtrlPairPage

/////////////////////////////////////////////////////////////////////////////

#endif // _LCPRPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\listitem.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ListItem.cpp
//
//	Abstract:
//		Implementation of the CListItem class.
//
//	Author:
//		David Potter (davidp)	May 6, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ListItem.h"
#include "ClusItem.h"
#include "ListItem.inl"
#include "TraceTag.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag g_tagListItem(_T("Document"), _T("LIST ITEM"), 0);
CTraceTag g_tagListItemCreate(_T("Create"), _T("LIST ITEM CREATE"), 0);
CTraceTag g_tagListItemDelete(_T("Delete"), _T("LIST ITEM DELETE"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CListItem
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CListItem, CCmdTarget)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CListItem, CCmdTarget)
	//{{AFX_MSG_MAP(CListItem)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::CListItem
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListItem::CListItem(void)
{
	m_ptiParent = NULL;
	m_pci = NULL;

}  //*** CListItem::CListItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::CListItem
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pci			[IN OUT] Cluster item represented by this item.
//		ptiParent	[IN OUT] Parent tree item to which this item belongs.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListItem::CListItem(IN OUT CClusterItem * pci, IN OUT CTreeItem * ptiParent)
{
	ASSERT_VALID(ptiParent);
	ASSERT_VALID(pci);

	m_ptiParent = ptiParent;
	m_pci = pci;

	Trace(g_tagListItemCreate, _T("CListItem() - Creating '%s', parent = '%s'"), pci->StrName(), (ptiParent ? ptiParent->Pci()->StrName() : _T("<None>")));

}  //*** CListItem::CListItem(pci)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::~CListItem
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListItem::~CListItem(void)
{
	Trace(g_tagListItemDelete, _T("~CListItem() - Deleting list item '%s', parent = '%s'"), (Pci() != NULL ? Pci()->StrName() : _T("<Unknown>")), (PtiParent()->Pci() != NULL ? PtiParent()->Pci()->StrName() : _T("<Unknown>")));

	// Remove ourselves from all views.
	RemoveFromAllLists();

}  //*** CListItem::~CListItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::Ili
//
//	Routine Description:
//		Returns the index of the item in the specified list view.
//
//	Arguments:
//		pclv		[IN OUT] List view in which to search for the item.
//
//	Return Value:
//		ili			Index of the item, or -1 if it was not found.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CListItem::Ili(CClusterListView * pclv) const
{
	LV_FINDINFO		lvfi;
	int				ili;

	lvfi.flags = LVFI_PARAM;
	lvfi.lParam = (LPARAM) this;

	ili = pclv->GetListCtrl().FindItem(&lvfi);
	Trace(g_tagListItem, _T("Item index = %d"), ili);
	return ili;

}  //*** CListItem::Ili()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::IliInsertInList
//
//	Routine Description:
//		Insert the item in a list.
//
//	Arguments:
//		pclv		[IN OUT] Cluster list view item is being added to.
//
//	Return Value:
//		ili			Index of the new item in the list, or -1 if unsuccessful.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CListItem::IliInsertInList(IN OUT CClusterListView * pclv)
{
	POSITION		posColi;
	CColumnItem *	pcoli;
	CString			strColumnData;
	int				ili;
	int				iliReturn;

	ASSERT_VALID(Pci());
	ASSERT(Ili(pclv) == -1);	// Make sure we aren't in that list yet.

	// Determine the index of this item.
	ili = Plc(pclv)->GetItemCount();

	// Save a pointer to the list view to which we are being added.
	if (LpclvViews().Find(pclv) == NULL)
		LpclvViews().AddTail(pclv);

	// Get the first column's data.
	VERIFY((posColi = Lpcoli().GetHeadPosition()) != NULL);
	VERIFY((pcoli = Lpcoli().GetNext(posColi)) != NULL);
	Pci()->BGetColumnData(pcoli->Colid(), strColumnData);

	// Insert the item into the list and add the first column.
	// The rest of the columns get added by the call to UpdateState().
	VERIFY((iliReturn
				= Plc(pclv)->InsertItem(
						LVIF_TEXT | LVIF_PARAM,		// nMask
						ili,						// nItem
						strColumnData,				// lpszItem
						0,							// nState
						0,							// nStateMask
						0,							// nImage
						(LPARAM) this				// lParam
						)) != -1);

	// Add ourselves to the cluster item's list.
	Pci()->AddListItem(this);

	UpdateState();
	return iliReturn;

}  //*** CListItem::IliInsertInList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::RemoveFromAllLists
//
//	Routine Description:
//		Remove the item from all lists.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListItem::RemoveFromAllLists(void)
{
	ASSERT_VALID(Pci());

	// Loop through each view and remove the item from the list.
	{
		int					ili;
		POSITION			posView;
		POSITION			posViewPrev;
		CClusterListView *	pclv;

		posView = LpclvViews().GetHeadPosition();
		while (posView != NULL)
		{
			// Get the next list view list entry.
			posViewPrev = posView;
			pclv = LpclvViews().GetNext(posView);
			ASSERT_VALID(pclv);

			ili = Ili(pclv);
			ASSERT(ili != -1);

			// Delete the item.
			VERIFY(pclv->GetListCtrl().DeleteItem(ili));
			LpclvViews().RemoveAt(posViewPrev);
		}  // while:  more lists
	}  // Loop through each view and remove the item from the list

	// Remove ourselves from the cluster item's list.
	Pci()->RemoveListItem(this);

	// Remove ourselves from the tree's list.
//	PtiParent()->RemoveChild(Pci());

}  //*** CListItem::RemoveFromAllLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::PreRemoveFromList
//
//	Routine Description:
//		Prepare to remove the item from a list.
//
//	Arguments:
//		pclv		[IN OUT] Cluster list view item is being removed from.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListItem::PreRemoveFromList(IN OUT CClusterListView * pclv)
{
	POSITION	posView;

	ASSERT_VALID(pclv);
	ASSERT_VALID(Pci());

	// Find the view in our list.
	VERIFY((posView = LpclvViews().Find(pclv)) != NULL);

	// Remove ourselves from the cluster item's list if this is the last view.
//	if (LpclvViews().GetCount() == 1)
//	{
//		Pci()->RemoveListItem(this);
//	}  // if:  this is the last view

	// Remove the view from the list.
	LpclvViews().RemoveAt(posView);

}  //*** CListItem::PreRemoveFromList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::UpdateState
//
//	Routine Description:
//		Update the current state of the item.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListItem::UpdateState(void)
{
	ASSERT_VALID(Pci());

	// Ask the item to update its state.
	Pci()->UpdateState();

}  //*** CListItem::UpdateState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::UpdateUIState
//
//	Routine Description:
//		Update the current UI state of the item.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListItem::UpdateUIState(void)
{
	BOOL				bSuccess;
	POSITION			posView;
	POSITION			posColi;
	CColumnItem *		pcoli;
	int					icoli;
	int					ili;
	CString				strColumnData;
	UINT				nImage;
	UINT				nMask;
	CClusterListView *	pclv;
	CListCtrl *			plc;

	ASSERT_VALID(Pci());
//	ASSERT(LpclvViews().GetCount() > 0);

	// Loop through the views and update the state on each one.
	posView = LpclvViews().GetHeadPosition();
	while (posView != NULL)
	{
		// Get the pointers to the view and the list control.
		VERIFY((pclv = LpclvViews().GetNext(posView)) != NULL);
		ASSERT_KINDOF(CClusterListView, pclv);
		plc = Plc(pclv);

		// Get the item index.
		VERIFY((ili = Ili(pclv)) != -1);

		// Set the column data.
		VERIFY((posColi = Lpcoli().GetHeadPosition()) != NULL);
		for (icoli = 0 ; posColi != NULL ; icoli++)
		{
			VERIFY((pcoli = Lpcoli().GetNext(posColi)) != NULL);
			ASSERT_KINDOF(CColumnItem, pcoli);

			bSuccess = Pci()->BGetColumnData(pcoli->Colid(), strColumnData);
			if (!bSuccess)
			{
				Trace(g_tagListItem, _T("IliInsertInList: Column #%d (ID %d) not available for %s '%s'"), icoli, pcoli->Colid(), Pci()->StrType(), Pci()->StrName());
			}  // if:  column data not available
			if (icoli == 0)
			{
				nMask = LVIF_TEXT | LVIF_IMAGE;
				nImage = Pci()->IimgState();
			}  // if:  first column
			else
			{
				nMask = LVIF_TEXT;
				nImage = (UINT) -1;
			}  // else:  not first column
			VERIFY(plc->SetItem(
							ili,			// nItem
							icoli,			// nSubItem
							nMask,			// nMask
							strColumnData,	// lpszItem
							nImage,			// nImage
							0,				// nState
							0,				// nStateMask
							0				// lParam
							));
		}  // for:  each column item in the list
	}  // while:  more views

}  //*** CListItem::UpdateUIState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::OnCmdMsg
//
//	Routine Description:
//		Processes command messages.  Attempts to pass them on to a selected
//		item first.
//
//	Arguments:
//		nID				[IN] Command ID.
//		nCode			[IN] Notification code.
//		pExtra			[IN OUT] Used according to the value of nCode.
//		pHandlerInfo	[OUT] ???
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CListItem::OnCmdMsg(
	UINT					nID,
	int						nCode,
	void *					pExtra,
	AFX_CMDHANDLERINFO *	pHandlerInfo
	)
{
	ASSERT_VALID(Pci());

	// Give the cluster item a chance to handle the message.
	if (Pci()->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
		return TRUE;

	return CCmdTarget::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

}  //*** CListItem::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CListItem::EditLabel
//
//	Routine Description:
//		Processes the ID_FILE_RENAME menu command.
//
//	Arguments:
//		pclv		[IN OUT] Cluster list view item is being edited in.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CListItem::EditLabel(IN OUT CClusterListView * pclv)
{
	ASSERT_VALID(pclv);
	ASSERT_VALID(Pci());

	ASSERT(Pci()->BCanBeEdited());
	pclv->GetListCtrl().EditLabel(Ili(pclv));

}  //*** CListItem::EditLabel()


//***************************************************************************


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DeleteAllItemData
//
//	Routine Description:
//		Deletes all item data in a CList.
//
//	Arguments:
//		rlp		[IN OUT] List whose data is to be deleted.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DeleteAllItemData(IN OUT CListItemList & rlp)
{
	POSITION	pos;
	CListItem *	pli;

	// Delete all the items in the list.
	pos = rlp.GetHeadPosition();
	while (pos != NULL)
	{
		pli = rlp.GetNext(pos);
		ASSERT_VALID(pli);
//		Trace(g_tagListItemDelete, _T("DeleteAllItemData(rlpli) - Deleting list item '%s'"), pli->Pci()->StrName());
		delete pli;
	}  // while:  more items in the list

}  //*** DeleteAllItemData()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\listitem.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ListItem.inl
//
//	Abstract:
//		Inline function implementations for the CListItem class.
//
//	Author:
//		David Potter (davidp)	May 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _LISTITEM_INL_
#define _LISTITEM_INL_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _LISTITEM_H_
#include "ListItem.h"	// for CListItem
#endif

#ifndef _CLUSITEM_H_
#include "ClusItem.h"	// for CClusterItem
#endif

#ifndef _TREEITEM_H_
#include "TreeItem.h"
#endif

#ifndef _LISTVIEW_H_
#include "ListView.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline Function Definitions
/////////////////////////////////////////////////////////////////////////////

inline CMenu * CListItem::PmenuPopup(void)
{
	ASSERT(Pci() != NULL);
	return Pci()->PmenuPopup();

}  //*** CListItem::PmenuPopup()

inline const CColumnItemList & CListItem::Lpcoli(void) const
{
	ASSERT(PtiParent() != NULL);
	return PtiParent()->Lpcoli();

}  //*** CListItem::Lpcoli()

inline CListCtrl * CListItem::Plc(CClusterListView * pclv) const
{
	ASSERT(pclv != NULL);
	return &pclv->GetListCtrl();

}  //*** CListItem::Plc(pclv)

inline const CString & CListItem::StrName(void) const
{
	ASSERT(Pci() != NULL);
	return Pci()->StrName();

}  //*** CListItem::StrName()

/////////////////////////////////////////////////////////////////////////////

#endif // _LISTITEM_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\lcprwpag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		LCPrWPag.h
//
//	Abstract:
//		Definition of the CListCtrlPairWizPage dialog class.
//
//	Implementation File:
//		LCPrWPag.cpp
//
//	Author:
//		David Potter (davidp)	August 31, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _LCPRWPAG_H_
#define _LCPRWPAG_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BaseWPag.h"	// for CBaseWizardPage
#endif

#ifndef _LCPAIR_H_
#include "LCPair.h"		// for PFNLCPGETCOLUMN, CListCtrlPair
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CListCtrlPairWizPage;

/////////////////////////////////////////////////////////////////////////////
// CListCtrlPairWizPage dialog
/////////////////////////////////////////////////////////////////////////////

class CListCtrlPairWizPage : public CBaseWizardPage
{
	DECLARE_DYNCREATE(CListCtrlPairWizPage)

// Construction
public:
	CListCtrlPairWizPage(void);
	CListCtrlPairWizPage(
		IN UINT				idd,
		IN const DWORD *	pdwHelpMap,
		IN DWORD			dwStyle,
		IN PFNLCPGETCOLUMN	pfnGetColumn,
		IN PFNLCPDISPPROPS	pfnDisplayProps
		);
	~CListCtrlPairWizPage(void);

// Attributes
protected:
	CClusterItemList *			m_plpobjRight;
	const CClusterItemList *	m_plpobjLeft;
	DWORD						m_dwStyle;
	PFNLCPGETCOLUMN				m_pfnGetColumn;
	PFNLCPDISPPROPS				m_pfnDisplayProps;

	BOOL						BIsStyleSet(IN DWORD dwStyle) const	{ return (m_dwStyle & dwStyle) == dwStyle; }

	CListCtrlPair::CColumnArray	m_aColumns;

public:
	BOOL				BOrdered(void) const		{ return BIsStyleSet(LCPS_ORDERED); }
	BOOL				BCanBeOrdered(void) const	{ return BIsStyleSet(LCPS_CAN_BE_ORDERED); }
	int					NAddColumn(IN IDS idsText, IN int nWidth);

	void				SetLists(IN OUT CClusterItemList * plpobjRight, IN const CClusterItemList * plpobjLeft);
	void				SetLists(IN const CClusterItemList * plpobjRight, IN const CClusterItemList * plpobjLeft);

// Dialog Data
	//{{AFX_DATA(CListCtrlPairWizPage)
	enum { IDD = 0 };
	//}}AFX_DATA

protected:
	CListCtrlPair *		m_plcp;

public:
	CListCtrlPair *		Plcp(void) const		{ return m_plcp; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListCtrlPairWizPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CListCtrlPairWizPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CListCtrlPairWizPage

/////////////////////////////////////////////////////////////////////////////

#endif // _LCPRWPAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\listitem.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ListItem.h
//
//	Abstract:
//		Definition of the CListItem class.
//
//	Author:
//		David Potter (davidp)	May 6, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _LISTITEM_H_
#define _LISTITEM_H_

#ifndef __AFXTEMPL_H__
#include "afxtempl.h"	// for CList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CListItem;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef CList<CListItem *, CListItem *> CListItemList;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _COLITEM_H_
#include "ColItem.h"	// for CColumnItemList;
#endif

#ifndef _LISTVIEW_H_
#include "ListView.h"	// for CClusterListViewList
#endif

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterItem;

/////////////////////////////////////////////////////////////////////////////
// CListItem command target

class CListItem : public CCmdTarget
{
	friend class CClusterListView;

	DECLARE_DYNCREATE(CListItem)

	CListItem(void);		// protected constructor used by dynamic creation
	CListItem(IN OUT CClusterItem * pci, IN OUT CTreeItem * pti);

// Attributes
protected:
	CTreeItem *				m_ptiParent;
	CClusterItem *			m_pci;
	CClusterListViewList	m_lpclvViews;

	CClusterListViewList &	LpclvViews(void)		{ return m_lpclvViews; }
	const CColumnItemList &	Lpcoli(void) const;

public:
	CTreeItem *				PtiParent(void) const	{ return m_ptiParent; }
	CClusterItem *			Pci(void) const			{ return m_pci; }

	int						Ili(CClusterListView * pclv) const;
	CListCtrl *				Plc(CClusterListView * pclv) const;

	const CString &			StrName(void) const;

// Operations
public:
	int						IliInsertInList(IN OUT CClusterListView * pclv);
	void					RemoveFromAllLists(void);
	void					PreRemoveFromList(IN OUT CClusterListView * pclv);
	virtual void			UpdateState(void);
	void					UpdateUIState(void);

	CMenu *					PmenuPopup(void);
	void					EditLabel(IN OUT CClusterListView * pclv);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListItem)
	public:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CListItem(void);

protected:
	// Generated message map functions
	//{{AFX_MSG(CListItem)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

};  //*** class CListItem

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

void DeleteAllItemData(IN OUT CListItemList & rlp);

/////////////////////////////////////////////////////////////////////////////

#endif // _LISTITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\listview.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ListView.cpp
//
//  Abstract:
//      Implementation of the CListView class.
//
//  Author:
//      David Potter (davidp)   May 6, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "ClusDoc.h"
#include "ClusItem.h"
#include "ListView.h"
#include "ListItem.h"
#include "ListItem.inl"
#include "SplitFrm.h"
#include "TreeItem.h"
#include "TreeView.h"
#include "ClusDoc.h"
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagListView(_T("UI"), _T("LIST VIEW"), 0);
CTraceTag   g_tagListDrag(_T("Drag&Drop"), _T("LIST VIEW DRAG"), 0);
CTraceTag   g_tagListDragMouse(_T("Drag&Drop"), _T("LIST VIEW DRAG MOUSE"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterListView
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CClusterListView, CListView)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CClusterListView, CListView)
    //{{AFX_MSG_MAP(CClusterListView)
    ON_WM_DESTROY()
    ON_NOTIFY_REFLECT(LVN_ITEMCHANGED, OnItemChanged)
    ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnClick)
    ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblClk)
    ON_COMMAND(ID_OPEN_ITEM, OpenItem)
    ON_NOTIFY_REFLECT(LVN_BEGINLABELEDIT, OnBeginLabelEdit)
    ON_NOTIFY_REFLECT(LVN_ENDLABELEDIT, OnEndLabelEdit)
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
    ON_COMMAND(ID_FILE_PROPERTIES, OnCmdProperties)
    ON_COMMAND(ID_FILE_RENAME, OnCmdRename)
    ON_NOTIFY_REFLECT(LVN_BEGINDRAG, OnBeginDrag)
    ON_NOTIFY_REFLECT(LVN_BEGINRDRAG, OnBeginDrag)
    ON_NOTIFY_REFLECT(LVN_KEYDOWN, OnKeyDown)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::CClusterListView
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterListView::CClusterListView(void)
{
    m_ptiParent = NULL;
    m_nColumns = 0;
    m_nSortDirection = -1;
    m_pcoliSort = NULL;

    m_pframe = NULL;

    // Initialize label editing.
    m_pliBeingEdited = NULL;
    m_bShiftPressed = FALSE;
    m_bControlPressed = FALSE;
    m_bAltPressed = FALSE;

    // Initialize drag & drop.
    m_iliDrag = -1;
    m_pliDrag = NULL;
    m_iliDrop = -1;

}  //*** CClusterListView::CClusterListView()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::~CClusterListView
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterListView::~CClusterListView(void)
{
    if (m_ptiParent != NULL)
        m_ptiParent->Release();

}  //*** CClusterListView::~CClusterListView()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::Create
//
//  Routine Description:
//      Create the window.
//
//  Arguments:
//      lpszClassName   [IN] Name of the window class to create.
//      lpszWindowName  [IN] Name of the window (used as the caption).
//      dwStyle         [IN] Window styles.
//      rect            [IN] Size and position of the window
//      pParentWnd      [IN OUT ] Parent window.
//      nID             [IN] ID of the window.
//      pContext        [IN OUT] Create context of the window.
//
//  Return Value:
//      0               Successful.
//      !0              Unsuccessful.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterListView::Create(
    LPCTSTR             lpszClassName,
    LPCTSTR             lpszWindowName,
    DWORD               dwStyle,
    const RECT &        rect,
    CWnd *              pParentWnd,
    UINT                nID,
    CCreateContext *    pContext
    )
{
    BOOL                bSuccess;

    // Set default style bits.
    dwStyle |=
        LVS_SHAREIMAGELISTS
        | LVS_EDITLABELS
        | LVS_SINGLESEL
        | LVS_SHOWSELALWAYS
        | LVS_ICON
        | LVS_REPORT
        ;

    bSuccess = CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
    if (bSuccess)
    {
        GetListCtrl().SetImageList(GetClusterAdminApp()->PilLargeImages(), LVSIL_NORMAL);
        GetListCtrl().SetImageList(GetClusterAdminApp()->PilSmallImages(), LVSIL_SMALL);
//      GetListCtrl().SetImageList(GetClusterAdminApp()->PilSmallImages(), LVSIL_STATE);

        // Change list view control extended styles.
        {
            DWORD   dwExtendedStyle;

            dwExtendedStyle = (DWORD)GetListCtrl().SendMessage(LVM_GETEXTENDEDLISTVIEWSTYLE);
            GetListCtrl().SendMessage(
                LVM_SETEXTENDEDLISTVIEWSTYLE,
                0,
                dwExtendedStyle
                    | LVS_EX_FULLROWSELECT
                    | LVS_EX_HEADERDRAGDROP
                );
        }  // Change list view control extended styles

    }  // if:  window created successfully

    return bSuccess;

}  //*** CClusterListView::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnInitialUpdate
//
//  Routine Description:
//      Do one-time initialization.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnInitialUpdate()
{
    CListView::OnInitialUpdate();

    // Save the frame pointer.
//  ASSERT(m_pframe == NULL);
    m_pframe = (CSplitterFrame *) GetParentFrame();
    ASSERT_VALID(m_pframe);
    ASSERT_KINDOF(CSplitterFrame, m_pframe);

}  //*** CClusterListView::OnInitialUpdate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::Refresh
//
//  Routine Description:
//      Refresh the view by reloading all the data.
//
//  Arguments:
//      ptiSelected [IN OUT] Pointer to currently selected item in the tree control.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::Refresh(IN OUT CTreeItem * ptiSelected)
{
    // Save columns.
    if (PtiParent() != NULL)
        SaveColumns();

    // Clean up the control to start with.
    DeleteAllItems();

    // Cleanup the previous parent tree item.
    if (m_ptiParent != NULL)
        m_ptiParent->Release();
    m_ptiParent = ptiSelected;

    // Setup the new selection.
    if (m_ptiParent != NULL)
    {
        ASSERT_VALID(ptiSelected);

        CListCtrl &             rListCtrl   = GetListCtrl();
        const CListItemList &   rlpli       = ptiSelected->LpliChildren();

        m_ptiParent->AddRef();

        // Add columns to the list control.
        AddColumns();

        // Add items from the tree item's list to the list view.
        {
            POSITION        pos;
            CListItem *     pli;

            // Tell the list control how many items we will be adding.
            // This improves performance.
            rListCtrl.SetItemCount((int)rlpli.GetCount());

            // Add the items to the list control.
            pos = rlpli.GetHeadPosition();
            while (pos != NULL)
            {
                pli = rlpli.GetNext(pos);
                ASSERT_VALID(pli);
                pli->IliInsertInList(this);
            }  // while:  more items in the list
        }  // Add items from the tree item's list to the list view

        // Give the focus to the first item in the list.
        if (rListCtrl.GetItemCount() != 0)
            rListCtrl.SetItem(0, 0, LVIF_STATE, NULL, 0, LVIS_FOCUSED, LVIS_FOCUSED, NULL);
    }  // if:  non-null selection

    // Set the sort column and direction.
    m_nSortDirection = -1;
    m_pcoliSort = NULL;

}  //*** CClusterListView::Refresh()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::DeleteAllItems
//
//  Routine Description:
//      Delete all the list and column items.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        All items deleted successfully.
//      FALSE       Not all items were deleted successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterListView::DeleteAllItems(void)
{
    BOOL    bDeletedAllItems;
    BOOL    bDeletedAllColumns  = TRUE;
    int     icol;

    // Remove all the items from our list.
    {
        CListItem * pli;
        int         ili;
        int         cli = GetListCtrl().GetItemCount();

        // Get the index of the first item.
        for (ili = 0 ; ili < cli; ili++)
        {
            pli = (CListItem *) GetListCtrl().GetItemData(ili);
            ASSERT_VALID(pli);
            pli->PreRemoveFromList(this);
        }  // for:  each item in the list

    }  // Remove all the items from the cluster item back pointer list

    // Delete the columns.
    {
        for (icol = m_nColumns - 1 ; icol >= 0 ; icol--)
        {
            // Delete the column from the view.
            if (!GetListCtrl().DeleteColumn(icol))
                bDeletedAllColumns = FALSE;
        }  // for:  each column
        m_nColumns = 0;
    }  // Delete the columns

    // Remove all the items from the list.
    bDeletedAllItems = GetListCtrl().DeleteAllItems();

    return (bDeletedAllItems && bDeletedAllColumns);

}  //*** CClusterListView::DeleteAllItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::SaveColumns
//
//  Routine Description:
//      Save the columns being displayed in the list view.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::SaveColumns(void)
{
    int         icol;
    DWORD *     prgnColumnInfo;
    CListCtrl & rplc = GetListCtrl();

    ASSERT_VALID(PtiParent());

    // We can only save column information if we are in report view.
    if (GetView() & LVS_REPORT)
    {
        try
        {
            // Get the column info array for this view.
            prgnColumnInfo = PtiParent()->PrgnColumnInfo(this);

            // Save the widths of the columns.
            for (icol = m_nColumns - 1 ; icol >= 0 ; icol--)
                prgnColumnInfo[icol + 1] = rplc.GetColumnWidth(icol);

            // Save the position information in the array.
            rplc.SendMessage(LVM_GETCOLUMNORDERARRAY, m_nColumns, (LPARAM) &prgnColumnInfo[m_nColumns + 1]);
        }  // try
        catch (CException * pe)
        {
            pe->Delete();
        }  // catch:  CException
    }  // if:  we are in detail view

}  //*** CClusterListView::SaveColumns()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::AddColumns
//
//  Routine Description:
//      Add columns to the list view.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::AddColumns(void)
{
    POSITION        pos;
    int             cColumns;
    int             icoli = 0;
    CColumnItem *   pcoli;
    DWORD *         prgnColumnInfo;
    CListCtrl &     rplc = GetListCtrl();

    ASSERT_VALID(PtiParent());

    try
    {
        // Get the column info.
        cColumns = (int)PtiParent()->Lpcoli().GetCount();
        prgnColumnInfo = PtiParent()->PrgnColumnInfo(this);

        pos = PtiParent()->Lpcoli().GetHeadPosition();
        for (icoli = 0 ; pos != NULL ; icoli++)
        {
            // Get the next column item.
            pcoli = PtiParent()->Lpcoli().GetNext(pos);
            ASSERT(pcoli != NULL);

            // Insert the column item in the list.
            rplc.InsertColumn(
                    icoli,                      // nCol
                    pcoli->StrText(),           // lpszColumnHeading
                    LVCFMT_LEFT,                // nFormat
                    prgnColumnInfo[icoli + 1],  // nWidth
                    icoli                       // nSubItem
                    );
        }  // while:  more items in the list

        // Set column positions.
        rplc.SendMessage(LVM_SETCOLUMNORDERARRAY, cColumns, (LPARAM) &prgnColumnInfo[cColumns + 1]);
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    m_nColumns = icoli;

}  //*** CClusterListView::AddColumns()

/////////////////////////////////////////////////////////////////////////////
// CClusterListView diagnostics
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
void CClusterListView::AssertValid(void) const
{
    CListView::AssertValid();

}  //*** CClusterListView::AssertValid()

void CClusterListView::Dump(CDumpContext& dc) const
{
    CListView::Dump(dc);

}  //*** CClusterListView::Dump()

CClusterDoc * CClusterListView::GetDocument(void) // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CClusterDoc)));
    return (CClusterDoc *) m_pDocument;

}  //*** CClusterListView::GetDocument()
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::PliFocused
//
//  Routine Description:
//      Get the list item that has the focus.
//
//  Arguments:
//      None.
//
//  Return Value:
//      pliSelected     The item with the focus or NULL if no item has focus.
//
//--
/////////////////////////////////////////////////////////////////////////////
CListItem * CClusterListView::PliFocused(void) const
{
    int         iliFocused;
    CListItem * pliFocused;

    iliFocused = IliFocused();
    if (iliFocused != -1)
    {
        pliFocused = (CListItem *) GetListCtrl().GetItemData(iliFocused);
        ASSERT_VALID(pliFocused);
    }  // if:  found an item with the focus
    else
        pliFocused = NULL;

    return pliFocused;

}  //*** CClusterListView::PliFocused()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.  Attempts to pass them on to a selected
//      item first.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterListView::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    int         ili;
    CListItem * pli;
    BOOL        bHandled    = FALSE;

    // If there is a current item selected, give it a chance
    // to handle the message.
    ili = GetListCtrl().GetNextItem(-1, LVNI_FOCUSED);
    if (ili != -1)
    {
        pli = (CListItem *) GetListCtrl().GetItemData(ili);
        ASSERT_VALID(pli);
        bHandled = pli->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
    }  // if:  an item is selected

    if (!bHandled)
        bHandled = CListView::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

    return bHandled;

}  //*** CClusterListView::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::PmenuPopup
//
//  Routine Description:
//      Returns a popup menu.
//
//  Arguments:
//      rpointScreen    [IN OUT] Position of the cursor, in screen coordinates.
//      rpci            [OUT] Pointer in which to return associated cluster item.
//
//  Return Value:
//      pmenu       A popup menu for the item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CMenu * CClusterListView::PmenuPopup(
    IN OUT CPoint &     rpointScreen,
    OUT CClusterItem *& rpci
    )
{
    CListItem * pli     = NULL;
    CMenu *     pmenu   = NULL;

    rpci = NULL;

    // If there are no coordinates (-1,-1), display a menu for the selected item.
    if ((rpointScreen.x == -1) && (rpointScreen.y == -1))
    {
        CListItem * pliFocused  = PliFocused();
        CRect       rect;

        if ((pliFocused != NULL)
                && GetListCtrl().GetItemRect(IliFocused(), &rect, LVIR_BOUNDS))
        {
            pli = pliFocused;
        }  // if:  item with focus and it is visible
        else
            GetWindowRect(&rect);
        rpointScreen.x = (rect.right - rect.left) / 2;
        rpointScreen.y = (rect.bottom - rect.top) / 2;
        ClientToScreen(&rpointScreen);
    }  // if:  no coordinates
    else
    {
        CPoint      pointClient;
        int         ili;
        UINT        uiFlags;

        // Get the coordinates of the point where the user clicked the right mouse
        // button.  We need in both screen and client coordinates.
        pointClient = rpointScreen;
        ScreenToClient(&pointClient);

        // Get the item under the cursor and get its popup menu.
        ili = GetListCtrl().HitTest(pointClient, &uiFlags);
        if ((ili != -1) && ((uiFlags | LVHT_ONITEM) != 0))
        {
            // Get the list item for the item under the cursor.
            pli = (CListItem *) GetListCtrl().GetItemData(ili);
            ASSERT_VALID(pli);
        }  // if:  on an item
    }  // else:  coordinates specified

    if (pli != NULL)
    {
        // Get a menu from the item.
        pmenu = pli->PmenuPopup();
        rpci = pli->Pci();
    }  // if:  item found

    return pmenu;

}  //*** CClusterListView::PmenuPopup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnUpdateProperties
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_PROPERTIES
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnUpdateProperties(CCmdUI * pCmdUI)
{
    CListItem * pliFocused = PliFocused();

    // If there is an item with the focus, pass this message on to it.
    if (pliFocused != NULL)
    {
        ASSERT_VALID(pliFocused->Pci());
        pliFocused->Pci()->OnUpdateProperties(pCmdUI);
    }  // if:  there is an item with the focus

}  //*** CClusterListView::OnUpdateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnCmdProperties
//
//  Routine Description:
//      Processes the ID_FILE_PROPERTIES menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnCmdProperties(void)
{
    CListItem * pliFocused = PliFocused();

    // If there is an item with the focus, pass this message on to it.
    if (pliFocused != NULL)
    {
        ASSERT_VALID(pliFocused->Pci());
        pliFocused->Pci()->OnCmdProperties();
    }  // if:  there is an item with the focus

}  //*** CClusterListView::OnCmdProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnItemChanged
//
//  Routine Description:
//      Handler method for the LVN_ITEMCHANGED message.
//
//  Arguments:
//      pNMHDR      [IN OUT] WM_NOTIFY structure.
//      pResult     [OUT] LRESULT in which to return the result of this operation.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnItemChanged(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW *   pNMListView = (NM_LISTVIEW *) pNMHDR;
    CWnd *          pwndFocus   = GetFocus();
    CListItem *     pli;

    if (m_pDocument != NULL)  // this happens on system shutdown
    {
        // If the item has just lost or received the focus, save it and set the menu.
        if ((pNMListView->uChanged & LVIF_STATE)
                && (pwndFocus == &GetListCtrl()))
        {
            ASSERT(pNMListView->iItem != -1);

            // Get the item whose state is changing.
            pli = (CListItem *) pNMListView->lParam;
            ASSERT_VALID(pli);

            if ((pNMListView->uOldState & LVIS_FOCUSED)
                    && !(pNMListView->uNewState & LVIS_FOCUSED))
            {
                Trace(g_tagListView, _T("OnItemChanged() - '%s' lost focus"), pli->Pci()->StrName());

                // Tell the document of the new selection.
                GetDocument()->OnSelChanged(NULL);
            }  // if:  old item losing focus
            else if (!(pNMListView->uOldState & LVIS_FOCUSED)
                        && (pNMListView->uNewState & LVIS_FOCUSED))
            {
                Trace(g_tagListView, _T("OnItemChanged() - '%s' received focus"), pli->Pci()->StrName());

                // Tell the document of the new selection.
                GetDocument()->OnSelChanged(pli->Pci());
            }  // else:  new item receiving focus
        }  // if:  item received the focus
    }  // if:  document is available

    *pResult = 0;

}  //*** CClusterListView::OnItemChanged()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnActivateView
//
//  Routine Description:
//      Called when the view is activated.
//
//  Arguments:
//      bActivate       [IN] Indicates whether the view being activated or deactivated.
//      pActivateView   [IN OUT] Points to the view object that is being activated.
//      peactiveView    [IN OUT] Points to the view object that is being deactivated.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnActivateView(
    BOOL        bActivate,
    CView *     pActivateView,
    CView *     pDeactiveView
    )
{
    CListItem * pliFocused  = PliFocused();

    if (m_pDocument != NULL)  // this happens on system shutdown
    {
        if (bActivate && (pliFocused != NULL))
        {
            ASSERT_VALID(pliFocused->Pci());
            Trace(g_tagListView, _T("OnActivateView() - '%s' received focus"), pliFocused->Pci()->StrName());

            // Tell the document of the new selection.
            GetDocument()->OnSelChanged(pliFocused->Pci());
        }  // if:  we are being activated
    }  // if:  document is available

    CListView::OnActivateView(bActivate, pActivateView, pDeactiveView);

}  //*** CClusterListView::OnActivateView()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnDestroy
//
//  Routine Description:
//      Handler method for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnDestroy(void)
{
    // Save the columns.
    if (PtiParent() != NULL)
        SaveColumns();

    // Clean up the control.
    DeleteAllItems();

    CListView::OnDestroy();

}  //*** CClusterListView::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnColumnClick
//
//  Routine Description:
//      Handler method for the LVN_COLUMNCLICK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnColumnClick(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW *   pNMListView = (NM_LISTVIEW *) pNMHDR;
    int             ili;
    CListItem *     pli;
    POSITION        pos;
    CColumnItem *   pcoli;

    if (GetListCtrl().GetItemCount() != 0)
    {
        // Get the first item in the list.
        ili = GetListCtrl().GetNextItem(-1, LVNI_ALL);
        ASSERT(ili != -1);
        pli = (CListItem *) GetListCtrl().GetItemData(ili);
        ASSERT_VALID(pli);
        ASSERT_VALID(pli->PtiParent());

        // Get the column item to sort by.
        pos = pli->PtiParent()->Lpcoli().FindIndex(pNMListView->iSubItem);
        ASSERT(pos != NULL);
        pcoli = pli->PtiParent()->Lpcoli().GetAt(pos);
        ASSERT_VALID(pcoli);

        // Save the current sort column and direction.
        if (pcoli == PcoliSort())
            m_nSortDirection ^= -1;
        else
        {
            m_pcoliSort = pcoli;
            m_nSortDirection = 0;
        }  // else:  different column

        // Sort the list.
        GetListCtrl().SortItems(CompareItems, (LPARAM) this);
    }  // if:  there are items in the list

    *pResult = 0;

}  //*** CClusterListView::OnColumnClick()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::CompareItems [static]
//
//  Routine Description:
//      Callback function for the CListCtrl::SortItems method.
//
//  Arguments:
//      lparam1     First item to compare.
//      lparam2     Second item to compare.
//      lparamSort  Sort parameter.
//
//  Return Value:
//      -1          First parameter comes before second.
//      0           First and second parameters are the same.
//      1           First parameter comes after second.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CALLBACK CClusterListView::CompareItems(
    LPARAM  lparam1,
    LPARAM  lparam2,
    LPARAM  lparamSort
    )
{
    CListItem *         pli1    = (CListItem *) lparam1;
    CListItem *         pli2    = (CListItem *) lparam2;
    CClusterListView *  pclv    = (CClusterListView *) lparamSort;
    CString             str1;
    CString             str2;
    int                 nResult;

    ASSERT_VALID(pli1);
    ASSERT_VALID(pli2);
    ASSERT_VALID(pli1->Pci());
    ASSERT_VALID(pli2->Pci());
    ASSERT_VALID(pclv);
    ASSERT_VALID(pclv->PcoliSort());

    // Get the strings from the list items.
    pli1->Pci()->BGetColumnData(pclv->PcoliSort()->Colid(), str1);
    pli2->Pci()->BGetColumnData(pclv->PcoliSort()->Colid(), str2);

    // Compare the two strings.
    // Use CompareString() so that it will sort properly on localized builds.
    nResult = CompareString(
                LOCALE_USER_DEFAULT,
                0,
                str1,
                str1.GetLength(),
                str2,
                str2.GetLength()
                );
    if ( nResult == CSTR_LESS_THAN )
    {
        nResult = -1;
    }
    else if ( nResult == CSTR_EQUAL )
    {
        nResult = 0;
    }
    else if ( nResult == CSTR_GREATER_THAN )
    {
        nResult = 1;
    }
    else
    {
        // An error occurred.  Ignore it.
        nResult = 0;
    }

    // Return the result based on the direction we are sorting.
    if (pclv->NSortDirection() != 0)
        nResult = -nResult;

    return nResult;

}  //*** CClusterListView::CompareItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnDblClk
//
//  Routine Description:
//      Handler method for the NM_DBLCLK message.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnDblClk(NMHDR * pNMHDR, LRESULT * pResult)
{
    OpenItem();
    *pResult = 0;

}  //*** CClusterListView::OnDblClk()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OpenItem
//
//  Routine Description:
//      Open the item with the focus.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OpenItem(void)
{
    CListItem * pliFocused = PliFocused();

    if (m_pliBeingEdited == NULL)
    {
        // If an item has focus, open it or show its properties.
        if (pliFocused != NULL)
        {
            CTreeItem *     pti;

            ASSERT_VALID(pliFocused->PtiParent());

            Trace(g_tagListView, _T("Opening item '%s'"), pliFocused->Pci()->StrName());

            // Find the item tree item for the list item.
            pti = pliFocused->PtiParent()->PtiChildFromPci(pliFocused->Pci());

            // If this item has a tree item, open it up.  Otherwise show its
            // properties.
            if (pti != NULL)
            {
                CSplitterFrame *    pframe;

                // Get the frame pointer so we can talk to the tree view.
                pframe = (CSplitterFrame *) GetParentFrame();
                ASSERT_KINDOF(CSplitterFrame, pframe);

                pliFocused->PtiParent()->OpenChild(pti, pframe);
            }  // if:  item is openable
            else
                OnCmdProperties();
        }  // if:  an item has focus
    }  // if:  label not being edited
    else
    {
        ASSERT_VALID(m_pliBeingEdited);
        Trace(g_tagListView, _T("Not opening item '%s'"), m_pliBeingEdited->Pci()->StrName());
    }  // else if:  label being edited
    
}  //*** CClusterListView::OpenItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnBeginLabelEdit
//
//  Routine Description:
//      Handler method for the LVN_BEGINLABELEDIT message.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnBeginLabelEdit(NMHDR * pNMHDR, LRESULT * pResult)
{
    ASSERT(pNMHDR != NULL);

    LV_DISPINFO * pDispInfo = (LV_DISPINFO *) pNMHDR;
    CListItem * pli = (CListItem *) pDispInfo->item.lParam;

    ASSERT(m_pliBeingEdited == NULL);
    ASSERT_VALID(pli->Pci());

    if (pli->Pci()->BCanBeEdited())
    {
        pli->Pci()->OnBeginLabelEdit(GetListCtrl().GetEditControl());
        m_pliBeingEdited = pli;
        *pResult = FALSE;
    }  // if:  object can be renamed
    else
        *pResult = TRUE;

    m_bShiftPressed = FALSE;
    m_bControlPressed = FALSE;
    m_bAltPressed = FALSE;

}  //*** CClusterListView::OnBeginLabelEdit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnEndLabelEdit
//
//  Routine Description:
//      Handler method for the LVN_ENDLABELEDIT message.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnEndLabelEdit(NMHDR * pNMHDR, LRESULT * pResult)
{
    ASSERT(pNMHDR != NULL);

    LV_DISPINFO * pDispInfo = (LV_DISPINFO *) pNMHDR;
    CListItem * pli = (CListItem *) pDispInfo->item.lParam;

    ASSERT_VALID(pli);
    ASSERT(pli == m_pliBeingEdited);
    ASSERT_VALID(pli->Pci());

    // If the edit wasn't cancelled, rename it.
    if (pDispInfo->item.mask & LVIF_TEXT)
    {
        ASSERT(pli->Pci()->BCanBeEdited());
        ASSERT(pDispInfo->item.pszText != NULL);

        Trace(g_tagListView, _T("Ending edit of item '%s' (Saving as '%s')"), pli->Pci()->StrName(), pDispInfo->item.pszText);

        if ( pli->Pci()->BIsLabelEditValueValid( pDispInfo->item.pszText ) )
        {
            try
            {
                pli->Pci()->Rename(pDispInfo->item.pszText);
                *pResult = TRUE;
            }  // try
            catch (CException * pe)
            {
                pe->ReportError();
                pe->Delete();
                *pResult = FALSE;
            }  // catch:  CException
        } // if:  name is valid
        else
        {
            *pResult = FALSE;
        }
    }  // if:  the edit wasn't cancelled
    else
    {
        Trace(g_tagListView, _T("Ending edit of item '%s' (Not Saving)"), pli->Pci()->StrName());
        *pResult = TRUE;
    }  // else:  edit was cancelled

    m_pliBeingEdited = NULL;
    m_bShiftPressed = FALSE;
    m_bControlPressed = FALSE;
    m_bAltPressed = FALSE;

}  //*** CClusterListView::OnEndLabelEdit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnBeginDrag
//
//  Routine Description:
//      Handler method for the LVN_BEGINDRAG and LVN_BEGINRDRAG messages.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnBeginDrag(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW *   pNMListView = (NM_LISTVIEW *) pNMHDR;
    CListCtrl &     rlc         = GetListCtrl();
    CPoint          ptAction;
    CClusterItem *  pci = NULL;
    CImageList *    pimagelist;

    ASSERT_VALID(Pframe());

    // Get the item being dragged.
    {
        int         ili;
        CListItem * pli;

        // Get the item being dragged.
        ili = pNMListView->iItem;
        pli = (CListItem *) rlc.GetItemData(ili);
        ASSERT_VALID(pli);
        ASSERT_KINDOF(CListItem, pli);
        ASSERT_VALID(pli->Pci());

        // If the item can not be dragged, abort the operation.
        if (!pli->Pci()->BCanBeDragged())
            return;

        // Deselect the item being dragged.
        rlc.SetItemState(ili, 0, LVIS_SELECTED);

        // Save info for later.
        m_iliDrag = ili;
        m_pliDrag = pli;
        m_iliDrop = -1;
        pci = pli->Pci();
    }  // Get the item being dragged

    // Create the image list and let the frame window initialize the drag operation.
    {
        CPoint  ptImage;
        CPoint  ptFrameItem;
        CPoint  ptHotSpot;

        pimagelist = rlc.CreateDragImage(m_iliDrag, &ptImage);
        ASSERT(pimagelist != NULL);
        ptFrameItem = pNMListView->ptAction;
        Pframe()->ScreenToClient(&ptFrameItem);

        // Calculate the hot spot point.
        {
            long lStyle = rlc.GetStyle() & LVS_TYPEMASK;
            switch (lStyle)
            {
                case LVS_REPORT:
                case LVS_LIST:
                case LVS_SMALLICON:
                    ptHotSpot.x = 0;
                    ptHotSpot.y = -16;
                    break;
                case LVS_ICON:
                    ptHotSpot.x = 8;
                    ptHotSpot.y = 8;
                    break;
            }  // switch:  lStyle
        }  // Calculate the hot spot point

        Trace(g_tagListDrag, _T("OnBeginDrag() - Dragging '%s' at (%d,%d)"), m_pliDrag->StrName(), ptFrameItem.x, ptFrameItem.y);
        Pframe()->BeginDrag(pimagelist, pci, ptFrameItem, ptHotSpot);
        pimagelist->SetDragCursorImage(0, CPoint(0, 0));  // define the hot spot for the new cursor image
    }  // Create the image list and let the frame window initialize the drag operation

    *pResult = 0;

}  //*** CClusterListView::OnBeginDrag(pNMHDR, pResult)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnMouseMoveForDrag
//
//  Routine Description:
//      Handler method for the WM_MOUSEMOVE message during a drag operation.
//      This function is only responsible for providing view-specific
//      functionality, such as selecting the drop target if it is valid.
//
//  Arguments:
//      nFlags      Indicates whether various virtual keys are down.
//      point       Specifies the x- and y-coordinate of the cursor in frame
//                      coordinates.
//      pwndDrop    Specifies the window under the cursor.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnMouseMoveForDrag(
    IN UINT         nFlags,
    IN OUT CPoint   point,
    IN const CWnd * pwndDrop
    )
{
    ASSERT(BDragging());
    ASSERT_VALID(Pframe());

    // If we are dragging, select the drop target.
    if (BDragging())
    {
        int             ili;
        UINT            uFlags;
        CPoint          ptView;
        CListCtrl &     rlc     = GetListCtrl();

        // Convert the point to view coordinates.
        ptView = point;
        Pframe()->ClientToScreen(&ptView);
        rlc.ScreenToClient(&ptView);

        // If this window is the drop target, find the item under the cursor.
        if (pwndDrop == &rlc)
        {
            // If we are over a list item, highlight it.
            ili = rlc.HitTest(ptView, &uFlags);
            if (ili != -1)
            {
                CListItem * pli;

                // Get the item to be highlight.
                pli = (CListItem *) rlc.GetItemData(ili);
                ASSERT_VALID(pli);
                ASSERT_KINDOF(CListItem, pli);
                ASSERT_VALID(pli->Pci());

                // If this is not a drop target, change the cursor.
                if (pli->Pci()->BCanBeDropTarget(Pframe()->PciDrag()))
                    Pframe()->ChangeDragCursor(IDC_ARROW);
                else
                    Pframe()->ChangeDragCursor(IDC_NO);
            }  // if:  over a list item
        }  // if:  this window is the drop target
        else
            ili = -1;

        // If the drop target is or was in this view, update the view.
        if ((ili != -1) || (m_iliDrop != -1))
        {
            // Unlock window updates.
            VERIFY(Pimagelist()->DragShowNolock(FALSE /*bShow*/));

            // Turn off highlight for the previous drop target.
            if (m_iliDrop != -1)
            {
                VERIFY(rlc.SetItemState(m_iliDrop, 0, LVIS_DROPHILITED));
                VERIFY(rlc.RedrawItems(m_iliDrop, m_iliDrop));
            }  // if:  there was a previous drop target

            // Highlight the new drop target.
            if (ili != -1)
            {
                VERIFY(rlc.SetItemState(ili, LVIS_DROPHILITED, LVIS_DROPHILITED));
                VERIFY(rlc.RedrawItems(ili, ili));
            }  // if:  over an item
            m_iliDrop = ili;

            rlc.UpdateWindow();
            VERIFY(Pimagelist()->DragShowNolock(TRUE /*bShow*/));
        }  // if:  new or old drop target

    }  // if:  list item is being dragged

}  //*** CClusterListView::OnMouseMoveForDrag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnButtonUpForDrag
//
//  Routine Description:
//      Called to handle a button up event during drag and drop.
//
//  Arguments:
//      nFlags      Indicates whether various virtual keys are down.
//      point       Specifies the x- and y-coordinate of the cursor.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnButtonUpForDrag(IN UINT nFlags, IN CPoint point)
{
    ASSERT(BDragging());
    ASSERT_VALID(Pframe());
    ASSERT_VALID(Pframe()->PciDrag());

    // If we are dragging, process the drop.
    if (BDragging())
    {
        int             ili;
        UINT            flags;
        CPoint          ptView;
        CListCtrl &     rlc     = GetListCtrl();

        Trace(g_tagListDrag, _T("OnButtonUpForDrag()"));

        // Convert the point to view coordinates.
        ptView = point;
        Pframe()->ClientToScreen(&ptView);
        rlc.ScreenToClient(&ptView);

        // If we are over a tree item, drop the item being dragged.
        ili = rlc.HitTest(ptView, &flags);
        if (ili != -1)
        {
            CListItem * pliDropTarget;

            // Get the item to drop on.
            pliDropTarget = (CListItem *) rlc.GetItemData(ili);
            ASSERT_VALID(pliDropTarget);
            ASSERT_KINDOF(CListItem, pliDropTarget);
            ASSERT_VALID(pliDropTarget->Pci());

            if (pliDropTarget->Pci() != Pframe()->PciDrag())
                pliDropTarget->Pci()->DropItem(Pframe()->PciDrag());
        }  // if:  over a tree item
    }  // if:  tree item is being dragged

}  //*** CClusterListView::OnButtonUpForDrag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::BeginDrag
//
//  Routine Description:
//      Called by the frame to begin a drag operation.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::BeginDrag(void)
{
    Trace(g_tagListDrag, _T("BeginDrag()"));

}  //*** CClusterListView::BeginDrag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::EndDrag
//
//  Routine Description:
//      Called by the frame to end a drag operation.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::EndDrag(void)
{
    // Clear and reset highlights.  The second one can fail, since the item
    // could be removed from the list by this time.
    if (m_iliDrop != -1)
        VERIFY(GetListCtrl().SetItemState(m_iliDrop, 0, LVIS_DROPHILITED));
    if (m_iliDrag != -1)
        GetListCtrl().SetItemState(m_iliDrag, LVIS_SELECTED, LVIS_SELECTED);

    m_iliDrag = -1;
    m_pliDrag = NULL;
    m_iliDrop = -1;

    Trace(g_tagListDrag, _T("EndDrag()"));

}  //*** CClusterListView::EndDrag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::PreTranslateMessage
//
//  Routine Description:
//      Translate window messages before they are dispatched.
//      This is necessary for handling keystrokes properly while editing
//      the label on an item.
//
//  Arguments:
//      pMsg    Points to a MSG structure that contains the message to process.
//
//  Return Value:
//      TRUE    Message was handled.
//      FALSE   Message was not handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterListView::PreTranslateMessage(MSG * pMsg)
{
    BOOL    bForward    = FALSE;

    if (m_pliBeingEdited != NULL)
    {
        CEdit * pedit = GetListCtrl().GetEditControl();
        ASSERT(pedit != NULL);

        if (pMsg->message == WM_KEYDOWN)
        {
            if (pMsg->wParam == VK_SHIFT)
                m_bShiftPressed = TRUE;
            else if (pMsg->wParam == VK_CONTROL)
            {
                ::CopyMemory(&m_msgControl, pMsg, sizeof(m_msgControl));
                m_bControlPressed = TRUE;
            }  // else if:  control key pressed
            else if ((pMsg->wParam == VK_RETURN)
                        || (pMsg->wParam == VK_ESCAPE)
                        || (pMsg->wParam == VK_INSERT)
                        || (pMsg->wParam == VK_DELETE)
                        || (pMsg->wParam == VK_F1)
                        || (pMsg->wParam == VK_F5)
                        || (pMsg->wParam == VK_F6)
                    )
            {
                Trace(g_tagListView, _T("PreTranslateMessage() - Forwarding WM_KEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
                bForward = TRUE;
                if (m_bControlPressed)
                {
                    if (pMsg->wParam == VK_RETURN)
                        pedit->SendMessage(WM_KEYUP, m_msgControl.wParam, m_msgControl.lParam);
                }  // if:  control key pressed
            }  // else if:  editing key pressed
            else if ((pMsg->wParam == VK_TAB)
                        || (m_bControlPressed
                                && (_T('A') <= pMsg->wParam) && (pMsg->wParam <= _T('Y'))
                                && (pMsg->wParam != _T('C'))
                                && (pMsg->wParam != _T('H'))
                                && (pMsg->wParam != _T('M'))
                                && (pMsg->wParam != _T('V'))
                                && (pMsg->wParam != _T('X'))
                            )
                        )
            {
                Trace(g_tagListView, _T("PreTranslateMessage() - Ignoring WM_KEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
                MessageBeep(MB_ICONEXCLAMATION);
                return TRUE;
            }  // else if:  key pressed that should be ignored
#ifdef NEVER
            else
            {
                Trace(g_tagListView, _T("PreTranslateMessage() - Not forwarding WM_KEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
            }  // else:  not processing key
#endif
        }  // if:  key pressed while editing label
        else if (pMsg->message == WM_SYSKEYDOWN)
        {
            if (pMsg->wParam == VK_MENU)
                m_bAltPressed = TRUE;
            else if ((pMsg->wParam == VK_RETURN)
                    )
            {
                Trace(g_tagListView, _T("PreTranslateMessage() - Forwarding WM_SYSKEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
                bForward = TRUE;
            }  // else if:  editing key pressed
#ifdef NEVER
            else
            {
                Trace(g_tagListView, _T("PreTranslateMessage() - Not forwarding WM_SYSKEYDOWN - %d '%c', lparam = %08.8x"), pMsg->wParam, pMsg->wParam, pMsg->lParam);
            }  // else:  not processing key
#endif
        }  // else if:  system key pressed while editing label
        if (bForward)
        {
            pedit->SendMessage(pMsg->message, pMsg->wParam, pMsg->lParam);
            return TRUE;
        }  // if:  forwarding the message
        else if (pMsg->message == WM_KEYUP)
        {
            if (pMsg->wParam == VK_SHIFT)
                m_bShiftPressed = FALSE;
            else if (pMsg->wParam == VK_CONTROL)
                m_bControlPressed = FALSE;
        }  // else if:  key up
        else if (pMsg->message == WM_SYSKEYUP)
        {
            if (pMsg->wParam == VK_MENU)
                m_bAltPressed = FALSE;
        }  // else if:  system key up
    }  // if:  editing a label

    return CListView::PreTranslateMessage(pMsg);

}  //*** CClusterListView::PreTranslateMessage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnCmdRename
//
//  Routine Description:
//      Processes the ID_FILE_RENAME menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnCmdRename(void)
{
    CListItem * pliFocused = PliFocused();

    // If an item has focus, begin label editing
    if (pliFocused != NULL)
    {
        ASSERT_VALID(pliFocused);
        pliFocused->EditLabel(this);
    }  // if:  an item has the focus

}  //*** CClusterListView::OnCmdRename()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::SetView
//
//  Routine Description:
//      Set the current view of the list view control.
//
//  Arguments:
//      dwView      [IN] List view to set.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::SetView(IN DWORD dwView)
{
    // Get the current window style.
    DWORD dwStyle = GetWindowLong(GetListCtrl().m_hWnd, GWL_STYLE);

    // Only set the window style if the view bits have changed.
    if ((dwStyle & LVS_TYPEMASK) != dwView)
    {
        // Save the column information before switching out of report view.
        if ((dwStyle & LVS_REPORT) && (PtiParent() != NULL))
            SaveColumns();

        // Set the new view.
        SetWindowLong(GetListCtrl().m_hWnd, GWL_STYLE, (dwStyle & ~LVS_TYPEMASK) | dwView);
    }  // if:  view has changed

}  //*** CClusterListView::SetView()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterListView::OnKeyDown
//
//  Routine Description:
//      Handler method for the LVN_KEYDOWN message.
//
//  Arguments:
//      pNMHDR      Notification message structure.
//      pResult     Place in which to return the result.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterListView::OnKeyDown(NMHDR * pNMHDR, LRESULT * pResult)
{
    LV_KEYDOWN * pLVKeyDown = (LV_KEYDOWN *) pNMHDR;

    if (BDragging() && (pLVKeyDown->wVKey == VK_ESCAPE))
        Pframe()->AbortDrag();

    *pResult = 0;

}  //*** CClusterListView::OnKeyDown()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\mainfrm.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		MainFrm.h
//
//	Abstract:
//		Definition of the CMainFrame class.
//
//	Author:
//		David Potter (davidp)	May 1, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _MAINFRM_H_
#define _MAINFRM_H_

/////////////////////////////////////////////////////////////////////////////
// Class CMainFrame
/////////////////////////////////////////////////////////////////////////////

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame(void);

// Attributes
public:

// Operations
public:

	// For customizing the default messages on the status bar
	virtual void	GetMessageString(UINT nID, CString& rMessage) const;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	//}}AFX_VIRTUAL

// Implementation
public:
#ifdef _DEBUG
	virtual void	AssertValid() const;
	virtual void	Dump(CDumpContext& dc) const;
#endif

protected:
	// control bar embedded members
	CStatusBar		m_wndStatusBar;
	CToolBar		m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnClose();
	afx_msg void OnHelp();
	//}}AFX_MSG
	afx_msg LRESULT	OnRestoreDesktop(WPARAM wparam, LPARAM lparam);
	afx_msg LRESULT	OnClusterNotify(WPARAM wparam, LPARAM lparam);
	DECLARE_MESSAGE_MAP()

};  //*** class CMainFrame

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

BOOL ReadWindowPlacement(OUT LPWINDOWPLACEMENT pwp, IN LPCTSTR pszSection, IN DWORD nValueNum);
void WriteWindowPlacement(IN const LPWINDOWPLACEMENT pwp, IN LPCTSTR pszSection, IN DWORD nValueNum);

/////////////////////////////////////////////////////////////////////////////

#endif // _MAINFRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\modnodes.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ModNodes.cpp
//
//	Abstract:
//		Definition of the CModifyNodesDlg dialog.
//
//	Implementation File:
//		ModNodes.h
//
//	Author:
//		David Potter (davidp)	July 16, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _MODNODES_H_
#define _MODNODES_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _NODE_H_
#include "Node.h"		// for CNodeList
#endif

#ifndef _LCPRDLG_H_
#include "LCPrDlg.h"	// for CListCtrlPairDlg
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CModifyNodesDlg;

/////////////////////////////////////////////////////////////////////////////
// CModifyNodesDlg dialog
/////////////////////////////////////////////////////////////////////////////

class CModifyNodesDlg : public CListCtrlPairDlg
{
	DECLARE_DYNCREATE(CModifyNodesDlg)

// Construction
public:
	CModifyNodesDlg(void);
	CModifyNodesDlg::CModifyNodesDlg(
		IN UINT					idd,
		IN const DWORD *		pdwHelpMap,
		IN OUT CNodeList &		rlpciRight,
		IN const CNodeList &	rlpciLeft,
		IN DWORD				dwStyle,
		IN OUT CWnd *			pParent = NULL
		);

// Callback functions
	static void CALLBACK	GetColumn(
								IN OUT CObject *	pobj,
								IN int				iItem,
								IN int				icol,
								IN OUT CDialog *	pdlg,
								OUT CString &		rstr,
								OUT int *			piimg
								);
	static BOOL	CALLBACK	BDisplayProperties(IN OUT CObject * pobj);

// Dialog Data
	//{{AFX_DATA(CModifyNodesDlg)
	enum { IDD = 0 };
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CModifyNodesDlg)
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CModifyNodesDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CModifyNodesDlg

/////////////////////////////////////////////////////////////////////////////

#endif // _MODNODES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\modnodes.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ModNodes.cpp
//
//	Abstract:
//		Implementation of the CModifyNodesDlg dialog.
//
//	Author:
//		David Potter (davidp)	July 16, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ModNodes.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CModifyNodesDlg
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CModifyNodesDlg, CListCtrlPairDlg)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CModifyNodesDlg, CListCtrlPairDlg)
	//{{AFX_MSG_MAP(CModifyNodesDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyNodesDlg::CModifyNodesDlg
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CModifyNodesDlg::CModifyNodesDlg(void)
{
}  //*** CModifyNodesDlg::CModifyNodesDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyNodesDlg::CModifyNodesDlg
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idd				[IN] Dialog ID.
//		pdwHelpMap		[IN] Control-to-Help ID mapping array.
//		rlpciRight		[IN OUT] List for the right list control.
//		rlpciLeft		[IN] List for the left list control.
//		dwStyle			[IN] Style:
//							LCPS_SHOW_IMAGES	Show images to left of items.
//							LCPS_ALLOW_EMPTY	Allow right list to be empty.
//							LCPS_ORDERED		Ordered right list.
//		pParent			[IN OUT] Parent window.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CModifyNodesDlg::CModifyNodesDlg(
	IN UINT					idd,
	IN const DWORD *		pdwHelpMap,
	IN OUT CNodeList &		rlpciRight,
	IN const CNodeList &	rlpciLeft,
	IN DWORD				dwStyle,
	IN OUT CWnd *			pParent /*=NULL*/
	) : CListCtrlPairDlg(
			idd,
			pdwHelpMap,
			&rlpciRight,
			&rlpciLeft,
			dwStyle | LCPS_PROPERTIES_BUTTON | (dwStyle & LCPS_ORDERED ? LCPS_CAN_BE_ORDERED : 0),
			GetColumn,
			BDisplayProperties,
			pParent
			)
{
	//{{AFX_DATA_INIT(CModifyNodesDlg)
	//}}AFX_DATA_INIT

}  //*** CModifyNodesDlg::CModifyNodesDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyNodesDlg::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Focus needs to be set.
//		FALSE	Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CModifyNodesDlg::OnInitDialog(void)
{
	// Add columns.
	try
	{
		NAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
	}  // try
	catch (CException * pe)
	{
		pe->ReportError();
		pe->Delete();
	}  // catch:  CException

	// Call the base class method.
	CListCtrlPairDlg::OnInitDialog();

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CModifyNodesDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyNodesDlg::GetColumn [static]
//
//	Routine Description:
//		Returns a column for an item.
//
//	Arguments:
//		pobj		[IN OUT] Object for which the column is to be displayed.
//		iItem		[IN] Index of the item in the list.
//		icol		[IN] Column number whose text is to be retrieved.
//		pdlg		[IN OUT] Dialog to which object belongs.
//		rstr		[OUT] String in which to return column text.
//		piimg		[OUT] Image index for the object.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CALLBACK CModifyNodesDlg::GetColumn(
	IN OUT CObject *	pobj,
	IN int				iItem,
	IN int				icol,
	IN OUT CDialog *	pdlg,
	OUT CString &		rstr,
	OUT int *			piimg
	)
{
	CClusterNode *	pciNode	= (CClusterNode *) pobj;

	ASSERT_VALID(pciNode);
	ASSERT(icol == 0);

	pciNode->BGetColumnData(IDS_COLTEXT_NAME, rstr);
	if (piimg != NULL)
		*piimg = pciNode->IimgObjectType();

}  //*** CModifyNodesDlg::GetColumn()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyNodesDlg::BDisplayProperties [static]
//
//	Routine Description:
//		Display the properties of the specified object.
//
//	Arguments:
//		pobj	[IN OUT] Cluster item whose properties are to be displayed.
//
//	Return Value:
//		TRUE	Properties where accepted.
//		FALSE	Properties where cancelled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK CModifyNodesDlg::BDisplayProperties(IN OUT CObject * pobj)
{
	CClusterItem *	pci = (CClusterItem *) pobj;

	ASSERT_KINDOF(CClusterItem, pobj);

	return pci->BDisplayProperties();

}  //*** CModifyNodesDlg::BDisplayProperties();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\mainfrm.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		MainFrm.cpp
//
//	Abstract:
//		Implementation of the CMainFrame class.
//
//	Author:
//		David Potter (davidp)	May 1, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "MainFrm.h"
#include "TraceTag.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag	g_tagMainFrame(TEXT("UI"), TEXT("MAIN FRAME"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_WM_CLOSE()
	//}}AFX_MSG_MAP
	// Global help commands
	ON_COMMAND(ID_HELP_FINDER, OnHelp)
	ON_COMMAND(ID_HELP, OnHelp)
	ON_COMMAND(ID_CONTEXT_HELP, OnHelp)
	ON_COMMAND(ID_DEFAULT_HELP, OnHelp)
	ON_MESSAGE(WM_CAM_RESTORE_DESKTOP, OnRestoreDesktop)
	ON_MESSAGE(WM_CAM_CLUSTER_NOTIFY, OnClusterNotify)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMainFrame::CMainFrame
//
//	Routine Description:
//		Default construtor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CMainFrame::CMainFrame(void)
{
}  //*** CMainFrame::CMainFrame()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMainFrame::OnCreate
//
//	Routine Description:
//		Handler for the WM_CREATE message.  Create the contents of the frame,
//		including toolbars, status bars, etc.
//
//	Arguments:
//		lpCreateStruct	Pointer to a CREATESTRUCT.
//
//	Return Value:
//		-1		Failed to create.
//		0		Created successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		Trace(g_tagMainFrame, _T("Failed to create toolbar"));
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this)
			|| !m_wndStatusBar.SetIndicators(
								indicators,
								sizeof(indicators)/sizeof(UINT)
								))
	{
		Trace(g_tagMainFrame, _T("Failed to create status bar"));
		return -1;      // fail to create
	}

	// TODO: Remove this if you don't want tool tips or a resizeable toolbar
	m_wndToolBar.SetBarStyle(
					m_wndToolBar.GetBarStyle()
					| CBRS_TOOLTIPS
					| CBRS_FLYBY
					| CBRS_SIZE_DYNAMIC
					);

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	// Hide the toolbar and/or status bar is that is the current setting.
	{
		BOOL	bShowToolBar;
		BOOL	bShowStatusBar;

		// Read the settings from the user's profile.
		bShowToolBar = AfxGetApp()->GetProfileInt(
										REGPARAM_SETTINGS,
										REGPARAM_SHOW_TOOL_BAR,
										TRUE
										);
		bShowStatusBar = AfxGetApp()->GetProfileInt(
										REGPARAM_SETTINGS,
										REGPARAM_SHOW_STATUS_BAR,
										TRUE
										);

		// Show or hide the toolbar and status bar.
		m_wndToolBar.ShowWindow(bShowToolBar);
		m_wndStatusBar.ShowWindow(bShowStatusBar);
	}  // Hide the toolbar and/or status bar is that is the current setting

	return 0;

}  //*** CMainFrame::OnCreate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMainFrame::GetMessageString
//
//	Routine Description:
//		Get a string for a command ID.
//
//	Arguments:
//		nID			[IN] Command ID for which a string should be returned.
//		rMessage	[OUT] String in which to return the message.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMainFrame::GetMessageString(UINT nID, CString& rMessage) const
{
	CFrameWnd *	pframe;

	// Pass off to the active MDI child frame window, if there is one.
	pframe = MDIGetActive();
	if (pframe == NULL)
		CMDIFrameWnd::GetMessageString(nID, rMessage);
	else
		pframe->GetMessageString(nID, rMessage);

}  //*** CMainFrame::GetMessageString()

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
void CMainFrame::AssertValid(void) const
{
	CMDIFrameWnd::AssertValid();

}  //*** CMainFrame::AssertValid()

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);

}  //*** CMainFrame::Dump()

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMainFrame::OnClusterNotify
//
//	Routine Description:
//		Handler for the WM_CAM_CLUSTER_NOTIFY message.
//		Processes cluster notifications.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnClose(void)
{
	// Save the current window position and size.
	{
		WINDOWPLACEMENT wp;
		wp.length = sizeof wp;
		if (GetWindowPlacement(&wp))
		{
			wp.flags = 0;
			if (IsZoomed())
				wp.flags |= WPF_RESTORETOMAXIMIZED;
			if (IsIconic())
				wp.showCmd = SW_SHOWMINNOACTIVE;

			// and write it to the .INI file
			WriteWindowPlacement(&wp, REGPARAM_SETTINGS, 0);
		}  // if:  window placement retrieved successfully
	}  // Save the current window position and size

	// Save the current connections.
	GetClusterAdminApp()->SaveConnections();

	// Save the current toolbar and status bar show state.
	AfxGetApp()->WriteProfileInt(
					REGPARAM_SETTINGS,
					REGPARAM_SHOW_TOOL_BAR,
					((m_wndToolBar.GetStyle() & WS_VISIBLE) ? TRUE : FALSE)
					);
	AfxGetApp()->WriteProfileInt(
					REGPARAM_SETTINGS,
					REGPARAM_SHOW_STATUS_BAR,
					((m_wndStatusBar.GetStyle() & WS_VISIBLE) ? TRUE : FALSE)
					);

	CMDIFrameWnd::OnClose();

}  //*** CMainFrame::OnClose()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMainFrame::OnRestoreDesktop
//
//	Routine Description:
//		Handler for the WM_CAM_RESTORE_DESKTOP message.
//		Restores the desktop from the saved parameters.
//
//	Arguments:
//		wparam		1st parameter.
//		lparam		2nd parameter.
//
//	Return Value:
//		Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnRestoreDesktop(WPARAM wparam, LPARAM lparam)
{
	// Call this method on the application.
	return GetClusterAdminApp()->OnRestoreDesktop(wparam, lparam);

}  //*** CMainFrame::OnRestoreDesktop()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMainFrame::OnClusterNotify
//
//	Routine Description:
//		Handler for the WM_CAM_CLUSTER_NOTIFY message.
//		Processes cluster notifications.
//
//	Arguments:
//		wparam		1st parameter.
//		lparam		2nd parameter.
//
//	Return Value:
//		Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CMainFrame::OnClusterNotify(WPARAM wparam, LPARAM lparam)
{
	CClusterAdminApp *	papp	= GetClusterAdminApp();

	// Call this method on the application.
	return papp->OnClusterNotify(wparam, lparam);

}  //*** CMainFrame::OnClusterNotify()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CMainFrame::OnHelp
//
//	Routine Description:
//		Handler for the IDM_HELP_FINDER menu command.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMainFrame::OnHelp(void)
{
	HtmlHelpW( m_hWnd, _T("MSCSConcepts.chm"), HH_DISPLAY_TOPIC, 0L );

}  //*** CMainFrame::OnHelp()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Helpers for saving/restoring window state

static TCHAR g_szFormat[] = _T("%u,%u,%d,%d,%d,%d,%d,%d,%d,%d");

/////////////////////////////////////////////////////////////////////////////
//++
//
//	ReadWindowPlacement
//
//	Routine Description:
//		Read window placement parameters.
//
//	Arguments:
//		pwp			[OUT] WINDOWPLACEMENT structure to fill.
//		pszSection	[IN] Section name under which to read data.
//		nValueNum	[IN] Number of the value to read.
//
//	Return Value:
//		TRUE		Parameters read.
//		FALSE		Parameters not read.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL ReadWindowPlacement(
	OUT LPWINDOWPLACEMENT	pwp,
	IN LPCTSTR				pszSection,
	IN DWORD				nValueNum
	)
{
	CString strBuffer;
	CString	strValueName;

	if (nValueNum <= 1)
		strValueName = REGPARAM_WINDOW_POS;
	else
		strValueName.Format(REGPARAM_WINDOW_POS _T("-%d"), nValueNum);

	strBuffer = AfxGetApp()->GetProfileString(pszSection, strValueName);
	if (strBuffer.IsEmpty())
		return FALSE;

	WINDOWPLACEMENT wp;
	int nRead = _stscanf(strBuffer, g_szFormat,
		&wp.flags, &wp.showCmd,
		&wp.ptMinPosition.x, &wp.ptMinPosition.y,
		&wp.ptMaxPosition.x, &wp.ptMaxPosition.y,
		&wp.rcNormalPosition.left, &wp.rcNormalPosition.top,
		&wp.rcNormalPosition.right, &wp.rcNormalPosition.bottom);

	if (nRead != 10)
		return FALSE;

	wp.length = sizeof wp;
	*pwp = wp;
	return TRUE;

}  //*** ReadWindowPlacement()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	WriteWindowPlacement
//
//	Routine Description:
//		Write window placement parameters.
//
//	Arguments:
//		pwp			[IN] WINDOWPLACEMENT structure to save.
//		pszSection	[IN] Section name under which to write data.
//		nValueNum	[IN] Number of the value to write.
//
//	Return Value:
//		TRUE		Parameters read.
//		FALSE		Parameters not read.
//
//--
/////////////////////////////////////////////////////////////////////////////
void WriteWindowPlacement(
	IN const LPWINDOWPLACEMENT	pwp,
	IN LPCTSTR					pszSection,
	IN DWORD					nValueNum
	)
{
	TCHAR szBuffer[sizeof("-32767")*8 + sizeof("65535")*2];
	CString strBuffer;
	CString	strValueName;

	if (nValueNum <= 1)
		strValueName = REGPARAM_WINDOW_POS;
	else
		strValueName.Format(REGPARAM_WINDOW_POS _T("-%d"), nValueNum);

	wsprintf(szBuffer, g_szFormat,
		pwp->flags, pwp->showCmd,
		pwp->ptMinPosition.x, pwp->ptMinPosition.y,
		pwp->ptMaxPosition.x, pwp->ptMaxPosition.y,
		pwp->rcNormalPosition.left, pwp->rcNormalPosition.top,
		pwp->rcNormalPosition.right, pwp->rcNormalPosition.bottom);
	AfxGetApp()->WriteProfileString(pszSection, strValueName, szBuffer);

}  //*** WriteWindowPlacement()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\listview.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		ListView.h
//
//	Abstract:
//		Definition of the CClusterListView class.
//
//	Implementation File:
//		ListView.cpp
//
//	Author:
//		David Potter (davidp)	May 3, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _LISTVIEW_H_
#define _LISTVIEW_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterListView;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CColumnItem;
class CClusterDoc;
class CTreeItem;
class CSplitterFrame;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef CList<CClusterListView *, CClusterListView *> CClusterListViewList;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_H_
#include "TreeItem.h"	// for CTreeItem
#endif

#ifndef _SPLITFRM_H
#include "SplitFrm.h"	// for CSplitterFrame
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterListView view
/////////////////////////////////////////////////////////////////////////////

class CClusterListView : public CListView
{
	friend class CListItem;
	friend class CClusterDoc;
	friend class CSplitterFrame;

protected:
	CClusterListView(void);			// protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CClusterListView)

// Attributes
protected:
	CTreeItem *			m_ptiParent;
	int					m_nColumns;
	CSplitterFrame *	m_pframe;

	BOOL				BDragging(void) const		{ ASSERT_VALID(Pframe()); return Pframe()->BDragging(); }
	CImageList *		Pimagelist(void) const		{ ASSERT_VALID(Pframe()); return Pframe()->Pimagelist(); }

public:
	CClusterDoc *		GetDocument(void);
	CSplitterFrame *	Pframe(void) const			{ return m_pframe; }
	CListItem *			PliFocused(void) const;
	int					IliFocused(void) const	{ return GetListCtrl().GetNextItem(-1, LVNI_FOCUSED); }
	CTreeItem *			PtiParent(void) const	{ return m_ptiParent; }

// Operations
public:
	void				Refresh(IN OUT CTreeItem * ptiSelected);
	BOOL				DeleteAllItems(void);
	void				SaveColumns(void);
	void				SetView(IN DWORD dwView);
	int					GetView(void) const		{ return (GetWindowLong(GetListCtrl().m_hWnd, GWL_STYLE) & LVS_TYPEMASK); }

	CMenu *				PmenuPopup(
							IN CPoint &			rpointScreen,
							OUT CClusterItem *&	rpci
							);

protected:
	void				AddColumns(void);

//	CMenu *				PmenuPopup(void);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CClusterListView)
	public:
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void OnInitialUpdate();
	protected:
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CClusterListView(void);
#ifdef _DEBUG
	virtual void		AssertValid(void) const;
	virtual void		Dump(CDumpContext& dc) const;
#endif

	static int CALLBACK	CompareItems(LPARAM lparam1, LPARAM lparam2, LPARAM lparamSort);
	int					m_nSortDirection;
	CColumnItem *		m_pcoliSort;

	// Label editing.
	CListItem *			m_pliBeingEdited;
	BOOL				m_bShiftPressed;
	BOOL				m_bControlPressed;
	BOOL				m_bAltPressed;
	MSG					m_msgControl;

	// Drag & drop.
	int					m_iliDrag;
	CListItem *			m_pliDrag;
	int					m_iliDrop;
	CPoint				m_ptDragHotSpot;
	void				OnMouseMoveForDrag(IN UINT nFlags, IN CPoint point, IN const CWnd * pwndDrop);
	void				OnButtonUpForDrag(IN UINT nFlags, IN CPoint point);
	void				BeginDrag(void);
	void				EndDrag(void);

	int					NSortDirection(void) const	{ return m_nSortDirection; }
	CColumnItem *		PcoliSort(void) const		{ return m_pcoliSort; }

	// Generated message map functions
protected:
	//{{AFX_MSG(CClusterListView)
	afx_msg void OnDestroy();
	afx_msg void OnItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblClk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OpenItem();
	afx_msg void OnBeginLabelEdit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEndLabelEdit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
	afx_msg void OnCmdProperties();
	afx_msg void OnCmdRename();
	afx_msg void OnBeginDrag(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeyDown(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CClusterListView

#ifndef _DEBUG  // debug version in TreeView.cpp
inline CClusterDoc * CClusterListView::GetDocument(void)
   { return (CClusterDoc *) m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _LISTVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\modres.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ModRes.cpp
//
//	Abstract:
//		Definition of the CModifyResourcesDlg dialog.
//
//	Implementation File:
//		ModNodes.h
//
//	Author:
//		David Potter (davidp)	November 26, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _MODRES_H_
#define _MODRES_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _RES_H_
#include "Res.h"		// for CResourceList
#endif

#ifndef _LCPRDLG_H_
#include "LCPrDlg.h"	// for CListCtrlPairDlg
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CModifyResourcesDlg;

/////////////////////////////////////////////////////////////////////////////
// CModifyResourcesDlg dialog
/////////////////////////////////////////////////////////////////////////////

class CModifyResourcesDlg : public CListCtrlPairDlg
{
	DECLARE_DYNCREATE(CModifyResourcesDlg)

// Construction
public:
	CModifyResourcesDlg(void);
	CModifyResourcesDlg::CModifyResourcesDlg(
		IN UINT						idd,
		IN const DWORD *			pdwHelpMap,
		IN OUT CResourceList &		rlpciRight,
		IN const CResourceList &	rlpciLeft,
		IN DWORD					dwStyle,
		IN OUT CWnd *				pParent = NULL
		);

// Callback functions
	static void CALLBACK	GetColumn(
								IN OUT CObject *	pobj,
								IN int				iItem,
								IN int				icol,
								IN OUT CDialog *	pdlg,
								OUT CString &		rstr,
								OUT int *			piimg
								);
	static BOOL	CALLBACK	BDisplayProperties(IN OUT CObject * pobj);

// Dialog Data
	//{{AFX_DATA(CModifyResourcesDlg)
	enum { IDD = 0 };
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CModifyResourcesDlg)
	//}}AFX_VIRTUAL

// Implementation
protected:
	IDS						m_idsTitle;

	IDS						IdsTitle(void) const		{ return m_idsTitle; }

	// Generated message map functions
	//{{AFX_MSG(CModifyResourcesDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CModifyResourcesDlg

/////////////////////////////////////////////////////////////////////////////

#endif // _MODRES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\modres.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ModRes.cpp
//
//	Abstract:
//		Implementation of the CModifyResourcesDlg dialog.
//
//	Author:
//		David Potter (davidp)	November 26, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ModRes.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CModifyResourcesDlg
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CModifyResourcesDlg, CListCtrlPairDlg)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CModifyResourcesDlg, CListCtrlPairDlg)
	//{{AFX_MSG_MAP(CModifyResourcesDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyResourcesDlg::CModifyResourcesDlg
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CModifyResourcesDlg::CModifyResourcesDlg(void)
{
}  //*** CModifyResourcesDlg::CModifyResourcesDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyResourcesDlg::CModifyResourcesDlg
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idd				[IN] Dialog ID.
//		pdwHelpMap		[IN] Control-to-Help ID mapping array.
//		rlpciRight		[IN OUT] List for the right list control.
//		rlpciLeft		[IN] List for the left list control.
//		dwStyle			[IN] Style:
//							LCPS_SHOW_IMAGES	Show images to left of items.
//							LCPS_ALLOW_EMPTY	Allow right list to be empty.
//							LCPS_ORDERED		Ordered right list.
//		pParent			[IN OUT] Parent window.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CModifyResourcesDlg::CModifyResourcesDlg(
	IN UINT						idd,
	IN const DWORD *			pdwHelpMap,
	IN OUT CResourceList &		rlpciRight,
	IN const CResourceList &	rlpciLeft,
	IN DWORD					dwStyle,
	IN OUT CWnd *				pParent //=NULL
	) : CListCtrlPairDlg(
			idd,
			pdwHelpMap,
			&rlpciRight,
			&rlpciLeft,
			dwStyle | LCPS_PROPERTIES_BUTTON | (dwStyle & LCPS_ORDERED ? LCPS_CAN_BE_ORDERED : 0),
			GetColumn,
			BDisplayProperties,
			pParent
			)
{
	//{{AFX_DATA_INIT(CModifyResourcesDlg)
	//}}AFX_DATA_INIT

}  //*** CModifyResourcesDlg::CModifyResourcesDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyResourcesDlg::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Focus needs to be set.
//		FALSE	Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CModifyResourcesDlg::OnInitDialog(void)
{
	// Add columns.
	try
	{
		NAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
		NAddColumn(IDS_COLTEXT_RESTYPE, COLI_WIDTH_RESTYPE);
	}  // try
	catch (CException * pe)
	{
		pe->ReportError();
		pe->Delete();
	}  // catch:  CException

	// Call the base class method.
	CListCtrlPairDlg::OnInitDialog();

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CModifyResourcesDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyResourcesDlg::GetColumn [static]
//
//	Routine Description:
//		Returns a column for an item.
//
//	Arguments:
//		pobj		[IN OUT] Object for which the column is to be displayed.
//		iItem		[IN] Index of the item in the list.
//		icol		[IN] Column number whose text is to be retrieved.
//		pdlg		[IN OUT] Dialog to which object belongs.
//		rstr		[OUT] String in which to return column text.
//		piimg		[OUT] Image index for the object.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CALLBACK CModifyResourcesDlg::GetColumn(
	IN OUT CObject *	pobj,
	IN int				iItem,
	IN int				icol,
	IN OUT CDialog *	pdlg,
	OUT CString &		rstr,
	OUT int *			piimg
	)
{
	CResource *	pciRes	= (CResource *) pobj;
	int			colid;

	ASSERT_VALID(pciRes);
	ASSERT((0 <= icol) && (icol <= 1));

	switch (icol)
	{
		// Sorting by resource name.
		case 0:
			colid = IDS_COLTEXT_RESOURCE;
			break;

		// Sorting by resource type.
		case 1:
			colid = IDS_COLTEXT_RESTYPE;
			break;

		default:
			colid = IDS_COLTEXT_RESOURCE;
			break;
	}  // switch:  icol

	pciRes->BGetColumnData(colid, rstr);
	if (piimg != NULL)
		*piimg = pciRes->IimgObjectType();

}  //*** CModifyResourcesDlg::GetColumn()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CModifyResourcesDlg::BDisplayProperties [static]
//
//	Routine Description:
//		Display the properties of the specified object.
//
//	Arguments:
//		pobj	[IN OUT] Cluster item whose properties are to be displayed.
//
//	Return Value:
//		TRUE	Properties where accepted.
//		FALSE	Properties where cancelled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK CModifyResourcesDlg::BDisplayProperties(IN OUT CObject * pobj)
{
	CClusterItem *	pci = (CClusterItem *) pobj;

	ASSERT_KINDOF(CClusterItem, pobj);

	return pci->BDisplayProperties();

}  //*** CModifyResourcesDlg::BDisplayProperties();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\moveres.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      MoveRes.cpp
//
//  Abstract:
//      Implementation of the CMoveResourcesDlg class.
//
//  Author:
//      David Potter (davidp)   April 1, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "MoveRes.h"
#include "Res.h"
#include "ResType.h"
#include "HelpData.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMoveResourcesDlg class
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CMoveResourcesDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CMoveResourcesDlg)
    ON_NOTIFY(NM_DBLCLK, IDC_MR_RESOURCES_LIST, OnDblClkResourcesList)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_MR_RESOURCES_LIST, OnColumnClick)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
    ON_BN_CLICKED(IDYES, CBaseDialog::OnOK)
    ON_BN_CLICKED(IDNO, CBaseDialog::OnCancel)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMoveResourcesDlg::CMoveResourcesDlg
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pciRes      [IN] Resource being moved.
//      plpci       [IN] List of resources which are dependent on pciRes.
//      pParent     [IN OUT] Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CMoveResourcesDlg::CMoveResourcesDlg(
    IN CResource *              pciRes,
    IN const CResourceList *    plpci,
    IN OUT CWnd *               pParent /*=NULL*/
    )
    : CBaseDialog(IDD, g_aHelpIDs_IDD_MOVE_RESOURCES, pParent)
{
    //{{AFX_DATA_INIT(CMoveResourcesDlg)
    //}}AFX_DATA_INIT

    ASSERT_VALID(pciRes);
    ASSERT(plpci != NULL);

    m_pciRes = pciRes;
    m_plpci = plpci;

}  //*** CMoveResourcesDlg::CMoveResourcesDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMoveResourcesDlg::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMoveResourcesDlg::DoDataExchange(CDataExchange * pDX)
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMoveResourcesDlg)
    DDX_Control(pDX, IDC_MR_RESOURCES_LIST, m_lcResources);
    //}}AFX_DATA_MAP

}  //*** CMoveResourcesDlg::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMoveResourcesDlg::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CMoveResourcesDlg::OnInitDialog(void)
{
    int     nitem;

    CBaseDialog::OnInitDialog();

    // Change list view control extended styles.
    {
        DWORD   dwExtendedStyle;

        dwExtendedStyle = (DWORD)m_lcResources.SendMessage(LVM_GETEXTENDEDLISTVIEWSTYLE);
        m_lcResources.SendMessage(
            LVM_SETEXTENDEDLISTVIEWSTYLE,
            0,
            dwExtendedStyle
                | LVS_EX_FULLROWSELECT
                | LVS_EX_HEADERDRAGDROP
            );
    }  // Change list view control extended styles

    // Set the image list for the list control to use.
    m_lcResources.SetImageList(GetClusterAdminApp()->PilSmallImages(), LVSIL_SMALL);

    // Add the columns.
    {
        CString         strColumn;
        try
        {
            strColumn.LoadString(IDS_COLTEXT_NAME);
            m_lcResources.InsertColumn(0, strColumn, LVCFMT_LEFT, COLI_WIDTH_NAME * 3 / 2);
            strColumn.LoadString(IDS_COLTEXT_RESTYPE);
            m_lcResources.InsertColumn(1, strColumn, LVCFMT_LEFT, COLI_WIDTH_RESTYPE * 3 / 2);
        }  // try
        catch (CException * pe)
        {
            pe->Delete();
        }  // catch:  CException
    }  // Add the columns

    // Add the resource being moved to the list.
    nitem = m_lcResources.InsertItem(0, PciRes()->StrName(), PciRes()->IimgObjectType());
    m_lcResources.SetItemText(nitem, 1, PciRes()->StrRealResourceTypeDisplayName());
    m_lcResources.SetItemData(nitem, (DWORD_PTR) PciRes());
    m_pciRes->AddRef();

    // Add the items.
    {
        POSITION        pos;
        int             iitem;
        CResource *     pciRes;

        pos = Plpci()->GetHeadPosition();
        for (iitem = 1 ; pos != NULL ; iitem++)
        {
            pciRes = (CResource *) Plpci()->GetNext(pos);
            ASSERT_VALID(pciRes);
            if (pciRes != PciRes())
            {
                nitem = m_lcResources.InsertItem(iitem, pciRes->StrName(), pciRes->IimgObjectType());
                m_lcResources.SetItemText(nitem, 1, pciRes->StrRealResourceTypeDisplayName());
                m_lcResources.SetItemData(nitem, (DWORD_PTR) pciRes);
                pciRes->AddRef();
            }  // if:  not resource being moved
        }  // while:  more items in the list
    }  // Add the items

    // Sort the items.
    m_nSortColumn = 0;
    m_nSortDirection = 0;
    m_lcResources.SortItems(CompareItems, (LPARAM) this);

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CMoveResourcesDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMoveResourcesDlg::OnDestroy
//
//  Routine Description:
//      Handler method for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMoveResourcesDlg::OnDestroy(void)
{
    // Dereference all the cluster item pointers.
    if (m_lcResources.m_hWnd != NULL)
    {
        int             ili = -1;
        CClusterItem *  pci;

        while ((ili = m_lcResources.GetNextItem(ili, LVNI_ALL)) != -1)
        {
            pci = (CClusterItem *) m_lcResources.GetItemData(ili);
            ASSERT_VALID(pci);
            ASSERT_KINDOF(CClusterItem, pci);

            pci->Release();
        }  // while:  more items in the list control
    }  // if:  list control has been instantiated

    CBaseDialog::OnDestroy();

}  //*** CMoveResourcesDlg::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMoveResourcesDlg::OnDblClkDependsList
//
//  Routine Description:
//      Handler method for the NM_DBLCLK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMoveResourcesDlg::OnDblClkResourcesList(NMHDR * pNMHDR, LRESULT * pResult)
{
    int             iitem;
    CResource *     pciRes;

    // Get the item with the focus.
    iitem = m_lcResources.GetNextItem(-1, LVNI_FOCUSED);
    ASSERT(iitem != -1);

    if (iitem != -1)
    {
        // Get the resource pointer.
        pciRes = (CResource *) m_lcResources.GetItemData(iitem);
        ASSERT_VALID(pciRes);

        // Get properties of that item.
        pciRes->BDisplayProperties(FALSE /*bReadOnly*/);
    }  // if:  found an item with focus

    *pResult = 0;

}  //*** CMoveResourcesDlg::OnDblClkResourcesList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMoveResourcesDlg::OnColumnClick
//
//  Routine Description:
//      Handler method for the LVN_COLUMNCLICK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMoveResourcesDlg::OnColumnClick(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW * pNMListView = (NM_LISTVIEW *) pNMHDR;

    if (m_lcResources.GetItemCount() != 0)
    {
        // Save the current sort column and direction.
        if (pNMListView->iSubItem == m_nSortColumn)
            m_nSortDirection ^= -1;
        else
        {
            m_nSortColumn = pNMListView->iSubItem;
            m_nSortDirection = 0;
        }  // else:  different column

        // Sort the list.
        m_lcResources.SortItems(CompareItems, (LPARAM) this);
    }  // if:  there are items in the list

    *pResult = 0;

}  //*** CMoveResourcesDlg::OnColumnClick()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMoveResourcesDlg::CompareItems [static]
//
//  Routine Description:
//      Callback function for the CListCtrl::SortItems method.
//
//  Arguments:
//      lparam1     First item to compare.
//      lparam2     Second item to compare.
//      lparamSort  Sort parameter.
//
//  Return Value:
//      -1          First parameter comes before second.
//      0           First and second parameters are the same.
//      1           First parameter comes after second.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CALLBACK CMoveResourcesDlg::CompareItems(
    LPARAM  lparam1,
    LPARAM  lparam2,
    LPARAM  lparamSort
    )
{
    CResource *         pciRes1 = (CResource *) lparam1;
    CResource *         pciRes2 = (CResource *) lparam2;
    CMoveResourcesDlg * pdlg    = (CMoveResourcesDlg *) lparamSort;
    const CString *     pstr1;
    const CString *     pstr2;
    int                 nResult;

    ASSERT_VALID(pciRes1);
    ASSERT_VALID(pciRes2);
    ASSERT_VALID(pdlg);

    // Get the strings from the list items.
    if (pdlg->m_nSortColumn == 1)
    {
        pstr1 = &pciRes1->StrRealResourceTypeDisplayName();
        pstr2 = &pciRes2->StrRealResourceTypeDisplayName();
    }  //  if:  sorting on name column
    else
    {
        pstr1 = &pciRes1->StrName();
        pstr2 = &pciRes2->StrName();
    }  // else:  sorting on resource type column

    // Compare the two strings.
    // Use CompareString() so that it will sort properly on localized builds.
    nResult = CompareString(
                LOCALE_USER_DEFAULT,
                0,
                *pstr1,
                pstr1->GetLength(),
                *pstr2,
                pstr2->GetLength()
                );
    if ( nResult == CSTR_LESS_THAN )
    {
        nResult = -1;
    }
    else if ( nResult == CSTR_EQUAL )
    {
        nResult = 0;
    }
    else if ( nResult == CSTR_GREATER_THAN )
    {
        nResult = 1;
    }
    else
    {
        // An error occurred.  Ignore it.
        nResult = 0;
    }

    // Return the result based on the direction we are sorting.
    if (pdlg->m_nSortDirection != 0)
        nResult = -nResult;

    return nResult;

}  //*** CMoveResourcesDlg::CompareItems()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\netiface.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		NetIFace.cpp
//
//	Abstract:
//		Implementation of the CNetInterface class.
//
//	Author:
//		David Potter (davidp)	May 28, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "NetIFace.h"
#include "ClusItem.inl"
#include "Cluster.h"
#include "NetIProp.h"
#include "ExcOper.h"
#include "TraceTag.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag	g_tagNetIFace(_T("Document"), _T("NETWORK INTERFACE"), 0);
CTraceTag	g_tagNetIFaceNotify(_T("Notify"), _T("NETIFACE NOTIFY"), 0);
CTraceTag	g_tagNetIFaceRegNotify(_T("Notify"), _T("NETIFACE REG NOTIFY"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetInterface
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNetInterface, CClusterItem)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNetInterface, CClusterItem)
	//{{AFX_MSG_MAP(CNetInterface)
	ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterface::CNetInterface
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetInterface::CNetInterface(void)
	: CClusterItem(NULL, IDS_ITEMTYPE_NETIFACE)
{
	CommonConstruct();

}  //*** CResoruce::CNetInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterface::CommonConstruct
//
//	Routine Description:
//		Common construction.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterface::CommonConstruct(void)
{
	m_idmPopupMenu = IDM_NETIFACE_POPUP;
	m_hnetiface = NULL;

	m_dwCharacteristics = CLUS_CHAR_UNKNOWN;
	m_dwFlags = 0;

	m_pciNode = NULL;
	m_pciNetwork = NULL;

	// Set the object type image.
	m_iimgObjectType = GetClusterAdminApp()->Iimg(IMGLI_NETIFACE);

	// Setup the property array.
	{
		m_rgProps[epropName].Set(CLUSREG_NAME_NETIFACE_NAME, m_strName, m_strName);
		m_rgProps[epropNode].Set(CLUSREG_NAME_NETIFACE_NODE, m_strNode, m_strNode);
		m_rgProps[epropNetwork].Set(CLUSREG_NAME_NETIFACE_NETWORK, m_strNetwork, m_strNetwork);
		m_rgProps[epropAdapter].Set(CLUSREG_NAME_NETIFACE_ADAPTER_NAME, m_strAdapter, m_strAdapter);
		m_rgProps[epropAddress].Set(CLUSREG_NAME_NETIFACE_ADDRESS, m_strAddress, m_strAddress);
		m_rgProps[epropDescription].Set(CLUSREG_NAME_NETIFACE_DESC, m_strDescription, m_strDescription);
	}  // Setup the property array

}  //*** CNetInterface::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterface::~CNetInterface
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetInterface::~CNetInterface(void)
{
	// Cleanup this object.
	Cleanup();

	// Close the network interface handle.
	if (Hnetiface() != NULL)
		CloseClusterNetInterface(Hnetiface());

}  //*** CNetInterface::~CNetInterface

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterface::Cleanup
//
//	Routine Description:
//		Cleanup the item.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterface::Cleanup(void)
{
	// Remove ourselves from the node's list.
	if (PciNode() != NULL)
	{
		PciNode()->RemoveNetInterface(this);
		PciNode()->Release();
		m_pciNode = NULL;
	}  // if:  there is a node

	// Remove ourselves from the network's list.
	if (PciNetwork() != NULL)
	{
		PciNetwork()->RemoveNetInterface(this);
		PciNetwork()->Release();
		m_pciNetwork = NULL;
	}  // if:  there is a network

	// Remove the item from the network interface list.
	{
		POSITION	posPci;

		posPci = Pdoc()->LpciNetInterfaces().Find(this);
		if (posPci != NULL)
		{
			Pdoc()->LpciNetInterfaces().RemoveAt(posPci);
		}  // if:  found in the document's list
	}  // Remove the item from the network interface list

}  //*** CNetInterface::Cleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterface::Init
//
//	Routine Description:
//		Initialize the item.
//
//	Arguments:
//		pdoc		[IN OUT] Document to which this item belongs.
//		lpszName	[IN] Name of the item.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		CNTException	Errors from OpenClusterNetInterface() or
//		GetClusterNetInterfaceKey().
//		Any exceptions thrown by new.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterface::Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName)
{
	DWORD		dwStatus = ERROR_SUCCESS;
	LONG		lResult;
	CString 	strName(lpszName);	// Required if built non-Unicode
	CWaitCursor wc;

	ASSERT(Hnetiface() == NULL);
	ASSERT(Hkey() == NULL);

	// Call the base class method.
	CClusterItem::Init(pdoc, lpszName);

	try
	{
		// Open the network interface.
		m_hnetiface = OpenClusterNetInterface(Hcluster(), strName);
		if (Hnetiface() == NULL)
		{
			dwStatus = GetLastError();
			ThrowStaticException(dwStatus, IDS_OPEN_NETIFACE_ERROR, lpszName);
		}  // if:  error opening the cluster network interface

		// Get the network interface registry key.
		m_hkey = GetClusterNetInterfaceKey(Hnetiface(), MAXIMUM_ALLOWED);
		if (Hkey() == NULL)
			ThrowStaticException(GetLastError(), IDS_GET_NETIFACE_KEY_ERROR, lpszName);

		ASSERT(Pcnk() != NULL);
		Trace(g_tagClusItemNotify, _T("CNetInterface::Init() - Registering for network interface notifications (%08.8x) for '%s'"), Pcnk(), StrName());

		// Register for network interface notifications.
		lResult = RegisterClusterNotify(
							GetClusterAdminApp()->HchangeNotifyPort(),
							(	  CLUSTER_CHANGE_NETINTERFACE_STATE
								| CLUSTER_CHANGE_NETINTERFACE_DELETED
								| CLUSTER_CHANGE_NETINTERFACE_PROPERTY),
							Hnetiface(),
							(DWORD_PTR) Pcnk()
							);
		if (lResult != ERROR_SUCCESS)
		{
			dwStatus = lResult;
			ThrowStaticException(dwStatus, IDS_NETIFACE_NOTIF_REG_ERROR, lpszName);
		}  // if:  error registering for network interface notifications

		// Register for registry notifications.
		if (Hkey() != NULL)
		{
			lResult = RegisterClusterNotify(
								GetClusterAdminApp()->HchangeNotifyPort(),
								(CLUSTER_CHANGE_REGISTRY_NAME
									| CLUSTER_CHANGE_REGISTRY_ATTRIBUTES
									| CLUSTER_CHANGE_REGISTRY_VALUE
									| CLUSTER_CHANGE_REGISTRY_SUBTREE),
								Hkey(),
								(DWORD_PTR) Pcnk()
								);
			if (lResult != ERROR_SUCCESS)
			{
				dwStatus = lResult;
				ThrowStaticException(dwStatus, IDS_NETIFACE_NOTIF_REG_ERROR, lpszName);
			}  // if:  error registering for registry notifications
		}  // if:  there is a key

		// Read the initial state.
		UpdateState();
	}  // try
	catch (CException *)
	{
		if (Hkey() != NULL)
		{
			ClusterRegCloseKey(Hkey());
			m_hkey = NULL;
		}  // if:  registry key opened
		if (Hnetiface() != NULL)
		{
			CloseClusterNetInterface(Hnetiface());
			m_hnetiface = NULL;
		}  // if:  network interface opened
		m_bReadOnly = TRUE;
		throw;
	}  // catch:  CException

}  //*** CNetInterface::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterface::ReadItem
//
//	Routine Description:
//		Read the item parameters from the cluster database.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		CNTException		Errors from CClusterItem::DwReadValue().
//		Any exceptions thrown by ConstructList or CList::AddTail().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterface::ReadItem(void)
{
	DWORD		dwStatus;
	DWORD		dwRetStatus = ERROR_SUCCESS;
	CWaitCursor wc;

	ASSERT_VALID(this);

	if (Hnetiface() != NULL)
	{
		m_rgProps[epropDescription].m_value.pstr = &m_strDescription;

		// Call the base class method.
		CClusterItem::ReadItem();

		// Read and parse the common properties.
		{
			CClusPropList	cpl;

			dwStatus = cpl.ScGetNetInterfaceProperties(
								Hnetiface(),
								CLUSCTL_NETINTERFACE_GET_COMMON_PROPERTIES
								);
			if (dwStatus == ERROR_SUCCESS)
				dwStatus = DwParseProperties(cpl);
			if (dwStatus != ERROR_SUCCESS)
				dwRetStatus = dwStatus;
		}  // Read and parse the common properties

		// Read and parse the read-only common properties.
		if (dwRetStatus == ERROR_SUCCESS)
		{
			CClusPropList	cpl;

			dwStatus = cpl.ScGetNetInterfaceProperties(
								Hnetiface(),
								CLUSCTL_NETINTERFACE_GET_RO_COMMON_PROPERTIES
								);
			if (dwStatus == ERROR_SUCCESS)
				dwStatus = DwParseProperties(cpl);
			if (dwStatus != ERROR_SUCCESS)
				dwRetStatus = dwStatus;
		}  // if:  no error yet

		// Find the node object.
		{
			CClusterNode *	pciNode;

			pciNode = Pdoc()->LpciNodes().PciNodeFromName(StrNode());
			if (pciNode != m_pciNode)
			{
				if (m_pciNode != NULL)
				{
					m_pciNode->RemoveNetInterface(this);
					m_pciNode->Release();
				}  // if:  old node
				m_pciNode = pciNode;
				if (m_pciNode != NULL)
				{
					m_pciNode->AddRef();
					m_pciNode->AddNetInterface(this);
				}  // if:  new node
			}  // if:  node changed (should never happen)
		}  // Find the node object

		// Find the network object.
		{
			CNetwork *	pciNetwork;

			pciNetwork = Pdoc()->LpciNetworks().PciNetworkFromName(StrNetwork());
			if (pciNetwork != m_pciNetwork)
			{
				if (m_pciNetwork != NULL)
				{
					m_pciNetwork->RemoveNetInterface(this);
					m_pciNetwork->Release();
				}  // if:  old network
				m_pciNetwork = pciNetwork;
				if (m_pciNetwork != NULL)
				{
					m_pciNetwork->AddRef();
					m_pciNetwork->AddNetInterface(this);
				}  // if:  new network
			}  // if:  netowrk changed (should never happen)
		}  // Find the network object

		// Read the characteristics flag.
		if (dwRetStatus == ERROR_SUCCESS)
		{
			DWORD	cbReturned;

			dwStatus = ClusterNetInterfaceControl(
							Hnetiface(),
							NULL,
							CLUSCTL_NETINTERFACE_GET_CHARACTERISTICS,
							NULL,
							NULL,
							&m_dwCharacteristics,
							sizeof(m_dwCharacteristics),
							&cbReturned
							);
			if (dwStatus != ERROR_SUCCESS)
				dwRetStatus = dwStatus;
			else
			{
				ASSERT(cbReturned == sizeof(m_dwCharacteristics));
			}  // else:  data retrieved successfully
		}  // if:  no error yet

		// Read the flags.
		if (dwRetStatus == ERROR_SUCCESS)
		{
			DWORD	cbReturned;

			dwStatus = ClusterNetInterfaceControl(
							Hnetiface(),
							NULL,
							CLUSCTL_NETINTERFACE_GET_FLAGS,
							NULL,
							NULL,
							&m_dwFlags,
							sizeof(m_dwFlags),
							&cbReturned
							);
			if (dwStatus != ERROR_SUCCESS)
				dwRetStatus = dwStatus;
			else
			{
				ASSERT(cbReturned == sizeof(m_dwFlags));
			}  // else:  data retrieved successfully
		}  // if:  no error yet

		// Construct the list of extensions.
		ReadExtensions();

	}  // if:  network interface is available

	// Read the initial state.
	UpdateState();

	// If any errors occurred, throw an exception.
	if (dwRetStatus != ERROR_SUCCESS)
	{
		m_bReadOnly = TRUE;
//		if (dwRetStatus != ERROR_FILE_NOT_FOUND)
			ThrowStaticException(dwRetStatus, IDS_READ_NETIFACE_PROPS_ERROR, StrName());
	}  // if:  error reading properties

	MarkAsChanged(FALSE);

}  //*** CNetInterface::ReadItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterface::ReadExtensions
//
//	Routine Description:
//		Read extension lists.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterface::ReadExtensions(void)
{
}  //*** CNetInterface::ReadExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterface::PlstrExtension
//
//	Routine Description:
//		Return the list of admin extensions.
//
//	Arguments:
//		None.
//
//	Return Value:
//		plstr		List of extensions.
//		NULL		No extension associated with this object.
//
//	Exceptions Thrown:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CStringList * CNetInterface::PlstrExtensions(void) const
{
	return &Pdoc()->PciCluster()->LstrNetworkExtensions();

}  //*** CNetInterface::PlstrExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterface::SetCommonProperties
//
//	Routine Description:
//		Set the common properties for this network interface in the cluster
//		database.
//
//	Arguments:
//		rstrDesc		[IN] Description string.
//		bValidateOnly	[IN] Only validate the data.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		Any exceptions thrown by CClusterItem::SetCommonProperties().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterface::SetCommonProperties(
	IN const CString &	rstrDesc,
	IN BOOL 			bValidateOnly
	)
{
	CNTException	nte(ERROR_SUCCESS, 0, NULL, NULL, FALSE /*bAutoDelete*/);

	m_rgProps[epropDescription].m_value.pstr = (CString *) &rstrDesc;

	try
	{
		CClusterItem::SetCommonProperties(bValidateOnly);
	}  // try
	catch (CNTException * pnte)
	{
		nte.SetOperation(
					pnte->Sc(),
					pnte->IdsOperation(),
					pnte->PszOperArg1(),
					pnte->PszOperArg2()
					);
	}  // catch:  CNTException

	m_rgProps[epropDescription].m_value.pstr = &m_strDescription;

	if (nte.Sc() != ERROR_SUCCESS)
		ThrowStaticException(
						nte.Sc(),
						nte.IdsOperation(),
						nte.PszOperArg1(),
						nte.PszOperArg2()
						);

}  //*** CNetInterface::SetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterface::DwSetCommonProperties
//
//	Routine Description:
//		Set the common properties for this network interface in the cluster
//		database.
//
//	Arguments:
//		rcpl			[IN] Property list to set.
//		bValidateOnly	[IN] Only validate the data.
//
//	Return Value:
//		Any status returned by ClusterNetInterfaceControl().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetInterface::DwSetCommonProperties(
	IN const CClusPropList &	rcpl,
	IN BOOL 					bValidateOnly
	)
{
	DWORD		dwStatus;
	CWaitCursor wc;

	ASSERT(Hnetiface());

	if ((rcpl.PbPropList() != NULL) && (rcpl.CbPropList() > 0))
	{
		DWORD	cbProps;
		DWORD	dwControl;

		if (bValidateOnly)
			dwControl = CLUSCTL_NETINTERFACE_VALIDATE_COMMON_PROPERTIES;
		else
			dwControl = CLUSCTL_NETINTERFACE_SET_COMMON_PROPERTIES;

		// Set common properties.
		dwStatus = ClusterNetInterfaceControl(
						Hnetiface(),
						NULL,	// hNode
						dwControl,
						rcpl.PbPropList(),
						rcpl.CbPropList(),
						NULL,	// lpOutBuffer
						0,		// nOutBufferSize
						&cbProps
						);
	}  // if:  there is data to set
	else
		dwStatus = ERROR_SUCCESS;

	return dwStatus;

}  //*** CNetInterface::DwSetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterface::UpdateState
//
//	Routine Description:
//		Update the current state of the item.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterface::UpdateState(void)
{
	CClusterAdminApp *	papp = GetClusterAdminApp();

	Trace(g_tagNetIFace, _T("(%s) (%s (%x)) - Updating state"), Pdoc()->StrNode(), StrName(), this);

	// Get the current state of the network interface.
	if (Hnetiface() == NULL)
		m_cnis = ClusterNetInterfaceStateUnknown;
	else
	{
		CWaitCursor wc;

		m_cnis = GetClusterNetInterfaceState(Hnetiface());
	}  // else:  network interface is available

	// Save the current state image index.
	switch (Cnis())
	{
		case ClusterNetInterfaceStateUnknown:
		case ClusterNetInterfaceUnavailable:
			m_iimgState = papp->Iimg(IMGLI_NETIFACE_UNKNOWN);
			break;
		case ClusterNetInterfaceUp:
			m_iimgState = papp->Iimg(IMGLI_NETIFACE);
			break;
		case ClusterNetInterfaceUnreachable:
			m_iimgState = papp->Iimg(IMGLI_NETIFACE_UNREACHABLE);
			break;
		case ClusterNetInterfaceFailed:
			m_iimgState = papp->Iimg(IMGLI_NETIFACE_FAILED);
			break;
		default:
			Trace(g_tagNetIFace, _T("(%s) (%s (%x)) - UpdateState: Unknown state '%d' for network interface '%s'"), Pdoc()->StrNode(), StrName(), this, Cnis(), StrName());
			m_iimgState = (UINT) -1;
			break;
	}  // switch:  Crs()

	// Call the base class method.
	CClusterItem::UpdateState();

}  //*** CNetInterface::UpdateState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterface::BGetColumnData
//
//	Routine Description:
//		Returns a string with the column data.
//
//	Arguments:
//		colid			[IN] Column ID.
//		rstrText		[OUT] String in which to return the text for the column.
//
//	Return Value:
//		TRUE		Column data returned.
//		FALSE		Column ID not recognized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetInterface::BGetColumnData(IN COLID colid, OUT CString & rstrText)
{
	BOOL	bSuccess;

	switch (colid)
	{
		case IDS_COLTEXT_STATE:
			GetStateName(rstrText);
			bSuccess = TRUE;
			break;
		case IDS_COLTEXT_NODE:
			rstrText = StrNode();
			bSuccess = TRUE;
			break;
		case IDS_COLTEXT_NETWORK:
			if (PciNetwork() == NULL)
				rstrText = StrNetwork();
			else
				rstrText = PciNetwork()->StrName();
			bSuccess = TRUE;
			break;
		case IDS_COLTEXT_ADAPTER:
			rstrText = StrAdapter();
			bSuccess = TRUE;
			break;
		case IDS_COLTEXT_ADDRESS:
			rstrText = StrAddress();
			bSuccess = TRUE;
			break;
		default:
			bSuccess = CClusterItem::BGetColumnData(colid, rstrText);
			break;
	}  // switch:  colid

	return bSuccess;

}  //*** CNetInterface::BGetColumnData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterface::GetTreeName
//
//	Routine Description:
//		Returns a string to be used in a tree control.
//
//	Arguments:
//		rstrName	[OUT] String in which to return the name.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
void CNetInterface::GetTreeName(OUT CString & rstrName) const
{
	CString 	strState;

	GetStateName(strState);
	rstrName.Format(_T("%s (%s)"), StrName(), strState);

}  //*** CNetInterface::GetTreeName()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterface::GetStateName
//
//	Routine Description:
//		Returns a string with the name of the current state.
//
//	Arguments:
//		rstrState	[OUT] String in which to return the name of the current state.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterface::GetStateName(OUT CString & rstrState) const
{
	switch (Cnis())
	{
		case ClusterNetInterfaceStateUnknown:
			rstrState.LoadString(IDS_UNKNOWN);
			break;
		case ClusterNetInterfaceUp:
			rstrState.LoadString(IDS_UP);
			break;
		case ClusterNetInterfaceUnreachable:
			rstrState.LoadString(IDS_UNREACHABLE);
			break;
		case ClusterNetInterfaceFailed:
			rstrState.LoadString(IDS_FAILED);
			break;
		case ClusterNetInterfaceUnavailable:
			rstrState.LoadString(IDS_UNAVAILABLE);
			break;
		default:
			rstrState.Empty();
			break;
	}  // switch:  Crs()

}  //*** CNetInterface::GetStateName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterface::OnUpdateProperties
//
//	Routine Description:
//		Determines whether menu items corresponding to ID_FILE_PROPERTIES
//		should be enabled or not.
//
//	Arguments:
//		pCmdUI		[IN OUT] Command routing object.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterface::OnUpdateProperties(CCmdUI * pCmdUI)
{
	pCmdUI->Enable(TRUE);

}  //*** CNetInterface::OnUpdateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterface::BDisplayProperties
//
//	Routine Description:
//		Display properties for the object.
//
//	Arguments:
//		bReadOnly	[IN] Don't allow edits to the object properties.
//
//	Return Value:
//		TRUE	OK pressed.
//		FALSE	OK not pressed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetInterface::BDisplayProperties(IN BOOL bReadOnly)
{
	BOOL					bChanged = FALSE;
	CNetInterfacePropSheet	sht(AfxGetMainWnd());

	// Do this in case this object is deleted while we are operating on it.
	AddRef();

	// If the object has changed, read it.
	if (BChanged())
		ReadItem();

	// Display the property sheet.
	try
	{
		sht.SetReadOnly(bReadOnly);
		if (sht.BInit(this, IimgObjectType()))
			bChanged = ((sht.DoModal() == IDOK) && !bReadOnly);
	}  // try
	catch (CException * pe)
	{
		pe->Delete();
	}  // catch:  CException

	Release();
	return bChanged;

}  //*** CNetInterface::BDisplayProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterface::OnClusterNotify
//
//	Routine Description:
//		Handler for the WM_CAM_CLUSTER_NOTIFY message.
//		Processes cluster notifications for this object.
//
//	Arguments:
//		pnotify 	[IN OUT] Object describing the notification.
//
//	Return Value:
//		Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CNetInterface::OnClusterNotify(IN OUT CClusterNotify * pnotify)
{
	ASSERT(pnotify != NULL);
	ASSERT_VALID(this);

	try
	{
		switch (pnotify->m_dwFilterType)
		{
			case CLUSTER_CHANGE_NETINTERFACE_STATE:
				Trace(g_tagNetIFaceNotify, _T("(%s) - Network Interface '%s' (%x) state changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
				UpdateState();
				break;

			case CLUSTER_CHANGE_NETINTERFACE_DELETED:
				Trace(g_tagNetIFaceNotify, _T("(%s) - Network Interface '%s' (%x) deleted (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
				if (Pdoc()->BClusterAvailable())
					Delete();
				break;

			case CLUSTER_CHANGE_NETINTERFACE_PROPERTY:
				Trace(g_tagNetIFaceNotify, _T("(%s) - Network Interface '%s' (%x) properties changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
				if (Pdoc()->BClusterAvailable())
					ReadItem();
				break;

			case CLUSTER_CHANGE_REGISTRY_NAME:
				Trace(g_tagNetIFaceNotify, _T("(%s) - Registry namespace '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
				MarkAsChanged();
				break;

			case CLUSTER_CHANGE_REGISTRY_ATTRIBUTES:
				Trace(g_tagNetIFaceNotify, _T("(%s) - Registry attributes for '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
				MarkAsChanged();
				break;

			case CLUSTER_CHANGE_REGISTRY_VALUE:
				Trace(g_tagNetIFaceNotify, _T("(%s) - Registry value '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
				MarkAsChanged();
				break;

			default:
				Trace(g_tagNetIFaceNotify, _T("(%s) - Unknown network interface notification (%x) for '%s' (%x) (%s)"), Pdoc()->StrNode(), pnotify->m_dwFilterType, StrName(), this, pnotify->m_strName);
		}  // switch:  dwFilterType
	}  // try
	catch (CException * pe)
	{
		// Don't display anything on notification errors.
		// If it's really a problem, the user will see it when
		// refreshing the view.
		//pe->ReportError();
		pe->Delete();
	}  // catch:  CException

	delete pnotify;
	return 0;

}  //*** CNetInterface::OnClusterNotify()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DeleteAllItemData
//
//	Routine Description:
//		Deletes all item data in a CList.
//
//	Arguments:
//		rlp 	[IN OUT] List whose data is to be deleted.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef NEVER
void DeleteAllItemData(IN OUT CNetInterfaceList & rlp)
{
	POSITION		pos;
	CNetInterface * pci;

	// Delete all the items in the Contained list.
	pos = rlp.GetHeadPosition();
	while (pos != NULL)
	{
		pci = rlp.GetNext(pos);
		ASSERT_VALID(pci);
//		Trace(g_tagClusItemDelete, _T("DeleteAllItemData(rlp) - Deleting network interface cluster item '%s' (%x)"), pci->StrName(), pci);
		pci->Delete();
	}  // while:  more items in the list

}  //*** DeleteAllItemData()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\netiface.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		NetIFace.h
//
//	Abstract:
//		Definition of the CNetInterface class.
//
//	Implementation File:
//		NetIFace.cpp
//
//	Author:
//		David Potter (davidp)	May 28, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _NETIFACE_H_
#define _NETIFACE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNetInterface;
class CNetInterfaceList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterNode;
class CNetwork;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSITEM_H_
#include "ClusItem.h"	// for CClusterItem
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CObjectProperty, CClusPropList
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetInterface command target
/////////////////////////////////////////////////////////////////////////////

class CNetInterface : public CClusterItem
{
	DECLARE_DYNCREATE(CNetInterface)

// Construction
public:
	CNetInterface(void);		// protected constructor used by dynamic creation
	void					Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName);

protected:
	void					CommonConstruct(void);

// Attributes
protected:
	HNETINTERFACE			m_hnetiface;
	CLUSTER_NETINTERFACE_STATE	m_cnis;

	CString					m_strNode;
	CClusterNode *			m_pciNode;
	CString					m_strNetwork;
	CNetwork *				m_pciNetwork;
	CString					m_strAdapter;
	CString					m_strAddress;
	DWORD					m_dwCharacteristics;
	DWORD					m_dwFlags;

	enum
	{
		epropName = 0,
		epropNode,
		epropNetwork,
		epropAdapter,
		epropAddress,
		epropDescription,
		epropMAX
	};

	CObjectProperty		m_rgProps[epropMAX];

public:
	HNETINTERFACE			Hnetiface(void) const				{ return m_hnetiface; }
	CLUSTER_NETINTERFACE_STATE	Cnis(void) const			    { return m_cnis; }

	const CString &			StrNode(void) const					{ return m_strNode; }
	CClusterNode *			PciNode(void) const					{ return m_pciNode; }
	const CString &			StrNetwork(void) const				{ return m_strNetwork; }
	CNetwork *				PciNetwork(void) const				{ return m_pciNetwork; }
	const CString &			StrAdapter(void) const				{ return m_strAdapter; }
	const CString &			StrAddress(void) const				{ return m_strAddress; }
	DWORD					DwCharacteristics(void) const		{ return m_dwCharacteristics; }
	DWORD					DwFlags(void) const		            { return m_dwFlags; }

	void					GetStateName(OUT CString & rstrState) const;

// Operations
public:
	void					ReadExtensions(void);

	void					SetCommonProperties(
								IN const CString &	rstrDesc,
								IN BOOL				bValidateOnly
								);
	void					SetCommonProperties(
								IN const CString &	rstrDesc
								)
	{
		SetCommonProperties(rstrDesc, FALSE /*bValidateOnly*/);
	}
	void					ValidateCommonProperties(
								IN const CString &	rstrDesc
								)
	{
		SetCommonProperties(rstrDesc, TRUE /*bValidateOnly*/);
	}

// Overrides
public:
	virtual void			Cleanup(void);
	virtual void			ReadItem(void);
	virtual void			UpdateState(void);
	virtual	BOOL			BGetColumnData(IN COLID colid, OUT CString & rstrText);
	virtual BOOL			BDisplayProperties(IN BOOL bReadOnly = FALSE);

	virtual const CStringList *	PlstrExtensions(void) const;

#ifdef _DISPLAY_STATE_TEXT_IN_TREE
	virtual void			GetTreeName(OUT CString & rstrName) const;
#endif

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetInterface)
	//}}AFX_VIRTUAL

	virtual LRESULT			OnClusterNotify(IN OUT CClusterNotify * pnotify);

protected:
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }
	virtual DWORD					DwSetCommonProperties(IN const CClusPropList & rcpl, IN BOOL bValidateOnly = FALSE);

// Implementation
public:
	virtual ~CNetInterface(void);

public:
	// Generated message map functions
	//{{AFX_MSG(CNetInterface)
	afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

};  //*** class CNetInterface

/////////////////////////////////////////////////////////////////////////////
// CNetInterfaceList
/////////////////////////////////////////////////////////////////////////////

class CNetInterfaceList : public CClusterItemList
{
public:
	CNetInterface *		PciNetInterfaceFromName(
						IN LPCTSTR		pszName,
						OUT POSITION *	ppos = NULL
						)
	{
		return (CNetInterface *) PciFromName(pszName, ppos);
	}

};  //*** class CNetInterfaceList

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

//void DeleteAllItemData(IN OUT CNetInterfaceList & rlp);

#ifdef _DEBUG
class CTraceTag;
extern CTraceTag g_tagNetIFace;
extern CTraceTag g_tagNetIFaceNotify;
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _NETIFACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\netiprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		NetIProp.cpp
//
//	Abstract:
//		Implementation of the network interface property sheet and pages.
//
//	Author:
//		David Potter (davidp)	June 9, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "NetIProp.h"
#include "HelpData.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetworkPropSheet
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CNetInterfacePropSheet, CBasePropertySheet)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNetInterfacePropSheet, CBasePropertySheet)
	//{{AFX_MSG_MAP(CNetInterfacePropSheet)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfacePropSheet::CNetInterfacePropSheet
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pParentWnd	[IN OUT] Parent window for this property sheet.
//		iSelectPage	[IN] Page to show first.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetInterfacePropSheet::CNetInterfacePropSheet(
	IN OUT CWnd *		pParentWnd,
	IN UINT				iSelectPage
	)
	: CBasePropertySheet(pParentWnd, iSelectPage)
{
	m_rgpages[0] = &PageGeneral();

}  //*** CNetInterfacePropSheet::CNetInterfacePropSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfacePropSheet::BInit
//
//	Routine Description:
//		Initialize the property sheet.
//
//	Arguments:
//		pci			[IN OUT] Cluster item whose properties are to be displayed.
//		iimgIcon	[IN] Index in the large image list for the image to use
//					  as the icon on each page.
//
//	Return Value:
//		TRUE		Property sheet initialized successfully.
//		FALSE		Error initializing property sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetInterfacePropSheet::BInit(
	IN OUT CClusterItem *	pci,
	IN IIMG					iimgIcon
	)
{
	// Call the base class method.
	if (!CBasePropertySheet::BInit(pci, iimgIcon))
		return FALSE;

	// Set the read-only flag if the handles are invalid.
	m_bReadOnly = PciNetIFace()->BReadOnly()
					|| (PciNetIFace()->Cnis() == ClusterNetInterfaceStateUnknown);

	return TRUE;

}  //*** CNetInterfacePropSheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfacePropSheet::Ppages
//
//	Routine Description:
//		Returns the array of pages to add to the property sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Page array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage ** CNetInterfacePropSheet::Ppages(void)
{
	return m_rgpages;

}  //*** CNetworkPropSheet::Pppges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfacePropSheet::Cpages
//
//	Routine Description:
//		Returns the count of pages in the array.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Count of pages in the array.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CNetInterfacePropSheet::Cpages(void)
{
	return sizeof(m_rgpages) / sizeof(CBasePropertyPage *);

}  //*** CNetInterfacePropSheet::Cpages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNetInterfaceGeneralPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNetInterfaceGeneralPage, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNetInterfaceGeneralPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CNetInterfaceGeneralPage)
	//}}AFX_MSG_MAP
	ON_EN_CHANGE(IDC_PP_NETIFACE_DESC, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceGeneralPage::CNetInterfaceGeneralPage
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetInterfaceGeneralPage::CNetInterfaceGeneralPage(void)
	: CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_NETIFACE_GENERAL)
{
	//{{AFX_DATA_INIT(CNetInterfaceGeneralPage)
	m_strNode = _T("");
	m_strNetwork = _T("");
	m_strDesc = _T("");
	m_strAdapter = _T("");
	m_strAddress = _T("");
	m_strName = _T("");
	m_strState = _T("");
	//}}AFX_DATA_INIT

}  //*** CNetInterfaceGeneralPage::CNetInterfaceGeneralPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceGeneralPage::BInit
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		psht		[IN OUT] Property sheet to which this page belongs.
//
//	Return Value:
//		TRUE		Page initialized successfully.
//		FALSE		Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetInterfaceGeneralPage::BInit(IN OUT CBaseSheet * psht)
{
	BOOL	bSuccess;

	ASSERT_KINDOF(CNetInterfacePropSheet, psht);

	bSuccess = CBasePropertyPage::BInit(psht);
	if (bSuccess)
	{
		try
		{
			m_strNode = PciNetIFace()->StrNode();
			m_strNetwork = PciNetIFace()->StrNetwork();
			m_strDesc = PciNetIFace()->StrDescription();
			m_strAdapter = PciNetIFace()->StrAdapter();
			m_strAddress = PciNetIFace()->StrAddress();
			m_strName = PciNetIFace()->StrName();
			PciNetIFace()->GetStateName(m_strState);
		} // try
		catch (CException * pe)
		{
			pe->ReportError();
			pe->Delete();
			bSuccess = FALSE;
		}  // catch:  CException
	}  //  if:  base class method was successful

	return bSuccess;

}  //*** CNetInterfaceGeneralPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceGeneralPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetInterfaceGeneralPage::DoDataExchange(CDataExchange * pDX)
{
	CBasePropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNetInterfaceGeneralPage)
	DDX_Control(pDX, IDC_PP_NETIFACE_DESC, m_editDesc);
	DDX_Text(pDX, IDC_PP_NETIFACE_NODE, m_strNode);
	DDX_Text(pDX, IDC_PP_NETIFACE_NETWORK, m_strNetwork);
	DDX_Text(pDX, IDC_PP_NETIFACE_DESC, m_strDesc);
	DDX_Text(pDX, IDC_PP_NETIFACE_ADAPTER, m_strAdapter);
	DDX_Text(pDX, IDC_PP_NETIFACE_ADDRESS, m_strAddress);
	DDX_Text(pDX, IDC_PP_NETIFACE_NAME, m_strName);
	DDX_Text(pDX, IDC_PP_NETIFACE_CURRENT_STATE, m_strState);
	//}}AFX_DATA_MAP

}  //*** CNetInterfaceGeneralPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceGeneralPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Focus needs to be set.
//		FALSE	Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetInterfaceGeneralPage::OnInitDialog(void)
{
	CBasePropertyPage::OnInitDialog();

	// If read-only, set all controls to be either disabled or read-only.
	if (BReadOnly())
	{
		m_editDesc.SetReadOnly(TRUE);
	}  // if:  sheet is read-only

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CNetInterfaceGeneralPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetInterfaceGeneralPage::OnApply
//
//	Routine Description:
//		Handler for when the Apply button is pressed.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetInterfaceGeneralPage::OnApply(void)
{
	// Set the data from the page in the cluster item.
	try
	{
		CWaitCursor	wc;

		PciNetIFace()->SetCommonProperties(m_strDesc);
	}  // try
	catch (CException * pe)
	{
		pe->ReportError();
		pe->Delete();
		return FALSE;
	}  // catch:  CException

	return CBasePropertyPage::OnApply();

}  //*** CNetInterfaceGeneralPage::OnApply()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\moveres.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		MoveRes.cpp
//
//	Abstract:
//		Definition of the CMoveResourcesDlg dialog.
//
//	Implementation File:
//		MoveRes.h
//
//	Author:
//		David Potter (davidp)	April 1, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _MOVERES_H_
#define _MOVERES_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESOURCE_H_
#include "resource.h"
#define _RESOURCE_H_
#endif

#ifndef _BASEDLG_H_
#include "BaseDlg.h"	// for CBaseDialog
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CMoveResourcesDlg;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CResource;
class CResourceList;

/////////////////////////////////////////////////////////////////////////////
// CMoveResourcesDlg class
/////////////////////////////////////////////////////////////////////////////

class CMoveResourcesDlg : public CBaseDialog
{
// Construction
public:
	CMoveResourcesDlg(
		IN CResource *				pciRes,
		IN const CResourceList *	plpci,
		IN OUT CWnd *				pParent = NULL
		);

// Dialog Data
	//{{AFX_DATA(CMoveResourcesDlg)
	enum { IDD = IDD_MOVE_RESOURCES };
	CListCtrl	m_lcResources;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMoveResourcesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CResource *				m_pciRes;
	const CResourceList *	m_plpci;
	int						m_nSortDirection;
	int						m_nSortColumn;

	const CResource *		PciRes(void) const		{ return m_pciRes; }
	const CResourceList *	Plpci(void) const		{ return m_plpci; }

	static int CALLBACK		CompareItems(LPARAM lparam1, LPARAM lparam2, LPARAM lparamSort);

	// Generated message map functions
	//{{AFX_MSG(CMoveResourcesDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnDblClkResourcesList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CMoveResourcesDlg

/////////////////////////////////////////////////////////////////////////////

#endif // _MOVERES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\netiprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		NetIProp.h
//
//	Abstract:
//		Definition of the network interface property sheet and pages.
//
//	Author:
//		David Potter (davidp)	June 9, 1997
//
//	Implementation File:
//		NetIProp.cpp
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _NETIPROP_H_
#define _NETIPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePPag.h"	// for CBasePropertyPage
#endif

#ifndef _BASESHT_H_
#include "BasePSht.h"	// for CBasePropertySheet
#endif

#ifndef _NETWORK_H_
#include "NetIFace.h"	// for CNetInterface
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNetInterfaceGeneralPage;
class CNetInterfacePropSheet;

/////////////////////////////////////////////////////////////////////////////
// CNetInterfaceGeneralPage dialog
/////////////////////////////////////////////////////////////////////////////

class CNetInterfaceGeneralPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CNetInterfaceGeneralPage)

// Construction
public:
	CNetInterfaceGeneralPage();

	virtual	BOOL		BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CNetInterfaceGeneralPage)
	enum { IDD = IDD_PP_NETIFACE_GENERAL };
	CEdit	m_editDesc;
	CString	m_strNode;
	CString	m_strNetwork;
	CString	m_strDesc;
	CString	m_strAdapter;
	CString	m_strAddress;
	CString	m_strName;
	CString	m_strState;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNetInterfaceGeneralPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CNetInterfacePropSheet *	PshtNetIFace(void) const	{ return (CNetInterfacePropSheet *) Psht(); }
	CNetInterface *				PciNetIFace(void) const		{ return (CNetInterface *) Pci(); }

	// Generated message map functions
	//{{AFX_MSG(CNetInterfaceGeneralPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNetInterfaceGeneralPage

/////////////////////////////////////////////////////////////////////////////
// CNetInterfacePropSheet
/////////////////////////////////////////////////////////////////////////////

class CNetInterfacePropSheet : public CBasePropertySheet
{
	DECLARE_DYNAMIC(CNetInterfacePropSheet)

// Construction
public:
	CNetInterfacePropSheet(
		IN OUT CWnd *	pParentWnd = NULL,
		IN UINT			iSelectPage = 0
		);
	virtual BOOL					BInit(
										IN OUT CClusterItem *	pciCluster,
										IN IIMG					iimgIcon
										);

// Attributes
protected:
	CBasePropertyPage *				m_rgpages[1];

	// Pages
	CNetInterfaceGeneralPage		m_pageGeneral;

	CNetInterfaceGeneralPage &		PageGeneral(void)		{ return m_pageGeneral; }

public:
	CNetInterface *					PciNetIFace(void) const	{ return (CNetInterface *) Pci(); }

// Operations

// Overrides
protected:
	virtual CBasePropertyPage **	Ppages(void);
	virtual int						Cpages(void);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetInterfacePropSheet)
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CNetInterfacePropSheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNetInterfacePropSheet

/////////////////////////////////////////////////////////////////////////////

#endif // _NETIPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\netprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		NetProp.cpp
//
//	Abstract:
//		Implementation of the network property sheet and pages.
//
//	Author:
//		David Potter (davidp)	June 9, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "NetProp.h"
#include "HelpData.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetworkPropSheet
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CNetworkPropSheet, CBasePropertySheet)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNetworkPropSheet, CBasePropertySheet)
	//{{AFX_MSG_MAP(CNetworkPropSheet)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetworkPropSheet::CNetworkPropSheet
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pParentWnd	[IN OUT] Parent window for this property sheet.
//		iSelectPage	[IN] Page to show first.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetworkPropSheet::CNetworkPropSheet(
	IN OUT CWnd *		pParentWnd,
	IN UINT				iSelectPage
	)
	: CBasePropertySheet(pParentWnd, iSelectPage)
{
	m_rgpages[0] = &PageGeneral();

}  //*** CNetworkPropSheet::CNetworkPropSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetworkPropSheet::BInit
//
//	Routine Description:
//		Initialize the property sheet.
//
//	Arguments:
//		pci			[IN OUT] Cluster item whose properties are to be displayed.
//		iimgIcon	[IN] Index in the large image list for the image to use
//					  as the icon on each page.
//
//	Return Value:
//		TRUE		Property sheet initialized successfully.
//		FALSE		Error initializing property sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetworkPropSheet::BInit(
	IN OUT CClusterItem *	pci,
	IN IIMG					iimgIcon
	)
{
	// Call the base class method.
	if (!CBasePropertySheet::BInit(pci, iimgIcon))
		return FALSE;

	// Set the read-only flag if the handles are invalid.
	m_bReadOnly = PciNet()->BReadOnly()
					|| (PciNet()->Cns() == ClusterNetworkStateUnknown);

	return TRUE;

}  //*** CNetworkPropSheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetworkPropSheet::Ppages
//
//	Routine Description:
//		Returns the array of pages to add to the property sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Page array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage ** CNetworkPropSheet::Ppages(void)
{
	return m_rgpages;

}  //*** CNetworkPropSheet::Pppges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetworkPropSheet::Cpages
//
//	Routine Description:
//		Returns the count of pages in the array.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Count of pages in the array.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CNetworkPropSheet::Cpages(void)
{
	return sizeof(m_rgpages) / sizeof(CBasePropertyPage *);

}  //*** CNetworkPropSheet::Cpages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNetworkGeneralPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNetworkGeneralPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNetworkGeneralPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CNetworkGeneralPage)
	ON_BN_CLICKED(IDC_PP_NET_ROLE_ENABLE_NETWORK, OnEnableNetwork)
	//}}AFX_MSG_MAP
	ON_EN_CHANGE(IDC_PP_NET_NAME, CBasePropertyPage::OnChangeCtrl)
	ON_EN_CHANGE(IDC_PP_NET_DESC, CBasePropertyPage::OnChangeCtrl)
	ON_BN_CLICKED(IDC_PP_NET_ROLE_ALL_COMM, CBasePropertyPage::OnChangeCtrl)
	ON_BN_CLICKED(IDC_PP_NET_ROLE_INTERNAL_ONLY, CBasePropertyPage::OnChangeCtrl)
	ON_BN_CLICKED(IDC_PP_NET_ROLE_CLIENT_ONLY, CBasePropertyPage::OnChangeCtrl)
	ON_EN_CHANGE(IDC_PP_NET_ADDRESS_MASK, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetworkGeneralPage::CNetworkGeneralPage
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetworkGeneralPage::CNetworkGeneralPage(void)
	: CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_NET_GENERAL)
{
	//{{AFX_DATA_INIT(CNetworkGeneralPage)
	m_strName = _T("");
	m_strDesc = _T("");
	m_bEnabled = FALSE;
	m_nRole = -1;
	m_strAddressMask = _T("");
	m_strState = _T("");
	//}}AFX_DATA_INIT

}  //*** CNetworkGeneralPage::CNetworkGeneralPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetworkGeneralPage::BInit
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		psht		[IN OUT] Property sheet to which this page belongs.
//
//	Return Value:
//		TRUE		Page initialized successfully.
//		FALSE		Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetworkGeneralPage::BInit(IN OUT CBaseSheet * psht)
{
	BOOL	bSuccess;

	ASSERT_KINDOF(CNetworkPropSheet, psht);

	bSuccess = CBasePropertyPage::BInit(psht);
	if (bSuccess)
	{
		try
		{
			m_strName = PciNet()->StrName();
			m_strDesc = PciNet()->StrDescription();
			m_cnr = PciNet()->Cnr();
			m_strAddressMask = PciNet()->StrAddressMask();
			PciNet()->GetStateName(m_strState);

			if (m_cnr == ClusterNetworkRoleNone)
			{
				m_bEnabled = FALSE;
				m_nRole = -1;
			}  // if:  network is disabled
			else
			{
				m_bEnabled = TRUE;
				if (m_cnr == ClusterNetworkRoleClientAccess)
					m_nRole = 0;
				else if (m_cnr == ClusterNetworkRoleInternalUse)
					m_nRole = 1;
				else if (m_cnr == ClusterNetworkRoleInternalAndClient)
					m_nRole = 2;
				else
				{
					ASSERT(0);
					m_nRole = -1;
					m_bEnabled = FALSE;
				}  // else;  Unknown role
			}  // else:  network not disabled
		} // try
		catch (CException * pe)
		{
			pe->ReportError();
			pe->Delete();
			bSuccess = FALSE;
		}  // catch:  CException
	}  //  if:  base class method was successful

	return bSuccess;

}  //*** CNetworkGeneralPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetworkGeneralPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetworkGeneralPage::DoDataExchange(CDataExchange* pDX)
{
	CBasePropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNetworkGeneralPage)
	DDX_Control(pDX, IDC_PP_NET_ADDRESS_MASK, m_editAddressMask);
	DDX_Control(pDX, IDC_PP_NET_ROLE_ENABLE_NETWORK, m_ckbEnable);
	DDX_Control(pDX, IDC_PP_NET_ROLE_CLIENT_ONLY, m_rbRoleClientOnly);
	DDX_Control(pDX, IDC_PP_NET_ROLE_INTERNAL_ONLY, m_rbRoleInternalOnly);
	DDX_Control(pDX, IDC_PP_NET_ROLE_ALL_COMM, m_rbRoleAllComm);
	DDX_Control(pDX, IDC_PP_NET_DESC, m_editDesc);
	DDX_Control(pDX, IDC_PP_NET_NAME, m_editName);
	DDX_Text(pDX, IDC_PP_NET_NAME, m_strName);
	DDX_Text(pDX, IDC_PP_NET_DESC, m_strDesc);
	DDX_Text(pDX, IDC_PP_NET_ADDRESS_MASK, m_strAddressMask);
	DDX_Text(pDX, IDC_PP_NET_CURRENT_STATE, m_strState);
	DDX_Radio(pDX, IDC_PP_NET_ROLE_CLIENT_ONLY, m_nRole);
	DDX_Check(pDX, IDC_PP_NET_ROLE_ENABLE_NETWORK, m_bEnabled);
	//}}AFX_DATA_MAP

	if (pDX->m_bSaveAndValidate)
	{
		// Validate the name.
		if (!NcIsValidConnectionName(m_strName))
		{
			ThrowStaticException((IDS) IDS_INVALID_NETWORK_CONNECTION_NAME);
		} // if:  error validating the name

		// Convert address and address mask.
		if (m_bEnabled)
		{
			switch (m_nRole)
			{
				case 0:
					m_cnr = ClusterNetworkRoleClientAccess;
					break;
				case 1:
					m_cnr = ClusterNetworkRoleInternalUse;
					break;
				case 2:
					m_cnr = ClusterNetworkRoleInternalAndClient;
					break;
				default:
					ASSERT(0);
					break;
			}  // switch:  m_nRole
		}  // if:  network is enabled
		else
			m_cnr = ClusterNetworkRoleNone;
	}  // if:  saving data from dialog

}  //*** CNetworkGeneralPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetworkGeneralPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Focus needs to be set.
//		FALSE	Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetworkGeneralPage::OnInitDialog(void)
{
	CBasePropertyPage::OnInitDialog();

	// If read-only, set all controls to be either disabled or read-only.
	if (BReadOnly())
	{
		m_editName.SetReadOnly(TRUE);
		m_editDesc.SetReadOnly(TRUE);
		m_ckbEnable.EnableWindow(FALSE);
		m_rbRoleAllComm.EnableWindow(FALSE);
		m_rbRoleInternalOnly.EnableWindow(FALSE);
		m_rbRoleClientOnly.EnableWindow(FALSE);
		m_editAddressMask.SetReadOnly(TRUE);
	}  // if:  sheet is read-only
	else
	{
		m_editName.SetLimitText(NETCON_MAX_NAME_LEN);
	}  // else:  sheet is read/write

	OnEnableNetwork();

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CNetworkGeneralPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetworkGeneralPage::OnApply
//
//	Routine Description:
//		Handler for when the Apply button is pressed.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetworkGeneralPage::OnApply(void)
{
	// Set the data from the page in the cluster item.
	try
	{
		CWaitCursor	wc;

		PciNet()->SetName(m_strName);
		PciNet()->SetCommonProperties(
							m_strDesc,
							m_cnr
							);
	}  // try
	catch (CException * pe)
	{
		pe->ReportError();
		pe->Delete();
		return FALSE;
	}  // catch:  CException

	return CBasePropertyPage::OnApply();

}  //*** CNetworkGeneralPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNetworkGeneralPage::OnEnableNetwork
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the Enable network checkbox.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetworkGeneralPage::OnEnableNetwork(void)
{
	BOOL	bEnabled;

	OnChangeCtrl();

	bEnabled = (!BReadOnly() && (m_ckbEnable.GetCheck() == BST_CHECKED));

	m_rbRoleAllComm.EnableWindow(bEnabled);
	m_rbRoleInternalOnly.EnableWindow(bEnabled);
	m_rbRoleClientOnly.EnableWindow(bEnabled);
	GetDlgItem(IDC_PP_NET_ROLE_CAPTION)->EnableWindow(bEnabled);

	if (   bEnabled
		&& (m_rbRoleAllComm.GetCheck() != BST_CHECKED)
		&& (m_rbRoleInternalOnly.GetCheck() != BST_CHECKED)
		&& (m_rbRoleClientOnly.GetCheck() != BST_CHECKED))
		m_rbRoleAllComm.SetCheck(BST_CHECKED);

}  //*** CNetworkGeneralPage::OnEnableNetwork()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\netprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		NetProp.h
//
//	Abstract:
//		Definition of the network property sheet and pages.
//
//	Author:
//		David Potter (davidp)	June 9, 1997
//
//	Implementation File:
//		NetProp.cpp
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _NETPROP_H_
#define _NETPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePPag.h"	// for CBasePropertyPage
#endif

#ifndef _BASESHT_H_
#include "BasePSht.h"	// for CBasePropertySheet
#endif

#ifndef _NETWORK_H_
#include "Network.h"	// for CNetwork
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNetworkGeneralPage;
class CNetworkPropSheet;

/////////////////////////////////////////////////////////////////////////////
// CNetworkGeneralPage dialog
/////////////////////////////////////////////////////////////////////////////

class CNetworkGeneralPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CNetworkGeneralPage)

// Construction
public:
	CNetworkGeneralPage(void);

	virtual	BOOL		BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CNetworkGeneralPage)
	enum { IDD = IDD_PP_NET_GENERAL };
	CEdit	m_editAddressMask;
	CEdit	m_editDesc;
	CEdit	m_editName;
	CButton	m_rbRoleClientOnly;
	CButton	m_rbRoleInternalOnly;
	CButton	m_rbRoleAllComm;
	CButton	m_ckbEnable;
	CString	m_strName;
	CString	m_strDesc;
	CString	m_strAddressMask;
	CString	m_strState;
	int		m_nRole;
	BOOL	m_bEnabled;
	//}}AFX_DATA
	CLUSTER_NETWORK_ROLE	m_cnr;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNetworkGeneralPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CNetworkPropSheet *	PshtNetwork(void) const	{ return (CNetworkPropSheet *) Psht(); }
	CNetwork *			PciNet(void) const		{ return (CNetwork *) Pci(); }

	// Generated message map functions
	//{{AFX_MSG(CNetworkGeneralPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnEnableNetwork();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNetworkGeneralPage

/////////////////////////////////////////////////////////////////////////////
// CNetworkPropSheet
/////////////////////////////////////////////////////////////////////////////

class CNetworkPropSheet : public CBasePropertySheet
{
	DECLARE_DYNAMIC(CNetworkPropSheet)

// Construction
public:
	CNetworkPropSheet(
		IN OUT CWnd *	pParentWnd = NULL,
		IN UINT			iSelectPage = 0
		);
	virtual BOOL					BInit(
										IN OUT CClusterItem *	pciCluster,
										IN IIMG					iimgIcon
										);

// Attributes
protected:
	CBasePropertyPage *				m_rgpages[1];

	// Pages
	CNetworkGeneralPage				m_pageGeneral;

	CNetworkGeneralPage &			PageGeneral(void)		{ return m_pageGeneral; }

public:
	CNetwork *						PciNet(void) const	{ return (CNetwork *) Pci(); }

// Operations

// Overrides
protected:
	virtual CBasePropertyPage **	Ppages(void);
	virtual int						Cpages(void);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetworkPropSheet)
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CNetworkPropSheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNetworkPropSheet

/////////////////////////////////////////////////////////////////////////////

#endif // _NETPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\notify.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		Notify.h
//
//	Abstract:
//		Definition of the CNotify class.
//
//	Implementation File:
//		Notify.cpp
//
//	Author:
//		David Potter (davidp)	May 22, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _NOTIFY_H_
#define _NOTIFY_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterNotifyKey;
class CClusterNotify;
class CClusterNotifyContext;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterDoc;
class CClusterItem;

/////////////////////////////////////////////////////////////////////////////
// ClusterNotifyKeyType
/////////////////////////////////////////////////////////////////////////////

enum ClusterNotifyKeyType
{
	cnktUnknown,
	cnktDoc,
	cnktClusterItem
};

/////////////////////////////////////////////////////////////////////////////
// CNotifyKey
/////////////////////////////////////////////////////////////////////////////

class CClusterNotifyKey
{
public:
	CClusterNotifyKey(IN CClusterDoc * pdoc);
	CClusterNotifyKey(IN CClusterItem * pci, IN LPCTSTR pszName);

	ClusterNotifyKeyType	m_cnkt;
	CString					m_strName;
	union
	{
		CClusterDoc *		m_pdoc;
		CClusterItem *		m_pci;
	};

};  //*** class CNotifyKey

typedef CList<CClusterNotifyKey *, CClusterNotifyKey *> CClusterNotifyKeyList;

/////////////////////////////////////////////////////////////////////////////
// CNotify
/////////////////////////////////////////////////////////////////////////////

class CClusterNotify
{
public:
	union
	{
		DWORD_PTR			m_dwNotifyKey;
		CClusterNotifyKey *	m_pcnk;
	};
	DWORD					m_dwFilterType;
	CString					m_strName;

};  //*** class CClusterNotify

typedef CList<CClusterNotify *, CClusterNotify *> CClusterNotifyList;

/////////////////////////////////////////////////////////////////////////////
// CClusterNotifyContext
/////////////////////////////////////////////////////////////////////////////

class CClusterNotifyContext : public CObject
{
	DECLARE_DYNAMIC(CClusterNotifyContext)

public:
	HCHANGE			m_hchangeNotifyPort;
	HWND			m_hwndFrame;

};  //*** class CClusterNotifyContext

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
LPCTSTR PszNotificationName(IN DWORD dwNotification);
#endif // _DEBUG
void DeleteAllItemData(IN OUT CClusterNotifyList & rlp);

/////////////////////////////////////////////////////////////////////////////

#endif // _NOTIFY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\node.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      Node.cpp
//
//  Description:
//      Implementation of the CClusNode class.
//
//  Maintained By:
//      David Potter (davidp)   May 3, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "Node.h"
#include "ClusItem.inl"
#include "NodeProp.h"
#include "ExcOper.h"
#include "TraceTag.h"
#include "Cluster.h"
#include "CASvc.h"
#include "ResType.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagNode(_T("Document"), _T("NODE"), 0);
CTraceTag   g_tagNodeDrag(_T("Drag&Drop"), _T("NODE DRAG"), 0);
CTraceTag   g_tagNodeNotify(_T("Notify"), _T("NODE NOTIFY"), 0);
CTraceTag   g_tagNodeRegNotify(_T("Notify"), _T("NODE REG NOTIFY"), 0);
#endif


/////////////////////////////////////////////////////////////////////////////
// CClusterNode
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CClusterNode, CClusterItem)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CClusterNode, CClusterItem)
    //{{AFX_MSG_MAP(CClusterNode)
    ON_UPDATE_COMMAND_UI(ID_FILE_PAUSE_NODE, OnUpdatePauseNode)
    ON_UPDATE_COMMAND_UI(ID_FILE_RESUME_NODE, OnUpdateResumeNode)
    ON_UPDATE_COMMAND_UI(ID_FILE_EVICT_NODE, OnUpdateEvictNode)
    ON_UPDATE_COMMAND_UI(ID_FILE_START_SERVICE, OnUpdateStartService)
    ON_UPDATE_COMMAND_UI(ID_FILE_STOP_SERVICE, OnUpdateStopService)
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
    ON_COMMAND(ID_FILE_PAUSE_NODE, OnCmdPauseNode)
    ON_COMMAND(ID_FILE_RESUME_NODE, OnCmdResumeNode)
    ON_COMMAND(ID_FILE_EVICT_NODE, OnCmdEvictNode)
    ON_COMMAND(ID_FILE_START_SERVICE, OnCmdStartService)
    ON_COMMAND(ID_FILE_STOP_SERVICE, OnCmdStopService)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::CClusterNode
//
//  Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNode::CClusterNode(void) : CClusterItem(NULL, IDS_ITEMTYPE_NODE)
{
    m_idmPopupMenu = IDM_NODE_POPUP;
    m_hnode = NULL;

    m_nNodeHighestVersion = 0;
    m_nNodeLowestVersion = 0;
    m_nMajorVersion = 0;
    m_nMinorVersion = 0;
    m_nBuildNumber = 0;

    m_plpcigrpOnline = NULL;
    m_plpciresOnline = NULL;
    m_plpciNetInterfaces = NULL;

    // Set the object type image.
    m_iimgObjectType = GetClusterAdminApp()->Iimg(IMGLI_NODE);

    // Setup the property array.
    {
        m_rgProps[epropName].Set(CLUSREG_NAME_NODE_NAME, m_strName, m_strName);
        m_rgProps[epropDescription].Set(CLUSREG_NAME_NODE_DESC, m_strDescription, m_strDescription);
        m_rgProps[epropNodeHighestVersion].Set(CLUSREG_NAME_NODE_HIGHEST_VERSION, m_nNodeHighestVersion, m_nNodeHighestVersion);
        m_rgProps[epropNodeLowestVersion].Set(CLUSREG_NAME_NODE_LOWEST_VERSION, m_nNodeLowestVersion, m_nNodeLowestVersion);
        m_rgProps[epropMajorVersion].Set(CLUSREG_NAME_NODE_MAJOR_VERSION, m_nMajorVersion, m_nMajorVersion);
        m_rgProps[epropMinorVersion].Set(CLUSREG_NAME_NODE_MINOR_VERSION, m_nMinorVersion, m_nMinorVersion);
        m_rgProps[epropBuildNumber].Set(CLUSREG_NAME_NODE_BUILD_NUMBER, m_nBuildNumber, m_nBuildNumber);
        m_rgProps[epropCSDVersion].Set(CLUSREG_NAME_NODE_CSDVERSION, m_strCSDVersion, m_strCSDVersion);
    }  // Setup the property array

    // To keep the application running as long as an OLE automation
    //  object is active, the constructor calls AfxOleLockApp.

//  AfxOleLockApp();

}  //*** CClusterNode::CClusterNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::~CClusterNode
//
//  Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNode::~CClusterNode(void)
{
    delete m_plpcigrpOnline;
    delete m_plpciresOnline;
    delete m_plpciNetInterfaces;

    // Close the node.
    if (Hnode() != NULL)
        CloseClusterNode(Hnode());

    // To terminate the application when all objects created with
    //  with OLE automation, the destructor calls AfxOleUnlockApp.

//  AfxOleUnlockApp();

}  //*** CClusterNode::~CClusterNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::Cleanup
//
//  Description:
//      Cleanup the item.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::Cleanup(void)
{
    // Delete the Groups Online list.
    if (m_plpcigrpOnline != NULL)
        m_plpcigrpOnline->RemoveAll();

    // Delete the Resources Online list.
    if (m_plpciresOnline != NULL)
        m_plpciresOnline->RemoveAll();

    // Delete the Network Interfaces list.
    if (m_plpciNetInterfaces != NULL)
        m_plpciNetInterfaces->RemoveAll();

    // Remove the item from the node list.
    {
        POSITION    posPci;

        posPci = Pdoc()->LpciNodes().Find(this);
        if (posPci != NULL)
        {
            Pdoc()->LpciNodes().RemoveAt(posPci);
        }  // if:  found in the document's list
    }  // Remove the item from the node list

}  //*** CClusterNode::Cleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::Init
//
//  Description:
//      Initialize the item.
//
//  Arguments:
//      pdoc        [IN OUT] Document to which this item belongs.
//      lpszName    [IN] Name of the item.
//
//  Return Values:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from OpenClusterGroup or ClusterRegOpenKey.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName)
{
    DWORD       dwStatus = ERROR_SUCCESS;
    LONG        lResult;
    CWaitCursor wc;

    ASSERT(Hnode() == NULL);
    ASSERT(Hkey() == NULL);

    // Call the base class method.
    CClusterItem::Init(pdoc, lpszName);

    try
    {
        // Open the node.
        m_hnode = OpenClusterNode(Hcluster(), lpszName);
        if (Hnode() == NULL)
        {
            dwStatus = GetLastError();
            ThrowStaticException(dwStatus, IDS_OPEN_NODE_ERROR, lpszName);
        }  // if:  error opening the cluster node

        // Get the node registry key.
        m_hkey = GetClusterNodeKey(Hnode(), MAXIMUM_ALLOWED);
        if (Hkey() == NULL)
            ThrowStaticException(GetLastError(), IDS_GET_NODE_KEY_ERROR, lpszName);

        ASSERT(Pcnk() != NULL);
        Trace(g_tagClusItemNotify, _T("CClusterNode::Init() - Registering for node notifications (%08.8x) for '%s'"), Pcnk(), StrName());

        // Register for node notifications.
        lResult = RegisterClusterNotify(
                            GetClusterAdminApp()->HchangeNotifyPort(),
                            (CLUSTER_CHANGE_NODE_STATE
                                | CLUSTER_CHANGE_NODE_DELETED
                                | CLUSTER_CHANGE_NODE_PROPERTY),
                            Hnode(),
                            (DWORD_PTR) Pcnk()
                            );
        if (lResult != ERROR_SUCCESS)
        {
            dwStatus = lResult;
            ThrowStaticException(dwStatus, IDS_NODE_NOTIF_REG_ERROR, lpszName);
        }  // if:  error registering for node notifications

        // Register for registry notifications.
        if (Hkey() != NULL)
        {
            lResult = RegisterClusterNotify(
                                GetClusterAdminApp()->HchangeNotifyPort(),
                                (CLUSTER_CHANGE_REGISTRY_NAME
                                    | CLUSTER_CHANGE_REGISTRY_ATTRIBUTES
                                    | CLUSTER_CHANGE_REGISTRY_VALUE
                                    | CLUSTER_CHANGE_REGISTRY_SUBTREE),
                                Hkey(),
                                (DWORD_PTR) Pcnk()
                                );
            if (lResult != ERROR_SUCCESS)
            {
                dwStatus = lResult;
                ThrowStaticException(dwStatus, IDS_NODE_NOTIF_REG_ERROR, lpszName);
            }  // if:  error registering for registry notifications
        }  // if:  there is a key

        // Allocate lists.
        m_plpcigrpOnline = new CGroupList;
        if ( m_plpcigrpOnline == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the group list

        m_plpciresOnline = new CResourceList;
        if ( m_plpciresOnline == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the resource list

        m_plpciNetInterfaces = new CNetInterfaceList;
        if ( m_plpciNetInterfaces == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the net interface list

        // Read the initial state.
        UpdateState();
    }  // try
    catch (CException *)
    {
        if (Hkey() != NULL)
        {
            ClusterRegCloseKey(Hkey());
            m_hkey = NULL;
        }  // if:  registry key opened
        if (Hnode() != NULL)
        {
            CloseClusterNode(Hnode());
            m_hnode = NULL;
        }  // if:  node opened
        m_bReadOnly = TRUE;
        throw;
    }  // catch:  CException

}  //*** CClusterNode::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::ReadItem
//
//  Description:
//      Read the item parameters from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions from CClusterItem::ReadItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::ReadItem(void)
{
    DWORD       dwStatus;
    DWORD       dwRetStatus = ERROR_SUCCESS;
    CWaitCursor wc;

    ASSERT(Hnode() != NULL);

    if (Hnode() != NULL)
    {
        m_rgProps[epropDescription].m_value.pstr = &m_strDescription;

        // Call the base class method.
        CClusterItem::ReadItem();

        // Read and parse the common properties.
        {
            CClusPropList   cpl;

            dwStatus = cpl.ScGetNodeProperties(
                                Hnode(),
                                CLUSCTL_NODE_GET_COMMON_PROPERTIES
                                );
            if (dwStatus == ERROR_SUCCESS)
                dwStatus = DwParseProperties(cpl);
            if (dwStatus != ERROR_SUCCESS)
                dwRetStatus = dwStatus;
        }  // Read and parse the common properties

        // Read and parse the read-only common properties.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            CClusPropList   cpl;

            dwStatus = cpl.ScGetNodeProperties(
                                Hnode(),
                                CLUSCTL_NODE_GET_RO_COMMON_PROPERTIES
                                );
            if (dwStatus == ERROR_SUCCESS)
                dwStatus = DwParseProperties(cpl);
            if (dwStatus != ERROR_SUCCESS)
                dwRetStatus = dwStatus;
        }  // if:  no error yet

        // Read extension lists.
        ReadExtensions();

    }  // if:  node is avaialble

    // Read the initial state.
    UpdateState();

//  ConstructActiveGroupList();
//  ConstructActiveResourceList();

    // If any errors occurred, throw an exception.
    if (dwRetStatus != ERROR_SUCCESS)
    {
        m_bReadOnly = TRUE;
        ThrowStaticException(dwRetStatus, IDS_READ_NODE_PROPS_ERROR, StrName());
    }  // if:  error reading properties

    MarkAsChanged(FALSE);

}  //*** CClusterNode::ReadItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::PlstrExtensions
//
//  Description:
//      Return the list of admin extensions.
//
//  Arguments:
//      None.
//
//  Return Values:
//      plstr       List of extensions.
//      NULL        No extension associated with this object.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CStringList * CClusterNode::PlstrExtensions(void) const
{
    return &Pdoc()->PciCluster()->LstrNodeExtensions();

}  //*** CClusterNode::PlstrExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::ReadExtensions
//
//  Description:
//      Read extension lists.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::ReadExtensions(void)
{
}  //*** CClusterNode::ReadExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::AddActiveGroup
//
//  Description:
//      Add a group to the list of active groups.
//
//  Arguments:
//      pciGroup    [IN OUT] New active group.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::AddActiveGroup(IN OUT CGroup * pciGroup)
{
    POSITION    posPci;

    Trace(g_tagNode, _T("Adding active group '%s' (%x) to node '%s"), (pciGroup ? pciGroup->StrName() : _T("")), pciGroup, StrName());

    // Make sure the group is not already in the list.
    VERIFY((posPci = LpcigrpOnline().Find(pciGroup)) == NULL);

    if (posPci == NULL)
    {
        POSITION    posPtiNode;
        CTreeItem * ptiNode;
        CTreeItem * ptiGroups;

        // Loop through each tree item to update the Active Groups list.
        posPtiNode = LptiBackPointers().GetHeadPosition();
        while (posPtiNode != NULL)
        {
            ptiNode = LptiBackPointers().GetNext(posPtiNode);
            ASSERT_VALID(ptiNode);

            // Find the Active Groups child tree item and add the new group.
            ptiGroups = ptiNode->PtiChildFromName(IDS_TREEITEM_ACTIVEGROUPS);
            ASSERT_VALID(ptiGroups);
            VERIFY(ptiGroups->PliAddChild(pciGroup) != NULL);
        }  // while:  more tree items for this node

        m_plpcigrpOnline->AddTail(pciGroup);
    }  // if:  group not in the list yet

}  //*** CClusterNode::AddActiveGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::AddActiveResource
//
//  Description:
//      Add a resource to the list of active resources.
//
//  Arguments:
//      pciRes      [IN OUT] New active resource.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::AddActiveResource(IN OUT CResource * pciRes)
{
    POSITION    posPci;

    Trace(g_tagNode, _T("Adding active resource '%s' (%x) to node '%s"), (pciRes ? pciRes->StrName() : _T("")), pciRes, StrName());

    // Make sure the resource is not already in the list.
    VERIFY((posPci = LpciresOnline().Find(pciRes)) == NULL);

    if (posPci == NULL)
    {
        POSITION    posPtiNode;
        CTreeItem * ptiNode;
        CTreeItem * ptiResources;

        // Loop through each tree item to update the Active Resources list.
        posPtiNode = LptiBackPointers().GetHeadPosition();
        while (posPtiNode != NULL)
        {
            ptiNode = LptiBackPointers().GetNext(posPtiNode);
            ASSERT_VALID(ptiNode);

            // Find the Active Resources child tree item and add the new resource.
            ptiResources = ptiNode->PtiChildFromName(IDS_TREEITEM_ACTIVERESOURCES);
            ASSERT_VALID(ptiResources);
            VERIFY(ptiResources->PliAddChild(pciRes) != NULL);
        }  // while:  more tree items for this node

        m_plpciresOnline->AddTail(pciRes);

    }  // if:  resource not in the list yet

}  //*** CClusterNode::AddActiveResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::AddNetInterface
//
//  Description:
//      Add a network interface to the list of interaces installed in this node.
//
//  Arguments:
//      pciNetIFace     [IN OUT] New network interface.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::AddNetInterface(IN OUT CNetInterface * pciNetIFace)
{
    POSITION    posPci;

    ASSERT_VALID(pciNetIFace);
    Trace(g_tagNode, _T("(%s) (%s (%x)) - Adding network interface '%s'"), Pdoc()->StrNode(), StrName(), this, pciNetIFace->StrName());

    // Make sure the resource is not already in the list.
    VERIFY((posPci = LpciNetInterfaces().Find(pciNetIFace)) == NULL);

    if (posPci == NULL)
    {
        POSITION    posPtiNode;
        CTreeItem * ptiNode;
        CTreeItem * ptiNetIFace;

        // Loop through each tree item to update the Network Interfaces list.
        posPtiNode = LptiBackPointers().GetHeadPosition();
        while (posPtiNode != NULL)
        {
            ptiNode = LptiBackPointers().GetNext(posPtiNode);
            ASSERT_VALID(ptiNode);

            // Find the Active Resources child tree item and add the new resource.
            ptiNetIFace = ptiNode->PtiChildFromName(IDS_TREEITEM_NETIFACES);
            ASSERT_VALID(ptiNetIFace);
            VERIFY(ptiNetIFace->PliAddChild(pciNetIFace) != NULL);
        }  // while:  more tree items for this node

        m_plpciNetInterfaces->AddTail(pciNetIFace);

    }  // if:  network interface not in the list yet

}  //*** CClusterNode::AddNetInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::RemoveActiveGroup
//
//  Description:
//      Remove a group from the list of active groups.
//
//  Arguments:
//      pciGroup    [IN OUT] Group that is no longer active on this node.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::RemoveActiveGroup(IN OUT CGroup * pciGroup)
{
    POSITION    posPci;

    Trace(g_tagNode, _T("Removing active group '%s' (%x) from node '%s"), (pciGroup ? pciGroup->StrName() : _T("")), pciGroup, StrName());

    // Make sure the group is in the list.
    VERIFY((posPci = LpcigrpOnline().Find(pciGroup)) != NULL);

    if (posPci != NULL)
    {
        POSITION    posPtiNode;
        CTreeItem * ptiNode;
        CTreeItem * ptiGroups;

        // Loop through each tree item to update the Active Groups list.
        posPtiNode = LptiBackPointers().GetHeadPosition();
        while (posPtiNode != NULL)
        {
            ptiNode = LptiBackPointers().GetNext(posPtiNode);
            ASSERT_VALID(ptiNode);

            // Find the Active Groups child tree item and remove the group.
            ptiGroups = ptiNode->PtiChildFromName(IDS_TREEITEM_ACTIVEGROUPS);
            ASSERT_VALID(ptiGroups);
            ptiGroups->RemoveChild(pciGroup);
        }  // while:  more tree items for this node

        m_plpcigrpOnline->RemoveAt(posPci);

    }  // if:  group in the list

}  //*** CClusterNode::RemoveActiveGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::RemoveActiveResource
//
//  Description:
//      Remove a resource from the list of active resources.
//
//  Arguments:
//      pciRes      [IN OUT] Resource that is no longer active on this node.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::RemoveActiveResource(IN OUT CResource * pciRes)
{
    POSITION    posPci;

    Trace(g_tagNode, _T("Removing active resource '%s' (%x) from node '%s"), (pciRes ? pciRes->StrName() : _T("")), pciRes, StrName());

    // Make sure the resource is in the list.
    VERIFY((posPci = LpciresOnline().Find(pciRes)) != NULL);

    if (posPci != NULL)
    {
        POSITION    posPtiNode;
        CTreeItem * ptiNode;
        CTreeItem * ptiResources;

        // Loop through each tree item to update the Active Resources list.
        posPtiNode = LptiBackPointers().GetHeadPosition();
        while (posPtiNode != NULL)
        {
            ptiNode = LptiBackPointers().GetNext(posPtiNode);
            ASSERT_VALID(ptiNode);

            // Find the Active Resources child tree item and remove the resource.
            ptiResources = ptiNode->PtiChildFromName(IDS_TREEITEM_ACTIVERESOURCES);
            ASSERT_VALID(ptiResources);
            ptiResources->RemoveChild(pciRes);
        }  // while:  more tree items for this node

        m_plpciresOnline->RemoveAt(posPci);

    }  // if:  resource in the list

}  //*** CClusterNode::RemoveActiveResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::RemoveNetInterface
//
//  Description:
//      Remove a network interface from the list of interaces installed in this node.
//
//  Arguments:
//      pciNetIFace     [IN OUT] Network interface that is no longer
//                          connected to this network.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::RemoveNetInterface(IN OUT CNetInterface * pciNetIFace)
{
    POSITION    posPci;

    ASSERT_VALID(pciNetIFace);
    Trace(g_tagNode, _T("(%s) (%s (%x)) - Removing network interface '%s'"), Pdoc()->StrNode(), StrName(), this, pciNetIFace->StrName());

    // Make sure the network interface is in the list.
    VERIFY((posPci = LpciNetInterfaces().Find(pciNetIFace)) != NULL);

    if (posPci != NULL)
    {
        POSITION    posPtiNode;
        CTreeItem * ptiNode;
        CTreeItem * ptiNetIFace;

        // Loop through each tree item to update the Network Interfaces list.
        posPtiNode = LptiBackPointers().GetHeadPosition();
        while (posPtiNode != NULL)
        {
            ptiNode = LptiBackPointers().GetNext(posPtiNode);
            ASSERT_VALID(ptiNode);

            // Find the Network Interfaces child tree item and remove the resource.
            ptiNetIFace = ptiNode->PtiChildFromName(IDS_TREEITEM_NETIFACES);
            ASSERT_VALID(ptiNetIFace);
            ptiNetIFace->RemoveChild(pciNetIFace);
        }  // while:  more tree items for this network

        m_plpciNetInterfaces->RemoveAt(posPci);

    }  // if:  network interface in the list

}  //*** CClusterNode::RemoveNetInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::SetDescription
//
//  Description:
//      Set the description in the cluster database.
//
//  Arguments:
//      rstrDesc        [IN] Description to set.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Values:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by WriteItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::SetDescription(
    IN const CString &  rstrDesc,
    IN BOOL             bValidateOnly
    )
{
    CNTException    nte(ERROR_SUCCESS, 0, NULL, NULL, FALSE /*bAutoDelete*/);

    m_rgProps[epropDescription].m_value.pstr = (CString *) &rstrDesc;

    try
    {
        CClusterItem::SetCommonProperties(bValidateOnly);
    }  // try
    catch (CNTException * pnte)
    {
        nte.SetOperation(
                    pnte->Sc(),
                    pnte->IdsOperation(),
                    pnte->PszOperArg1(),
                    pnte->PszOperArg2()
                    );
    }  // catch:  CNTException

    m_rgProps[epropDescription].m_value.pstr = &m_strDescription;

    if (nte.Sc() != ERROR_SUCCESS)
        ThrowStaticException(
                        nte.Sc(),
                        nte.IdsOperation(),
                        nte.PszOperArg1(),
                        nte.PszOperArg2()
                        );

}  //*** CClusterNode::SetDescription()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::DwSetCommonProperties
//
//  Description:
//      Set the common properties for this resource in the cluster database.
//
//  Arguments:
//      rcpl            [IN] Property list to set.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Values:
//      Any status returned by ClusterResourceControl().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterNode::DwSetCommonProperties(
    IN const CClusPropList &    rcpl,
    IN BOOL                     bValidateOnly
    )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hnode());

    if ((rcpl.PbPropList() != NULL) && (rcpl.CbPropList() > 0))
    {
        DWORD   cbProps;
        DWORD   dwControl;

        if (bValidateOnly)
            dwControl = CLUSCTL_NODE_VALIDATE_COMMON_PROPERTIES;
        else
            dwControl = CLUSCTL_NODE_SET_COMMON_PROPERTIES;

        // Set private properties.
        dwStatus = ClusterNodeControl(
                        Hnode(),
                        NULL,   // hNode
                        dwControl,
                        rcpl.PbPropList(),
                        rcpl.CbPropList(),
                        NULL,   // lpOutBuffer
                        0,      // nOutBufferSize
                        &cbProps
                        );
    }  // if:  there is data to set
    else
        dwStatus = ERROR_SUCCESS;

    return dwStatus;

}  //*** CClusterNode::DwSetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::BCanBeDropTarget
//
//  Description:
//      Determine if the specified item can be dropped on this item.
//
//  Arguments:
//      pci         [IN OUT] Item to be dropped on this item.
//
//  Return Values:
//      TRUE        Can be drop target.
//      FALSE       Can NOT be drop target.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterNode::BCanBeDropTarget(IN const CClusterItem * pci) const
{
    BOOL    bCan;

    // This node can be a drop target only if the specified item
    // is a group and it is not already a running on this node.

    if ((Cns() == ClusterNodeUp)
            && (pci->IdsType() == IDS_ITEMTYPE_GROUP))
    {
        CGroup *    pciGroup = (CGroup *) pci;
        ASSERT_KINDOF(CGroup, pciGroup);
        if (pciGroup->StrOwner() != StrName())
            bCan = TRUE;
        else
            bCan = FALSE;
        Trace(g_tagNodeDrag, _T("BCanBeDropTarget() - Dragging group '%s' (%x) (owner = '%s') over node '%s' (%x)"), pciGroup->StrName(), pciGroup, pciGroup->StrOwner(), StrName(), this);
    }  // if:  node is up and dropping group item
    else
        bCan = FALSE;

    return bCan;

}  //*** CClusterNode::BCanBeDropTarget()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::DropItem
//
//  Description:
//      Process an item being dropped on this item.
//
//  Arguments:
//      pci         [IN OUT] Item dropped on this item.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::DropItem(IN OUT CClusterItem * pci)
{
    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    do // do-while to prevent goto's
    {
        if (BCanBeDropTarget(pci))
        {
            POSITION        pos;
            UINT            imenu;
            UINT            idMenu;
            CClusterNode *  pciNode;
            CGroup *        pciGroup;

            // Calculate the ID of this node.
            pos = Pdoc()->LpciNodes().GetHeadPosition();
            for (imenu = 0, idMenu = ID_FILE_MOVE_GROUP_1
                    ; pos != NULL
                    ; idMenu++)
            {
                pciNode = (CClusterNode *) Pdoc()->LpciNodes().GetNext(pos);
                ASSERT_VALID(pciNode);
                if (pciNode == this)
                    break;
            }  // for:  each group
            ASSERT(imenu < (UINT) Pdoc()->LpciNodes().GetCount());

            // Change the group of the specified resource.
            pciGroup = (CGroup *) pci;
            ASSERT_KINDOF(CGroup, pci);
            ASSERT_VALID(pciGroup);

            // Verify that the resource should be moved.
            {
                CString strMsg;

                strMsg.FormatMessage(IDS_VERIFY_MOVE_GROUP, pciGroup->StrName(), pciGroup->StrOwner(), StrName());
                if (AfxMessageBox(strMsg, MB_YESNO | MB_ICONEXCLAMATION) != IDYES)
                    break;
            }  // Verify that the resource should be moved

            // Move the group.
            pciGroup->OnCmdMoveGroup(idMenu);
        }  // if:  item can be dropped on this item
        else if (pci->IdsType() == IDS_ITEMTYPE_GROUP)
        {
            CString     strMsg;

#ifdef _DEBUG
            CGroup *    pciGroup = (CGroup *) pci;

            ASSERT_KINDOF(CGroup, pci);
            ASSERT_VALID(pciGroup);
#endif // _DEBUG

            // Format the proper message.
            if (Cns() != ClusterNodeUp)
                strMsg.FormatMessage(IDS_CANT_MOVE_GROUP_TO_DOWN_NODE, pci->StrName(), StrName());
            else
            {
                ASSERT(pciGroup->StrOwner() == StrName());
                strMsg.FormatMessage(IDS_CANT_MOVE_GROUP_TO_SAME_NODE, pci->StrName(), StrName());
            }  // else:  problem is not that the node is not up
            AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
        }  // else if:  dropped item is a group
        else
            CClusterItem::DropItem(pci);
    }  while (0); // do-while to prevent goto's

    Release();

}  //*** CClusterNode::DropItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::UpdateState
//
//  Description:
//      Update the current state of the item.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::UpdateState( void )
{
    CClusterAdminApp *  papp    = GetClusterAdminApp();
    CLUSTER_NODE_STATE  cnsPrev = m_cns;

    // Get the current state of the node.
    if ( Hnode() == NULL )
    {
        m_cns = ClusterNodeStateUnknown;
    } // if: node is not valid
    else
    {
        CWaitCursor wc;

        m_cns = GetClusterNodeState( Hnode() );
    }  // else:  node is valid

    // Save the current state image index.
    switch ( Cns() )
    {
        case ClusterNodeStateUnknown:
            m_iimgState = papp->Iimg( IMGLI_NODE_UNKNOWN );
            break;
        case ClusterNodeUp:
            m_iimgState = papp->Iimg( IMGLI_NODE );
            if ( cnsPrev == ClusterNodeDown )
            {
                UpdateResourceTypePossibleOwners();
            } // if: node was previously down
            break;
        case ClusterNodeDown:
            m_iimgState = papp->Iimg( IMGLI_NODE_DOWN );
            break;
        case ClusterNodePaused:
            m_iimgState = papp->Iimg( IMGLI_NODE_PAUSED );
            break;
        case ClusterNodeJoining:
            m_iimgState = papp->Iimg( IMGLI_NODE_UNKNOWN );
            break;
        default:
            Trace( g_tagNode, _T("(%s (%x)) - UpdateState: Unknown state '%d' for node '%s'"), StrName(), this, Cns(), StrName() );
            m_iimgState = (UINT) -1;
            break;
    }  // switch:  Cns()

    // Call the base class method.
    CClusterItem::UpdateState();

}  //*** CClusterNode::UpdateState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::UpdateResourceTypePossibleOwners
//
//  Description:
//      Update the possible owner lists of any resource types that have
//      faked them because of nodes being down.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::UpdateResourceTypePossibleOwners( void )
{
    POSITION        pos;
    CResourceType * pciResType;

    pos = Pdoc()->LpciResourceTypes().GetHeadPosition();
    while ( pos != NULL )
    {
        pciResType = (CResourceType *) Pdoc()->LpciResourceTypes().GetNext( pos );
        ASSERT_VALID( pciResType );
        if ( pciResType->BPossibleOwnersAreFake() )
        {
            pciResType->CollectPossibleOwners();
        } // if: possible owners have been faked
    } // while: more resource types

} //*** CClusterNode::UpdateResourceTypePossibleOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnFinalRelease
//
//  Description:
//      Called when the last OLE reference to or from the object is released.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnFinalRelease(void)
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CClusterItem::OnFinalRelease();

}  //*** CClusterNode::OnFinalRelease()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::BGetColumnData
//
//  Description:
//      Returns a string with the column data.
//
//  Arguments:
//      colid       [IN] Column ID.
//      rstrText    [OUT] String in which to return the text for the column.
//
//  Return Values:
//      TRUE        Column data returned.
//      FALSE       Column ID not recognized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterNode::BGetColumnData(IN COLID colid, OUT CString & rstrText)
{
    BOOL    bSuccess;

    switch (colid)
    {
        case IDS_COLTEXT_STATE:
            GetStateName(rstrText);
            bSuccess = TRUE;
            break;
        default:
            bSuccess = CClusterItem::BGetColumnData(colid, rstrText);
            break;
    }  // switch:  colid

    return bSuccess;

}  //*** CClusterNode::BGetColumnData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::GetTreeName
//
//  Description:
//      Returns a string to be used in a tree control.
//
//  Arguments:
//      rstrName    [OUT] String in which to return the name.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
void CClusterNode::GetTreeName(OUT CString & rstrName) const
{
    CString     strState;

    GetStateName(strState);
    rstrName.Format(_T("%s (%s)"), StrName(), strState);

}  //*** CClusterNode::GetTreeName()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::GetStateName
//
//  Description:
//      Returns a string with the name of the current state.
//
//  Arguments:
//      rstrState   [OUT] String in which to return the name of the current state.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::GetStateName(OUT CString & rstrState) const
{
    switch (Cns())
    {
        case ClusterNodeStateUnknown:
            rstrState.LoadString(IDS_UNKNOWN);
            break;
        case ClusterNodeUp:
            rstrState.LoadString(IDS_UP);
            break;
        case ClusterNodeDown:
            rstrState.LoadString(IDS_DOWN);
            break;
        case ClusterNodePaused:
            rstrState.LoadString(IDS_PAUSED);
            break;
        case ClusterNodeJoining:
            rstrState.LoadString(IDS_JOINING);
            break;
        default:
            rstrState.Empty();
            break;
    }  // switch:  Cns()

}  //*** CClusterNode::GetStateName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnUpdatePauseNode
//
//  Description:
//      Determines whether menu items corresponding to ID_FILE_PAUSE_NODE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnUpdatePauseNode(CCmdUI * pCmdUI)
{
    if (Cns() == ClusterNodeUp)
        pCmdUI->Enable(TRUE);
    else
        pCmdUI->Enable(FALSE);

}  //*** CClusterNode::OnUpdatePauseNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnUpdateResumeNode
//
//  Description:
//      Determines whether menu items corresponding to ID_FILE_RESUME_NODE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnUpdateResumeNode(CCmdUI * pCmdUI)
{
    if (Cns() == ClusterNodePaused)
        pCmdUI->Enable(TRUE);
    else
        pCmdUI->Enable(FALSE);

}  //*** CClusterNode::OnUpdateResumeNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnUpdateEvictNode
//
//  Description:
//      Determines whether menu items corresponding to ID_FILE_EVICT_NODE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnUpdateEvictNode( CCmdUI * pCmdUI )
{
    BOOL    fCanEvict;

    fCanEvict = FCanBeEvicted();

    pCmdUI->Enable( fCanEvict );

}  //*** CClusterNode::OnUpdateEvictNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnUpdateStartService
//
//  Description:
//      Determines whether menu items corresponding to ID_FILE_START_SERVICE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnUpdateStartService(CCmdUI * pCmdUI)
{
    if ((Cns() == ClusterNodeStateUnknown)
            || (Cns() == ClusterNodeDown))
        pCmdUI->Enable(TRUE);
    else
        pCmdUI->Enable(FALSE);

}  //*** CClusterNode::OnUpdateStartService()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnUpdateStopService
//
//  Description:
//      Determines whether menu items corresponding to ID_FILE_STOP_SERVICE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnUpdateStopService(CCmdUI * pCmdUI)
{
    if ((Cns() == ClusterNodeStateUnknown)
            || (Cns() == ClusterNodeUp))
        pCmdUI->Enable(TRUE);
    else
        pCmdUI->Enable(FALSE);

}  //*** CClusterNode::OnUpdateStopService()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnCmdPauseNode
//
//  Description:
//      Processes the ID_FILE_PAUSE_NODE menu command.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnCmdPauseNode(void)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hnode() != NULL);

    dwStatus = PauseClusterNode(Hnode());
    if (dwStatus != ERROR_SUCCESS)
    {
        CNTException    nte(dwStatus, IDS_PAUSE_NODE_ERROR, StrName(), NULL, FALSE /*bAutoDelete*/);
        nte.ReportError();
    }  // if:  error pausing node

    UpdateState();

}  //*** CClusterNode::OnCmdPauseNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnCmdResumeNode
//
//  Description:
//      Processes the ID_FILE_RESUME_NODE menu command.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnCmdResumeNode(void)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hnode() != NULL);

    dwStatus = ResumeClusterNode(Hnode());
    if (dwStatus != ERROR_SUCCESS)
    {
        CNTException    nte(dwStatus, IDS_RESUME_NODE_ERROR, StrName(), NULL, FALSE /*bAUtoDelete*/);
        nte.ReportError();
    }  // if:  error resuming node

    UpdateState();

}  //*** CClusterNode::OnCmdResumeNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnCmdEvictNode
//
//  Description:
//      Processes the ID_FILE_EVICT_NODE menu command.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnCmdEvictNode(void)
{
    ASSERT(Hnode() != NULL);

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    if ( ! FCanBeEvicted() )
    {
        TCHAR   szMsg[1024];
        CNTException nte(ERROR_CANT_EVICT_ACTIVE_NODE, 0, NULL, NULL, FALSE /*bAutoDelete*/);
        nte.FormatErrorMessage(szMsg, sizeof(szMsg) / sizeof(TCHAR), NULL, FALSE /*bIncludeID*/);
        AfxMessageBox(szMsg);
    }  // if:  node can not be evicted
    else
    {
        DWORD       dwStatus;
        DWORD       dwCleanupStatus;
        HRESULT     hrCleanupStatus;
        CString     strMsg;
        CWaitCursor wc;

        try
        {
            // Verify that the user really wants to evict this node.
            strMsg.FormatMessage(IDS_VERIFY_EVICT_NODE, StrName());
            if (AfxMessageBox(strMsg, MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2) == IDYES)
            {
                // Evict the node.
                dwStatus = EvictClusterNodeEx(Hnode(), INFINITE, &hrCleanupStatus);
               
                // convert any cleanup error from an hresult to a win32 error code 
                dwCleanupStatus = HRESULT_CODE( hrCleanupStatus );

                if( ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP == dwStatus )
                {
                    //
                    // Eviction was successful, but cleanup failed.  dwCleanupStatus contains
                    // the cleanup error code. 
                    //
                    CNTException nte( dwCleanupStatus, IDS_EVICT_NODE_ERROR_UNAVAILABLE, StrName(), NULL, FALSE /*bAutoDelete*/ );
                    nte.ReportError();
                }
                else if( ERROR_SUCCESS != dwStatus )
                {
                    //
                    // Eviction was not successful.  Display the error.
                    //
                    CNTException nte(dwStatus, IDS_EVICT_NODE_ERROR, StrName(), NULL, FALSE /*bAutoDelete*/);
                    nte.ReportError();
                }  // if:  error evicting the node
                // else: eviction and cleanup successful

                UpdateState();

            } // if: user selected yes from message box (to online resource)

        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
    }  // else:  node is down

    Release();

}  //*** CClusterNode::OnCmdEvictNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnCmdStartService
//
//  Description:
//      Processes the ID_FILE_START_SERVICE menu command.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnCmdStartService(void)
{
    HRESULT     hr;
    BOOL        bRefresh = FALSE;
    CWaitCursor wc;

    // If all nodes are down or unavailable, we need to refresh.
    if ( Cns() == ClusterNodeStateUnknown )
    {
        bRefresh = TRUE;
    }
    else
    {
        int             cNodesUp = 0;
        POSITION        pos;
        CClusterNode *  pciNode;

        pos = Pdoc()->LpciNodes().GetHeadPosition();
        while ( pos != NULL )
        {
            pciNode = (CClusterNode *) Pdoc()->LpciNodes().GetNext( pos );
            ASSERT_VALID( pciNode );
            if ( pciNode->Cns() == ClusterNodeStateUnknown )
            {
                cNodesUp++;
            }
        }  // while:  more items in the list
        if ( cNodesUp > 0 )
        {
            bRefresh = TRUE;
        }
    }  // else:  node state is available

    // Start the service.
    hr = HrStartService( CLUSTER_SERVICE_NAME, StrName() );
    if ( FAILED( hr ) )
    {
        CNTException    nte( hr, IDS_START_CLUSTER_SERVICE_ERROR, StrName(), NULL, FALSE /*bAutoDelete*/ );
        nte.ReportError();
    }  // if:  error starting the service
    else if ( bRefresh )
    {
        Sleep( 2000 );
        Pdoc()->Refresh();
    }  // else if:  we need to refresh

} //*** CClusterNode::OnCmdStartService()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnCmdStopService
//
//  Description:
//      Processes the ID_FILE_STOP_SERVICE menu command.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnCmdStopService(void)
{
    HRESULT                 hr;

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // Stop the service.
    hr = HrStopService( CLUSTER_SERVICE_NAME, StrName() );
    if ( FAILED( hr ) )
    {
        CNTException    nte( hr, IDS_STOP_CLUSTER_SERVICE_ERROR, StrName(), NULL, FALSE /*bAutoDelete*/ );
        nte.ReportError();
    }

    Release();

} //*** CClusterNode::OnCmdStopService()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnUpdateProperties
//
//  Description:
//      Determines whether menu items corresponding to ID_FILE_PROPERTIES
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::OnUpdateProperties(CCmdUI * pCmdUI)
{
    pCmdUI->Enable(TRUE);

}  //*** CClusterNode::OnUpdateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::BDisplayProperties
//
//  Description:
//      Display properties for the object.
//
//  Arguments:
//      bReadOnly   [IN] Don't allow edits to the object properties.
//
//  Return Values:
//      TRUE    OK pressed.
//      FALSE   OK not pressed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterNode::BDisplayProperties(IN BOOL bReadOnly)
{
    BOOL            bChanged = FALSE;
    CNodePropSheet  sht(AfxGetMainWnd());

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // If the object has changed, read it.
    if (BChanged())
        ReadItem();

    // Display the property sheet.
    try
    {
        sht.SetReadOnly(bReadOnly);
        if (sht.BInit(this, IimgObjectType()))
            bChanged = ((sht.DoModal() == IDOK) && !bReadOnly);
    }  // try
    catch (CException * pe)
    {
        pe->Delete();
    }  // catch:  CException

    Release();
    return bChanged;

}  //*** CClusterNode::BDisplayProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::OnClusterNotify
//
//  Description:
//      Handler for the WM_CAM_CLUSTER_NOTIFY message.
//      Processes cluster notifications for this object.
//
//  Arguments:
//      pnotify     [IN OUT] Object describing the notification.
//
//  Return Values:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CClusterNode::OnClusterNotify(IN OUT CClusterNotify * pnotify)
{
    ASSERT(pnotify != NULL);
    ASSERT_VALID(this);

    try
    {
        switch (pnotify->m_dwFilterType)
        {
            case CLUSTER_CHANGE_NODE_STATE:
                Trace(g_tagNodeNotify, _T("(%s) - Node '%s' (%x) state changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                UpdateState();
                break;

            case CLUSTER_CHANGE_NODE_DELETED:
                Trace(g_tagNodeNotify, _T("(%s) - Node '%s' (%x) deleted (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                if (Pdoc()->BClusterAvailable())
                    Delete();
                break;

            case CLUSTER_CHANGE_NODE_PROPERTY:
                Trace(g_tagNodeNotify, _T("(%s) - Node '%s' (%x) properties changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                if (Pdoc()->BClusterAvailable())
                    ReadItem();
                break;

            case CLUSTER_CHANGE_REGISTRY_NAME:
                Trace(g_tagNodeRegNotify, _T("(%s) - Registry namespace '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            case CLUSTER_CHANGE_REGISTRY_ATTRIBUTES:
                Trace(g_tagNodeRegNotify, _T("(%s) - Registry attributes for '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            case CLUSTER_CHANGE_REGISTRY_VALUE:
                Trace(g_tagNodeRegNotify, _T("(%s) - Registry value '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            default:
                Trace(g_tagNodeNotify, _T("(%s) - Unknown node notification (%x) for '%s' (%x) (%s)"), Pdoc()->StrNode(), pnotify->m_dwFilterType, StrName(), this, pnotify->m_strName);
        }  // switch:  dwFilterType
    }  // try
    catch (CException * pe)
    {
        // Don't display anything on notification errors.
        // If it's really a problem, the user will see it when
        // refreshing the view.
        //pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    delete pnotify;
    return 0;

}  //*** CClusterNode::OnClusterNotify()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::Delete
//
//  Description:
//      Do the CClusterItem::Delete processing unique to this class.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNode::Delete(void)
{
    POSITION        _pos = NULL;
    CResourceType * _ptype = NULL;
    CResource *     _pres = NULL;

    //
    // Remove this node from the resource types possible owners list
    //
    _pos = Pdoc()->LpciResourceTypes().GetHeadPosition();

    while (_pos != NULL)
    {
        _ptype = dynamic_cast<CResourceType *>(Pdoc()->LpciResourceTypes().GetNext(_pos));
        if (_ptype != NULL)
        {
            _ptype->RemoveNodeFromPossibleOwners(NULL, this);
        } // if: _ptype != NULL
    } // while: _pos != NULL

    //
    // Remove this node from the resources possible owners list
    //
    _pos = Pdoc()->LpciResources().GetHeadPosition();

    while (_pos != NULL)
    {
        _pres = dynamic_cast<CResource *>(Pdoc()->LpciResources().GetNext(_pos));
        if (_pres != NULL)
        {
            _pres->RemoveNodeFromPossibleOwners(NULL, this);
        } // if: _pres != NULL
    } // while: _pos != NULL

    CClusterItem::Delete();             // do the old processing

}  //*** CClusterNode::Delete()
*/

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNode::FCanBeEvicted
//
//  Description:
//      Determine if the node can be evicted.
//
//  Arguments:
//      None.
//
//  Return Values:
//      TRUE        Node can be evicted.
//      FALSE       Node can not be evicted.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CClusterNode::FCanBeEvicted( void )
{
    BOOL    fCanEvict;

    if ( ( m_nMajorVersion < 5 )
      || ( ( m_nMajorVersion == 5 )
        && ( m_nMinorVersion < 1 ) ) )
    {
        if ( ( Cns() == ClusterNodeDown )
          || ( Pdoc()->LpciNodes().GetCount() > 1 ) )
        {
            fCanEvict = TRUE;
        }
        else
        {
            fCanEvict = FALSE;
        }
    } // if: pre-Whistler node
    else
    {
        if ( ( Cns() == ClusterNodeDown )
          || ( Pdoc()->LpciNodes().GetCount() == 1 ) )
        {
            fCanEvict = TRUE;
        }
        else
        {
            fCanEvict = FALSE;
        }
    } // else: Whistler or higher node

    return fCanEvict;

} //*** CClusterNode::FCanBeEvicted()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DeleteAllItemData
//
//  Description:
//      Deletes all item data in a CList.
//
//  Arguments:
//      rlp     [IN OUT] List whose data is to be deleted.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef NEVER
void DeleteAllItemData(IN OUT CNodeList & rlp)
{
    POSITION        pos;
    CClusterNode *  pci;

    // Delete all the items in the Contained list.
    pos = rlp.GetHeadPosition();
    while (pos != NULL)
    {
        pci = rlp.GetNext(pos);
        ASSERT_VALID(pci);
//      Trace(g_tagClusItemDelete, _T("DeleteAllItemData(rlpcinode) - Deleting node cluster item '%s' (%x)"), pci->StrName(), pci);
        pci->Delete();
    }  // while:  more items in the list

}  //*** DeleteAllItemData()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\nodeprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		NodeProp.cpp
//
//	Abstract:
//		Definition of the node property sheet and pages.
//
//	Author:
//		David Potter (davidp)	May 17, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _NODEPROP_H_
#define _NODEPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePPag.h"	// for CBasePropertyPage
#endif

#ifndef _BASESHT_H_
#include "BasePSht.h"	// for CBasePropertySheet
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNodeGeneralPage;
class CNodePropSheet;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterNode;

/////////////////////////////////////////////////////////////////////////////
// CNodeGeneralPage dialog
/////////////////////////////////////////////////////////////////////////////

class CNodeGeneralPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CNodeGeneralPage)

// Construction
public:
	CNodeGeneralPage(void);

	virtual	BOOL		BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CNodeGeneralPage)
	enum { IDD = IDD_PP_NODE_GENERAL };
	CEdit	m_editDesc;
	CEdit	m_editName;
	CString	m_strName;
	CString	m_strDesc;
	CString	m_strState;
	CString	m_strVersion;
	CString	m_strCSDVersion;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNodeGeneralPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CNodePropSheet *	PshtNode(void)	{ return (CNodePropSheet *) Psht(); }
	CClusterNode *		PciNode(void)	{ return (CClusterNode *) Pci(); }

	// Generated message map functions
	//{{AFX_MSG(CNodeGeneralPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNodeGeneralPage

/////////////////////////////////////////////////////////////////////////////
// CNodePropSheet
/////////////////////////////////////////////////////////////////////////////

class CNodePropSheet : public CBasePropertySheet
{
	DECLARE_DYNAMIC(CNodePropSheet)

// Construction
public:
	CNodePropSheet(
		IN OUT CWnd *	pParentWnd = NULL,
		IN UINT			iSelectPage = 0
		);
	virtual BOOL					BInit(
										IN OUT CClusterItem *	pciCluster,
										IN IIMG					iimgIcon
										);

// Attributes
protected:
	CBasePropertyPage *				m_rgpages[1];

	// Pages
	CNodeGeneralPage				m_pageGeneral;

	CNodeGeneralPage &				PageGeneral(void)		{ return m_pageGeneral; }

public:
	CClusterNode *					PciNode(void) const		{ return (CClusterNode *) Pci(); }

// Operations

// Overrides
protected:
	virtual CBasePropertyPage **	Ppages(void);
	virtual int						Cpages(void);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNodePropSheet)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CNodePropSheet(void);

	// Generated message map functions
protected:
	//{{AFX_MSG(CNodePropSheet)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNodePropSheet

/////////////////////////////////////////////////////////////////////////////

#endif // _NODEPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\network.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1997-1999 Microsoft Corporation
//
//	Module Name:
//		Network.h
//
//	Abstract:
//		Definition of the CNetwork class.
//
//	Implementation File:
//		Network.cpp
//
//	Author:
//		David Potter (davidp)	May 28, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _NETWORK_H_
#define _NETWORK_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNetwork;
class CNetworkList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNetInterface;
class CNetInterfaceList;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSITEM_H_
#include "ClusItem.h"	// for CClusterItem
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"	// for CObjectProperty, CClusPropList
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetwork command target
/////////////////////////////////////////////////////////////////////////////

class CNetwork : public CClusterItem
{
	DECLARE_DYNCREATE(CNetwork)

// Construction
public:
	CNetwork(void);		// protected constructor used by dynamic creation
	void					Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName);

protected:
	void					CommonConstruct(void);

// Attributes
protected:
	HNETWORK				m_hnetwork;
    CLUSTER_NETWORK_STATE	m_cns;

	CLUSTER_NETWORK_ROLE	m_cnr;
	CString					m_strAddress;
	CString					m_strAddressMask;

	DWORD					m_dwCharacteristics;
	DWORD					m_dwFlags;

	CNetInterfaceList *		m_plpciNetInterfaces;

	enum
	{
		epropName = 0,
		epropRole,
		epropAddress,
		epropAddressMask,
		epropDescription,
		epropMAX
	};

	CObjectProperty		m_rgProps[epropMAX];

public:
	HNETWORK				Hnetwork(void) const				{ return m_hnetwork; }
	CLUSTER_NETWORK_STATE	Cns(void) const						{ return m_cns; }

	CLUSTER_NETWORK_ROLE	Cnr(void) const						{ return m_cnr; }
	const CString &			StrAddress(void) const				{ return m_strAddress; }
	const CString &			StrAddressMask(void) const			{ return m_strAddressMask; }
	DWORD					DwCharacteristics(void) const		{ return m_dwCharacteristics; }
	DWORD					DwFlags(void) const		            { return m_dwFlags; }

	const CNetInterfaceList &	LpciNetInterfaces(void) const	{ ASSERT(m_plpciNetInterfaces != NULL); return *m_plpciNetInterfaces; }

	void					GetStateName(OUT CString & rstrState) const;
	void					GetRoleName(OUT CString & rstrRole) const;

// Operations
public:
	void					CollectInterfaces(IN OUT CNetInterfaceList * plpci) const;

	void					ReadExtensions(void);

	void					AddNetInterface(IN OUT CNetInterface * pciNetIFace);
	void					RemoveNetInterface(IN OUT CNetInterface * pciNetIFace);

	void					SetName(IN LPCTSTR pszName);
	void					SetCommonProperties(
								IN const CString &		rstrDesc,
								IN CLUSTER_NETWORK_ROLE	cnr,
								IN BOOL					bValidateOnly
								);
	void					SetCommonProperties(
								IN const CString &		rstrDesc,
								IN CLUSTER_NETWORK_ROLE	cnr
								)
	{
		SetCommonProperties(rstrDesc, cnr, FALSE /*bValidateOnly*/);
	}
	void					ValidateCommonProperties(
								IN const CString &		rstrDesc,
								IN CLUSTER_NETWORK_ROLE	cnr
								)
	{
		SetCommonProperties(rstrDesc, cnr, TRUE /*bValidateOnly*/);
	}

// Overrides
public:
	virtual void			Cleanup(void);
	virtual void			ReadItem(void);
	virtual void			UpdateState(void);
	virtual void			Rename(IN LPCTSTR pszName);
	virtual	BOOL			BGetColumnData(IN COLID colid, OUT CString & rstrText);
	virtual BOOL			BCanBeEdited(void) const;
	virtual void			OnBeginLabelEdit(IN OUT CEdit * pedit);
	virtual BOOL			BDisplayProperties(IN BOOL bReadOnly = FALSE);

	virtual const CStringList *	PlstrExtensions(void) const;

#ifdef _DISPLAY_STATE_TEXT_IN_TREE
	virtual void			GetTreeName(OUT CString & rstrName) const;
#endif

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetwork)
	//}}AFX_VIRTUAL

	virtual LRESULT			OnClusterNotify(IN OUT CClusterNotify * pnotify);

protected:
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }
	virtual DWORD					DwSetCommonProperties(IN const CClusPropList & rcpl, IN BOOL bValidateOnly = FALSE);

// Implementation
public:
	virtual ~CNetwork(void);

public:
	// Generated message map functions
	//{{AFX_MSG(CNetwork)
	afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

};  //*** class CNetwork

/////////////////////////////////////////////////////////////////////////////
// CNetworkList
/////////////////////////////////////////////////////////////////////////////

class CNetworkList : public CClusterItemList
{
public:
	CNetwork *		PciNetworkFromName(
						IN LPCTSTR		pszName,
						OUT POSITION *	ppos = NULL
						)
	{
		return (CNetwork *) PciFromName(pszName, ppos);
	}

};  //*** class CNetworkList

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

//void DeleteAllItemData(IN OUT CNetworkList & rlp);

#ifdef _DEBUG
class CTraceTag;
extern CTraceTag g_tagNetwork;
extern CTraceTag g_tagNetNotify;
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _NETWORK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\notify.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		Notify.cpp
//
//	Abstract:
//		Implementation of the notification classes.
//
//	Author:
//		David Potter (davidp)	Septemper 26, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Notify.h"
#include "ClusDoc.h"
#include "ClusItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNotifyKey
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterNotifyKey::CClusterNotifyKey
//
//	Routine Description:
//		Cluster notification key constructor for documents.
//
//	Arguments:
//		pdoc		Pointer to the document.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNotifyKey::CClusterNotifyKey(
	IN CClusterDoc *	pdoc
	)
{
	ASSERT_VALID(pdoc);

	m_cnkt = cnktDoc;
	m_pdoc = pdoc;

}  //*** CClusterNotifyKey::CClusterNotifyKey(CClusterDoc*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterNotifyKey::CClusterNotifyKey
//
//	Routine Description:
//		Cluster notification key constructor.
//
//	Arguments:
//		pci			Pointer to the cluster item.
//		lpszName	Name of the object.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNotifyKey::CClusterNotifyKey(
	IN CClusterItem *	pci,
	IN LPCTSTR			lpszName
	)
{
	ASSERT_VALID(pci);
	ASSERT(lpszName != NULL);
	ASSERT(*lpszName != _T('\0'));

	m_cnkt = cnktClusterItem;
	m_pci = pci;

	try
	{
		m_strName = lpszName;
	}
	catch (...)
	{
	}  // catch:  anything

}  //*** CClusterNotifyKey::CClusterNotifyKey(CClusterItem*)


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
/////////////////////////////////////////////////////////////////////////////
//++
//
//	PszNotificationName
//
//	Routine Description:
//		Get the name of a notification.
//
//	Arguments:
//		dwNotification	[IN] Notification whose name is to be returned.
//
//	Return Value:
//		Name of the notificaiton.
//
//--
/////////////////////////////////////////////////////////////////////////////
LPCTSTR PszNotificationName(IN DWORD dwNotification)
{
	switch (dwNotification)
	{
		case CLUSTER_CHANGE_NODE_STATE:
			return _T("NODE_STATE");
		case CLUSTER_CHANGE_NODE_DELETED:
			return _T("NODE_DELETED");
		case CLUSTER_CHANGE_NODE_ADDED:
			return _T("NODE_ADDED");
		case CLUSTER_CHANGE_NODE_PROPERTY:
			return _T("NODE_PROPERTY");

		case CLUSTER_CHANGE_REGISTRY_NAME:
			return _T("REGISTRY_NAME");
		case CLUSTER_CHANGE_REGISTRY_ATTRIBUTES:
			return _T("REGISTRY_ATTRIBUTES");
		case CLUSTER_CHANGE_REGISTRY_VALUE:
			return _T("REGISTRY_VALUE");
		case CLUSTER_CHANGE_REGISTRY_SUBTREE:
			return _T("REGISTRY_SUBTREE");

		case CLUSTER_CHANGE_RESOURCE_STATE:
			return _T("RESOURCE_STATE");
		case CLUSTER_CHANGE_RESOURCE_DELETED:
			return _T("RESOURCE_DELETED");
		case CLUSTER_CHANGE_RESOURCE_ADDED:
			return _T("RESOURCE_ADDED");
		case CLUSTER_CHANGE_RESOURCE_PROPERTY:
			return _T("RESOURCE_PROPERTY");

		case CLUSTER_CHANGE_GROUP_STATE:
			return _T("GROUP_STATE");
		case CLUSTER_CHANGE_GROUP_DELETED:
			return _T("GROUP_DELETED");
		case CLUSTER_CHANGE_GROUP_ADDED:
			return _T("GROUP_ADDED");
		case CLUSTER_CHANGE_GROUP_PROPERTY:
			return _T("GROUP_PROPERTY");

		case CLUSTER_CHANGE_RESOURCE_TYPE_DELETED:
			return _T("RESOURCE_TYPE_DELETED");
		case CLUSTER_CHANGE_RESOURCE_TYPE_ADDED:
			return _T("RESOURCE_TYPE_ADDED");
		case CLUSTER_CHANGE_RESOURCE_TYPE_PROPERTY:
			return _T("RESOURCE_TYPE_PROPERTY");

		case CLUSTER_CHANGE_NETWORK_STATE:
			return _T("NETWORK_STATE");
		case CLUSTER_CHANGE_NETWORK_DELETED:
			return _T("NETWORK_DELETED");
		case CLUSTER_CHANGE_NETWORK_ADDED:
			return _T("NETWORK_ADDED");
		case CLUSTER_CHANGE_NETWORK_PROPERTY:
			return _T("NETWORK_PROPERTY");

		case CLUSTER_CHANGE_NETINTERFACE_STATE:
			return _T("NETINTERFACE_STATE");
		case CLUSTER_CHANGE_NETINTERFACE_DELETED:
			return _T("NETINTERFACE_DELETED");
		case CLUSTER_CHANGE_NETINTERFACE_ADDED:
			return _T("NETINTERFACE_ADDED");
		case CLUSTER_CHANGE_NETINTERFACE_PROPERTY:
			return _T("NETINTERFACE_PROPERTY");

		case CLUSTER_CHANGE_QUORUM_STATE:
			return _T("QUORUM_STATE");
		case CLUSTER_CHANGE_CLUSTER_STATE:
			return _T("CLUSTER_STATE");
		case CLUSTER_CHANGE_CLUSTER_PROPERTY:
			return _T("CLUSTER_PROPERTY");

		default:
			return _T("<UNKNOWN>");
	}  // switch:  dwNotification

}  //*** PszNotificationName()
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//	DeleteAllItemData
//
//	Routine Description:
//		Deletes all item data in a CList.
//
//	Arguments:
//		rlp		[IN OUT] List whose data is to be deleted.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DeleteAllItemData(IN OUT CClusterNotifyList & rlp)
{
	POSITION			pos;
	CClusterNotify *	pcn;

	// Delete all the items in the Contained list.
	pos = rlp.GetHeadPosition();
	while (pos != NULL)
	{
		pcn = rlp.GetNext(pos);
		ASSERT(pcn != NULL);
		delete pcn;
	}  // while:  more items in the list

}  //*** DeleteAllItemData()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\node.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      Node.h
//
//  Description:
//      Definition of the CClusterNode class.
//
//  Implementation File:
//      Node.cpp
//
//  Maintained By:
//      David Potter (davidp)   May 3, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _NODE_H_
#define _NODE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterNode;
class CNodeList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_H_
#include "ClusItem.h"   // for CClusterItem
#endif

#ifndef _GROUP_H_
#include "Group.h"      // for CGroupList
#endif

#ifndef _RES_H_
#include "Res.h"        // for CResourceList
#endif

#ifndef _NETIFACE_H_
#include "NetIFace.h"   // for CNetInterfaceList
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"   // for CObjectProperty, CClusPropList
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterNode command target
/////////////////////////////////////////////////////////////////////////////

class CClusterNode : public CClusterItem
{
    DECLARE_DYNCREATE(CClusterNode)

    CClusterNode(void);     // protected constructor used by dynamic creation
    void                    Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName);

// Attributes
protected:
    HNODE                   m_hnode;
    CLUSTER_NODE_STATE      m_cns;
    DWORD                   m_nNodeHighestVersion;
    DWORD                   m_nNodeLowestVersion;
    DWORD                   m_nMajorVersion;
    DWORD                   m_nMinorVersion;
    DWORD                   m_nBuildNumber;
    CString                 m_strCSDVersion;
    CGroupList *            m_plpcigrpOnline;
    CResourceList *         m_plpciresOnline;
    CNetInterfaceList *     m_plpciNetInterfaces;

    enum
    {
        epropName = 0,
        epropDescription,
        epropNodeHighestVersion,
        epropNodeLowestVersion,
        epropMajorVersion,
        epropMinorVersion,
        epropBuildNumber,
        epropCSDVersion,
        epropMAX
    };

    CObjectProperty     m_rgProps[epropMAX];

public:
    HNODE                   Hnode(void) const           { return m_hnode; }
    CLUSTER_NODE_STATE      Cns(void) const             { return m_cns; }
    DWORD                   NNodeHighestVersion(void) const { return m_nNodeHighestVersion; }
    DWORD                   NNodeLowestVersion(void) const  { return m_nNodeLowestVersion; }
    DWORD                   NMajorVersion(void) const   { return m_nMajorVersion; }
    DWORD                   NMinorVersion(void) const   { return m_nMinorVersion; }
    DWORD                   NBuildNumber(void) const    { return m_nBuildNumber; }
    const CString &         StrCSDVersion(void) const   { return m_strCSDVersion; }
    const CGroupList &      LpcigrpOnline(void) const   { ASSERT(m_plpcigrpOnline != NULL); return *m_plpcigrpOnline; }
    const CResourceList &   LpciresOnline(void) const   { ASSERT(m_plpciresOnline != NULL); return *m_plpciresOnline; }
    const CNetInterfaceList & LpciNetInterfaces(void) const { ASSERT(m_plpciNetInterfaces != NULL); return *m_plpciNetInterfaces; }

    void                    GetStateName(OUT CString & rstrState) const;
//  void                    Delete(void);

// Operations
public:
    void                    ReadExtensions(void);

    void                    AddActiveGroup(IN OUT CGroup * pciGroup);
    void                    AddActiveResource(IN OUT CResource * pciResource);
    void                    AddNetInterface(IN OUT CNetInterface * pciNetIFace);
    void                    RemoveActiveGroup(IN OUT CGroup * pciGroup);
    void                    RemoveActiveResource(IN OUT CResource * pciResource);
    void                    RemoveNetInterface(IN OUT CNetInterface * pciNetIFace);

    void                    SetDescription(IN const CString & rstrDesc, IN BOOL bValidateOnly = FALSE);
    void                    UpdateResourceTypePossibleOwners( void );

// Overrides
public:
    virtual void            Cleanup(void);
    virtual void            ReadItem(void);
    virtual void            UpdateState(void);
    virtual BOOL            BGetColumnData(IN COLID colid, OUT CString & rstrText);
    virtual BOOL            BDisplayProperties(IN BOOL bReadOnly = FALSE);

    // Drag & Drop
    virtual BOOL            BCanBeDropTarget(IN const CClusterItem * pci) const;
    virtual void            DropItem(IN OUT CClusterItem * pci);

    virtual const CStringList * PlstrExtensions(void) const;

#ifdef _DISPLAY_STATE_TEXT_IN_TREE
    virtual void            GetTreeName(OUT CString & rstrName) const;
#endif

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClusterNode)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    virtual LRESULT         OnClusterNotify(IN OUT CClusterNotify * pnotify);

protected:
    virtual const CObjectProperty * Pprops(void) const  { return m_rgProps; }
    virtual DWORD                   Cprops(void) const  { return sizeof(m_rgProps) / sizeof(CObjectProperty); }
    virtual DWORD                   DwSetCommonProperties(IN const CClusPropList & rcpl, IN BOOL bValidateOnly = FALSE);

// Implementation
public:
    virtual ~CClusterNode(void);

protected:
    CTreeItem *             m_ptiActiveGroups;
    CTreeItem *             m_ptiActiveResources;

    BOOL
        FCanBeEvicted( void );

protected:
    // Generated message map functions
    //{{AFX_MSG(CClusterNode)
    afx_msg void OnUpdatePauseNode(CCmdUI* pCmdUI);
    afx_msg void OnUpdateResumeNode(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEvictNode(CCmdUI* pCmdUI);
    afx_msg void OnUpdateStartService(CCmdUI* pCmdUI);
    afx_msg void OnUpdateStopService(CCmdUI* pCmdUI);
    afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
    afx_msg void OnCmdPauseNode();
    afx_msg void OnCmdResumeNode();
    afx_msg void OnCmdEvictNode();
    afx_msg void OnCmdStartService();
    afx_msg void OnCmdStopService();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
#ifdef _CLUADMIN_USE_OLE_
    DECLARE_OLECREATE(CClusterNode)

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CClusterNode)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()
#endif // _CLUADMIN_USE_OLE_

};  //*** class CClusterNode

/////////////////////////////////////////////////////////////////////////////
// CNodeList
/////////////////////////////////////////////////////////////////////////////

class CNodeList : public CClusterItemList
{
public:
    CClusterNode *      PciNodeFromName(
                            IN LPCTSTR      pszName,
                            OUT POSITION *  ppos = NULL
                            )
    {
        return (CClusterNode *) PciFromName(pszName, ppos);
    }

};  //*** class CNodeList

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

//void DeleteAllItemData(IN OUT CNodeList & rlp);

#ifdef _DEBUG
class CTraceTag;
extern CTraceTag g_tagNode;
extern CTraceTag g_tagNodeNotify;
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\network.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      Network.cpp
//
//  Abstract:
//      Implementation of the CNetwork class.
//
//  Author:
//      David Potter (davidp)   May 6, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "Network.h"
#include "ClusItem.inl"
#include "Cluster.h"
#include "NetProp.h"
#include "ExcOper.h"
#include "TraceTag.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagNetwork(_T("Document"), _T("NETWORK"), 0);
CTraceTag   g_tagNetNotify(_T("Notify"), _T("NET NOTIFY"), 0);
CTraceTag   g_tagNetRegNotify(_T("Notify"), _T("NET REG NOTIFY"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetwork
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNetwork, CClusterItem)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNetwork, CClusterItem)
    //{{AFX_MSG_MAP(CNetwork)
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::CNetwork
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetwork::CNetwork(void)
    : CClusterItem(NULL, IDS_ITEMTYPE_NETWORK)
{
    CommonConstruct();

}  //*** CResoruce::CNetwork()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::CommonConstruct(void)
{
    m_idmPopupMenu = IDM_NETWORK_POPUP;
    m_hnetwork = NULL;

    m_dwCharacteristics = CLUS_CHAR_UNKNOWN;
    m_dwFlags = 0;

    m_cnr = ClusterNetworkRoleNone;

    m_plpciNetInterfaces = NULL;

    // Set the object type image.
    m_iimgObjectType = GetClusterAdminApp()->Iimg(IMGLI_NETWORK);

    // Setup the property array.
    {
        m_rgProps[epropName].Set(CLUSREG_NAME_NET_NAME, m_strName, m_strName);
        m_rgProps[epropRole].Set(CLUSREG_NAME_NET_ROLE, (DWORD &) m_cnr, (DWORD &) m_cnr);
        m_rgProps[epropAddress].Set(CLUSREG_NAME_NET_ADDRESS, m_strAddress, m_strAddress);
        m_rgProps[epropAddressMask].Set(CLUSREG_NAME_NET_ADDRESS_MASK, m_strAddressMask, m_strAddressMask);
        m_rgProps[epropDescription].Set(CLUSREG_NAME_NET_DESC, m_strDescription, m_strDescription);
    }  // Setup the property array

}  //*** CNetwork::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::~CNetwork
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetwork::~CNetwork(void)
{
    // Cleanup this object.
    Cleanup();

    delete m_plpciNetInterfaces;

    // Close the network handle.
    if (Hnetwork() != NULL)
        CloseClusterNetwork(Hnetwork());

}  //*** CNetwork::~CNetwork

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::Cleanup
//
//  Routine Description:
//      Cleanup the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::Cleanup(void)
{
    // Delete the Network Interface list.
    if (m_plpciNetInterfaces != NULL)
        m_plpciNetInterfaces->RemoveAll();

    // Remove the item from the network list.
    {
        POSITION    posPci;

        posPci = Pdoc()->LpciNetworks().Find(this);
        if (posPci != NULL)
        {
            Pdoc()->LpciNetworks().RemoveAt(posPci);
        }  // if:  found in the document's list
    }  // Remove the item from the network list

}  //*** CNetwork::Cleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::Init
//
//  Routine Description:
//      Initialize the item.
//
//  Arguments:
//      pdoc        [IN OUT] Document to which this item belongs.
//      lpszName    [IN] Name of the item.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from OpenClusterNetwork or GetClusterNetworkKey.
//      Any exceptions thrown by new.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName)
{
    DWORD       dwStatus = ERROR_SUCCESS;
    LONG        lResult;
    CString     strName(lpszName);  // Required if built non-Unicode
    CWaitCursor wc;

    ASSERT(Hnetwork() == NULL);
    ASSERT(Hkey() == NULL);

    // Call the base class method.
    CClusterItem::Init(pdoc, lpszName);

    try
    {
        // Open the network.
        m_hnetwork = OpenClusterNetwork(Hcluster(), strName);
        if (Hnetwork() == NULL)
        {
            dwStatus = GetLastError();
            ThrowStaticException(dwStatus, IDS_OPEN_NETWORK_ERROR, lpszName);
        }  // if:  error opening the cluster network

        // Get the network registry key.
        m_hkey = GetClusterNetworkKey(Hnetwork(), MAXIMUM_ALLOWED);
//      if (Hkey() == NULL)
//          ThrowStaticException(GetLastError(), IDS_GET_NETWORK_KEY_ERROR, lpszName);

        if (BDocObj())
        {
            ASSERT(Pcnk() != NULL);
            Trace(g_tagClusItemNotify, _T("CNetwork::Init() - Registering for network notifications (%08.8x) for '%s'"), Pcnk(), StrName());

            // Register for network notifications.
            lResult = RegisterClusterNotify(
                                GetClusterAdminApp()->HchangeNotifyPort(),
                                (     CLUSTER_CHANGE_NETWORK_STATE
                                    | CLUSTER_CHANGE_NETWORK_DELETED
                                    | CLUSTER_CHANGE_NETWORK_PROPERTY),
                                Hnetwork(),
                                (DWORD_PTR) Pcnk()
                                );
            if (lResult != ERROR_SUCCESS)
            {
                dwStatus = lResult;
                ThrowStaticException(dwStatus, IDS_RES_NOTIF_REG_ERROR, lpszName);
            }  // if:  error registering for network notifications

            // Register for registry notifications.
            if (m_hkey != NULL)
            {
                lResult = RegisterClusterNotify(
                                    GetClusterAdminApp()->HchangeNotifyPort(),
                                    (CLUSTER_CHANGE_REGISTRY_NAME
                                        | CLUSTER_CHANGE_REGISTRY_ATTRIBUTES
                                        | CLUSTER_CHANGE_REGISTRY_VALUE
                                        | CLUSTER_CHANGE_REGISTRY_SUBTREE),
                                    Hkey(),
                                    (DWORD_PTR) Pcnk()
                                    );
                if (lResult != ERROR_SUCCESS)
                {
                    dwStatus = lResult;
                    ThrowStaticException(dwStatus, IDS_RES_NOTIF_REG_ERROR, lpszName);
                }  // if:  error registering for registry notifications
            }  // if:  there is a key
        }  // if:  document object

        // Allocate lists.
        m_plpciNetInterfaces = new CNetInterfaceList;
        if ( m_plpciNetInterfaces == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the network interface list

        // Read the initial state.
        UpdateState();
    }  // try
    catch (CException *)
    {
        if (Hkey() != NULL)
        {
            ClusterRegCloseKey(Hkey());
            m_hkey = NULL;
        }  // if:  registry key opened
        if (Hnetwork() != NULL)
        {
            CloseClusterNetwork(Hnetwork());
            m_hnetwork = NULL;
        }  // if:  network opened
        m_bReadOnly = TRUE;
        throw;
    }  // catch:  CException

}  //*** CNetwork::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::ReadItem
//
//  Routine Description:
//      Read the item parameters from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::ReadItem(void)
{
    DWORD       dwStatus;
    DWORD       dwRetStatus = ERROR_SUCCESS;
    CString     strOldName;
    CWaitCursor wc;

    ASSERT_VALID(this);

    if (Hnetwork() != NULL)
    {
        m_rgProps[epropDescription].m_value.pstr = &m_strDescription;
        m_rgProps[epropRole].m_value.pdw = (DWORD *) &m_cnr;

        // Save the name so we can detect changes.
        strOldName = StrName();

        // Call the base class method.
        CClusterItem::ReadItem();

        // Read and parse the common properties.
        {
            CClusPropList   cpl;

            dwStatus = cpl.ScGetNetworkProperties(
                                Hnetwork(),
                                CLUSCTL_NETWORK_GET_COMMON_PROPERTIES
                                );
            if (dwStatus == ERROR_SUCCESS)
                dwStatus = DwParseProperties(cpl);
            if (dwStatus != ERROR_SUCCESS)
                dwRetStatus = dwStatus;
        }  // Read and parse the common properties

        // Read and parse the read-only common properties.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            CClusPropList   cpl;

            dwStatus = cpl.ScGetNetworkProperties(
                                Hnetwork(),
                                CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES
                                );
            if (dwStatus == ERROR_SUCCESS)
                dwStatus = DwParseProperties(cpl);
            if (dwStatus != ERROR_SUCCESS)
                dwRetStatus = dwStatus;
        }  // if:  no error yet

        // Read the characteristics.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            DWORD   cbReturned;

            dwStatus = ClusterNetworkControl(
                            Hnetwork(),
                            NULL,
                            CLUSCTL_NETWORK_GET_CHARACTERISTICS,
                            NULL,
                            NULL,
                            &m_dwCharacteristics,
                            sizeof(m_dwCharacteristics),
                            &cbReturned
                            );
            if (dwStatus != ERROR_SUCCESS)
                dwRetStatus = dwStatus;
            else
            {
                ASSERT(cbReturned == sizeof(m_dwCharacteristics));
            }  // else:  data retrieved successfully
        }  // if:  no error yet

        // Read the flags.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            DWORD   cbReturned;

            dwStatus = ClusterNetworkControl(
                            Hnetwork(),
                            NULL,
                            CLUSCTL_NETWORK_GET_FLAGS,
                            NULL,
                            NULL,
                            &m_dwFlags,
                            sizeof(m_dwFlags),
                            &cbReturned
                            );
            if (dwStatus != ERROR_SUCCESS)
                dwRetStatus = dwStatus;
            else
            {
                ASSERT(cbReturned == sizeof(m_dwFlags));
            }  // else:  data retrieved successfully
        }  // if:  no error yet

        // Construct the list of extensions.
        ReadExtensions();

        // If the name changed, update all the network interfaces.
        if ( (m_plpciNetInterfaces != NULL) && (StrName() != strOldName) )
        {
            POSITION        posPciNetIFaces;
            CNetInterface * pciNetIFace;

            posPciNetIFaces = m_plpciNetInterfaces->GetHeadPosition();
            while ( posPciNetIFaces != NULL )
            {
                pciNetIFace = reinterpret_cast< CNetInterface * >( m_plpciNetInterfaces->GetNext(posPciNetIFaces) );
                ASSERT_VALID(pciNetIFace);
                ASSERT_KINDOF(CNetInterface, pciNetIFace);
                pciNetIFace->ReadItem();
            } // while:  more items in the list
        } // if:  list exists and name changed

    }  // if:  network is available

    // Read the initial state.
    UpdateState();

    // If any errors occurred, throw an exception.
    if (dwRetStatus != ERROR_SUCCESS)
    {
        m_bReadOnly = TRUE;
//      if (dwRetStatus != ERROR_FILE_NOT_FOUND)
            ThrowStaticException(dwRetStatus, IDS_READ_NETWORK_PROPS_ERROR, StrName());
    }  // if:  error reading properties

    MarkAsChanged(FALSE);

}  //*** CNetwork::ReadItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::ReadExtensions
//
//  Routine Description:
//      Read extension lists.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::ReadExtensions(void)
{
}  //*** CNetwork::ReadExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::PlstrExtension
//
//  Routine Description:
//      Return the list of admin extensions.
//
//  Arguments:
//      None.
//
//  Return Value:
//      plstr       List of extensions.
//      NULL        No extension associated with this object.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CStringList * CNetwork::PlstrExtensions(void) const
{
    return &Pdoc()->PciCluster()->LstrNetworkExtensions();

}  //*** CNetwork::PlstrExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::CollectInterfaces
//
//  Routine Description:
//      Construct a list of interfaces connected to this network.
//
//  Arguments:
//      plpci           [IN OUT] List to fill.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from ClusterNetworkOpenEnum() or
//                        ClusterNetworkEnum().
//      Any exceptions thrown by new or CList::AddTail().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::CollectInterfaces(IN OUT CNetInterfaceList * plpci) const
{
    DWORD           dwStatus;
    HNETWORKENUM    hnetenum;
    int             ienum;
    LPWSTR          pwszName = NULL;
    DWORD           cchName;
    DWORD           cchmacName;
    DWORD           dwRetType;
    CNetInterface * pciNetIFace;
    CWaitCursor     wc;

    ASSERT_VALID(Pdoc());
    ASSERT(Hnetwork() != NULL);

    if (plpci == NULL)
        plpci = m_plpciNetInterfaces;

    ASSERT(plpci != NULL);

    // Remove the previous contents of the list.
    plpci->RemoveAll();

    if (Hnetwork() != NULL)
    {
        // Open the enumeration.
        hnetenum = ClusterNetworkOpenEnum(Hnetwork(), CLUSTER_NETWORK_ENUM_NETINTERFACES);
        if (hnetenum == NULL)
            ThrowStaticException(GetLastError(), IDS_ENUM_NETWORK_INTERFACES_ERROR, StrName());

        try
        {
            // Allocate a name buffer.
            cchmacName = 128;
            pwszName = new WCHAR[cchmacName];
            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating name buffer

            // Loop through the enumeration and add each interface to the list.
            for (ienum = 0 ; ; ienum++)
            {
                // Get the next item in the enumeration.
                cchName = cchmacName;
                dwStatus = ClusterNetworkEnum(hnetenum, ienum, &dwRetType, pwszName, &cchName);
                if (dwStatus == ERROR_MORE_DATA)
                {
                    delete [] pwszName;
                    cchmacName = ++cchName;
                    pwszName = new WCHAR[cchmacName];
                    if ( pwszName == NULL )
                    {
                        AfxThrowMemoryException();
                    } // if: error allocating name buffer
                    dwStatus = ClusterNetworkEnum(hnetenum, ienum, &dwRetType, pwszName, &cchName);
                }  // if:  name buffer was too small
                if (dwStatus == ERROR_NO_MORE_ITEMS)
                    break;
                else if (dwStatus != ERROR_SUCCESS)
                    ThrowStaticException(dwStatus, IDS_ENUM_NETWORK_INTERFACES_ERROR, StrName());

                ASSERT(dwRetType == CLUSTER_NETWORK_ENUM_NETINTERFACES);

                // Find the item in the list of networks on the document.
                pciNetIFace = Pdoc()->LpciNetInterfaces().PciNetInterfaceFromName(pwszName);
                ASSERT_VALID(pciNetIFace);

                // Add the interface to the list.
                if (pciNetIFace != NULL)
                {
                    plpci->AddTail(pciNetIFace);
                }  // if:  found node in list

            }  // for:  each network interface connected to this network

            delete [] pwszName;
            ClusterNetworkCloseEnum(hnetenum);

        }  // try
        catch (CException *)
        {
            delete [] pwszName;
            ClusterNetworkCloseEnum(hnetenum);
            throw;
        }  // catch:  any exception
    }  // if:  network is available

}  //*** CNetwork::CollecPossibleOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::AddNetInterface
//
//  Routine Description:
//      Add a network interface to the list of interaces connected to this
//      network.
//
//  Arguments:
//      pciNetIFace     [IN OUT] New network interface.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::AddNetInterface(IN OUT CNetInterface * pciNetIFace)
{
    POSITION    posPci;

    ASSERT_VALID(pciNetIFace);
    Trace(g_tagNetwork, _T("(%s) (%s (%x)) - Adding network interface '%s'"), Pdoc()->StrNode(), StrName(), this, pciNetIFace->StrName());

    // Make sure the network interface is not already in the list.
    VERIFY((posPci = LpciNetInterfaces().Find(pciNetIFace)) == NULL);

    if (posPci == NULL)
    {
        POSITION    posPtiNetwork;
        CTreeItem * ptiNetwork;

        // Loop through each tree item to update the Network list.
        posPtiNetwork = LptiBackPointers().GetHeadPosition();
        while (posPtiNetwork != NULL)
        {
            ptiNetwork = LptiBackPointers().GetNext(posPtiNetwork);
            ASSERT_VALID(ptiNetwork);

            // Add the new network interface.
            VERIFY(ptiNetwork->PliAddChild(pciNetIFace) != NULL);
        }  // while:  more tree items for this network

        m_plpciNetInterfaces->AddTail(pciNetIFace);

    }  // if:  network interface not in the list yet

}  //*** CNetwork::AddNetInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::RemoveNetInterface
//
//  Routine Description:
//      Remove a network interface from the list of interfaces connected to
//      this network
//
//  Arguments:
//      pciNetIFace     [IN OUT] Network interface that is no longer
//                          connected to this network.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::RemoveNetInterface(IN OUT CNetInterface * pciNetIFace)
{
    POSITION    posPci;

    ASSERT_VALID(pciNetIFace);
    Trace(g_tagNetwork, _T("(%s) (%s (%x)) - Removing network interface '%s'"), Pdoc()->StrNode(), StrName(), this, pciNetIFace->StrName());

    // Make sure the network interface is in the list.
    VERIFY((posPci = LpciNetInterfaces().Find(pciNetIFace)) != NULL);

    if (posPci != NULL)
    {
        POSITION    posPtiNetwork;
        CTreeItem * ptiNetwork;

        // Loop through each tree item to update the Network list.
        posPtiNetwork = LptiBackPointers().GetHeadPosition();
        while (posPtiNetwork != NULL)
        {
            ptiNetwork = LptiBackPointers().GetNext(posPtiNetwork);
            ASSERT_VALID(ptiNetwork);

            // Remove the network interface.
            ptiNetwork->RemoveChild(pciNetIFace);
        }  // while:  more tree items for this network

        m_plpciNetInterfaces->RemoveAt(posPci);

    }  // if:  network interface in the list

}  //*** CNetwork::RemoveNetInterface()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::SetName
//
//  Routine Description:
//      Set the name of this network.
//
//  Arguments:
//      pszName         [IN] New name of the network.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by Rename().
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::SetName(IN LPCTSTR pszName)
{
    Rename(pszName);

}  //*** CNetwork::SetName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::SetCommonProperties
//
//  Routine Description:
//      Set the common properties for this network in the cluster database.
//
//  Arguments:
//      rstrDesc        [IN] Description string.
//      cnr             [IN] Network role.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusterItem::SetCommonProperties().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::SetCommonProperties(
    IN const CString &      rstrDesc,
    IN CLUSTER_NETWORK_ROLE cnr,
    IN BOOL                 bValidateOnly
    )
{
    CNTException    nte(ERROR_SUCCESS, 0, NULL, NULL, FALSE /*bAutoDelete*/);

    m_rgProps[epropDescription].m_value.pstr = (CString *) &rstrDesc;
    m_rgProps[epropRole].m_value.pdw = (DWORD *) &cnr;

    try
    {
        CClusterItem::SetCommonProperties(bValidateOnly);
    }  // try
    catch (CNTException * pnte)
    {
        nte.SetOperation(
                    pnte->Sc(),
                    pnte->IdsOperation(),
                    pnte->PszOperArg1(),
                    pnte->PszOperArg2()
                    );
    }  // catch:  CNTException

    m_rgProps[epropDescription].m_value.pstr = &m_strDescription;
    m_rgProps[epropRole].m_value.pdw = (DWORD *) &m_cnr;

    if (nte.Sc() != ERROR_SUCCESS)
        ThrowStaticException(
                        nte.Sc(),
                        nte.IdsOperation(),
                        nte.PszOperArg1(),
                        nte.PszOperArg2()
                        );

}  //*** CNetwork::SetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::DwSetCommonProperties
//
//  Routine Description:
//      Set the common properties for this network in the cluster database.
//
//  Arguments:
//      rcpl            [IN] Property list to set.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Value:
//      Any status returned by ClusterNetworkControl().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CNetwork::DwSetCommonProperties(
    IN const CClusPropList &    rcpl,
    IN BOOL                     bValidateOnly
    )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hnetwork());

    if ((rcpl.PbPropList() != NULL) && (rcpl.CbPropList() > 0))
    {
        DWORD   cbProps;
        DWORD   dwControl;

        if (bValidateOnly)
            dwControl = CLUSCTL_NETWORK_VALIDATE_COMMON_PROPERTIES;
        else
            dwControl = CLUSCTL_NETWORK_SET_COMMON_PROPERTIES;

        // Set common properties.
        dwStatus = ClusterNetworkControl(
                        Hnetwork(),
                        NULL,   // hNode
                        dwControl,
                        rcpl.PbPropList(),
                        rcpl.CbPropList(),
                        NULL,   // lpOutBuffer
                        0,      // nOutBufferSize
                        &cbProps
                        );
    }  // if:  there is data to set
    else
        dwStatus = ERROR_SUCCESS;

    return dwStatus;

}  //*** CNetwork::DwSetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::UpdateState
//
//  Routine Description:
//      Update the current state of the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::UpdateState(void)
{
    CClusterAdminApp *  papp = GetClusterAdminApp();

    Trace(g_tagNetwork, _T("(%s) (%s (%x)) - Updating state"), Pdoc()->StrNode(), StrName(), this);

    // Get the current state of the network.
    if (Hnetwork() == NULL)
        m_cns = ClusterNetworkStateUnknown;
    else
    {
        CWaitCursor wc;

        m_cns = GetClusterNetworkState(Hnetwork());
    }  // else:  network is available

    // Save the current state image index.
    switch (Cns())
    {
        case ClusterNetworkStateUnknown:
        case ClusterNetworkUnavailable:
            m_iimgState = papp->Iimg(IMGLI_NETWORK_UNKNOWN);
            break;
        case ClusterNetworkUp:
            m_iimgState = papp->Iimg(IMGLI_NETWORK);
            break;
        case ClusterNetworkPartitioned:
            m_iimgState = papp->Iimg(IMGLI_NETWORK_PARTITIONED);
            break;
        case ClusterNetworkDown:
            m_iimgState = papp->Iimg(IMGLI_NETWORK_DOWN);
            break;
        default:
            Trace(g_tagNetwork, _T("(%s) (%s (%x)) - UpdateState: Unknown state '%d' for network '%s'"), Pdoc()->StrNode(), StrName(), this, Cns(), StrName());
            m_iimgState = (UINT) -1;
            break;
    }  // switch:  Crs()

    // Call the base class method.
    CClusterItem::UpdateState();

}  //*** CNetwork::UpdateState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::BGetColumnData
//
//  Routine Description:
//      Returns a string with the column data.
//
//  Arguments:
//      colid           [IN] Column ID.
//      rstrText        [OUT] String in which to return the text for the column.
//
//  Return Value:
//      TRUE        Column data returned.
//      FALSE       Column ID not recognized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetwork::BGetColumnData(IN COLID colid, OUT CString & rstrText)
{
    BOOL    bSuccess;

    switch (colid)
    {
        case IDS_COLTEXT_STATE:
            GetStateName(rstrText);
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_ROLE:
            GetRoleName(rstrText);
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_ADDRESS:
            rstrText = m_strAddress;
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_MASK:
            rstrText = m_strAddressMask;
            bSuccess = TRUE;
            break;
        default:
            bSuccess = CClusterItem::BGetColumnData(colid, rstrText);
            break;
    }  // switch:  colid

    return bSuccess;

}  //*** CNetwork::BGetColumnData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::GetTreeName
//
//  Routine Description:
//      Returns a string to be used in a tree control.
//
//  Arguments:
//      rstrName    [OUT] String in which to return the name.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
void CNetwork::GetTreeName(OUT CString & rstrName) const
{
    CString     strState;

    GetStateName(strState);
    rstrName.Format(_T("%s (%s)"), StrName(), strState);

}  //*** CNetwork::GetTreeName()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::GetStateName
//
//  Routine Description:
//      Returns a string with the name of the current state.
//
//  Arguments:
//      rstrState   [OUT] String in which to return the name of the current state.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::GetStateName(OUT CString & rstrState) const
{
    switch (Cns())
    {
        case ClusterNetworkStateUnknown:
            rstrState.LoadString(IDS_UNKNOWN);
            break;
        case ClusterNetworkUp:
            rstrState.LoadString(IDS_UP);
            break;
        case ClusterNetworkPartitioned:
            rstrState.LoadString(IDS_PARTITIONED);
            break;
        case ClusterNetworkDown:
            rstrState.LoadString(IDS_DOWN);
            break;
        case ClusterNetworkUnavailable:
            rstrState.LoadString(IDS_UNAVAILABLE);
            break;
        default:
            rstrState.Empty();
            break;
    }  // switch:  Crs()

}  //*** CNetwork::GetStateName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::GetRoleName
//
//  Routine Description:
//      Returns a string with the name of the current network role.
//
//  Arguments:
//      rstrRole    [OUT] String in which to return the name of the current role.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::GetRoleName(OUT CString & rstrRole) const
{
    switch (Cnr())
    {
        case ClusterNetworkRoleInternalAndClient:
            rstrRole.LoadString(IDS_CLIENT_AND_CLUSTER);
            break;
        case ClusterNetworkRoleClientAccess:
            rstrRole.LoadString(IDS_CLIENT_ONLY);
            break;
        case ClusterNetworkRoleInternalUse:
            rstrRole.LoadString(IDS_CLUSTER_ONLY);
            break;
        case ClusterNetworkRoleNone:
            rstrRole.LoadString(IDS_DONT_USE);
            break;
        default:
            rstrRole.Empty();
            break;
    }  // switch:  Cnr()

}  //*** CNetwork::GetRoleName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::BCanBeEdited
//
//  Routine Description:
//      Determines if the network can be renamed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Network can be renamed.
//      FALSE       Network cannot be renamed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetwork::BCanBeEdited(void) const
{
    BOOL    bCanBeEdited;

    if (   (Cns() == ClusterNetworkStateUnknown)
        || BReadOnly())
        bCanBeEdited  = FALSE;
    else
        bCanBeEdited = TRUE;

    return bCanBeEdited;

}  //*** CNetwork::BCanBeEdited()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::Rename
//
//  Routine Description:
//      Rename the network.
//
//  Arguments:
//      pszName         [IN] New name to give to the network.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors returned from SetClusterNetwName().
//      Any exceptions thrown by SetClusterNetworkName().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::Rename(IN LPCTSTR pszName)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hnetwork() != NULL);

    if (StrName() != pszName)
    {
        // Validate the name.
        if (!NcIsValidConnectionName(pszName))
        {
            ThrowStaticException((IDS) IDS_INVALID_NETWORK_CONNECTION_NAME);
        } // if:  error validating the name

        dwStatus = SetClusterNetworkName(Hnetwork(), pszName);
        if (dwStatus != ERROR_SUCCESS)
            ThrowStaticException(dwStatus, IDS_RENAME_NETWORK_ERROR, StrName(), pszName);
    }  // if:  the name changed

}  //*** CNetwork::Rename()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::OnBeginLabelEdit
//
//  Routine Description:
//      Prepare an edit control in a view for editing the cluster name.
//
//  Arguments:
//      pedit       [IN OUT] Edit control to prepare.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::OnBeginLabelEdit(IN OUT CEdit * pedit)
{
    ASSERT_VALID(pedit);

    pedit->SetLimitText(NETCON_MAX_NAME_LEN);

}  //*** CNetwork::OnBeginLabelEdit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::OnUpdateProperties
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_PROPERTIES
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetwork::OnUpdateProperties(CCmdUI * pCmdUI)
{
    pCmdUI->Enable(TRUE);

}  //*** CNetwork::OnUpdateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::BDisplayProperties
//
//  Routine Description:
//      Display properties for the object.
//
//  Arguments:
//      bReadOnly   [IN] Don't allow edits to the object properties.
//
//  Return Value:
//      TRUE    OK pressed.
//      FALSE   OK not pressed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetwork::BDisplayProperties(IN BOOL bReadOnly)
{
    BOOL                bChanged = FALSE;
    CNetworkPropSheet   sht(AfxGetMainWnd());

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // If the object has changed, read it.
    if (BChanged())
        ReadItem();

    // Display the property sheet.
    try
    {
        sht.SetReadOnly(bReadOnly);
        if (sht.BInit(this, IimgObjectType()))
            bChanged = ((sht.DoModal() == IDOK) && !bReadOnly);
    }  // try
    catch (CException * pe)
    {
        pe->Delete();
    }  // catch:  CException

    Release();
    return bChanged;

}  //*** CNetwork::BDisplayProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetwork::OnClusterNotify
//
//  Routine Description:
//      Handler for the WM_CAM_CLUSTER_NOTIFY message.
//      Processes cluster notifications for this object.
//
//  Arguments:
//      pnotify     [IN OUT] Object describing the notification.
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CNetwork::OnClusterNotify(IN OUT CClusterNotify * pnotify)
{
    ASSERT(pnotify != NULL);
    ASSERT_VALID(this);

    try
    {
        switch (pnotify->m_dwFilterType)
        {
            case CLUSTER_CHANGE_NETWORK_STATE:
                Trace(g_tagNetNotify, _T("(%s) - Network '%s' (%x) state changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                UpdateState();
                break;

            case CLUSTER_CHANGE_NETWORK_DELETED:
                Trace(g_tagNetNotify, _T("(%s) - Network '%s' (%x) deleted (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                if (Pdoc()->BClusterAvailable())
                    Delete();
                break;

            case CLUSTER_CHANGE_NETWORK_PROPERTY:
                Trace(g_tagNetNotify, _T("(%s) - Network '%s' (%x) properties changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                if (Pdoc()->BClusterAvailable())
                    ReadItem();
                break;

            case CLUSTER_CHANGE_REGISTRY_NAME:
                Trace(g_tagNetRegNotify, _T("(%s) - Registry namespace '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            case CLUSTER_CHANGE_REGISTRY_ATTRIBUTES:
                Trace(g_tagNetRegNotify, _T("(%s) - Registry attributes for '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            case CLUSTER_CHANGE_REGISTRY_VALUE:
                Trace(g_tagNetRegNotify, _T("(%s) - Registry value '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            default:
                Trace(g_tagNetNotify, _T("(%s) - Unknown network notification (%x) for '%s' (%x) (%s)"), Pdoc()->StrNode(), pnotify->m_dwFilterType, StrName(), this, pnotify->m_strName);
        }  // switch:  dwFilterType
    }  // try
    catch (CException * pe)
    {
        // Don't display anything on notification errors.
        // If it's really a problem, the user will see it when
        // refreshing the view.
        //pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    delete pnotify;
    return 0;

}  //*** CNetwork::OnClusterNotify()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DeleteAllItemData
//
//  Routine Description:
//      Deletes all item data in a CList.
//
//  Arguments:
//      rlp     [IN OUT] List whose data is to be deleted.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef NEVER
void DeleteAllItemData(IN OUT CNetworkList & rlp)
{
    POSITION    pos;
    CNetwork *  pci;

    // Delete all the items in the Contained list.
    pos = rlp.GetHeadPosition();
    while (pos != NULL)
    {
        pci = rlp.GetNext(pos);
        ASSERT_VALID(pci);
//      Trace(g_tagClusItemDelete, _T("DeleteAllItemData(rlp) - Deleting network cluster item '%s' (%x)"), pci->StrName(), pci);
        pci->Delete();
    }  // while:  more items in the list

}  //*** DeleteAllItemData()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\proplsts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		PropLstS.cpp
//
//	Abstract:
//		Stub for implementation of property list classes.
//
//	Author:
//		David Potter (davidp)	February 24, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "PropList.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\nodeprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		NodeProp.cpp
//
//	Abstract:
//		Implementation of the node property sheet and pages.
//
//	Author:
//		David Potter (davidp)	May 17, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "NodeProp.h"
#include "Node.h"
#include "HelpData.h"	// for g_rghelpmapNodeGeneral

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNodePropSheet
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CNodePropSheet, CBasePropertySheet)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNodePropSheet, CBasePropertySheet)
	//{{AFX_MSG_MAP(CNodePropSheet)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodePropSheet::CNodePropSheet
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pci			[IN OUT] Cluster item whose properties are to be displayed.
//		pParentWnd	[IN OUT] Parent window for this property sheet.
//		iSelectPage	[IN] Page to show first.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNodePropSheet::CNodePropSheet(
	IN OUT CWnd *			pParentWnd,
	IN UINT					iSelectPage
	)
	: CBasePropertySheet(pParentWnd, iSelectPage)
{
	m_rgpages[0] = &PageGeneral();

}  //*** CNodePropSheet::CNodePropSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodePropSheet::BInit
//
//	Routine Description:
//		Initialize the property sheet.
//
//	Arguments:
//		pci			[IN OUT] Cluster item whose properties are to be displayed.
//		iimgIcon	[IN] Index in the large image list for the image to use
//					  as the icon on each page.
//
//	Return Value:
//		TRUE		Property sheet initialized successfully.
//		FALSE		Error initializing property sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNodePropSheet::BInit(
	IN OUT CClusterItem *	pci,
	IN IIMG					iimgIcon
	)
{
	// Call the base class method.
	if (!CBasePropertySheet::BInit(pci, iimgIcon))
		return FALSE;

	// Set the read-only flag.
	m_bReadOnly = PciNode()->BReadOnly()
					|| (PciNode()->Cns() == ClusterNodeStateUnknown);

	return TRUE;

}  //*** CNodePropSheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodePropSheet::~CNodePropSheet
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNodePropSheet::~CNodePropSheet(void)
{
}  //*** CNodePropSheet::~CNodePropSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodePropSheet::Ppages
//
//	Routine Description:
//		Returns the array of pages to add to the property sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Page array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage ** CNodePropSheet::Ppages(void)
{
	return m_rgpages;

}  //*** CNodePropSheet::Ppages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodePropSheet::Cpages
//
//	Routine Description:
//		Returns the count of pages in the array.
//
//	Arguments:
//		None.
//
//	Return Value:
//		Count of pages in the array.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CNodePropSheet::Cpages(void)
{
	return sizeof(m_rgpages) / sizeof(CBasePropertyPage *);

}  //*** CNodePropSheet::Cpages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNodeGeneralPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNodeGeneralPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CNodeGeneralPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CNodeGeneralPage)
	//}}AFX_MSG_MAP
	ON_EN_CHANGE(IDC_PP_NODE_DESC, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodeGeneralPage::CNodeGeneralPage
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNodeGeneralPage::CNodeGeneralPage(void)
	: CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_NODE_GENERAL)
{
	//{{AFX_DATA_INIT(CNodeGeneralPage)
	m_strName = _T("");
	m_strDesc = _T("");
	m_strState = _T("");
	//}}AFX_DATA_INIT

}  //*** CNodeGeneralPage::CNodeGeneralPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodeGeneralPage::BInit
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		psht		[IN OUT] Property sheet to which this page belongs.
//
//	Return Value:
//		TRUE		Page initialized successfully.
//		FALSE		Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNodeGeneralPage::BInit(IN OUT CBaseSheet * psht)
{
	BOOL	bSuccess;

	ASSERT_KINDOF(CNodePropSheet, psht);

	bSuccess = CBasePropertyPage::BInit(psht);
	if (bSuccess)
	{
		try
		{
			m_strName = PciNode()->StrName();
			m_strDesc = PciNode()->StrDescription();
			m_strVersion.Format(
				IDS_VERSION_NUMBER_FORMAT,
				PciNode()->NMajorVersion(),
				PciNode()->NMinorVersion(),
				PciNode()->NBuildNumber(),
				0
				);
			m_strCSDVersion = PciNode()->StrCSDVersion();

			PciNode()->GetStateName(m_strState);
		}  // try
		catch (CException * pe)
		{
			pe->ReportError();
			pe->Delete();
			bSuccess = FALSE;
		}  // catch:  CException
	}  // if:  base class method was successful

	return bSuccess;

}  //*** CNodeGeneralPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodeGeneralPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNodeGeneralPage::DoDataExchange(CDataExchange * pDX)
{
	CBasePropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNodeGeneralPage)
	DDX_Control(pDX, IDC_PP_NODE_DESC, m_editDesc);
	DDX_Control(pDX, IDC_PP_NODE_NAME, m_editName);
	DDX_Text(pDX, IDC_PP_NODE_NAME, m_strName);
	DDX_Text(pDX, IDC_PP_NODE_DESC, m_strDesc);
	DDX_Text(pDX, IDC_PP_NODE_CURRENT_STATE, m_strState);
	DDX_Text(pDX, IDC_PP_NODE_VERSION, m_strVersion);
	DDX_Text(pDX, IDC_PP_NODE_CSD_VERSION, m_strCSDVersion);
	//}}AFX_DATA_MAP

}  //*** CNodeGeneralPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodeGeneralPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Focus needs to be set.
//		FALSE	Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNodeGeneralPage::OnInitDialog(void)
{
	CBasePropertyPage::OnInitDialog();

	m_editName.SetReadOnly(TRUE);

	// If read-only, set all controls to be either disabled or read-only.
	if (BReadOnly())
	{
		m_editDesc.SetReadOnly(TRUE);
	}  // if:  sheet is read-only

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CNodeGeneralPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CNodeGeneralPage::OnApply
//
//	Routine Description:
//		Handler for when the Apply button is pressed.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNodeGeneralPage::OnApply(void)
{
	// Set the data from the page in the cluster item.
	try
	{
		CWaitCursor	wc;

		PciNode()->SetDescription(m_strDesc);
	}  // try
	catch (CException * pe)
	{
		pe->ReportError();
		pe->Delete();
		return FALSE;
	}  // catch:  CException

	return CBasePropertyPage::OnApply();

}  //*** CNodeGeneralPage::OnApply()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\olcpair.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		OLCPair.h
//
//	Abstract:
//		Definition of the CListCtrlPair dialog.
//
//	Implementation File:
//		OLCPair.cpp
//
//	Author:
//		David Potter (davidp)	August 8, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _OLCPAIR_H_
#define _OLCPAIR_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _LCPAIR_H_
#include "LCPair.h"		// for CListCtrlPair
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class COrderedListCtrlPair;

/////////////////////////////////////////////////////////////////////////////
// COrderedListCtrlPair command target
/////////////////////////////////////////////////////////////////////////////

class COrderedListCtrlPair : public CListCtrlPair
{
	DECLARE_DYNCREATE(COrderedListCtrlPair)

// Construction
public:
	COrderedListCtrlPair(void);			// protected constructor used by dynamic creation
	COrderedListCtrlPair(
		IN OUT CDialog *			pdlg,
		IN OUT CClusterItemList *	plpobjRight,
		IN const CClusterItemList *	plpobjLeft,
		IN DWORD					dwStyle,
		IN PFNLCPGETCOLUMN			pfnGetColumn,
		IN PFNLCPDISPPROPS			pfnDisplayProps
		);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COrderedListCtrlPair)
	//}}AFX_VIRTUAL
	virtual BOOL	OnSetActive(void);
	virtual void	DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	CButton			m_pbMoveUp;
	CButton			m_pbMoveDown;

	void			SetUpDownState(void);

	// Generated message map functions
	//{{AFX_MSG(COrderedListCtrlPair)
	//}}AFX_MSG
public:
	virtual BOOL OnInitDialog();
protected:
	afx_msg void OnClickedMoveUp();
	afx_msg void OnClickedMoveDown();
	afx_msg void OnItemChangedRightList(NMHDR* pNMHDR, LRESULT* pResult);

	DECLARE_MESSAGE_MAP()

};  //*** class COrderedListCtrlPair

/////////////////////////////////////////////////////////////////////////////

#endif // _OLCPAIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\res.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      Res.cpp
//
//  Abstract:
//      Implementation of the CResource class.
//
//  Author:
//      David Potter (davidp)   May 6, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "Res.h"
#include "ClusItem.inl"
#include "ResProp.h"
#include "ExcOper.h"
#include "TraceTag.h"
#include "Cluster.h"
#include "DelRes.h"
#include "MoveRes.h"
#include "WaitDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagResource(_T("Document"), _T("RESOURCE"), 0);
CTraceTag   g_tagResNotify(_T("Notify"), _T("RES NOTIFY"), 0);
CTraceTag   g_tagResRegNotify(_T("Notify"), _T("RES REG NOTIFY"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CResource
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CResource, CClusterItem)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CResource, CClusterItem)
    //{{AFX_MSG_MAP(CResource)
    ON_UPDATE_COMMAND_UI(ID_FILE_BRING_ONLINE, OnUpdateBringOnline)
    ON_UPDATE_COMMAND_UI(ID_FILE_TAKE_OFFLINE, OnUpdateTakeOffline)
    ON_UPDATE_COMMAND_UI(ID_FILE_INITIATE_FAILURE, OnUpdateInitiateFailure)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_1, OnUpdateMoveResource1)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_2, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_3, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_4, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_5, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_6, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_7, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_8, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_9, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_10, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_11, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_12, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_13, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_14, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_15, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_16, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_17, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_18, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_19, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_MOVE_RESOURCE_20, OnUpdateMoveResourceRest)
    ON_UPDATE_COMMAND_UI(ID_FILE_DELETE, OnUpdateDelete)
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
    ON_COMMAND(ID_FILE_BRING_ONLINE, OnCmdBringOnline)
    ON_COMMAND(ID_FILE_TAKE_OFFLINE, OnCmdTakeOffline)
    ON_COMMAND(ID_FILE_INITIATE_FAILURE, OnCmdInitiateFailure)
    ON_COMMAND(ID_FILE_DELETE, OnCmdDelete)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::CResource
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResource::CResource(void)
    : CClusterItem(NULL, IDS_ITEMTYPE_RESOURCE)
{
    CommonConstruct();

} //*** CResoruce::CResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::CResource
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      bDocObj     [IN] TRUE = object is part of the document.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResource::CResource(IN BOOL bDocObj)
    : CClusterItem(NULL, IDS_ITEMTYPE_RESOURCE)
{
    CommonConstruct();
    m_bDocObj = bDocObj;

} //*** CResource::CResource(bDocObj)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::CommonConstruct(void)
{
    m_idmPopupMenu = IDM_RESOURCE_POPUP;
    m_bInitializing = FALSE;
    m_bDeleting = FALSE;

    m_hresource = NULL;

    m_bSeparateMonitor = FALSE;
    m_nLooksAlive = CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE;
    m_nIsAlive = CLUSTER_RESOURCE_DEFAULT_IS_ALIVE;
    m_crraRestartAction = CLUSTER_RESOURCE_DEFAULT_RESTART_ACTION;
    m_nRestartThreshold = CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD;
    m_nRestartPeriod = CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD;
    m_nPendingTimeout = CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT;

    m_rciResClassInfo.rc = CLUS_RESCLASS_UNKNOWN;
    m_rciResClassInfo.SubClass = 0;
    m_dwCharacteristics = CLUS_CHAR_UNKNOWN;
    m_dwFlags = 0;

    m_pciOwner = NULL;
    m_pciGroup = NULL;
    m_pciResourceType = NULL;
    m_pcrd = NULL;

    m_plpciresDependencies = NULL;
    m_plpcinodePossibleOwners = NULL;

    // Set the object type image.
    m_iimgObjectType = GetClusterAdminApp()->Iimg(IMGLI_RES);

    // Setup the property array.
    {
        m_rgProps[epropName].Set(CLUSREG_NAME_RES_NAME, m_strName, m_strName);
        m_rgProps[epropType].Set(CLUSREG_NAME_RES_TYPE, m_strResourceType, m_strResourceType);
        m_rgProps[epropDescription].Set(CLUSREG_NAME_RES_DESC, m_strDescription, m_strDescription);
        m_rgProps[epropSeparateMonitor].Set(CLUSREG_NAME_RES_SEPARATE_MONITOR, m_bSeparateMonitor, m_bSeparateMonitor);
        m_rgProps[epropLooksAlive].Set(CLUSREG_NAME_RES_LOOKS_ALIVE, m_nLooksAlive, m_nLooksAlive);
        m_rgProps[epropIsAlive].Set(CLUSREG_NAME_RES_IS_ALIVE, m_nIsAlive, m_nIsAlive);
        m_rgProps[epropRestartAction].Set(CLUSREG_NAME_RES_RESTART_ACTION, (DWORD &) m_crraRestartAction, (DWORD &) m_crraRestartAction);
        m_rgProps[epropRestartThreshold].Set(CLUSREG_NAME_RES_RESTART_THRESHOLD, m_nRestartThreshold, m_nRestartThreshold);
        m_rgProps[epropRestartPeriod].Set(CLUSREG_NAME_RES_RESTART_PERIOD, m_nRestartPeriod, m_nRestartPeriod);
        m_rgProps[epropPendingTimeout].Set(CLUSREG_NAME_RES_PENDING_TIMEOUT, m_nPendingTimeout, m_nPendingTimeout);
    } // Setup the property array

#ifdef _CLUADMIN_USE_OLE_
    EnableAutomation();
#endif

    // To keep the application running as long as an OLE automation
    //  object is active, the constructor calls AfxOleLockApp.

//  AfxOleLockApp();

} //*** CResource::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::~CResource
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResource::~CResource(void)
{
    // Cleanup this object.
    Cleanup();

    delete m_plpciresDependencies;
    delete m_plpcinodePossibleOwners;
    delete [] (PBYTE) m_pcrd;

    // Close the resource handle.
    if (Hresource() != NULL)
    {
        CloseClusterResource(Hresource());
        m_hresource = NULL;
    } // if:  resource is open

    // To terminate the application when all objects created with
    //  with OLE automation, the destructor calls AfxOleUnlockApp.

//  AfxOleUnlockApp();

} //*** CResource::~CResource

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::Cleanup
//
//  Routine Description:
//      Cleanup the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::Cleanup(void)
{
    // Delete the Dependencies list.
    if (m_plpciresDependencies != NULL)
        m_plpciresDependencies->RemoveAll();

    // Delete the PossibleOwners list.
    if (m_plpcinodePossibleOwners != NULL)
        m_plpcinodePossibleOwners->RemoveAll();

    // If we are active on a node, remove ourselves from that active list.
    if (PciOwner() != NULL)
    {
        if (BDocObj())
            PciOwner()->RemoveActiveResource(this);
        PciOwner()->Release();
        m_pciOwner = NULL;
    } // if:  there is an owner

    // Remove ourselves from the group's list.
    if (PciGroup() != NULL)
    {
        if (BDocObj())
            PciGroup()->RemoveResource(this);
        PciGroup()->Release();
        m_pciGroup = NULL;
    } // if:  there is a group

    // Update the reference count to the resource type
    if (PciResourceType() != NULL)
    {
        PciResourceType()->Release();
        m_pciResourceType = NULL;
    } // if:  there is a resource type

    // Remove the item from the resource list.
    if (BDocObj())
    {
        POSITION    posPci;

        posPci = Pdoc()->LpciResources().Find(this);
        if (posPci != NULL)
        {
            Pdoc()->LpciResources().RemoveAt(posPci);
        } // if:  found in the document's list
    } // if:  this is a document object

} //*** CResource::Cleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::Create
//
//  Routine Description:
//      Create a resource.
//
//  Arguments:
//      pdoc                [IN OUT] Document to which this item belongs.
//      lpszName            [IN] Name of the resource.
//      lpszType            [IN] Type of the resource.
//      lpszGroup           [IN] Group in which to create the resource.
//      bSeparateMonitor    [IN] TRUE = run resource in separate monitor.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from CreateClusterResource.
//      Any exceptions thrown by CResource::Init(), CResourceList::new(),
//      or CNodeList::new().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::Create(
    IN OUT CClusterDoc *    pdoc,
    IN LPCTSTR              lpszName,
    IN LPCTSTR              lpszType,
    IN LPCTSTR              lpszGroup,
    IN BOOL                 bSeparateMonitor
    )
{
    DWORD       dwStatus;
    DWORD       dwFlags;
    HRESOURCE   hresource;
    CGroup *    pciGroup;
    CString     strName(lpszName);  // Required if built non-Unicode
    CString     strType(lpszType);  // Required if built non-Unicode
    CWaitCursor wc;

    ASSERT(Hresource() == NULL);
    ASSERT(Hkey() == NULL);
    ASSERT_VALID(pdoc);
    ASSERT(lpszName != NULL);
    ASSERT(lpszType != NULL);
    ASSERT(lpszGroup != NULL);

    // Find the specified group.
    pciGroup = pdoc->LpciGroups().PciGroupFromName(lpszGroup);
    ASSERT_VALID(pciGroup);

    // Set the flags.
    if (bSeparateMonitor)
        dwFlags = CLUSTER_RESOURCE_SEPARATE_MONITOR;
    else
        dwFlags = 0;

    // Create the resource.
    hresource = CreateClusterResource(pciGroup->Hgroup(), strName, strType, dwFlags);
    if (hresource == NULL)
    {
        dwStatus = GetLastError();
        ThrowStaticException(dwStatus, IDS_CREATE_RESOURCE_ERROR, lpszName);
    } // if:  error creating the cluster resource

    CloseClusterResource(hresource);

    // Open the resource.
    Init(pdoc, lpszName);

} //*** CResource::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::Init
//
//  Routine Description:
//      Initialize the item.
//
//  Arguments:
//      pdoc        [IN OUT] Document to which this item belongs.
//      lpszName    [IN] Name of the item.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from OpenClusterResource or GetClusterResourceKey.
//      Any exceptions thrown by new.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName)
{
    DWORD       dwStatus = ERROR_SUCCESS;
    LONG        lResult;
    CString     strName(lpszName);  // Required if built non-Unicode
    CWaitCursor wc;

    ASSERT(Hresource() == NULL);
    ASSERT(Hkey() == NULL);

    // Call the base class method.
    CClusterItem::Init(pdoc, lpszName);

    try
    {
        // Open the resource.
        m_hresource = OpenClusterResource(Hcluster(), strName);
        if (Hresource() == NULL)
        {
            dwStatus = GetLastError();
            ThrowStaticException(dwStatus, IDS_OPEN_RESOURCE_ERROR, lpszName);
        } // if:  error opening the cluster resource

        // Get the resource registry key.
        m_hkey = GetClusterResourceKey(Hresource(), MAXIMUM_ALLOWED);
        if (Hkey() == NULL)
            ThrowStaticException(GetLastError(), IDS_GET_RESOURCE_KEY_ERROR, lpszName);

        if (BDocObj())
        {
            ASSERT(Pcnk() != NULL);
            Trace(g_tagClusItemNotify, _T("CResource::Init() - Registering for resource notifications (%08.8x) for '%s'"), Pcnk(), StrName());

            // Register for resource notifications.
            lResult = RegisterClusterNotify(
                                GetClusterAdminApp()->HchangeNotifyPort(),
                                (CLUSTER_CHANGE_RESOURCE_STATE
                                    | CLUSTER_CHANGE_RESOURCE_DELETED
                                    | CLUSTER_CHANGE_RESOURCE_PROPERTY),
                                Hresource(),
                                (DWORD_PTR) Pcnk()
                                );
            if (lResult != ERROR_SUCCESS)
            {
                dwStatus = lResult;
                ThrowStaticException(dwStatus, IDS_RES_NOTIF_REG_ERROR, lpszName);
            } // if:  error registering for resource notifications

            // Register for registry notifications.
            if (Hkey != NULL)
            {
                lResult = RegisterClusterNotify(
                                    GetClusterAdminApp()->HchangeNotifyPort(),
                                    (CLUSTER_CHANGE_REGISTRY_NAME
                                        | CLUSTER_CHANGE_REGISTRY_ATTRIBUTES
                                        | CLUSTER_CHANGE_REGISTRY_VALUE
                                        | CLUSTER_CHANGE_REGISTRY_SUBTREE),
                                    Hkey(),
                                    (DWORD_PTR) Pcnk()
                                    );
                if (lResult != ERROR_SUCCESS)
                {
                    dwStatus = lResult;
                    ThrowStaticException(dwStatus, IDS_RES_NOTIF_REG_ERROR, lpszName);
                } // if:  error registering for registry notifications
            } // if:  there is a key
        } // if:  document object

        // Allocate lists.
        m_plpciresDependencies = new CResourceList;
        if ( m_plpciresDependencies == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the dependency list

        m_plpcinodePossibleOwners = new CNodeList;
        if ( m_plpcinodePossibleOwners == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the possible owners list

        // Read the initial state.
        UpdateState();
    } // try
    catch (CException *)
    {
        if (Hkey() != NULL)
        {
            ClusterRegCloseKey(Hkey());
            m_hkey = NULL;
        } // if:  registry key opened
        if (Hresource() != NULL)
        {
            CloseClusterResource(Hresource());
            m_hresource = NULL;
        } // if:  resource opened
        m_bReadOnly = TRUE;
        throw;
    } // catch:  CException

} //*** CResource::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::ReadItem
//
//  Routine Description:
//      Read the item parameters from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::ReadItem(void)
{
    DWORD       dwStatus;
    DWORD       dwRetStatus = ERROR_SUCCESS;
    CWaitCursor wc;

    ASSERT_VALID(this);

    m_bInitializing = FALSE;

    if (Hresource() != NULL)
    {
        m_rgProps[epropDescription].m_value.pstr = &m_strDescription;
        m_rgProps[epropSeparateMonitor].m_value.pb = &m_bSeparateMonitor;
        m_rgProps[epropLooksAlive].m_value.pdw = &m_nLooksAlive;
        m_rgProps[epropIsAlive].m_value.pdw = &m_nIsAlive;
        m_rgProps[epropRestartAction].m_value.pdw = (DWORD *) &m_crraRestartAction;
        m_rgProps[epropRestartThreshold].m_value.pdw = &m_nRestartThreshold;
        m_rgProps[epropRestartPeriod].m_value.pdw = &m_nRestartPeriod;
        m_rgProps[epropPendingTimeout].m_value.pdw = &m_nPendingTimeout;

        // Call the base class method.
        Trace( g_tagResource, _T("(%s) (%s (%x)) - CResource::ReadItem() - Calling CClusterItem::ReadItem()"), Pdoc()->StrNode(), StrName(), this );
        CClusterItem::ReadItem();

        // Read and parse the common properties.
        {
            CClusPropList   cpl;

            Trace( g_tagResource, _T("(%s) (%s (%x)) - CResource::ReadItem() - Getting common properties"), Pdoc()->StrNode(), StrName(), this );
            dwStatus = cpl.ScGetResourceProperties(
                                Hresource(),
                                CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES
                                );
            if (dwStatus == ERROR_SUCCESS)
            {
                Trace( g_tagResource, _T("(%s) (%s (%x)) - CResource::ReadItem() - Parsing common properties"), Pdoc()->StrNode(), StrName(), this );
                dwStatus = DwParseProperties(cpl);
            } // if: properties read successfully
            if (dwStatus != ERROR_SUCCESS)
            {
                Trace( g_tagError, _T("(%s) (%s (%x)) - CResource::ReadItem() - Error 0x%08.8x getting or parsing common properties"), Pdoc()->StrNode(), StrName(), this, dwStatus );
                dwRetStatus = dwStatus;
            } // if: error reading or parsing properties
        } // Read and parse the common properties

        // Read and parse the read-only common properties.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            CClusPropList   cpl;

            Trace( g_tagResource, _T("(%s) (%s (%x)) - CResource::ReadItem() - Getting common RO properties"), Pdoc()->StrNode(), StrName(), this );
            dwStatus = cpl.ScGetResourceProperties(
                                Hresource(),
                                CLUSCTL_RESOURCE_GET_RO_COMMON_PROPERTIES
                                );
            if (dwStatus == ERROR_SUCCESS)
            {
                Trace( g_tagResource, _T("(%s) (%s (%x)) - CResource::ReadItem() - Parsing common RO properties"), Pdoc()->StrNode(), StrName(), this );
                dwStatus = DwParseProperties(cpl);
            } // if: properties read successfully
            if (dwStatus != ERROR_SUCCESS)
            {
                Trace( g_tagError, _T("(%s) (%s (%x)) - CResource::ReadItem() - Error 0x%08.8x getting or parsing common RO properties"), Pdoc()->StrNode(), StrName(), this, dwStatus );
                dwRetStatus = dwStatus;
            } // if: error reading or parsing properties
        } // if:  no error yet

        // Find the resource type object.
        {
            CResourceType * pciResType;

            pciResType = Pdoc()->LpciResourceTypes().PciResTypeFromName(StrResourceType());
            if (m_pciResourceType != NULL)
                m_pciResourceType->Release();
            m_pciResourceType = pciResType;
            if (m_pciResourceType != NULL)
                m_pciResourceType->AddRef();
        } // Find the resource type object

        // Read the required dependencies.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            PCLUSPROP_REQUIRED_DEPENDENCY pcrd;

            Trace( g_tagResource, _T("(%s) (%s (%x)) - CResource::ReadItem() - Getting required dependencies"), Pdoc()->StrNode(), StrName(), this );
            dwStatus = DwResourceControlGet(CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES, (PBYTE *) &pcrd);
            if (dwStatus != ERROR_SUCCESS)
            {
                Trace( g_tagError, _T("(%s) (%s (%x)) - CResource::ReadItem() - Error 0x%08.8x getting required dependencies"), Pdoc()->StrNode(), StrName(), this, dwStatus );
                dwRetStatus = dwStatus;
            } // if: error getting required dependencies
            delete [] (PBYTE) m_pcrd;
            m_pcrd = pcrd;
        } // if:  no error yet

        // Read the resource class.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            DWORD   cbReturned;

            dwStatus = ClusterResourceControl(
                            Hresource(),
                            NULL,
                            CLUSCTL_RESOURCE_GET_CLASS_INFO,
                            NULL,
                            NULL,
                            &m_rciResClassInfo,
                            sizeof(m_rciResClassInfo),
                            &cbReturned
                            );
            if (dwStatus != ERROR_SUCCESS)
                dwRetStatus = dwStatus;
            else
            {
                ASSERT(cbReturned == sizeof(m_rciResClassInfo));
            } // else:  data retrieved successfully
        } // if:  no error yet

        // Read the characteristics.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            DWORD   cbReturned;

            dwStatus = ClusterResourceControl(
                            Hresource(),
                            NULL,
                            CLUSCTL_RESOURCE_GET_CHARACTERISTICS,
                            NULL,
                            NULL,
                            &m_dwCharacteristics,
                            sizeof(m_dwCharacteristics),
                            &cbReturned
                            );
            if (dwStatus != ERROR_SUCCESS)
                dwRetStatus = dwStatus;
            else
            {
                ASSERT(cbReturned == sizeof(m_dwCharacteristics));
            } // else:  data retrieved successfully
        } // if:  no error yet

        // Read the flags.
        if (dwRetStatus == ERROR_SUCCESS)
        {
            DWORD   cbReturned;

            dwStatus = ClusterResourceControl(
                            Hresource(),
                            NULL,
                            CLUSCTL_RESOURCE_GET_FLAGS,
                            NULL,
                            NULL,
                            &m_dwFlags,
                            sizeof(m_dwFlags),
                            &cbReturned
                            );
            if (dwStatus != ERROR_SUCCESS)
                dwRetStatus = dwStatus;
            else
            {
                ASSERT(cbReturned == sizeof(m_dwFlags));
            } // else:  data retrieved successfully
        } // if:  no error yet

        // Construct the list of extensions.
        ReadExtensions();

        if (dwRetStatus == ERROR_SUCCESS)
        {
            // Construct the lists.
            CollectPossibleOwners(NULL);
            CollectDependencies(NULL);
        } // if:  no error reading properties
    } // if:  resource is available

    // Read the initial state.
    UpdateState();

    // If any errors occurred, throw an exception.
    if (dwRetStatus != ERROR_SUCCESS)
    {
        m_bReadOnly = TRUE;
        if (   (dwRetStatus != ERROR_RESOURCE_NOT_AVAILABLE)
            && (dwRetStatus != ERROR_KEY_DELETED))
            ThrowStaticException(dwRetStatus, IDS_READ_RESOURCE_PROPS_ERROR, StrName());
    } // if:  error reading properties

    MarkAsChanged(FALSE);

} //*** CResource::ReadItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::DwResourceControlGet
//
//  Routine Description:
//      Send a control function to the resource to get information from it.
//
//  Arguments:
//      dwFunctionCode  [IN] Control function code.
//      pbInBuf         [IN] Input buffer to pass to the resource.
//      cbInBuf         [IN] Size of data in input buffer.
//      ppbOutBuf       [OUT] Output buffer.
//
//  Return Value:
//      Any status returned from ClusterResourceControl().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResource::DwResourceControlGet(
    IN DWORD        dwFunctionCode,
    IN PBYTE        pbInBuf,
    IN DWORD        cbInBuf,
    OUT PBYTE *     ppbOutBuf
    )
{
    DWORD       dwStatus    = ERROR_SUCCESS;
    DWORD       cbOutBuf    = 512;
    CWaitCursor wc;

    ASSERT(ppbOutBuf != NULL);
    *ppbOutBuf = NULL;

    // Allocate memory for the buffer.
    try
    {
        *ppbOutBuf = new BYTE[cbOutBuf];
        if ( *ppbOutBuf == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the output buffer
    } // try
    catch (CMemoryException * pme)
    {
        *ppbOutBuf = NULL;
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        pme->Delete();
    } // catch:  CMemoryException
    if (dwStatus != ERROR_SUCCESS)
        return dwStatus;

    // Call the control function to get the data.
    dwStatus = ClusterResourceControl(
                    Hresource(),
                    NULL,
                    dwFunctionCode,
                    pbInBuf,
                    cbInBuf,
                    *ppbOutBuf,
                    cbOutBuf,
                    &cbOutBuf
                    );
    if (dwStatus == ERROR_MORE_DATA)
    {
        // Allocate more memory for the buffer.
        try
        {
            dwStatus = ERROR_SUCCESS;
            delete [] *ppbOutBuf;
            *ppbOutBuf = new BYTE[cbOutBuf];
            if ( *ppbOutBuf == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the output buffer
        } // try
        catch (CMemoryException * pme)
        {
            *ppbOutBuf = NULL;
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
            pme->Delete();
        } // catch:  CMemoryException
        if (dwStatus != ERROR_SUCCESS)
            return dwStatus;

        // Call the control function again to get the data.
        dwStatus = ClusterResourceControl(
                        Hresource(),
                        NULL,
                        dwFunctionCode,
                        pbInBuf,
                        cbInBuf,
                        *ppbOutBuf,
                        cbOutBuf,
                        &cbOutBuf
                        );
    } // if:  our buffer is too small
    if ((dwStatus != ERROR_SUCCESS) || (cbOutBuf == 0))
    {
        delete [] *ppbOutBuf;
        *ppbOutBuf = NULL;
    } // if:  error getting data or no data returned

    return dwStatus;

} //*** CResource::DwResourceControlGet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::PlstrExtension
//
//  Routine Description:
//      Return the list of admin extensions.
//
//  Arguments:
//      None.
//
//  Return Value:
//      plstr       List of extensions.
//      NULL        No extension associated with this object.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CStringList * CResource::PlstrExtensions(void) const
{
    return &LstrCombinedExtensions();

} //*** CResource::PlstrExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::ReadExtensions
//
//  Routine Description:
//      Read extension lists.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::ReadExtensions(void)
{
    CWaitCursor wc;

    // Construct the list of extensions.
    {
        POSITION            posStr;
        const CStringList * plstr;

        ASSERT_VALID(Pdoc());

        m_lstrCombinedExtensions.RemoveAll();

        // Add resource-specific extensions first.
        if (PciResourceType() != NULL)
        {
            ASSERT_VALID(PciResourceType());
            plstr = &PciResourceType()->LstrAdminExtensions();
            posStr = plstr->GetHeadPosition();
            while (posStr != NULL)
            {
                m_lstrCombinedExtensions.AddTail(plstr->GetNext(posStr));
            } // while:  more extensions available
        } // if:  valid resource type found

        // Add extensions for all resources next.
        plstr = &Pdoc()->PciCluster()->LstrResourceExtensions();
        posStr = plstr->GetHeadPosition();
        while (posStr != NULL)
        {
            m_lstrCombinedExtensions.AddTail(plstr->GetNext(posStr));
        } // while:  more extensions available
    } // Construct the list of extensions

} //*** CResource::ReadExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::CollecPossibleOwners
//
//  Routine Description:
//      Construct a list of node items which are enumerable on the
//      resource.
//
//  Arguments:
//      plpci           [IN OUT] List to fill.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from ClusterResourceOpenEnum() or
//                        ClusterResourceEnum().
//      Any exceptions thrown by new or CList::AddTail().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::CollectPossibleOwners(IN OUT CNodeList * plpci) const
{
    DWORD           dwStatus;
    HRESENUM        hresenum;
    int             ienum;
    LPWSTR          pwszName = NULL;
    DWORD           cchName;
    DWORD           cchmacName;
    DWORD           dwRetType;
    CClusterNode *  pciNode;
    CWaitCursor     wc;

    ASSERT_VALID(Pdoc());
    ASSERT(Hresource() != NULL);

    if (plpci == NULL)
        plpci = m_plpcinodePossibleOwners;

    ASSERT(plpci != NULL);

    // Remove the previous contents of the list.
    plpci->RemoveAll();

    if (Hresource() != NULL)
    {
        // Open the enumeration.
        hresenum = ClusterResourceOpenEnum(Hresource(), CLUSTER_RESOURCE_ENUM_NODES);
        if (hresenum == NULL)
            ThrowStaticException(GetLastError(), IDS_ENUM_POSSIBLE_OWNERS_ERROR, StrName());

        try
        {
            // Allocate a name buffer.
            cchmacName = 128;
            pwszName = new WCHAR[cchmacName];
            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the name buffer

            // Loop through the enumeration and add each dependent resource to the list.
            for (ienum = 0 ; ; ienum++)
            {
                // Get the next item in the enumeration.
                cchName = cchmacName;
                dwStatus = ClusterResourceEnum(hresenum, ienum, &dwRetType, pwszName, &cchName);
                if (dwStatus == ERROR_MORE_DATA)
                {
                    delete [] pwszName;
                    cchmacName = ++cchName;
                    pwszName = new WCHAR[cchmacName];
                    if ( pwszName == NULL )
                    {
                        AfxThrowMemoryException();
                    } // if: error allocating the name buffer
                    dwStatus = ClusterResourceEnum(hresenum, ienum, &dwRetType, pwszName, &cchName);
                } // if:  name buffer was too small
                if (dwStatus == ERROR_NO_MORE_ITEMS)
                    break;
                else if (dwStatus != ERROR_SUCCESS)
                    ThrowStaticException(dwStatus, IDS_ENUM_POSSIBLE_OWNERS_ERROR, StrName());

                ASSERT(dwRetType == CLUSTER_RESOURCE_ENUM_NODES);

                // Find the item in the list of resources on the document.
                pciNode = Pdoc()->LpciNodes().PciNodeFromName(pwszName);
                ASSERT_VALID(pciNode);

                // Add the resource to the list.
                if (pciNode != NULL)
                {
                    plpci->AddTail(pciNode);
                } // if:  found node in list

            } // for:  each item in the group

            delete [] pwszName;
            ClusterResourceCloseEnum(hresenum);

        } // try
        catch (CException *)
        {
            delete [] pwszName;
            ClusterResourceCloseEnum(hresenum);
            throw;
        } // catch:  any exception
    } // if:  resource is available

} //*** CResource::CollecPossibleOwners()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::RemoveNodeFromPossibleOwners
//
//  Routine Description:
//      Remove the passed in node from the possible owners list.
//
//  Arguments:
//      plpci       [IN OUT] List to fill.
//      pNode       [IN] The node to remove from the list
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CList.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::RemoveNodeFromPossibleOwners(
    IN OUT      CNodeList *     plpci,
    IN const    CClusterNode *  pNode
    )
{
    if (plpci == NULL)
    {
        plpci = m_plpcinodePossibleOwners;
    } // if: plpci is NULL

    ASSERT(plpci != NULL);

    POSITION        _pos;
    CClusterNode *  _pnode = plpci->PciNodeFromName(pNode->StrName(), &_pos);

    if ((_pnode != NULL) && (_pos != NULL))
    {
        plpci->RemoveAt(_pos);
    } // if: node was found in the list

} //*** CResource::RemoveNodeFromPossibleOwners()
*/
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::CollectDependencies
//
//  Routine Description:
//      Collect the resources on which this resource is dependent.
//
//  Arguments:
//      plpci           [IN OUT] List to fill.
//      bFullTree       [IN] TRUE = collect dependencies of dependencies.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from ClusterResourceOpenEnum() or
//                        ClusterResourceEnum().
//      Any exceptions thrown by new or CList::AddTail().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::CollectDependencies(
    IN OUT CResourceList *  plpci,
    IN BOOL                 bFullTree
    ) const
{
    DWORD           dwStatus;
    HRESENUM        hresenum;
    int             ienum;
    LPWSTR          pwszName = NULL;
    DWORD           cchName;
    DWORD           cchmacName;
    DWORD           dwRetType;
    CResource *     pciRes;
    CWaitCursor     wc;

    ASSERT_VALID(Pdoc());
    ASSERT(Hresource() != NULL);

    if (plpci == NULL)
        plpci = m_plpciresDependencies;

    ASSERT(plpci != NULL);

    // Remove the previous contents of the list.
    if (!bFullTree)
        plpci->RemoveAll();

    if (Hresource() != NULL)
    {
        // Open the enumeration.
        hresenum = ClusterResourceOpenEnum(Hresource(), CLUSTER_RESOURCE_ENUM_DEPENDS);
        if (hresenum == NULL)
            ThrowStaticException(GetLastError(), IDS_ENUM_DEPENDENCIES_ERROR, StrName());

        try
        {
            // Allocate a name buffer.
            cchmacName = 128;
            pwszName = new WCHAR[cchmacName];
            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the name buffer

            // Loop through the enumeration and add each dependent resource to the list.
            for (ienum = 0 ; ; ienum++)
            {
                // Get the next item in the enumeration.
                cchName = cchmacName;
                dwStatus = ClusterResourceEnum(hresenum, ienum, &dwRetType, pwszName, &cchName);
                if (dwStatus == ERROR_MORE_DATA)
                {
                    delete [] pwszName;
                    cchmacName = ++cchName;
                    pwszName = new WCHAR[cchmacName];
                    if ( pwszName == NULL )
                    {
                        AfxThrowMemoryException();
                    } // if: error allocating the name buffer
                    dwStatus = ClusterResourceEnum(hresenum, ienum, &dwRetType, pwszName, &cchName);
                } // if:  name buffer was too small
                if (dwStatus == ERROR_NO_MORE_ITEMS)
                    break;
                else if (dwStatus != ERROR_SUCCESS)
                    ThrowStaticException(dwStatus, IDS_ENUM_DEPENDENCIES_ERROR, StrName());

                ASSERT(dwRetType == CLUSTER_RESOURCE_ENUM_DEPENDS);

                // Find the item in the list of resources on the document and
                // add its dependencies to the list.
                pciRes = Pdoc()->LpciResources().PciResFromName(pwszName);
                if (pciRes != NULL)
                {
                    // Add this resource to the list.
                    if (plpci->Find(pciRes) == NULL)
                    {
                        plpci->AddTail(pciRes);
                    } // if:  resource not in the list yet

                    // Add the resources on which this resource is dependent to the list.
                    if (bFullTree)
                        pciRes->CollectDependencies(plpci, bFullTree);
                } // if:  resource found in the list
            } // for:  each item in the group

            delete [] pwszName;
            ClusterResourceCloseEnum(hresenum);

        } // try
        catch (CException *)
        {
            delete [] pwszName;
            if (hresenum != NULL)
                ClusterResourceCloseEnum(hresenum);
            throw;
        } // catch:  any exception
    } // if:  resource is available

} //*** CResource::CollectDependencies()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::CollectProvidesFor
//
//  Routine Description:
//      Collect the list of resources which are dependent on this resource.
//
//  Arguments:
//      plpci       [IN OUT] List of resources.
//      bFullTree   [IN] TRUE = collect dependencies of dependencies.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from ClusterResourceOpenEnum() or
//                            ClusterResourceEnum().
//      Any exceptions thrown by CList::AddHead().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::CollectProvidesFor(
    IN OUT CResourceList *  plpci,
    IN BOOL                 bFullTree
    ) const
{
    DWORD           dwStatus;
    HRESENUM        hresenum    = NULL;
    WCHAR *         pwszName    = NULL;
    int             ienum;
    DWORD           cchName;
    DWORD           cchmacName;
    DWORD           dwType;
    CResource *     pciRes;
    CWaitCursor     wc;

    ASSERT_VALID(this);
    ASSERT(Hresource != NULL);

    ASSERT(plpci != NULL);

    // Remove the previous contents of the list.
    if (!bFullTree)
        plpci->RemoveAll();

    if (Hresource() != NULL)
    {
        try
        {
            // Allocate a name buffer.
            cchmacName = 128;
            pwszName = new WCHAR[cchmacName];
            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the name buffer

            // Open the enumeration.
            hresenum = ClusterResourceOpenEnum(Hresource(), CLUSTER_RESOURCE_ENUM_PROVIDES);
            if (hresenum == NULL)
                ThrowStaticException(GetLastError(), IDS_ENUM_PROVIDES_FOR_ERROR, StrName());

            // Loop through the enumeration and add each one's providers to the list.
            for (ienum = 0 ; ; ienum++)
            {
                // Get the next item in the enumeration.
                cchName = cchmacName;
                dwStatus = ClusterResourceEnum(hresenum, ienum, &dwType, pwszName, &cchName);
                if (dwStatus == ERROR_MORE_DATA)
                {
                    delete [] pwszName;
                    cchmacName = ++cchName;
                    pwszName = new WCHAR[cchmacName];
                    if ( pwszName == NULL )
                    {
                        AfxThrowMemoryException();
                    } // if: error allocating the name buffer
                    dwStatus = ClusterResourceEnum(hresenum, ienum, &dwType, pwszName, &cchName);
                } // if:  name buffer was too small
                if (dwStatus == ERROR_NO_MORE_ITEMS)
                    break;
                else if (dwStatus != ERROR_SUCCESS)
                    ThrowStaticException(dwStatus, IDS_ENUM_PROVIDES_FOR_ERROR, StrName());

                ASSERT(dwType == CLUSTER_RESOURCE_ENUM_PROVIDES);

                // Find the item in the list of resources on the document and
                // add its providers to the list.
                pciRes = Pdoc()->LpciResources().PciResFromName(pwszName);
                if (pciRes != NULL)
                {
                    // Add this resource to the list.
                    if (plpci->Find(pciRes) == NULL)
                    {
                        plpci->AddHead(pciRes);
                    } // if:  resource not in the list yet

                    // Add the resources this resource provides for to the list.
                    if (bFullTree)
                        pciRes->CollectProvidesFor(plpci, bFullTree);
                } // if:  resource found in the list
            } // for:  each dependent resource

            // Close the enumeration.
            delete [] pwszName;
            pwszName = NULL;
            ClusterResourceCloseEnum(hresenum);
            hresenum = NULL;

        } // try
        catch (CException *)
        {
            delete [] pwszName;
            if (hresenum != NULL)
                ClusterResourceCloseEnum(hresenum);
            throw;
        } // catch:  CException
    } // if:  resource is available

} //*** CResource::CollectProvidesFor()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::CollectDependencyTree
//
//  Routine Description:
//      Collect the resources on which this resource is dependent and which
//      are dependent on it.
//
//  Arguments:
//      plpci           [IN OUT] List to fill.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from ClusterResourceOpenEnum() or
//                        ClusterResourceEnum().
//      Any exceptions thrown by new or CList::AddTail().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::CollectDependencyTree(
    IN OUT CResourceList *  plpci
    ) const
{
    DWORD           dwStatus;
    HRESENUM        hresenum = NULL;
    int             ienum;
    LPWSTR          pwszName = NULL;
    DWORD           cchName;
    DWORD           cchmacName;
    DWORD           dwRetType;
    CResource *     pciRes;
    CWaitCursor     wc;
    int             iType;
    static DWORD    rgdwType[]  = { CLUSTER_RESOURCE_ENUM_DEPENDS, CLUSTER_RESOURCE_ENUM_PROVIDES };
    static IDS      rgidsTypeError[] = { IDS_ENUM_DEPENDENCIES_ERROR, IDS_ENUM_PROVIDES_FOR_ERROR };

    ASSERT_VALID(Pdoc());
    ASSERT(Hresource() != NULL);

    ASSERT(plpci != NULL);

    if (Hresource() != NULL)
    {
        try
        {
            // Allocate a name buffer.
            cchmacName = 128;
            pwszName = new WCHAR[cchmacName];
            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the name buffer

            for (iType = 0 ; iType < sizeof(rgdwType) / sizeof(DWORD) ; iType++)
            {
                // Open the enumeration.
                hresenum = ClusterResourceOpenEnum(Hresource(), rgdwType[iType]);
                if (hresenum == NULL)
                    ThrowStaticException(GetLastError(), rgidsTypeError[iType], StrName());

                // Loop through the enumeration and add each dependent or
                // provider resource to the list.
                for (ienum = 0 ; ; ienum++)
                {
                    // Get the next item in the enumeration.
                    cchName = cchmacName;
                    dwStatus = ClusterResourceEnum(hresenum, ienum, &dwRetType, pwszName, &cchName);
                    if (dwStatus == ERROR_MORE_DATA)
                    {
                        delete [] pwszName;
                        cchmacName = ++cchName;
                        pwszName = new WCHAR[cchmacName];
                        if ( pwszName == NULL )
                        {
                            AfxThrowMemoryException();
                        } // if: error allocating the name buffer
                        dwStatus = ClusterResourceEnum(hresenum, ienum, &dwRetType, pwszName, &cchName);
                    } // if:  name buffer was too small
                    if (dwStatus == ERROR_NO_MORE_ITEMS)
                        break;
                    else if (dwStatus != ERROR_SUCCESS)
                        ThrowStaticException(dwStatus, rgidsTypeError[iType], StrName());

                    ASSERT(dwRetType == rgdwType[iType]);

                    // Find the item in the list of resources on the document and
                    // add its dependencies and providers to the list.
                    pciRes = Pdoc()->LpciResources().PciResFromName(pwszName);
                    if (pciRes != NULL)
                    {
                        // Add this resource to the list.
                        if (plpci->Find(pciRes) == NULL)
                        {
                            plpci->AddTail(pciRes);
                            pciRes->CollectDependencyTree(plpci);
                        } // if:  resource not in the list yet
                    } // if:  resource found in the list
                } // for:  each item in the group

                ClusterResourceCloseEnum(hresenum);
                hresenum = NULL;

            } // for:  each type of enumeration

            delete [] pwszName;

        } // try
        catch (CException *)
        {
            delete [] pwszName;
            if (hresenum != NULL)
                ClusterResourceCloseEnum(hresenum);
            throw;
        } // catch:  any exception
    } // if:  resource is available

} //*** CResource::CollectDependencyTree()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::SetName
//
//  Routine Description:
//      Set the name of this resource.
//
//  Arguments:
//      pszName         [IN] New name of the resource.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by Rename.
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::SetName(IN LPCTSTR pszName)
{
    Rename(pszName);

} //*** CResource::SetName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::SetGroup
//
//  Routine Description:
//      Set the group to which this resource belongs.
//
//  Arguments:
//      pszGroup        [IN] New group for the resource.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    IDS_MOVE_RESOURCE_ERROR - errors from
//                          ChangeClusterResourceGroup().
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::SetGroup(IN LPCTSTR pszGroup)
{
    DWORD       dwStatus;
    CGroup *    pciGroup;
    CString     strGroup(pszGroup); // Required if built non-Unicode
    CWaitCursor wc;

    ASSERT(pszGroup != NULL);
    ASSERT(Hresource() != NULL);

    if ((Hresource() != NULL) && (StrGroup() != pszGroup))
    {
        // Find the group.
        pciGroup = Pdoc()->LpciGroups().PciGroupFromName(pszGroup);
        ASSERT_VALID(pciGroup);

        // Change the group.
        dwStatus = ChangeClusterResourceGroup(Hresource(), pciGroup->Hgroup());
        if (dwStatus != ERROR_SUCCESS)
            ThrowStaticException(dwStatus, IDS_MOVE_RESOURCE_ERROR, StrName(), pszGroup);

        SetGroupState(pciGroup->StrName());
    } // if:  the name changed

} //*** CResource::SetGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::SetDependencies
//
//  Routine Description:
//      Set the list of resources on which this resource depends on
//      in the cluster database.
//
//  Arguments:
//      rlpci       [IN] List of resources on which this resource depends on.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException(dwStatus)  Errors from AddClusterResourceDependency()
//                                and RemoveClusterResourceDependency().
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::SetDependencies(IN const CResourceList & rlpci)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hresource() != NULL);

    if (Hresource() != NULL)
    {
        // Add any entries that are in the new last but not in the old list as
        // new dependencies.
        {
            POSITION    posPci;
            CResource * pciRes;

            posPci = rlpci.GetHeadPosition();
            while (posPci != NULL)
            {
                pciRes = (CResource *) rlpci.GetNext(posPci);
                ASSERT_VALID(pciRes);

                if (LpciresDependencies().Find(pciRes) == NULL)
                {
                    // Add the resource as a dependency of this one.
                    dwStatus = AddClusterResourceDependency(Hresource(), pciRes->Hresource());
                    if (dwStatus != ERROR_SUCCESS)
                        ThrowStaticException(dwStatus, IDS_ADD_DEPENDENCY_ERROR, pciRes->StrName(), StrName());

                    // Add the resource into our list.
                    m_plpciresDependencies->AddTail(pciRes);
                } // if:  item not found in existing list
            } // while:  more items in the list
        } // Add new dependencies

        // Delete any entries that are in the new old but not in the new list.
        {
            POSITION    posPci;
            POSITION    posPrev;
            CResource * pciRes;

            posPci = LpciresDependencies().GetHeadPosition();
            while (posPci != NULL)
            {
                posPrev = posPci;
                pciRes = (CResource *) LpciresDependencies().GetNext(posPci);
                if (rlpci.Find(pciRes) == NULL)
                {
                    // Remove the resource as a dependency of this one.
                    dwStatus = RemoveClusterResourceDependency(Hresource(), pciRes->Hresource());
                    if (dwStatus != ERROR_SUCCESS)
                        ThrowStaticException(dwStatus, IDS_REMOVE_DEPENDENCY_ERROR, pciRes->StrName(), StrName());

                    // Remove the resource from our list.
                    m_plpciresDependencies->RemoveAt(posPrev);
                } // if:  item not found in new list
            } // while:  more items in the list
        } // Remove old dependencies
    } // if:  resource is available

} //*** CResource::SetDependencies()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::SetPossibleOwners
//
//  Routine Description:
//      Set the list of possible owners of this resource in the cluster
//      database.
//
//  Arguments:
//      rlpci       [IN] List of possible owners (nodes).
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException            IDS_TAKE_RESOURCE_OFFLINE_ERROR.
//      CNTException(dwStatus)  Errors from AddClusterResourceNode()
//                                and RemoveClusterResourceNode().
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::SetPossibleOwners(IN const CNodeList & rlpci)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hresource() != NULL);

    if (Hresource() != NULL)
    {
        // If the list of possible owners is empty, make sure this resource
        // is offline.
        if ((rlpci.GetCount() == 0) && (Crs() == ClusterResourceOnline))
        {
            dwStatus = OfflineClusterResource(Hresource());
            if ((dwStatus != ERROR_SUCCESS)
                    && (dwStatus != ERROR_IO_PENDING))
                ThrowStaticException(dwStatus, IDS_TAKE_RESOURCE_OFFLINE_ERROR, StrName());
        } // if:  no possible owners

        // Add any entries that are in the new list but not in the old list as
        // new owners.
        {
            POSITION        posPci;
            CClusterNode *  pciNode;

            posPci = rlpci.GetHeadPosition();
            while (posPci != NULL)
            {
                pciNode = (CClusterNode *) rlpci.GetNext(posPci);
                ASSERT_VALID(pciNode);

                if (LpcinodePossibleOwners().Find(pciNode) == NULL)
                {
                    // Add the node as an owner of this resource.
                    dwStatus = AddClusterResourceNode(Hresource(), pciNode->Hnode());
                    if (dwStatus != ERROR_SUCCESS)
                        ThrowStaticException(dwStatus, IDS_ADD_RES_OWNER_ERROR, pciNode->StrName(), StrName());

                    // Add the node into our list.
                    m_plpcinodePossibleOwners->AddTail(pciNode);
                } // if:  item not found in existing list
            } // while:  more items in the list
        } // Add new owner

        // Delete any entries that are in the old but not in the new list.
        {
            POSITION        posPci;
            POSITION        posPrev;
            CClusterNode *  pciNode;

            posPci = LpcinodePossibleOwners().GetHeadPosition();
            while (posPci != NULL)
            {
                posPrev = posPci;
                pciNode = (CClusterNode *) LpcinodePossibleOwners().GetNext(posPci);
                if (rlpci.Find(pciNode) == NULL)
                {
                    // Remove the node as an owner of this resource.
                    dwStatus = RemoveClusterResourceNode(Hresource(), pciNode->Hnode());
                    if (dwStatus != ERROR_SUCCESS)
                        ThrowStaticException(dwStatus, IDS_REMOVE_RES_OWNER_ERROR, pciNode->StrName(), StrName());

                    // Remove the node from our list.
                    m_plpcinodePossibleOwners->RemoveAt(posPrev);
                } // if:  item not found in new list
            } // while:  more items in the list
        } // Remove old owners
    } // if:  resource is available

} //*** CResource::SetPossibleOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::SetCommonProperties
//
//  Routine Description:
//      Set the common properties for this resource in the cluster database.
//
//  Arguments:
//      rstrDesc        [IN] Description string.
//      bSeparate       [IN] TRUE = run resource in separate monitor, FALSE = run with other resources.
//      nLooksAlive     [IN] Looks Alive poll interval.
//      nIsAlive        [IN] Is Alive poll interval.
//      crra            [IN] Restart action.
//      nThreshold      [IN] Restart threshold.
//      nPeriod         [IN] Restart period.
//      nTimeout        [IN] Pending timeout in minutes.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusterItem::SetCommonProperties().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::SetCommonProperties(
    IN const CString &  rstrDesc,
    IN BOOL             bSeparate,
    IN DWORD            nLooksAlive,
    IN DWORD            nIsAlive,
    IN CRRA             crra,
    IN DWORD            nThreshold,
    IN DWORD            nPeriod,
    IN DWORD            nTimeout,
    IN BOOL             bValidateOnly
    )
{
    CNTException    nte(ERROR_SUCCESS, 0, NULL, NULL, FALSE /*bAutoDelete*/);

    m_rgProps[epropDescription].m_value.pstr = (CString *) &rstrDesc;
    m_rgProps[epropSeparateMonitor].m_value.pb = &bSeparate;
    m_rgProps[epropLooksAlive].m_value.pdw = &nLooksAlive;
    m_rgProps[epropIsAlive].m_value.pdw = &nIsAlive;
    m_rgProps[epropRestartAction].m_value.pdw = (DWORD *) &crra;
    m_rgProps[epropRestartThreshold].m_value.pdw = &nThreshold;
    m_rgProps[epropRestartPeriod].m_value.pdw = &nPeriod;
    m_rgProps[epropPendingTimeout].m_value.pdw = &nTimeout;

    try
    {
        CClusterItem::SetCommonProperties(bValidateOnly);
    } // try
    catch (CNTException * pnte)
    {
        nte.SetOperation(
                    pnte->Sc(),
                    pnte->IdsOperation(),
                    pnte->PszOperArg1(),
                    pnte->PszOperArg2()
                    );
    } // catch:  CNTException

    m_rgProps[epropDescription].m_value.pstr = &m_strDescription;
    m_rgProps[epropSeparateMonitor].m_value.pb = &m_bSeparateMonitor;
    m_rgProps[epropLooksAlive].m_value.pdw = &m_nLooksAlive;
    m_rgProps[epropIsAlive].m_value.pdw = &m_nIsAlive;
    m_rgProps[epropRestartAction].m_value.pdw = (DWORD *) &m_crraRestartAction;
    m_rgProps[epropRestartThreshold].m_value.pdw = &m_nRestartThreshold;
    m_rgProps[epropRestartPeriod].m_value.pdw = &m_nRestartPeriod;
    m_rgProps[epropPendingTimeout].m_value.pdw = &m_nPendingTimeout;

    if (nte.Sc() != ERROR_SUCCESS)
        ThrowStaticException(
                        nte.Sc(),
                        nte.IdsOperation(),
                        nte.PszOperArg1(),
                        nte.PszOperArg2()
                        );

} //*** CResource::SetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::DwSetCommonProperties
//
//  Routine Description:
//      Set the common properties for this resource in the cluster database.
//
//  Arguments:
//      rcpl            [IN] Property list to set.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Value:
//      Any status returned by ClusterResourceControl().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResource::DwSetCommonProperties(
    IN const CClusPropList &    rcpl,
    IN BOOL                     bValidateOnly
    )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hresource());

    if ((rcpl.PbPropList() != NULL) && (rcpl.CbPropList() > 0))
    {
        DWORD   cbProps;
        DWORD   dwControl;

        if (bValidateOnly)
            dwControl = CLUSCTL_RESOURCE_VALIDATE_COMMON_PROPERTIES;
        else
            dwControl = CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES;

        // Set common properties.
        dwStatus = ClusterResourceControl(
                        Hresource(),
                        NULL,   // hNode
                        dwControl,
                        rcpl.PbPropList(),
                        rcpl.CbPropList(),
                        NULL,   // lpOutBuffer
                        0,      // nOutBufferSize
                        &cbProps
                        );
    } // if:  there is data to set
    else
        dwStatus = ERROR_SUCCESS;

    return dwStatus;

} //*** CResource::DwSetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::BRequiredDependenciesPresent
//
//  Routine Description:
//      Determine if the specified list contains each required resource
//      for this type of resource.
//
//  Arguments:
//      rlpciRes        [IN] List of resources.
//      rstrMissing     [OUT] String in which to return a missing resource
//                          class name or type name.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CString::LoadString() or CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::BRequiredDependenciesPresent(
    IN const CResourceList &    rlpciRes,
    OUT CString &               rstrMissing
    )
{
    POSITION                pos;
    BOOL                    bFound = TRUE;
    const CResource *       pciRes;
    CLUSPROP_BUFFER_HELPER  props;

    if (Pcrd() == NULL)
        return TRUE;

    // Collect the list of required dependencies.
    props.pRequiredDependencyValue = Pcrd();

    // Loop through each required dependency and make sure
    // there is a dependency on a resource of that type.
    while (props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
    {
        bFound = FALSE;
        pos = rlpciRes.GetHeadPosition();
        while (pos != NULL)
        {
            // Get the next resource.
            pciRes = (CResource *) rlpciRes.GetNext(pos);
            ASSERT_VALID(pciRes);
            ASSERT_KINDOF(CResource, pciRes);

            // If this is the right type, we've satisfied the
            // requirement so exit the loop.
            if (props.pSyntax->dw == CLUSPROP_SYNTAX_RESCLASS)
            {
                if (props.pResourceClassValue->rc == pciRes->ResClass())
                {
                    bFound = TRUE;
                    props.pb += sizeof(*props.pResourceClassValue);
                } // if:  match found
            } // if:  resource class
            else if (props.pSyntax->dw == CLUSPROP_SYNTAX_NAME)
            {
                if (pciRes->StrRealResourceType().CompareNoCase(props.pStringValue->sz) == 0)
                {
                    bFound = TRUE;
                    props.pb += sizeof(*props.pStringValue) + ALIGN_CLUSPROP(props.pStringValue->cbLength);
                } // if:  match found
            } // else if:  resource name
            else
            {
                ASSERT(0);
                break;
            } // else:  unknown data type
            if (bFound)
                break;
        } // while:  more items in the list

        // If a match was not found, changes cannot be applied.
        if (!bFound)
        {
            if (props.pSyntax->dw == CLUSPROP_SYNTAX_RESCLASS)
            {
                if (!rstrMissing.LoadString(IDS_RESCLASS_UNKNOWN + props.pResourceClassValue->rc))
                    rstrMissing.LoadString(IDS_RESCLASS_UNKNOWN);
            } // if:  resource class not found
            else if (props.pSyntax->dw == CLUSPROP_SYNTAX_NAME)
            {
                CResourceType * pciResType;

                // Find the resource type in our list.
                pciResType = (CResourceType *) Pdoc()->LpciResourceTypes().PciFromName(props.pStringValue->sz);
                if (pciResType != NULL)
                    rstrMissing = pciResType->StrDisplayName();
                else
                    rstrMissing = props.pStringValue->sz;
            } // else if:  resource type name not found
            break;
        } // if:  not found

    } // while:  more dependencies required

    return bFound;

} //*** CResource::BRequiredDependenciesPresent()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::DeleteResource
//
//  Routine Description:
//      Delete this resource and all dependent resources.
//
//  Arguments:
//      rlpci       [IN] List of resources to delete in addition to this one.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CResource::DeleteResource().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::DeleteResource(IN const CResourceList & rlpci)
{
    CWaitCursor wc;

    // Delete each resource in the list.
    {
        POSITION    pos;
        CResource * pciRes;

        pos = rlpci.GetHeadPosition();
        while (pos != NULL)
        {
            pciRes = (CResource *) rlpci.GetNext(pos);
            if (pciRes != NULL)
                pciRes->DeleteResource();
        } // while:  more items in the list
    } // Delete each resource in the list

    // Delete this resource.
    DeleteResource();

} //*** CResource::DeleteResource(rlpci)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::DeleteResource
//
//  Routine Description:
//      Delete this resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from DeleteClusterResource().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::DeleteResource(void)
{
    DWORD       dwStatus;
    BOOL        bWeTookOffline = FALSE;
    CWaitCursor wc;

    ASSERT(!BDeleting());

    if (Hresource() != NULL)
    {
        // Make sure the resource is offline.
        if (    (Crs() != ClusterResourceOffline)
            &&  (Crs() != ClusterResourceFailed))
        {
            dwStatus = OfflineClusterResource(Hresource());
            if (dwStatus == ERROR_IO_PENDING)
            {
                WaitForOffline();
                if (    (Crs() != ClusterResourceOffline)
                    &&  (Crs() != ClusterResourceFailed))
                {
                    ThrowStaticException(IDS_DELETE_RESOURCE_ERROR_OFFLINE_PENDING, StrName());
                }  // if: resource still not offline
            } // if: offline pending
            else if (  (dwStatus != ERROR_SUCCESS)
                    && (dwStatus != ERROR_FILE_NOT_FOUND)
                    && (dwStatus != ERROR_RESOURCE_NOT_AVAILABLE))
            {
                ThrowStaticException(dwStatus, IDS_TAKE_RESOURCE_OFFLINE_ERROR, StrName());
            }
            bWeTookOffline = TRUE;
        } // if: resource is not offline

        // Delete the resource itself.
        Trace(g_tagResource, _T("(%s) DeleteResource() - Deleting '%s' (%x)"), Pdoc()->StrNode(), StrName(), this);
        dwStatus = DeleteClusterResource(Hresource());
        if (   (dwStatus != ERROR_SUCCESS)
            && (dwStatus != ERROR_FILE_NOT_FOUND)
            && (dwStatus != ERROR_RESOURCE_NOT_AVAILABLE))
        {
            if (bWeTookOffline)
            {
                OnlineClusterResource(Hresource());
            }
            ThrowStaticException(dwStatus, IDS_DELETE_RESOURCE_ERROR, StrName());
        } // if:  error occurred

        m_bDeleting = TRUE;

        UpdateState();
    } // if:  resource has been opened/created

} //*** CResource::DeleteResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::WaitForOffline
//
//  Routine Description:
//      Wait for the resource to go offline.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CResource::Move().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::WaitForOffline( void )
{
    CWaitForResourceOfflineDlg  dlg( this, AfxGetMainWnd() );

    dlg.DoModal();
    UpdateState();

} //*** CResource::WaitForOffline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::Move
//
//  Routine Description:
//      Move this resource and all dependent and depending resources to
//      another group.
//
//  Arguments:
//      pciGroup    [IN] Group to move resources to.
//      rlpci       [IN] List of resources to move in addition to this one.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CResource::Move().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::Move(
    IN const CGroup *           pciGroup,
    IN const CResourceList &    rlpci
    )
{
    CWaitCursor wc;

    // Move each resource in the list.
    {
        POSITION    pos;
        CResource * pciRes;

        pos = rlpci.GetHeadPosition();
        while (pos != NULL)
        {
            pciRes = (CResource *) rlpci.GetNext(pos);
            if (pciRes != NULL)
                pciRes->Move(pciGroup);
        } // while:  more items in the list
    } // Move each resource in the list

    // Move this resource.
    Move(pciGroup);

} //*** CResource::Move(rlpci)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::Move
//
//  Routine Description:
//      Move this resource.
//
//  Arguments:
//      pciGroup    [IN] Group to move resources to.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from ChangeClusterResourceGroup().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::Move(IN const CGroup * pciGroup)
{
    DWORD           dwStatus;

    ASSERT_VALID(pciGroup);

    if ((Hresource() != NULL)
            && (pciGroup != NULL)
            && (pciGroup->Hgroup() != NULL))
    {
        // Move the resource.
        Trace(g_tagResource, _T("(%s) Move() - moving '%s' (%x) from '%s' (%x) to '%s' (%x)"), Pdoc()->StrNode(), StrName(), this, StrGroup(), PciGroup(), pciGroup->StrName(), pciGroup);
        dwStatus = ChangeClusterResourceGroup(Hresource(), pciGroup->Hgroup());
        if ((dwStatus != ERROR_SUCCESS)
                && (dwStatus != ERROR_FILE_NOT_FOUND))
            ThrowStaticException(dwStatus, IDS_MOVE_RESOURCE_ERROR, StrName(), pciGroup->StrName());

        UpdateState();
    } // if:  resource has been opened/created

} //*** CResource::Move()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnFinalRelease
//
//  Routine Description:
//      Called when the last OLE reference to or from the object is released.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnFinalRelease(void)
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CClusterItem::OnFinalRelease();

} //*** CResource::OnFinalRelease()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::BCanBeDependent
//
//  Routine Description:
//      Determine whether this resource can be dependent on the specified one.
//
//  Arguments:
//      pciRes      [IN] Resource to check.
//
//  Return Value:
//      TRUE        Resource can be a dependent.
//      FALSE       Resource can NOT be a dependent.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::BCanBeDependent(IN CResource * pciRes)
{
    CWaitCursor wc;

    ASSERT_VALID(pciRes);

    if ((Hresource() != NULL)
            && (pciRes->Hresource() != NULL)
            && (pciRes != this)
            && (StrGroup() == pciRes->StrGroup())
            )
        return ::CanResourceBeDependent(Hresource(), pciRes->Hresource());
    else
        return FALSE;

} //*** CResource::BCanBeDependent()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::BIsDependent
//
//  Routine Description:
//      Determine whether this resource is dependent on the specified one.
//
//  Arguments:
//      pciRes      [IN] Resource to check.
//
//  Return Value:
//      TRUE        Resource is a dependent.
//      FALSE       Resource is NOT a dependent.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::BIsDependent(IN CResource * pciRes)
{
    ASSERT_VALID(pciRes);

    if ((m_plpciresDependencies != NULL)
            && (LpciresDependencies().Find(pciRes) != NULL))
        return TRUE;
    else
        return FALSE;

} //*** CResource::BIsDependent()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::BGetNetworkName
//
//  Routine Description:
//      Returns the name of the network name of the first Network Name
//      resource on which the specified resource depends.
//
//  Arguments:
//      lpszNetName     [OUT] String in which to return the network name.
//      pcchNetName     [IN OUT] Points to a variable that specifies the
//                          maximum size, in characters, of the buffer.  This
//                          value should be large enough to contain
//                          MAX_COMPUTERNAME_LENGTH + 1 characters.  Upon
//                          return it contains the actual number of characters
//                          copied.
//
//  Return Value:
//      TRUE        Resource is dependent on a network name resource.
//      FALSE       Resource is NOT dependent on a network name resource.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::BGetNetworkName(
    OUT WCHAR *     lpszNetName,
    IN OUT DWORD *  pcchNetName
    )
{
    CWaitCursor wc;

    ASSERT_VALID(this);
    ASSERT(m_hresource != NULL);

    ASSERT(lpszNetName != NULL);
    ASSERT(pcchNetName != NULL);

    return GetClusterResourceNetworkName(m_hresource, lpszNetName, pcchNetName);

} //*** CResource::BGetNetworkName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::BGetNetworkName
//
//  Routine Description:
//      Returns the name of the network name of the first Network Name
//      resource on which the specified resource depends.
//
//  Arguments:
//      rstrNetName     [OUT] String in which to return the network name.
//
//  Return Value:
//      TRUE        Resource is dependent on a network name resource.
//      FALSE       Resource is NOT dependent on a network name resource.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::BGetNetworkName(OUT CString & rstrNetName)
{
    BOOL    bSuccess;
    WCHAR   szNetName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD   nSize = sizeof(szNetName) / sizeof(WCHAR);

    bSuccess = BGetNetworkName(szNetName, &nSize);
    if (bSuccess)
        rstrNetName = szNetName;
    else
        rstrNetName = _T("");

    return bSuccess;

} //*** CResource::BGetNetworkName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::UpdateState
//
//  Routine Description:
//      Update the current state of the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::UpdateState(void)
{
    CClusterAdminApp *      papp        = GetClusterAdminApp();
    WCHAR *                 pwszOwner   = NULL;
    WCHAR *                 pwszGroup   = NULL;
    WCHAR *                 prgwszOwner = NULL;
    WCHAR *                 prgwszGroup = NULL;
    DWORD                   cchOwner;
    DWORD                   cchGroup;
    DWORD                   sc;
    DWORD                   oldcchOwner;
    DWORD                   oldcchGroup;

    Trace(g_tagResource, _T("(%s) (%s (%x)) - Updating state"), Pdoc()->StrNode(), StrName(), this);

    // Get the current state of the resource.
    if (Hresource() == NULL)
        m_crs = ClusterResourceStateUnknown;
    else
    {
        CWaitCursor wc;

        cchOwner = 100;
        oldcchOwner = cchOwner;
        prgwszOwner = new WCHAR[cchOwner];

        if( prgwszOwner == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the buffer

        cchGroup = 100;
        oldcchGroup = cchGroup;
        prgwszGroup = new WCHAR[cchGroup];

        if( prgwszGroup == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the buffer

        m_crs = GetClusterResourceState(Hresource(), prgwszOwner, &cchOwner, prgwszGroup, &cchGroup);
        sc = GetLastError();
        
        if( sc == ERROR_MORE_DATA )
        {
            //
            // Increment before the check.  This way we'll know whether we'll need to resize the buffer,
            // and if not then we report it as being just big enough.
            //
            cchOwner++;
            if( cchOwner > oldcchOwner )
            {
                delete [] prgwszOwner;
                oldcchOwner = cchOwner;
                prgwszOwner = new WCHAR[cchOwner];

                if( prgwszOwner == NULL )
                {
                    AfxThrowMemoryException();
                } // if: error allocating the buffer
            }

            cchGroup++;
            if( cchGroup > oldcchGroup )
            {
                delete [] prgwszGroup;
                oldcchGroup = cchGroup;
                prgwszGroup = new WCHAR[cchGroup];

                if( prgwszGroup == NULL )
                {
                    AfxThrowMemoryException();
                } // if: error allocating the buffer
            }

            //
            // Note that it's possible that the owning group or node changed since the last call to 
            // GetClusterResourceState.  In that case our buffers may still be too small.  Hit F5 to refresh.
            //
            m_crs = GetClusterResourceState(Hresource(), prgwszOwner, &cchOwner, prgwszGroup, &cchGroup);
        }
        pwszOwner = prgwszOwner;
        pwszGroup = prgwszGroup;
    } // else:  resource is available

    // Save the current state image index.
    switch (Crs())
    {
        case ClusterResourceStateUnknown:
            m_iimgState = papp->Iimg(IMGLI_RES_UNKNOWN);
            pwszOwner = NULL;
            pwszGroup = NULL;
            break;
        case ClusterResourceOnline:
            m_iimgState = papp->Iimg(IMGLI_RES);
            break;
        case ClusterResourceOnlinePending:
            m_iimgState = papp->Iimg(IMGLI_RES_PENDING);
            break;
        case ClusterResourceOffline:
            m_iimgState = papp->Iimg(IMGLI_RES_OFFLINE);
            break;
        case ClusterResourceOfflinePending:
            m_iimgState = papp->Iimg(IMGLI_RES_PENDING);
            break;
        case ClusterResourceFailed:
            m_iimgState = papp->Iimg(IMGLI_RES_FAILED);
            break;
        default:
            Trace(g_tagResource, _T("(%s) (%s (%x)) - UpdateState: Unknown state '%d' for resource '%s'"), Pdoc()->StrNode(), StrName(), this, Crs(), StrName());
            m_iimgState = (UINT) -1;
            break;
    } // switch:  Crs()

    SetOwnerState(pwszOwner);
    SetGroupState(pwszGroup);

    if( NULL != prgwszOwner )
    {
        delete [] prgwszOwner;
    }
    
    if( NULL != prgwszGroup )
    {
        delete [] prgwszGroup;
    }

    // Call the base class method.
    CClusterItem::UpdateState();

} //*** CResource::UpdateState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::SetOwnerState
//
//  Routine Description:
//      Set a new owner for this resource.
//
//  Arguments:
//      pszNewOwner     [IN] Name of the new owner.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::SetOwnerState(IN LPCTSTR pszNewOwner)
{
    CClusterNode *  pciOldOwner = PciOwner();
    CClusterNode *  pciNewOwner;

    Trace(g_tagResource, _T("(%s) (%s (%x)) - Setting owner to '%s'"), Pdoc()->StrNode(), StrName(), this, pszNewOwner);

    if (pszNewOwner == NULL)
        pciNewOwner = NULL;
    else
        pciNewOwner = Pdoc()->LpciNodes().PciNodeFromName(pszNewOwner);
    if (pciNewOwner != pciOldOwner)
    {
#ifdef _DEBUG
        if (g_tagResource.BAny())
        {
            CString     strMsg;
            CString     strMsg2;

            strMsg.Format(_T("(%s) (%s (%x)) - Changing owner from "), Pdoc()->StrNode(), StrName(), this);
            if (pciOldOwner == NULL)
                strMsg += _T("nothing ");
            else
            {
                strMsg2.Format(_T("'%s' "), pciOldOwner->StrName());
                strMsg += strMsg2;
            } // else:  previous owner
            if (pciNewOwner == NULL)
                strMsg += _T("to nothing");
            else
            {
                strMsg2.Format(_T("to '%s'"), pciNewOwner->StrName());
                strMsg += strMsg2;
            } // else:  new owner
            Trace(g_tagResource, strMsg);
        } // if:  trace tag turned on
#endif
        m_strOwner = pszNewOwner;
        m_pciOwner = pciNewOwner;

        // Update reference counts.
        if (pciOldOwner != NULL)
            pciOldOwner->Release();
        if (pciNewOwner != NULL)
            pciNewOwner->AddRef();

        if (BDocObj())
        {
            if (pciOldOwner != NULL)
                pciOldOwner->RemoveActiveResource(this);
            if (pciNewOwner != NULL)
                pciNewOwner->AddActiveResource(this);
        } // if:  this is a document object
    } // if:  owner changed
    else if ((pszNewOwner != NULL) && (StrOwner() != pszNewOwner))
        m_strOwner = pszNewOwner;

} //*** CResource::SetOwnerState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::SetGroupState
//
//  Routine Description:
//      Set a new group for this resource.
//
//  Arguments:
//      pszNewGroup     [IN] Name of the new group.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::SetGroupState(IN LPCTSTR pszNewGroup)
{
    CGroup *    pciOldGroup = PciGroup();
    CGroup *    pciNewGroup;

    Trace(g_tagResource, _T("(%s) (%s (%x)) - Setting group to '%s'"), Pdoc()->StrNode(), StrName(), this, (pszNewGroup == NULL ? _T("") : pszNewGroup));

    if (pszNewGroup == NULL)
        pciNewGroup = NULL;
    else
        pciNewGroup = Pdoc()->LpciGroups().PciGroupFromName(pszNewGroup);
    if (pciNewGroup != pciOldGroup)
    {
#ifdef _DEBUG
        if (g_tagResource.BAny())
        {
            CString     strMsg;
            CString     strMsg2;

            strMsg.Format(_T("(%s) (%s (%x)) - Changing group from "), Pdoc()->StrNode(), StrName(), this);
            if (pciOldGroup == NULL)
                strMsg += _T("nothing ");
            else
            {
                strMsg2.Format(_T("'%s' "), pciOldGroup->StrName());
                strMsg += strMsg2;
            } // else:  previous group
            if (pciNewGroup == NULL)
                strMsg += _T("to nothing");
            else
            {
                strMsg2.Format(_T("to '%s'"), pciNewGroup->StrName());
                strMsg += strMsg2;
            } // else:  new group
            Trace(g_tagResource, strMsg);
        } // if:  trace tag turned on
#endif
        m_strGroup = pszNewGroup;
        m_pciGroup = pciNewGroup;

        // Update reference counts.
        if (pciOldGroup != NULL)
            pciOldGroup->Release();
        if (pciNewGroup != NULL)
            pciNewGroup->AddRef();

        if (BDocObj())
        {
            if (pciOldGroup != NULL)
                pciOldGroup->RemoveResource(this);
            if (pciNewGroup != NULL)
                pciNewGroup->AddResource(this);
        } // if:  this is a document object
    } // if:  owner changed
    else if ((pszNewGroup != NULL) && (StrGroup() != pszNewGroup))
        m_strGroup = pszNewGroup;

} //*** CResource::SetGroupState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::BGetColumnData
//
//  Routine Description:
//      Returns a string with the column data.
//
//  Arguments:
//      colid           [IN] Column ID.
//      rstrText        [OUT] String in which to return the text for the column.
//
//  Return Value:
//      TRUE        Column data returned.
//      FALSE       Column ID not recognized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::BGetColumnData(IN COLID colid, OUT CString & rstrText)
{
    BOOL    bSuccess;

    switch (colid)
    {
        case IDS_COLTEXT_STATE:
            GetStateName(rstrText);
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_RESTYPE:
            rstrText = StrRealResourceTypeDisplayName();
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_OWNER:
            rstrText = StrOwner();
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_GROUP:
            if (PciGroup() == NULL)
                rstrText = StrGroup();
            else
                rstrText = PciGroup()->StrName();
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_RESOURCE: // This is for showing dependencies
            colid = IDS_COLTEXT_NAME;
            // FALL THROUGH
        default:
            bSuccess = CClusterItem::BGetColumnData(colid, rstrText);
            break;
    } // switch:  colid

    return bSuccess;

} //*** CResource::BGetColumnData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::GetTreeName
//
//  Routine Description:
//      Returns a string to be used in a tree control.
//
//  Arguments:
//      rstrName    [OUT] String in which to return the name.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
void CResource::GetTreeName(OUT CString & rstrName) const
{
    CString     strState;

    GetStateName(strState);
    rstrName.Format(_T("%s (%s)"), StrName(), strState);

} //*** CResource::GetTreeName()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::GetStateName
//
//  Routine Description:
//      Returns a string with the name of the current state.
//
//  Arguments:
//      rstrState   [OUT] String in which to return the name of the current state.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::GetStateName(OUT CString & rstrState) const
{
    switch (Crs())
    {
        case ClusterResourceStateUnknown:
            rstrState.LoadString(IDS_UNKNOWN);
            break;
        case ClusterResourceOnline:
            rstrState.LoadString(IDS_ONLINE);
            break;
        case ClusterResourceOnlinePending:
            rstrState.LoadString(IDS_ONLINE_PENDING);
            break;
        case ClusterResourceOffline:
            rstrState.LoadString(IDS_OFFLINE);
            break;
        case ClusterResourceOfflinePending:
            rstrState.LoadString(IDS_OFFLINE_PENDING);
            break;
        case ClusterResourceFailed:
            rstrState.LoadString(IDS_FAILED);
            break;
        default:
            rstrState.Empty();
            break;
    } // switch:  Crs()

} //*** CResource::GetStateName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::BCanBeEdited
//
//  Routine Description:
//      Determines if the resource can be renamed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Resource can be renamed.
//      FALSE       Resource cannot be renamed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::BCanBeEdited(void) const
{
    BOOL    bCanBeEdited;

    if (   (Crs() == ClusterResourceStateUnknown)
        || BReadOnly())
        bCanBeEdited  = FALSE;
    else
        bCanBeEdited = TRUE;

    return bCanBeEdited;

} //*** CResource::BCanBeEdited()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::Rename
//
//  Routine Description:
//      Rename the resource.
//
//  Arguments:
//      pszName         [IN] New name to give to the resource.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors returned from SetClusterResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::Rename(IN LPCTSTR pszName)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hresource() != NULL);

    if (StrName() != pszName)
    {
        dwStatus = SetClusterResourceName(Hresource(), pszName);
        if (dwStatus != ERROR_SUCCESS)
            ThrowStaticException(dwStatus, IDS_RENAME_RESOURCE_ERROR, StrName(), pszName);
        m_strName = pszName;
    } // if:  the name changed

} //*** CResource::Rename()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    BOOL        bHandled    = FALSE;

    // If this is a MOVE_RESOURCE command, process it here.
    if ((ID_FILE_MOVE_RESOURCE_1 <= nID) && (nID <= ID_FILE_MOVE_RESOURCE_20))
    {
        Trace(g_tagResource, _T("(%s) OnCmdMsg() %s (%x) - ID = %d, code = %d"), Pdoc()->StrNode(), StrName(), this, nID, nCode);
        if (nCode == 0)
        {
            OnCmdMoveResource(nID);
            bHandled = TRUE;
        } // if:  code = 0
    } // if:  move resource

    if (!bHandled)
        bHandled = CClusterItem::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

    return bHandled;

} //*** CResource::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnUpdateBringOnline
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_BRING_ONLINE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnUpdateBringOnline(CCmdUI * pCmdUI)
{
    if ((Crs() != ClusterResourceOnline)
            && (Crs() != ClusterResourceOnlinePending)
            && (Crs() != ClusterResourceStateUnknown))
        pCmdUI->Enable(TRUE);
    else
        pCmdUI->Enable(FALSE);

} //*** CResource::OnUpdateBringOnline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnUpdateTakeOffline
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_TAKE_OFFLINE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnUpdateTakeOffline(CCmdUI * pCmdUI)
{
    if (Crs() == ClusterResourceOnline)
        pCmdUI->Enable(TRUE);
    else
        pCmdUI->Enable(FALSE);

} //*** CResource::OnUpdateTakeOffline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnUpdateInitiateFailure
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_INITIATE_FAILURE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnUpdateInitiateFailure(CCmdUI * pCmdUI)
{
    if (Crs() == ClusterResourceOnline)
        pCmdUI->Enable(TRUE);
    else
        pCmdUI->Enable(FALSE);

} //*** CResource::OnUpdateInitiateFailure()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnUpdateMoveResource1
//
//  Routine Description:
//      Determines whether menu items corresponding to
//      ID_FILE_MOVE_RESOURCE_1 should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnUpdateMoveResource1(CCmdUI * pCmdUI)
{
    if (pCmdUI->m_pSubMenu == NULL)
    {
        CString     strMenuName;

        if ((pCmdUI->m_pMenu != NULL) && (pCmdUI->m_pSubMenu == NULL))
            pCmdUI->m_pMenu->GetMenuString(pCmdUI->m_nID, strMenuName, MF_BYCOMMAND);

        if ((strMenuName != StrGroup())
                && ((Crs() == ClusterResourceOnline)
                        || (Crs() == ClusterResourceOffline)))
            pCmdUI->Enable(TRUE);
        else
            pCmdUI->Enable(FALSE);
    } // if:  nested menu is being displayed
    else
    {
        BOOL    bEnabled;

        if (Pdoc()->LpciGroups().GetCount() < 2)
            bEnabled = FALSE;
        else
        {
            POSITION    pos;
            UINT        imenu;
            UINT        idMenu;
            UINT        cmenu;
            CGroup *    pciGroup;
            CMenu *     pmenu   = pCmdUI->m_pSubMenu;

            bEnabled = TRUE;

            // Delete the items in the menu.
            cmenu = pmenu->GetMenuItemCount();
            while (cmenu-- > 0)
                pmenu->DeleteMenu(0, MF_BYPOSITION);

            // Add each group to the menu.
            pos = Pdoc()->LpciGroups().GetHeadPosition();
            for (imenu = 0, idMenu = ID_FILE_MOVE_RESOURCE_1
                    ; pos != NULL
                    ; idMenu++)
            {
                pciGroup = (CGroup *) Pdoc()->LpciGroups().GetNext(pos);
                ASSERT_VALID(pciGroup);
                pmenu->InsertMenu(
                            imenu++,
                            MF_BYPOSITION,
                            idMenu,
                            pciGroup->StrName()
                            );
            } // for:  each group
        } // else:  move user is available

        // Enable or disable the Move menu.
        pCmdUI->m_pMenu->EnableMenuItem(
                            pCmdUI->m_nIndex,
                            MF_BYPOSITION
                            | (bEnabled ? MF_ENABLED : MF_GRAYED)
                            );
    } // else:  top-level menu is being displayed

} //*** CResource::OnUpdateMoveResource1()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnUpdateMoveResourceRest
//
//  Routine Description:
//      Determines whether menu items corresponding to
//      ID_FILE_MOVE_RESOURCE_2 through ID_FILE_MOVE_RESOURCE_20
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnUpdateMoveResourceRest(CCmdUI * pCmdUI)
{
    CString     strMenuName;

    if ((pCmdUI->m_pMenu != NULL) && (pCmdUI->m_pSubMenu == NULL))
        pCmdUI->m_pMenu->GetMenuString(pCmdUI->m_nID, strMenuName, MF_BYCOMMAND);

    if ((strMenuName != StrGroup())
            && ((Crs() == ClusterResourceOnline)
                    || (Crs() == ClusterResourceOffline)))
        pCmdUI->Enable(TRUE);
    else
        pCmdUI->Enable(FALSE);

} //*** CResource::OnUpdateMoveResourceRest()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnUpdateDelete
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_DELETE
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnUpdateDelete(CCmdUI * pCmdUI)
{
    if (Crs() != ClusterResourceStateUnknown)
        pCmdUI->Enable(TRUE);
    else
        pCmdUI->Enable(FALSE);

} //*** CResource::OnUpdateDelete()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnCmdBringOnline
//
//  Routine Description:
//      Processes the ID_FILE_BRING_ONLINE menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnCmdBringOnline(void)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hresource() != NULL);

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // If there are no possible owners for this resource, display a message.
    if (LpcinodePossibleOwners().GetCount() == 0)
        AfxMessageBox(IDS_NO_POSSIBLE_OWNERS, MB_OK | MB_ICONINFORMATION);
    else
    {
        dwStatus = OnlineClusterResource(Hresource());
        if ((dwStatus != ERROR_SUCCESS)
                && (dwStatus != ERROR_IO_PENDING))
        {
            CNTException    nte(dwStatus, IDS_BRING_RESOURCE_ONLINE_ERROR, StrName(), NULL, FALSE /*bAutoDelete*/);
            nte.ReportError();
        } // if:  error bringing the resource online

        UpdateState();
    } // else:  resource has at least one possible owner

    Release();

} //*** CResource::OnCmdBringOnline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnCmdTakeOffline
//
//  Routine Description:
//      Processes the ID_FILE_TAKE_OFFLINE menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnCmdTakeOffline(void)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hresource() != NULL);

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    do // do-while to prevent goto's
    {
        // If this connection was made through the cluster name and this is
        // either the cluster name resource or one of the resources on which
        // it is dependent, warn the user.
        if (!BAllowedToTakeOffline())
            break;

        dwStatus = OfflineClusterResource(Hresource());
        if ((dwStatus != ERROR_SUCCESS)
                && (dwStatus != ERROR_IO_PENDING))
        {
            CNTException    nte(dwStatus, IDS_TAKE_RESOURCE_OFFLINE_ERROR, StrName(), NULL, FALSE /*bAutoDelete*/);
            nte.ReportError();
        } // if:  error taking the resource offline

        UpdateState();
    }  while (0); // do-while to prevent goto's

    Release();

} //*** CResource::OnCmdTakeOffline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnCmdInitiateFailure
//
//  Routine Description:
//      Processes the ID_FILE_INITIATE_FAILURE menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnCmdInitiateFailure(void)
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT(Hresource() != NULL);

    dwStatus = FailClusterResource(Hresource());
    if (dwStatus != ERROR_SUCCESS)
    {
        CNTException    nte(dwStatus, IDS_INIT_RESOURCE_FAILURE_ERROR, StrName(), NULL /*bAutoDelete*/);
        nte.ReportError();
    } // if:  error initiating failure

    UpdateState();

} //*** CResource::OnCmdInitiateFailure()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnCmdMoveResource
//
//  Routine Description:
//      Processes the ID_FILE_MOVE_RESOURCE_# menu commands.
//
//  Arguments:
//      nID             [IN] Command ID.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnCmdMoveResource(IN UINT nID)
{
    int         ipci;

    ASSERT(Hresource() != NULL);

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    do // do-while to prevent goto's
    {
        ipci = (int) (nID - ID_FILE_MOVE_RESOURCE_1);
        ASSERT(ipci < Pdoc()->LpciGroups().GetCount());
        if (ipci < Pdoc()->LpciGroups().GetCount())
        {
            POSITION        pos;
            CResourceList   lpciMove;
            CString         strMsg;
            CGroup *        pciGroup;

            // Get the group.
            pos = Pdoc()->LpciGroups().FindIndex(ipci);
            ASSERT(pos != NULL);
            pciGroup = (CGroup *) Pdoc()->LpciGroups().GetAt(pos);
            ASSERT_VALID(pciGroup);

            try
            {
                // Verify that the user really wants to move this resource.
                strMsg.FormatMessage(IDS_VERIFY_MOVE_RESOURCE, StrName(), StrGroup(), pciGroup->StrName());
                if (AfxMessageBox(strMsg, MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2) == IDNO)
                    break;

                // Collect the list of resources which will be moved if confirmed.
                lpciMove.AddTail(this);
                CollectDependencyTree(&lpciMove);

                // If this resource is dependent on or is a dependent of any other resource,
                // display another warning message.
                if (lpciMove.GetCount() > 0)
                {
                    CMoveResourcesDlg   dlg(this, &lpciMove, AfxGetMainWnd());
                    if (dlg.DoModal() != IDOK)
                        break;
                } // if:  resource is dependent of another resource

                // Move the resource.
                {
                    CWaitCursor wc;
                    Move(pciGroup);
                } // Move the resource
            } // try
            catch (CException * pe)
            {
                pe->ReportError();
                pe->Delete();
            } // catch:  CException
        } // if:  valid index
    }  while (0); // do-while to prevent goto's

    Release();

} //*** CResource::OnCmdMoveResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnCmdDelete
//
//  Routine Description:
//      Processes the ID_FILE_DELETE menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnCmdDelete(void)
{
    CResourceList   lpci;
    CString         strMsg;

    ASSERT(Hresource() != NULL);

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    do // do-while to prevent goto's
    {
        try
        {
            // If this is a core resource, we can't delete it.
            if (BCore())
            {
                AfxMessageBox(IDS_CANT_DELETE_CORE_RESOURCE, MB_OK | MB_ICONSTOP);
                break;
            } // If this is a core resource

            // Verify that the user really wants to delete this resource.
            strMsg.FormatMessage(IDS_VERIFY_DELETE_RESOURCE, StrName());
            if (AfxMessageBox(strMsg, MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2) == IDNO)
                break;

            if (Hresource() != NULL)
            {
                // Collect the list of resources which will be deleted if confirmed.
                CollectProvidesFor(&lpci, TRUE /*bFullTree*/);

                // If any of these resources are core resources, we can't
                // delete any of the resources.
                {
                    POSITION    pos;
                    CResource * pciRes = NULL;

                    pos = lpci.GetHeadPosition();
                    while (pos != NULL)
                    {
                        pciRes = (CResource *) lpci.GetNext(pos);
                        ASSERT_VALID(pciRes);
                        if (pciRes->BCore())
                        {
                            AfxMessageBox(IDS_CANT_DELETE_CORE_RESOURCE, MB_OK | MB_ICONSTOP);
                            break;
                        } // if:  found a core resource
                        pciRes = NULL;
                    } // while:  more items in the list
                    if (pciRes != NULL)
                        break;
                } // Check for core resources

                // If this resource is a dependent of any other resource, display
                // another warning message.
                if (lpci.GetCount() > 0)
                {
                    CDeleteResourcesDlg dlg(this, &lpci, AfxGetMainWnd());
                    if (dlg.DoModal() != IDOK)
                        break;
                } // if:  resource is dependent of another resource

                // Delete the resource.
                {
                    CWaitCursor wc;
                    DeleteResource(lpci);
                } // Delete the resource
            } // if:  resource still exists
        } // try
        catch (CNTException * pnte)
        {
            if (pnte->Sc() != ERROR_RESOURCE_NOT_AVAILABLE)
                pnte->ReportError();
            pnte->Delete();
        } // catch:  CNTException
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
        } // catch:  CException
    }  while (0); // do-while to prevent goto's

    Release();

} //*** CResource::OnCmdDelete()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnUpdateProperties
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_PROPERTIES
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResource::OnUpdateProperties(CCmdUI * pCmdUI)
{
    pCmdUI->Enable(TRUE);

} //*** CResource::OnUpdateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::BDisplayProperties
//
//  Routine Description:
//      Display properties for the object.
//
//  Arguments:
//      bReadOnly   [IN] Don't allow edits to the object properties.
//
//  Return Value:
//      TRUE    OK pressed.
//      FALSE   OK not pressed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::BDisplayProperties(IN BOOL bReadOnly)
{
    BOOL                bChanged = FALSE;
    CResourcePropSheet  sht(AfxGetMainWnd());

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // If the object has changed, read it.
    if (BChanged())
        ReadItem();

    // Display the property sheet.
    try
    {
        sht.SetReadOnly(bReadOnly);
        if (sht.BInit(this, IimgObjectType()))
            bChanged = ((sht.DoModal() == IDOK) && !bReadOnly);
    } // try
    catch (CException * pe)
    {
        pe->Delete();
    } // catch:  CException

    Release();
    return bChanged;

} //*** CResource::BDisplayProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::BAllowedToTakeOffline
//
//  Routine Description:
//      Determine if this resource is allowed to be taken offline.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Resource is allowed to be taken offline.
//      FALSE       Resource is NOT allowed to be taken offline.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResource::BAllowedToTakeOffline(void)
{
    BOOL    bAllowed = TRUE;

    ASSERT_VALID(Pdoc());

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // Check to see if document is connected via the cluster name.
    if (Pdoc()->StrName() == Pdoc()->StrNode())
    {
        // If this is the core network name resource, we need to ask
        // the user first.
        if (   (StrRealResourceType().CompareNoCase(CLUS_RESTYPE_NAME_NETNAME) == 0)
            && BCore() )
            bAllowed = FALSE;
        else
        {
            CResourceList   lpci;
            CResource *     pciRes;
            POSITION        pos;

            // Collect all the resources above this resource in the
            // dependency tree.  If one of them is the cluster name
            // resource, we need to ask the user first.
            try
            {
                CollectProvidesFor(&lpci, TRUE /*bFullTree*/);
                pos = lpci.GetHeadPosition();
                while (pos != NULL)
                {
                    pciRes = (CResource *) lpci.GetNext(pos);
                    ASSERT_VALID(pciRes);

                    if (   (pciRes->StrRealResourceType().CompareNoCase(CLUS_RESTYPE_NAME_NETNAME) == 0)
                        && pciRes->BCore() )
                        bAllowed = FALSE;
                } // while:  more resources in the list
            } // try
            catch (CException * pe)
            {
                pe->Delete();
            } // catch:  CException
        } // else:  not the cluster name resource
    } // if:  connected via the cluster name

    // If not allowed to take offline, ask the user to confirm.
    if (!bAllowed)
    {
        ID      id;
        CString strMsg;

        strMsg.FormatMessage(IDS_TAKE_CLUSTER_NAME_OFFLINE_QUERY, StrName(), Pdoc()->StrName());
        id = AfxMessageBox(strMsg, MB_OKCANCEL | MB_ICONEXCLAMATION);
        bAllowed = (id == IDOK);
    } // if:  not allowed to atake offline

    Release();

    return bAllowed;

} //*** CResource::BAllowedToTakeOffline()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::OnClusterNotify
//
//  Routine Description:
//      Handler for the WM_CAM_CLUSTER_NOTIFY message.
//      Processes cluster notifications for this object.
//
//  Arguments:
//      pnotify     [IN OUT] Object describing the notification.
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CResource::OnClusterNotify(IN OUT CClusterNotify * pnotify)
{
    ASSERT(pnotify != NULL);
    ASSERT_VALID(this);

    try
    {
        switch (pnotify->m_dwFilterType)
        {
            case CLUSTER_CHANGE_RESOURCE_STATE:
                Trace(g_tagResNotify, _T("(%s) - Resource '%s' (%x) state changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                UpdateState();
                break;

            case CLUSTER_CHANGE_RESOURCE_DELETED:
                Trace(g_tagResNotify, _T("(%s) - Resource '%s' (%x) deleted (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                if (Pdoc()->BClusterAvailable())
                    Delete();
                break;

            case CLUSTER_CHANGE_RESOURCE_PROPERTY:
                Trace(g_tagResNotify, _T("(%s) - Resource '%s' (%x) properties changed (%s)"), Pdoc()->StrNode(), StrName(), this, pnotify->m_strName);
                if (!BDeleting() && Pdoc()->BClusterAvailable())
                    ReadItem();
                break;

            case CLUSTER_CHANGE_REGISTRY_NAME:
                Trace(g_tagResRegNotify, _T("(%s) - Registry namespace '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            case CLUSTER_CHANGE_REGISTRY_ATTRIBUTES:
                Trace(g_tagResRegNotify, _T("(%s) - Registry attributes for '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            case CLUSTER_CHANGE_REGISTRY_VALUE:
                Trace(g_tagResRegNotify, _T("(%s) - Registry value '%s' changed (%s %s (%x))"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName(), this);
                MarkAsChanged();
                break;

            default:
                Trace(g_tagResNotify, _T("(%s) - Unknown resource notification (%x) for '%s' (%x) (%s)"), Pdoc()->StrNode(), pnotify->m_dwFilterType, StrName(), this, pnotify->m_strName);
        } // switch:  dwFilterType
    } // try
    catch (CException * pe)
    {
        // Don't display anything on notification errors.
        // If it's really a problem, the user will see it when
        // refreshing the view.
        //pe->ReportError();
        pe->Delete();
    } // catch:  CException

    delete pnotify;
    return 0;

} //*** CResource::OnClusterNotify()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DeleteAllItemData
//
//  Routine Description:
//      Deletes all item data in a CList.
//
//  Arguments:
//      rlp     [IN OUT] List whose data is to be deleted.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef NEVER
void DeleteAllItemData(IN OUT CResourceList & rlp)
{
    POSITION    pos;
    CResource * pci;

    // Delete all the items in the Contained list.
    pos = rlp.GetHeadPosition();
    while (pos != NULL)
    {
        pci = rlp.GetNext(pos);
        ASSERT_VALID(pci);
//      Trace(g_tagClusItemDelete, _T("DeleteAllItemData(rlpcires) - Deleting resource cluster item '%s' (%x)"), pci->StrName(), pci);
        pci->Delete();
    } // while:  more items in the list

} //*** DeleteAllItemData()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\res.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      Res.h
//
//  Abstract:
//      Definition of the CResource class.
//
//  Implementation File:
//      Res.cpp
//
//  Author:
//      David Potter (davidp)   May 6, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _RES_H_
#define _RES_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CResource;
class CResourceList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CGroup;
class CResourceType;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterNode;
class CNodeList;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSITEM_H_
#include "ClusItem.h"   // for CClusterItem
#endif

#ifndef _RESTYPE_H_
#include "ResType.h"    // for CResourceType
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"   // for CObjectProperty, CClusPropList
#endif

/////////////////////////////////////////////////////////////////////////////
// CResource command target
/////////////////////////////////////////////////////////////////////////////

class CResource : public CClusterItem
{
    DECLARE_DYNCREATE(CResource)

// Construction
public:
    CResource(void);        // protected constructor used by dynamic creation
    CResource(IN BOOL bDocobj);
    void                    Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName);
    void                    Create(
                                IN OUT CClusterDoc *    pdoc,
                                IN LPCTSTR              lpszName,
                                IN LPCTSTR              lpszType,
                                IN LPCTSTR              lpszGroup,
                                IN BOOL                 bSeparateMonitor
                                );

protected:
    void                    CommonConstruct(void);

// Attributes
protected:
    HRESOURCE               m_hresource;
    CLUSTER_RESOURCE_STATE  m_crs;
    CString                 m_strOwner;
    CClusterNode *          m_pciOwner;
    CString                 m_strGroup;
    CGroup *                m_pciGroup;

    BOOL                    m_bSeparateMonitor;
    DWORD                   m_nLooksAlive;
    DWORD                   m_nIsAlive;
    CRRA                    m_crraRestartAction;
    DWORD                   m_nRestartThreshold;
    DWORD                   m_nRestartPeriod;
    DWORD                   m_nPendingTimeout;

    CString                 m_strResourceType;
    CResourceType *         m_pciResourceType;
    PCLUSPROP_REQUIRED_DEPENDENCY   m_pcrd;
    CLUS_RESOURCE_CLASS_INFO        m_rciResClassInfo;
    DWORD                   m_dwCharacteristics;
    DWORD                   m_dwFlags;

    CResourceList *         m_plpciresDependencies;
    CNodeList *             m_plpcinodePossibleOwners;

    enum
    {
        epropName = 0,
        epropType,
        epropDescription,
        epropSeparateMonitor,
        epropLooksAlive,
        epropIsAlive,
        epropRestartAction,
        epropRestartThreshold,
        epropRestartPeriod,
        epropPendingTimeout,
        epropMAX
    };

    CObjectProperty     m_rgProps[epropMAX];

public:
    HRESOURCE               Hresource(void) const               { return m_hresource; }
    CLUSTER_RESOURCE_STATE  Crs(void) const                     { return m_crs; }
    const CString &         StrOwner(void) const                { return m_strOwner; }
    CClusterNode *          PciOwner(void) const                { return m_pciOwner; }
    const CString &         StrGroup(void) const                { return m_strGroup; }
    CGroup *                PciGroup(void) const                { return m_pciGroup; }

    const CString &         StrResourceType(void) const         { return m_strResourceType; }
    const CString &         StrRealResourceType(void) const
    {
        if (PciResourceType() == NULL)
            return StrResourceType();
        else
        {
            ASSERT_VALID(PciResourceType());
            return PciResourceType()->StrName();
        }
    }
    const CString &         StrRealResourceTypeDisplayName(void) const
    {
        if (PciResourceType() == NULL)
            return StrResourceType();
        else
        {
            ASSERT_VALID(PciResourceType());
            if (PciResourceType()->StrDisplayName().GetLength() == 0)
                return PciResourceType()->StrName();
            else
                return PciResourceType()->StrDisplayName();
        }
    }

    CResourceType *         PciResourceType(void) const         { return m_pciResourceType; }
    BOOL                    BSeparateMonitor(void) const        { return m_bSeparateMonitor; }
    DWORD                   NLooksAlive(void) const             { return m_nLooksAlive; }
    DWORD                   NIsAlive(void) const                { return m_nIsAlive; }
    CRRA                    CrraRestartAction(void) const       { return m_crraRestartAction; }
    DWORD                   NRestartThreshold(void) const       { return m_nRestartThreshold; }
    DWORD                   NRestartPeriod(void) const          { return m_nRestartPeriod; }
    DWORD                   NPendingTimeout(void) const         { return m_nPendingTimeout; }
    const PCLUSPROP_REQUIRED_DEPENDENCY Pcrd(void) const        { return m_pcrd; }
    CLUSTER_RESOURCE_CLASS  ResClass(void) const                { return m_rciResClassInfo.rc; }
    PCLUS_RESOURCE_CLASS_INFO   PrciResClassInfo(void)          { return &m_rciResClassInfo; }
    DWORD                   DwCharacteristics(void) const       { return m_dwCharacteristics; }
    DWORD                   DwFlags(void) const                 { return m_dwFlags; }
    BOOL                    BQuorumCapable( void ) const        { return (m_dwCharacteristics & CLUS_CHAR_QUORUM) != 0; }
    BOOL                    BLocalQuorum( void ) const          { return (m_dwCharacteristics & CLUS_CHAR_LOCAL_QUORUM) != 0; }
    BOOL                    BLocalQuorumDebug( void ) const     { return (m_dwCharacteristics & CLUS_CHAR_LOCAL_QUORUM_DEBUG) != 0; }
    BOOL                    BDeleteRequiresAllNodes( void ) const { return (m_dwCharacteristics & CLUS_CHAR_DELETE_REQUIRES_ALL_NODES) != 0; }
    BOOL                    BCore( void ) const                 { return (m_dwFlags & CLUS_FLAG_CORE) != 0; }

    const CResourceList &   LpciresDependencies(void) const     { ASSERT(m_plpciresDependencies != NULL); return *m_plpciresDependencies; }
    const CNodeList &       LpcinodePossibleOwners(void) const  { ASSERT(m_plpcinodePossibleOwners != NULL); return *m_plpcinodePossibleOwners; }

    void                    GetStateName(OUT CString & rstrState) const;

    BOOL                    BCanBeDependent(IN CResource * pciRes);
    BOOL                    BIsDependent(IN CResource * pciRes);
    BOOL                    BGetNetworkName(OUT WCHAR * lpszNetName, IN OUT DWORD * pcchNetName);
    BOOL                    BGetNetworkName(OUT CString & rstrNetName);

// Operations
public:
    void                    SetOwnerState(IN LPCTSTR pszNewOwner);
    void                    SetGroupState(IN LPCTSTR pszNewGroup);

    void                    CollectPossibleOwners(IN OUT CNodeList * plpci) const;
//  void                    RemoveNodeFromPossibleOwners(IN OUT CNodeList * plpci, IN const CClusterNode * pNode);
    void                    CollectDependencies(IN OUT CResourceList * plpci, IN BOOL bFullTree = FALSE) const;
    void                    CollectProvidesFor(IN OUT CResourceList * plpci, IN BOOL bFullTree = FALSE) const;
    void                    CollectDependencyTree(IN OUT CResourceList * plpci) const;

    void                    DeleteResource(void);
    void                    Move(IN const CGroup * pciGroup);
    void                    ReadExtensions(void);

    void                    SetName(IN LPCTSTR pszName);
    void                    SetGroup(IN LPCTSTR pszGroup);
    void                    SetDependencies(IN const CResourceList & rlpci);
    void                    SetPossibleOwners(IN const CNodeList & rlpci);
    void                    SetCommonProperties(
                                IN const CString &  rstrDesc,
                                IN BOOL             bSeparate,
                                IN DWORD            nLooksAlive,
                                IN DWORD            nIsAlive,
                                IN CRRA             crra,
                                IN DWORD            nThreshold,
                                IN DWORD            nPeriod,
                                IN DWORD            nTimeout,
                                IN BOOL             bValidateOnly
                                );
    void                    SetCommonProperties(
                                IN const CString &  rstrDesc,
                                IN BOOL             bSeparate,
                                IN DWORD            nLooksAlive,
                                IN DWORD            nIsAlive,
                                IN CRRA             crra,
                                IN DWORD            nThreshold,
                                IN DWORD            nPeriod,
                                IN DWORD            nTimeout
                                )
    {
        SetCommonProperties(rstrDesc, bSeparate, nLooksAlive, nIsAlive,crra,
                            nThreshold, nPeriod, nTimeout, FALSE /*bValidateOnly*/ );
    }
    void                    ValidateCommonProperties(
                                IN const CString &  rstrDesc,
                                IN BOOL             bSeparate,
                                IN DWORD            nLooksAlive,
                                IN DWORD            nIsAlive,
                                IN CRRA             crra,
                                IN DWORD            nThreshold,
                                IN DWORD            nPeriod,
                                IN DWORD            nTimeout
                                )
    {
        SetCommonProperties(rstrDesc, bSeparate, nLooksAlive, nIsAlive,crra,
                            nThreshold, nPeriod, nTimeout, TRUE /*bValidateOnly*/ );
    }

    DWORD                   DwResourceControlGet(
                                IN DWORD        dwFunctionCode,
                                IN PBYTE        pbInBuf,
                                IN DWORD        cbInBuf,
                                OUT PBYTE *     ppbOutBuf
                                );
    DWORD                   DwResourceControlGet(
                                IN DWORD        dwFunctionCode,
                                OUT PBYTE *     ppbOutBuf
                                )                           { return DwResourceControlGet(dwFunctionCode, NULL, NULL, ppbOutBuf); }
    BOOL                    BRequiredDependenciesPresent(
                                IN const CResourceList &    rlpciRes,
                                OUT CString &               rstrMissing
                                );

// Overrides
public:
    virtual void            Cleanup(void);
    virtual void            ReadItem(void);
    virtual void            UpdateState(void);
    virtual void            Rename(IN LPCTSTR pszName);
    virtual BOOL            BGetColumnData(IN COLID colid, OUT CString & rstrText);
    virtual BOOL            BCanBeEdited(void) const;
    virtual BOOL            BDisplayProperties(IN BOOL bReadOnly = FALSE);

    // Drag & Drop
    virtual BOOL            BCanBeDragged(void) const   { return TRUE; }

    virtual const CStringList * PlstrExtensions(void) const;

#ifdef _DISPLAY_STATE_TEXT_IN_TREE
    virtual void            GetTreeName(OUT CString & rstrName) const;
#endif

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CResource)
    public:
    virtual void OnFinalRelease();
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
    //}}AFX_VIRTUAL

    virtual LRESULT         OnClusterNotify(IN OUT CClusterNotify * pnotify);

protected:
    virtual const CObjectProperty * Pprops(void) const  { return m_rgProps; }
    virtual DWORD                   Cprops(void) const  { return sizeof(m_rgProps) / sizeof(CObjectProperty); }
    virtual DWORD                   DwSetCommonProperties(IN const CClusPropList & rcpl, IN BOOL bValidateOnly = FALSE);

// Implementation
protected:
    CStringList             m_lstrCombinedExtensions;
    BOOL                    m_bInitializing;
    BOOL                    m_bDeleting;

    const CStringList &     LstrCombinedExtensions(void) const  { return m_lstrCombinedExtensions; }

public:
    virtual ~CResource(void);
    BOOL                    BInitializing(void) const               { return m_bInitializing; }
    BOOL                    BDeleting(void) const                   { return m_bDeleting; }
    void                    SetInitializing(IN BOOL bInit = TRUE)   { m_bInitializing = bInit; }

protected:
    void                    DeleteResource(IN const CResourceList & rlpci);
    void                    Move(IN const CGroup * pciGroup, IN const CResourceList & rlpci);
    BOOL                    BAllowedToTakeOffline(void);
    void                    WaitForOffline( void );

public:
    // Generated message map functions
    //{{AFX_MSG(CResource)
    afx_msg void OnUpdateBringOnline(CCmdUI* pCmdUI);
    afx_msg void OnUpdateTakeOffline(CCmdUI* pCmdUI);
    afx_msg void OnUpdateInitiateFailure(CCmdUI* pCmdUI);
    afx_msg void OnUpdateMoveResource1(CCmdUI* pCmdUI);
    afx_msg void OnUpdateMoveResourceRest(CCmdUI* pCmdUI);
    afx_msg void OnUpdateDelete(CCmdUI* pCmdUI);
    afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
    afx_msg void OnCmdBringOnline();
    afx_msg void OnCmdTakeOffline();
    afx_msg void OnCmdInitiateFailure();
    afx_msg void OnCmdDelete();
    //}}AFX_MSG
    afx_msg void OnCmdMoveResource(IN UINT nID);

    DECLARE_MESSAGE_MAP()
#ifdef _CLUADMIN_USE_OLE_
    DECLARE_OLECREATE(CResource)

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CResource)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()
#endif // _CLUADMIN_USE_OLE_

}; //*** class CResource

/////////////////////////////////////////////////////////////////////////////
// CResourceList
/////////////////////////////////////////////////////////////////////////////

class CResourceList : public CClusterItemList
{
public:
    CResource *     PciResFromName(
                        IN LPCTSTR      pszName,
                        OUT POSITION *  ppos = NULL
                        )
    {
        return (CResource *) PciFromName(pszName, ppos);
    }

}; //*** class CResourceList

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

//void DeleteAllItemData(IN OUT CResourceList & rlp);

#ifdef _DEBUG
class CTraceTag;
extern CTraceTag g_tagResource;
extern CTraceTag g_tagResNotify;
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _RES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CluAdmin.rc
//
#define IDP_OLE_INIT_FAILED             100
#define IDS_CLUADMIN_DESC               101
#define IDR_MAINFRAME                   102
#define IDR_CLUADMTYPE                  103
#define IDM_CLUSTER                     104
#define IDM_CLUSTER_POPUP               105
#define IDM_NODE                        106
#define IDM_NODE_POPUP                  107
#define IDM_GROUP                       108
#define IDM_GROUP_POPUP                 109
#define IDM_RESOURCE                    110
#define IDM_RESOURCE_POPUP              111
#define IDM_RESTYPE                     112
#define IDM_RESTYPE_POPUP               113
#define IDM_NETWORK                     114
#define IDM_NETWORK_POPUP               115
#define IDM_NETIFACE                    116
#define IDM_NETIFACE_POPUP              117
#define IDM_VIEW_POPUP                  118
#define IDM_MOVE_GROUP                  119
#define IDB_WIZ_NEW_GROUP               132
#define IDB_WIZ_NEW_RESOURCE            133
#define IDB_FOLDER_16                   140
#define IDB_FOLDER_32                   141
#define IDB_CLUSTER_16                  142
#define IDB_CLUSTER_32                  143
#define IDB_CLUSTER_64                  144
#define IDB_CLUSTER_UNKNOWN_16          145
#define IDB_CLUSTER_UNKNOWN_32          146
#define IDB_NODE_16                     147
#define IDB_NODE_32                     148
#define IDB_NODE_DOWN_16                149
#define IDB_NODE_DOWN_32                150
#define IDB_NODE_PAUSED_16              151
#define IDB_NODE_PAUSED_32              152
#define IDB_NODE_UNKNOWN_16             153
#define IDB_NODE_UNKNOWN_32             154
#define IDB_GROUP_16                    155
#define IDB_GROUP_32                    156
#define IDB_GROUP_PARTIAL_ONLINE_16     157
#define IDB_GROUP_PARTIAL_ONLINE_32     158
#define IDB_GROUP_PENDING_16            159
#define IDB_GROUP_PENDING_32            160
#define IDB_GROUP_OFFLINE_16            161
#define IDB_GROUP_OFFLINE_32            162
#define IDB_GROUP_FAILED_16             163
#define IDB_GROUP_FAILED_32             164
#define IDB_GROUP_UNKNOWN_16            165
#define IDB_GROUP_UNKNOWN_32            166
#define IDB_RES_16                      167
#define IDB_RES_32                      168
#define IDB_RES_OFFLINE_16              169
#define IDB_RES_OFFLINE_32              170
#define IDB_RES_PENDING_16              171
#define IDB_RES_PENDING_32              172
#define IDB_RES_FAILED_16               173
#define IDB_RES_FAILED_32               174
#define IDB_RES_UNKNOWN_16              175
#define IDB_RES_UNKNOWN_32              176
#define IDB_RESTYPE_16                  177
#define IDB_RESTYPE_32                  178
#define IDB_RESTYPE_UNKNOWN_16          179
#define IDB_RESTYPE_UNKNOWN_32          180
#define IDB_NETWORK_16                  181
#define IDB_NETWORK_32                  182
#define IDB_NETWORK_PARTITIONED_16      183
#define IDB_NETWORK_PARTITIONED_32      184
#define IDB_NETWORK_DOWN_16             185
#define IDB_NETWORK_DOWN_32             186
#define IDB_NETWORK_UNKNOWN_16          187
#define IDB_NETWORK_UNKNOWN_32          188
#define IDB_NETIFACE_16                 189
#define IDB_NETIFACE_32                 190
#define IDB_NETIFACE_UNREACHABLE_16     191
#define IDB_NETIFACE_UNREACHABLE_32     192
#define IDB_NETIFACE_FAILED_16          193
#define IDB_NETIFACE_FAILED_32          194
#define IDB_NETIFACE_UNKNOWN_16         195
#define IDB_NETIFACE_UNKNOWN_32         196
#define IDD_ABOUTBOX                    200
#define IDD_OPEN_CLUSTER                201
#define IDD_DELETE_RESOURCES            202
#define IDD_MOVE_RESOURCES              203
#define IDD_MODIFY_PREFERRED_OWNERS     204
#define IDD_MODIFY_POSSIBLE_OWNERS      205
#define IDD_MODIFY_DEPENDENCIES         206
#define IDD_YESTOALL                    207
#define IDD_BROWSE_CLUSTERS             208
#define IDD_PP_CLUSTER_GENERAL          220
#define IDD_PP_CLUSTER_QUORUM           221
#define IDD_PP_CLUSTER_NET_PRIORITY     222
#define IDD_PP_NODE_GENERAL             230
#define IDD_PP_GROUP_GENERAL            240
#define IDD_PP_GROUP_FAILOVER           241
#define IDD_PP_GROUP_FAILBACK           242
#define IDD_PP_RES_GENERAL              250
#define IDD_PP_RES_DEPENDS              251
#define IDD_PP_RES_ADVANCED             252
#define IDD_PP_RESTYPE_GENERAL          260
#define IDD_PP_NETWORK_GENERAL          263
#define IDD_PP_NETIFACE_GENERAL         267
#define IDD_WIZ_GROUP_NAME              270
#define IDD_WIZ_PREFERRED_OWNERS        271
#define IDD_WIZ_RESOURCE_NAME           280
#define IDD_WIZ_POSSIBLE_OWNERS         281
#define IDD_WIZ_DEPENDENCIES            282
#define IDD_TRACE_SETTINGS              300
#define IDD_BARF_SETTINGS               301
#define IDD_BARF_ALL_SETTINGS           302
#define IDD_PP_NET_GENERAL              303
#define IDD_WAIT                        304
#define IDI_PROGRESS_0                  500
#define IDI_PROGRESS_1                  501
#define IDI_PROGRESS_2                  502
#define IDI_PROGRESS_3                  503
#define IDI_PROGRESS_4                  504
#define IDI_PROGRESS_5                  505
#define IDI_PROGRESS_6                  506
#define IDI_PROGRESS_7                  507
#define IDI_PROGRESS_8                  508
#define IDI_PROGRESS_9                  509
#define IDI_PROGRESS_10                 510
#define IDI_PROGRESS_11                 511
#define IDC_ABOUT_ICON                  1001
#define IDC_ABOUT_PRODUCT_TITLE         1002
#define IDC_ABOUT_FILE_TITLE            1003
#define IDC_ABOUT_VERSION               1004
#define IDC_ABOUT_COPYRIGHT             1005
#define IDC_ABOUT_WARNING_LINE          1006
#define IDC_ABOUT_WARNING               1007
#define IDC_OCD_ACTION_LABEL            1010
#define IDC_OCD_ACTION                  1011
#define IDC_OCD_NAME_LABEL              1012
#define IDC_OCD_NAME                    1013
#define IDC_OCD_BROWSE                  1014
#define IDC_DR_LABEL_1                  1020
#define IDC_DR_RESOURCES_LIST           1021
#define IDC_DR_LABEL_2                  1022
#define IDC_MR_LABEL_1                  1030
#define IDC_MR_RESOURCES_LIST           1031
#define IDC_MR_LABEL_2                  1032
#define IDC_LCP_NOTE                    1050
#define IDC_LCP_LEFT_LABEL              1051
#define IDC_LCP_LEFT_LIST               1052
#define IDC_LCP_ADD                     1053
#define IDC_LCP_REMOVE                  1054
#define IDC_LCP_RIGHT_LABEL             1055
#define IDC_LCP_RIGHT_LIST              1056
#define IDC_LCP_MOVE_UP                 1057
#define IDC_LCP_MOVE_DOWN               1058
#define IDC_LCP_PROPERTIES              1059
#define IDC_YTA_MESSAGE                 1070
#define IDC_YTA_QUESTION                1071
#define IDC_YTA_YESTOALL                1072
#define IDC_BC_CLUSTER_LABEL            1075
#define IDC_BC_CLUSTER                  1076
#define IDC_BC_LIST                     1077
#define IDC_W_PROGRESS                  1080
#define IDC_W_MESSAGE                   1081
#define IDC_PP_TITLE                    1100
#define IDC_PP_ICON                     1101
#define IDC_PP_CLUS_NAME_LABEL          1110
#define IDC_PP_CLUS_NAME                1111
#define IDC_PP_CLUS_DESC_LABEL          1112
#define IDC_PP_CLUS_DESC                1113
#define IDC_PP_CLUS_INFO_LINE           1115
#define IDC_PP_CLUS_VENDOR_ID           1116
#define IDC_PP_CLUS_VERSION             1117
#define IDC_PP_CLUS_QUORUM_RESOURCE_LABEL 1119
#define IDC_PP_CLUS_QUORUM_RESOURCE     1120
#define IDC_PP_CLUS_QUORUM_LOGGING_GROUP 1121
#define IDC_PP_CLUS_QUORUM_PARTITION_LABEL 1122
#define IDC_PP_CLUS_QUORUM_PARTITION    1123
#define IDC_PP_CLUS_QUORUM_ROOT_PATH    1124
#define IDC_PP_CLUS_QUORUM_ROOT_PATH_LABEL 1125
#define IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE_LABEL 1126
#define IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE 1127
#define IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE_LABEL2 1128
#define IDC_PP_CLUS_PRIORITY_LIST_LABEL 1129
#define IDC_PP_CLUS_PRIORITY_LIST       1130
#define IDC_PP_CLUS_PRIORITY_UP         1131
#define IDC_PP_CLUS_PRIORITY_DOWN       1132
#define IDC_PP_CLUS_PRIORITY_NOTE       1133
#define IDC_PP_CLUS_PRIORITY_PROPERTIES 1134
#define IDC_PP_NODE_NAME_LABEL          1150
#define IDC_PP_NODE_NAME                1151
#define IDC_PP_NODE_DESC_LABEL          1152
#define IDC_PP_NODE_DESC                1153
#define IDC_PP_NODE_CURRENT_STATE_LABEL 1154
#define IDC_PP_NODE_CURRENT_STATE       1155
#define IDC_PP_NODE_VERSION             1156
#define IDC_PP_NODE_CSD_VERSION         1157
#define IDC_PP_GROUP_NAME               1200
#define IDC_PP_GROUP_NAME_LABEL         1201
#define IDC_PP_GROUP_DESC_LABEL         1202
#define IDC_PP_GROUP_DESC               1203
#define IDC_PP_GROUP_PREF_OWNERS_LABEL  1204
#define IDC_PP_GROUP_PREF_OWNERS        1205
#define IDC_PP_GROUP_PREF_OWNERS_MODIFY 1206
#define IDC_PP_GROUP_INFO_LINE          1207
#define IDC_PP_GROUP_CURRENT_STATE_LABEL 1208
#define IDC_PP_GROUP_CURRENT_STATE      1209
#define IDC_PP_GROUP_CURRENT_NODE_LABEL 1210
#define IDC_PP_GROUP_CURRENT_NODE       1211
#define IDC_PP_GROUP_FAILOVER_THRESH_LABEL 1212
#define IDC_PP_GROUP_FAILOVER_THRESH    1213
#define IDC_PP_GROUP_FAILOVER_PERIOD_LABEL 1214
#define IDC_PP_GROUP_FAILOVER_PERIOD    1215
#define IDC_PP_GROUP_FAILOVER_PERIOD_LABEL2 1216
#define IDC_PP_GROUP_AUTOFB_PREVENT     1217
#define IDC_PP_GROUP_AUTOFB_GROUP       1218
#define IDC_PP_GROUP_AUTOFB_ALLOW       1219
#define IDC_PP_GROUP_FB_IMMED           1220
#define IDC_PP_GROUP_FB_WINDOW          1221
#define IDC_PP_GROUP_FBWIN_START        1222
#define IDC_PP_GROUP_FBWIN_START_SPIN   1223
#define IDC_PP_GROUP_FB_WINDOW_LABEL1   1224
#define IDC_PP_GROUP_FBWIN_END          1225
#define IDC_PP_GROUP_FBWIN_END_SPIN     1226
#define IDC_PP_GROUP_FB_WINDOW_LABEL2   1227
#define IDC_PP_RES_NAME_LABEL           1250
#define IDC_PP_RES_NAME                 1251
#define IDC_PP_RES_DESC_LABEL           1252
#define IDC_PP_RES_DESC                 1253
#define IDC_PP_RES_POSSIBLE_OWNERS_LABEL 1254
#define IDC_PP_RES_POSSIBLE_OWNERS      1255
#define IDC_PP_RES_POSSIBLE_OWNERS_MODIFY 1256
#define IDC_PP_RES_SEPARATE_MONITOR     1257
#define IDC_PP_RES_INFO_LINE            1258
#define IDC_PP_RES_RESOURCE_TYPE_LABEL  1259
#define IDC_PP_RES_RESOURCE_TYPE        1260
#define IDC_PP_RES_GROUP_LABEL          1261
#define IDC_PP_RES_GROUP                1262
#define IDC_PP_RES_CURRENT_STATE_LABEL  1263
#define IDC_PP_RES_CURRENT_STATE        1264
#define IDC_PP_RES_CURRENT_NODE_LABEL   1265
#define IDC_PP_RES_CURRENT_NODE         1266
#define IDC_PP_RES_NOTE                 1267
#define IDC_PP_RES_DEPENDS_LIST_LABEL   1268
#define IDC_PP_RES_DEPENDS_LIST         1269
#define IDC_PP_RES_MODIFY               1270
#define IDC_PP_RES_PROPERTIES           1271
#define IDC_PP_RES_DONT_RESTART         1272
#define IDC_PP_RES_RESTART_GROUP        1273
#define IDC_PP_RES_RESTART              1274
#define IDC_PP_RES_AFFECT_THE_GROUP     1275
#define IDC_PP_RES_RESTART_THRESH_LABEL 1276
#define IDC_PP_RES_RESTART_THRESHOLD    1277
#define IDC_PP_RES_RESTART_PERIOD_LABEL 1278
#define IDC_PP_RES_RESTART_PERIOD       1279
#define IDC_PP_RES_RESTART_PERIOD_LABEL2 1280
#define IDC_PP_RES_LOOKS_ALIVE_GROUP    1281
#define IDC_PP_RES_DEFAULT_LOOKS_ALIVE  1282
#define IDC_PP_RES_SPECIFY_LOOKS_ALIVE  1283
#define IDC_PP_RES_LOOKS_ALIVE          1284
#define IDC_PP_RES_SPECIFY_LOOKS_ALIVE_LABEL 1285
#define IDC_PP_RES_IS_ALIVE_GROUP       1286
#define IDC_PP_RES_DEFAULT_IS_ALIVE     1287
#define IDC_PP_RES_SPECIFY_IS_ALIVE     1288
#define IDC_PP_RES_IS_ALIVE             1289
#define IDC_PP_RES_IS_ALIVE_LABEL       1290
#define IDC_PP_RES_PENDING_TIMEOUT_LABEL 1291
#define IDC_PP_RES_PENDING_TIMEOUT      1292
#define IDC_PP_RES_PENDING_TIMEOUT_LABEL2 1293
#define IDC_PP_RESTYPE_NAME_LABEL       1350
#define IDC_PP_RESTYPE_NAME             1351
#define IDC_PP_RESTYPE_DISPLAY_NAME_LABEL 1352
#define IDC_PP_RESTYPE_DISPLAY_NAME     1353
#define IDC_PP_RESTYPE_DESC_LABEL       1354
#define IDC_PP_RESTYPE_DESC             1355
#define IDC_PP_RESTYPE_POLLINT_GROUP    1356
#define IDC_PP_RESTYPE_LOOKS_ALIVE_LABEL 1357
#define IDC_PP_RESTYPE_LOOKS_ALIVE      1358
#define IDC_PP_RESTYPE_LOOKS_ALIVE_LABEL2 1359
#define IDC_PP_RESTYPE_IS_ALIVE_LABEL   1360
#define IDC_PP_RESTYPE_IS_ALIVE         1361
#define IDC_PP_RESTYPE_IS_ALIVE_LABEL2  1362
#define IDC_PP_RESTYPE_POSSIBLE_OWNERS_LABEL 1363
#define IDC_PP_RESTYPE_POSSIBLE_OWNERS  1364
#define IDC_PP_RESTYPE_RESDLL_LABEL     1365
#define IDC_PP_RESTYPE_RESDLL           1366
#define IDC_PP_RESTYPE_QUORUM_CAPABLE   1367
#define IDC_PP_RESTYPE_QUORUM_CAPABLE_LABEL 1368
#define IDC_PP_NET_NAME_LABEL           1370
#define IDC_PP_NET_NAME                 1371
#define IDC_PP_NET_DESC_LABEL           1372
#define IDC_PP_NET_DESC                 1373
#define IDC_PP_NET_ROLE_ENABLE_NETWORK  1374
#define IDC_PP_NET_ROLE_ALL_COMM        1375
#define IDC_PP_NET_ROLE_INTERNAL_ONLY   1376
#define IDC_PP_NET_ROLE_CLIENT_ONLY     1377
#define IDC_PP_NET_ADDRESS_LABEL        1378
#define IDC_PP_NET_ADDRESS              1379
#define IDC_PP_NET_ADDRESS_MASK_LABEL   1380
#define IDC_PP_NET_ADDRESS_MASK         1381
#define IDC_PP_NET_PRIORITY_LABEL       1382
#define IDC_PP_NET_PRIORITY             1383
#define IDC_PP_NET_CURRENT_STATE_LABEL  1384
#define IDC_PP_NET_CURRENT_STATE        1385
#define IDC_PP_NETIFACE_NODE_LABEL      1386
#define IDC_PP_NETIFACE_NODE            1387
#define IDC_PP_NETIFACE_NETWORK_LABEL   1388
#define IDC_PP_NETIFACE_NETWORK         1389
#define IDC_PP_NETIFACE_DESC_LABEL      1390
#define IDC_PP_NETIFACE_DESC            1391
#define IDC_PP_NETIFACE_ADAPTER_LABEL   1392
#define IDC_PP_NETIFACE_ADAPTER         1393
#define IDC_PP_NETIFACE_ADDRESS_LABEL   1394
#define IDC_PP_NETIFACE_ADDRESS         1395
#define IDC_PP_NETIFACE_NAME_LABEL      1396
#define IDC_PP_NETIFACE_NAME            1397
#define IDC_PP_NETIFACE_CURRENT_STATE_LABEL 1398
#define IDC_PP_NETIFACE_CURRENT_STATE   1399
#define IDC_WIZ_GRAPHIC                 1400
#define IDC_WIZ_GROUP_NAME_LABEL        1410
#define IDC_WIZ_GROUP_NAME              1411
#define IDC_WIZ_GROUP_DESC_LABEL        1412
#define IDC_WIZ_GROUP_DESC              1413
#define IDC_WIZ_GROUP_WIZ_DESC          1414
#define IDC_WIZ_GROUP_CLICK_NEXT        1415
#define IDC_WIZ_RES_NAME_LABEL          1450
#define IDC_WIZ_RES_NAME                1451
#define IDC_WIZ_RES_DESC_LABEL          1452
#define IDC_WIZ_RES_DESC                1453
#define IDC_WIZ_RES_RESTYPE_LABEL       1454
#define IDC_WIZ_RES_RESTYPE             1455
#define IDC_WIZ_RES_GROUP_LABEL         1456
#define IDC_WIZ_RES_GROUP               1457
#define IDC_WIZ_RES_SEPARATE_MONITOR    1458
#define IDC_WIZ_RES_CLICK_NEXT          1459
#define IDC_TS_LISTBOX                  2000
#define IDC_TS_TAGS_TO_DISPLAY_LABEL    2001
#define IDC_TS_TAGS_TO_DISPLAY_CB       2002
#define IDC_TS_TRACE_TO_LABEL           2003
#define IDC_TS_TRACE_TO_DEBUG           2004
#define IDC_TS_TRACE_DEBUG_BREAK        2005
#define IDC_TS_TRACE_TO_COM2            2006
#define IDC_TS_TRACE_TO_FILE            2007
#define IDC_TS_FILE                     2008
#define IDC_TS_SELECT_ALL               2009
#define IDC_TS_DEFAULT                  2010
#define IDC_BS_RESOURCE_LABEL           2020
#define IDC_BS_CURRENT_FAIL_AT_LABEL    2021
#define IDC_BS_CURRENT_COUNT_LABEL      2022
#define IDC_BS_CATEGORIES_LIST          2023
#define IDC_BS_FAIL_AT_LABEL            2024
#define IDC_BS_FAIL_AT                  2025
#define IDC_BS_CONTINUOUS               2026
#define IDC_BS_DISABLE                  2027
#define IDC_BS_GLOBAL_ENABLE            2028
#define IDC_BS_RESET_CURRENT_COUNT      2029
#define IDC_BS_RESET_ALL_COUNTS         2030
#define IDC_BAS_MAIN_LABEL              2040
#define IDC_BAS_HWND_LABEL              2041
#define IDC_BAS_HWND                    2042
#define IDC_BAS_WM_LABEL                2043
#define IDC_BAS_WM                      2044
#define IDC_BAS_WPARAM_LABEL            2045
#define IDC_BAS_WPARAM                  2046
#define IDC_BAS_LPARAM_LABEL            2047
#define IDC_BAS_LPARAM                  2049
#define IDC_BAS_MENU_ITEM               2050
#define IDC_PP_NET_ROLE_CAPTION         3017
#define ID_FILE_NEW_GROUP               32772
#define ID_FILE_NEW_RESOURCE            32773
#define ID_FILE_NEW_RESOURCE_TYPE       32774
#define ID_FILE_NEW_NODE                32775
#define ID_FILE_NEW_CLUSTER             32776
#define ID_FILE_CONFIG_APP              32777
#define ID_FILE_DELETE                  32780
#define ID_FILE_RENAME                  32781
#define ID_FILE_PROPERTIES              32782
#define ID_FILE_PAUSE_NODE              32783
#define ID_FILE_RESUME_NODE             32784
#define ID_FILE_EVICT_NODE              32785
#define ID_FILE_START_SERVICE           32786
#define ID_FILE_STOP_SERVICE            32787
#define ID_FILE_BRING_ONLINE            32788
#define ID_FILE_TAKE_OFFLINE            32789
#define ID_FILE_MOVE_GROUP              32790
#define ID_FILE_MOVE_GROUP_1            32791
#define ID_FILE_MOVE_GROUP_2            32792
#define ID_FILE_MOVE_GROUP_3            32793
#define ID_FILE_MOVE_GROUP_4            32794
#define ID_FILE_MOVE_GROUP_5            32795
#define ID_FILE_MOVE_GROUP_6            32796
#define ID_FILE_MOVE_GROUP_7            32797
#define ID_FILE_MOVE_GROUP_8            32798
#define ID_FILE_MOVE_GROUP_9            32799
#define ID_FILE_MOVE_GROUP_10           32800
#define ID_FILE_MOVE_GROUP_11           32801
#define ID_FILE_MOVE_GROUP_12           32802
#define ID_FILE_MOVE_GROUP_13           32803
#define ID_FILE_MOVE_GROUP_14           32804
#define ID_FILE_MOVE_GROUP_15           32805
#define ID_FILE_MOVE_GROUP_16           32806
#define ID_FILE_MOVE_RESOURCE_1         32807
#define ID_FILE_MOVE_RESOURCE_2         32808
#define ID_FILE_MOVE_RESOURCE_3         32809
#define ID_FILE_MOVE_RESOURCE_4         32810
#define ID_FILE_MOVE_RESOURCE_5         32811
#define ID_FILE_MOVE_RESOURCE_6         32812
#define ID_FILE_MOVE_RESOURCE_7         32813
#define ID_FILE_MOVE_RESOURCE_8         32814
#define ID_FILE_MOVE_RESOURCE_9         32815
#define ID_FILE_MOVE_RESOURCE_10        32816
#define ID_FILE_MOVE_RESOURCE_11        32817
#define ID_FILE_MOVE_RESOURCE_12        32818
#define ID_FILE_MOVE_RESOURCE_13        32819
#define ID_FILE_MOVE_RESOURCE_14        32820
#define ID_FILE_MOVE_RESOURCE_15        32821
#define ID_FILE_MOVE_RESOURCE_16        32822
#define ID_FILE_MOVE_RESOURCE_17        32823
#define ID_FILE_MOVE_RESOURCE_18        32824
#define ID_FILE_MOVE_RESOURCE_19        32825
#define ID_FILE_MOVE_RESOURCE_20        32826
#define ID_FILE_INITIATE_FAILURE        32827
#define ID_EDIT_INVERT_SELECTION        32828
#define ID_VIEW_LARGE_ICONS             32829
#define ID_VIEW_SMALL_ICONS             32830
#undef ID_VIEW_LIST
#undef ID_VIEW_DETAILS
#define ID_VIEW_LIST                    32831
#define ID_VIEW_DETAILS                 32832
#define ID_VIEW_REFRESH                 32833
#define ID_VIEW_OPTIONS                 32834
#define ID_WINDOW_CLOSE_ALL             32835
#define ID_DEBUG_TRACE_SETTINGS         32836
#define ID_OPEN_ITEM                    32837
#define ID_DEBUG_BARF_SETTINGS          32838
#define ID_DEBUG_BARF_ALL               32839
#define IDS_OPEN_CLUSTER_ERROR          40500
#define IDS_OPEN_NODE_ERROR             40501
#define IDS_OPEN_GROUP_ERROR            40502
#define IDS_OPEN_RESOURCE_ERROR         40503
#define IDS_OPEN_NETWORK_ERROR          40504
#define IDS_OPEN_NETIFACE_ERROR         40505
#define IDS_GET_CLUSTER_KEY_ERROR       40506
#define IDS_GET_NODE_KEY_ERROR          40507
#define IDS_GET_GROUP_KEY_ERROR         40508
#define IDS_GET_RESOURCE_KEY_ERROR      40509
#define IDS_GET_RESTYPE_KEY_ERROR       40510
#define IDS_GET_NETWORK_KEY_ERROR       40511
#define IDS_GET_NETIFACE_KEY_ERROR      40512
#define IDS_CLUSTER_NOTIF_REG_ERROR     40513
#define IDS_REG_NOTIF_REG_ERROR         40514
#define IDS_NODE_NOTIF_REG_ERROR        40515
#define IDS_GROUP_NOTIF_REG_ERROR       40516
#define IDS_RES_NOTIF_REG_ERROR         40517
#define IDS_RESTYPE_NOTIF_REG_ERROR     40518
#define IDS_NETWORK_NOTIF_REG_ERROR     40519
#define IDS_NETIFACE_NOTIF_REG_ERROR    40520
#define IDS_READ_CLUSTER_PROPS_ERROR    40521
#define IDS_READ_NODE_PROPS_ERROR       40522
#define IDS_READ_GROUP_PROPS_ERROR      40523
#define IDS_READ_RESOURCE_PROPS_ERROR   40524
#define IDS_READ_RESOURCE_TYPE_PROPS_ERROR 40525
#define IDS_READ_NETWORK_PROPS_ERROR    40526
#define IDS_READ_NETIFACE_PROPS_ERROR   40527
#define IDS_OPEN_CLUSTER_ENUM_ERROR     40528
#define IDS_ENUM_CLUSTER_ERROR          40529
#define IDS_ENUM_PREFERRED_OWNERS_ERROR 40530
#define IDS_ENUM_CONTAINS_ERROR         40531
#define IDS_ENUM_POSSIBLE_OWNERS_ERROR  40532
#define IDS_ENUM_DEPENDENCIES_ERROR     40533
#define IDS_ENUM_PROVIDES_FOR_ERROR     40534
#define IDS_ENUM_NETWORK_INTERFACES_ERROR 40535
#define IDS_ENUM_NETWORK_PRIORITY_ERROR 40536
#define IDS_CREATE_GROUP_ERROR          40537
#define IDS_CREATE_RESOURCE_ERROR       40538
#define IDS_DELETE_GROUP_ERROR          40539
#define IDS_DELETE_RESOURCE_ERROR       40540
#define IDS_RENAME_CLUSTER_ERROR        40541
#define IDS_RENAME_RESOURCE_ERROR       40542
#define IDS_RENAME_GROUP_ERROR          40543
#define IDS_RENAME_NETWORK_ERROR        40544
#define IDS_START_CLUSTER_SERVICE_ERROR 40545
#define IDS_STOP_CLUSTER_SERVICE_ERROR  40546
#define IDS_CANNOT_START_CLUSTER_SERVICE 40547
#define IDS_SET_QUORUM_RESOURCE_ERROR   40548
#define IDS_PAUSE_NODE_ERROR            40549
#define IDS_RESUME_NODE_ERROR           40550
#define IDS_EVICT_NODE_ERROR            40551
#define IDS_BRING_GROUP_ONLINE_ERROR    40552
#define IDS_TAKE_GROUP_OFFLINE_ERROR    40553
#define IDS_MOVE_GROUP_ERROR            40554
#define IDS_BRING_RESOURCE_ONLINE_ERROR 40555
#define IDS_TAKE_RESOURCE_OFFLINE_ERROR 40556
#define IDS_INIT_RESOURCE_FAILURE_ERROR 40557
#define IDS_MOVE_RESOURCE_ERROR         40558
#define IDS_ADD_RES_OWNER_ERROR         40559
#define IDS_REMOVE_RES_OWNER_ERROR      40560
#define IDS_ADD_DEPENDENCY_ERROR        40561
#define IDS_REMOVE_DEPENDENCY_ERROR     40562
#define IDS_LOAD_EXT_DLL_ERROR          40563
#define IDS_EXT_GET_ENTRY_POINT_ERROR   40564
#define IDS_EXT_GET_CLASS_FACTORY_ERROR 40565
#define IDS_EXT_CREATE_INSTANCE_ERROR   40566
#define IDS_EXT_GET_INTERFACE_ERROR     40567
#define IDS_EXT_INITIALIZE_ERROR        40568
#define IDS_EXT_ADD_PAGES_ERROR         40569
#define IDS_EXT_INVOKE_COMMAND_ERROR    40570
#define IDS_EXT_QUERY_CONTEXT_MENU_ERROR 40571
#define IDS_CREATE_PARAMS_KEY_ERROR     40572
#define IDS_SAME_START_AND_END          40573
#define IDS_EMPTY_RIGHT_LIST            40574
#define IDS_NO_POSSIBLE_OWNERS_QUERY    40576
#define IDS_NO_POSSIBLE_OWNERS          40577
#define IDS_SET_GROUP_NODE_LIST_ERROR   40578
#define IDS_NO_AVAILABLE_NODES_FOR_GROUP 40579
#define IDS_CANT_MOVE_RES_DEPEND_ERROR  40580
#define IDS_NOACLEDITOR                 40581
#define IDS_CLSIDFROMSTRING_ERROR       40582
#define IDS_INSERT_MENU_ERROR           40583
#define IDS_DELETE_RESOURCE_ERROR_OFFLINE_PENDING 40584
#define IDS_CANT_MOVE_GROUP_TO_SAME_NODE 40585
#define IDS_CANT_MOVE_GROUP_TO_DOWN_NODE 40586
#define IDS_CANT_MOVE_RES_TO_GROUP      40587
#define IDS_REQUIRED_DEPENDENCY_NOT_FOUND 40588
#define IDS_APPLY_PARAM_CHANGES_ERROR   40589
#define IDS_INVALID_CLUSTER_NAME        40590
#define IDS_INVALID_CLUSTER_NAME_TOO_LONG 40591
#define IDS_INVALID_CLUSTER_NAME_INVALID_CHARS 40592
#define IDS_INVALID_CLUSTER_NAME_IN_USE 40593
#define IDS_DISPLAY_NAME_NOT_CHANGED    40594
#define IDS_LOCAL_ACCOUNTS_SPECIFIED    40595
#define IDS_NO_ACCESS_GRANTED           40596
#define IDS_QUORUM_RES_CANT_HAVE_DEPS   40597
#define IDS_RES_NOT_OWNED_BY_POSSIBLE_OWNER 40598
#define IDS_CANT_DELETE_CORE_RESOURCE   40599
#define IDS_SET_NET_PRIORITY_ERROR      40600
#define IDS_ERROR_VALIDATING_NETWORK_NAME 40601
#define IDS_INVALID_NETWORK_CONNECTION_NAME 40602
#define IDS_ERROR_MSG_ID                40609
#define IDS_CREATED_GROUP               40610
#define IDS_CREATED_RESOURCE            40611
#define IDS_CLUSTER_NOT_AVAILABLE       40612
#define IDS_VERIFY_DELETE_RESOURCE      40613
#define IDS_VERIFY_DELETE_GROUP         40614
#define IDS_VERIFY_EVICT_NODE           40616
#define IDS_START_CLUSTER_SERVICE       40617
#define IDS_GET_DISK_INFO_ERROR         40618
#define IDS_VERIFY_STOP_CLUSTER_SERVICE 40620
#define IDS_VERIFY_MOVE_GROUP           40621
#define IDS_VERIFY_MOVE_RESOURCE        40622
#define IDS_RESTART_CLUSTER_NAME        40623
#define IDS_CHANGE_RES_TYPE_NAME_EFFECT 40624
#define IDS_TAKE_CLUSTER_NAME_OFFLINE_QUERY 40625
#define IDS_GET_QUORUM_DEVICES_ERROR    40626
#define IDS_CREATE_CLUSCFGWIZ_OBJ_ERROR 40627
#define IDS_CREATE_CLUSTER_ERROR        40628
#define IDS_ADD_NODES_TO_CLUSTER_ERROR  40629
#define IDS_GET_RESOURCE_STATE_ERROR    40630
#define IDS_INVALID_CLUSTER_NAME_INVALID_DNS_CHARS 40631

#define IDS_WINDOW_TITLE_FORMAT         40640
#define IDS_PROPSHEET_CAPTION           40641
#define IDS_PROPSHEET_CAPTION_NEW       40642
#define IDS_OFFLINE                     40643
#define IDS_OFFLINE_PENDING             40644
#define IDS_ONLINE                      40645
#define IDS_ONLINE_PENDING              40646
#define IDS_PARTIAL_ONLINE              40647
#define IDS_FAILED                      40648
#define IDS_INITIALIZING                40649
#define IDS_PAUSED                      40650
#define IDS_DOWN                        40651
#define IDS_JOINING                     40652
#define IDS_UP                          40653
#define IDS_UNAVAILABLE                 40654
#define IDS_PARTITIONED                 40655
#define IDS_UNREACHABLE                 40656
#define IDS_UNKNOWN                     40657
#define IDS_PENDING                     40658
#define IDS_CLIENT_AND_CLUSTER          40660
#define IDS_CLIENT_ONLY                 40661
#define IDS_CLUSTER_ONLY                40662
#define IDS_DONT_USE                    40663
#define IDS_YES                         40664
#define IDS_NO                          40665
#define IDS_ABOUT_WARNING               40666
#define IDS_NEW_GROUP_TITLE             40667
#define IDS_NEW_RESOURCE_TITLE          40668
#define IDS_MENU_PROPERTIES             40670
#define IDS_MENU_WHATS_THIS             40671
#define IDS_SB_OPENING_CONNECTION       40680
#define IDS_SB_STARTING_CLUSTER_SERVICE 40681
#define IDS_SB_STARTING_SERVICE         40682
#define IDS_SB_STOPPING_SERVICE         40683
#define IDS_SB_ADDING_NODE              40684
#define IDS_SB_READING_NODE             40685
#define IDS_SB_ADDING_GROUP             40686
#define IDS_SB_READING_GROUP            40687
#define IDS_SB_ADDING_RESOURCE          40688
#define IDS_SB_READING_RESOURCE         40689
#define IDS_SB_ADDING_RESTYPE           40690
#define IDS_SB_READING_RESTYPE          40691
#define IDS_SB_ADDING_NETWORK           40692
#define IDS_SB_READING_NETWORK          40693
#define IDS_SB_ADDING_NETIFACE          40694
#define IDS_SB_READING_NETIFACE         40695
#define IDS_TREEITEM_NODES              40700
#define IDS_TREEITEM_GROUPS             40701
#define IDS_TREEITEM_RESOURCES          40703
#define IDS_TREEITEM_RESTYPES           40704
#define IDS_TREEITEM_NETWORKS           40705
#define IDS_TREEITEM_NETIFACES          40706
#define IDS_TREEITEM_ACTIVEGROUPS       40707
#define IDS_TREEITEM_ACTIVERESOURCES    40708
#define IDS_TREEITEM_PHYSDEVS           40709
#define IDS_TREEITEM_CLUSTER_CONFIG     40710
#define IDS_ITEMTYPE_CLUSTER            40720
#define IDS_ITEMTYPE_CONTAINER          40721
#define IDS_ITEMTYPE_NODE               40722
#define IDS_ITEMTYPE_GROUP              40723
#define IDS_ITEMTYPE_RESOURCE           40724
#define IDS_ITEMTYPE_RESTYPE            40725
#define IDS_ITEMTYPE_NETWORK            40726
#define IDS_ITEMTYPE_NETIFACE           40727
#define IDS_COLTEXT_NAME                40730
#define IDS_COLTEXT_TYPE                40731
#define IDS_COLTEXT_DESCRIPTION         40732
#define IDS_COLTEXT_OWNER               40733
#define IDS_COLTEXT_RESTYPE             40734
#define IDS_COLTEXT_RESDLL              40735
#define IDS_COLTEXT_EXTDLL              40736
#define IDS_COLTEXT_GROUP               40737
#define IDS_COLTEXT_RESOURCE            40738
#define IDS_COLTEXT_STATE               40739
#define IDS_COLTEXT_DISPLAY_NAME        40740
#define IDS_COLTEXT_ROLE                40741
#define IDS_COLTEXT_NODE                40742
#define IDS_COLTEXT_NETWORK             40743
#define IDS_COLTEXT_ADAPTER             40744
#define IDS_COLTEXT_ADDRESS             40745
#define IDS_COLTEXT_MASK                40746
#define IDS_RESCLASS_UNKNOWN            40750
#define IDS_RESCLASS_STORAGE            40751
#define IDS_CMDLINE_NORECONNECT         40800
#define IDS_CMDLINE_NORECON             40801
#define IDS_CMDLINE_NORPCAUTH           40802
#define IDS_REGKEY_COMPANY              40850
#define IDS_VERSION_NUMBER_FORMAT       40851
#define IDS_OP_VERSION_NUMBER_FORMAT    40852
#define IDS_ACLEDIT_PERM_GEN_NO_ACCESS  40860
#define IDS_ACLEDIT_PERM_GEN_READ       40861
#define IDS_ACLEDIT_PERM_GEN_MODIFY     40862
#define IDS_ACLEDIT_PERM_GEN_ALL        40863
#define IDS_ACLEDIT_TITLE               40864
#define IDS_MENUNAME_DEFAULT_MOVE_GROUP 40870
#define IDS_OCD_CREATE_CLUSTER          40880
#define IDS_OCD_ADD_NODES               40881
#define IDS_OCD_OPEN_CONNECTION         40882
#define IDS_WAIT_TITLE                  40890
#define IDS_WAIT_FOR_OFFLINE_TITLE      40891
#define IDS_WAIT_FOR_OFFLINE_MESSAGE    40892
#define IDS_WAIT_FOR_ONLINE_TITLE       40893
#define IDS_WAIT_FOR_ONLINE_MESSAGE     40894
#define IDS_EVICT_NODE_ERROR_UNAVAILABLE 40895
#define IDS_SELECT_QUORUM_RESOURCE_ERROR 40896
#define IDS_ONLINE_QUORUM_RESOURCE_PROMPT 40897

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        352
#define _APS_NEXT_COMMAND_VALUE         32851
#define _APS_NEXT_CONTROL_VALUE         3018
#define _APS_NEXT_SYMED_VALUE           114
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\olcpair.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		OLCPair.cpp
//
//	Abstract:
//		Implementation of the COrderedListCtrlPair class.
//
//	Author:
//		David Potter (davidp)	August 8, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "OLCPair.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COrderedListCtrlPair
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(COrderedListCtrlPair, CListCtrlPair)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(COrderedListCtrlPair, CListCtrlPair)
	//{{AFX_MSG_MAP(COrderedListCtrlPair)
	//}}AFX_MSG_MAP
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LCP_RIGHT_LIST, OnItemChangedRightList)
	ON_BN_CLICKED(IDC_LCP_MOVE_UP, OnClickedMoveUp)
	ON_BN_CLICKED(IDC_LCP_MOVE_DOWN, OnClickedMoveDown)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	COrderedListCtrlPair::COrderedListCtrlPair
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
COrderedListCtrlPair::COrderedListCtrlPair(void)
{
	ModifyStyle(0, LCPS_ORDERED);

}  //*** COrderedListCtrlPair::COrderedListCtrlPair()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	COrderedListCtrlPair::COrderedListCtrlPair
//
//	Routine Description:
//		Cconstructor.
//
//	Arguments:
//		pdlg			[IN OUT] Dialog to which controls belong.
//		plpobjRight		[IN OUT] List for the right list control.
//		plpobjLeft		[IN] List for the left list control.
//		dwStyle			[IN] Style:
//							LCPS_SHOW_IMAGES	Show images to left of items.
//							LCPS_ALLOW_EMPTY	Allow right list to be empty.
//							LCPS_ORDERED		Ordered right list.
//		pfnGetColumn	[IN] Function pointer for retrieving columns.
//		pfnDisplayProps	[IN] Function pointer for displaying properties.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
COrderedListCtrlPair::COrderedListCtrlPair(
	IN OUT CDialog *			pdlg,
	IN OUT CClusterItemList *	plpobjRight,
	IN const CClusterItemList *	plpobjLeft,
	IN DWORD					dwStyle,
	IN PFNLCPGETCOLUMN			pfnGetColumn,
	IN PFNLCPDISPPROPS			pfnDisplayProps
	)
	: CListCtrlPair(
			pdlg,
			plpobjRight,
			plpobjLeft,
			dwStyle,
			pfnGetColumn,
			pfnDisplayProps
			)
{
}  //*** COrderedListCtrlPair::COrderedListCtrlPair()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	COrderedListCtrlPair::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void COrderedListCtrlPair::DoDataExchange(CDataExchange * pDX)
{
	CListCtrlPair::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_LCP_MOVE_UP, m_pbMoveUp);
	DDX_Control(pDX, IDC_LCP_MOVE_DOWN, m_pbMoveDown);

}  //*** COrderedListCtrlPair::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	COrderedListCtrlPair::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Focus needs to be set.
//		FALSE	Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL COrderedListCtrlPair::OnInitDialog(void)
{
	// Call the base class method.
	CListCtrlPair::OnInitDialog();

	// If this is an ordered list, show the Move buttons.
	// Otherwise, hide them.
	SetUpDownState();

	// If this is an ordered list, don't sort items in the right list.
	if (BOrdered())
		m_lcRight.ModifyStyle(LVS_SORTASCENDING, 0, 0);
	else
		m_lcRight.ModifyStyle(0, LVS_SORTASCENDING, 0);

	// Reload the list control.
	Pdlg()->UpdateData(FALSE /*bSaveAndValidate*/);

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** COrderedListCtrlPair::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	COrderedListCtrlPair::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL COrderedListCtrlPair::OnSetActive(void)
{
	UINT	nSelCount;

	nSelCount = m_lcRight.GetSelectedCount();
	if (BPropertiesButton())
		m_pbProperties.EnableWindow(nSelCount == 1);

	// Enable or disable the other buttons.
	if (!BReadOnly())
		SetUpDownState();

	return CListCtrlPair::OnSetActive();

}  //*** COrderedListCtrlPair::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	COrderedListCtrlPair::OnItemChangedRightList
//
//	Routine Description:
//		Handler method for the LVN_ITEMCHANGED message in the right list.
//
//	Arguments:
//		pNMHDR		[IN OUT] WM_NOTIFY structure.
//		pResult		[OUT] LRESULT in which to return the result of this operation.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void COrderedListCtrlPair::OnItemChangedRightList(NMHDR * pNMHDR, LRESULT * pResult)
{
	NM_LISTVIEW *	pNMListView = (NM_LISTVIEW *) pNMHDR;

	// Call the base class method.
	CListCtrlPair::OnItemChangedRightList(pNMHDR, pResult);

	if (BOrdered())
	{
		// If the selection changed, enable/disable the Remove button.
		if ((pNMListView->uChanged & LVIF_STATE)
				&& ((pNMListView->uOldState & LVIS_SELECTED)
						|| (pNMListView->uNewState & LVIS_SELECTED)))
		{
			SetUpDownState();
		}  // if:  selection changed
	}  // if:  list is ordered

	*pResult = 0;

}  //*** COrderedListCtrlPair::OnItemChangedRightList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	COrderedListCtrlPair::OnClickedMoveUp
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the Move Up button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void COrderedListCtrlPair::OnClickedMoveUp(void)
{
	int				nItem;
	CClusterItem *	pci;

	// Find the index of the selected item.
	nItem = m_lcRight.GetNextItem(-1, LVNI_SELECTED);
	ASSERT(nItem != -1);

	// Get the item pointer.
	pci = (CClusterItem *) m_lcRight.GetItemData(nItem);
	ASSERT_VALID(pci);

	// Remove the selected item from the list and add it back in.
	{
		POSITION	posRemove;
		POSITION	posAdd;

		// Find the position of the item to be removed and the item before
		// which the item is to be inserted.
		posRemove = LpobjRight().FindIndex(nItem);
		ASSERT(posRemove != NULL);
		ASSERT(posRemove == LpobjRight().Find(pci));
		posAdd = LpobjRight().FindIndex(nItem - 1);
		ASSERT(posAdd != NULL);
		VERIFY(LpobjRight().InsertBefore(posAdd, pci) != NULL);
		LpobjRight().RemoveAt(posRemove);
	}  // Remove the selected item from the list and add it back in

	// Remove the selected item from the list control and add it back in.
	VERIFY(m_lcRight.DeleteItem(nItem));
	NInsertItemInListCtrl(nItem - 1, pci, m_lcRight);
	m_lcRight.SetItemState(
		nItem - 1,
		LVIS_SELECTED | LVIS_FOCUSED,
		LVIS_SELECTED | LVIS_FOCUSED
		);
	m_lcRight.EnsureVisible(nItem - 1, FALSE /*bPartialOK*/);
	m_lcRight.SetFocus();

}  //*** COrderedListCtrlPair::OnClickedMoveUp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	COrderedListCtrlPair::OnClickedMoveDown
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the Move Down button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void COrderedListCtrlPair::OnClickedMoveDown(void)
{
	int				nItem;
	CClusterItem *	pci;

	// Find the index of the selected item.
	nItem = m_lcRight.GetNextItem(-1, LVNI_SELECTED);
	ASSERT(nItem != -1);

	// Get the item pointer.
	pci = (CClusterItem *) m_lcRight.GetItemData(nItem);
	ASSERT_VALID(pci);

	// Remove the selected item from the list and add it back in.
	{
		POSITION	posRemove;
		POSITION	posAdd;

		// Find the position of the item to be removed and the item after
		// which the item is to be inserted.
		posRemove = LpobjRight().FindIndex(nItem);
		ASSERT(posRemove != NULL);
		ASSERT(posRemove == LpobjRight().Find(pci));
		posAdd = LpobjRight().FindIndex(nItem + 1);
		ASSERT(posAdd != NULL);
		VERIFY(LpobjRight().InsertAfter(posAdd, pci) != NULL);
		LpobjRight().RemoveAt(posRemove);
	}  // Remove the selected item from the list and add it back in

	// Remove the selected item from the list control and add it back in.
	VERIFY(m_lcRight.DeleteItem(nItem));
	NInsertItemInListCtrl(nItem + 1, pci, m_lcRight);
	m_lcRight.SetItemState(
		nItem + 1,
		LVIS_SELECTED | LVIS_FOCUSED,
		LVIS_SELECTED | LVIS_FOCUSED
		);
	m_lcRight.EnsureVisible(nItem + 1, FALSE /*bPartialOK*/);
	m_lcRight.SetFocus();

}  //*** COrderedListCtrlPair::OnClickedMoveDown()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	COrderedListCtrlPair::SetUpDownState
//
//	Routine Description:
//		Set the state of the Up/Down buttons based on the selection.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void COrderedListCtrlPair::SetUpDownState(void)
{
	BOOL	bEnableUp;
	BOOL	bEnableDown;

	if (   BOrdered()
		&& !BReadOnly()
		&& (m_lcRight.GetSelectedCount() == 1))
	{
		int		nItem;

		bEnableUp = TRUE;
		bEnableDown = TRUE;

		// Find the index of the selected item.
		nItem = m_lcRight.GetNextItem(-1, LVNI_SELECTED);
		ASSERT(nItem != -1);

		// If the first item is selected, can't move up.
		if (nItem == 0)
			bEnableUp = FALSE;

		// If the last item is selected, can't move down.
		if (nItem == m_lcRight.GetItemCount() - 1)
			bEnableDown = FALSE;
	}  // if:  only one item selected
	else
	{
		bEnableUp = FALSE;
		bEnableDown = FALSE;
	}  // else:  zero or more than one item selected

	m_pbMoveUp.EnableWindow(bEnableUp);
	m_pbMoveDown.EnableWindow(bEnableDown);

}  //*** COrderedListCtrlPair::SetUpDownState()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\openclus.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      OpenClus.cpp
//
//  Abstract:
//      Implementation of the COpenClusterDialog class.
//
//  Author:
//      David Potter (davidp)   May 1, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "OpenClus.h"
#include "ClusMru.h"
#include "DDxDDv.h"
#include "HelpData.h"
#include <lmcons.h>
#include <lmserver.h>
#include <lmapibuf.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COpenClusterDialog dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(COpenClusterDialog, CBaseDialog)
    //{{AFX_MSG_MAP(COpenClusterDialog)
    ON_BN_CLICKED(IDC_OCD_BROWSE, OnBrowse)
    ON_CBN_SELCHANGE(IDC_OCD_ACTION, OnSelChangeAction)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  COpenClusterDialog::COpenClusterDialog
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pParentWnd          [IN OUT] Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
COpenClusterDialog::COpenClusterDialog(CWnd * pParentWnd /*=NULL*/)
    : CBaseDialog(IDD, g_aHelpIDs_IDD_OPEN_CLUSTER, pParentWnd)
{
    CClusterAdminApp *      papp    = GetClusterAdminApp();
    CRecentClusterList *    prcl    = papp->PrclRecentClusterList();

    //{{AFX_DATA_INIT(COpenClusterDialog)
    m_strName = _T("");
    //}}AFX_DATA_INIT

    m_nAction = -1;

    // If there are no items in the MRU list, set the default action
    // to Create New Cluster.  Otherwise, set the default action to
    // Open Connection.
    if ( prcl->GetSize() == 0 )
    {
        m_nAction = OPEN_CLUSTER_DLG_CREATE_NEW_CLUSTER;
    } // if: nothing in the MRU list
    else
    {
        m_nAction = OPEN_CLUSTER_DLG_OPEN_CONNECTION;
    } // else: something in the MRU list

}  //*** COpenClusterDialog::COpenClusterDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  COpenClusterDialog::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void COpenClusterDialog::DoDataExchange(CDataExchange * pDX)
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(COpenClusterDialog)
    DDX_Control(pDX, IDC_OCD_NAME_LABEL, m_staticName);
    DDX_Control(pDX, IDC_OCD_BROWSE, m_pbBrowse);
    DDX_Control(pDX, IDC_OCD_ACTION, m_cboxAction);
    DDX_Control(pDX, IDOK, m_pbOK);
    DDX_Control(pDX, IDC_OCD_NAME, m_cboxName);
    DDX_Text(pDX, IDC_OCD_NAME, m_strName);
    //}}AFX_DATA_MAP

    if ( pDX->m_bSaveAndValidate )
    {
        m_nAction = m_cboxAction.GetCurSel();
        if ( m_nAction != OPEN_CLUSTER_DLG_CREATE_NEW_CLUSTER )
        {
            DDV_RequiredText(pDX, IDC_OCD_NAME, IDC_OCD_NAME_LABEL, m_strName);
            DDV_MaxChars(pDX, m_strName, MAX_PATH - 1);
        } // if: not creating a new cluster
    } // if: saving data
    else
    {
        m_cboxAction.SetCurSel( m_nAction );
        OnSelChangeAction();
    } // else: setting data

}  //*** COpenClusterDialog::DoDataExchange

/////////////////////////////////////////////////////////////////////////////
//++
//
//  COpenClusterDialog::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL COpenClusterDialog::OnInitDialog(void)
{
    CClusterAdminApp *      papp    = GetClusterAdminApp();
    CRecentClusterList *    prcl    = papp->PrclRecentClusterList();
    int                     iMRU;
    CString                 strName;
    CWaitCursor             wc;

    // Call the base class method to get our control mappings.
    CBaseDialog::OnInitDialog();

    // Add the items to the Action combobox.
    strName.LoadString( IDS_OCD_CREATE_CLUSTER );
    m_cboxAction.AddString( strName );
    strName.LoadString( IDS_OCD_ADD_NODES );
    m_cboxAction.AddString( strName );
    strName.LoadString( IDS_OCD_OPEN_CONNECTION );
    m_cboxAction.AddString( strName );

    // Set the proper selection in the Action combobox.
    m_cboxAction.SetCurSel( m_nAction );
    OnSelChangeAction();

    // Set limits on the combobox edit control.
    m_cboxName.LimitText(MAX_PATH - 1);

    // Loop through the MRU items and add each one to the list in order.
    for (iMRU = 0 ; iMRU < prcl->GetSize() ; iMRU++)
    {
        if (!prcl->GetDisplayName(strName, iMRU, NULL, 0))
            break;
        try
        {
            m_cboxName.InsertString(iMRU, strName);
            if ((iMRU == 0) && (m_strName.GetLength() == 0))
                m_strName = strName;
        }  // try
        catch (CException * pe)
        {
            pe->Delete();
        }  // catch:  CException
    }  // for:  each MRU item

    // Select an item in the list.
    if (m_strName.GetLength() > 0)
    {
        int     istr;

        istr = m_cboxName.FindStringExact(-1, m_strName);
        if (istr == CB_ERR)
            m_cboxName.SetWindowText(m_strName);
        else
            m_cboxName.SetCurSel(istr);
    }  // if:  name already specified
    else if (prcl->GetDisplayName(strName, 0, NULL, 0))
        m_cboxName.SelectString(-1, strName);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE

}  //*** COpenClusterDialog::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  COpenClusterDialog::OnBrowse
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Browse button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void COpenClusterDialog::OnBrowse(void)
{
    ID              id;
    int             istr;
    CBrowseClusters dlg(this);

    id = (ID)dlg.DoModal();
    if (id == IDOK)
    {
        istr = m_cboxName.FindStringExact(-1, dlg.m_strCluster);
        if (istr == CB_ERR)
            m_cboxName.SetWindowText(dlg.m_strCluster);
        else
            m_cboxName.SetCurSel(istr);
    }  // if:  user selected a cluster name

}  //*** COpenClusterDialog::OnBrowse()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  COpenClusterDialog::OnSelChangeAction
//
//  Routine Description:
//      Handler for the CBN_SELCHANGE message on the Action combobox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void COpenClusterDialog::OnSelChangeAction( void )
{
    if ( m_cboxAction.GetCurSel() == OPEN_CLUSTER_DLG_CREATE_NEW_CLUSTER )
    {
        m_staticName.EnableWindow( FALSE );
        m_cboxName.EnableWindow( FALSE );
        m_pbBrowse.EnableWindow( FALSE );
    } // if: create cluster option selected
    else
    {
        m_staticName.EnableWindow( TRUE );
        m_cboxName.EnableWindow( TRUE );
        m_pbBrowse.EnableWindow( TRUE );
    } // else: create cluster option NOT selected

} //*** COpenClusterDialog::OnSelChangeAction()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CBrowseClusters dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CBrowseClusters, CBaseDialog)
    //{{AFX_MSG_MAP(CBrowseClusters)
    ON_EN_CHANGE(IDC_BC_CLUSTER, OnChangeCluster)
    ON_LBN_SELCHANGE(IDC_BC_LIST, OnSelChangeList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBrowseClusters::CBrowseClusters
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pParentWnd          [IN OUT] Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBrowseClusters::CBrowseClusters(CWnd * pParent /*=NULL*/)
    : CBaseDialog(IDD, g_aHelpIDs_IDD_BROWSE_CLUSTERS, pParent)
{
    //{{AFX_DATA_INIT(CBrowseClusters)
    m_strCluster = _T("");
    //}}AFX_DATA_INIT

}  //*** CBrowseClusters::CBrowseClusters()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBrowseClusters::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBrowseClusters::DoDataExchange(CDataExchange * pDX)
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CBrowseClusters)
    DDX_Control(pDX, IDOK, m_pbOK);
    DDX_Control(pDX, IDC_BC_LIST, m_lbList);
    DDX_Control(pDX, IDC_BC_CLUSTER, m_editCluster);
    DDX_Text(pDX, IDC_BC_CLUSTER, m_strCluster);
    //}}AFX_DATA_MAP

}  //*** CBrowseClusters::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBrowseClusters::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBrowseClusters::OnInitDialog(void)
{
    CWaitCursor wc;

    // Call the base class method.
    CBaseDialog::OnInitDialog();

    // Collect list of clusters from the network.
    {
        DWORD               dwStatus;
        DWORD               nEntriesRead;
        DWORD               nTotalEntries;
        DWORD               iEntry;
        SERVER_INFO_100 *   pServerInfo = NULL;
        SERVER_INFO_100 *   pCurServerInfo;

        dwStatus = NetServerEnum(
                        NULL,               // servername
                        100,                // level
                        (LPBYTE *) &pServerInfo,
                        1000000,            // prefmaxlen
                        &nEntriesRead,      // entriesread
                        &nTotalEntries,     // totalentries
                        SV_TYPE_CLUSTER_NT, // servertype
                        NULL,               // domain
                        NULL                // resume_handle
                        );
        if (dwStatus == ERROR_SUCCESS)
        {
            ASSERT(pServerInfo != NULL);
            pCurServerInfo = pServerInfo;
            for (iEntry = 0 ; iEntry < nTotalEntries ; iEntry++, pCurServerInfo++)
            {
                if (m_lbList.FindStringExact(-1, pCurServerInfo->sv100_name) == LB_ERR)
                {
                    try
                    {
                        m_lbList.AddString(pCurServerInfo->sv100_name);
                    }  // try
                    catch (CException * pe)
                    {
                        pe->Delete();
                    }  // catch:  CException
                }  // if:  cluster not in list yet
            }  // for:  each entry in the array
        }  // if:  successfully retrieved list of clusters
        NetApiBufferFree(pServerInfo);
    }  // Collect list of clusters from the network

    // Enable/disable controls.
    OnChangeCluster();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CBrowseClusters::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBrowseClusters::OnChangeCluster
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Cluster edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBrowseClusters::OnChangeCluster(void)
{
    BOOL    bEnable;

    bEnable = m_editCluster.GetWindowTextLength() != 0;
    m_pbOK.EnableWindow(bEnable);

}  //*** CBrowseClusters::OnChangeCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBrowseClusters::OnSelChangeList
//
//  Routine Description:
//      Handler for the LBN_SELCHANGE message on the list box.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBrowseClusters::OnSelChangeList(void)
{
    int     istr;

    istr = m_lbList.GetCurSel();
    if (istr != LB_ERR)
    {
        CString strText;

        m_lbList.GetText(istr, strText);
        m_editCluster.SetWindowText(strText);
    }  // if:  there is a selection

}  //*** CBrowseClusters::OnSelChangeList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\openclus.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      OpenClus.h
//
//  Abstract:
//      Definition of the COpenClusterDialog class.
//
//  Author:
//      David Potter (davidp)   May 3, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _OPENCLUS_H_
#define _OPENCLUS_H_

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define OPEN_CLUSTER_DLG_CREATE_NEW_CLUSTER     0
#define OPEN_CLUSTER_DLG_ADD_NODES              1
#define OPEN_CLUSTER_DLG_OPEN_CONNECTION        2

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class COpenClusterDialog;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEDLG_H_
#include "BaseDlg.h"    // for CBaseDialog
#endif

/////////////////////////////////////////////////////////////////////////////
// COpenCluster class
/////////////////////////////////////////////////////////////////////////////

class COpenClusterDialog : public CBaseDialog
{
// Construction
public:
    COpenClusterDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(COpenClusterDialog)
	enum { IDD = IDD_OPEN_CLUSTER };
    CButton     m_pbOK;
	CButton	    m_pbBrowse;
    CComboBox   m_cboxAction;
    CComboBox   m_cboxName;
	CStatic	    m_staticName;
    CString     m_strName;
	//}}AFX_DATA
	int		m_nAction;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(COpenClusterDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(COpenClusterDialog)
    virtual BOOL OnInitDialog();
    afx_msg void OnBrowse();
	afx_msg void OnSelChangeAction();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class COpenClusterDialog

/////////////////////////////////////////////////////////////////////////////
// CBrowseClusters dialog
/////////////////////////////////////////////////////////////////////////////

class CBrowseClusters : public CBaseDialog
{
// Construction
public:
    CBrowseClusters(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CBrowseClusters)
    enum { IDD = IDD_BROWSE_CLUSTERS };
    CButton m_pbOK;
    CListBox    m_lbList;
    CEdit   m_editCluster;
    CString m_strCluster;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CBrowseClusters)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CBrowseClusters)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeCluster();
    afx_msg void OnSelChangeList();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CBrowseClusters

/////////////////////////////////////////////////////////////////////////////

#endif // _OPENCLUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\resprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ResProp.cpp
//
//  Abstract:
//      Implementation of the resource property sheet and pages.
//
//  Author:
//      David Potter (davidp)   May 16, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "ResProp.h"
#include "Res.h"
#include "ClusDoc.h"
#include "Cluster.h"
#include "ModNodes.h"
#include "ModRes.h"
#include "DDxDDv.h"
#include "HelpData.h"
#include "ExcOper.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CResourcePropSheet
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CResourcePropSheet, CBasePropertySheet)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CResourcePropSheet, CBasePropertySheet)
    //{{AFX_MSG_MAP(CResourcePropSheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePropSheet::CResourcePropSheet
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pParentWnd  [IN OUT] Parent window for this property sheet.
//      iSelectPage [IN] Page to show first.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResourcePropSheet::CResourcePropSheet(
    IN OUT CWnd *       pParentWnd,
    IN UINT             iSelectPage
    )
    : CBasePropertySheet(pParentWnd, iSelectPage)
{
    m_rgpages[0] = &PageGeneral();
    m_rgpages[1] = &PageDepends();
    m_rgpages[2] = &PageAdvanced();

}  //*** CResourcePropSheet::CResourcePropSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePropSheet::BInit
//
//  Routine Description:
//      Initialize the property sheet.
//
//  Arguments:
//      pci         [IN OUT] Cluster item whose properties are to be displayed.
//      iimgIcon    [IN] Index in the large image list for the image to use
//                    as the icon on each page.
//
//  Return Value:
//      TRUE        Property sheet initialized successfully.
//      FALSE       Error initializing property sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourcePropSheet::BInit(
    IN OUT CClusterItem *   pci,
    IN IIMG                 iimgIcon
    )
{
    // Call the base class method.
    if (!CBasePropertySheet::BInit(pci, iimgIcon))
        return FALSE;

    // Set the read-only flag if the handles are invalid.
    m_bReadOnly = PciRes()->BReadOnly()
                    || (PciRes()->Crs() == ClusterResourceStateUnknown);

    SetPfGetResNetName(CResourceDependsPage::BGetNetworkName, &PageDepends());

    return TRUE;

}  //*** CResourcePropSheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePropSheet::Ppages
//
//  Routine Description:
//      Returns the array of pages to add to the property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Page array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage ** CResourcePropSheet::Ppages(void)
{
    return m_rgpages;

}  //*** CResourcePropSheet::Pppges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourcePropSheet::Cpages
//
//  Routine Description:
//      Returns the count of pages in the array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Count of pages in the array.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CResourcePropSheet::Cpages(void)
{
    return sizeof(m_rgpages) / sizeof(CBasePropertyPage *);

}  //*** CResourcePropSheet::Cpages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResourceGeneralPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CResourceGeneralPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CResourceGeneralPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CResourceGeneralPage)
    ON_BN_CLICKED(IDC_PP_RES_POSSIBLE_OWNERS_MODIFY, OnModifyPossibleOwners)
    ON_LBN_DBLCLK(IDC_PP_RES_POSSIBLE_OWNERS, OnDblClkPossibleOwners)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
    ON_EN_CHANGE(IDC_PP_RES_NAME, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_RES_DESC, CBasePropertyPage::OnChangeCtrl)
    ON_BN_CLICKED(IDC_PP_RES_SEPARATE_MONITOR, CBasePropertyPage::OnChangeCtrl)
    ON_COMMAND(ID_FILE_PROPERTIES, OnProperties)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::CResourceGeneralPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResourceGeneralPage::CResourceGeneralPage(void)
    : CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_RES_GENERAL)
{
    //{{AFX_DATA_INIT(CResourceGeneralPage)
    m_strName = _T("");
    m_strDesc = _T("");
    m_strGroup = _T("");
    m_strState = _T("");
    m_strNode = _T("");
    m_bSeparateMonitor = FALSE;
    //}}AFX_DATA_INIT

}  //*** CResourceGeneralPage::CResourceGeneralPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      psht        [IN OUT] Property sheet to which this page belongs.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceGeneralPage::BInit(IN OUT CBaseSheet * psht)
{
    BOOL    bSuccess;

    ASSERT_KINDOF(CResourcePropSheet, psht);

    bSuccess = CBasePropertyPage::BInit(psht);
    if (bSuccess)
    {
        try
        {
            m_strName = PciRes()->StrName();
            m_strDesc = PciRes()->StrDescription();
            if (PciRes()->PciResourceType() != NULL)
                m_strType = PciRes()->PciResourceType()->StrDisplayName();
            m_strGroup = PciRes()->StrGroup();
            m_strNode = PciRes()->StrOwner();
            m_bSeparateMonitor = PciRes()->BSeparateMonitor();

            // Duplicate the possible owners list.
            {
                POSITION        pos;
                CClusterNode *  pciNode;

                pos = PciRes()->LpcinodePossibleOwners().GetHeadPosition();
                while (pos != NULL)
                {
                    pciNode = (CClusterNode *) PciRes()->LpcinodePossibleOwners().GetNext(pos);
                    ASSERT_VALID(pciNode);
                    m_lpciPossibleOwners.AddTail(pciNode);
                }  // while:  more nodes in the list
            }  // Duplicate the possible owners list

            PciRes()->GetStateName(m_strState);
        } // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
            bSuccess = FALSE;
        }  // catch:  CException
    }  //  if:  base class method was successful

    return bSuccess;

}  //*** CResourceGeneralPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceGeneralPage::DoDataExchange(CDataExchange * pDX)
{
    CBasePropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CResourceGeneralPage)
    DDX_Control(pDX, IDC_PP_RES_DESC, m_editDesc);
    DDX_Control(pDX, IDC_PP_RES_SEPARATE_MONITOR, m_ckbSeparateMonitor);
    DDX_Control(pDX, IDC_PP_RES_POSSIBLE_OWNERS_MODIFY, m_pbPossibleOwnersModify);
    DDX_Control(pDX, IDC_PP_RES_POSSIBLE_OWNERS, m_lbPossibleOwners);
    DDX_Control(pDX, IDC_PP_RES_NAME, m_editName);
    DDX_Text(pDX, IDC_PP_RES_NAME, m_strName);
    DDX_Text(pDX, IDC_PP_RES_DESC, m_strDesc);
    DDX_Text(pDX, IDC_PP_RES_RESOURCE_TYPE, m_strType);
    DDX_Text(pDX, IDC_PP_RES_GROUP, m_strGroup);
    DDX_Text(pDX, IDC_PP_RES_CURRENT_STATE, m_strState);
    DDX_Text(pDX, IDC_PP_RES_CURRENT_NODE, m_strNode);
    DDX_Check(pDX, IDC_PP_RES_SEPARATE_MONITOR, m_bSeparateMonitor);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (!BReadOnly())
        {
            try
            {
                PciRes()->ValidateCommonProperties(
                                    m_strDesc,
                                    m_bSeparateMonitor,
                                    PciRes()->NLooksAlive(),
                                    PciRes()->NIsAlive(),
                                    PciRes()->CrraRestartAction(),
                                    PciRes()->NRestartThreshold(),
                                    PciRes()->NRestartPeriod(),
                                    PciRes()->NPendingTimeout()
                                    );
            }  // try
            catch (CException * pe)
            {
                pe->ReportError();
                pe->Delete();
                pDX->Fail();
            }  // catch:  CException

            if ((LpciPossibleOwners().GetCount() == 0))
            {
                ID id = AfxMessageBox(IDS_NO_POSSIBLE_OWNERS_QUERY, MB_YESNO | MB_ICONWARNING);
                if (id == IDNO)
                    pDX->Fail();
            }  // if:  no possible owners
        }  // if:  not read only
    }  // if:  saving data from the dialog
    else
    {
        FillPossibleOwners();
    }  // else:  setting data to the dialog

}  //*** CResourceGeneralPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::FillPossibleOwners
//
//  Routine Description:
//      Fill the Possible Owners list box.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceGeneralPage::FillPossibleOwners(void)
{
    POSITION        posPci;
    CClusterNode *  pciNode;
    int             iitem;

    m_lbPossibleOwners.ResetContent();

    posPci = LpciPossibleOwners().GetHeadPosition();
    while (posPci != NULL)
    {
        pciNode = (CClusterNode *) LpciPossibleOwners().GetNext(posPci);
        iitem = m_lbPossibleOwners.AddString(pciNode->StrName());
        if (iitem >= 0)
            m_lbPossibleOwners.SetItemDataPtr(iitem, pciNode);
    }  // for:  each string in the list

}  //*** CResourceGeneralPage::FillPossibleOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceGeneralPage::OnInitDialog(void)
{
    CBasePropertyPage::OnInitDialog();

    // If read-only, set all controls to be either disabled or read-only.
    if (BReadOnly())
    {
        m_editName.SetReadOnly(TRUE);
        m_editDesc.SetReadOnly(TRUE);
        m_pbPossibleOwnersModify.EnableWindow(FALSE);
        m_ckbSeparateMonitor.EnableWindow(FALSE);
    }  // if:  sheet is read-only

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CResourceGeneralPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::OnApply
//
//  Routine Description:
//      Handler for when the Apply button is pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceGeneralPage::OnApply(void)
{
    // Set the data from the page in the cluster item.
    try
    {
        CWaitCursor wc;

        PciRes()->SetName(m_strName);
        PciRes()->SetPossibleOwners(LpciPossibleOwners());
        PciRes()->SetCommonProperties(
                            m_strDesc,
                            m_bSeparateMonitor,
                            PciRes()->NLooksAlive(),
                            PciRes()->NIsAlive(),
                            PciRes()->CrraRestartAction(),
                            PciRes()->NRestartThreshold(),
                            PciRes()->NRestartPeriod(),
                            PciRes()->NPendingTimeout()
                            );
    }  // try
    catch (CNTException * pnte)
    {
        pnte->ReportError();
        pnte->Delete();
        if (pnte->Sc() != ERROR_RESOURCE_PROPERTIES_STORED)
            return FALSE;
    }  // catch:  CNTException
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CBasePropertyPage::OnApply();

}  //*** CResourceGeneralPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::OnProperties
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Properties button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceGeneralPage::OnProperties(void)
{
    int             iitem;
    CClusterNode *  pciNode;

    // Get the item with the focus.
    iitem = m_lbPossibleOwners.GetCurSel();
    ASSERT(iitem >= 0);

    if (iitem >= 0)
    {
        // Get the node pointer.
        pciNode = (CClusterNode *) m_lbPossibleOwners.GetItemDataPtr(iitem);
        ASSERT_VALID(pciNode);

        // Set properties of that item.
        if (pciNode->BDisplayProperties())
        {
        }  // if:  properties changed
    }  // if:  found an item with focus

}  //*** CResourceGeneralPage::OnProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceGeneralPage::OnContextMenu(CWnd * pWnd, CPoint point)
{
    BOOL            bHandled    = FALSE;
    CMenu *         pmenu       = NULL;
    CListBox *      pListBox    = (CListBox *) pWnd;
    CString         strMenuName;
    CWaitCursor     wc;

    // If focus is not in the list control, don't handle the message.
    if ( pWnd == &m_lbPossibleOwners )
    {
        // Create the menu to display.
        try
        {
            pmenu = new CMenu;
            if ( pmenu == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the menu

            if ( pmenu->CreatePopupMenu() )
            {
                UINT    nFlags  = MF_STRING;

                // If there are no items in the list, disable the menu item.
                if ( pListBox->GetCount() == 0 )
                {
                    nFlags |= MF_GRAYED;
                } // if: no items in the list

                // Add the Properties item to the menu.
                strMenuName.LoadString( IDS_MENU_PROPERTIES );
                if ( pmenu->AppendMenu( nFlags, ID_FILE_PROPERTIES, strMenuName ) )
                {
                    bHandled = TRUE;
                    if ( pListBox->GetCurSel() == -1 )
                    {
                        pListBox->SetCurSel( 0 );
                    } // if: no items selected
                }  // if:  successfully added menu item
            }  // if:  menu created successfully
        }  // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
    }  // if:  focus is on list control

    if ( bHandled )
    {
        // Display the menu.
        if ( ! pmenu->TrackPopupMenu(
                        TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                        point.x,
                        point.y,
                        this
                        ) )
        {
        }  // if:  unsuccessfully displayed the menu
    }  // if:  there is a menu to display
    else
    {
        CBasePropertyPage::OnContextMenu( pWnd, point );
    } // else: no menu to display

    delete pmenu;

}  //*** CResourceGeneralPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::OnModifyPossibleOwners
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Modify Possible Owners button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceGeneralPage::OnModifyPossibleOwners(void)
{
    CModifyNodesDlg dlg(
                        IDD_MODIFY_POSSIBLE_OWNERS,
                        g_aHelpIDs_IDD_MODIFY_POSSIBLE_OWNERS,
                        m_lpciPossibleOwners,
                        PciRes()->PciResourceType()->LpcinodePossibleOwners(),
                        LCPS_SHOW_IMAGES | LCPS_ALLOW_EMPTY
                        );

    if (dlg.DoModal() == IDOK)
    {
        SetModified(TRUE);
        FillPossibleOwners();
    }  // if:  OK button pressed

}  //*** CResourceGeneralPage::OnModifyPossibleOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::OnDblClkPossibleOwners
//
//  Routine Description:
//      Handler for the LBN_DBLCLK message on the Possible Owners listbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceGeneralPage::OnDblClkPossibleOwners(void)
{
    OnProperties();

}  //*** CResourceGeneralPage::OnDblClkPossibleOwners()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResourceDependsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CResourceDependsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CResourceDependsPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CResourceDependsPage)
    ON_BN_CLICKED(IDC_PP_RES_MODIFY, OnModify)
    ON_NOTIFY(NM_DBLCLK, IDC_PP_RES_DEPENDS_LIST, OnDblClkDependsList)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_PP_RES_DEPENDS_LIST, OnColumnClick)
    ON_BN_CLICKED(IDC_PP_RES_PROPERTIES, OnProperties)
    ON_WM_CONTEXTMENU()
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_PP_RES_DEPENDS_LIST, OnItemChangedDependsList)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_FILE_PROPERTIES, OnProperties)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::CResourceDependsPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResourceDependsPage::CResourceDependsPage(void)
    : CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_RES_DEPENDS)

{
    //{{AFX_DATA_INIT(CResourceDependsPage)
    //}}AFX_DATA_INIT

    m_bQuorumResource = FALSE;

}  //*** CResourceDependsPage::CResourceDependsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      psht        [IN OUT] Property sheet to which this page belongs.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceDependsPage::BInit(IN OUT CBaseSheet * psht)
{
    BOOL            bSuccess;

    ASSERT_KINDOF(CResourcePropSheet, psht);

    // Call the base class to do base-level initialization.
    // NOTE:  MUST BE DONE BEFORE ACCESSING THE SHEET.
    bSuccess = CBasePropertyPage::BInit(psht);
    if (bSuccess)
    {
        try
        {
            // Duplicate the dependencies list.
            {
                POSITION        pos;
                CResource *     pciRes;

                pos = PciRes()->LpciresDependencies().GetHeadPosition();
                while (pos != NULL)
                {
                    pciRes = (CResource *) PciRes()->LpciresDependencies().GetNext(pos);
                    ASSERT_VALID(pciRes);
                    m_lpciresDependencies.AddTail(pciRes);
                }  // while:  more nodes in the list
            }  // Duplicate the dependencies list

            // Create the list of resources on which this resource can be dependent.
            {
                POSITION                posPci;
                CResource *             pciRes;
                CResourceList &         rlpciResources      = PciRes()->Pdoc()->LpciResources();

                LpciresAvailable().RemoveAll();

                posPci = rlpciResources.GetHeadPosition();
                while (posPci != NULL)
                {
                    // Get the cluster item pointer.
                    pciRes = (CResource *) rlpciResources.GetNext(posPci);
                    ASSERT_VALID(pciRes);

                    // If we CAN be dependent on this resource, add it to our Available list.
                    if (PciRes()->BCanBeDependent(pciRes)
                            || PciRes()->BIsDependent(pciRes))
                        LpciresAvailable().AddTail(pciRes);
                }  // while:  more items in the list
            }  // Create the list of resources on which this resource can be dependent

            // Determine if we are the quorum resource.
            m_bQuorumResource = (PciRes()->StrName() == PciRes()->Pdoc()->PciCluster()->StrQuorumResource());
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
            bSuccess = FALSE;
        }  // catch:  CException
    }  //  if:  base class method was successful

    return bSuccess;

}  //*** CResourceDependsPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceDependsPage::DoDataExchange(CDataExchange * pDX)
{
    CBasePropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CResourceDependsPage)
    DDX_Control(pDX, IDC_PP_RES_PROPERTIES, m_pbProperties);
    DDX_Control(pDX, IDC_PP_RES_MODIFY, m_pbModify);
    DDX_Control(pDX, IDC_PP_RES_DEPENDS_LIST, m_lcDependencies);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
    }  // if:  saving data from the dialog
    else
    {
        FillDependencies();
    }  // else:  setting data to the dialog

}  //*** CResourceDependsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::FillDependencies
//
//  Routine Description:
//      Fill the Possible Owners list box.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceDependsPage::FillDependencies(void)
{
    POSITION        pos;
    int             iitem;
    int             nitem;
    CResource *     pciRes;

    m_lcDependencies.DeleteAllItems();

    pos = LpciresDependencies().GetHeadPosition();
    for (iitem = 0 ; pos != NULL ; iitem++)
    {
        pciRes = (CResource *) LpciresDependencies().GetNext(pos);
        ASSERT_VALID(pciRes);
        nitem = m_lcDependencies.InsertItem(iitem, pciRes->StrName(), pciRes->IimgObjectType());
        m_lcDependencies.SetItemText(nitem, 1, pciRes->StrRealResourceTypeDisplayName());
        m_lcDependencies.SetItemData(nitem, (DWORD_PTR) pciRes);
    }  // for:  each string in the list

    // Sort the items.
    m_nSortColumn = 0;
    m_nSortDirection = 0;
    m_lcDependencies.SortItems(CompareItems, (LPARAM) this);

    // If there are any items, set the focus on the first one.
    if (m_lcDependencies.GetItemCount() != 0)
        m_lcDependencies.SetItemState(0, LVIS_FOCUSED, LVIS_FOCUSED);

}  //*** CResourceDependsPage::FillDependencies()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceDependsPage::OnInitDialog(void)
{
    // Call the base class method.
    CBasePropertyPage::OnInitDialog();

    // Enable the Properties button by default.
    m_pbProperties.EnableWindow(FALSE);

    // Change list view control extended styles.
    {
        DWORD   dwExtendedStyle;

        dwExtendedStyle = (DWORD)m_lcDependencies.SendMessage(LVM_GETEXTENDEDLISTVIEWSTYLE);
        m_lcDependencies.SendMessage(
            LVM_SETEXTENDEDLISTVIEWSTYLE,
            0,
            dwExtendedStyle
                | LVS_EX_FULLROWSELECT
                | LVS_EX_HEADERDRAGDROP
            );
    }  // Change list view control extended styles

    // Set the image list for the list control to use.
    m_lcDependencies.SetImageList(GetClusterAdminApp()->PilSmallImages(), LVSIL_SMALL);

    // Add the columns.
    {
        CString         strColumn;

        try
        {
            strColumn.LoadString(IDS_COLTEXT_NAME);
            m_lcDependencies.InsertColumn(0, strColumn, LVCFMT_LEFT, COLI_WIDTH_NAME * 3 / 2);
            strColumn.LoadString(IDS_COLTEXT_RESTYPE);
            m_lcDependencies.InsertColumn(1, strColumn, LVCFMT_LEFT, COLI_WIDTH_RESTYPE * 3 / 2);
        }  // try
        catch (CException * pe)
        {
            pe->Delete();
        }  // catch:  CException
    }  // Add the columns

    // Fill the list control.
    FillDependencies();

    if (BReadOnly())
    {
        m_pbModify.EnableWindow(FALSE);
    }  // if:  read-only page

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CResourceDependsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::OnApply
//
//  Routine Description:
//      Handler for the PSM_APPLY message, which is sent when the Apply
//      button is pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceDependsPage::OnApply(void)
{
    ASSERT(!BReadOnly());

    // Check to see if required dependencies have been made.
    {
        CString     strMissing;
        CString     strMsg;

        try
        {
            if (!PciRes()->BRequiredDependenciesPresent(LpciresDependencies(), strMissing))
            {
                strMsg.FormatMessage(IDS_REQUIRED_DEPENDENCY_NOT_FOUND, strMissing);
                AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
                return FALSE;
            }  // if:  all required dependencies not present
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
            return FALSE;
        }  // catch:  CException
    }  // Check to see if required dependencies have been made

    // Set the data from the page in the cluster item.
    try
    {
        CWaitCursor wc;

        PciRes()->SetDependencies(LpciresDependencies());
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CBasePropertyPage::OnApply();

}  //*** CResourceDependsPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::OnModify
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Modify button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceDependsPage::OnModify(void)
{
    CModifyResourcesDlg dlg(
                            IDD_MODIFY_DEPENDENCIES,
                            g_aHelpIDs_IDD_MODIFY_DEPENDENCIES,
                            m_lpciresDependencies,
                            m_lpciresAvailable,
                            LCPS_SHOW_IMAGES | LCPS_ALLOW_EMPTY
                            );

    ASSERT(!BReadOnly());

    // If this is the quorum resource, display an error message.
    if (BQuorumResource())
    {
        AfxMessageBox(IDS_QUORUM_RES_CANT_HAVE_DEPS);
    }  // if:  this is the quorum resource
    else
    {
        if (dlg.DoModal() == IDOK)
        {
            SetModified(TRUE);
            FillDependencies();
        }  // if:  OK button pressed
    }  // else:  not the quorum resource

}  //*** CResourceDependsPage::OnModify()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::OnProperties
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Properties button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceDependsPage::OnProperties(void)
{
    DisplayProperties();

}  //*** CResourceDependsPage::OnProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CListCtrlPair::OnItemChangedDependsList
//
//  Routine Description:
//      Handler method for the LVN_ITEMCHANGED message in the dependencies
//      list.
//
//  Arguments:
//      pNMHDR      [IN OUT] WM_NOTIFY structure.
//      pResult     [OUT] LRESULT in which to return the result of this operation.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceDependsPage::OnItemChangedDependsList(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW * pNMListView = (NM_LISTVIEW *) pNMHDR;

    // If the selection changed, enable/disable the Properties button.
    if ((pNMListView->uChanged & LVIF_STATE)
            && ((pNMListView->uOldState & LVIS_SELECTED)
                    || (pNMListView->uNewState & LVIS_SELECTED))
            && !BReadOnly())
    {
        UINT    cSelected = m_lcDependencies.GetSelectedCount();

        // If there is only one item selected, enable the Properties button.
        // Otherwise disable it.
        m_pbProperties.EnableWindow((cSelected == 1) ? TRUE : FALSE);
    }  // if:  selection changed

    *pResult = 0;

}  //*** CResourceDependsPage::OnItemChangedDependsList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceDependsPage::OnContextMenu(CWnd * pWnd, CPoint point)
{
    BOOL            bHandled    = FALSE;
    CMenu *         pmenu       = NULL;
    CListCtrl *     pListCtrl   = (CListCtrl *) pWnd;
    CString         strMenuName;
    CWaitCursor     wc;

    // If focus is not in the list control, don't handle the message.
    if (pWnd == &m_lcDependencies)
    {
        // Create the menu to display.
        try
        {
            pmenu = new CMenu;
            if ( pmenu == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the menu

            if ( pmenu->CreatePopupMenu() )
            {
                UINT    nFlags  = MF_STRING;

                // If there are no items in the list, disable the menu item.
                if ( pListCtrl->GetItemCount() == 0 )
                {
                    nFlags |= MF_GRAYED;
                } // if: no items in the list

                // Add the Properties item to the menu.
                strMenuName.LoadString( IDS_MENU_PROPERTIES );
                if ( pmenu->AppendMenu( nFlags, ID_FILE_PROPERTIES, strMenuName ) )
                {
                    bHandled = TRUE;
                    if ( ( pListCtrl->GetItemCount() != 0 )
                      && ( pListCtrl->GetNextItem( -1, LVNI_FOCUSED ) == -1 ) )
                    {
                        pListCtrl->SetItemState( 0, LVNI_FOCUSED, LVNI_FOCUSED );
                    } // if: no item selected
                }  // if:  successfully added menu item
            }  // if:  menu created successfully
        }  // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
    }  // if:  focus is on the list control

    if ( bHandled )
    {
        // Display the menu.
        if ( ! pmenu->TrackPopupMenu(
                        TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                        point.x,
                        point.y,
                        this
                        ) )
        {
        }  // if:  unsuccessfully displayed the menu
    }  // if:  there is a menu to display
    else
    {
        CBasePropertyPage::OnContextMenu( pWnd, point );
    } // else: no menu to display

    delete pmenu;

}  //*** CResourceDependsPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::OnDblClkDependsList
//
//  Routine Description:
//      Handler method for the NM_DBLCLK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceDependsPage::OnDblClkDependsList(NMHDR * pNMHDR, LRESULT * pResult)
{
    DisplayProperties();
    *pResult = 0;

}  //*** CResourceDependsPage::OnDblClkDependsList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::OnColumnClick
//
//  Routine Description:
//      Handler method for the LVN_COLUMNCLICK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceDependsPage::OnColumnClick(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW * pNMListView = (NM_LISTVIEW *) pNMHDR;

    if (m_lcDependencies.GetItemCount() != 0)
    {
        // Save the current sort column and direction.
        if (pNMListView->iSubItem == m_nSortColumn)
            m_nSortDirection ^= -1;
        else
        {
            m_nSortColumn = pNMListView->iSubItem;
            m_nSortDirection = 0;
        }  // else:  different column

        // Sort the list.
        m_lcDependencies.SortItems(CompareItems, (LPARAM) this);
    }  // if:  there are items in the list

    *pResult = 0;

}  //*** CResourceDependsPage::OnColumnClick()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::CompareItems [static]
//
//  Routine Description:
//      Callback function for the CListCtrl::SortItems method.
//
//  Arguments:
//      lparam1     First item to compare.
//      lparam2     Second item to compare.
//      lparamSort  Sort parameter.
//
//  Return Value:
//      -1          First parameter comes before second.
//      0           First and second parameters are the same.
//      1           First parameter comes after second.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CALLBACK CResourceDependsPage::CompareItems(
    LPARAM  lparam1,
    LPARAM  lparam2,
    LPARAM  lparamSort
    )
{
    CResource *         pciRes1 = (CResource *) lparam1;
    CResource *         pciRes2 = (CResource *) lparam2;
    CResourceDependsPage *  ppage   = (CResourceDependsPage *) lparamSort;
    const CString *     pstr1;
    const CString *     pstr2;
    int                 nResult;

    ASSERT_VALID(pciRes1);
    ASSERT_VALID(pciRes2);
    ASSERT_VALID(ppage);

    // Get the strings from the list items.
    if (ppage->m_nSortColumn == 1)
    {
        pstr1 = &pciRes1->StrRealResourceTypeDisplayName();
        pstr2 = &pciRes2->StrRealResourceTypeDisplayName();
    }  //  if:  sorting on name column
    else
    {
        pstr1 = &pciRes1->StrName();
        pstr2 = &pciRes2->StrName();
    }  // else:  sorting on resource type column

    // Compare the two strings.
    // Use CompareString() so that it will sort properly on localized builds.
    nResult = CompareString(
                LOCALE_USER_DEFAULT,
                0,
                *pstr1,
                pstr1->GetLength(),
                *pstr2,
                pstr2->GetLength()
                );
    if ( nResult == CSTR_LESS_THAN )
    {
        nResult = -1;
    }
    else if ( nResult == CSTR_EQUAL )
    {
        nResult = 0;
    }
    else if ( nResult == CSTR_GREATER_THAN )
    {
        nResult = 1;
    }
    else
    {
        // An error occurred.  Ignore it.
        nResult = 0;
    }

    // Return the result based on the direction we are sorting.
    if (ppage->m_nSortDirection != 0)
        nResult = -nResult;

    return nResult;

}  //*** CResourceDependsPage::CompareItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::DisplayProperties
//
//  Routine Description:
//      Display properties of the item with the focus.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceDependsPage::DisplayProperties()
{
    int             iitem;
    CResource *     pciRes;

    // Get the item with the focus.
    iitem = m_lcDependencies.GetNextItem(-1, LVNI_FOCUSED);
    ASSERT(iitem != -1);

    if (iitem != -1)
    {
        // Get the resource pointer.
        pciRes = (CResource *) m_lcDependencies.GetItemData(iitem);
        ASSERT_VALID(pciRes);

        // Set properties of that item.
        if (pciRes->BDisplayProperties())
        {
            m_lcDependencies.SetItem(
                    iitem,
                    0,
                    LVIF_TEXT | LVIF_IMAGE,
                    pciRes->StrName(),
                    pciRes->IimgObjectType(),
                    0,
                    0,
                    0
                    );
            m_lcDependencies.SetItemData(iitem, (DWORD_PTR) pciRes);
            m_lcDependencies.SetItemText(iitem, 1, pciRes->StrRealResourceTypeDisplayName());
        }  // if:  properties changed
    }  // if:  found an item with focus

}  //*** CResourceDependsPage::DisplayProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependsPage::BGetNetworkName [static]
//
//  Routine Description:
//      Get the name of a network name resource on which this resource is
//      dependent.
//
//  Arguments:
//      lpszNetName     [OUT] String in which to return the network name resource name.
//      pcchNetName     [IN OUT] Points to a variable that specifies the
//                          maximum size, in characters, of the buffer.  This
//                          value shold be large enough to contain
//                          MAX_COMPUTERNAME_LENGTH + 1 characters.  Upon
//                          return it contains the actual number of characters
//                          copied.
//      pvContext       [IN OUT] Context for the operation.
//
//  Return Value:
//      TRUE        Resource is dependent on a network name resource.
//      FALSE       Resource is NOT dependent on a network name resource.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK CResourceDependsPage::BGetNetworkName(
    OUT WCHAR *     lpszNetName,
    IN OUT DWORD *  pcchNetName,
    IN OUT PVOID    pvContext
    )
{
    POSITION                pos;
    CResource *             pciRes;
    CResourceDependsPage *  ppage = (CResourceDependsPage *) pvContext;

    ASSERT(lpszNetName != NULL);
    ASSERT(pcchNetName != NULL);
    ASSERT(*pcchNetName > MAX_COMPUTERNAME_LENGTH);
    ASSERT_KINDOF(CResourceDependsPage, ppage);

    pos = ppage->LpciresDependencies().GetHeadPosition();
    while (pos != NULL)
    {
        pciRes = (CResource *) ppage->LpciresDependencies().GetNext(pos);
        ASSERT_VALID(pciRes);
        if (pciRes->StrRealResourceType().CompareNoCase(RESNAME_NETWORK_NAME) == 0)
        {
            DWORD   dwStatus;
            CString strNetName;

            // Read the network name.
            dwStatus = pciRes->DwReadValue(REGPARAM_NAME, REGPARAM_PARAMETERS, strNetName);
            if (dwStatus != ERROR_SUCCESS)
                return FALSE;

            ASSERT(strNetName.GetLength() < (int) *pcchNetName);
            wcscpy(lpszNetName, strNetName);
            return TRUE;
        }  // if:  found a match
        else if (pciRes->BGetNetworkName(lpszNetName, pcchNetName))
            return TRUE;
    }  // while:  more items in the list

    ASSERT_VALID(ppage->PciRes());

    // If the resource has a direct dependency on a Network Name resource,
    // we need to return FALSE because the user has removed it from the
    // list here.
    pos = ppage->PciRes()->LpciresDependencies().GetHeadPosition();
    while (pos != NULL)
    {
        pciRes = (CResource *) ppage->PciRes()->LpciresDependencies().GetNext(pos);
        ASSERT_VALID(pciRes);
        if (pciRes->StrRealResourceType().CompareNoCase(RESNAME_NETWORK_NAME) == 0)
            return FALSE;
    }  // while:  more items in the list

    // There is no direct dependency on a Network Name resource.  Call
    // the API to see if there is an indirect dependency.
    return ppage->PciRes()->BGetNetworkName(lpszNetName, pcchNetName);

}  //*** CResourceDependsPage::BGetNetworkName()

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResourceAdvancedPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CResourceAdvancedPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CResourceAdvancedPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CResourceAdvancedPage)
    ON_BN_CLICKED(IDC_PP_RES_DONT_RESTART, OnClickedDontRestart)
    ON_BN_CLICKED(IDC_PP_RES_RESTART, OnClickedRestart)
    ON_BN_CLICKED(IDC_PP_RES_DEFAULT_LOOKS_ALIVE, OnClickedDefaultLooksAlive)
    ON_BN_CLICKED(IDC_PP_RES_DEFAULT_IS_ALIVE, OnClickedDefaultIsAlive)
    ON_EN_CHANGE(IDC_PP_RES_LOOKS_ALIVE, OnChangeLooksAlive)
    ON_EN_CHANGE(IDC_PP_RES_IS_ALIVE, OnChangeIsAlive)
    ON_BN_CLICKED(IDC_PP_RES_SPECIFY_LOOKS_ALIVE, OnClickedSpecifyLooksAlive)
    ON_BN_CLICKED(IDC_PP_RES_SPECIFY_IS_ALIVE, OnClickedSpecifyIsAlive)
    //}}AFX_MSG_MAP
    ON_BN_CLICKED(IDC_PP_RES_AFFECT_THE_GROUP, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_RES_RESTART_THRESHOLD, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_RES_RESTART_PERIOD, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_RES_PENDING_TIMEOUT, CBasePropertyPage::OnChangeCtrl)
    ON_BN_CLICKED(IDC_PP_RES_SPECIFY_LOOKS_ALIVE, CBasePropertyPage::OnChangeCtrl)
    ON_BN_CLICKED(IDC_PP_RES_SPECIFY_IS_ALIVE, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::CResourceAdvancedPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResourceAdvancedPage::CResourceAdvancedPage(void)
    : CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_RES_ADVANCED)
{
    //{{AFX_DATA_INIT(CResourceAdvancedPage)
    m_bAffectTheGroup = FALSE;
    m_nRestart = -1;
    //}}AFX_DATA_INIT

}  //*** CResourceAdvancedPage::CResourceAdvancedPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      psht        [IN OUT] Property sheet to which this page belongs.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceAdvancedPage::BInit(IN OUT CBaseSheet * psht)
{
    BOOL    bSuccess;

    ASSERT_KINDOF(CResourcePropSheet, psht);

    bSuccess = CBasePropertyPage::BInit(psht);
    if (bSuccess)
    {
        m_crraRestartAction = PciRes()->CrraRestartAction();
        m_nRestart = 1;
        m_bAffectTheGroup = FALSE;
        if (m_crraRestartAction == ClusterResourceDontRestart)
            m_nRestart = 0;
        else if (m_crraRestartAction == ClusterResourceRestartNotify)
            m_bAffectTheGroup = TRUE;

        m_nThreshold = PciRes()->NRestartThreshold();
        m_nPeriod = PciRes()->NRestartPeriod() / 1000; // display units are seconds, stored units are milliseconds
        m_nLooksAlive = PciRes()->NLooksAlive();
        m_nIsAlive = PciRes()->NIsAlive();
        m_nPendingTimeout = PciRes()->NPendingTimeout() / 1000; // display units are seconds, stored units are milliseconds
    }  // if:  base class method was successful

    return TRUE;

}  //*** CResourceAdvancedPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceAdvancedPage::DoDataExchange(CDataExchange * pDX)
{
    CBasePropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CResourceAdvancedPage)
    DDX_Control(pDX, IDC_PP_RES_AFFECT_THE_GROUP, m_ckbAffectTheGroup);
    DDX_Control(pDX, IDC_PP_RES_PENDING_TIMEOUT, m_editPendingTimeout);
    DDX_Control(pDX, IDC_PP_RES_DEFAULT_LOOKS_ALIVE, m_rbDefaultLooksAlive);
    DDX_Control(pDX, IDC_PP_RES_SPECIFY_LOOKS_ALIVE, m_rbSpecifyLooksAlive);
    DDX_Control(pDX, IDC_PP_RES_DEFAULT_IS_ALIVE, m_rbDefaultIsAlive);
    DDX_Control(pDX, IDC_PP_RES_SPECIFY_IS_ALIVE, m_rbSpecifyIsAlive);
    DDX_Control(pDX, IDC_PP_RES_LOOKS_ALIVE, m_editLooksAlive);
    DDX_Control(pDX, IDC_PP_RES_IS_ALIVE, m_editIsAlive);
    DDX_Control(pDX, IDC_PP_RES_DONT_RESTART, m_rbDontRestart);
    DDX_Control(pDX, IDC_PP_RES_RESTART, m_rbRestart);
    DDX_Control(pDX, IDC_PP_RES_RESTART_THRESHOLD, m_editThreshold);
    DDX_Control(pDX, IDC_PP_RES_RESTART_PERIOD, m_editPeriod);
    DDX_Check(pDX, IDC_PP_RES_AFFECT_THE_GROUP, m_bAffectTheGroup);
    DDX_Radio(pDX, IDC_PP_RES_DONT_RESTART, m_nRestart);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        CString strValue;

        if (!BReadOnly())
        {
            if (m_nRestart == 1)
            {
                DDX_Number(
                    pDX,
                    IDC_PP_RES_RESTART_THRESHOLD,
                    m_nThreshold,
                    CLUSTER_RESOURCE_MINIMUM_RESTART_THRESHOLD,
                    CLUSTER_RESOURCE_MAXIMUM_RESTART_THRESHOLD
                    );
                DDX_Number(
                    pDX,
                    IDC_PP_RES_RESTART_PERIOD,
                    m_nPeriod,
                    CLUSTER_RESOURCE_MINIMUM_RESTART_PERIOD,
                    CLUSTER_RESOURCE_MAXIMUM_RESTART_PERIOD / 1000 // display units are seconds, stored units are milliseconds
                    );
            }  // if:  restart is enabled

            if (m_rbDefaultLooksAlive.GetCheck() == BST_CHECKED)
                m_nLooksAlive = CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL;
            else
                DDX_Number(
                    pDX,
                    IDC_PP_RES_LOOKS_ALIVE,
                    m_nLooksAlive,
                    CLUSTER_RESOURCE_MINIMUM_LOOKS_ALIVE,
                    CLUSTER_RESOURCE_MAXIMUM_LOOKS_ALIVE_UI
                    );

            if (m_rbDefaultIsAlive.GetCheck() == BST_CHECKED)
                m_nIsAlive = CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL;
            else
                DDX_Number(
                    pDX,
                    IDC_PP_RES_IS_ALIVE,
                    m_nIsAlive,
                    CLUSTER_RESOURCE_MINIMUM_IS_ALIVE,
                    CLUSTER_RESOURCE_MAXIMUM_IS_ALIVE_UI
                    );

            DDX_Number(
                pDX,
                IDC_PP_RES_PENDING_TIMEOUT,
                m_nPendingTimeout,
                CLUSTER_RESOURCE_MINIMUM_PENDING_TIMEOUT,
                CLUSTER_RESOURCE_MAXIMUM_PENDING_TIMEOUT / 1000 // display units are seconds, stored units are milliseconds
                );

            try
            {
                PciRes()->ValidateCommonProperties(
                                    PciRes()->StrDescription(),
                                    PciRes()->BSeparateMonitor(),
                                    m_nLooksAlive,
                                    m_nIsAlive,
                                    m_crraRestartAction,
                                    m_nThreshold,
                                    m_nPeriod * 1000, // display units are seconds, stored units are milliseconds
                                    m_nPendingTimeout * 1000 // display units are seconds, stored units are milliseconds
                                    );
            }  // try
            catch (CException * pe)
            {
                pe->ReportError();
                pe->Delete();
                pDX->Fail();
            }  // catch:  CException
        }  // if:  not read only
    }  // if:  saving data
    else
    {
        DDX_Number(
            pDX,
            IDC_PP_RES_RESTART_THRESHOLD,
            m_nThreshold,
            CLUSTER_RESOURCE_MINIMUM_RESTART_THRESHOLD,
            CLUSTER_RESOURCE_MAXIMUM_RESTART_THRESHOLD
            );
        DDX_Number(
            pDX,
            IDC_PP_RES_RESTART_PERIOD,
            m_nPeriod,
            CLUSTER_RESOURCE_MINIMUM_RESTART_PERIOD,
            CLUSTER_RESOURCE_MAXIMUM_RESTART_PERIOD / 1000 // display units are seconds, stored units are milliseconds
            );
        if (m_nRestart == 0)
        {
            m_rbDontRestart.SetCheck(BST_CHECKED);
            m_rbRestart.SetCheck(BST_UNCHECKED);
            OnClickedDontRestart();
        }  // if:  Don't Restart selected
        else
        {
            m_rbDontRestart.SetCheck(BST_UNCHECKED);
            m_rbRestart.SetCheck(BST_CHECKED);
            OnClickedRestart();
        }  // else:  Restart selected

        if (m_nLooksAlive == (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL)
        {
            DWORD   nLooksAlive;
            
            if (PciRes()->PciResourceType() == NULL)
            {
                m_rbDefaultLooksAlive.EnableWindow(FALSE);
                m_rbSpecifyLooksAlive.EnableWindow(FALSE);
                m_editLooksAlive.EnableWindow(FALSE);
                m_editLooksAlive.SetWindowText(_T(""));
            }  // if:  no resource type
            else
            {
                ASSERT_VALID(PciRes()->PciResourceType());
                nLooksAlive = PciRes()->PciResourceType()->NLooksAlive();
                DDX_Text(pDX, IDC_PP_RES_LOOKS_ALIVE, nLooksAlive);
                m_editLooksAlive.SetReadOnly();
            }  // else:  resource type known
            m_rbDefaultLooksAlive.SetCheck(BST_CHECKED);
            m_rbSpecifyLooksAlive.SetCheck(BST_UNCHECKED);
        }  // if:  using default
        else
        {
            m_rbDefaultLooksAlive.SetCheck(BST_UNCHECKED);
            m_rbSpecifyLooksAlive.SetCheck(BST_CHECKED);
            DDX_Number(
                pDX,
                IDC_PP_RES_LOOKS_ALIVE,
                m_nLooksAlive,
                CLUSTER_RESOURCE_MINIMUM_LOOKS_ALIVE,
                CLUSTER_RESOURCE_MAXIMUM_LOOKS_ALIVE_UI
                );
            m_editLooksAlive.SetReadOnly(FALSE);
        }  // if:  not using default

        if (m_nIsAlive == (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL)
        {
            DWORD   nIsAlive;
            
            if (PciRes()->PciResourceType() == NULL)
            {
                m_rbDefaultIsAlive.EnableWindow(FALSE);
                m_rbSpecifyIsAlive.EnableWindow(FALSE);
                m_editIsAlive.EnableWindow(FALSE);
                m_editIsAlive.SetWindowText(_T(""));
            }  // if:  no resource type
            else
            {
                ASSERT_VALID(PciRes()->PciResourceType());
                nIsAlive = PciRes()->PciResourceType()->NIsAlive();
                DDX_Text(pDX, IDC_PP_RES_IS_ALIVE, nIsAlive);
                m_editIsAlive.SetReadOnly();
            }  // else:  resource type known
            m_rbDefaultIsAlive.SetCheck(BST_CHECKED);
            m_rbSpecifyIsAlive.SetCheck(BST_UNCHECKED);
        }  // if:  using default
        else
        {
            m_rbDefaultIsAlive.SetCheck(BST_UNCHECKED);
            m_rbSpecifyIsAlive.SetCheck(BST_CHECKED);
            DDX_Number(
                pDX,
                IDC_PP_RES_IS_ALIVE,
                m_nIsAlive,
                CLUSTER_RESOURCE_MINIMUM_IS_ALIVE,
                CLUSTER_RESOURCE_MAXIMUM_IS_ALIVE_UI
                );
            m_editIsAlive.SetReadOnly(FALSE);
        }  // if:  not using default

        DDX_Number(
            pDX,
            IDC_PP_RES_PENDING_TIMEOUT,
            m_nPendingTimeout,
            CLUSTER_RESOURCE_MINIMUM_PENDING_TIMEOUT,
            CLUSTER_RESOURCE_MAXIMUM_PENDING_TIMEOUT / 1000 // display units are seconds, stored units are milliseconds
            );
    }  // else:  not saving data

}  //*** CResourceAdvancedPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceAdvancedPage::OnInitDialog(void)
{
    CBasePropertyPage::OnInitDialog();

    // If read-only, set all controls to be either disabled or read-only.
    if (BReadOnly())
    {
        m_rbDontRestart.EnableWindow(FALSE);
        m_rbRestart.EnableWindow(FALSE);
        m_ckbAffectTheGroup.EnableWindow(FALSE);
        m_editThreshold.SetReadOnly(TRUE);
        m_editPeriod.SetReadOnly(TRUE);
        m_rbDefaultLooksAlive.EnableWindow(FALSE);
        m_rbSpecifyLooksAlive.EnableWindow(FALSE);
        m_editLooksAlive.SetReadOnly(TRUE);
        m_rbDefaultIsAlive.EnableWindow(FALSE);
        m_rbSpecifyIsAlive.EnableWindow(FALSE);
        m_editIsAlive.SetReadOnly(TRUE);
        m_editPendingTimeout.SetReadOnly(TRUE);
    }  // if:  sheet is read-only

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CResourceAdvancedPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnApply
//
//  Routine Description:
//      Handler for when the Apply button is pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceAdvancedPage::OnApply(void)
{
    // Set the data from the page in the cluster item.
    try
    {
        CWaitCursor wc;

        if (m_nRestart == 0)
            m_crraRestartAction = ClusterResourceDontRestart;
        else if (m_bAffectTheGroup)
            m_crraRestartAction = ClusterResourceRestartNotify;
        else
            m_crraRestartAction = ClusterResourceRestartNoNotify;

        PciRes()->SetCommonProperties(
                            PciRes()->StrDescription(),
                            PciRes()->BSeparateMonitor(),
                            m_nLooksAlive,
                            m_nIsAlive,
                            m_crraRestartAction,
                            m_nThreshold,
                            m_nPeriod * 1000, // display units are seconds, stored units are milliseconds
                            m_nPendingTimeout * 1000 // display units are seconds, stored units are milliseconds
                            );
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CBasePropertyPage::OnApply();

}  //*** CResourceAdvancedPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnClickedDontRestart
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Don't Restart radio button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceAdvancedPage::OnClickedDontRestart(void)
{
    // Disable the restart parameter controls.
    m_ckbAffectTheGroup.EnableWindow(FALSE);
    m_editThreshold.EnableWindow(FALSE);
    m_editPeriod.EnableWindow(FALSE);

    // Call the base class method if the state changed.
    if (m_nRestart != 0)
    {
        CBasePropertyPage::OnChangeCtrl();
    }  // if:  state changed

}  //*** CResourceAdvancedPage::OnClickedDontRestart()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnClickedRestart
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Restart No Notify radio button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceAdvancedPage::OnClickedRestart(void)
{
    // Enable the restart parameter controls.
    m_ckbAffectTheGroup.EnableWindow(TRUE);
    m_editThreshold.EnableWindow(TRUE);
    m_editPeriod.EnableWindow(TRUE);

    // Call the base class method if the state changed.
    if (m_nRestart != 1)
    {
        m_ckbAffectTheGroup.SetCheck(BST_CHECKED);
        CBasePropertyPage::OnChangeCtrl();
    }  // if:  state changed

}  //*** CResourceAdvancedPage::OnClickedRestart()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnChangeLooksAlive
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Looks Alive edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceAdvancedPage::OnChangeLooksAlive(void)
{
    m_rbDefaultLooksAlive.SetCheck(BST_UNCHECKED);
    m_rbSpecifyLooksAlive.SetCheck(BST_CHECKED);

    CBasePropertyPage::OnChangeCtrl();

}  //*** CResourceAdvancedPage::OnChangeLooksAlive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnChangeIsAlive
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Is Alive edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceAdvancedPage::OnChangeIsAlive(void)
{
    m_rbDefaultIsAlive.SetCheck(BST_UNCHECKED);
    m_rbSpecifyIsAlive.SetCheck(BST_CHECKED);

    CBasePropertyPage::OnChangeCtrl();

}  //*** CResourceAdvancedPage::OnChangeIsAlive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnClickedDefaultLooksAlive
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Use Default Looks Alive radio button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceAdvancedPage::OnClickedDefaultLooksAlive(void)
{
    if (m_nLooksAlive != (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL)
    {
        CString str;

        str.Format(_T("%u"), PciRes()->PciResourceType()->NLooksAlive());
        m_editLooksAlive.SetWindowText(str);

        m_rbDefaultLooksAlive.SetCheck(BST_CHECKED);
        m_rbSpecifyLooksAlive.SetCheck(BST_UNCHECKED);
        m_editLooksAlive.SetReadOnly();

        CBasePropertyPage::OnChangeCtrl();
    }  // if:  value changed

}  //*** CResourceAdvancedPage::OnClickedDefaultLooksAlive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnClickedDefaultIsAlive
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Use Default Is Alive radio button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceAdvancedPage::OnClickedDefaultIsAlive(void)
{
    if (m_nIsAlive != (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL)
    {
        CString str;

        str.Format(_T("%u"), PciRes()->PciResourceType()->NIsAlive());
        m_editIsAlive.SetWindowText(str);

        m_rbDefaultIsAlive.SetCheck(BST_CHECKED);
        m_rbSpecifyIsAlive.SetCheck(BST_UNCHECKED);
        m_editIsAlive.SetReadOnly();

        CBasePropertyPage::OnChangeCtrl();
    }  // if:  value changed

}  //*** CResourceAdvancedPage::OnClickedDefaultIsAlive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnClickedSpecifyLooksAlive
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Specify Looks Alive radio button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceAdvancedPage::OnClickedSpecifyLooksAlive(void)
{
    m_editLooksAlive.SetReadOnly(FALSE);
    CBasePropertyPage::OnChangeCtrl();

}  //*** CResourceAdvancedPage::OnClickedSpecifyLooksAlive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnClickedSpecifyIsAlive
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Specify Is Alive radio button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceAdvancedPage::OnClickedSpecifyIsAlive(void)
{
    m_editIsAlive.SetReadOnly(FALSE);
    CBasePropertyPage::OnChangeCtrl();

}  //*** CResourceAdvancedPage::OnClickedSpecifyIsAlive()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\restprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ResTProp.cpp
//
//  Abstract:
//      Implementation of the resource type property sheet and pages.
//
//  Author:
//      David Potter (davidp)   May 14, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ResTProp.h"
#include "ResType.h"
#include "DDxDDv.h"
#include "HelpData.h"   // for g_rghelpmap*

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CResTypePropSheet
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CResTypePropSheet, CBasePropertySheet)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CResTypePropSheet, CBasePropertySheet)
    //{{AFX_MSG_MAP(CResTypePropSheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypePropSheet::CResTypePropSheet
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pci         [IN OUT] Cluster item whose properties are to be displayed.
//      pParentWnd  [IN OUT] Parent window for this property sheet.
//      iSelectPage [IN] Page to show first.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResTypePropSheet::CResTypePropSheet(
    IN OUT CWnd *           pParentWnd,
    IN UINT                 iSelectPage
    )
    : CBasePropertySheet(pParentWnd, iSelectPage)
{
    m_rgpages[0] = &PageGeneral();

}  //*** CResTypePropSheet::CResTypePropSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypePropSheet::BInit
//
//  Routine Description:
//      Initialize the property sheet.
//
//  Arguments:
//      pci         [IN OUT] Cluster item whose properties are to be displayed.
//      iimgIcon    [IN] Index in the large image list for the image to use
//                    as the icon on each page.
//
//  Return Value:
//      TRUE        Property sheet initialized successfully.
//      FALSE       Error initializing property sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResTypePropSheet::BInit(
    IN OUT CClusterItem *   pci,
    IN IIMG                 iimgIcon
    )
{
    // Call the base class method.
    if (!CBasePropertySheet::BInit(pci, iimgIcon))
        return FALSE;

    // Set the read-only flag.
    m_bReadOnly = PciResType()->BReadOnly();

    return TRUE;

}  //*** CResTypePropSheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypePropSheet::Ppages
//
//  Routine Description:
//      Returns the array of pages to add to the property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Page array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage ** CResTypePropSheet::Ppages(void)
{
    return m_rgpages;

}  //*** CResTypePropSheet::Ppages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypePropSheet::Cpages
//
//  Routine Description:
//      Returns the count of pages in the array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Count of pages in the array.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CResTypePropSheet::Cpages(void)
{
    return sizeof(m_rgpages) / sizeof(CBasePropertyPage *);

}  //*** CResTypePropSheet::Cpages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CResTypeGeneralPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CResTypeGeneralPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CResTypeGeneralPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CResTypeGeneralPage)
    ON_EN_KILLFOCUS(IDC_PP_RESTYPE_DISPLAY_NAME, OnKillFocusDisplayName)
    ON_LBN_DBLCLK(IDC_PP_RESTYPE_POSSIBLE_OWNERS, OnDblClkPossibleOwners)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
    ON_EN_CHANGE(IDC_PP_RESTYPE_DISPLAY_NAME, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_RESTYPE_DESC, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_RESTYPE_LOOKS_ALIVE, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_RESTYPE_IS_ALIVE, CBasePropertyPage::OnChangeCtrl)
    ON_COMMAND(ID_FILE_PROPERTIES, OnProperties)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGeneralPage::CResTypeGeneralPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResTypeGeneralPage::CResTypeGeneralPage(void)
    : CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_RESTYPE_GENERAL)
{
    //{{AFX_DATA_INIT(CResTypeGeneralPage)
    m_strDisplayName = _T("");
    m_strDesc = _T("");
    m_strName = _T("");
    m_strResDLL = _T("");
    m_strQuorumCapable = _T("");
    //}}AFX_DATA_INIT

}  //*** CResTypeGeneralPage::CResTypePropSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailoverPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      psht        [IN OUT] Property sheet to which this page belongs.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResTypeGeneralPage::BInit(IN OUT CBaseSheet * psht)
{
    BOOL    bSuccess;

    ASSERT_KINDOF(CResTypePropSheet, psht);

    bSuccess = CBasePropertyPage::BInit(psht);

    if (bSuccess)
    {
        m_strDisplayName = PciResType()->StrDisplayName();
        m_strDesc = PciResType()->StrDescription();
        m_nLooksAlive = PciResType()->NLooksAlive();
        m_nIsAlive = PciResType()->NIsAlive();
        m_strName = PciResType()->StrName();
        m_strResDLL = PciResType()->StrResDLLName();
        if (PciResType()->BQuorumCapable())
            m_strQuorumCapable.LoadString(IDS_YES);
        else
            m_strQuorumCapable.LoadString(IDS_NO);

        // Duplicate the possible owners list.
        {
            POSITION        pos;
            CClusterNode *  pciNode;

            pos = PciResType()->LpcinodePossibleOwners().GetHeadPosition();
            while (pos != NULL)
            {
                pciNode = (CClusterNode *) PciResType()->LpcinodePossibleOwners().GetNext(pos);
                ASSERT_VALID(pciNode);
                m_lpciPossibleOwners.AddTail(pciNode);
            }  // while:  more nodes in the list
        }  // Duplicate the possible owners list
    } // if:  base class method was successful

    return bSuccess;

}  //*** CResTypeGeneralPage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGeneralPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResTypeGeneralPage::DoDataExchange(CDataExchange * pDX)
{
    CString strValue;

    CBasePropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CResTypeGeneralPage)
    DDX_Control(pDX, IDC_PP_RESTYPE_QUORUM_CAPABLE, m_editQuorumCapable);
    DDX_Control(pDX, IDC_PP_RESTYPE_RESDLL, m_editResDLL);
    DDX_Control(pDX, IDC_PP_RESTYPE_NAME, m_editName);
    DDX_Control(pDX, IDC_PP_RESTYPE_POSSIBLE_OWNERS, m_lbPossibleOwners);
    DDX_Control(pDX, IDC_PP_RESTYPE_IS_ALIVE, m_editIsAlive);
    DDX_Control(pDX, IDC_PP_RESTYPE_LOOKS_ALIVE, m_editLooksAlive);
    DDX_Control(pDX, IDC_PP_RESTYPE_DESC, m_editDesc);
    DDX_Control(pDX, IDC_PP_RESTYPE_DISPLAY_NAME, m_editDisplayName);
    DDX_Text(pDX, IDC_PP_RESTYPE_NAME, m_strName);
    DDX_Text(pDX, IDC_PP_RESTYPE_DISPLAY_NAME, m_strDisplayName);
    DDX_Text(pDX, IDC_PP_RESTYPE_DESC, m_strDesc);
    DDX_Text(pDX, IDC_PP_RESTYPE_RESDLL, m_strResDLL);
    DDX_Text(pDX, IDC_PP_RESTYPE_QUORUM_CAPABLE, m_strQuorumCapable);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (!BReadOnly())
        {
            DDX_Number(pDX, IDC_PP_RESTYPE_LOOKS_ALIVE, m_nLooksAlive, 10, 0xffffffff);
            DDX_Number(pDX, IDC_PP_RESTYPE_IS_ALIVE, m_nIsAlive, 10, 0xffffffff);

            try
            {
                PciResType()->ValidateCommonProperties(
                                    m_strDisplayName,
                                    m_strDesc,
                                    m_nLooksAlive,
                                    m_nIsAlive
                                    );
            }  // try
            catch (CException * pe)
            {
                pe->ReportError();
                pe->Delete();
                pDX->Fail();
            }  // catch:  CException
        }  // if:  not read only
    }  // if:  saving data
    else
    {
        if (PciResType()->BAvailable())
        {
            DDX_Number(pDX, IDC_PP_RESTYPE_LOOKS_ALIVE, m_nLooksAlive, CLUSTER_RESTYPE_MINIMUM_LOOKS_ALIVE, CLUSTER_RESTYPE_MAXIMUM_LOOKS_ALIVE);
            DDX_Number(pDX, IDC_PP_RESTYPE_IS_ALIVE, m_nIsAlive, CLUSTER_RESTYPE_MINIMUM_IS_ALIVE, CLUSTER_RESTYPE_MAXIMUM_IS_ALIVE);
        } // if:  resource type properties are available
        else
        {
            m_editLooksAlive.SetWindowText(_T(""));
            m_editIsAlive.SetWindowText(_T(""));
            m_editQuorumCapable.SetWindowText(_T(""));
        } // else:  resource type properties are NOT available
        FillPossibleOwners();
    }  // else:  setting data to dialog

}  //*** CResTypeGeneralPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGeneralPage::FillPossibleOwners
//
//  Routine Description:
//      Fill the Possible Owners list box.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResTypeGeneralPage::FillPossibleOwners(void)
{
    POSITION        posPci;
    CClusterNode *  pciNode;
    int             iitem;

    m_lbPossibleOwners.ResetContent();

    posPci = LpciPossibleOwners().GetHeadPosition();
    while (posPci != NULL)
    {
        pciNode = (CClusterNode *) LpciPossibleOwners().GetNext(posPci);
        iitem = m_lbPossibleOwners.AddString(pciNode->StrName());
        if (iitem >= 0)
            m_lbPossibleOwners.SetItemDataPtr(iitem, pciNode);
    }  // for:  each string in the list

}  //*** CResTypeGeneralPage::FillPossibleOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGeneralPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResTypeGeneralPage::OnInitDialog(void)
{
    CBasePropertyPage::OnInitDialog();

    // Set the static edit controls ReadOnly
    m_editName.SetReadOnly(TRUE);
    m_editResDLL.SetReadOnly(TRUE);
    m_editQuorumCapable.SetReadOnly(TRUE);

    // If read-only, set all controls to be either disabled or read-only.
    if (BReadOnly())
    {
        m_editDisplayName.SetReadOnly(TRUE);
        m_editDesc.SetReadOnly(TRUE);
        m_editLooksAlive.SetReadOnly(TRUE);
        m_editIsAlive.SetReadOnly(TRUE);
    }  // if:  sheet is read-only

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CResTypeGeneralPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGeneralPage::OnApply
//
//  Routine Description:
//      Handler for the PSN_APPLY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResTypeGeneralPage::OnApply(void)
{
    // Set the data from the page in the cluster item.
    try
    {
        CWaitCursor wc;

        PciResType()->SetCommonProperties(
                        m_strDisplayName,
                        m_strDesc,
                        m_nLooksAlive,
                        m_nIsAlive
                        );
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CBasePropertyPage::OnApply();

}  //*** CResTypeGeneralPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGeneralPage::OnKillFocusDisplayName
//
//  Routine Description:
//      Handler for the WM_KILLFOCUS message on the Display Name edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResTypeGeneralPage::OnKillFocusDisplayName(void)
{
    CString     strName;

    m_editDisplayName.GetWindowText(strName);
    SetObjectTitle(strName);
    Ppsht()->SetCaption(strName);

}  //*** CResTypeGeneralPage::OnKillFocusDisplayName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGeneralPage::OnProperties
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Properties button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResTypeGeneralPage::OnProperties(void)
{
    int             iitem;
    CClusterNode *  pciNode;

    // Get the item with the focus.
    iitem = m_lbPossibleOwners.GetCurSel();
    ASSERT(iitem >= 0);

    if (iitem >= 0)
    {
        // Get the node pointer.
        pciNode = (CClusterNode *) m_lbPossibleOwners.GetItemDataPtr(iitem);
        ASSERT_VALID(pciNode);

        // Set properties of that item.
        if (pciNode->BDisplayProperties())
        {
        }  // if:  properties changed
    }  // if:  found an item with focus

}  //*** CResTypeGeneralPage::OnProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGeneralPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResTypeGeneralPage::OnContextMenu(CWnd * pWnd, CPoint point)
{
    BOOL            bHandled    = FALSE;
    CMenu *         pmenu       = NULL;
    CListBox *      pListBox    = (CListBox *) pWnd;
    CString         strMenuName;
    CWaitCursor     wc;

    // If focus is not in the list control, don't handle the message.
    if (pWnd == &m_lbPossibleOwners)
    {
        // Create the menu to display.
        try
        {
            pmenu = new CMenu;
            if (pmenu->CreatePopupMenu())
            {
                UINT    nFlags  = MF_STRING;

                // If there are no items in the list, disable the menu item.
                if (pListBox->GetCount() == 0)
                    nFlags |= MF_GRAYED;

                // Add the Properties item to the menu.
                strMenuName.LoadString(IDS_MENU_PROPERTIES);
                if (pmenu->AppendMenu(nFlags, ID_FILE_PROPERTIES, strMenuName))
                {
                    bHandled = TRUE;
                    if (pListBox->GetCurSel() == -1)
                        pListBox->SetCurSel(0);
                }  // if:  successfully added menu item
            }  // if:  menu created successfully
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
    }  // if:  focus is on list control

    if (bHandled)
    {
        // Display the menu.
        if (!pmenu->TrackPopupMenu(
                        TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                        point.x,
                        point.y,
                        this
                        ))
        {
        }  // if:  unsuccessfully displayed the menu
    }  // if:  there is a menu to display
    else
        CBasePropertyPage::OnContextMenu(pWnd, point);

    delete pmenu;

}  //*** CResTypeGeneralPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResTypeGeneralPage::OnDblClkPossibleOwners
//
//  Routine Description:
//      Handler for the LBN_DBLCLK message on the Possible Owners listbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResTypeGeneralPage::OnDblClkPossibleOwners(void)
{
    OnProperties();

}  //*** CResTypeGeneralPage::OnDblClkPossibleOwners()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\restprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ResTProp.cpp
//
//	Abstract:
//		Definition of the resource type property sheet and pages.
//
//	Author:
//		David Potter (davidp)	May 14, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESTPROP_H_
#define _RESTPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePPag.h"	// for CBasePropertyPage
#endif

#ifndef _BASESHT_H_
#include "BasePSht.h"	// for CBasePropertySheet
#endif

#ifndef _NODE_H_
#include "Node.h"		// for CNodeList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CResTypeGeneralPage;
class CResTypePropSheet;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CResourceType;

/////////////////////////////////////////////////////////////////////////////
// CClusterGeneralPage dialog
/////////////////////////////////////////////////////////////////////////////

class CResTypeGeneralPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CResTypeGeneralPage)

// Construction
public:
	CResTypeGeneralPage(void);

	virtual	BOOL			BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CResTypeGeneralPage)
	enum { IDD = IDD_PP_RESTYPE_GENERAL };
	CEdit	m_editQuorumCapable;
	CEdit	m_editResDLL;
	CEdit	m_editName;
	CListBox	m_lbPossibleOwners;
	CEdit	m_editIsAlive;
	CEdit	m_editLooksAlive;
	CEdit	m_editDisplayName;
	CEdit	m_editDesc;
	CString	m_strDisplayName;
	CString	m_strDesc;
	CString	m_strName;
	CString	m_strResDLL;
	CString	m_strQuorumCapable;
	//}}AFX_DATA
	DWORD	m_nLooksAlive;
	DWORD	m_nIsAlive;

	CNodeList				m_lpciPossibleOwners;

	const CNodeList &		LpciPossibleOwners(void) const	{ return m_lpciPossibleOwners; }

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CResTypeGeneralPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CResTypePropSheet *		PshtResType(void)	{ return (CResTypePropSheet *) Psht(); }
	CResourceType *			PciResType(void)	{ return (CResourceType *) Pci(); }

	void					FillPossibleOwners(void);

	// Generated message map functions
	//{{AFX_MSG(CResTypeGeneralPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnKillFocusDisplayName();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnDblClkPossibleOwners();
	//}}AFX_MSG
	afx_msg void OnProperties();
	DECLARE_MESSAGE_MAP()

};  //*** class CResTypeGeneralPage

/////////////////////////////////////////////////////////////////////////////
// CResTypePropSheet
/////////////////////////////////////////////////////////////////////////////

class CResTypePropSheet : public CBasePropertySheet
{
	DECLARE_DYNAMIC(CResTypePropSheet)

// Construction
public:
	CResTypePropSheet(
		IN OUT CWnd *	pParentWnd = NULL,
		IN UINT			iSelectPage = 0
		);
	virtual BOOL					BInit(
										IN OUT CClusterItem *	pciCluster,
										IN IIMG					iimgIcon
										);

// Attributes
protected:
	CBasePropertyPage *				m_rgpages[1];

	// Pages
	CResTypeGeneralPage				m_pageGeneral;

	CResTypeGeneralPage &			PageGeneral(void)		{ return m_pageGeneral; }

public:
	CResourceType *					PciResType(void) const	{ return (CResourceType *) Pci(); }

	virtual CBasePropertyPage **	Ppages(void);
	virtual int						Cpages(void);

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CResTypePropSheet)
	//}}AFX_VIRTUAL

// Implementation
public:

	// Generated message map functions
protected:
	//{{AFX_MSG(CResTypePropSheet)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CResTypePropSheet

/////////////////////////////////////////////////////////////////////////////

#endif // _RESTPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\restype.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ResType.cpp
//
//  Abstract:
//      Implementation of the CResourceType class.
//
//  Author:
//      David Potter (davidp)   May 6, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "ResType.h"
#include "Node.h"
#include "ClusItem.inl"
#include "ResTProp.h"
#include "ExcOper.h"
#include "TraceTag.h"
#include "Cluster.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagResType( _T("Document"), _T("RESOURCE TYPE"), 0 );
CTraceTag   g_tagResTypeNotify( _T("Notify"), _T("RESTYPE NOTIFY"), 0 );
#endif

/////////////////////////////////////////////////////////////////////////////
// CResourceType
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE( CResourceType, CClusterItem )

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP( CResourceType, CClusterItem )
    //{{AFX_MSG_MAP(CResourceType)
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::CResourceType
//
//  Routine Description:
//      Default construtor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResourceType::CResourceType( void ) : CClusterItem( NULL, IDS_ITEMTYPE_RESTYPE )
{
    m_idmPopupMenu = IDM_RESTYPE_POPUP;

    m_nLooksAlive = CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE;
    m_nIsAlive = CLUSTER_RESTYPE_DEFAULT_IS_ALIVE;

    m_rciResClassInfo.rc = CLUS_RESCLASS_UNKNOWN;
    m_rciResClassInfo.SubClass = 0;
    m_dwCharacteristics = CLUS_CHAR_UNKNOWN;
    m_dwFlags = 0;
    m_bAvailable = FALSE;

    m_plpcinodePossibleOwners = NULL;

    m_bPossibleOwnersAreFake = FALSE;

    // Set the object type and state images.
    m_iimgObjectType = GetClusterAdminApp()->Iimg( IMGLI_RESTYPE );
    m_iimgState = m_iimgObjectType;

    // Setup the property array.
    {
        m_rgProps[ epropDisplayName ].Set( CLUSREG_NAME_RESTYPE_NAME, m_strDisplayName, m_strDisplayName );
        m_rgProps[ epropDllName ].Set( CLUSREG_NAME_RESTYPE_DLL_NAME, m_strResDLLName, m_strResDLLName );
        m_rgProps[ epropDescription ].Set( CLUSREG_NAME_RESTYPE_DESC, m_strDescription, m_strDescription );
        m_rgProps[ epropLooksAlive ].Set( CLUSREG_NAME_RESTYPE_LOOKS_ALIVE, m_nLooksAlive, m_nLooksAlive );
        m_rgProps[ epropIsAlive ].Set( CLUSREG_NAME_RESTYPE_IS_ALIVE, m_nIsAlive, m_nIsAlive );
    }  // Setup the property array

}  //*** CResourceType::CResourceType()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::~CResourceType
//
//  Routine Description:
//      Destrutor
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResourceType::~CResourceType( void )
{
    // Cleanup this object.
    Cleanup();

    delete m_plpcinodePossibleOwners;

}  //*** CResourceType::~CResourceType()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::Cleanup
//
//  Routine Description:
//      Cleanup the item.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::Cleanup( void )
{
    POSITION    posPci;

    // Delete the PossibleOwners list.
    if ( m_plpcinodePossibleOwners != NULL )
    {
        m_plpcinodePossibleOwners->RemoveAll();
    } // if: possible owners have been allocated

    // Remove the item from the resource type list.
    posPci = Pdoc()->LpciResourceTypes().Find( this );
    if ( posPci != NULL )
    {
        Pdoc()->LpciResourceTypes().RemoveAt( posPci );
    }  // if:  found in the document's list

}  //*** CResourceType::Cleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::Init
//
//  Routine Description:
//      Initialize the item.
//
//  Arguments:
//      pdoc        [IN OUT] Document to which this item belongs.
//      lpszName    [IN] Name of the item.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from GetClusterResourceTypeKey.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::Init( IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName )
{
    DWORD       dwStatus = ERROR_SUCCESS;
    LONG        lResult;
    CWaitCursor wc;

    ASSERT( Hkey() == NULL );

    // Call the base class method.
    CClusterItem::Init( pdoc, lpszName );

    try
    {
        // Open the resource type.
        m_hkey = GetClusterResourceTypeKey( Hcluster(), lpszName, MAXIMUM_ALLOWED );
        if ( Hkey() == NULL )
        {
            ThrowStaticException( GetLastError(), IDS_GET_RESTYPE_KEY_ERROR, lpszName );
        } // if: error getting the resource type key

        ASSERT( Pcnk() != NULL );
        Trace( g_tagClusItemNotify, _T("CResourceType::Init() - Registering for resource type notifications (%08.8x) for '%s'"), Pcnk(), StrName() );

        // Register for registry notifications.
        if ( Hkey() != NULL )
        {
            lResult = RegisterClusterNotify(
                                GetClusterAdminApp()->HchangeNotifyPort(),
                                (CLUSTER_CHANGE_REGISTRY_NAME
                                    | CLUSTER_CHANGE_REGISTRY_ATTRIBUTES
                                    | CLUSTER_CHANGE_REGISTRY_VALUE
                                    | CLUSTER_CHANGE_REGISTRY_SUBTREE),
                                Hkey(),
                                (DWORD_PTR) Pcnk()
                                );
            if ( lResult != ERROR_SUCCESS )
            {
                dwStatus = lResult;
                ThrowStaticException( dwStatus, IDS_RESTYPE_NOTIF_REG_ERROR, lpszName );
            }  // if:  error registering for registry notifications
        }  // if:  there is a key

        // Allocate lists.
        m_plpcinodePossibleOwners = new CNodeList;
        if ( m_plpcinodePossibleOwners == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the node list

        // Read the initial state.
        UpdateState();
    }  // try
    catch ( CException * )
    {
        if ( Hkey() != NULL )
        {
            ClusterRegCloseKey( Hkey() );
            m_hkey = NULL;
        }  // if:  registry key opened
        m_bReadOnly = TRUE;
        throw;
    }  // catch:  CException

}  //*** CResourceType::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::ReadItem
//
//  Routine Description:
//      Read the item parameters from the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue() or
//                              CResourceType::ConstructResourceList().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::ReadItem( void )
{
    DWORD       dwStatus;
    DWORD       dwRetStatus = ERROR_SUCCESS;
    CWaitCursor wc;

    ASSERT_VALID( this );
    ASSERT( Hcluster() != NULL );

    if ( Hcluster() != NULL )
    {
        m_rgProps[ epropDisplayName ].m_value.pstr = (CString *) &m_strDisplayName;
        m_rgProps[ epropDescription ].m_value.pstr = (CString *) &m_strDescription;
        m_rgProps[ epropLooksAlive ].m_value.pdw = &m_nLooksAlive;
        m_rgProps[ epropIsAlive ].m_value.pdw = &m_nIsAlive;

        // Call the base class method.
        CClusterItem::ReadItem();

        // Read and parse the common properties.
        {
            CClusPropList   cpl;

            dwStatus = cpl.ScGetResourceTypeProperties(
                                Hcluster(),
                                StrName(),
                                CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES
                                );
            if ( dwStatus == ERROR_SUCCESS )
            {
                dwStatus = DwParseProperties( cpl );
            } // if: properties read successfully
            if ( dwStatus != ERROR_SUCCESS )
            {
                dwRetStatus = dwStatus;
            } // if: error reading or parsing properties
        }  // Read and parse the common properties

        // Read and parse the read-only common properties.
        if ( dwRetStatus == ERROR_SUCCESS )
        {
            CClusPropList   cpl;

            dwStatus = cpl.ScGetResourceTypeProperties(
                                Hcluster(),
                                StrName(),
                                CLUSCTL_RESOURCE_TYPE_GET_RO_COMMON_PROPERTIES
                                );
            if ( dwStatus == ERROR_SUCCESS )
            {
                dwStatus = DwParseProperties( cpl );
            } // if: properties read successfully
            if ( dwStatus != ERROR_SUCCESS )
            {
                dwRetStatus = dwStatus;
            } // if: error reading or parsing properties
        }  // if:  no error yet

        // Read the resource class information.
        if ( dwRetStatus == ERROR_SUCCESS )
        {
            DWORD   cbReturned;

            dwStatus = ClusterResourceTypeControl(
                            Hcluster(),
                            StrName(),
                            NULL,
                            CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO,
                            NULL,
                            NULL,
                            &m_rciResClassInfo,
                            sizeof( m_rciResClassInfo ),
                            &cbReturned
                            );
            if ( dwStatus != ERROR_SUCCESS )
            {
                dwRetStatus = dwStatus;
            } // if: error getting class info
            else
            {
                ASSERT( cbReturned == sizeof( m_rciResClassInfo ) );
            }  // else:  data retrieved successfully
        }  // if:  no error yet

        // Read the characteristics.
        if ( dwRetStatus == ERROR_SUCCESS )
        {
            DWORD   cbReturned;

            dwStatus = ClusterResourceTypeControl(
                            Hcluster(),
                            StrName(),
                            NULL,
                            CLUSCTL_RESOURCE_TYPE_GET_CHARACTERISTICS,
                            NULL,
                            NULL,
                            &m_dwCharacteristics,
                            sizeof( m_dwCharacteristics ),
                            &cbReturned
                            );
            if ( dwStatus != ERROR_SUCCESS )
            {
                dwRetStatus = dwStatus;
            } // if: error getting characteristics
            else
            {
                ASSERT( cbReturned == sizeof( m_dwCharacteristics ) );
            }  // else:  data retrieved successfully
        }  // if:  no error yet

        // Read the flags.
        if ( dwRetStatus == ERROR_SUCCESS )
        {
            DWORD   cbReturned;

            dwStatus = ClusterResourceTypeControl(
                            Hcluster(),
                            StrName(),
                            NULL,
                            CLUSCTL_RESOURCE_TYPE_GET_FLAGS,
                            NULL,
                            NULL,
                            &m_dwFlags,
                            sizeof( m_dwFlags ),
                            &cbReturned
                            );
            if ( dwStatus != ERROR_SUCCESS )
            {
                dwRetStatus = dwStatus;
            } // if: error getting flags
            else
            {
                ASSERT( cbReturned == sizeof( m_dwFlags ) );
            }  // else:  data retrieved successfully
        }  // if:  no error yet

        // Construct the list of extensions.
        ReadExtensions();

        if ( dwRetStatus == ERROR_SUCCESS )
        {
            // Construct the lists.
            CollectPossibleOwners();
        }  // if:  no error reading properties
    }  // if:  key is available

    // Set the image based on whether we were able to read the properties
    // or not.  If we weren't able to read the properties, read the display
    // name and DLL name so that we can clue the user in to the fact that
    // there is a problem.
    if ( dwRetStatus != ERROR_SUCCESS )
    {
        m_bAvailable = FALSE;
        m_iimgObjectType = GetClusterAdminApp()->Iimg( IMGLI_RESTYPE_UNKNOWN );
        if ( Hkey() != NULL )
        {
            DwReadValue( CLUSREG_NAME_RESTYPE_NAME, NULL, m_strDisplayName );
            DwReadValue( CLUSREG_NAME_RESTYPE_DLL_NAME, NULL, m_strResDLLName );
        } // if:  cluster database key is available
    } // if:  error reading properties
    else
    {
        m_bAvailable = TRUE;
        m_iimgObjectType = GetClusterAdminApp()->Iimg( IMGLI_RESTYPE );
    } // else:  no errors reading properties
    m_iimgState = m_iimgObjectType;

    // Read the initial state.
    UpdateState();

    // If any errors occurred, throw an exception.
    if ( dwRetStatus != ERROR_SUCCESS )
    {
        m_bReadOnly = TRUE;
        if ( dwRetStatus != ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND )
        {
            ThrowStaticException( dwRetStatus, IDS_READ_RESOURCE_TYPE_PROPS_ERROR, StrName() );
        } // if: error other than Resource Type Not Found occurred
    }  // if:  error reading properties

    MarkAsChanged( FALSE );

}  //*** CResourceType::ReadItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::PlstrExtensions
//
//  Routine Description:
//      Return the list of admin extensions.
//
//  Arguments:
//      None.
//
//  Return Value:
//      plstr       List of extensions.
//      NULL        No extension associated with this object.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CStringList * CResourceType::PlstrExtensions( void ) const
{
    return &LstrCombinedExtensions();

}  //*** CResourceType::PlstrExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::ReadExtensions
//
//  Routine Description:
//      Read extension lists.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Errors from CClusterItem::DwReadValue().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::ReadExtensions( void )
{
    DWORD       dwStatus;
    DWORD       dwRetStatus = ERROR_SUCCESS;
    CWaitCursor wc;

    if ( Hkey() != NULL )
    {
        // Read the Extension DLL name.
        dwStatus = DwReadValue( CLUSREG_NAME_ADMIN_EXT, NULL, m_lstrAdminExtensions );
        if ( ( dwStatus != ERROR_SUCCESS )
          && ( dwStatus != ERROR_FILE_NOT_FOUND ) )
        {
            dwRetStatus = dwStatus;
        } // if: error reading the value
    }  // if:  key is available
    else
    {
        m_lstrAdminExtensions.RemoveAll();
    } // else: key is not available

    // Construct the list of extensions.
    {
        POSITION            posStr;
        const CStringList * plstr;

        ASSERT_VALID( Pdoc() );

        m_lstrCombinedExtensions.RemoveAll();

        // Add resource type-specific extensions first.
        plstr = &LstrAdminExtensions();
        posStr = plstr->GetHeadPosition();
        while ( posStr != NULL )
        {
            m_lstrCombinedExtensions.AddTail( plstr->GetNext( posStr ) );
        }  // while:  more extensions available

        // Add extensions for all resource types next.
        plstr = &Pdoc()->PciCluster()->LstrResTypeExtensions();
        posStr = plstr->GetHeadPosition();
        while ( posStr != NULL )
        {
            m_lstrCombinedExtensions.AddTail( plstr->GetNext( posStr ) );
        }  // while:  more extensions available
    }  // Construct the list of extensions

    // Loop through all the resources of this type and ask them
    // to read their extensions.
    {
        POSITION    pos;
        CResource * pciRes;

        pos = Pdoc()->LpciResources().GetHeadPosition();
        while ( pos != NULL )
        {
            pciRes = (CResource *) Pdoc()->LpciResources().GetNext( pos );
            ASSERT_VALID( pciRes );
            if ( pciRes->PciResourceType() == this )
            {
                pciRes->ReadExtensions();
            } // if: found resource of this type
        }  // while:  more resources in the list
    }  // Read resource extensions

}  //*** CResourceType::ReadExtensions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::CollecPossibleOwners
//
//  Routine Description:
//      Construct a list of node items which are enumerable on the
//      resource type.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors from ClusterResourceTypeOpenEnum() or
//                        ClusterResourceTypeEnum().
//      Any exceptions thrown by new or CList::AddTail().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::CollectPossibleOwners( void )
{
    DWORD           dwStatus;
    HRESTYPEENUM    hrestypeenum;
    int             ienum;
    LPWSTR          pwszName = NULL;
    DWORD           cchName;
    DWORD           cchmacName;
    DWORD           dwRetType;
    CClusterNode *  pciNode;
    CWaitCursor     wc;

    ASSERT_VALID( Pdoc() );
    ASSERT( Hcluster() != NULL );

    ASSERT( m_plpcinodePossibleOwners != NULL );

    // Remove the previous contents of the list.
    m_plpcinodePossibleOwners->RemoveAll();

    // Indicate that we need to re-read resource type possible owners
    // when a node comes online or is added.
    m_bPossibleOwnersAreFake = TRUE;

    if ( Hcluster() != NULL )
    {
        // Open the enumeration.
        hrestypeenum = ClusterResourceTypeOpenEnum( Hcluster(), StrName(), CLUSTER_RESOURCE_TYPE_ENUM_NODES );
        if ( hrestypeenum == NULL )
        {
            dwStatus = GetLastError();
            if ( dwStatus != ERROR_NODE_NOT_AVAILABLE )
            {
                ThrowStaticException( dwStatus, IDS_ENUM_POSSIBLE_OWNERS_ERROR, StrName() );
            } // if: error other than other node not up occurred

            // Add all nodes to the list so that the user can manipulate
            // possible owners of resources of this type.
            AddAllNodesAsPossibleOwners();

        } // if: error opening the enumeration
        else
        {
            try
            {
                // Allocate a name buffer.
                cchmacName = 128;
                pwszName = new WCHAR[ cchmacName ];
                if ( pwszName == NULL )
                {
                    AfxThrowMemoryException();
                } // if: error allocating the name buffer

                // Loop through the enumeration and add each dependent resource to the list.
                for ( ienum = 0 ; ; ienum++ )
                {
                    // Get the next item in the enumeration.
                    cchName = cchmacName;
                    dwStatus = ClusterResourceTypeEnum( hrestypeenum, ienum, &dwRetType, pwszName, &cchName );
                    if ( dwStatus == ERROR_MORE_DATA )
                    {
                        delete [] pwszName;
                        cchmacName = ++cchName;
                        pwszName = new WCHAR[ cchmacName];
                        if ( pwszName == NULL )
                        {
                            AfxThrowMemoryException();
                        } // if: error allocating the name buffer
                        dwStatus = ClusterResourceTypeEnum( hrestypeenum, ienum, &dwRetType, pwszName, &cchName );
                    }  // if:  name buffer was too small
                    if ( dwStatus == ERROR_NO_MORE_ITEMS )
                    {
                        break;
                    } // if: reached the end of the list
                    else if ( dwStatus != ERROR_SUCCESS )
                    {
                        ThrowStaticException( dwStatus, IDS_ENUM_POSSIBLE_OWNERS_ERROR, StrName() );
                    } // if: error getting the next item occurred

                    ASSERT( dwRetType == CLUSTER_RESOURCE_TYPE_ENUM_NODES );

                    // Find the item in the list of resources on the document.
                    pciNode = Pdoc()->LpciNodes().PciNodeFromName( pwszName );
                    ASSERT_VALID( pciNode );

                    // Add the resource to the list.
                    if ( pciNode != NULL )
                    {
                        m_plpcinodePossibleOwners->AddTail( pciNode );
                    }  // if:  found node in list

                }  // for:  each item in the resource type

                delete [] pwszName;
                ClusterResourceTypeCloseEnum( hrestypeenum );

                // Indicate that we have a real possible owners list.
                m_bPossibleOwnersAreFake = FALSE;

            }  // try
            catch ( CException * )
            {
                delete [] pwszName;
                ClusterResourceTypeCloseEnum( hrestypeenum );
                throw;
            }  // catch:  any exception
        } // else: no error opening the enumeration
    }  // if:  resource is available

}  //*** CResourceType::CollecPossibleOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::AddAllNodesAsPossibleOwners
//
//  Routine Description:
//      Add all nodes as possible owners to the specified list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::AddAllNodesAsPossibleOwners( void )
{
    POSITION        pos;
    CClusterNode *  pciNode;

    pos = Pdoc()->LpciNodes().GetHeadPosition();
    while ( pos != NULL )
    {
        pciNode = (CClusterNode *) Pdoc()->LpciNodes().GetNext( pos );
        ASSERT_VALID( pciNode );
        m_plpcinodePossibleOwners->AddTail( pciNode );
    } // while: more nodes in the list

} //*** CResourceType::AddAllNodesAsPossibleOwners()
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::RemoveNodeFromPossibleOwners
//
//  Routine Description:
//      Remove the passed in node from the possible owners list.
//
//  Arguments:
//      plpci       [IN OUT] List to fill.
//      pNode       [IN] The node to remove from the list
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CList.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::RemoveNodeFromPossibleOwners(
    IN OUT      CNodeList *     plpci,
    IN const    CClusterNode *  pNode
    )
{
    if ( plpci == NULL )
    {
        plpci = m_plpcinodePossibleOwners;
    } // if: plpci is NULL

    ASSERT( plpci != NULL );

    POSITION        pos;
    CClusterNode *  pnode = plpci->PciNodeFromName( pNode->StrName(), &_pos );

    if ( ( pnode != NULL ) && ( pos != NULL ) )
    {
        plpci->RemoveAt( pos );
    } // if: node was found in the list

}  //*** CResourceType::RemoveNodeFromPossibleOwners()
*/
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::SetCommonProperties
//
//  Routine Description:
//      Set the parameters for this resource type in the cluster database.
//
//  Arguments:
//      rstrName        [IN] Display name string.
//      rstrDesc        [IN] Description string.
//      nLooksAlive     [IN] Looks Alive poll interval.
//      nIsAlive        [IN] Is Alive poll interval.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by WriteItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::SetCommonProperties(
    IN const CString &  rstrName,
    IN const CString &  rstrDesc,
    IN DWORD            nLooksAlive,
    IN DWORD            nIsAlive,
    IN BOOL             bValidateOnly
    )
{
    CNTException    nte(ERROR_SUCCESS, 0, NULL, NULL, FALSE /*bAutoDelete*/);

    m_rgProps[ epropDisplayName ].m_value.pstr = (CString *) &rstrName;
    m_rgProps[ epropDescription ].m_value.pstr = (CString *) &rstrDesc;
    m_rgProps[ epropLooksAlive ].m_value.pdw = &nLooksAlive;
    m_rgProps[ epropIsAlive ].m_value.pdw = &nIsAlive;

    try
    {
        CClusterItem::SetCommonProperties( bValidateOnly );
    } // try
    catch ( CNTException * pnte )
    {
        nte.SetOperation(
                    pnte->Sc(),
                    pnte->IdsOperation(),
                    pnte->PszOperArg1(),
                    pnte->PszOperArg2()
                    );
    } // catch: CNTException

    m_rgProps[ epropDisplayName ].m_value.pstr = (CString *) &m_strDisplayName;
    m_rgProps[ epropDescription ].m_value.pstr = (CString *) &m_strDescription;
    m_rgProps[ epropLooksAlive ].m_value.pdw = &m_nLooksAlive;
    m_rgProps[ epropIsAlive ].m_value.pdw = &m_nIsAlive;

    if ( nte.Sc() != ERROR_SUCCESS )
    {
        ThrowStaticException(
                        nte.Sc(),
                        nte.IdsOperation(),
                        nte.PszOperArg1(),
                        nte.PszOperArg2()
                        );
    } // if: error occurred

}  //*** CResourceType::SetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::DwSetCommonProperties
//
//  Routine Description:
//      Set the common properties for this resource type in the cluster database.
//
//  Arguments:
//      rcpl            [IN] Property list to set.
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Value:
//      Any status returned by ClusterResourceControl().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CResourceType::DwSetCommonProperties(
    IN const CClusPropList &    rcpl,
    IN BOOL                     bValidateOnly
    )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    ASSERT( Hcluster() );

    if ( ( rcpl.PbPropList() != NULL ) && ( rcpl.CbPropList() > 0 ) )
    {
        DWORD   cbProps;
        DWORD   dwControl;

        if ( bValidateOnly )
        {
            dwControl = CLUSCTL_RESOURCE_TYPE_VALIDATE_COMMON_PROPERTIES;
        } // if: only validating the properties
        else
        {
            dwControl = CLUSCTL_RESOURCE_TYPE_SET_COMMON_PROPERTIES;
        } // else: setting the properties

        // Set private properties.
        dwStatus = ClusterResourceTypeControl(
                        Hcluster(),
                        StrName(),
                        NULL,   // hNode
                        dwControl,
                        rcpl.PbPropList(),
                        rcpl.CbPropList(),
                        NULL,   // lpOutBuffer
                        0,      // nOutBufferSize
                        &cbProps
                        );
    }  // if:  there is data to set
    else
    {
        dwStatus = ERROR_SUCCESS;
    } // if: no data to be set

    return dwStatus;

}  //*** CResourceType::DwSetCommonProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::OnFinalRelease
//
//  Routine Description:
//      Called when the last OLE reference to or from the object is released.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::OnFinalRelease( void )
{
    // When the last reference for an automation object is released
    // OnFinalRelease is called.  The base class will automatically
    // deletes the object.  Add additional cleanup required for your
    // object before calling the base class.

    CClusterItem::OnFinalRelease();

}  //*** CResourceType::OnFinalRelease()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::BGetColumnData
//
//  Routine Description:
//      Returns a string with the column data.
//
//  Arguments:
//      colid           [IN] Column ID.
//      rstrText        [OUT] String in which to return the text for the column.
//
//  Return Value:
//      TRUE        Column data returned.
//      FALSE       Column ID not recognized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceType::BGetColumnData( IN COLID colid, OUT CString & rstrText )
{
    BOOL    bSuccess;

    switch ( colid )
    {
        case IDS_COLTEXT_DISPLAY_NAME:
            rstrText = StrDisplayName();
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_RESDLL:
            rstrText = StrResDLLName();
            bSuccess = TRUE;
            break;
        default:
            bSuccess = CClusterItem::BGetColumnData( colid, rstrText );
            break;
    }  // switch:  colid

    return bSuccess;

}  //*** CResourceType::BGetColumnData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::BCanBeEdited
//
//  Routine Description:
//      Determines if the resource can be renamed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Resource can be renamed.
//      FALSE       Resource cannot be renamed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceType::BCanBeEdited( void ) const
{
    return ! BReadOnly();

}  //*** CResourceType::BCanBeEdited()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::Rename
//
//  Routine Description:
//      Rename the resource.
//
//  Arguments:
//      pszName         [IN] New name to give to the resource.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException    Errors returned from SetClusterResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::Rename( IN LPCTSTR pszName )
{
    CString     strName;

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    if ( StrDisplayName() != pszName )
    {
        ID  idReturn;

        idReturn = AfxMessageBox( IDS_CHANGE_RES_TYPE_NAME_EFFECT, MB_YESNO | MB_ICONEXCLAMATION );
        if ( idReturn != IDYES )
        {
            Release();
            ThrowStaticException( (IDS) IDS_DISPLAY_NAME_NOT_CHANGED );
        }  // if:  user doesn't want to change the name
    }  // if:  display name changed

    strName = pszName;

    SetCommonProperties( strName, m_strDescription, m_nLooksAlive, m_nIsAlive );

    Release();

}  //*** CResourceType::Rename()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::OnUpdateProperties
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_PROPERTIES
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CResourceType::OnUpdateProperties( CCmdUI * pCmdUI )
{
    pCmdUI->Enable( TRUE );

}  //*** CResourceType::OnUpdateProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::BDisplayProperties
//
//  Routine Description:
//      Display properties for the object.
//
//  Arguments:
//      bReadOnly   [IN] Don't allow edits to the object properties.
//
//  Return Value:
//      TRUE    OK pressed.
//      FALSE   OK not pressed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CResourceType::BDisplayProperties( IN BOOL bReadOnly )
{
    BOOL                bChanged = FALSE;
    CResTypePropSheet   sht( AfxGetMainWnd() );

    // Do this in case this object is deleted while we are operating on it.
    AddRef();

    // If the object has changed, read it.
    if ( BChanged() )
    {
        ReadItem();
    } // if: the object has changed

    // Display the property sheet.
    try
    {
        sht.SetReadOnly( bReadOnly );
        if ( sht.BInit( this, IimgObjectType() ) )
        {
            bChanged = ( ( sht.DoModal() == IDOK ) && ! bReadOnly );
        } // if: initialized successfully
    }  // try
    catch ( CException * pe )
    {
        pe->Delete();
    }  // catch:  CException

    Release();
    return bChanged;

}  //*** CResourceType::BDisplayProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceType::OnClusterNotify
//
//  Routine Description:
//      Handler for the WM_CAM_CLUSTER_NOTIFY message.
//      Processes cluster notifications for this object.
//
//  Arguments:
//      pnotify     [IN OUT] Object describing the notification.
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CResourceType::OnClusterNotify( IN OUT CClusterNotify * pnotify )
{
    ASSERT( pnotify != NULL );
    ASSERT_VALID( this );

    try
    {
        switch ( pnotify->m_dwFilterType )
        {
            case CLUSTER_CHANGE_REGISTRY_NAME:
                Trace( g_tagResTypeNotify, _T("(%s) - Registry namespace '%s' changed (%s %s)"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName() );
                if ( Pdoc()->BClusterAvailable() )
                {
                    ReadItem();
                } // if: connection cluster is available
                break;

            case CLUSTER_CHANGE_REGISTRY_ATTRIBUTES:
                Trace( g_tagResTypeNotify, _T("(%s) - Registry attributes for '%s' changed (%s %s)"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName() );
                if ( Pdoc()->BClusterAvailable() )
                {
                    ReadItem();
                } // if: connection to cluster is available
                break;

            case CLUSTER_CHANGE_REGISTRY_VALUE:
                Trace( g_tagResTypeNotify, _T("(%s) - Registry value '%s' changed (%s %s)"), Pdoc()->StrNode(), pnotify->m_strName, StrType(), StrName() );
                if ( Pdoc()->BClusterAvailable() )
                {
                    ReadItem();
                } // if: connection to cluster is available
                break;

            default:
                Trace( g_tagResTypeNotify, _T("(%s) - Unknown resource type notification (%x) for '%s'"), Pdoc()->StrNode(), pnotify->m_dwFilterType, pnotify->m_strName );
        }  // switch:  dwFilterType
    }  // try
    catch ( CException * pe )
    {
        // Don't display anything on notification errors.
        // If it's really a problem, the user will see it when
        // refreshing the view.
        //pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    delete pnotify;
    return 0;

}  //*** CResourceType::OnClusterNotify()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DeleteAllItemData
//
//  Routine Description:
//      Deletes all item data in a CList.
//
//  Arguments:
//      rlp     [IN OUT] List whose data is to be deleted.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef NEVER
void DeleteAllItemData( IN OUT CResourceTypeList & rlp )
{
    POSITION        pos;
    CResourceType * pci;

    // Delete all the items in the Contained list.
    pos = rlp.GetHeadPosition();
    while ( pos != NULL )
    {
        pci = rlp.GetNext( pos );
        ASSERT_VALID( pci );
//      Trace( g_tagClusItemDelete, _T("DeleteAllItemData(rlpcirestype) - Deleting resource type cluster item '%s'"), pci->StrName() );
        pci->Delete();
    }  // while:  more items in the list

}  //*** DeleteAllItemData()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\restype.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      Res.h
//
//  Abstract:
//      Definition of the CResource class.
//
//  Author:
//      David Potter (davidp)   May 6, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESTYPE_H_
#define _RESTYPE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CResourceType;
class CResourceTypeList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNodeList;
class CClusterNode;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_
#include "ClusItem.h"   // for CClusterItem
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"   // for CObjectProperty, CClusPropList
#endif

/////////////////////////////////////////////////////////////////////////////
// CResourceType command target
/////////////////////////////////////////////////////////////////////////////

class CResourceType : public CClusterItem
{
    DECLARE_DYNCREATE( CResourceType )

    CResourceType( void );      // protected constructor used by dynamic creation
    void                    Init( IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName );

// Attributes
protected:
    CString                 m_strDisplayName;
    CString                 m_strResDLLName;
    CStringList             m_lstrAdminExtensions;
    DWORD                   m_nLooksAlive;
    DWORD                   m_nIsAlive;
    CLUS_RESOURCE_CLASS_INFO    m_rciResClassInfo;
    DWORD                   m_dwCharacteristics;
    DWORD                   m_dwFlags;
    BOOL                    m_bAvailable;

    CNodeList *             m_plpcinodePossibleOwners;

    enum
    {
        epropDisplayName = 0,
        epropDllName,
        epropDescription,
        epropLooksAlive,
        epropIsAlive,
        epropMAX
    };

    CObjectProperty         m_rgProps[ epropMAX ];

public:
    const CString &         StrDisplayName( void ) const        { return m_strDisplayName; }
    const CString &         StrResDLLName( void ) const         { return m_strResDLLName; }
    const CStringList &     LstrAdminExtensions( void ) const   { return m_lstrAdminExtensions; }
    DWORD                   NLooksAlive( void ) const           { return m_nLooksAlive; }
    DWORD                   NIsAlive( void ) const              { return m_nIsAlive; }
    CLUSTER_RESOURCE_CLASS  ResClass( void ) const              { return m_rciResClassInfo.rc; }
    PCLUS_RESOURCE_CLASS_INFO   PrciResClassInfo( void )        { return &m_rciResClassInfo; }
    DWORD                   DwCharacteristics( void ) const     { return m_dwCharacteristics; }
    DWORD                   DwFlags( void ) const               { return m_dwFlags; }
    BOOL                    BQuorumCapable( void ) const        { return (m_dwCharacteristics & CLUS_CHAR_QUORUM) != 0; }
    BOOL                    BAvailable( void ) const            { return m_bAvailable; }

    const CNodeList &       LpcinodePossibleOwners( void ) const
    {
        ASSERT( m_plpcinodePossibleOwners != NULL );
        return *m_plpcinodePossibleOwners;

    } //*** LpcinodePossibleOwners()


// Operations
public:
    void                    ReadExtensions( void );
    void                    CollectPossibleOwners( void );
    void                    AddAllNodesAsPossibleOwners( void );
//  void                    RemoveNodeFromPossibleOwners( IN OUT CNodeList * plpci, IN const CClusterNode * pNode );

    void                    SetCommonProperties(
                                IN const CString &  rstrName,
                                IN const CString &  rstrDesc,
                                IN DWORD            nLooksAlive,
                                IN DWORD            nIsAlive,
                                IN BOOL             bValidateOnly
                                );
    void                    SetCommonProperties(
                                IN const CString &  rstrName,
                                IN const CString &  rstrDesc,
                                IN DWORD            nLooksAlive,
                                IN DWORD            nIsAlive
                                )
    {
        SetCommonProperties( rstrName, rstrDesc, nLooksAlive, nIsAlive, FALSE /*bValidateOnly*/ );
    }
    void                    ValidateCommonProperties(
                                IN const CString &  rstrName,
                                IN const CString &  rstrDesc,
                                IN DWORD            nLooksAlive,
                                IN DWORD            nIsAlive
                                )
    {
        SetCommonProperties( rstrName, rstrDesc, nLooksAlive, nIsAlive, TRUE /*bValidateOnly*/ );
    }

// Overrides
public:
    virtual LPCTSTR         PszTitle( void ) const      { return m_strDisplayName; }
    virtual void            Cleanup( void );
    virtual void            ReadItem( void );
    virtual void            Rename( IN LPCTSTR pszName );
    virtual BOOL            BGetColumnData( IN COLID colid, OUT CString & rstrText );
    virtual BOOL            BCanBeEdited( void ) const;
    virtual BOOL            BDisplayProperties( IN BOOL bReadOnly = FALSE );

    virtual const CStringList * PlstrExtensions( void ) const;

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CResourceType)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

    virtual LRESULT         OnClusterNotify( IN OUT CClusterNotify * pnotify );

protected:
    virtual const CObjectProperty * Pprops( void ) const    { return m_rgProps; }
    virtual DWORD                   Cprops( void ) const    { return sizeof( m_rgProps ) / sizeof( CObjectProperty ); }
    virtual DWORD                   DwSetCommonProperties( IN const CClusPropList & rcpl, IN BOOL bValidateOnly = FALSE );

// Implementation
protected:
    CStringList             m_lstrCombinedExtensions;
    BOOL                    m_bPossibleOwnersAreFake;

    const CStringList &     LstrCombinedExtensions( void ) const    { return m_lstrCombinedExtensions; }

public:
    virtual                 ~CResourceType( void );
    BOOL                    BPossibleOwnersAreFake( void ) const    { return m_bPossibleOwnersAreFake; }

protected:
    // Generated message map functions
    //{{AFX_MSG(CResourceType)
    afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

};  //*** class CResourceType

/////////////////////////////////////////////////////////////////////////////
// CResourceTypeList
/////////////////////////////////////////////////////////////////////////////

class CResourceTypeList : public CClusterItemList
{
public:
    CResourceType * PciResTypeFromName(
                        IN LPCTSTR      pszName,
                        OUT POSITION *  ppos = NULL
                        )
    {
        return (CResourceType *) PciFromName( pszName, ppos );
    }

};  //*** class CResourceTypeList

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

//void DeleteAllItemData( IN OUT CResourceTypeList & rlp );

#ifdef _DEBUG
class CTraceTag;
extern CTraceTag g_tagResType;
extern CTraceTag g_tagResTypeNotify;
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _RESTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\resprop.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		ResProp.h
//
//	Abstract:
//		Definition of the resource property sheet and pages.
//
//	Author:
//		David Potter (davidp)	May 16, 1996
//
//	Implementation File:
//		ResProp.cpp
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESPROP_H_
#define _RESPROP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePPag.h"	// for CBasePropertyPage
#endif

#ifndef _BASESHT_H_
#include "BasePSht.h"	// for CBasePropertySheet
#endif

#ifndef _RES_H_
#include "Res.h"		// for CResource, RRA
#endif

#ifndef _NODE_H_
#include "Node.h"		// for CNodeList
#endif

#ifndef _LCPRPAGE_H_
#include "LCPrPage.h"	// for CListCtrlPairPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CResourceGeneralPage;
class CResourceDependsPage;
class CResourceAdvancedPage;
class CResourcePropSheet;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CResourceGeneralPage dialog
/////////////////////////////////////////////////////////////////////////////

class CResourceGeneralPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CResourceGeneralPage)

// Construction
public:
	CResourceGeneralPage(void);

	virtual	BOOL			BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CResourceGeneralPage)
	enum { IDD = IDD_PP_RES_GENERAL };
	CEdit	m_editDesc;
	CButton	m_ckbSeparateMonitor;
	CButton	m_pbPossibleOwnersModify;
	CListBox	m_lbPossibleOwners;
	CEdit	m_editName;
	CString	m_strName;
	CString	m_strDesc;
	CString	m_strType;
	CString	m_strGroup;
	CString	m_strState;
	CString	m_strNode;
	BOOL	m_bSeparateMonitor;
	//}}AFX_DATA

	CNodeList				m_lpciPossibleOwners;

	const CNodeList &		LpciPossibleOwners(void) const	{ return m_lpciPossibleOwners; }

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CResourceGeneralPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CResourcePropSheet *	PshtResource(void) const	{ return (CResourcePropSheet *) Psht(); }
	CResource *				PciRes(void) const			{ return (CResource *) Pci(); }

	void					FillPossibleOwners(void);

	// Generated message map functions
	//{{AFX_MSG(CResourceGeneralPage)
	afx_msg void OnModifyPossibleOwners();
	virtual BOOL OnInitDialog();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnDblClkPossibleOwners();
	//}}AFX_MSG
	afx_msg void OnProperties();
	DECLARE_MESSAGE_MAP()

};  //*** class CResourceGeneralPage

/////////////////////////////////////////////////////////////////////////////
// CResourceDependsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CResourceDependsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CResourceDependsPage)

// Construction
public:
	CResourceDependsPage(void);

	virtual	BOOL			BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CResourceDependsPage)
	enum { IDD = IDD_PP_RES_DEPENDS };
	CButton	m_pbProperties;
	CButton	m_pbModify;
	CListCtrl	m_lcDependencies;
	//}}AFX_DATA
	CResourceList			m_lpciresAvailable;
	CResourceList			m_lpciresDependencies;

	CResourceList &			LpciresAvailable(void)		{ return m_lpciresAvailable; }
	CResourceList &			LpciresDependencies(void)	{ return m_lpciresDependencies; }

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CResourceDependsPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Callback Functions
protected:
	static int CALLBACK		CompareItems(LPARAM lparam1, LPARAM lparam2, LPARAM lparamSort);

public:
	static BOOL CALLBACK	BGetNetworkName(
								OUT WCHAR *			lpszNetName,
								IN OUT DWORD *		pcchNetName,
								IN OUT PVOID		pvContext
								);

// Implementation
protected:
	BOOL					m_bQuorumResource;

	BOOL					BQuorumResource(void) const	{ return m_bQuorumResource; }

	CResourcePropSheet *	PshtResource(void) const	{ return (CResourcePropSheet *) Psht(); }
	CResource *				PciRes(void) const			{ return (CResource *) Pci(); }

	void					FillDependencies(void);
	void					DisplayProperties(void);

	int						m_nSortDirection;
	int						m_nSortColumn;

	// Generated message map functions
	//{{AFX_MSG(CResourceDependsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnModify();
	afx_msg void OnDblClkDependsList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnProperties();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnItemChangedDependsList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CResourceDependsPage

/////////////////////////////////////////////////////////////////////////////
// CResourceAdvancedPage dialog
/////////////////////////////////////////////////////////////////////////////

class CResourceAdvancedPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CResourceAdvancedPage)

// Construction
public:
	CResourceAdvancedPage(void);

	virtual	BOOL			BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CResourceAdvancedPage)
	enum { IDD = IDD_PP_RES_ADVANCED };
	CButton	m_ckbAffectTheGroup;
	CEdit	m_editPendingTimeout;
	CButton	m_rbDefaultLooksAlive;
	CButton	m_rbSpecifyLooksAlive;
	CButton	m_rbDefaultIsAlive;
	CButton	m_rbSpecifyIsAlive;
	CEdit	m_editLooksAlive;
	CEdit	m_editIsAlive;
	CButton	m_rbDontRestart;
	CButton	m_rbRestart;
	CEdit	m_editThreshold;
	CEdit	m_editPeriod;
	BOOL	m_bAffectTheGroup;
	int		m_nRestart;
	//}}AFX_DATA
	CRRA	m_crraRestartAction;
	DWORD	m_nThreshold;
	DWORD	m_nPeriod;
	DWORD	m_nLooksAlive;
	DWORD	m_nIsAlive;
	DWORD	m_nPendingTimeout;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CResourceAdvancedPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CResourcePropSheet *	PshtResource(void) const	{ return (CResourcePropSheet *) Psht(); }
	CResource *				PciRes(void) const			{ return (CResource *) Pci(); }

	// Generated message map functions
	//{{AFX_MSG(CResourceAdvancedPage)
	afx_msg void OnClickedDontRestart();
	afx_msg void OnClickedRestart();
	afx_msg void OnClickedDefaultLooksAlive();
	afx_msg void OnClickedDefaultIsAlive();
	afx_msg void OnChangeLooksAlive();
	afx_msg void OnChangeIsAlive();
	virtual BOOL OnInitDialog();
	afx_msg void OnClickedSpecifyLooksAlive();
	afx_msg void OnClickedSpecifyIsAlive();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CResourceAdvancedPage

/////////////////////////////////////////////////////////////////////////////
// CResourcePropSheet
/////////////////////////////////////////////////////////////////////////////

class CResourcePropSheet : public CBasePropertySheet
{
	DECLARE_DYNAMIC(CResourcePropSheet)

// Construction
public:
	CResourcePropSheet(
		IN OUT CWnd *	pParentWnd = NULL,
		IN UINT			iSelectPage = 0
		);
	virtual BOOL					BInit(
										IN OUT CClusterItem *	pciCluster,
										IN IIMG					iimgIcon
										);

// Attributes
protected:
	CBasePropertyPage *				m_rgpages[3];

	// Pages
	CResourceGeneralPage			m_pageGeneral;
	CResourceDependsPage			m_pageDepends;
	CResourceAdvancedPage			m_pageAdvanced;

	CResourceGeneralPage &			PageGeneral(void)		{ return m_pageGeneral; }
	CResourceDependsPage &			PageDepends(void)		{ return m_pageDepends; }
	CResourceAdvancedPage &			PageAdvanced(void)		{ return m_pageAdvanced; }

public:
	CResource *						PciRes(void) const	{ return (CResource *) Pci(); }

// Operations

// Overrides
protected:
	virtual CBasePropertyPage **	Ppages(void);
	virtual int						Cpages(void);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CResourcePropSheet)
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CResourcePropSheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CResourcePropSheet

/////////////////////////////////////////////////////////////////////////////

#endif // _RESPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\reswiz.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ResWiz.cpp
//
//  Abstract:
//      Implementation of the CCreateResourceWizard class and all pages
//      specific to a new resource wizard.
//
//  Author:
//      David Potter (davidp)   September 3, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ResWiz.h"
#include "ClusDoc.h"
#include "DDxDDv.h"
#include "HelpData.h"
#include "TreeView.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCreateResourceWizard
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CCreateResourceWizard, CBaseWizard)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CCreateResourceWizard, CBaseWizard)
    //{{AFX_MSG_MAP(CCreateResourceWizard)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateResourceWizard::CCreateResourceWizard
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pdoc        [IN OUT] Document in which resource is to be created.
//      pParentWnd  [IN OUT] Parent window for this property sheet.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCreateResourceWizard::CCreateResourceWizard(
    IN OUT CClusterDoc *    pdoc,
    IN OUT CWnd *           pParentWnd
    )
    : CBaseWizard(IDS_NEW_RESOURCE_TITLE, pParentWnd)
{
    ASSERT_VALID(pdoc);
    m_pdoc = pdoc;

    m_pciResType = NULL;
    m_pciGroup = NULL;
    m_pciRes = NULL;
    m_bCreated = FALSE;

    m_rgpages[0].m_pwpage = &m_pageName;
    m_rgpages[0].m_dwWizButtons = PSWIZB_NEXT;
    m_rgpages[1].m_pwpage = &m_pageOwners;
    m_rgpages[1].m_dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
    m_rgpages[2].m_pwpage = &m_pageDependencies;
    m_rgpages[2].m_dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;

}  //*** CCreateResourceWizard::CCreateResourceWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateResourceWizard::~CCreateResourceWizard
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CCreateResourceWizard::~CCreateResourceWizard(void)
{
    if (m_pciRes != NULL)
        m_pciRes->Release();
    if (m_pciResType != NULL)
        m_pciResType->Release();
    if (m_pciGroup != NULL)
        m_pciGroup->Release();

}  //*** CCreateResourceWizard::~CCreateResourceWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateResourceWizard::BInit
//
//  Routine Description:
//      Initialize the wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Wizard initialized successfully.
//      FALSE   Wizard not initialized successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCreateResourceWizard::BInit(void)
{
    // Call the base class method.
    CClusterAdminApp *  papp = GetClusterAdminApp();
    if (!CBaseWizard::BInit(papp->Iimg(IMGLI_RES)))
        return FALSE;

    // Get default group and/or resource type.
    {
        CTreeItem * pti;
        CListItem * pli;

        // Get the current MDI frame window.
        CSplitterFrame * pframe = (CSplitterFrame *) ((CFrameWnd*)AfxGetMainWnd())->GetActiveFrame();
        ASSERT_VALID(pframe);
        ASSERT_KINDOF(CSplitterFrame, pframe);

        // Get currently selected tree item and list item with focus.
        pti = pframe->PviewTree()->PtiSelected();
        pli = pframe->PviewList()->PliFocused();

        // If the currently selected item in the tree view is a group,
        // default to using that group.
        ASSERT_VALID(pti);
        ASSERT_VALID(pti->Pci());
        if (pti->Pci()->IdsType() == IDS_ITEMTYPE_GROUP)
        {
            ASSERT_KINDOF(CGroup, pti->Pci());
            m_pciGroup = (CGroup *) pti->Pci();
        }  // if:  group selected
        else
        {
            // If the item with the focus in the list control is a group,
            // default to using it.  If it is a resource, use its group.
            if (pli != NULL)
            {
                ASSERT_VALID(pli->Pci());
                if (pli->Pci()->IdsType() == IDS_ITEMTYPE_GROUP)
                {
                    ASSERT_KINDOF(CGroup, pli->Pci());
                    m_pciGroup = (CGroup *) pli->Pci();
                }  // if:  group has focus
                else if (pli->Pci()->IdsType() == IDS_ITEMTYPE_RESOURCE)
                {
                    ASSERT_KINDOF(CResource, pli->Pci());
                    m_pciGroup = ((CResource *) pli->Pci())->PciGroup();
                }  // else if:  resource has focus
            }  // if:  a list item has focus
        }  // else:  tree item not a group

        // Increment the reference count on the group.
        if (m_pciGroup != NULL)
            m_pciGroup->AddRef();

        // If a resource is selected, set the default resource type from it.
        // If a resource type is selected, set the default resource type to it.
        if (pli != NULL)
        {
            ASSERT_VALID(pli->Pci());
            if (pli->Pci()->IdsType() == IDS_ITEMTYPE_RESOURCE)
            {
                ASSERT_KINDOF(CResource, pli->Pci());
                m_pciResType = ((CResource *) pli->Pci())->PciResourceType();
            }  // if:  resource has focus
            else if (pli->Pci()->IdsType() == IDS_ITEMTYPE_RESTYPE)
            {
                ASSERT_KINDOF(CResourceType, pli->Pci());
                m_pciResType = (CResourceType *) pli->Pci();
            }  // else if:  resource type has focus
        }  // if:  a list item has focus

        // Increment the reference count on the resource type.
        if (m_pciResType != NULL)
            m_pciResType->AddRef();
    }  // // Get currently selected group

    return TRUE;

}  //*** CCreateResourceWizard::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateResourceWizard::OnCancel
//
//  Routine Description:
//      Called after the wizard has been dismissed when the Cancel button
//      has been pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCreateResourceWizard::OnCancel(void)
{
    if (BCreated())
    {
        ASSERT_VALID(PciRes());
        try
        {
            PciRes()->DeleteResource();
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
        catch (...)
        {
        }  // catch:  anything
        m_bCreated = FALSE;
    }  // if:  we created the object

}  //*** CCreateResourceWizard::OnCancel()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::OnWizardFinish
//
//  Routine Description:
//      Called after the wizard has been dismissed when the Finish button
//      has been pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CCreateResourceWizard::OnWizardFinish(void)
{
    CResource * pciResDoc;

    ASSERT_VALID(PciRes());

    try
    {
        pciResDoc = (CResource *) Pdoc()->LpciResources().PciFromName(PciRes()->StrName());
        ASSERT_VALID(pciResDoc);
        if (pciResDoc != NULL)
            pciResDoc->ReadItem();
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
    }  // catch:  CException

}  //*** CCreateResourceWizard::OnWizardFinish()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateResourceWizard::Ppages
//
//  Routine Description:
//      Returns the array of pages to add to the property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Page array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWizPage * CCreateResourceWizard::Ppages(void)
{
    return m_rgpages;

}  //*** CCreateResourceWizard::Ppages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateResourceWizard::Cpages
//
//  Routine Description:
//      Returns the count of pages in the array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Count of pages in the array.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CCreateResourceWizard::Cpages(void)
{
    return sizeof(m_rgpages) / sizeof(CWizPage);

}  //*** CCreateResourceWizard::Cpages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCreateResourceWizard::BSetRequiredFields
//
//  Routine Description:
//      Set the required fields of the resource, creating it if necessary.
//
//  Arguments:
//      rstrName            [IN] Name of the resource.
//      pciResType          [IN] The resource type of the resource.
//      pciGroup            [IN] The group to which the resource belongs.
//      bSeparateMonitor    [IN] TRUE = Resource runs in a separate moniotor.
//      rstrDesc            [IN] Description of the resource.
//
//  Return Value:
//      TRUE            Required fields set successfully.
//      FALSE           Error setting the required fields.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCreateResourceWizard::BSetRequiredFields(
    IN const CString &  rstrName,
    IN CResourceType *  pciResType,
    IN CGroup *         pciGroup,
    IN BOOL             bSeparateMonitor,
    IN const CString &  rstrDesc
    )
{
    BOOL        bSuccess = TRUE;
    CResource * pciResDoc;
    CWaitCursor wc;

    ASSERT(pciGroup != NULL);

    try
    {
        if (   BCreated()
            && (   (pciResType->StrName().CompareNoCase(PciRes()->StrRealResourceType()) != 0)
                || (PciRes()->PciGroup() == NULL)
                || (pciGroup->StrName().CompareNoCase(PciRes()->PciGroup()->StrName()) != 0)))
        {
            PciRes()->DeleteResource();
            m_bCreated = FALSE;
        }  // if:  object created already but resource type changed
        if (!BCreated())
        {
            // Allocate an item.
            if (PciRes() != NULL)
            {
                VERIFY(m_pciRes->Release() == 0);
            }  // if:  item already allocated
            m_pciRes = new CResource(FALSE);
            if ( m_pciRes == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the resource
            m_pciRes->AddRef();

            // Create the resource.
            PciRes()->Create(
                        Pdoc(),
                        rstrName,
                        pciResType->StrName(),
                        pciGroup->StrName(),
                        bSeparateMonitor
                        );

            // Create the resource in the document.
            pciResDoc = Pdoc()->PciAddNewResource(rstrName);
            if (pciResDoc != NULL)
                pciResDoc->SetInitializing();

            // Read the resource.
            PciRes()->ReadItem();

            // Set the description field.
            try
            {
                PciRes()->SetCommonProperties(
                            rstrDesc,
                            bSeparateMonitor,
                            PciRes()->NLooksAlive(),
                            PciRes()->NIsAlive(),
                            PciRes()->CrraRestartAction(),
                            PciRes()->NRestartThreshold(),
                            PciRes()->NRestartPeriod(),
                            PciRes()->NPendingTimeout()
                            );
            }  // try
            catch (CNTException * pnte)
            {
                if (pnte->Sc() != ERROR_RESOURCE_PROPERTIES_STORED)
                    throw;
                pnte->Delete();
            }  // catch:  CNTException

            m_strName = rstrName;
            m_strDescription = rstrDesc;
            m_bCreated = TRUE;
            m_bNeedToLoadExtensions = TRUE;
        }  // if:  object not created yet
        else
        {
            ASSERT_VALID(PciRes());

            // If the group changed, clear the dependencies.
            if (pciGroup->StrName() != PciRes()->StrGroup())
            {
                CResourceList   lpobjRes;
                PciRes()->SetDependencies(lpobjRes);
                PciRes()->SetGroup(pciGroup->StrName());
            }  // if:  group name changed

            PciRes()->SetName(rstrName);
            try
            {
                PciRes()->SetCommonProperties(
                            rstrDesc,
                            bSeparateMonitor,
                            PciRes()->NLooksAlive(),
                            PciRes()->NIsAlive(),
                            PciRes()->CrraRestartAction(),
                            PciRes()->NRestartThreshold(),
                            PciRes()->NRestartPeriod(),
                            PciRes()->NPendingTimeout()
                            );
            }  // try
            catch (CNTException * pnte)
            {
                if (pnte->Sc() != ERROR_RESOURCE_PROPERTIES_STORED)
                    throw;
                pnte->Delete();
            }  // catch:  CNTException
            m_strName = rstrName;
            m_strDescription = rstrDesc;
        }  // else:  object already exists

        // Save the resource type pointer.
        if (pciResType != m_pciResType)
        {
            pciResType->AddRef();
            if (m_pciResType != NULL)
                m_pciResType->Release();
            m_pciResType = pciResType;
        }  // if:  the resource type changed
        // Save the group pointer.
        if (pciGroup != m_pciGroup)
        {
            pciGroup->AddRef();
            if (m_pciGroup != NULL)
                m_pciGroup->Release();
            m_pciGroup = pciGroup;
        }  // if:  the group changed
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        if (PciRes() != NULL)
        {
            try
            {
                PciRes()->DeleteResource();
            }  // try
            catch (...)
            {
            }  // catch:  Anything
            VERIFY(m_pciRes->Release() == 0);
            m_pciRes = NULL;
            m_bCreated = FALSE;
        }  // if:  there is a resource
        bSuccess = FALSE;
    }  // catch:  CException

    return bSuccess;

}  //*** CCreateResourceWizard::BSetRequiredFields()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNewResNamePage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNewResNamePage, CBaseWizardPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNewResNamePage, CBaseWizardPage)
    //{{AFX_MSG_MAP(CNewResNamePage)
    ON_EN_CHANGE(IDC_WIZ_RES_NAME, OnChangeResName)
    ON_EN_KILLFOCUS(IDC_WIZ_RES_NAME, OnKillFocusResName)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResNamePage::CNewResNamePage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNewResNamePage::CNewResNamePage(void)
    : CBaseWizardPage(IDD, g_aHelpIDs_IDD_WIZ_RESOURCE_NAME)
{
    //{{AFX_DATA_INIT(CNewResNamePage)
    m_strName = _T("");
    m_strDesc = _T("");
    m_strGroup = _T("");
    m_strResType = _T("");
    m_bSeparateMonitor = FALSE;
    //}}AFX_DATA_INIT

    m_pciResType = NULL;
    m_pciGroup = NULL;

}  //*** CNewResNamePage::CNewResNamePage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResNamePage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewResNamePage::DoDataExchange(CDataExchange * pDX)
{
    CBaseWizardPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewResNamePage)
    DDX_Control(pDX, IDC_WIZ_RES_GROUP, m_cboxGroups);
    DDX_Control(pDX, IDC_WIZ_RES_RESTYPE, m_cboxResTypes);
    DDX_Control(pDX, IDC_WIZ_RES_DESC, m_editDesc);
    DDX_Control(pDX, IDC_WIZ_RES_NAME, m_editName);
    DDX_Text(pDX, IDC_WIZ_RES_NAME, m_strName);
    DDX_Text(pDX, IDC_WIZ_RES_DESC, m_strDesc);
    DDX_CBString(pDX, IDC_WIZ_RES_GROUP, m_strGroup);
    DDX_CBString(pDX, IDC_WIZ_RES_RESTYPE, m_strResType);
    DDX_Check(pDX, IDC_WIZ_RES_SEPARATE_MONITOR, m_bSeparateMonitor);
    //}}AFX_DATA_MAP

    DDV_RequiredText(pDX, IDC_WIZ_RES_NAME, IDC_WIZ_RES_NAME_LABEL, m_strName);

    if (pDX->m_bSaveAndValidate)
    {
        int     icbi;

        icbi = m_cboxResTypes.GetCurSel();
        ASSERT(icbi != CB_ERR);
        m_pciResType = (CResourceType *) m_cboxResTypes.GetItemDataPtr(icbi);

        icbi = m_cboxGroups.GetCurSel();
        ASSERT(icbi != CB_ERR);
        m_pciGroup = (CGroup *) m_cboxGroups.GetItemDataPtr(icbi);
    }  // if:  saving data from dialog
    else
    {
        // Select the proper resource type item.
        if (m_cboxResTypes.GetCurSel() == CB_ERR)
            m_cboxResTypes.SetCurSel(0);

        // Select the proper group item.
        if (m_cboxGroups.GetCurSel() == CB_ERR)
            m_cboxGroups.SetCurSel(0);
    }  // else:  setting to dialog

}  //*** CNewResNamePage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResNamePage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResNamePage::OnInitDialog(void)
{
    CBaseWizardPage::OnInitDialog();

    // Fill the Resource Type list.
    {
        POSITION        pos;
        CResourceType * pciResType;
        int             icbi;

        CDC           * pCboxDC;
        CFont         * pfontOldFont;
        CFont         * pfontCBFont;
        int             nCboxHorizExtent = 0;
        CSize           cboxTextSize;
        TEXTMETRIC      tm;

        tm.tmAveCharWidth = 0;

        //
        // Refer to Knowledge base article Q66370 for details on how to
        // set the horizontal extent of a list box (or drop list).
        //

        pCboxDC = m_cboxResTypes.GetDC();                   // Get the device context (DC) from the combo box.
        pfontCBFont = m_cboxResTypes.GetFont();             // Get the combo box font.
        pfontOldFont = pCboxDC->SelectObject(pfontCBFont);  // Select this font into the DC. Save the old font.
        pCboxDC->GetTextMetrics(&tm);                       // Get the text metrics of this DC.

        pos = PwizRes()->Pdoc()->LpciResourceTypes().GetHeadPosition();
        while (pos != NULL)
        {
            pciResType = (CResourceType *) PwizRes()->Pdoc()->LpciResourceTypes().GetNext(pos);

            const CString &rstrCurResTypeString = pciResType->StrDisplayName();

            ASSERT_VALID(pciResType);
            if (   (pciResType->Hkey() != NULL)
                && (rstrCurResTypeString.GetLength() > 0)
                && (pciResType->StrName() != CLUS_RESTYPE_NAME_FTSET)
                )
            {
                icbi = m_cboxResTypes.AddString(rstrCurResTypeString);
                
                // Compute the horizontal extent of this string.
                cboxTextSize = pCboxDC->GetTextExtent(rstrCurResTypeString);
                if (cboxTextSize.cx > nCboxHorizExtent)
                {
                    nCboxHorizExtent = cboxTextSize.cx;
                }

                ASSERT(icbi != CB_ERR);
                m_cboxResTypes.SetItemDataPtr(icbi, pciResType);
                pciResType->AddRef();
            }  // if:  resource type is valid
        }  // while:  more items in the list

        pCboxDC->SelectObject(pfontOldFont);                // Reset the original font in the DC
        m_cboxResTypes.ReleaseDC(pCboxDC);                  // Release the DC
        m_cboxResTypes.SetHorizontalExtent(nCboxHorizExtent + tm.tmAveCharWidth);

    }  // Fill the Resource Type list

    // Fill the Group list.
    {
        POSITION    pos;
        CGroup *    pciGroup;
        int         icbi;

        pos = PwizRes()->Pdoc()->LpciGroups().GetHeadPosition();
        while (pos != NULL)
        {
            pciGroup = (CGroup *) PwizRes()->Pdoc()->LpciGroups().GetNext(pos);
            ASSERT_VALID(pciGroup);
            if (   (pciGroup->Hgroup() != NULL)
                && (pciGroup->Hkey() != NULL))
            {
                icbi = m_cboxGroups.AddString(pciGroup->StrName());
                ASSERT(icbi != CB_ERR);
                m_cboxGroups.SetItemDataPtr(icbi, pciGroup);
                pciGroup->AddRef();
            }  // if:  group is valid
        }  // while:  more items in the list
    }  // Fill the Group list

    // If there is a group already selected, get its name.
    if (PwizRes()->PciGroup() != NULL)
        m_strGroup = PwizRes()->PciGroup()->StrName();

    // If there is a resource type already selected, get its name.
    if (PwizRes()->PciResType() != NULL)
        m_strResType = PwizRes()->PciResType()->StrName();

    UpdateData(FALSE /*bSaveAndValidate*/);

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CNewResNamePage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResNamePage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResNamePage::OnSetActive(void)
{
    BOOL    bSuccess;

    bSuccess = CBaseWizardPage::OnSetActive();
    if (bSuccess)
    {
        if (m_strName.IsEmpty())
            EnableNext(FALSE);
    }  // if:  successful thus far

    return bSuccess;

}  //*** CNewResNamePage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResNamePage::BApplyChanges
//
//  Routine Description:
//      Apply changes from this page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Changes applied successfully.
//      FALSE       Error applying changes.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResNamePage::BApplyChanges(void)
{
    CWaitCursor wc;

    ASSERT(Pwiz() != NULL);

    // Get the data from the dialog.
    if (!UpdateData(TRUE /*bSaveAndValidate*/))
        return FALSE;

    // Save the data in the sheet.
    if (!PwizRes()->BSetRequiredFields(
                        m_strName,
                        m_pciResType,
                        m_pciGroup,
                        m_bSeparateMonitor,
                        m_strDesc))
        return FALSE;

    // Load extensions here.
    Pwiz()->LoadExtensions(PwizRes()->PciRes());

    return TRUE;

}  //*** CNewResNamePage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResNamePage::OnDestroy
//
//  Routine Description:
//      Handler for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewResNamePage::OnDestroy(void)
{
    // Release references on resource type pointers.
    if (m_cboxResTypes.m_hWnd != NULL)
    {
        int             icbi;
        CResourceType * pciResType;

        for (icbi = m_cboxResTypes.GetCount() - 1 ; icbi >= 0 ; icbi--)
        {
            pciResType = (CResourceType *) m_cboxResTypes.GetItemDataPtr(icbi);
            ASSERT_VALID(pciResType);
            ASSERT_KINDOF(CResourceType, pciResType);

            pciResType->Release();
        }  // while:  more items in the list control
    }  // if:  resource types combobox has been initialized

    // Release references on group pointers.
    if (m_cboxGroups.m_hWnd != NULL)
    {
        int         icbi;
        CGroup *    pciGroup;

        for (icbi = m_cboxGroups.GetCount() - 1 ; icbi >= 0 ; icbi--)
        {
            pciGroup = (CGroup *) m_cboxGroups.GetItemDataPtr(icbi);
            ASSERT_VALID(pciGroup);
            ASSERT_KINDOF(CGroup, pciGroup);

            pciGroup->Release();
        }  // while:  more items in the list control
    }  // if:  groups combobox has been initialized

    CBaseWizardPage::OnDestroy();

}  //*** CNewResNamePage::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResNamePage::OnChangeResName
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Resource Name edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewResNamePage::OnChangeResName(void)
{
    if (m_editName.GetWindowTextLength() == 0)
        EnableNext(FALSE);
    else
        EnableNext(TRUE);

}  //*** CNewResNamePage::OnChangeResName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResNamePage::OnKillFocusResName
//
//  Routine Description:
//      Handler for the WM_KILLFOCUS message on the Resource Name edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewResNamePage::OnKillFocusResName(void)
{
    CString     strName;

    m_editName.GetWindowText(strName);
    SetObjectTitle(strName);

}  //*** CNewResNamePage::OnKillFocusResName()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNewResOwnersPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNewResOwnersPage, CListCtrlPairWizPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CNewResOwnersPage, CListCtrlPairWizPage)
    //{{AFX_MSG_MAP(CNewResOwnersPage)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResOwnersPage::CNewResOwnersPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNewResOwnersPage::CNewResOwnersPage(void)
    : CListCtrlPairWizPage(
            IDD,
            g_aHelpIDs_IDD_WIZ_POSSIBLE_OWNERS,
            LCPS_SHOW_IMAGES | LCPS_ALLOW_EMPTY,
            GetColumn,
            BDisplayProperties
            )
{
    //{{AFX_DATA_INIT(CNewResOwnersPage)
    //}}AFX_DATA_INIT

}  //*** CNewResOwnersPage::CNewResOwnersPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResOwnersPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewResOwnersPage::DoDataExchange(CDataExchange * pDX)
{
    // Initialize the lists before the list pair control is updated.
    if (!pDX->m_bSaveAndValidate)
    {
        if (!BInitLists())
            pDX->Fail();
    }  // if:  setting data to the dialog

    CListCtrlPairWizPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewResOwnersPage)
    DDX_Control(pDX, IDC_LCP_NOTE, m_staticNote);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (!BBackPressed())
        {
#if 0
            // If user removed node on which group is online,
            // display message and fail.
            if (!BOwnedByPossibleOwner())
            {
                CString strMsg;
                strMsg.FormatMessage(IDS_RES_NOT_OWNED_BY_POSSIBLE_OWNER, PciRes()->StrGroup(), PciRes()->StrOwner());
                AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
                strMsg.Empty(); // prepare to throw exception in Fail()
                pDX->Fail();
            }  // if:  not owned by possible owner
#endif
        }  // if:  Back button not pressed
    }  // if:  saving data from dialog

}  //*** CNewResOwnersPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResOwnersPage::BInitLists
//
//  Routine Description:
//      Initialize the lists.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResOwnersPage::BInitLists(void)
{
    BOOL        bSuccess = TRUE;

    ASSERT_VALID(PciRes());

    try
    {
        SetLists(&PciRes()->LpcinodePossibleOwners(), &PciRes()->Pdoc()->LpciNodes());
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        bSuccess = FALSE;
    }  // catch:  CException

    return bSuccess;

}  //*** CNewResOwnersPage::BInitLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResOwnersPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResOwnersPage::OnInitDialog(void)
{
    // Add columns.
    try
    {
        NAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    // Call the base class method.
    CListCtrlPairWizPage::OnInitDialog();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CNewResOwnersPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResOwnersPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResOwnersPage::OnSetActive(void)
{
    BOOL    bSuccess;

    PciRes()->CollectPossibleOwners(NULL);
    bSuccess = CListCtrlPairWizPage::OnSetActive();

    return bSuccess;

}  //*** CNewResOwnersPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResOwnersPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResOwnersPage::BApplyChanges(void)
{
    CWaitCursor wc;

    try
    {
        // Set the data from the page in the cluster item.
        PciRes()->SetPossibleOwners((CNodeList &) Plcp()->LpobjRight());
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CListCtrlPairWizPage::BApplyChanges();

}  //*** CNewResOwnersPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResOwnersPage::BOwnedByPossibleOwner
//
//  Routine Description:
//      Determine if the group in which this resource resides is owned by
//      a node in the proposed possible owners list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Group owned by node in possible owners list.
//      FALSE       Group NOT owned by node in possible owners list.
//
//  Exceptions Thrown:
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResOwnersPage::BOwnedByPossibleOwner(void) const
{
    CClusterNode *  pciNode = NULL;

    // Get the node on which the resource is online.
    PciRes()->UpdateState();

    // Find the owner node in the proposed possible owners list.
    {
        POSITION        pos;

        pos = Plcp()->LpobjRight().GetHeadPosition();
        while (pos != NULL)
        {
            pciNode = (CClusterNode *) Plcp()->LpobjRight().GetNext(pos);
            ASSERT_VALID(pciNode);

            if (PciRes()->StrOwner().CompareNoCase(pciNode->StrName()) == 0)
                break;
            pciNode = NULL;
        }  // while:  more items in the list
    }  // Find the owner node in the proposed possible owners list

    return (pciNode != NULL);

}  //*** CNewResOwnersPage::BOwnedByPossibleOwner()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResOwnersPage::GetColumn [static]
//
//  Routine Description:
//      Returns a column for an item.
//
//  Arguments:
//      pobj        [IN OUT] Object for which the column is to be displayed.
//      iItem       [IN] Index of the item in the list.
//      icol        [IN] Column number whose text is to be retrieved.
//      pdlg        [IN OUT] Dialog to which object belongs.
//      rstr        [OUT] String in which to return column text.
//      piimg       [OUT] Image index for the object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CALLBACK CNewResOwnersPage::GetColumn(
    IN OUT CObject *    pobj,
    IN int              iItem,
    IN int              icol,
    IN OUT CDialog *    pdlg,
    OUT CString &       rstr,
    OUT int *           piimg
    )
{
    CClusterNode *  pciNode = (CClusterNode *) pobj;
    int             colid;

    ASSERT_VALID(pciNode);
    ASSERT((0 <= icol) && (icol <= 1));

    switch (icol)
    {
        // Sorting by resource name.
        case 0:
            colid = IDS_COLTEXT_NAME;
            break;

        default:
            ASSERT(0);
            colid = IDS_COLTEXT_NAME;
            break;
    }  // switch:  pdlg->NSortColumn()

    pciNode->BGetColumnData(colid, rstr);
    if (piimg != NULL)
        *piimg = pciNode->IimgObjectType();

}  //*** CNewResOwnersPage::GetColumn()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResOwnersPage::BDisplayProperties [static]
//
//  Routine Description:
//      Display the properties of the specified object.
//
//  Arguments:
//      pobj    [IN OUT] Cluster item whose properties are to be displayed.
//
//  Return Value:
//      TRUE    Properties where accepted.
//      FALSE   Properties where cancelled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK CNewResOwnersPage::BDisplayProperties(IN OUT CObject * pobj)
{
    CClusterItem *  pci = (CClusterItem *) pobj;

    ASSERT_KINDOF(CClusterItem, pobj);

    return pci->BDisplayProperties();

}  //*** CNewResOwnersPage::BDisplayProperties();


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CNewResDependsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNewResDependsPage, CListCtrlPairWizPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CNewResDependsPage, CListCtrlPairWizPage)
    //{{AFX_MSG_MAP(CNewResDependsPage)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResDependsPage::CNewResDependsPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNewResDependsPage::CNewResDependsPage(void)
    : CListCtrlPairWizPage(
            IDD,
            g_aHelpIDs_IDD_WIZ_DEPENDENCIES,
            LCPS_SHOW_IMAGES | LCPS_ALLOW_EMPTY,
            GetColumn,
            BDisplayProperties
            )
{
    //{{AFX_DATA_INIT(CNewResDependsPage)
    //}}AFX_DATA_INIT

}  //*** CNewResDependsPage::CNewResDependsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResDependsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNewResDependsPage::DoDataExchange(CDataExchange * pDX)
{
    // Initialize the lists before the list pair control is updated.
    if (!pDX->m_bSaveAndValidate)
    {
        if (!BInitLists())
            pDX->Fail();
    }  // if:  setting data to the dialog

    CListCtrlPairWizPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CNewResDependsPage)
    //}}AFX_DATA_MAP

}  //*** CNewResDependsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResDependsPage::BInitLists
//
//  Routine Description:
//      Initialize the lists.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResDependsPage::BInitLists(void)
{
    BOOL        bSuccess = TRUE;

    ASSERT_VALID(PciRes());

    try
    {
        // Create the list of resources on which this resource can be dependent.
        {
            POSITION                posPci;
            CResource *             pciRes;
            const CResourceList &   rlpciResources = PciGroup()->Lpcires();

            LpciresAvailable().RemoveAll();

            posPci = rlpciResources.GetHeadPosition();
            while (posPci != NULL)
            {
                // Get the cluster item pointer.
                pciRes = (CResource *) rlpciResources.GetNext(posPci);
                ASSERT_VALID(pciRes);

                // If we CAN be dependent on this resource, add it to our Available list.
                if (PciRes()->BCanBeDependent(pciRes)
                        || PciRes()->BIsDependent(pciRes))
                    LpciresAvailable().AddTail(pciRes);
            }  // while:  more items in the list
        }  // Create the list of resources on which this resource can be dependent

        SetLists(&PciRes()->LpciresDependencies(), &LpciresAvailable());
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        bSuccess = FALSE;
    }  // catch:  CException

    return bSuccess;

}  //*** CNewResDependsPage::BInitLists()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResDependsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResDependsPage::OnInitDialog(void)
{
    // Add columns.
    try
    {
        NAddColumn(IDS_COLTEXT_RESOURCE, COLI_WIDTH_NAME);
        NAddColumn(IDS_COLTEXT_RESTYPE, COLI_WIDTH_RESTYPE);
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    // Call the base class method.
    CListCtrlPairWizPage::OnInitDialog();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CNewResDependsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResDependsPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNewResDependsPage::BApplyChanges(void)
{
    CWaitCursor wc;

    // Check to see if required dependencies have been made.
    {
        CString     strMissing;
        CString     strMsg;

        try
        {
            if (!PciRes()->BRequiredDependenciesPresent((const CResourceList &)Plcp()->LpobjRight(), strMissing))
            {
                strMsg.FormatMessage(IDS_REQUIRED_DEPENDENCY_NOT_FOUND, strMissing);
                AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
                return FALSE;
            }  // if:  all required dependencies not present
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
            return FALSE;
        }  // catch:  CException
    }  // Check to see if required dependencies have been made

    // Set the data from the page in the cluster item.
    try
    {
        PciRes()->SetDependencies((CResourceList &) Plcp()->LpobjRight());
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CListCtrlPairWizPage::BApplyChanges();

}  //*** CNewResDependsPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResDependsPage::GetColumn [static]
//
//  Routine Description:
//      Returns a column for an item.
//
//  Arguments:
//      pobj        [IN OUT] Object for which the column is to be displayed.
//      iItem       [IN] Index of the item in the list.
//      icol        [IN] Column number whose text is to be retrieved.
//      pdlg        [IN OUT] Dialog to which object belongs.
//      rstr        [OUT] String in which to return column text.
//      piimg       [OUT] Image index for the object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CALLBACK CNewResDependsPage::GetColumn(
    IN OUT CObject *    pobj,
    IN int              iItem,
    IN int              icol,
    IN OUT CDialog *    pdlg,
    OUT CString &       rstr,
    OUT int *           piimg
    )
{
    CResource * pciRes  = (CResource *) pobj;
    int         colid;

    ASSERT_VALID(pciRes);
    ASSERT((0 <= icol) && (icol <= 1));

    switch (icol)
    {
        // Sorting by resource name.
        case 0:
            colid = IDS_COLTEXT_RESOURCE;
            break;

        // Sorting by resource type.
        case 1:
            colid = IDS_COLTEXT_RESTYPE;
            break;

        default:
            ASSERT(0);
            colid = IDS_COLTEXT_RESOURCE;
            break;
    }  // switch:  pdlg->NSortColumn()

    pciRes->BGetColumnData(colid, rstr);
    if (piimg != NULL)
        *piimg = pciRes->IimgObjectType();

}  //*** CNewResDependsPage::GetColumn()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNewResDependsPage::BDisplayProperties [static]
//
//  Routine Description:
//      Display the properties of the specified object.
//
//  Arguments:
//      pobj    [IN OUT] Cluster item whose properties are to be displayed.
//
//  Return Value:
//      TRUE    Properties where accepted.
//      FALSE   Properties where cancelled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK CNewResDependsPage::BDisplayProperties(IN OUT CObject * pobj)
{
    CClusterItem *  pci = (CClusterItem *) pobj;

    ASSERT_KINDOF(CClusterItem, pobj);

    return pci->BDisplayProperties();

}  //*** CNewResDependsPage::BDisplayProperties();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\reswiz.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ResWiz.h
//
//	Abstract:
//		Definition of the CCreateResourceWizard class and all pages specific
//		to a new resource wizard.
//
//	Implementation File:
//		ResWiz.cpp
//
//	Author:
//		David Potter (davidp)	September 2, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESWIZ_H_
#define _RESWIZ_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEWIZ_H_
#include "BaseWiz.h"	// for CBaseWizard
#endif

#ifndef _BASEWPAG_H_
#include "BaseWPag.h"	// for CBaseWizardPage
#endif

#ifndef _LCPRPAGE_H_
#include "LCPrWPag.h"	// for CListCtrlPairWizPage
#endif

#ifndef _RES_H_
#include "Res.h"		// for CResourceList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNewResNamePage;
class CCreateResourceWizard;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CGroup;
class CResource;
class CResourceType;
class CClusterDoc;

/////////////////////////////////////////////////////////////////////////////
// CNewResNamePage property page
/////////////////////////////////////////////////////////////////////////////

class CNewResNamePage : public CBaseWizardPage
{
	DECLARE_DYNCREATE(CNewResNamePage)

// Construction
public:
	CNewResNamePage(void);

// Dialog Data
	//{{AFX_DATA(CNewResNamePage)
	enum { IDD = IDD_WIZ_RESOURCE_NAME };
	CComboBox	m_cboxGroups;
	CComboBox	m_cboxResTypes;
	CEdit	m_editDesc;
	CEdit	m_editName;
	CString	m_strName;
	CString	m_strDesc;
	CString	m_strGroup;
	CString	m_strResType;
	BOOL	m_bSeparateMonitor;
	//}}AFX_DATA
	CResourceType *	m_pciResType;
	CGroup *		m_pciGroup;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNewResNamePage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL			BApplyChanges(void);

// Implementation
protected:
	CCreateResourceWizard *	PwizRes(void) const		{ return (CCreateResourceWizard *) Pwiz(); }

	// Generated message map functions
	//{{AFX_MSG(CNewResNamePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeResName();
	afx_msg void OnKillFocusResName();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNewResNamePage

/////////////////////////////////////////////////////////////////////////////
// CNewResOwnersPage dialog
/////////////////////////////////////////////////////////////////////////////

class CNewResOwnersPage : public CListCtrlPairWizPage
{
	DECLARE_DYNCREATE(CNewResOwnersPage)

// Construction
public:
	CNewResOwnersPage(void);

// Dialog Data
	//{{AFX_DATA(CNewResOwnersPage)
	enum { IDD = IDD_WIZ_POSSIBLE_OWNERS };
	CStatic	m_staticNote;
	//}}AFX_DATA

// Callback functions
	static void CALLBACK	GetColumn(
								IN OUT CObject *	pobj,
								IN int				iItem,
								IN int				icol,
								IN OUT CDialog *	pdlg,
								OUT CString &		rstr,
								OUT int *			piimg
								);
	static BOOL	CALLBACK	BDisplayProperties(IN OUT CObject * pobj);

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNewResOwnersPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL			BApplyChanges(void);

// Implementation
protected:
	CCreateResourceWizard *	PwizRes(void) const		{ return (CCreateResourceWizard *) Pwiz(); }
	CResource *				PciRes(void) const;

	BOOL					BInitLists(void);
	BOOL					BOwnedByPossibleOwner(void) const;

	// Generated message map functions
	//{{AFX_MSG(CNewResOwnersPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNewResOwnersPage

/////////////////////////////////////////////////////////////////////////////
// CNewResDependsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CNewResDependsPage : public CListCtrlPairWizPage
{
	DECLARE_DYNCREATE(CNewResDependsPage)

// Construction
public:
	CNewResDependsPage(void);

// Dialog Data
	//{{AFX_DATA(CNewResDependsPage)
	enum { IDD = IDD_WIZ_DEPENDENCIES };
	//}}AFX_DATA
	CResourceList			m_lpciresAvailable;

	CResourceList &			LpciresAvailable(void)	{ return m_lpciresAvailable; }

// Callback functions
	static void CALLBACK	GetColumn(
								IN OUT CObject *	pobj,
								IN int				iItem,
								IN int				icol,
								IN OUT CDialog *	pdlg,
								OUT CString &		rstr,
								OUT int *			piimg
								);
	static BOOL	CALLBACK	BDisplayProperties(IN OUT CObject * pobj);

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNewResDependsPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL			BApplyChanges(void);

// Implementation
protected:
	CCreateResourceWizard *	PwizRes(void) const		{ return (CCreateResourceWizard *) Pwiz(); }
	CResource *				PciRes(void) const;
	CGroup *				PciGroup(void) const;

	BOOL					BInitLists(void);

	// Generated message map functions
	//{{AFX_MSG(CNewResDependsPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CNewResDependsPage

/////////////////////////////////////////////////////////////////////////////
// CCreateResourceWizard
/////////////////////////////////////////////////////////////////////////////

class CCreateResourceWizard : public CBaseWizard
{
	friend class CNewResNamePage;
	friend class CNewResOwnersPage;
	friend class CNewResDependsPage;

	DECLARE_DYNAMIC(CCreateResourceWizard)

// Construction
public:
	CCreateResourceWizard(IN OUT CClusterDoc * pdoc, IN OUT CWnd * pParentWnd);
	virtual				~CCreateResourceWizard(void);

	BOOL				BInit(void);

// Attributes
protected:
	enum { NumStdPages = 3 };
	CWizPage			m_rgpages[NumStdPages];

	CClusterDoc *		m_pdoc;
	CString				m_strName;
	CString				m_strDescription;
	CStringList			m_lstrPossibleOwners;
	CResourceType *		m_pciResType;
	CGroup *			m_pciGroup;

public:
	CClusterDoc *		Pdoc(void) const				{ return m_pdoc; }
	const CString &		StrName(void) const				{ return m_strName; }
	const CString &		StrDescription(void) const		{ return m_strDescription; }
	const CStringList &	LstrPossibleOwners(void) const	{ return m_lstrPossibleOwners; }
	CGroup *			PciGroup(void) const			{ return m_pciGroup; }
	CResourceType *		PciResType(void) const			{ return m_pciResType; }

// Operations
public:
	BOOL				BSetRequiredFields(
							IN const CString &	rstrName,
							IN CResourceType *	pciResType,
							IN CGroup *			pciGroup,
							IN BOOL				bSeparateMonitor,
							IN const CString &	rstrDesc
							);

// Overrides
protected:
	virtual void		OnWizardFinish(void);
	virtual void		OnCancel(void);
	virtual CWizPage *	Ppages(void);
	virtual int			Cpages(void);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCreateResourceWizard)
	//}}AFX_VIRTUAL

// Implementation
public:

protected:
	CNewResNamePage		m_pageName;
	CNewResOwnersPage	m_pageOwners;
	CNewResDependsPage	m_pageDependencies;
	CResource *			m_pciRes;
	BOOL				m_bCreated;

	CResource *			PciRes(void) const				{ return m_pciRes; }
	BOOL				BCreated(void) const			{ return m_bCreated; }


	// Generated message map functions
protected:
	//{{AFX_MSG(CCreateResourceWizard)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CCreateResourceWizard

/////////////////////////////////////////////////////////////////////////////
// Inline Function Definitions
/////////////////////////////////////////////////////////////////////////////

inline CResource * CNewResOwnersPage::PciRes(void) const
{
	ASSERT_VALID(PwizRes());
	return PwizRes()->PciRes();
}

inline CResource * CNewResDependsPage::PciRes(void) const
{
	ASSERT_VALID(PwizRes());
	return PwizRes()->PciRes();
}

inline CGroup * CNewResDependsPage::PciGroup(void) const
{
	ASSERT_VALID(PwizRes());
	return PwizRes()->PciGroup();
}

/////////////////////////////////////////////////////////////////////////////

#endif // _RESWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	CluAdmin.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\splitfrm.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		SplitFrm.h
//
//	Abstract:
//		Definition of the CSplitterFrame class.
//
//	ImplementationFile:
//		SplitFrm.cpp
//
//	Author:
//		David Potter (davidp)	May 1, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _SPLITFRM_H_
#define _SPLITFRM_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CSplitterFrame;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterDoc;
class CClusterTreeView;
class CClusterListView;
class CClusterItem;
class CExtensions;
class CTreeItem;

/////////////////////////////////////////////////////////////////////////////
// CSplitterFrame
/////////////////////////////////////////////////////////////////////////////

class CSplitterFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CSplitterFrame)
public:
	CSplitterFrame();

// Attributes
protected:
	CSplitterWnd		m_wndSplitter;
	CClusterDoc *		m_pdoc;
	int					m_iFrame;

	BOOL				m_bDragging;
	CImageList *		m_pimagelist;
	CClusterItem *		m_pciDrag;

public:
	CClusterDoc *		Pdoc(void) const			{ return m_pdoc; }
	int					NFrameNumber(void) const	{ return m_iFrame; }

	BOOL				BDragging(void) const		{ return m_bDragging; }
	CImageList *		Pimagelist(void) const		{ return m_pimagelist; }
	CClusterItem *		PciDrag(void) const			{ return m_pciDrag; }

// Operations
public:
	CClusterTreeView *	PviewTree(void) const		{ return (CClusterTreeView *) m_wndSplitter.GetPane(0, 0); }
	CClusterListView *	PviewList(void)const		{ return (CClusterListView *) m_wndSplitter.GetPane(0, 1); }

	void				CalculateFrameNumber();
	void				InitFrame(IN OUT CClusterDoc * pdoc);
	void				ConstructProfileValueName(
							OUT CString &	rstrName,
							IN LPCTSTR		pszPrefix
							) const;

	void				BeginDrag(
							IN OUT CImageList *		pimagelist,
							IN OUT CClusterItem *	pci,
							IN CPoint				ptImage,
							IN CPoint				ptStart
							);
	void				ChangeDragCursor(LPCTSTR pszCursor);
	void				AbortDrag(void);

	// For customizing the default messages on the status bar
	virtual void		GetMessageString(UINT nID, CString& rMessage) const;

protected:
	CMenu *				PmenuPopup(void) const;
	void				Cleanup(void);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSplitterFrame)
	public:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	protected:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CSplitterFrame(void);
#ifdef _DEBUG
	virtual void AssertValid(void) const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	CExtensions *		m_pext;
	CExtensions *		Pext(void) const			{ return m_pext; }

	void				OnButtonUp(UINT nFlags, CPoint point);

// Generated message map functions
protected:
	//{{AFX_MSG(CSplitterFrame)
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnDestroy();
	afx_msg void OnUpdateLargeIconsView(CCmdUI* pCmdUI);
	afx_msg void OnUpdateSmallIconsView(CCmdUI* pCmdUI);
	afx_msg void OnUpdateListView(CCmdUI* pCmdUI);
	afx_msg void OnUpdateDetailsView(CCmdUI* pCmdUI);
	afx_msg void OnLargeIconsView();
	afx_msg void OnSmallIconsView();
	afx_msg void OnListView();
	afx_msg void OnDetailsView();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	//}}AFX_MSG
#ifdef _DEBUG
	afx_msg void OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd);
#endif
	afx_msg void OnUpdateExtMenu(CCmdUI* pCmdUI);
	afx_msg LRESULT	OnUnloadExtension(WPARAM wparam, LPARAM lparam);
	DECLARE_MESSAGE_MAP()

};  //*** class CSplitterFrame

/////////////////////////////////////////////////////////////////////////////

#endif // _SPLITFRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\tracedlg.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      TraceDlg.cpp
//
//  Abstract:
//      Implementation of the CTraceDialog class.
//
//  Author:
//      David Potter (davidp)   May 29, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#define _RESOURCE_H_
#include "TraceDlg.h"
#include "TraceTag.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// CTraceDialog dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CTraceDialog, CDialog)
    //{{AFX_MSG_MAP(CTraceDialog)
    ON_BN_CLICKED(IDC_TS_SELECT_ALL, OnSelectAll)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_TS_LISTBOX, OnItemChangedListbox)
    ON_BN_CLICKED(IDC_TS_TRACE_TO_DEBUG, OnClickedTraceToDebug)
    ON_BN_CLICKED(IDC_TS_TRACE_DEBUG_BREAK, OnClickedTraceDebugBreak)
    ON_BN_CLICKED(IDC_TS_TRACE_TO_COM2, OnClickedTraceToCom2)
    ON_BN_CLICKED(IDC_TS_TRACE_TO_FILE, OnClickedTraceToFile)
    ON_CBN_SELCHANGE(IDC_TS_TAGS_TO_DISPLAY_CB, OnSelChangeTagsToDisplay)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_TS_LISTBOX, OnColumnClickListbox)
    ON_BN_CLICKED(IDC_TS_DEFAULT, OnDefault)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::CTraceDialog
//
//  Routine Description:
//      Constructor.  Initializes the dialog class.
//
//  Arguments:
//      pParent     [IN OUT] Parent window.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTraceDialog::CTraceDialog(CWnd * pParent /*=NULL*/)
    : CDialog(CTraceDialog::IDD, pParent)
{
    //{{AFX_DATA_INIT(CTraceDialog)
    m_strFile = _T("");
    //}}AFX_DATA_INIT

}  //*** CTraceDialog::CTraceDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::DoDataExchange(CDataExchange * pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CTraceDialog)
    DDX_Control(pDX, IDC_TS_LISTBOX, m_lcTagList);
    DDX_Control(pDX, IDC_TS_TRACE_TO_DEBUG, m_chkboxTraceToDebugWin);
    DDX_Control(pDX, IDC_TS_TRACE_DEBUG_BREAK, m_chkboxDebugBreak);
    DDX_Control(pDX, IDC_TS_TRACE_TO_COM2, m_chkboxTraceToCom2);
    DDX_Control(pDX, IDC_TS_TRACE_TO_FILE, m_chkboxTraceToFile);
    DDX_Control(pDX, IDC_TS_FILE, m_editFile);
    DDX_Control(pDX, IDC_TS_TAGS_TO_DISPLAY_CB, m_cboxDisplayOptions);
    DDX_Text(pDX, IDC_TS_FILE, m_strFile);
    //}}AFX_DATA_MAP

}  //*** CTraceDialog::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CTraceDialog::OnInitDialog(void)
{
    CDialog::OnInitDialog();

    // Set the dialog flags.
    {
        CTraceTag * ptag;

        ptag = CTraceTag::s_ptagFirst;
        while (ptag != NULL)
        {
            ptag->m_uiFlagsDialog = ptag->m_uiFlags;
            ptag = ptag->m_ptagNext;
        }  // while:  more tags in the list
    }  // Set the dialog flags

    // Change list view control extended styles.
    {
        DWORD   dwExtendedStyle;

        dwExtendedStyle = m_lcTagList.SendMessage(LVM_GETEXTENDEDLISTVIEWSTYLE);
        m_lcTagList.SendMessage(
            LVM_SETEXTENDEDLISTVIEWSTYLE,
            0,
            dwExtendedStyle
                | LVS_EX_FULLROWSELECT
                | LVS_EX_HEADERDRAGDROP
            );
    }  // Change list view control extended styles

    // Set the columns in the listbox.
    VERIFY(m_lcTagList.InsertColumn(0, TEXT("Section"), LVCFMT_LEFT, 75) != -1);
    VERIFY(m_lcTagList.InsertColumn(1, TEXT("Name"), LVCFMT_LEFT, 125) != -1);
    VERIFY(m_lcTagList.InsertColumn(2, TEXT("State"), LVCFMT_CENTER, 50) != -1);

    // Load the combobox.
    /*0*/ VERIFY(m_cboxDisplayOptions.AddString(TEXT("All Tags")) != CB_ERR);
    /*1*/ VERIFY(m_cboxDisplayOptions.AddString(TEXT("Debug Window Enabled")) != CB_ERR);
    /*2*/ VERIFY(m_cboxDisplayOptions.AddString(TEXT("Break Enabled")) != CB_ERR);
    /*3*/ VERIFY(m_cboxDisplayOptions.AddString(TEXT("COM2 Enabled")) != CB_ERR);
    /*4*/ VERIFY(m_cboxDisplayOptions.AddString(TEXT("File Enabled")) != CB_ERR);
    /*5*/ VERIFY(m_cboxDisplayOptions.AddString(TEXT("Anything Enabled")) != CB_ERR);
    VERIFY(m_cboxDisplayOptions.SetCurSel(0) != CB_ERR);
    m_nCurFilter = 0;

    // Set maximum length of the file edit control.
    m_editFile.LimitText(_MAX_PATH);

    // Load the listbox.
    LoadListbox();

    // Set sort info.
    m_nSortDirection = -1;
    m_nSortColumn = -1;

    m_strFile = CTraceTag::PszFile();
    m_nCurFilter = -1;

    UpdateData(FALSE);

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CTraceDialog::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::ConstructStateString [static]
//
//  Routine Description:
//      Construct a string to display from the state of the trace tag.
//
//  Arguments:
//      ptag        [IN] Tag from which to construct the state string.
//      rstr        [OUT] String in which to return the state string.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::ConstructStateString(
    IN const CTraceTag *    ptag,
    OUT CString &           rstr
    )
{
    rstr = "";
    if (ptag->BDebugDialog())
        rstr += "D";
    if (ptag->BBreakDialog())
        rstr += "B";
    if (ptag->BCom2Dialog())
        rstr += "C";
    if (ptag->BFileDialog())
        rstr += "F";

}  //*** CTraceDialog::ConstructStateString()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnOK
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the OK button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnOK(void)
{
    CTraceTag * ptag;
    CString     strSection;
    CString     strState;

    // Write tag states.
    ptag = CTraceTag::s_ptagFirst;
    while (ptag != NULL)
    {
        if (ptag->m_uiFlags != ptag->m_uiFlagsDialog)
        {
            ptag->m_uiFlags = ptag->m_uiFlagsDialog;
            strSection.Format(TRACE_TAG_REG_SECTION_FMT, ptag->PszSubsystem());
            ptag->ConstructRegState(strState);
            AfxGetApp()->WriteProfileString(strSection, ptag->PszName(), strState);
        }  // if:  tag state changed
        ptag = ptag->m_ptagNext;
    }  // while:  more tags int he list.

    // Write the file.
    if (m_strFile != CTraceTag::PszFile())
    {
        g_strTraceFile = m_strFile;
        AfxGetApp()->WriteProfileString(TRACE_TAG_REG_SECTION, TRACE_TAG_REG_FILE, m_strFile);
    }  // if:  file changed

    CDialog::OnOK();

}  //*** CTraceDialog::OnOK()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnSelectAll
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Select All button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnSelectAll(void)
{
    int     ili;

    // Select all the items in the list control.
    ili = m_lcTagList.GetNextItem(-1, LVNI_ALL);
    while (ili != -1)
    {
        m_lcTagList.SetItemState(ili, LVIS_SELECTED, LVIS_SELECTED);
        ili = m_lcTagList.GetNextItem(ili, LVNI_ALL);
    }  // while:  more items in the list

}  //*** CTraceDialog::OnSelectAll()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnDefault
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Default button.
//      Resets the trace tags to their default settings.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnDefault(void)
{
    CTraceTag * ptag;
    
    ptag = CTraceTag::s_ptagFirst;
    while (ptag != NULL)
    {
        ptag->m_uiFlagsDialog = ptag->m_uiFlagsDefault;
        ptag = ptag->m_ptagNext;
    }  // while:  more tags int he list.

    // Reload the listbox, keeping the same items
    LoadListbox();

}  //*** CTraceDialog::OnDefault()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnItemChangedListbox
//
//  Routine Description:
//      Handler for the LVN_ITEMCHANGED message on the listbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnItemChangedListbox(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW *   pNMListView = (NM_LISTVIEW *) pNMHDR;

    // If the item just became unselected or selected, change the checkboxes to match.
    if ((pNMListView->uChanged & LVIF_STATE)
            && ((pNMListView->uOldState & LVIS_SELECTED)
                || (pNMListView->uNewState & LVIS_SELECTED)))
    {
        // Handle a selection change.
        OnSelChangedListbox();
    }  // if:  item received the focus

    *pResult = 0;

}  //*** CTraceDialog::OnItemChangedListbox()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnSelChangedListbox
//
//  Routine Description:
//      Handles all that needs to when the listbox selection changes. That
//      is adjust the checkbox to their new value and determine if they need
//      to be simple or TRI-state checkboxes.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnSelChangedListbox(void)
{
    int         ili;
    int         nDebugWin       = BST_UNCHECKED;
    int         nDebugBreak     = BST_UNCHECKED;
    int         nCom2           = BST_UNCHECKED;
    int         nFile           = BST_UNCHECKED;
    BOOL        bFirstItem      = TRUE;
    CTraceTag * ptag;

    ili = m_lcTagList.GetNextItem(-1, LVNI_SELECTED);
    while (ili != -1)
    {
        // Get the tag for the selected item.
        ptag = (CTraceTag *) m_lcTagList.GetItemData(ili);
        ASSERT(ptag != NULL);

        ptag->m_uiFlagsDialogStart = ptag->m_uiFlagsDialog;
        if (bFirstItem)
        {
            nDebugWin = ptag->BDebugDialog();
            nDebugBreak = ptag->BBreakDialog();
            nCom2 = ptag->BCom2Dialog();
            nFile = ptag->BFileDialog();
            bFirstItem = FALSE;
        }  // if:  first selected item
        else
        {
            if (ptag->BDebugDialog() != nDebugWin)
                nDebugWin = BST_INDETERMINATE;
            if (ptag->BBreakDialog() != nDebugBreak)
                nDebugBreak = BST_INDETERMINATE;
            if (ptag->BCom2Dialog() != nCom2)
                nCom2 = BST_INDETERMINATE;
            if (ptag->BFileDialog() != nFile)
                nFile = BST_INDETERMINATE;
        }  // else:  not first selected item

        // Get the next selected item.
        ili = m_lcTagList.GetNextItem(ili, LVNI_SELECTED);
    }  // while:  more selected items

    AdjustButton(!bFirstItem, m_chkboxTraceToDebugWin, nDebugWin);
    AdjustButton(!bFirstItem, m_chkboxDebugBreak, nDebugBreak);
    AdjustButton(!bFirstItem, m_chkboxTraceToCom2, nCom2);
    AdjustButton(!bFirstItem, m_chkboxTraceToFile, nFile);

}  //*** CTraceDialog::OnSelChangedListbox()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::AdjustButton
//
//  Routine Description:
//      Configures the checkboxes of the dialog.  This includes setting the
//      style and the value of the buttons.
//
//  Arguments:
//      bEnable     [IN] Determines if the given checkbox is enabled or not
//                    (not when the selection is NULL!).
//      rchkbox     [IN OUT] Checkbox to adjust.
//      nState      [IN] State of the button (BST_CHECKED, BST_UNCHECKED,
//                    or BST_INDETERMINATE).
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::AdjustButton(
    IN BOOL             bEnable,
    IN OUT CButton &    rchkbox,
    IN int              nState
    )
{
    rchkbox.EnableWindow(bEnable);
    
    if (nState == BST_INDETERMINATE)
        rchkbox.SetButtonStyle(BS_AUTO3STATE, FALSE);
    else
        rchkbox.SetButtonStyle(BS_AUTOCHECKBOX, FALSE);

    rchkbox.SetCheck(nState);

}  //*** CTraceDialog::AdjustButton()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnColumnClickListbox
//
//  Routine Description:
//      Handler for the LVN_COLUMNCLICK message on the listbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnColumnClickListbox(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW * pNMListView = (NM_LISTVIEW *) pNMHDR;

    // Save the current sort column and direction.
    if (pNMListView->iSubItem == NSortColumn())
        m_nSortDirection ^= -1;
    else
    {
        m_nSortColumn = pNMListView->iSubItem;
        m_nSortDirection = 0;
    }  // else:  different column

    // Sort the list.
    VERIFY(m_lcTagList.SortItems(CompareItems, (LPARAM) this));

    *pResult = 0;

}  //*** CTraceDialog::OnColumnClickListbox()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::CompareItems [static]
//
//  Routine Description:
//      Callback function for the CListCtrl::SortItems method.
//
//  Arguments:
//      lparam1     First item to compare.
//      lparam2     Second item to compare.
//      lparamSort  Sort parameter.
//
//  Return Value:
//      -1          First parameter comes before second.
//      0           First and second parameters are the same.
//      1           First parameter comes after second.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CALLBACK CTraceDialog::CompareItems(
    LPARAM  lparam1,
    LPARAM  lparam2,
    LPARAM  lparamSort
    )
{
    CTraceTag *     ptag1   = (CTraceTag *) lparam1;
    CTraceTag *     ptag2   = (CTraceTag *) lparam2;
    CTraceDialog *  pdlg    = (CTraceDialog *) lparamSort;
    int             nResult;

    ASSERT(ptag1 != NULL);
    ASSERT(ptag2 != NULL);
    ASSERT_VALID(pdlg);
    ASSERT(pdlg->NSortColumn() >= 0);

    switch (pdlg->NSortColumn())
    {
        // Sorting by subsystem.
        case 0:
            nResult = lstrcmp(ptag1->PszSubsystem(), ptag2->PszSubsystem());
            break;

        // Sorting by name.
        case 1:
            nResult = lstrcmp(ptag1->PszName(), ptag2->PszName());
            break;

        // Sorting by state.
        case 2:
        {
            CString strState1;
            CString strState2;

            ConstructStateString(ptag1, strState1);
            ConstructStateString(ptag2, strState2);

            // Compare the two strings.
            // Use CompareString() so that it will sort properly on localized builds.
            nResult = CompareString(
                        LOCALE_USER_DEFAULT,
                        0,
                        strState1,
                        strState1.GetLength(),
                        strState2,
                        strState2.GetLength()
                        );
            if ( nResult == CSTR_LESS_THAN )
            {
                nResult = -1;
            }
            else if ( nResult == CSTR_EQUAL )
            {
                nResult = 0;
            }
            else if ( nResult == CSTR_GREATER_THAN )
            {
                nResult = 1;
            }
            else
            {
                // An error occurred.  Ignore it.
                nResult = 0;
            }
            break;
        }  // if:  sorting by state

        default:
            nResult = 0;
            break;
    }  // switch:  pdlg->NSortColumn()

    // Return the result based on the direction we are sorting.
    if (pdlg->NSortDirection() != 0)
        nResult = -nResult;

    return nResult;

}  //*** CTraceDialog::CompareItems()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnClickedTraceToDebug
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Trace to Debug Window checkbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnClickedTraceToDebug(void)
{
    ChangeState(m_chkboxTraceToDebugWin, CTraceTag::tfDebug);

}  //*** CTraceDialog::OnClickedTraceToDebug()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnClickedTraceDebugBreak
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Debug Break checkbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnClickedTraceDebugBreak(void)
{
    ChangeState(m_chkboxDebugBreak, CTraceTag::tfBreak);

}  //*** CTraceDialog::OnClickedTraceDebugBreak()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnClickedTraceToCom2
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Trace to COM2 checkbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnClickedTraceToCom2(void)
{
    ChangeState(m_chkboxTraceToCom2, CTraceTag::tfCom2);

}  //*** CTraceDialog::OnClickedTraceToCom2()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnClickedTraceToFile
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Trace to File checkbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnClickedTraceToFile(void)
{
    ChangeState(m_chkboxTraceToFile, CTraceTag::tfFile);

}  //*** CTraceDialog::OnClickedTraceToFile()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::ChangeState
//
//  Routine Description:
//      Change the state of selected items.
//
//  Arguments:
//      rchkbox     [IN OUT] Checkbox whose state is changing.
//      tfMask      [IN] Mask of state flags to change.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::ChangeState(
    IN OUT CButton &            rchkbox,
    IN CTraceTag::TraceFlags    tfMask
    )
{
    int             ili;
    CTraceTag *     ptag;
    CString         strState;
    int             nState;

    nState = rchkbox.GetCheck();

    // Set the proper flag on all selected items.
    ili = m_lcTagList.GetNextItem(-1, LVNI_SELECTED);
    while (ili != -1)
    {
        // Get the selected item.
        ptag = (CTraceTag *) m_lcTagList.GetItemData(ili);
        ASSERT(ptag != NULL);

        // Set the proper flag in the trace tag.
        if (nState == BST_INDETERMINATE)
        {
            ptag->m_uiFlagsDialog &= ~tfMask;
            ptag->m_uiFlagsDialog |= (tfMask & ptag->m_uiFlagsDialogStart);
        }  // if:  checkbox is in an indeterminate state
        else
            ptag->SetFlagsDialog(tfMask, nState);

        // Set the State column.
        ConstructStateString(ptag, strState);
        VERIFY(m_lcTagList.SetItem(ili, 2, LVIF_TEXT, strState, 0, 0, 0, 0) != 0);

        // Get the next item.
        ili = m_lcTagList.GetNextItem(ili, LVNI_SELECTED);
    }  // while:  more items in the list

}  //*** CTraceDialog::ChangeState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::OnSelChangeTagsToDisplay
//
//  Routine Description:
//      Handler for the CBN_SELCHANGE message on the Tags To Display combobox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::OnSelChangeTagsToDisplay(void)
{
    int             nCurFilter;

    // If a change was actually made, reload the listbox.
    nCurFilter = m_cboxDisplayOptions.GetCurSel();
    if (nCurFilter != m_nCurFilter)
    {
        m_nCurFilter = nCurFilter;
        LoadListbox();
    }  // if:  filter changed

}  //*** CTraceDialog::OnSelChangeTagsToDisplay()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::LoadListbox
//
//  Routine Description:
//      Load the listbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceDialog::LoadListbox(void)
{
    int             ili;
    int             iliReturn;
    CTraceTag *     ptag;
    CString         strState;

    m_lcTagList.DeleteAllItems();
    ptag = CTraceTag::s_ptagFirst;
    for (ili = 0 ; ptag != NULL ; )
    {
        // Insert the item in the list if it should be displayed.
        if (BDisplayTag(ptag))
        {
            iliReturn = m_lcTagList.InsertItem(
                                        LVIF_TEXT | LVIF_PARAM,
                                        ili,
                                        ptag->PszSubsystem(),
                                        0,
                                        0,
                                        0,
                                        (LPARAM) ptag
                                        );
            ASSERT(iliReturn != -1);
            VERIFY(m_lcTagList.SetItem(iliReturn, 1, LVIF_TEXT, ptag->PszName(), 0, 0, 0, 0) != 0);
            ConstructStateString(ptag, strState);
            VERIFY(m_lcTagList.SetItem(iliReturn, 2, LVIF_TEXT, strState, 0, 0, 0, 0) != 0);
            ili++;
        }  // if:  tag shold be displayed

        // Get the next tag.
        ptag = ptag->m_ptagNext;
    }  // while:  more tags in the list

    // If the list is not empty, select the first item.
    if (m_lcTagList.GetItemCount() > 0)
        VERIFY(m_lcTagList.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED) != 0);

}  //*** CTraceDialog::LoadListbox()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceDialog::BDisplayTag
//
//  Purpose:
//      Determines if a given tag should be displayed based on
//      the current filter selection.
//
//  Arguments:
//      ptag        [IN] Pointer to the tag to test
//
//  Return Value:
//      TRUE        Display the tag.
//      FALSE       Don't display the tag.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CTraceDialog::BDisplayTag(IN const CTraceTag * ptag)
{
    BOOL    bDisplay        = TRUE;
    
    switch (m_nCurFilter)
    {
        default:
//          AssertAlways(LITERAL("Unknown Filter, adjust CTraceDialog::FDisplayFilter"));
            break;

        case 0:
            break;

        case 1:
            if (!ptag->BDebugDialog())
                bDisplay = FALSE;
            break;
            
        case 2:
            if (!ptag->BBreakDialog())
                bDisplay = FALSE;
            break;

        case 3:
            if (!ptag->BCom2Dialog())
                bDisplay = FALSE;
            break;

        case 4:
            if (!ptag->BFileDialog())
                bDisplay = FALSE;
            break;

        case 5:
            if (!ptag->m_uiFlagsDialog)
                bDisplay = FALSE;
            break;
    }
    
    return bDisplay;

}  //*** CTraceDialog::BDisplayTag()

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\splitfrm.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      SplitFrm.cpp
//
//  Abstract:
//      Implementation of the CSplitterFrame class.
//
//  Author:
//      David Potter (davidp)   May 1, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ConstDef.h"
#include "SplitFrm.h"
#include "MainFrm.h"
#include "TreeView.h"
#include "ListView.h"
#include "TraceTag.h"
#include "ExtDll.h"
#include "ClusItem.h"
#include "ClusDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagSplitFrame(_T("UI"), _T("SPLITTER FRAME"), 0);
CTraceTag   g_tagSplitFrameMenu(_T("Menu"), _T("SPLITTER FRAME MENU"), 0);
CTraceTag   g_tagSplitFrameDrag(_T("Drag&Drop"), _T("SPLITTER FRAME DRAG"), 0);
CTraceTag   g_tagSplitFrameDragMouse(_T("Drag&Drop"), _T("SPLITTER FRAME DRAG MOUSE"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CSplitterFrame
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CSplitterFrame, CMDIChildWnd)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CSplitterFrame, CMDIChildWnd)
    //{{AFX_MSG_MAP(CSplitterFrame)
    ON_WM_CONTEXTMENU()
    ON_WM_DESTROY()
    ON_UPDATE_COMMAND_UI(ID_VIEW_LARGE_ICONS, OnUpdateLargeIconsView)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SMALL_ICONS, OnUpdateSmallIconsView)
    ON_UPDATE_COMMAND_UI(ID_VIEW_LIST, OnUpdateListView)
    ON_UPDATE_COMMAND_UI(ID_VIEW_DETAILS, OnUpdateDetailsView)
    ON_COMMAND(ID_VIEW_LARGE_ICONS, OnLargeIconsView)
    ON_COMMAND(ID_VIEW_SMALL_ICONS, OnSmallIconsView)
    ON_COMMAND(ID_VIEW_LIST, OnListView)
    ON_COMMAND(ID_VIEW_DETAILS, OnDetailsView)
    ON_WM_MOUSEMOVE()
    ON_WM_LBUTTONUP()
    ON_WM_RBUTTONUP()
    //}}AFX_MSG_MAP
#ifdef _DEBUG
    ON_WM_MDIACTIVATE()
#endif
    ON_MESSAGE(WM_CAM_UNLOAD_EXTENSION, OnUnloadExtension)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 0, OnUpdateExtMenu)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 1, OnUpdateExtMenu)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 2, OnUpdateExtMenu)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 3, OnUpdateExtMenu)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 4, OnUpdateExtMenu)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 5, OnUpdateExtMenu)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 6, OnUpdateExtMenu)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 7, OnUpdateExtMenu)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 8, OnUpdateExtMenu)
    ON_UPDATE_COMMAND_UI(CAEXT_MENU_FIRST_ID + 9, OnUpdateExtMenu)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::CSplitterFrame
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CSplitterFrame::CSplitterFrame(void)
{
    m_pdoc = NULL;
    m_iFrame = 0;
    m_pext = NULL;

    // Initialize drag & drop.
    m_bDragging = FALSE;
    m_pimagelist = NULL;
    m_pciDrag = NULL;

}  //*** CSplitterFrame::CSplitterFrame()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::CSplitterFrame
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CSplitterFrame::~CSplitterFrame(void)
{
    // Cleanup after ourselves.
    if ((Pdoc() != NULL) && (Pdoc()->PtiCluster() != NULL))
        Pdoc()->PtiCluster()->PreRemoveFromFrameWithChildren(this);

    // Cleanup any extensions.
    delete Pext();

}  //*** CSplitterFrame::~CSplitterFrame()

#ifdef _DEBUG
void CSplitterFrame::AssertValid(void) const
{
    CMDIChildWnd::AssertValid();

}  //*** CSplitterFrame::AssertValid()

void CSplitterFrame::Dump(CDumpContext& dc) const
{
    CMDIChildWnd::Dump(dc);

}  //*** CSplitterFrame::Dump()

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::CalculateFrameNumber
//
//  Routine Description:
//      Calculate the number of this frame connected to the document.  This
//      should only be called before the views have been created.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::CalculateFrameNumber(void)
{
    POSITION            pos;
    CView *             pview;

    if (Pdoc() != NULL)
    {
        // At least frame # 1 'cause we exist.
        m_iFrame = 1;

        pos = Pdoc()->GetFirstViewPosition();
        while (pos != NULL)
        {
            pview = Pdoc()->GetNextView(pos);
            ASSERT_VALID(pview);
            if (pview->IsKindOf(RUNTIME_CLASS(CClusterTreeView)))
            {
                if (pview->GetParentFrame() == this)
                    break;
                m_iFrame++;
            }  // if:  found another tree view
        }  // while:  more views in the list
    }  // if:  document associated with frame

}  //*** CSplitterFrame::CalculateFrameNumber()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::InitFrame
//
//  Routine Description:
//      Called to initialize the frame after being initially created and
//      after the document has been initialized.
//
//  Arguments:
//      pDoc        Document associated with the frame.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::InitFrame(IN OUT CClusterDoc * pDoc)
{
    m_pdoc = pDoc;
    ASSERT_VALID(Pdoc());

    // Calculate the number of our frame so the views can use it.
    CalculateFrameNumber();

    // Read from the profile.
    {
        CString         strSection;

        strSection.Format(REGPARAM_CONNECTIONS _T("\\%s"), Pdoc()->StrNode());
        // Set window placement.
        {
            WINDOWPLACEMENT wp;

            if (ReadWindowPlacement(&wp, strSection, NFrameNumber()))
                SetWindowPlacement(&wp);

        }  // Set window placement

        // Set splitter bar position.
        {
            CString     strValueName;
            CString     strPosition;
            int         nCurWidth;
            int         nMaxWidth;
            int         nRead;

            try
            {
                ConstructProfileValueName(strValueName, REGPARAM_SPLITTER_BAR_POS);
                strPosition = AfxGetApp()->GetProfileString(strSection, strValueName);
                nRead = _stscanf(strPosition, _T("%d,%d"), &nCurWidth, &nMaxWidth);
                if (nRead == 2)
                {
                    m_wndSplitter.SetColumnInfo(0, nCurWidth, nMaxWidth);
                    m_wndSplitter.RecalcLayout();
                }  // if:  correct number of parameters specified
            }  // try
            catch (CException * pe)
            {
                pe->Delete();
            }  // catch:  CException
        }  // Save the splitter bar position

        // Set the view style of the list view.
        {
            DWORD       dwView;
            CString     strValueName;

            try
            {
                // Construct the value name.
                ConstructProfileValueName(strValueName, REGPARAM_VIEW);

                // Read the view setting.
                dwView = AfxGetApp()->GetProfileInt(strSection, strValueName, (LVS_ICON | LVS_REPORT));
                PviewList()->SetView(dwView);
            }  // try
            catch (CException * pe)
            {
                pe->Delete();
            }  // catch:  CException
        }  // Set the view style of the list view
    }  // Read from the profile

}  //*** CSplitterFrame::InitFrame()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnCreateClient
//
//  Routine Description:
//      Called to create the client views for the frame.  Here we create
//      a splitter window with two views -- a tree view and a list view.
//
//  Arguments:
//      lpcs        Pointer to a CREATESTRUCT.
//      pContext    Pointer to a create context.
//
//  Return Value:
//      TRUE        Client created successfully.
//      FALSE       Failed to create client.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CSplitterFrame::OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext) 
{
    // Create a splitter window with 1 row & 2 columns.
    if (!m_wndSplitter.CreateStatic(this, 1, 2))
    {
        Trace(g_tagSplitFrame, _T("Failed to CreateStaticSplitter"));
        return FALSE;
    }  // if:  error creating splitter window

    // Add the first splitter pane.
    if (!m_wndSplitter.CreateView(0, 0, pContext->m_pNewViewClass, CSize(200, 50), pContext))
    {
        Trace(g_tagSplitFrame, _T("Failed to create first pane"));
        return FALSE;
    }  // if:  error creating first splitter pane

    // Add the second splitter pane.
    if (!m_wndSplitter.CreateView(0, 1, RUNTIME_CLASS(CClusterListView), CSize(0, 0), pContext))
    {
        Trace(g_tagSplitFrame, _T("Failed to create second pane"));
        return FALSE;
    }  // if:  error creating second pane

    // Activate the tree view.
//  SetActiveView((CView *) PviewTree());

    // If this is not the first frame on the document, initialize the frame.
    {
        CClusterDoc * pdoc = (CClusterDoc *) pContext->m_pCurrentDoc;
        if (pdoc->StrNode().GetLength() > 0)
            InitFrame(pdoc);
    }  // If this is not the first frame on the document, initialize the frame

    return TRUE;
    
}  //*** CSplitterFrame::OnCreateClient()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::ConstructProfileValueName
//
//  Routine Description:
//      Construct the name of a value that is to be written to the user's
//      profile.
//
//  Arguments:
//      rstrName    [OUT] String in which to return the constructed name.
//      pszPrefix   [IN] String to prefix the name with.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::ConstructProfileValueName(
    OUT CString &   rstrName,
    IN LPCTSTR      pszPrefix
    ) const
{
    ASSERT(pszPrefix != NULL);

    // Construct the name of the value to read.
    if (NFrameNumber() <= 1)
        rstrName = pszPrefix;
    else
        rstrName.Format(_T("%s-%d"), pszPrefix, NFrameNumber());

}  //*** CSplitterFrame::ConstructProfileValueName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::GetMessageString
//
//  Routine Description:
//      Get a string for a command ID.
//
//  Arguments:
//      nID         [IN] Command ID for which a string should be returned.
//      rMessage    [OUT] String in which to return the message.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::GetMessageString(UINT nID, CString& rMessage) const
{
    BOOL        bHandled    = FALSE;

    if ((Pext() != NULL)
            && (CAEXT_MENU_FIRST_ID <= nID))
        bHandled = Pext()->BGetCommandString(nID, rMessage);

    if (!bHandled)
        CMDIChildWnd::GetMessageString(nID, rMessage);

}  //*** CSplitterFrame::GetMessageString()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU method.
//
//  Arguments:
//      pWnd        Window in which the user right clicked the mouse.
//      point       Position of the cursor, in screen coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::OnContextMenu(CWnd * pWnd, CPoint point)
{
    CView *         pviewActive = GetActiveView();
    CMenu *         pmenu       = NULL;
    CClusterItem *  pci         = NULL;

    Trace(g_tagSplitFrame, _T("OnContextMenu()"));

    if (!BDragging())
    {
        if (pviewActive == PviewTree())
            pmenu = PviewTree()->PmenuPopup(point, pci);
        else if (pviewActive == PviewList())
            pmenu = PviewList()->PmenuPopup(point, pci);

        if (pmenu == NULL)
            pmenu = PmenuPopup();
    }  // if:  not dragging

    if (pmenu != NULL)
    {
        // If there is an extension already loaded, unload it.
        delete Pext();
        m_pext = NULL;

        // If there is an extension for this item, load it.
        if ((pci != NULL)
                && (pci->PlstrExtensions() != NULL)
                && (pci->PlstrExtensions()->GetCount() > 0))
        {
            CWaitCursor     wc;

            try
            {
                m_pext = new CExtensions;
                if ( m_pext == NULL )
                {
                    AfxThrowMemoryException();
                } // if: error allocating the extensions object
                Pext()->AddContextMenuItems(
                            pmenu->GetSubMenu(0),
                            *pci->PlstrExtensions(),
                            pci
                            );
            }  // try
            catch (CException * pe)
            {
#ifdef _DEBUG
                TCHAR       szError[256];
                pe->GetErrorMessage(szError, sizeof(szError) / sizeof(TCHAR));
                Trace(g_tagError, _T("CSplitterFrame::OnContextMenu() - Error loading extension DLL - %s"), szError);
#endif
                pe->Delete();

                delete Pext();
                m_pext = NULL;
            }  // catch:  CException
        }  // if:  this item has an extension

        // Display the menu.
        if (!pmenu->GetSubMenu(0)->TrackPopupMenu(
                        TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                        point.x,
                        point.y,
                        AfxGetMainWnd()
                        ))
        {
            delete Pext();
            m_pext = NULL;
        }  // if:  unsuccessfully displayed the menu
        else if (Pext() != NULL)
            PostMessage(WM_CAM_UNLOAD_EXTENSION, NULL, NULL);;
        pmenu->DestroyMenu();
        delete pmenu;
    }  // if:  there is a menu to display

}  //*** CSplitterFrame::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::PmenuPopup
//
//  Routine Description:
//      Returns a popup menu.
//
//  Arguments:
//      None.
//
//  Return Value:
//      pmenu       A popup menu for the item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CMenu * CSplitterFrame::PmenuPopup( void ) const
{
    CMenu * pmenu;

    // Load the menu.
    pmenu = new CMenu;
    if ( pmenu == NULL )
    {
        AfxThrowMemoryException();
    } // if: error allocating the menu

    if ( ! pmenu->LoadMenu( IDM_VIEW_POPUP ) )
    {
        delete pmenu;
        pmenu = NULL;
    }  // if:  error loading the menu

    return pmenu;

}  //*** CSplitterFrame::PmenuPopup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnCmdMsg
//
//  Routine Description:
//      Processes command messages.  If an extension DLL is loaded and the
//      message is a command selection, pass it on to the DLL.
//
//  Arguments:
//      nID             [IN] Command ID.
//      nCode           [IN] Notification code.
//      pExtra          [IN OUT] Used according to the value of nCode.
//      pHandlerInfo    [OUT] ???
//
//  Return Value:
//      TRUE            Message has been handled.
//      FALSE           Message has NOT been handled.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CSplitterFrame::OnCmdMsg(
    UINT                    nID,
    int                     nCode,
    void *                  pExtra,
    AFX_CMDHANDLERINFO *    pHandlerInfo
    )
{
    BOOL        bHandled    = FALSE;

    // If there is an extension DLL loaded, see if it wants to handle this message.
    if ((Pext() != NULL) && (nCode == 0))
    {
        Trace(g_tagSplitFrame, _T("OnCmdMsg() - Passing message to extension (ID = %d)"), nID);
        bHandled = Pext()->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

        // Unload the extension DLL if there is one loaded.
        if (bHandled)
        {
            delete Pext();
            m_pext = NULL;
        }  // if:  message was handled
    }  // if:  there is an extension DLL loaded

//  if ((CAEXT_MENU_FIRST_ID <= nID) && (nID <= CAEXT_MENU_LAST_ID))
//      Trace(g_tagSplitFrame, _T("CSplitterFrame::OnCmdMsg() - nID = %d, nCode = 0x%08.8x, pExtra = 0x%08.8x\n"), nID, nCode, pExtra);

    if (!bHandled)
        bHandled = CMDIChildWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

    return bHandled;

}  //*** CSplitterFrame::OnCmdMsg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnUpdateExtMenu
//
//  Routine Description:
//      Determines whether extension menu items should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::OnUpdateExtMenu(CCmdUI * pCmdUI)
{
    if (Pext() != NULL)
        Pext()->OnUpdateCommand(pCmdUI);

}  //*** CSplitterFrame::OnUpdateExtMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnUnloadExtension
//
//  Routine Description:
//      Handler for the WM_CAM_UNLOAD_EXTENSION message.
//
//  Arguments:
//      wparam      1st parameter.
//      lparam      2nd parameter.
//
//  Return Value:
//      ERROR_SUCCESS
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CSplitterFrame::OnUnloadExtension(WPARAM wparam, LPARAM lparam)
{
    Trace(g_tagSplitFrame, _T("OnUnloadExtension() - m_pext = 0x%08.8x"), Pext());
    delete Pext();
    m_pext = NULL;
    return ERROR_SUCCESS;

}  //*** CSplitterFrame::OnUnloadExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnDestroy
//
//  Routine Description:
//      Handler method for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::OnDestroy(void)
{
    // Display information about the current menu.
    TraceMenu(g_tagSplitFrameMenu, AfxGetMainWnd()->GetMenu(), _T("Menu before child wnd destroyed: "));

    // Save current settings.
    if (Pdoc() != NULL)
    {
        CString         strSection;

        // Construct the section name.
        ASSERT_VALID(Pdoc());
        strSection.Format(REGPARAM_CONNECTIONS _T("\\%s"), Pdoc()->StrNode());

        // Save the current window position information.
        {
            WINDOWPLACEMENT wp;

            wp.length = sizeof wp;
            if (GetWindowPlacement(&wp))
            {
                wp.flags = 0;
                if (IsZoomed())
                    wp.flags |= WPF_RESTORETOMAXIMIZED;

                // and write it to the .INI file
                WriteWindowPlacement(&wp, strSection, NFrameNumber());
            }  // if:  window placement retrieved successfully
        }  // Save the current window position information

        // Save the splitter bar position.
        {
            CString     strValueName;
            CString     strPosition;
            int         nCurWidth;
            int         nMaxWidth;

            m_wndSplitter.GetColumnInfo(0, nCurWidth, nMaxWidth);
            ConstructProfileValueName(strValueName, REGPARAM_SPLITTER_BAR_POS);
            strPosition.Format(_T("%d,%d"), nCurWidth, nMaxWidth);
            AfxGetApp()->WriteProfileString(strSection, strValueName, strPosition);
        }  // Save the splitter bar position

        // Save the current list view style.
        {
            DWORD       dwView;
            CString     strValueName;

            // Construct the value name.
            ConstructProfileValueName(strValueName, REGPARAM_VIEW);

            // Save the view setting.
            dwView = PviewList()->GetView();
            AfxGetApp()->WriteProfileInt(strSection, strValueName, dwView);
        }  // Save the current list view style
    }  // if:  document is valid

    // Call the base class method.
    CMDIChildWnd::OnDestroy();

    // Display information about the current menu.
    TraceMenu(g_tagSplitFrameMenu, AfxGetMainWnd()->GetMenu(), _T("Menu after child wnd destroyed: "));

}  //*** CSplitterFrame::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnUpdateLargeIconsView
//  CSplitterFrame::OnUpdateSmallIconsView
//  CSplitterFrame::OnUpdateListView
//  CSplitterFrame::OnUpdateDetailsView
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_VIEW_LARGE_ICONS,
//      ID_VIEW_SMALL_ICONS, ID_VIEW_LIST, and ID_VIEW_DETAILS should be
//      enabled or not.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::OnUpdateLargeIconsView(CCmdUI * pCmdUI)
{
    int     nCheck;

    nCheck = PviewList()->GetView();
    pCmdUI->SetRadio(nCheck == LVS_ICON);
    pCmdUI->Enable();

}  //*** CSplitterFrame::OnUpdateLargeIconsView()

void CSplitterFrame::OnUpdateSmallIconsView(CCmdUI * pCmdUI)
{
    int     nCheck;

    nCheck = PviewList()->GetView();
    pCmdUI->SetRadio(nCheck == LVS_SMALLICON);
    pCmdUI->Enable();

}  //*** CSplitterFrame::OnUpdateSmallIconsView()

void CSplitterFrame::OnUpdateListView(CCmdUI * pCmdUI)
{
    int     nCheck;

    nCheck = PviewList()->GetView();
    pCmdUI->SetRadio(nCheck == LVS_LIST);
    pCmdUI->Enable();

}  //*** CSplitterFrame::OnUpdateListView()

void CSplitterFrame::OnUpdateDetailsView(CCmdUI * pCmdUI)
{
    int     nCheck;

    nCheck = PviewList()->GetView();
    pCmdUI->SetRadio(nCheck == (LVS_REPORT | LVS_ICON));
    pCmdUI->Enable();

}  //*** CSplitterFrame::OnUpdateDetailsView()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnCmdLargeIconsView
//  CSplitterFrame::OnCmdSmallIconsView
//  CSplitterFrame::OnCmdListView
//  CSplitterFrame::OnCmdDetailsView
//
//  Routine Description:
//      Processes the ID_VIEW_LARGE_ICONS, ID_VIEW_SMALL_ICONS, ID_VIEW_LIST,
//      and ID_VIEW_DETAILS menu commands.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::OnLargeIconsView(void)
{
    PviewList()->SetView(LVS_ICON);

}  //*** CSplitterFrame::OnLargeIconsView()

void CSplitterFrame::OnSmallIconsView(void)
{
    PviewList()->SetView(LVS_SMALLICON);

}  //*** CSplitterFrame::OnSmallIconsView()

void CSplitterFrame::OnListView(void)
{
    PviewList()->SetView(LVS_LIST);

}  //*** CSplitterFrame::OnListView()

void CSplitterFrame::OnDetailsView(void)
{
    PviewList()->SetView(LVS_REPORT | LVS_ICON);

}  //*** CSplitterFrame::OnDetailsView()

#ifdef _DEBUG
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnMDIActivate
//
//  Routine Description:
//      Handler method for the WM_MDIACTIVATE message.
//
//  Arguments:
//      bActivate       [IN] TRUE if the child is being activated and FALSE
//                          if it is being deactivated.
//      pActivateWnd    [IN OUT] Child window to be activated.
//      pDeactivateWnd  [IN OUT] Child window being deactivated.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::OnMDIActivate(BOOL bActivate, CWnd* pActivateWnd, CWnd* pDeactivateWnd)
{
    if (g_tagSplitFrameMenu.BAny())
    {
        if (!bActivate)
        {
            CMDIFrameWnd *  pFrame = GetMDIFrame();
            CMenu           menuDefault;

            TraceMenu(g_tagSplitFrameMenu, AfxGetMainWnd()->GetMenu(), _T("Menu before deactivating: "));
            menuDefault.Attach(pFrame->m_hMenuDefault);
            TraceMenu(g_tagSplitFrameMenu, &menuDefault, _T("Frame menu before deactivating: "));
            menuDefault.Detach();
        }  // if:  deactivating
        else
        {
            CMDIFrameWnd *  pFrame = GetMDIFrame();
            CMenu           menuDefault;

            menuDefault.Attach(pFrame->m_hMenuDefault);
            TraceMenu(g_tagSplitFrameMenu, &menuDefault, _T("Frame menu before activating: "));
            menuDefault.Detach();
        }  // else:  activating
    }  // if:  tag is active

    CMDIChildWnd::OnMDIActivate(bActivate, pActivateWnd, pDeactivateWnd);

    if (!bActivate)
        TraceMenu(g_tagSplitFrameMenu, AfxGetMainWnd()->GetMenu(), _T("Menu after deactivating: "));

}  //*** CSplitterFrame::OnMDIActivate()
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::BeginDrag
//
//  Routine Description:
//      Called by a view to begin a drag operation.
//
//  Arguments:
//      pimagelist  [IN OUT] Image list to use for the drag operation.
//      pci         [IN OUT] Cluster item being dragged.
//      ptImage     [IN] Specifies the x- and y-coordinate of the cursor.
//      ptStart     [IN] Specifies the x- and y-coordinate of the start position.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::BeginDrag(
    IN OUT CImageList *     pimagelist,
    IN OUT CClusterItem *   pci,
    IN CPoint               ptImage,
    IN CPoint               ptStart
    )
{
    ASSERT(!BDragging());
    ASSERT(pimagelist != NULL);
    ASSERT_VALID(pci);

    // Save the cluster item.
    m_pciDrag = pci;

    // Prepare the image list.
    m_pimagelist = pimagelist;
    VERIFY(Pimagelist()->BeginDrag(0, ptStart));
    VERIFY(Pimagelist()->DragEnter(this, ptImage));
    SetCapture();

    // Set the dragging state.
    m_bDragging = TRUE;

    // Let each view initialize for the drag operation.
    PviewTree()->BeginDrag();
    PviewList()->BeginDrag();

}  //*** CSplitterFrame::BeginDrag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnMouseMove
//
//  Routine Description:
//      Handler method for the WM_MOUSEMOVE message during a drag operation.
//
//  Arguments:
//      nFlags      Indicates whether various virtual keys are down.
//      point       Specifies the x- and y-coordinate of the cursor in frame
//                      coordinates.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::OnMouseMove(UINT nFlags, CPoint point)
{
    // If we are dragging, move the drag image.
    if (BDragging())
    {
        CWnd *  pwndDrop;

        Trace(g_tagSplitFrameDragMouse, _T("OnMouseMove() - Moving to (%d,%d)"), point.x, point.y);

        // Move the item.
        ASSERT(Pimagelist() != NULL);
        VERIFY(Pimagelist()->DragMove(point));

        // Get the child window for this point.
        pwndDrop = ChildWindowFromPoint(point);
        if (pwndDrop == &m_wndSplitter)
            pwndDrop = m_wndSplitter.ChildWindowFromPoint(point);
        if ((pwndDrop == PviewTree()) || (pwndDrop == PviewList()))
            pwndDrop->SetFocus();
        PviewTree()->OnMouseMoveForDrag(nFlags, point, pwndDrop);
        PviewList()->OnMouseMoveForDrag(nFlags, point, pwndDrop);

    }  // if:  tree item is being dragged

    // Call the base class method.
    CMDIChildWnd::OnMouseMove(nFlags, point);

}  //*** CSplitterFrame::OnMouseMove()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnLButtonUp
//  CSplitterFrame::OnRButtonUp
//  CSplitterFrame::OnButtonUp
//
//  Routine Description:
//      Handler method for the WM_LBUTTONUP and WM_RBUTTONUP messages.
//
//  Arguments:
//      nFlags      Indicates whether various virtual keys are down.
//      point       Specifies the x- and y-coordinate of the cursor.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::OnLButtonUp(UINT nFlags, CPoint point)
{
    CMDIChildWnd::OnLButtonUp(nFlags, point);
    OnButtonUp(nFlags, point);

}  //*** CSplitterFrame::OnLButtonUp()

void CSplitterFrame::OnRButtonUp(UINT nFlags, CPoint point)
{
    CMDIChildWnd::OnRButtonUp(nFlags, point);
    OnButtonUp(nFlags, point);

}  //*** CSplitterFrame::OnRButtonUp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::OnButtonUp
//
//  Routine Description:
//      Process a button up event by ending an active drag operation.
//
//  Arguments:
//      nFlags      Indicates whether various virtual keys are down.
//      point       Specifies the x- and y-coordinate of the cursor.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::OnButtonUp(UINT nFlags, CPoint point)
{
    // If we are dragging, process the drop.
    if (BDragging())
    {
        CWnd *          pwndChild;

        Trace(g_tagSplitFrameDrag, _T("OnButtonUp() - Dropping at (%d,%d)"), point.x, point.y);

        // Cleanup the image list.
        ASSERT(Pimagelist() != NULL);
        VERIFY(Pimagelist()->DragLeave(this));
        Pimagelist()->EndDrag();
        delete m_pimagelist;
        m_pimagelist = NULL;

        // Get the child window for this point.
        pwndChild = ChildWindowFromPoint(point);
        if (pwndChild == &m_wndSplitter)
            pwndChild = m_wndSplitter.ChildWindowFromPoint(point);
        if (pwndChild == PviewTree())
            PviewTree()->OnButtonUpForDrag(nFlags, point);
        else if (pwndChild == PviewList())
            PviewList()->OnButtonUpForDrag(nFlags, point);

        // Cleanup.
        PviewTree()->EndDrag();
        PviewList()->EndDrag();
        VERIFY(ReleaseCapture());
        m_bDragging = FALSE;
        m_pciDrag = NULL;
    }  // if:  tree item is being dragged

}  //*** CSplitterFrame::OnButtonUp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::ChangeDragCursor
//
//  Routine Description:
//      Changes the cursor used for dragging.
//
//  Arguments:
//      pszCursor   [IN] System cursor to load.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::ChangeDragCursor(LPCTSTR pszCursor)
{
    HCURSOR hcurDrag = LoadCursor(NULL, pszCursor);
    ASSERT(hcurDrag != NULL);
    SetCursor(hcurDrag);
    Pimagelist()->SetDragCursorImage(0, CPoint(0, 0));  // define the hot spot for the new cursor image

}  //*** CSplitterFrame::ChangeDragCursor()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSplitterFrame::AbortDrag
//
//  Routine Description:
//      Abort the drag & drop operation currently in progress.
//
//  Arguments:
//      pszCursor   [IN] System cursor to load.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CSplitterFrame::AbortDrag(void)
{
    ASSERT(BDragging());

    Trace(g_tagSplitFrameDrag, _T("AbortDrag() - Aborting drag & drop"));

    // Cleanup the image list.
    ASSERT(Pimagelist() != NULL);
    VERIFY(Pimagelist()->DragLeave(this));
    Pimagelist()->EndDrag();
    delete m_pimagelist;
    m_pimagelist = NULL;

    // Cleanup.
    PviewTree()->EndDrag();
    PviewList()->EndDrag();
    VERIFY(ReleaseCapture());
    m_bDragging = FALSE;
    m_pciDrag = NULL;

}  //*** CSplitterFrame::AbortDrag()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\tracedlg.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      TraceDlg.h
//
//  Abstract:
//      Definition of the CTraceDialog class.
//
//  Implementation File:
//      TraceDlg.cpp
//
//  Author:
//      David Potter (davidp)   May 29, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TRACEDLG_H_
#define _TRACEDLG_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
class CTraceDialog;
#endif

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _TRACETAG_H_
#include "TraceTag.h"   // for CTraceTag
#endif

/////////////////////////////////////////////////////////////////////////////
// CTraceDialog dialog
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
class CTraceDialog : public CDialog
{
// Construction
public:
    CTraceDialog(CWnd * pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CTraceDialog)
    enum { IDD = IDD_TRACE_SETTINGS };
    CListCtrl   m_lcTagList;
    CButton m_chkboxTraceToDebugWin;
    CButton m_chkboxDebugBreak;
    CButton m_chkboxTraceToCom2;
    CButton m_chkboxTraceToFile;
    CEdit   m_editFile;
    CComboBox   m_cboxDisplayOptions;
    CString m_strFile;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CTraceDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    static int CALLBACK CompareItems(LPARAM lparam1, LPARAM lparam2, LPARAM lparamSort);
    static void         ConstructStateString(IN const CTraceTag * ptag, OUT CString & rstr);

    void                OnSelChangedListbox(void);
    void                AdjustButton(IN BOOL bEnable, IN OUT CButton & rchkbox, IN int nState);
    void                ChangeState(IN OUT CButton & rchkbox, IN CTraceTag::TraceFlags tfMask);
    void                LoadListbox(void);
    BOOL                BDisplayTag(IN const CTraceTag * ptag);

    int                 m_nCurFilter;
    int                 m_nSortDirection;
    int                 m_nSortColumn;

    int                 NSortDirection(void)        { return m_nSortDirection; }
    int                 NSortColumn(void)           { return m_nSortColumn; }

    // Generated message map functions
    //{{AFX_MSG(CTraceDialog)
    afx_msg void OnSelectAll();
    afx_msg void OnItemChangedListbox(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnClickedTraceToDebug();
    afx_msg void OnClickedTraceDebugBreak();
    afx_msg void OnClickedTraceToCom2();
    afx_msg void OnClickedTraceToFile();
    afx_msg void OnSelChangeTagsToDisplay();
    afx_msg void OnColumnClickListbox(NMHDR* pNMHDR, LRESULT* pResult);
    virtual void OnOK();
    afx_msg void OnDefault();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CTraceDialog
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _TRACEDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\tracetag.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      TraceTag.cpp
//
//  Abstract:
//      Implementation of the CTraceTag class.
//
//  Author:
//      David Potter (davidp)   May 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <winnls.h>
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef  _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

CTraceTag   g_tagAlways(_T("Debug"), _T("Always"), CTraceTag::tfDebug);
CTraceTag   g_tagError(_T("Debug"), _T("Error"), CTraceTag::tfDebug);

// g_pszTraceIniFile must be an LPTSTR so it exists before "{" of WinMain.
// If we make it a CString, it may not be constructed when some of the
// tags are constructed, so we won't restore their value.
//LPTSTR        g_pszTraceIniFile       = _T("Trace.INI");
CString     g_strTraceFile;
BOOL        g_bBarfDebug            = TRUE;

CRITICAL_SECTION    CTraceTag::s_critsec;
BOOL                CTraceTag::s_bCritSecValid = FALSE;

#endif  // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTraceTag
/////////////////////////////////////////////////////////////////////////////

#ifdef  _DEBUG

//  Static Variables...

CTraceTag *     CTraceTag::s_ptagFirst  = NULL;
CTraceTag *     CTraceTag::s_ptagLast   = NULL;
//HANDLE            CTraceTag::s_hfileCom2  = NULL;
LPCTSTR         CTraceTag::s_pszCom2    = _T(" com2 ");
LPCTSTR         CTraceTag::s_pszFile    = _T(" file ");
LPCTSTR         CTraceTag::s_pszDebug   = _T(" debug ");
LPCTSTR         CTraceTag::s_pszBreak   = _T(" break ");

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::CTraceTag
//
//  Routine Description:
//      Constructor.  "Initializes" the tag by giving it its name, giving
//      it a startup value (from the registry if possible), and adding it
//      to the list of current tags.
//
//  Arguments:
//      pszSubsystem    [IN] 8 char string to say to what the tag applies
//      pszName         [IN] Description of the tag (~30 chars)
//      uiFlagsDefault  [IN] Default value.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTraceTag::CTraceTag(
    IN LPCTSTR  pszSubsystem,
    IN LPCTSTR  pszName,
    IN UINT     uiFlagsDefault
    )
{
    //  Store the calling parameters
    m_pszSubsystem = pszSubsystem;
    m_pszName = pszName;
    m_uiFlagsDefault = uiFlagsDefault;
    m_uiFlags = uiFlagsDefault;

    //  Add the tag to the list of tags
    if (s_ptagLast != NULL)
        s_ptagLast->m_ptagNext = this;
    else
        s_ptagFirst = this;

    s_ptagLast = this;
    m_ptagNext = NULL;

    m_uiFlags = 0;

}  //*** CTraceTag::CTraceTag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::~CTraceTag
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTraceTag::~CTraceTag(void)
{
#ifdef NEVER
    if (s_hfileCom2 && (s_hfileCom2 != INVALID_HANDLE_VALUE))
    {
        ::CloseHandle(s_hfileCom2);
        s_hfileCom2 = NULL;
    }
#endif

}  //*** CTraceTag::~CTraceTag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::Init
//
//  Routine Description:
//      Initializes the tag by giving it its name and giving it a startup value
//      (from the registry if possible).
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::Init(void)
{
    CString     strSection;
    CString     strValue;

    //  Get the value from the Registry.
    strSection.Format(TRACE_TAG_REG_SECTION_FMT, m_pszSubsystem);
    strValue = AfxGetApp()->GetProfileString(strSection, m_pszName, 0);
    strValue.MakeLower();
    if (strValue.Find(s_pszCom2) != -1)
        m_uiFlags |= tfCom2;
    if (strValue.Find(s_pszFile) != -1)
        m_uiFlags |= tfFile;
    if (strValue.Find(s_pszDebug) != -1)
        m_uiFlags |= tfDebug;
    if (strValue.Find(s_pszBreak) != -1)
        m_uiFlags |= tfBreak;

}  //*** CTraceTag::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::ConstructRegState
//
//  Routine Description:
//      Constructs the registry state string.
//
//  Arguments:
//      rstr        [OUT] String in which to return the state string.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::ConstructRegState(OUT CString & rstr)
{
    rstr = "";
    if (BDebug())
        rstr += s_pszDebug;
    if (BBreak())
        rstr += s_pszBreak;
    if (BCom2())
        rstr += s_pszCom2;
    if (BFile())
        rstr += s_pszFile;

}  //*** CTraceTag::ConstructRegState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::SetFlags
//
//  Routine Description:
//      Sets/Resets TraceFlags.
//
//  Arguments:
//      tf          [IN] Flags to set.
//      bEnable     [IN] TRUE = set the flags, FALSE = clear the flags.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::SetFlags(IN UINT tf, IN BOOL bEnable)
{
    if (bEnable)
        m_uiFlags |= tf;
    else
        m_uiFlags &= ~tf;

}  //*** CTraceTag::SetFlags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::SetFlagsDialog
//
//  Routine Description:
//      Sets/Resets the "Dialog Settings"  version of the TraceFlags.
//
//  Arguments:
//      tf          [IN] Flags to set.
//      bEnable     [IN] TRUE = set the flags, FALSE = clear the flags.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::SetFlagsDialog(IN UINT tf, IN BOOL bEnable)
{
    if (bEnable)
        m_uiFlagsDialog |= tf;
    else
        m_uiFlagsDialog &= ~tf;

}  //*** CTraceTag::SetFlagsDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::PszFile
//
//  Routine Description:
//      Returns the name of the file where to write the trace output.
//      The filename is read from the registry if it is unknown.
//
//  Arguments:
//      None.
//
//  Return Value:
//      psz     Name of the file.
//
//--
/////////////////////////////////////////////////////////////////////////////
LPCTSTR CTraceTag::PszFile(void)
{
    static  BOOL    bInitialized    = FALSE;

    if (!bInitialized)
    {
        g_strTraceFile = AfxGetApp()->GetProfileString(
                                        TRACE_TAG_REG_SECTION,
                                        TRACE_TAG_REG_FILE,
                                        _T("C:\\Trace.out")
                                        );
#ifdef NEVER
        ::GetPrivateProfileString(
            _T("Trace File"),
            _T("Trace File"),
            _T("\\Trace.OUT"),
            g_strTraceFile.Sz(),
            g_strTraceFile.CchMac(),
            g_pszTraceIniFile
            );
#endif
        bInitialized = TRUE;
    }

    return g_strTraceFile;

}  //*** CTraceTag::PszFile()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::TraceV
//
//  Routine Description:
//      Processes a Trace statement based on the flags of the tag.
//
//  Arguments:
//      pszFormat   [IN] printf-style format string.
//      va_list     [IN] Argument block for the format string.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::TraceV(IN LPCTSTR pszFormat, va_list marker)
{
    CString     strTraceMsg;
    LPSTR       psz;
    CB          cb;
    CB          cbActual;
    
    // Get out quick with any formats if we're not turned on
    if (!m_pszName || !BAny())
        return;

    if (BCritSecValid())
        EnterCriticalSection(&s_critsec);

    FormatV(pszFormat, marker);
    strTraceMsg.Format(_T("%s: %s\x0D\x0A"), m_pszName, m_pchData);

    // Send trace output to the debug window.
    if (BDebug())
        OutputDebugString(strTraceMsg);

    if (BCom2() || BFile())
    {
#ifdef _UNICODE
        // Not much point in sending UNICODE output to COMM or file at the moment,
        // so convert to ANSI
        CHAR    aszTraceMsg[256];
        cb = ::WideCharToMultiByte(
                    CP_ANSI,
                    NULL,
                    strTraceMsg,
                    strTraceMsg.GetLength(),
                    aszTraceMsg,
                    sizeof(aszTraceMsg),
                    NULL,
                    NULL
                    );
        psz = aszTraceMsg;
#else
        cb = strTraceMsg.GetLength();
        psz = (LPSTR) (LPCSTR) strTraceMsg;
#endif

        // Send trace output to COM2.
        if (BCom2())
        {
            HANDLE          hfile           = INVALID_HANDLE_VALUE;
            static  BOOL    bOpenFailed     = FALSE;

            if (!bOpenFailed)
            {
                hfile = ::CreateFile(
                                _T("COM2:"),
                                GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_WRITE_THROUGH,
                                NULL
                                );
            }  // if:  not currently in a 'COM2 failed to open' state
            
            if (hfile != INVALID_HANDLE_VALUE)
            {
                ASSERT(::WriteFile(hfile, psz, cb, (LPDWORD) &cbActual, NULL));
//              ASSERT(::FlushFileBuffers(hfile));
                ASSERT(::CloseHandle(hfile));
            }  // if:  COM2 opened successfully
            else
            {
                if (!bOpenFailed)
                {
                    bOpenFailed = TRUE;     // Do this first, so the str.Format
                                            // do not cause problems with their trace statement.

                    AfxMessageBox(_T("COM2 could not be opened."), MB_OK | MB_ICONINFORMATION);
                }  // if:  open file didn't fail
            }  // else:  file not opened successfully
        }  // if:  sending trace output to COM2

        // Send trace output to a file.
        if (BFile())
        {
            HANDLE          hfile           = INVALID_HANDLE_VALUE;
            static  BOOL    bOpenFailed     = FALSE;

            if (!bOpenFailed)
            {
                hfile = ::CreateFile(
                                PszFile(),
                                GENERIC_WRITE,
                                FILE_SHARE_WRITE,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_FLAG_WRITE_THROUGH,
                                NULL
                                );
            }  // if:  not currently in a 'file failed to open' state

            if (hfile != INVALID_HANDLE_VALUE)
            {
                // Fail these calls silently to avoid recursive failing calls.
                ::SetFilePointer(hfile, NULL, NULL, FILE_END);
                ::WriteFile(hfile, psz, cb, (LPDWORD) &cbActual, NULL);
                ::CloseHandle(hfile);
            }  // if:  file opened successfully
            else
            {
                if (!bOpenFailed)
                {
                    CString     strMsg;

                    bOpenFailed = TRUE;     // Do this first, so the str.Format
                                            // do not cause problems with their trace statement.

                    strMsg.Format(_T("The DEBUG ONLY trace log file '%s' could not be opened"), PszFile());
                    AfxMessageBox(strMsg, MB_OK | MB_ICONINFORMATION);
                }  // if:  open file didn't fail
            }  // else:  file not opened successfully
        }  // if:  sending trace output to a file
    }  // if:  tracing to com and/or file

    // Do a DebugBreak on the trace.
    if (BBreak())
        DebugBreak();

    if (BCritSecValid())
        LeaveCriticalSection(&s_critsec);

}  //*** CTraceTag::TraceFn()

#endif // _DEBUG


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

#ifdef  _DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  Trace
//
//  Routine Description:
//      Maps the Trace statement to the proper method call.  This is needed
//      (instead of doing directly ptag->Trace()) to guarantee that no code
//      is added in the retail build.
//
//  Arguments:
//      rtag        [IN OUT] Tag controlling the debug output
//      pszFormat   [IN] printf style formatting string.
//      ...         [IN] printf style parameters, depends on pszFormat
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void __cdecl Trace(IN OUT CTraceTag & rtag, IN LPCTSTR pszFormat, ...)
{
    va_list     marker;

    va_start(marker, pszFormat);
    rtag.TraceV(pszFormat, marker);
    va_end(marker);

}  //*** Trace()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  TraceError
//
//  Routine Description:
//      Formats a standard error string and outputs it to all trace outputs.
//
//  Arguments:
//      rexcept     [IN OUT] Exception from which to obtain the message.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void TraceError(IN OUT CException & rexcept)
{
    TCHAR           szMessage[1024];

    rexcept.GetErrorMessage(szMessage, sizeof(szMessage) / sizeof(TCHAR));

    Trace(
        g_tagError,
        _T("EXCEPTION: %s"),
        szMessage
        );

}  //*** TraceError(CException&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  TraceError
//
//  Routine Description:
//      Formats a standard error string and outputs it to all trace outputs.
//
//  Arguments:
//      pszModule   [IN] Name of module in which error occurred.
//      sc          [IN] NT status code.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void TraceError(IN LPCTSTR pszModule, IN SC sc)
{
    TCHAR           szMessage[1024];
    CNTException    nte(sc);

    nte.GetErrorMessage(szMessage, sizeof(szMessage) / sizeof(TCHAR));

    Trace(
        g_tagError,
        _T("Module %s, SC = %#08lX = %d (10)\r\n = '%s'"),
        pszModule,
        sc,
        sc,
        szMessage
        );

}  //*** TraceError(pszModule, sc)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  InitAllTraceTags
//
//  Routine Description:
//      Initializes all trace tags in the tag list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void InitAllTraceTags(void)
{
    CTraceTag * ptag;

    // Loop through the tag list.
    for (ptag = CTraceTag::s_ptagFirst ; ptag != NULL ; ptag = ptag->m_ptagNext)
        ptag->Init();

    InitializeCriticalSection(&CTraceTag::s_critsec);
    CTraceTag::s_bCritSecValid = TRUE;

}  //*** InitAllTraceTags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CleanupAllTraceTags
//
//  Routine Description:
//      Cleanup after the trace tags.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CleanupAllTraceTags(void)
{
    if (CTraceTag::BCritSecValid())
    {
        DeleteCriticalSection(&CTraceTag::s_critsec);
        CTraceTag::s_bCritSecValid = FALSE;
    }  // if:  critical section is valid

}  //*** CleanupAllTraceTags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  TraceMenu
//
//  Routine Description:
//      Display information about menus.
//
//  Arguments:
//      rtag        [IN OUT] Trace tag to use to display information.
//      pmenu       [IN] Menu to traverse.
//      pszPrefix   [IN] Prefix string to display.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void TraceMenu(
    IN OUT CTraceTag &  rtag,
    IN const CMenu *    pmenu,
    IN LPCTSTR          pszPrefix
    )
{
    if (rtag.BAny())
    {
        UINT    cItems;
        UINT    iItem;
        UINT    nState;
        CString strMenu;
        CString strPrefix(pszPrefix);
        
        strPrefix += _T("->");

        cItems = pmenu->GetMenuItemCount();
        for (iItem = 0 ; iItem < cItems ; iItem++)
        {
            pmenu->GetMenuString(iItem, strMenu, MF_BYPOSITION);
            nState = pmenu->GetMenuState(iItem, MF_BYPOSITION);
            if (nState & MF_SEPARATOR)
                strMenu += _T("SEPARATOR");
            if (nState & MF_CHECKED)
                strMenu += _T(" (checked)");
            if (nState & MF_DISABLED)
                strMenu += _T(" (disabled)");
            if (nState & MF_GRAYED)
                strMenu += _T(" (grayed)");
            if (nState & MF_MENUBARBREAK)
                strMenu += _T(" (MenuBarBreak)");
            if (nState & MF_MENUBREAK)
                strMenu += _T(" (MenuBreak)");
            if (nState & MF_POPUP)
                strMenu += _T(" (popup)");

            Trace(rtag, _T("(0x%08.8x) %s%s"), pszPrefix, pmenu->m_hMenu, strMenu);

            if (nState & MF_POPUP)
                TraceMenu(rtag, pmenu->GetSubMenu(iItem), strPrefix);
        }  // for:  each item in the menu
    }  // if:  any output is enabled

}  //*** TraceMenu()

struct AFX_MAP_MESSAGE
{
    UINT    nMsg;
    LPCSTR  lpszMsg;
};

#include "dde.h"
#define DEFINE_MESSAGE(wm)  { wm, #wm }

static const AFX_MAP_MESSAGE allMessages[] =
{
    DEFINE_MESSAGE(WM_CREATE),
    DEFINE_MESSAGE(WM_DESTROY),
    DEFINE_MESSAGE(WM_MOVE),
    DEFINE_MESSAGE(WM_SIZE),
    DEFINE_MESSAGE(WM_ACTIVATE),
    DEFINE_MESSAGE(WM_SETFOCUS),
    DEFINE_MESSAGE(WM_KILLFOCUS),
    DEFINE_MESSAGE(WM_ENABLE),
    DEFINE_MESSAGE(WM_SETREDRAW),
    DEFINE_MESSAGE(WM_SETTEXT),
    DEFINE_MESSAGE(WM_GETTEXT),
    DEFINE_MESSAGE(WM_GETTEXTLENGTH),
    DEFINE_MESSAGE(WM_PAINT),
    DEFINE_MESSAGE(WM_CLOSE),
    DEFINE_MESSAGE(WM_QUERYENDSESSION),
    DEFINE_MESSAGE(WM_QUIT),
    DEFINE_MESSAGE(WM_QUERYOPEN),
    DEFINE_MESSAGE(WM_ERASEBKGND),
    DEFINE_MESSAGE(WM_SYSCOLORCHANGE),
    DEFINE_MESSAGE(WM_ENDSESSION),
    DEFINE_MESSAGE(WM_SHOWWINDOW),
    DEFINE_MESSAGE(WM_CTLCOLORMSGBOX),
    DEFINE_MESSAGE(WM_CTLCOLOREDIT),
    DEFINE_MESSAGE(WM_CTLCOLORLISTBOX),
    DEFINE_MESSAGE(WM_CTLCOLORBTN),
    DEFINE_MESSAGE(WM_CTLCOLORDLG),
    DEFINE_MESSAGE(WM_CTLCOLORSCROLLBAR),
    DEFINE_MESSAGE(WM_CTLCOLORSTATIC),
    DEFINE_MESSAGE(WM_WININICHANGE),
    DEFINE_MESSAGE(WM_DEVMODECHANGE),
    DEFINE_MESSAGE(WM_ACTIVATEAPP),
    DEFINE_MESSAGE(WM_FONTCHANGE),
    DEFINE_MESSAGE(WM_TIMECHANGE),
    DEFINE_MESSAGE(WM_CANCELMODE),
    DEFINE_MESSAGE(WM_SETCURSOR),
    DEFINE_MESSAGE(WM_MOUSEACTIVATE),
    DEFINE_MESSAGE(WM_CHILDACTIVATE),
    DEFINE_MESSAGE(WM_QUEUESYNC),
    DEFINE_MESSAGE(WM_GETMINMAXINFO),
    DEFINE_MESSAGE(WM_ICONERASEBKGND),
    DEFINE_MESSAGE(WM_NEXTDLGCTL),
    DEFINE_MESSAGE(WM_SPOOLERSTATUS),
    DEFINE_MESSAGE(WM_DRAWITEM),
    DEFINE_MESSAGE(WM_MEASUREITEM),
    DEFINE_MESSAGE(WM_DELETEITEM),
    DEFINE_MESSAGE(WM_VKEYTOITEM),
    DEFINE_MESSAGE(WM_CHARTOITEM),
    DEFINE_MESSAGE(WM_SETFONT),
    DEFINE_MESSAGE(WM_GETFONT),
    DEFINE_MESSAGE(WM_QUERYDRAGICON),
    DEFINE_MESSAGE(WM_COMPAREITEM),
    DEFINE_MESSAGE(WM_COMPACTING),
    DEFINE_MESSAGE(WM_NCCREATE),
    DEFINE_MESSAGE(WM_NCDESTROY),
    DEFINE_MESSAGE(WM_NCCALCSIZE),
    DEFINE_MESSAGE(WM_NCHITTEST),
    DEFINE_MESSAGE(WM_NCPAINT),
    DEFINE_MESSAGE(WM_NCACTIVATE),
    DEFINE_MESSAGE(WM_GETDLGCODE),
    DEFINE_MESSAGE(WM_NCMOUSEMOVE),
    DEFINE_MESSAGE(WM_NCLBUTTONDOWN),
    DEFINE_MESSAGE(WM_NCLBUTTONUP),
    DEFINE_MESSAGE(WM_NCLBUTTONDBLCLK),
    DEFINE_MESSAGE(WM_NCRBUTTONDOWN),
    DEFINE_MESSAGE(WM_NCRBUTTONUP),
    DEFINE_MESSAGE(WM_NCRBUTTONDBLCLK),
    DEFINE_MESSAGE(WM_NCMBUTTONDOWN),
    DEFINE_MESSAGE(WM_NCMBUTTONUP),
    DEFINE_MESSAGE(WM_NCMBUTTONDBLCLK),
    DEFINE_MESSAGE(WM_KEYDOWN),
    DEFINE_MESSAGE(WM_KEYUP),
    DEFINE_MESSAGE(WM_CHAR),
    DEFINE_MESSAGE(WM_DEADCHAR),
    DEFINE_MESSAGE(WM_SYSKEYDOWN),
    DEFINE_MESSAGE(WM_SYSKEYUP),
    DEFINE_MESSAGE(WM_SYSCHAR),
    DEFINE_MESSAGE(WM_SYSDEADCHAR),
    DEFINE_MESSAGE(WM_KEYLAST),
    DEFINE_MESSAGE(WM_INITDIALOG),
    DEFINE_MESSAGE(WM_COMMAND),
    DEFINE_MESSAGE(WM_SYSCOMMAND),
    DEFINE_MESSAGE(WM_TIMER),
    DEFINE_MESSAGE(WM_HSCROLL),
    DEFINE_MESSAGE(WM_VSCROLL),
    DEFINE_MESSAGE(WM_INITMENU),
    DEFINE_MESSAGE(WM_INITMENUPOPUP),
    DEFINE_MESSAGE(WM_MENUSELECT),
    DEFINE_MESSAGE(WM_MENUCHAR),
    DEFINE_MESSAGE(WM_ENTERIDLE),
    DEFINE_MESSAGE(WM_MOUSEMOVE),
    DEFINE_MESSAGE(WM_LBUTTONDOWN),
    DEFINE_MESSAGE(WM_LBUTTONUP),
    DEFINE_MESSAGE(WM_LBUTTONDBLCLK),
    DEFINE_MESSAGE(WM_RBUTTONDOWN),
    DEFINE_MESSAGE(WM_RBUTTONUP),
    DEFINE_MESSAGE(WM_RBUTTONDBLCLK),
    DEFINE_MESSAGE(WM_MBUTTONDOWN),
    DEFINE_MESSAGE(WM_MBUTTONUP),
    DEFINE_MESSAGE(WM_MBUTTONDBLCLK),
    DEFINE_MESSAGE(WM_PARENTNOTIFY),
    DEFINE_MESSAGE(WM_MDICREATE),
    DEFINE_MESSAGE(WM_MDIDESTROY),
    DEFINE_MESSAGE(WM_MDIACTIVATE),
    DEFINE_MESSAGE(WM_MDIRESTORE),
    DEFINE_MESSAGE(WM_MDINEXT),
    DEFINE_MESSAGE(WM_MDIMAXIMIZE),
    DEFINE_MESSAGE(WM_MDITILE),
    DEFINE_MESSAGE(WM_MDICASCADE),
    DEFINE_MESSAGE(WM_MDIICONARRANGE),
    DEFINE_MESSAGE(WM_MDIGETACTIVE),
    DEFINE_MESSAGE(WM_MDISETMENU),
    DEFINE_MESSAGE(WM_CUT),
    DEFINE_MESSAGE(WM_COPY),
    DEFINE_MESSAGE(WM_PASTE),
    DEFINE_MESSAGE(WM_CLEAR),
    DEFINE_MESSAGE(WM_UNDO),
    DEFINE_MESSAGE(WM_RENDERFORMAT),
    DEFINE_MESSAGE(WM_RENDERALLFORMATS),
    DEFINE_MESSAGE(WM_DESTROYCLIPBOARD),
    DEFINE_MESSAGE(WM_DRAWCLIPBOARD),
    DEFINE_MESSAGE(WM_PAINTCLIPBOARD),
    DEFINE_MESSAGE(WM_VSCROLLCLIPBOARD),
    DEFINE_MESSAGE(WM_SIZECLIPBOARD),
    DEFINE_MESSAGE(WM_ASKCBFORMATNAME),
    DEFINE_MESSAGE(WM_CHANGECBCHAIN),
    DEFINE_MESSAGE(WM_HSCROLLCLIPBOARD),
    DEFINE_MESSAGE(WM_QUERYNEWPALETTE),
    DEFINE_MESSAGE(WM_PALETTEISCHANGING),
    DEFINE_MESSAGE(WM_PALETTECHANGED),
    DEFINE_MESSAGE(WM_DDE_INITIATE),
    DEFINE_MESSAGE(WM_DDE_TERMINATE),
    DEFINE_MESSAGE(WM_DDE_ADVISE),
    DEFINE_MESSAGE(WM_DDE_UNADVISE),
    DEFINE_MESSAGE(WM_DDE_ACK),
    DEFINE_MESSAGE(WM_DDE_DATA),
    DEFINE_MESSAGE(WM_DDE_REQUEST),
    DEFINE_MESSAGE(WM_DDE_POKE),
    DEFINE_MESSAGE(WM_DDE_EXECUTE),
    DEFINE_MESSAGE(WM_DROPFILES),
    DEFINE_MESSAGE(WM_POWER),
    DEFINE_MESSAGE(WM_WINDOWPOSCHANGED),
    DEFINE_MESSAGE(WM_WINDOWPOSCHANGING),
// MFC specific messages
    DEFINE_MESSAGE(WM_SIZEPARENT),
    DEFINE_MESSAGE(WM_SETMESSAGESTRING),
    DEFINE_MESSAGE(WM_IDLEUPDATECMDUI),
    DEFINE_MESSAGE(WM_INITIALUPDATE),
    DEFINE_MESSAGE(WM_COMMANDHELP),
    DEFINE_MESSAGE(WM_HELPHITTEST),
    DEFINE_MESSAGE(WM_EXITHELPMODE),
    DEFINE_MESSAGE(WM_HELP),
    DEFINE_MESSAGE(WM_NOTIFY),
    DEFINE_MESSAGE(WM_CONTEXTMENU),
    DEFINE_MESSAGE(WM_TCARD),
    DEFINE_MESSAGE(WM_MDIREFRESHMENU),
    DEFINE_MESSAGE(WM_MOVING),
    DEFINE_MESSAGE(WM_STYLECHANGED),
    DEFINE_MESSAGE(WM_STYLECHANGING),
    DEFINE_MESSAGE(WM_SIZING),
    DEFINE_MESSAGE(WM_SETHOTKEY),
    DEFINE_MESSAGE(WM_PRINT),
    DEFINE_MESSAGE(WM_PRINTCLIENT),
    DEFINE_MESSAGE(WM_POWERBROADCAST),
    DEFINE_MESSAGE(WM_HOTKEY),
    DEFINE_MESSAGE(WM_GETICON),
    DEFINE_MESSAGE(WM_EXITMENULOOP),
    DEFINE_MESSAGE(WM_ENTERMENULOOP),
    DEFINE_MESSAGE(WM_DISPLAYCHANGE),
    DEFINE_MESSAGE(WM_STYLECHANGED),
    DEFINE_MESSAGE(WM_STYLECHANGING),
    DEFINE_MESSAGE(WM_GETICON),
    DEFINE_MESSAGE(WM_SETICON),
    DEFINE_MESSAGE(WM_SIZING),
    DEFINE_MESSAGE(WM_MOVING),
    DEFINE_MESSAGE(WM_CAPTURECHANGED),
    DEFINE_MESSAGE(WM_DEVICECHANGE),
    DEFINE_MESSAGE(WM_PRINT),
    DEFINE_MESSAGE(WM_PRINTCLIENT),
// MFC private messages
    DEFINE_MESSAGE(WM_QUERYAFXWNDPROC),
    DEFINE_MESSAGE(WM_RECALCPARENT),
    DEFINE_MESSAGE(WM_SIZECHILD),
    DEFINE_MESSAGE(WM_KICKIDLE),
    DEFINE_MESSAGE(WM_QUERYCENTERWND),
    DEFINE_MESSAGE(WM_DISABLEMODAL),
    DEFINE_MESSAGE(WM_FLOATSTATUS),
    DEFINE_MESSAGE(WM_ACTIVATETOPLEVEL),
    DEFINE_MESSAGE(WM_QUERY3DCONTROLS),
    DEFINE_MESSAGE(WM_RESERVED_0370),
    DEFINE_MESSAGE(WM_RESERVED_0371),
    DEFINE_MESSAGE(WM_RESERVED_0372),
    DEFINE_MESSAGE(WM_SOCKET_NOTIFY),
    DEFINE_MESSAGE(WM_SOCKET_DEAD),
    DEFINE_MESSAGE(WM_POPMESSAGESTRING),
    DEFINE_MESSAGE(WM_OCC_LOADFROMSTREAM),
    DEFINE_MESSAGE(WM_OCC_LOADFROMSTORAGE),
    DEFINE_MESSAGE(WM_OCC_INITNEW),
    DEFINE_MESSAGE(WM_OCC_LOADFROMSTREAM_EX),
    DEFINE_MESSAGE(WM_OCC_LOADFROMSTORAGE_EX),
    DEFINE_MESSAGE(WM_QUEUE_SENTINEL),
    DEFINE_MESSAGE(WM_RESERVED_037C),
    DEFINE_MESSAGE(WM_RESERVED_037D),
    DEFINE_MESSAGE(WM_RESERVED_037E),
    { 0, NULL, }    // end of message list
};

#undef DEFINE_MESSAGE
#define _countof(array) (sizeof(array)/sizeof(array[0]))

void AFXAPI TraceMsg(LPCTSTR lpszPrefix, HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    ASSERT(lpszPrefix != NULL);

    if (message == WM_MOUSEMOVE || message == WM_NCMOUSEMOVE ||
        message == WM_NCHITTEST || message == WM_SETCURSOR ||
        message == WM_CTLCOLORBTN ||
        message == WM_CTLCOLORDLG ||
        message == WM_CTLCOLOREDIT ||
        message == WM_CTLCOLORLISTBOX ||
        message == WM_CTLCOLORMSGBOX ||
        message == WM_CTLCOLORSCROLLBAR ||
        message == WM_CTLCOLORSTATIC ||
        message == WM_ENTERIDLE || message == WM_CANCELMODE ||
        message == 0x0118)    // WM_SYSTIMER (caret blink)
    {
        // don't report very frequently sent messages
        return;
    }

    LPCSTR lpszMsgName = NULL;
    char szBuf[80];

    // find message name
    if (message >= 0xC000)
    {
        // Window message registered with 'RegisterWindowMessage'
        //  (actually a USER atom)
        if (::GetClipboardFormatNameA(message, szBuf, _countof(szBuf)))
            lpszMsgName = szBuf;
    }
    else if (message >= WM_USER)
    {
        // User message
        wsprintfA(szBuf, "WM_USER+0x%04X", message - WM_USER);
        lpszMsgName = szBuf;
    }
    else
    {
        // a system windows message
        const AFX_MAP_MESSAGE* pMapMsg = allMessages;
        for (/*null*/; pMapMsg->lpszMsg != NULL; pMapMsg++)
        {
            if (pMapMsg->nMsg == message)
            {
                lpszMsgName = pMapMsg->lpszMsg;
                break;
            }
        }
    }

    if (lpszMsgName != NULL)
    {
        AfxTrace(_T("%s: hwnd=0x%04X, msg = %hs (0x%04X, 0x%08lX)\n"),
            lpszPrefix, (UINT)hwnd, lpszMsgName,
            wParam, lParam);
    }
    else
    {
        AfxTrace(_T("%s: hwnd=0x%04X, msg = 0x%04X (0x%04X, 0x%08lX)\n"),
            lpszPrefix, (UINT)hwnd, message,
            wParam, lParam);
    }

//#ifndef _MAC
//  if (message >= WM_DDE_FIRST && message <= WM_DDE_LAST)
//      TraceDDE(lpszPrefix, pMsg);
//#endif

}  //*** TraceMsg()

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

/////////////////////////////////////////////////////////////////////////////
// Common Pragmas
/////////////////////////////////////////////////////////////////////////////

#pragma warning(disable : 4100)     // unreferenced formal parameters
#pragma warning(disable : 4702)     // unreachable code
#pragma warning(disable : 4711)     // function selected for automatic inline expansion

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

//#define _DISPLAY_STATE_TEXT_IN_TREE
#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcview.h>
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

// Need to include this for WM_COMMANDHELP.  Unfortunately, both afxpriv.h and
// atlconv.h define some of the same macros.  Since we are using ATL, we'll use
// the ATL versions.
#define __AFXCONV_H__
#include <afxpriv.h>
#undef __AFXCONV_H__
#undef DEVMODEW2A
#undef DEVMODEA2W
#undef TEXTMETRICW2A
#undef TEXTMETRICA2W

#include <afxtempl.h>       // MFC template classes

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#ifndef _WINREG_
#include <winreg.h>     // for REGSAM (needed by clusapi.h)
#endif

#ifndef _CLUSTER_API_
#include <clusapi.h>    // for cluster definitions
#endif

#ifndef _CLUSUDEF_H_
#include "clusudef.h"   // for cluster project-wide definitions
#endif

#ifndef _CLUSRTL_INCLUDED_
#include "clusrtl.h"
#endif

#include <netcon.h>
#include <htmlhelp.h>

#ifndef _CADMTYPE_H_
#include "cadmtype.h"
#endif

#include <ClusCfgWizard.h>
#include <ClusCfgGuids.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\treeitem.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		TreeItem.inl
//
//	Abstract:
//		Inline function implementations for the CTreeItem class.
//
//	Author:
//		David Potter (davidp)	May 3, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_INL_
#define _TREEITEM_INL_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_H_
#include "TreeItem.h"	// for CTreeItem
#endif

#ifndef _CLUSITEM_H_
#include "ClusItem.h"	// for CClusterItem
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline Function Definitions
/////////////////////////////////////////////////////////////////////////////

inline CMenu * CTreeItem::PmenuPopup(void)
{
	ASSERT(Pci() != NULL);
	return Pci()->PmenuPopup();

}  //*** CTreeItem::PmenuPopup()

inline const CString & CTreeItem::StrName(void) const
{
	ASSERT(Pci() != NULL);
	return Pci()->StrName();

}  //*** CTreeItem::StrName()

/////////////////////////////////////////////////////////////////////////////

#endif // _TREEITEM_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\admin\cluadmin\treeitem.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		TreeItem.cpp
//
//	Abstract:
//		Implementation of the CTreeItem class.
//
//	Author:
//		David Potter (davidp)	May 3, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ConstDef.h"
#include "TreeItem.h"
#include "TreeItem.inl"
#include "TreeView.h"
#include "ListView.h"
#include "ClusDoc.h"
#include "SplitFrm.h"
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag g_tagTreeItemUpdate(_T("UI"), _T("TREE ITEM UPDATE"), 0);
CTraceTag g_tagTreeItemSelect(_T("UI"), _T("TREE ITEM SELECT"), 0);
CTraceTag g_tagTreeItemCreate(_T("Create"), _T("TREE ITEM CREATE"), 0);
CTraceTag g_tagTreeItemDelete(_T("Delete"), _T("TREE ITEM DELETE"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CTreeItemList
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItemList::PtiFromPci
//
//	Routine Description:
//		Find a tree item in the list by its cluster item.
//
//	Arguments:
//		pci			[IN] Cluster item to search for.
//		ppos		[OUT] Position of the item in the list.
//
//	Return Value:
//		pti			Tree item corresponding to the cluster item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem * CTreeItemList::PtiFromPci(
	IN const CClusterItem *	pci,
	OUT POSITION *			ppos	// = NULL
	) const
{
	POSITION	posPti;
	POSITION	posCurPti;
	CTreeItem *	pti	= NULL;

	posPti = GetHeadPosition();
	while (posPti != NULL)
	{
		posCurPti = posPti;
		pti = GetNext(posPti);
		ASSERT_VALID(pti);

		if (pti->Pci() == pci)
		{
			if (ppos != NULL)
				*ppos = posCurPti;
			break;
		}  // if:  found a match

		pti = NULL;
	}  // while:  more resources in the list

	return pti;

}  //*** CTreeItemList::PtiFromPci()


//***************************************************************************


/////////////////////////////////////////////////////////////////////////////
// CTreeItem
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CTreeItem, CBaseCmdTarget)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CTreeItem, CBaseCmdTarget)
	//{{AFX_MSG_MAP(CTreeItem)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::CTreeItem
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem::CTreeItem(void)
{
	m_ptiParent = NULL;
	m_pci = NULL;
	m_bWeOwnPci = FALSE;

}  //*** CTreeItem::CTreeItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::CTreeItem
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		ptiParent		[IN OUT] Parent item for this item.
//		pci				[IN OUT] Cluster item represented by this tree item.
//		bTakeOwnership	[IN] TRUE = delete pci when this object is destroyed.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem::CTreeItem(
	IN OUT CTreeItem *		ptiParent,
	IN OUT CClusterItem *	pci,
	IN BOOL					bTakeOwnership	// = FALSE
	)
{
	ASSERT_VALID(pci);

	m_ptiParent = ptiParent;
	m_pci = pci;
	m_bWeOwnPci = bTakeOwnership;

	m_pci->AddRef();

	// Set the column section name.  If there is a parent, append our name
	// onto the parent's section name.
	try
	{
		if (PtiParent() == NULL)
			m_strProfileSection.Format(
				REGPARAM_CONNECTIONS _T("\\%s\\%s"),
				Pci()->Pdoc()->StrNode(),
				Pci()->StrName()
				);
		else
			m_strProfileSection.Format(
				_T("%s\\%s"),
				PtiParent()->StrProfileSection(),
				Pci()->StrName()
				);
	}  // try
	catch (CException * pe)
	{
		// If an error occurs constructing the section name, just ignore it.
		pe->Delete();
	}  // catch:  CException

	Trace(g_tagTreeItemCreate, _T("CTreeItem() - Creating '%s', parent = '%s', owned = %d"), pci->StrName(), (ptiParent ? ptiParent->Pci()->StrName() : _T("<None>")), bTakeOwnership);

}  //*** CTreeItem::CTreeItem(pci)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::Init
//
//	Routine Description:
//		Initialize the tree item.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::Init(void)
{
}  //*** CTreeItem::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::~CTreeItem
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTreeItem::~CTreeItem(void)
{
#ifdef _DEBUG
	TCHAR	szName[1024];

	if (Pci() != NULL)
		_tcsncpy(szName, Pci()->StrName(), (sizeof(szName) / sizeof(TCHAR)) - 1);
	else
		_tcscpy(szName, _T("<Unknown>"));

	Trace(g_tagTreeItemDelete, _T("~CTreeItem() - Deleting tree item '%s'"), szName);
#endif

	// Cleanup this object.
	Cleanup();

	Trace(g_tagTreeItemDelete, _T("~CTreeItem() - Done deleting tree item '%s'"), szName);

}  //*** CTreeItem::~CTreeItem()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::Delete
//
//	Routine Description:
//		Delete the item.  If the item still has references, add it to the
//		document's pending delete list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::Delete(void)
{
	// Add a reference so that we don't delete ourselves while
	// still doing cleanup.
	AddRef();

	// Cleanup this object.
	Cleanup();

	// If there are still references to this object, add it to the delete
	// pending list.  Check for greater than 1 because we added a reference
	// at the beginning of this method.
//	if (NReferenceCount() > 1)
//	{
//		ASSERT(Pdoc()->LpciToBeDeleted().Find(this) == NULL);
//		Pdoc()->LpciToBeDeleted().AddTail(this);
//	}  // if:  object still has references to it

	// Release the reference we added at the beginning.  This will
	// cause the object to be deleted if we were the last reference.
	Release();

}  //*** CTreeItem::Delete()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::Cleanup
//
//	Routine Description:
//		Cleanup the item.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTreeItem::Cleanup(void)
{
	// Delete our children first.
	// NOTE:  List items MUST be deleted first since tree items delete
	// owned cluster items.
	DeleteAllItemData(m_lpliChildren);
	DeleteAllItemData(m_lptiChildren);
	m_lpliChildren.RemoveAll();
	m_lptiChildren.RemoveAll();

	// Remove ourself from all views.
	RemoveFromAllLists();

	// Delete all other lists.
	DeleteAllItemData(m_lpcoli);
	DeleteAllItemData(m_lptic);
	m_lpcoli.RemoveAll();
	m_lptic.RemoveAll();

	// If we own the cluster item, delete it.
	if (m_bWeOwnPci)
	{
#ifdef _DEBUG
		TCHAR	szName[1024];

		if (Pci() != NULL)
			_tcsncpy(szName, Pci()->StrName(), (sizeof(szName) / sizeof(TCHAR)) - 1);
		else
			_tcscpy(szName, _T("<Unknown>"));
		Trace(g_tagTreeItemDelete, _T("Cleanup --> Deleting cluster item '%s'"), szName);
#endif
		delete m_pci;
	}  // if:  we own the cluster item
	else if (m_pci != NULL)
		m_pci->Release();
	m_pci = NULL;

}  //*** CTreeItem::Cleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CTreeItem::StrProfileSection
//
//	Routine Description:
//		Return the profile section name for this item.
//
//	Arguments:
//		None.
//
//	Return Value:
//		CString		Reference to profile section string.
//
