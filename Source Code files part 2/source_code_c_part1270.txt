                // Yes, attach the value.
                    KnownControls[ControlType].pAttachFunction(hFrame,
                                                               ppCurrent,
                                                               pBytesLeft,
                                                               DataLength);

                } else {

                    // Nope, do nothing.
                    AttachPropertyInstance( hFrame,
                                            LDAPPropertyTable[LDAPP_CONTROL_VALUE].hProperty,
                                            DataLength,
                                            ((DataLength > 0)?*ppCurrent:*ppCurrent-1),
                                            0, 4, 0);
                    *ppCurrent += DataLength;
                    *pBytesLeft -= DataLength;

                }
            } // if DataLength > 0
        } // if Tag == LDAPP_BER_STRING ...
    } // if *pBytesLeft > 0 ...
}

#define LDAPP_CONTROL_VAL_LEVEL 4

void AttachLDAPControlValPaged( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{

    DWORD    DataLength;
    DWORD    HeaderLength;

    // skip the sequence header
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

    // look for an integer 'size'
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_PAGED_SIZE].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // look for the 'Cookie'
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

    if (DataLength) {    
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_PAGED_COOKIE].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, 0);
        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }
}


void AttachLDAPControlValVLVReq( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    DWORD    VLVLength;
    DWORD    TmpBytesLeft;
    BYTE     Tag;

    // skip the sequence header saving the length of the control value.
    *ppCurrent += TAG_LENGTH;
    VLVLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);
    TmpBytesLeft = *pBytesLeft;

    // get the before count
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_VLVREQ_BCOUNT].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // get the after count
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_VLVREQ_ACOUNT].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    Tag = GetTag(*ppCurrent) & TAG_MASK;
    *ppCurrent += TAG_LENGTH;
    *pBytesLeft -= TAG_LENGTH;

    if (LDAPP_VLV_REQ_BYOFFSET_TAG == Tag) {
        // get the length of the sequence and skip the following tag.
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength + TAG_LENGTH;
        *pBytesLeft -= HeaderLength + TAG_LENGTH;

        // get the offset
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= HeaderLength;

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_VLVREQ_OFFSET].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

        // skip to the contentCount
        *ppCurrent += DataLength + TAG_LENGTH;
        *pBytesLeft -= DataLength + TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= HeaderLength;

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_VLV_CONTENTCOUNT].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);        
    } else {
        // get the assertionValue
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= HeaderLength;
    
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_VLVREQ_GE].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);
    }

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // is there a contextID?
    if (VLVLength > (TmpBytesLeft - *pBytesLeft)) {
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_VLV_CONTEXT].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }

}


void AttachLDAPControlValVLVResp( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    DWORD    VLVLength;
    DWORD    TmpBytesLeft;
    BYTE     Tag;

    // skip the sequence header saving the length of the control value.
    *ppCurrent += TAG_LENGTH;
    VLVLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 
    TmpBytesLeft = *pBytesLeft;

    // get the targetPosition
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_VLVRESP_TARGETPOS].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // get the contentCount
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_VLV_CONTENTCOUNT].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

    *ppCurrent += DataLength + TAG_LENGTH;
    *pBytesLeft -= DataLength + TAG_LENGTH;

    // get the result code
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= HeaderLength;
    
    AttachPropertyInstance( hFrame,
                        LDAPPropertyTable[LDAPP_CONTROL_VLVRESP_RESCODE].hProperty,
                        DataLength,
                        *ppCurrent,
                        0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // is there a contextID?
    if (VLVLength > (TmpBytesLeft - *pBytesLeft)) {
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_VLV_CONTEXT].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }

}

void AttachLDAPControlValSortReq( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    DWORD    SortLengthOuter;
    DWORD    TmpBytesLeftOuter;
    DWORD    SortLengthInner;
    DWORD    TmpBytesLeftInner;
    BYTE     DefaultReverseFlag = 0;
    PBYTE    pReverseFlag = NULL;
    BYTE     Tag;
    
    // skip the sequence header saving the length of the control value.
    *ppCurrent += TAG_LENGTH;
    SortLengthOuter = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 
    TmpBytesLeftOuter = *pBytesLeft;

    while (SortLengthOuter > (TmpBytesLeftOuter - *pBytesLeft)) {


        // skip the sequence header saving the length of the inner sequence.
        *ppCurrent += TAG_LENGTH;
        SortLengthInner = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH); 
        TmpBytesLeftInner = *pBytesLeft;

        // get the attributeType
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_SORTREQ_ATTRTYPE].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, 0);

        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;

        if (SortLengthInner > (TmpBytesLeftInner - *pBytesLeft)) {
            Tag = GetTag(*ppCurrent);
            *ppCurrent += TAG_LENGTH;
            DataLength = GetLength(*ppCurrent, &HeaderLength);
            *ppCurrent += HeaderLength;
            *pBytesLeft -= (HeaderLength + TAG_LENGTH);
        }
        else {
            Tag = LDAPP_SORT_REQ_REVERSEORDER_TAG;
            DataLength = 0;
        }

        // If there is an orderingRul get that.
        if (LDAPP_SORT_REQ_ORDERINGRULE_TAG == (Tag & TAG_MASK)) {
            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LDAPP_CONTROL_SORTREQ_MATCHINGRULE].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    0, LDAPP_CONTROL_VAL_LEVEL, 0);
            *ppCurrent += DataLength;
            *pBytesLeft -= DataLength;

            if (SortLengthInner > (TmpBytesLeftInner - *pBytesLeft)) {
                Tag = GetTag(*ppCurrent);
                *ppCurrent += TAG_LENGTH;
                DataLength = GetLength(*ppCurrent, &HeaderLength);
                *ppCurrent += HeaderLength;
                *pBytesLeft -= (HeaderLength + TAG_LENGTH);
            }
            else {
                Tag = LDAPP_SORT_REQ_REVERSEORDER_TAG;
                DataLength = 0;
            }
        }

        // if the reverse flag wasn't specified set up the default.
        if (0 == DataLength) {
            pReverseFlag = &DefaultReverseFlag;
        }
        else {
            pReverseFlag = *ppCurrent;
        }

        AttachPropertyInstanceEx( hFrame,
                                  LDAPPropertyTable[LDAPP_CONTROL_SORTREQ_REVERSE].hProperty,
                                  DataLength,
                                  *ppCurrent,
                                  sizeof(BYTE),
                                  pReverseFlag,
                                  0, LDAPP_CONTROL_VAL_LEVEL, 0);

        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }
}

void AttachLDAPControlValSortResp( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    DWORD    SortLength;
    DWORD    TmpBytesLeft;
    BYTE     DefaultReverseFlag = 0;
    PBYTE    pReverseFlag = NULL;
    BYTE     Tag;
    
    // skip the sequence header saving the length of the control value.
    *ppCurrent += TAG_LENGTH;
    SortLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 
    TmpBytesLeft = *pBytesLeft;

    // get the result code
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_SORTRESP_RESCODE].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // if there is an attribute type, get it
    if (SortLength > (TmpBytesLeft - *pBytesLeft)) {
        Tag = GetTag(*ppCurrent);
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= (HeaderLength + TAG_LENGTH);

        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_SORTRESP_ATTRTYPE].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, 0);
        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }
}

void AttachLDAPControlValSD( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    DWORD    SDVal;
    DWORD    MaskedSDVal;
    DWORD    i;
    
    // skip the sequence header
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

    // Get the flags.
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

    SDVal = (DWORD) GetInt(*ppCurrent, DataLength);

    for(i=0; i < LDAPSDControlValsSET.nEntries; i++) {
        MaskedSDVal = SDVal & ((LPLABELED_DWORD)LDAPSDControlValsSET.lpDwordTable)[i].Value;
        if (MaskedSDVal) {
            AttachPropertyInstanceEx( hFrame,
                                      LDAPPropertyTable[LDAPP_CONTROL_SD_VAL].hProperty,
                                      DataLength,
                                      *ppCurrent,
                                      sizeof(DWORD),
                                      &MaskedSDVal,
                                      0, LDAPP_CONTROL_VAL_LEVEL, 0);
        }
    }

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;
}


void AttachLDAPControlValASQ( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    DWORD    i;
    BYTE     Tag;
    DWORD    LabelId = 0;
    
    // skip the sequence header
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

    Tag = GetTag(*ppCurrent);
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    if (BER_TAG_ENUMERATED == Tag) {
        LabelId = LDAPP_CONTROL_ASQ_RESCODE;
    } else if (BER_TAG_OCTETSTRING == Tag) {
        LabelId = LDAPP_CONTROL_ASQ_SRCATTR;
    }
    if (LabelId != 0) {    
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LabelId].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);
    }
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;
}

void AttachLDAPControlValDirSync( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    DWORD    Flags;
    DWORD    MaskedFlags;
    DWORD    i;
    
    // skip the sequence header
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

    // get the flags
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    Flags = (DWORD) GetInt(*ppCurrent, DataLength);

    //
    // iterate through each possible flag attaching a label if it exists.
    //
    for (i=0; i < LDAPDirSyncFlagsSET.nEntries; i++) {
        MaskedFlags = Flags & ((LPLABELED_DWORD)LDAPDirSyncFlagsSET.lpDwordTable)[i].Value;
        if (MaskedFlags) {
            AttachPropertyInstanceEx( hFrame,
                                    LDAPPropertyTable[LDAPP_CONTROL_DIRSYNC_FLAGS].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    sizeof(DWORD),
                                    &MaskedFlags,
                                    0, LDAPP_CONTROL_VAL_LEVEL, 0);
        }
    }

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;
    
    // Get the size
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_DIRSYNC_SIZE].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);
    
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // Get the cookie if there is one.
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    if (DataLength > 0) {
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_DIRSYNC_COOKIE].hProperty,
                                DataLength,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, 0);

        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }
}

void AttachLDAPControlValCrossDomMove( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    
    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_CROSSDOM_NAME].hProperty,
                            cbCtrlValue,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, 0);

    *ppCurrent += cbCtrlValue;
    *pBytesLeft -= cbCtrlValue;

}

void AttachLDAPControlValStats( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    DWORD    StatsLength;
    DWORD    TmpBytesLeft;
    DWORD    LabelId;
    DWORD    StatType;
    
    if (sizeof(DWORD) == cbCtrlValue) {
        // This is the stats request request (as opposed to the response) 
        // and some flags were passed.        
        AttachPropertyInstance( hFrame,
                                LDAPPropertyTable[LDAPP_CONTROL_STAT_FLAG].hProperty,
                                cbCtrlValue,
                                *ppCurrent,
                                0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);
        *ppCurrent += cbCtrlValue;
        *pBytesLeft -= cbCtrlValue;
        return;
    }

    //
    // this must be a stats response.
    //
    
    // skip the sequence header saving the length of the sequence.
    *ppCurrent += TAG_LENGTH;
    StatsLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 
    TmpBytesLeft = *pBytesLeft;

    while (StatsLength > (TmpBytesLeft - *pBytesLeft)) {
        //
        // get this stat's header
        //
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;

        StatType = GetInt(*ppCurrent, DataLength);

        *ppCurrent += DataLength;
        *pBytesLeft -= HeaderLength + DataLength + TAG_LENGTH;

        // now position on the stat itself
        *ppCurrent += TAG_LENGTH;
        DataLength = GetLength(*ppCurrent, &HeaderLength);
        *ppCurrent += HeaderLength;
        *pBytesLeft -= HeaderLength + TAG_LENGTH;

        // find the label to use and attach it.
        switch (StatType) {
        case STAT_THREADCOUNT:
            LabelId = LDAPP_CONTROL_STAT_THREADCOUNT;
            break;
        case STAT_CORETIME:
            LabelId = LDAPP_CONTROL_STAT_CORETIME;
            break;
        case STAT_CALLTIME:
            LabelId = LDAPP_CONTROL_STAT_CALLTIME;
            break;
        case STAT_SUBSRCHOP:
            LabelId = LDAPP_CONTROL_STAT_SUBSEARCHOPS;
            break;
        case STAT_ENTRIES_RETURNED:
            LabelId = LDAPP_CONTROL_STAT_ENTRIES_RETURNED;
            break;
        case STAT_ENTRIES_VISITED:
            LabelId = LDAPP_CONTROL_STAT_ENTRIES_VISITED;
            break;
        case STAT_FILTER:
            LabelId = LDAPP_CONTROL_STAT_FILTER;
            break;
        case STAT_INDEXES:
            LabelId = LDAPP_CONTROL_STAT_INDEXES;
            break;
        default:
            LabelId = -1;
        }

        if (-1 != LabelId) {
            AttachPropertyInstance( hFrame,
                                    LDAPPropertyTable[LabelId].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);
        }

        *ppCurrent += DataLength;
        *pBytesLeft -= DataLength;
    }
}

void AttachLDAPControlValGCVerify( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    
    // skip the sequence header
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

    // get the flags
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_GCVERIFYNAME_FLAGS].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, IFLAG_SWAPPED);

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;

    // get the server name
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    AttachPropertyInstance( hFrame,
                            LDAPPropertyTable[LDAPP_CONTROL_GCVERIFYNAME_NAME].hProperty,
                            DataLength,
                            *ppCurrent,
                            0, LDAPP_CONTROL_VAL_LEVEL, 0);

    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;
}

void AttachLDAPControlValSearchOpts( HFRAME hFrame, ULPBYTE * ppCurrent, LPDWORD pBytesLeft, DWORD cbCtrlValue)
{
    DWORD    DataLength;
    DWORD    HeaderLength;
    DWORD    SearchOpts;
    DWORD    MaskedSearchOpts;
    DWORD    i;
    
    // skip the sequence header
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH); 

    // get the flags
    *ppCurrent += TAG_LENGTH;
    DataLength = GetLength(*ppCurrent, &HeaderLength);
    *ppCurrent += HeaderLength;
    *pBytesLeft -= (HeaderLength + TAG_LENGTH);

    SearchOpts = GetInt(*ppCurrent, DataLength);

    //
    // Iterate through the possible search options labeling as appropriate.
    //
    for (i=0; i < LDAPSearchOptsSET.nEntries; i++) {
        MaskedSearchOpts = ((LPLABELED_DWORD)LDAPSearchOptsSET.lpDwordTable)[i].Value;
        if (MaskedSearchOpts) {
            AttachPropertyInstanceEx( hFrame,
                                    LDAPPropertyTable[LDAPP_CONTROL_SEARCHOPTS_OPTION].hProperty,
                                    DataLength,
                                    *ppCurrent,
                                    sizeof(DWORD),
                                    &MaskedSearchOpts,
                                    0, LDAPP_CONTROL_VAL_LEVEL, 0);
        }
    }
    
    *ppCurrent += DataLength;
    *pBytesLeft -= DataLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\netmon_parser\ldap_tags.c ===
#include "ldap.h"

// Length field identifiers
#define BER_LEN_IND_MASK        0x80
#define GetBerLenInd(x)         (x & BER_LEN_IND_MASK)
#define BER_LEN_IMMEDIATE       0x00
#define BER_LEN_INDEFINITE      0x80

#define BER_LEN_MASK            (BYTE)(~BER_LEN_IND_MASK)
#define GetBerLen(x)            (BYTE)(x & BER_LEN_MASK)

BYTE GetTag(ULPBYTE pCurrent)
{

    return pCurrent[0];

}

DWORD GetLength(ULPBYTE pInitialPointer, DWORD *LenLen)
{

  // we assume that the current pointer points at the length bytes
  // the first byte will either be the length or else it will be the
  // indicator for subsequent lengths.

    DWORD theLength = 0;
    DWORD tempLength = 0;
    BYTE  tLen;
    BYTE  i;

    *LenLen = 0;

    if(*pInitialPointer & BER_LEN_IND_MASK)
    {
        // this is going to contain many octets of length data
        tLen = GetBerLen(*pInitialPointer);
        if(tLen > sizeof(DWORD)) return (DWORD)0;
        
        // do some shifting. There are more efficient ways to do this
        for(i = 1; i<tLen; i++)
        {
            tempLength = pInitialPointer[i];
            theLength |= tempLength;
            theLength =  theLength << 8;
        }
        tempLength = pInitialPointer[tLen];
        theLength |= tempLength;


        *LenLen = tLen + 1;
        return theLength;
    }
    else
    {
        // the length is encoded directly
        *LenLen = 1;
        i = GetBerLen(*pInitialPointer);
        return (DWORD)i;
    }
}

LONG GetInt(ULPBYTE pCurrent, DWORD Length)
{
    ULONG   ulVal=0, ulTmp=0;
    ULONG   cbDiff;
    BOOL    fSign = FALSE;
    DWORD   dwRetVal;

    // We assume the tag & length have already been taken off and we're
    // at the value part.

    if (Length > sizeof(LONG)) {

        dwRetVal = 0x7FFFFFFF;
        return dwRetVal;
    }

    cbDiff = sizeof(LONG) - Length;

    // See if we need to sign extend;

    if ((cbDiff > 0) && (*pCurrent & 0x80)) {

        fSign = TRUE;
    }

    while (Length > 0)
    {
        ulVal <<= 8;
        ulVal |= (ULONG)*pCurrent++;
        Length--;
    }

    // Sign extend if necessary.
    if (fSign) {

        dwRetVal = 0x80000000;
        dwRetVal >>= cbDiff * 8;
        dwRetVal |= ulVal;

    } else {

        dwRetVal = (LONG) ulVal;
    }

    return dwRetVal;
}

BOOL AreOidsEqual(IN LDAPOID *String1, IN LDAPOID *String2)
{
    INT len;

    if ( String1->length == String2->length ) {
        for ( len = String1->length-1; len >= 0; len-- ) {
            if ( String1->value[len] != String2->value[len] ) {
                return FALSE;
            }
        }
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\boot\inicache.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       inicache.cxx
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Based on the observation that mkdit.exe spends most of its time
    calling GetPrivateProfileSection (much less on the same sections
    over and over and over again), this file implements a simple
    .ini file section cache.  Performance could be better improved
    by other means, but considering that mkdit is run rarely, this
    is probably a good enough solution.

Author:

    Dave Straube (DaveStr) 26-Dec-1996

Revision History:

--*/

#include <ntdspchX.h>
#include "SchGen.HXX"

typedef struct IniCacheItem
{
    CHAR    *sectionName;
    CHAR    *buffer;
    DWORD   cchBuffer;
} IniCacheItem;

#define         IniCacheIncrement 1000

IniCacheItem    *IniCache = NULL;       // cache is an array of IniCacheItem
DWORD           cIniCache = 0;          // # of items in cache
DWORD           cIniCacheMax = 0;       // # of items which can fit in cache

void
CleanupIniCache(void)
{
    ULONG i;

    if ( IniCache ) {
        for (i = 0; i < cIniCache; i++) {
            XFree(IniCache[i].sectionName);
            XFree(IniCache[i].buffer);
        }
        XFree(IniCache);
        IniCache = NULL;
        cIniCache = 0;
        cIniCacheMax = 0;
    }
}


int _cdecl CompareIniCacheItem(
    const void *pv1,
    const void *pv2)
{
   return(_stricmp(
               ((IniCacheItem *) pv1)->sectionName,
               ((IniCacheItem *) pv2)->sectionName));
}

void SortIniCache(void)
{
    if ( cIniCache < 2 )
        return;

    qsort(
        (void *) IniCache,
        (size_t) cIniCache,
        (size_t) sizeof(IniCacheItem),
        CompareIniCacheItem);
}

IniCacheItem * FindIniCacheItem(
    CHAR    *sectionName
    )
{
    IniCacheItem    *pItem = NULL;
    IniCacheItem    searchItem = { sectionName, NULL, 0 };

    if ( 0 == cIniCache )
        return(NULL);

    pItem = (IniCacheItem *) bsearch(
                    (void *) &searchItem,
                    (void *) IniCache,
                    (size_t) cIniCache,
                    (size_t) sizeof(IniCacheItem),
                    CompareIniCacheItem);

    return(pItem);
}

DWORD GetPrivateProfileSectionEx(
    CHAR    *sectionName,   // IN
    CHAR    **ppBuffer,     // OUT
    CHAR    *iniFile)       // IN

/*++

Routine Description:

    Cached version of GetPrivateProfileSection().  Doesn't clean up
    allocations on error under the assumption that upper levels are
    going to bail anyway and we're not worried about memory leaks on
    exit in mkhdr/mkdit.

Parameters:

    sectionName - Name of the desired .ini file section.

    ppBuffer - Address of return buffer pointer.  Filled in by this routine
        on success and allocated with XCalloc().

    iniFile - Name of .ini file.

Return Values:

    Buffer size on success.  0 on failure.

--*/

{
    IniCacheItem    *pItem;
    IniCacheItem    *tmpCache;
    DWORD           cch;
    DWORD           sectionSize;
    BOOL            fDone;

    // The sectionSize returned by GetPrivateProfileSection() doesn't 
    // include the final terminating NULL character.  Upper layer code
    // assumes the terminating character is there - so we need to 
    // allocate and copy it as required. IniCacheItem.cchBuffer 
    // represents the "real" buffer size.  

    if ( NULL != (pItem = FindIniCacheItem(sectionName)) )
    {
        // Cache hit - just realloc the section buffer.
        // printf("Cache hit(%s[%d])\n", pItem->sectionName, pItem->cchBuffer);

        *ppBuffer = (CHAR *) XCalloc(1, pItem->cchBuffer);

        if ( NULL == *ppBuffer )
        {
            return(0);
        }
        else
        {
            memcpy(*ppBuffer, pItem->buffer, pItem->cchBuffer);

            // Return sectionSize which is 1 less than buffer size.
            return(pItem->cchBuffer - 1);
        }
    }

    // Item isn't in the cache yet.  Go get it for real.
    // Empirical testing shows that the majority of schema.ini entries
    // require 1024 bytes, so we start there.

#define BufferIncrement 1024

    cch = BufferIncrement;

    do
    {
        *ppBuffer = (CHAR *) XCalloc(1, cch);

        if ( NULL == *ppBuffer )
            return(0);

        /*
        if ( BufferIncrement != cch )
            printf("GetPrivateProfileSection(%s[%d])\n", sectionName, cch);
        */

        sectionSize = GetPrivateProfileSection(
                                    sectionName,
                                    *ppBuffer,
                                    cch,
                                    iniFile);

        if ( sectionSize == (cch-2) )
        {
            // Buffer was too small - grow it and try again.

            XFree(*ppBuffer);
            cch += BufferIncrement;
        }
        else if ( 0 == sectionSize )
        {
            // Section doesn't exist.

            return(0);
        }
        else
        {
            // Section found - break out of loop.

            break;
        }
    } while ( TRUE );

    // Section found - add item to cache and return copy to caller.
    // Caller's copy is already in *ppBuffer and length is in sectionSize.

    if ( 0 == cIniCacheMax )
    {
        // Perform initial cache allocation.

        IniCache = (IniCacheItem *)
            XCalloc(1, IniCacheIncrement * sizeof(IniCacheItem));

        if ( NULL == IniCache )
            return(0);

        cIniCacheMax += IniCacheIncrement;
    }
    else if ( cIniCache == cIniCacheMax )
    {
        // Cache is full - grow it.

        tmpCache = (IniCacheItem *)
            XCalloc(1, (cIniCache + IniCacheIncrement) * sizeof(IniCacheItem));

        if ( NULL == tmpCache )
            return(0);

        cIniCacheMax += IniCacheIncrement;

        // Swap old and new.

        memcpy(tmpCache, IniCache, cIniCache * sizeof(IniCacheItem));
        XFree(IniCache);
        IniCache = tmpCache;
    }

    // There's room in the cache - insert new entry.

    IniCache[cIniCache].sectionName =
        (CHAR *) XCalloc(1, sizeof(CHAR) * (1 + strlen(sectionName)));

    if ( NULL == IniCache[cIniCache].sectionName )
        return(0);

    strcpy(IniCache[cIniCache].sectionName, sectionName);

    IniCache[cIniCache].buffer = (CHAR *) XCalloc(1, sectionSize + 1);

    if ( NULL == IniCache[cIniCache].buffer )
        return(0);

    memcpy(IniCache[cIniCache].buffer, *ppBuffer, sectionSize + 1);
    IniCache[cIniCache].cchBuffer = sectionSize + 1;

    cIniCache++;

    SortIniCache();

    return(sectionSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\netmon_parser\ldapinit.c ===
//=================================================================================================================//
//  MODULE: LDAPinit.c
//
//  Description:
//
//  Attach properties for the BLOODHOUND LDAP Parser.
//
//  Modification History
//
//  Arthur Brooking     05/08/96        Created from PPP Parser
//=================================================================================================================//
#include "ldap.h"

extern ENTRYPOINTS LDAPEntryPoints;
extern HPROTOCOL hLDAP;

char    IniFile[INI_PATH_LENGTH];

//==========================================================================================================================
//  FUNCTION: DllMain()
//
//  Modification History
//
//  Arthur Brooking     05/08/96        Created from PPP Parser
//==========================================================================================================================
DWORD Attached = 0;


BOOL WINAPI DllMain(HANDLE hInst, ULONG ulCommand, LPVOID lpReserved)
{

    if (ulCommand == DLL_PROCESS_ATTACH)
    {
        if (Attached++ == 0)
        {
            hLDAP    = CreateProtocol("LDAP",     &LDAPEntryPoints, ENTRYPOINTS_SIZE);
            
            if (BuildINIPath(IniFile, "LDAP.DLL") == NULL)
            {

#ifdef DEBUG
                BreakPoint();
#endif
                return FALSE;
            }


        }                  
    }
    else if (ulCommand == DLL_PROCESS_DETACH)
    {
        if (--Attached == 0)
        {
            DestroyProtocol(hLDAP);
        }
    }
            
    return TRUE;

    //... Make the compiler happy.

    UNREFERENCED_PARAMETER(hInst);
    UNREFERENCED_PARAMETER(lpReserved);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\boot\addobj.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1989 - 1999
//
//  File:       AddObj.cxx
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Adds the First set of objects to the DS
    Run during Install.

Author:

    Rajivendra Nath (RajNath) 07-07-96

Revision History:

--*/

#include <ntdspchX.h>

#include <schedule.h>       // new replication schedule format definitions

#include <sddlp.h>      //

#include "SchGen.hxx"

#define DEBSUB "ADDOBJ:"
extern "C"
{
    #include <permit.h>
    #include <ntdsa.h>
    #include <fileno.h>
    #include <drsuapi.h>
    #include <drserr.h>
    #include <mdlocal.h>
    #include <drancrep.h>      // For the draDecodeDraError... routine.
    #define  FILENO FILENO_ADDOBJ

    extern DWORD  dbCreateRoot();
    extern DWORD DBMoveObjectDeletionTimeToInfinite(DSNAME * pdsa);

    extern unsigned StringToOID ( char* Stroid, OID_t *Obj );
}

extern BOOL gInstallHasDoneSchemaMove;


NTSTATUS
AddOneObjectEx(
    IN NODE* NewNode,
    IN WCHAR* DN,
    IN UUID * pObjectGuid,
    IN WCHAR* P2,
    IN BOOL fVerbose = TRUE
    );

GUID
GenGuid();


VOID
FreeAttrBlk(
        ATTR* Attr,
        ULONG Count
        );

VOID
StrToAttrib (
        char*  strval,
        WCHAR *wstrval,
        ATTCACHE *pAC,
        UCHAR** ptr,
        DWORD&    siz);

DWORD
StrToOctet(char * String);

char*
PreProcessInifileShortcuts (
        char* strval,
        ATTCACHE* pAC,
        OUT  WCHAR **Widepp
        );

DWORD
AppendRDNStr(
    IN WCHAR *BaseName,
    IN unsigned ccBaseName,
    IN OUT WCHAR *NewName,
    IN unsigned ccNewName,
    IN WCHAR *Rdn,
    IN unsigned ccRdn,
    IN ATTRTYP AttrType
    );

BOOL
GetDefaultReplScheduleString (
        char *bData,
        ULONG cb
        );


BOOL fGenGuid=FALSE;
GUID gNext=dsInitialObjectGuid;

// Define the default replication schedule header
SCHEDULE g_sched = {
    sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES,   // Size field
    0,                                          // Bandwidth
    1,                                          // NumberOfSchedules
    {
        SCHEDULE_INTERVAL,                      // Type
        sizeof(SCHEDULE),                       // Offset
    },
};

// Define the default intra-site replication interval in new format - once every
// hour.  Each byte in the data represents an hour of a week, lower 4 bits
// represent if replication takes place in each quarter of the hour, and the
// upper 4 bits are reserved for future use (7 * 24 = 168 entries).
//
// Note:- If you change this, please make sure that gpDefaultIntrasiteSchedule
//        definition in ds\src\kcc\kccmain.cxx is changed appropriately.
BYTE g_defaultSchedDBData[SCHEDULE_DATA_ENTRIES] =
{
    // 12 columns & 14 rows = 168
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,

    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,

    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,

    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
};

//
// This heap is meant for the InstallBaseNTDS routines to allocate
// from; at the end of InstallBaseNTDS the heap is destroyed.
// Note that the heap handle is set to NULL in DestroyInstallHeap so that
// it can be created again.
HANDLE ghInstallHeap = NULL;
SIZE_T gulInstallHeapSize = 0;

void
CreateInstallHeap(void)
{
    ghInstallHeap = RtlCreateHeap((HEAP_NO_SERIALIZE
                                   | HEAP_GROWABLE
                                   | HEAP_ZERO_MEMORY
                                   | HEAP_CLASS_1),
                                  0,
                                  32*1024*1024, // reserve 32M of VA
                                  409600, // initial size of 400K
                                  0,
                                  0);
    if (!ghInstallHeap) {
        XOUTOFMEMORY();
    }

}

void
DestroyInstallHeap(void)
{
    if (ghInstallHeap) {
        RtlDestroyHeap(ghInstallHeap);
        ghInstallHeap = NULL;

        DPRINT1(0, "Destroying Install Heap, size = 0x%x\n",
                gulInstallHeapSize);

        gulInstallHeapSize = 0;
    }
}

void
XFree(void *p)
{
#if DBG
    gulInstallHeapSize -= RtlSizeHeap(ghInstallHeap, 0, p);
#endif
    RtlFreeHeap(ghInstallHeap, 0, p);
}

PVOID
XCalloc(DWORD Num,DWORD Size)
{
    PVOID ret;

    if (!ghInstallHeap) {
        CreateInstallHeap();
    }

    ret=RtlAllocateHeap(ghInstallHeap, HEAP_ZERO_MEMORY, Num*Size);
    if (ret==NULL)
    {
        XOUTOFMEMORY();
    }

#if DBG
    gulInstallHeapSize += Size;
#endif

    return ret;
}

PVOID
XRealloc(PVOID IBuff,DWORD Size)
{
    PVOID ret;

#if DBG
    gulInstallHeapSize -= RtlSizeHeap(ghInstallHeap, 0, IBuff);
    gulInstallHeapSize += Size;
#endif

    ret=RtlReAllocateHeap(ghInstallHeap, 0, IBuff, Size);
    if (ret==NULL)
    {
        XOUTOFMEMORY();
    }
    return ret;
}

char*
XStrdup(char* str)
{
    ULONG len;
    char* s;


    if (!ghInstallHeap) {
        CreateInstallHeap();
    }

    len = strlen(str) + 1;
    s = (char*)RtlAllocateHeap(ghInstallHeap, 0, len*sizeof(char));
    if (s==NULL)
    {
        XOUTOFMEMORY();
    }
    memcpy(s, str, len);

#if DBG
    gulInstallHeapSize += len;
#endif

    return s;
}


WCHAR gDsaNode[MAX_PATH];
char gDsaname[64];
int  gfDsaNode=0;


WCHAR ggSchemaname[MAX_PATH];
char gSchemaname[64];
int  gfgSchemaname=0;


WCHAR *gNcCurrentlyCreating = NULL;
ULONG  gNcObjectsRemaining = 0;

VOID
UpdateCreateNCInstallMessage(
    IN WCHAR *NewNcToCreate,  OPTIONAL
    IN ULONG NcIndex
    )
//
// This function is one large hack o' rama and it works.
//
{

    ULONG DefaultNcCount[3] = {
                               1586,  // Schema
                               140,   // Config
                               13    // Domain
                               };
    if ( NewNcToCreate )
    {
        Assert( NcIndex < 3 );
        gNcObjectsRemaining = DefaultNcCount[NcIndex];
        gNcCurrentlyCreating = NewNcToCreate;
    }

    if ( gNcCurrentlyCreating )
    {
        WCHAR ObjectsRemainingString[32];

        if ( gNcObjectsRemaining > 0 )
        {
            gNcObjectsRemaining--;
        }

        _itow( gNcObjectsRemaining, ObjectsRemainingString, 10 );

        SetInstallStatusMessage( DIRMSG_INSTALL_CREATE_PROGRESS,
                                 gNcCurrentlyCreating,
                                 ObjectsRemainingString,
                                 NULL,
                                 NULL,
                                 NULL
                                 );

    }

}

//-----------------------------------------------------------------------
//
// Function Name:   WalkTree
//
// Routine Description:
//
//    Recursively creates the DIT
//
// Author: RajNath
//
// Arguments:
//
//    NODE* pNode,         Start Node
//    char* ParentPath,    DN of the parent
//    char* Parent2,       Optional - if a copy is to be created then it goes here
//
// Return Value:
//
//    int        Zero On Succeess
//
//-----------------------------------------------------------------------
NTSTATUS
WalkTree(
    IN NODE* pNode,
    IN WCHAR* Parentpath,
    IN WCHAR* Parent2,
    IN BOOL fVerbose)
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    static Depth=1;
    WCHAR *cpath;
    WCHAR *cpath2;
    YAHANDLE     handle;
    NODE*        child;
    CLASSCACHE  *pCC;
    ULONG        ret;
    PWCHAR       pwbData;
    PWCHAR       pwbConfigAllocData = NULL;
    DWORD        cwbData;
    unsigned ccwstrval, ccParentpath, cccpath;

    child = pNode->GetNextChild(handle);
    while (child!=NULL)
    {
        WCHAR*        p2;
        WCHAR        *wstrval = NULL;
        p2=NULL;


        Assert(NULL == pwbConfigAllocData);
        cpath = NULL;
        cpath2 = NULL;

        pCC = child->GetClass();

        //
        // Lets see if we need to read registry or env to get the Name
        //
        char* strval = child->GetRDNOfObject();

        if ( !strval ) {
           // no object-name specified in the section. Use the
           // section name itself as the RDN of the object. This
           // is ok as long as section names are unique
           strval = child->NodeName();
        }
        else {
           DPRINT1(1,"Picked up non-section-name RDN %s\n", strval);
        }

        if (strncmp(REGENTRY,strval,sizeof(REGENTRY)-1)==0)
        {
            LONG   err;
            DWORD  dwType = REG_SZ;
            PWCHAR RegistryName;

            if (0 == (cwbData =  MultiByteToWideChar(
                               CP_ACP,
                               MB_PRECOMPOSED,
                               &strval[sizeof(REGENTRY)-1],
                               -1,
                               NULL,
                               0)))

            {
                DPRINT2(0, "WalkTree: MultiByteToWideChar failed with %d, line %d\n", GetLastError(), __LINE__);
                return STATUS_UNSUCCESSFUL;
            }

            RegistryName = (PWCHAR) XCalloc(cwbData, sizeof(WCHAR));

            if ( (0 == MultiByteToWideChar(
                               CP_ACP,
                               MB_PRECOMPOSED,
                               &strval[sizeof(REGENTRY)-1],
                               -1,
                               RegistryName,
                               cwbData)))

            {
                DPRINT2(0, "WalkTree: MultiByteToWideChar failed with %d, line %d\n", GetLastError(), __LINE__);
                XFree(RegistryName); RegistryName = NULL;
                return STATUS_UNSUCCESSFUL;
            }

            err =  GetConfigParamAllocW(RegistryName,
                                        (PVOID*)&pwbConfigAllocData,
                                        &cwbData);

            XFree(RegistryName); RegistryName = NULL;

            if (err!=0)
            {
                DPRINT2(0, "Could Not Read Registry %s REG_SZ. Error %d\n",
                        &strval[sizeof(REGENTRY)-1],GetLastError());
                return STATUS_OBJECT_NAME_NOT_FOUND;
            }

            wstrval = (WCHAR*) pwbConfigAllocData;

        }
        else if (strncmp(ENVENTRY,strval,sizeof(ENVENTRY)-1)==0)
        {
            LONG   err;
            PWCHAR EnvVarName;

            if ( 0 == ( cwbData =  MultiByteToWideChar(
                               CP_ACP,
                               MB_PRECOMPOSED,
                               &strval[sizeof(ENVENTRY)-1],
                               -1,
                               NULL,
                               0)))

            {
                DPRINT2(0, "WalkTree: MultiByteToWideChar failed with %d, line %d\n", GetLastError(), __LINE__);
                return STATUS_UNSUCCESSFUL;
            }

            EnvVarName = (PWCHAR) XCalloc( cwbData, sizeof(WCHAR) );

            if ( (0 == MultiByteToWideChar(
                   CP_ACP,
                   MB_PRECOMPOSED,
                   &strval[sizeof(ENVENTRY)-1],
                   -1,
                   EnvVarName,
                   cwbData)))

            {
                DPRINT2(0, "WalkTree: MultiByteToWideChar failed with %d, line %d\n", GetLastError(), __LINE__);
                XFree(EnvVarName); EnvVarName = NULL;
                return STATUS_UNSUCCESSFUL;
            }

            cwbData = GetEnvironmentVariableW(EnvVarName,
                                         NULL,
                                         0);

            if (cwbData == 0 )
            {
                DPRINT1(0, "Could Not Read Environment Var %s \n",
                        &strval[sizeof(ENVENTRY)-1]);
                return STATUS_OBJECT_NAME_NOT_FOUND;
            }

            pwbData = (PWCHAR) XCalloc( cwbData, sizeof(WCHAR) );
            cwbData = GetEnvironmentVariableW(EnvVarName,
                                         pwbData,
                                         cwbData);

            XFree(EnvVarName); EnvVarName = NULL;

            if (cwbData == 0) {
                XFree(pwbData);
                DPRINT1(0, "Could Not Read Environment Var %s \n",
                        &strval[sizeof(ENVENTRY)-1]);
                return STATUS_OBJECT_NAME_NOT_FOUND;
            }
            
            wstrval = (PWCHAR) pwbData;
        }

        if ( !wstrval )
        {

            ccwstrval = MultiByteToWideChar(CP_ACP,
                                            MB_PRECOMPOSED,
                                            strval,
                                            -1,
                                            NULL,
                                            0);

            if (0 == ccwstrval) {
                DPRINT2(0, "WalkTree: MultiByteToWideChar failed with %d, line %d\n", GetLastError(), __LINE__);
                return STATUS_UNSUCCESSFUL;
            }

            wstrval = (PWCHAR) XCalloc(ccwstrval, sizeof(WCHAR));
            ccwstrval = MultiByteToWideChar(CP_ACP,
                                            MB_PRECOMPOSED,
                                            strval,
                                            -1,
                                            wstrval,
                                            ccwstrval);

            if (0 == ccwstrval) {
                DPRINT2(0, "WalkTree: MultiByteToWideChar failed with %d, line %d\n", GetLastError(), __LINE__);
                XFree(wstrval); wstrval = NULL;
                return STATUS_UNSUCCESSFUL;
            }
        }
        else {
            ccwstrval = wcslen(wstrval);
        }

        ccParentpath = wcslen(Parentpath);
        cccpath = ccParentpath + ccwstrval + 20;
        cpath = (WCHAR*)XCalloc(cccpath, sizeof(WCHAR));

        AppendRDNStr(Parentpath,
                     ccParentpath,
                     cpath,
                     cccpath,
                     wstrval,
                     ccwstrval,
                     pCC->RdnIntId);

        if (Parent2) {

            ccParentpath = wcslen(Parent2);
            cccpath = ccParentpath + ccwstrval + 20;
            cpath2 = (WCHAR*) XCalloc(cccpath, sizeof(WCHAR));

            AppendRDNStr(Parent2,
                         ccParentpath,
                         cpath2,
                         cccpath,
                         wstrval,
                         ccwstrval,
                         pCC->RdnIntId);
        }

        if (pwbConfigAllocData) {
            //
            // wstrval was originally allocated by GetConfigParamAlloc
            // So it must be free'd with free().
            //
            Assert(wstrval == pwbConfigAllocData);
            free(pwbConfigAllocData); pwbConfigAllocData = NULL;            
            wstrval = NULL;
        } else {
            XFree(wstrval); wstrval = NULL;
        }

        if (strcmp(child->m_NodeName,gDsaname)==0)
        {
            wcscpy(gDsaNode,cpath);
            gfDsaNode=TRUE;
            DPRINT1(1,"MACHINE-NODE = %s\n",gDsaNode);
        }
        else if (strcmp(child->m_NodeName,gSchemaname)==0)
        {

            wcscpy(ggSchemaname,cpath);
            gfgSchemaname=TRUE;
            DPRINT1(1,"Schema-NODE = %s\n",ggSchemaname);

        }

        NtStatus = AddOneObjectEx( child,
                                   cpath,
                                   NULL,
                                   Parent2?cpath2:NULL,
                                   fVerbose );

        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }

        UpdateCreateNCInstallMessage( NULL, 0 );  // Parameters are ignored

        HEAPVALIDATE
        Depth++;
        NtStatus = WalkTree(child,cpath,p2,fVerbose);
        if (!NT_SUCCESS(NtStatus)) {
            XFree(cpath);
            if (cpath2) {
                XFree(cpath2);
            }
            return NtStatus;
        }
        Depth--;
        child = pNode->GetNextChild(handle);

        XFree(cpath);
        if (cpath2) {
            XFree(cpath2);
        }

    }

    return NtStatus;
}


#define MAX_ATTRIBUTES 256

//-----------------------------------------------------------------------
//
// Function Name:            AddOneObject
//
// Routine Description:
//
//    Adds one object to the dit
//
// Author: RajNath
//
// Arguments:
//
//    NODE* NewNode,       The Object to Add
//    char* DN,            The DN of the object
//    UUID * pObjectGuid   Pre-determined GUID for the object, or NULL
//    char* DN2,           A second name if a copy of this object is to be
//                                  created
// Return Value:
//
//    NTSTATUS code indicating the nature of the error; STATUS_SUCCESS if
//    success
//
//-----------------------------------------------------------------------

NTSTATUS
AddOneObjectEx(
    IN NODE* NewNode,
    IN WCHAR* DN,
    IN UUID * pObjectGuid,
    WCHAR* DN2,
    BOOL fVerbose
    )
{
    NTSTATUS   NtStatus;
    ATTR       attarray[MAX_ATTRIBUTES];
    ADDARG     AddArg;
    BOOL       fFoundDeleted = FALSE;

    COMMARG*   pcarg = &AddArg.CommArg;
    PDSNAME    pdsa  = NULL;
    DWORD      cbSize;
    ATTRBLOCK* pABlk = &AddArg.AttrBlock;

    ZeroMemory(&AddArg, sizeof(AddArg));

    cbSize = (DWORD)DSNameSizeFromLen(wcslen(DN));
    pdsa = (PDSNAME) XCalloc( cbSize, 1 );    
    BuildDefDSName(pdsa,DN,pObjectGuid,0);
    
    AddArg.pObject = pdsa;

    pABlk->pAttr=attarray;
    ZeroMemory(attarray,sizeof(attarray));


    InitCommarg(pcarg);
    pcarg->fLazyCommit = 1;

    YAHANDLE yh;
    ATTCACHE* pAC;
    char* strval;
    ULONG count=0;
    while (pAC = NewNode->GetNextAttribute(yh,&strval))
    {
        if(pAC->id == ATT_IS_DELETED) {
            fFoundDeleted = TRUE;
        }
        CreateAttr(attarray,count,pAC,strval);
    }

    pABlk->attrCount=count;

    NtStatus = CallCoreToAddObj(&AddArg,fVerbose);

    if(NT_SUCCESS(NtStatus) && fFoundDeleted) {
        // We added a value of the is-deleted attribute.  In this case, call the
        // special routine to set the deletion time to INFINITE (i.e. if you
        // went to the trouble of adding a deleted object via this code path,
        // we assume you don't want it garbage collected.
        if(DBMoveObjectDeletionTimeToInfinite(pdsa)) {
            // Failed.
            XFree(pdsa); pdsa = NULL;
            return STATUS_UNSUCCESSFUL;
        }
    }

    if (NT_SUCCESS(NtStatus) && DN2)
    {
        BuildDefDSName(pdsa,DN2,NULL,1);
        NtStatus = CallCoreToAddObj(&AddArg,fVerbose);
    }

    XFree(pdsa);
    return NtStatus;
}

DWORD
RemoteAddOneObject(
    IN LPWSTR  pServerName,
    IN NODE  * NewNode,
    IN WCHAR * DN,
    OUT UUID  * pObjectGuid, OPTIONAL
    OUT NT4SID *pObjectSid   OPTIONAL
    )
//
// This function is used to add an NTDSA object only
//
{
    DWORD      err;
    PDSNAME    dsabuff;
    DWORD       cbSize;
    ATTR       attarray[MAX_ATTRIBUTES];
    YAHANDLE yh;
    ATTCACHE* pAC;
    char* strval;
    ULONG count=0;
    ENTINFLIST eiList;
    ADDENTRY_REPLY_INFO *infoList;
    GUID* guidList;
    NT4SID*  sidList;


    ZeroMemory(attarray,sizeof(attarray));

    cbSize = (DWORD)DSNameSizeFromLen(wcslen(DN));
    dsabuff = (PDSNAME) XCalloc(cbSize, 1);
    BuildDefDSName(dsabuff, DN, NULL, 0);

    while (pAC = NewNode->GetNextAttribute(yh,&strval))
    {
        CreateAttr(attarray,count,pAC,strval);
    }

    RtlZeroMemory( &eiList, sizeof(eiList) );
    eiList.pNextEntInf = NULL;
    eiList.Entinf.pName = dsabuff;
    eiList.Entinf.ulFlags = 0;  //this is not used
    eiList.Entinf.AttrBlock.attrCount = count;
    eiList.Entinf.AttrBlock.pAttr = attarray;

    err =  I_DRSIsExtSupported(pTHStls,
                               pServerName,
                               DRS_EXT_POST_BETA3 );

    if ( err == ERROR_NOT_SUPPORTED ) {

        //
        // Ok, whack the server reference attribute
        //
        Assert( eiList.Entinf.AttrBlock.pAttr[count-1].attrTyp == ATT_SERVER_REFERENCE );
        eiList.Entinf.AttrBlock.attrCount--;
    }

    err =  RemoteAddOneObjectSimply(pServerName,
                                    NULL,
                                    &eiList,
                                    &infoList);

    if(pTHStls->errCode){
        // RemoteAddOneObjectSimply() sets the thread state error and
        // returns pTHS->errCode.  So crack out the real Win32 error
        // out of the thread error state, clear the errors and continue
        Assert(err == pTHStls->errCode);
        err = Win32ErrorFromPTHS(pTHStls);
        if(err == ERROR_DS_REMOTE_CROSSREF_OP_FAILED){
            // Note: Usually you can just use Win32ErrorFromPTHS(), but
            // if the remote side of the RemoteAddObject routine 
            // got a typical thread error state set, then this function
            // sets that this was a remote crossRef creation that failed in
            // the regular extendedErr and moves the error that caused the 
            // remote add op to fail in the extendedData field.
            err = GetTHErrorExtData(pTHStls);
        }
        Assert(err);
        THClearErrors();
    }
        

    if ( ERROR_SUCCESS == err ) {

        if ( pObjectGuid ) {
            *pObjectGuid = infoList[0].objGuid;
        }
        if ( pObjectSid ) {
            *pObjectSid = infoList[0].objSid;
        }

    }

    XFree(dsabuff);

    return err;
}

DWORD
RemoteAddOneObjectSimply(
    IN   LPWSTR pServerName,
    IN   SecBufferDesc * pClientCreds,
    IN   ENTINFLIST* pEntInfList,
    OUT  ADDENTRY_REPLY_INFO **infoList
    )
/*

  NOTE: This function now sets the thread state error and returns a
  pTHS->errCode.
  
*/
{
    THSTATE * pTHS = pTHStls;
    DRS_MSG_ADDENTRYREQ_V2 Req;
    DRS_MSG_ADDENTRYREPLY Reply;
    DWORD dwReplyVer;
    DWORD err;
    ULONG RetryMs;              // sleep time in milliseconds
    ULONG RetryTotalMs = 0;     // total of all sleeps in milliseconds
    ULONG RetryLimit = 100;     // in milliseconds
    ULONG RetryMaxMs = 60000;   // total of all sleeps cannot exceed 60 seconds

    Assert(pTHS);
    Req.EntInfList = *pEntInfList;

    DPRINT2(0,"About to add '%S' on server '%S'\n",
            Req.EntInfList.Entinf.pName->StringName,
            pServerName);

    err = I_DRSAddEntry(pTHS,
                        pServerName,
                        (DRS_SecBufferDesc *) pClientCreds,
                        &Req,
                        &dwReplyVer,
                        &Reply);
    // In a few cases, retry for a bit if BUSY is returned
    while ( TRUE ){
        // Continues on until we break from this if/else
        //   We break if we have an error that isn't BUSY
        //   or if we've tried for too long.

        if (err) {
            // We've hit a critical error, we couldn't even reach
            // the server, so break.
            break;
        }

        if(dwReplyVer == 2){           
            // Win2k response, determine if not busy, then break.
            if(! (Reply.V2.problem == SV_PROBLEM_BUSY &&
                  (Reply.V2.extendedErr == DIRERR_DATABASE_ERROR ||
                   Reply.V2.extendedErr == ERROR_DS_BUSY) &&
                  RetryTotalMs < RetryMaxMs) ){
                // Don't retry.
                break;
            }

        } else if(dwReplyVer == 3){
            
            if(Reply.V3.dwErrVer != 1){
                Assert(!"Unknown error version!");
                break;
            }
            if(Reply.V3.pErrData == NULL){
                // This means the the DRS_AddEntry call failed because
                // the DC was shutting down or out of memory.
                break;
            }
            if(Reply.V3.pErrData->V1.errCode && (Reply.V3.pErrData->V1.pErrInfo == NULL) ){
                Assert(!"We've got a bad error message.  Bailing.");
                // Be cool if we kept track of the DSID as well.
                err = ERROR_DS_CODE_INCONSISTENCY;
                break;
            }
            if(! (Reply.V3.pErrData->V1.errCode == serviceError &&
                  Reply.V3.pErrData->V1.pErrInfo->SvcErr.problem == SV_PROBLEM_BUSY &&
                  (Reply.V3.pErrData->V1.pErrInfo->SvcErr.extendedErr == DIRERR_DATABASE_ERROR ||
                   Reply.V3.pErrData->V1.pErrInfo->SvcErr.extendedErr == ERROR_DS_BUSY) &&
                  RetryTotalMs < RetryMaxMs )
                  ){
                // if not busy break
                break;
            }

        } else {
            Assert(!"Code Inconsistency!");
            // Punt the error ... but do set an error!
            err = ERROR_DS_CODE_INCONSISTENCY;
        }

        // Compute milliseconds to sleep before retry.
        srand((UINT)GetTickCount());
        RetryMs = rand() % RetryLimit;

        // Double the limit on each retry
        RetryLimit <<= 1;

        // Total of all sleeps can't exceed RetryMaxMs (60 seconds)
        RetryTotalMs += RetryMs;
        if (RetryTotalMs > RetryMaxMs) {
            RetryMs -= RetryTotalMs - RetryMaxMs;
        }

        // Wait a bit and then retry the remote operation
        DPRINT2(0, "REMOTE RETRY AddEntry(%ws) in %d msecs.\n",
                Req.EntInfList.Entinf.pName->StringName,
                RetryMs);
        Sleep(RetryMs);
        err = I_DRSAddEntry(pTHS,
                            pServerName,
                            (DRS_SecBufferDesc *) pClientCreds,
                            &Req,
                            &dwReplyVer,
                            &Reply);
    }

    if (err) {
        
        // Got an error on the local repl API side or we couldn't understand
        // the reply packet (like if the error state wasn't correct), set an
        // intelligent error in the extendedErr, and specify it was from the 
        // DRA in the extendedData.
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                    err);

    } else {

        // We at least got to the remote side ... so if there is an
        // error it needs to be gotten out of the reply message.
        if(dwReplyVer == 2){

            // This is OK to do, because the only time we get a reply
            // of version 2, is from a Win2k box, so this must be dcpromo
            // calling us, so we know that they're just going to look 
            // at the extended error and return it.
            if (Reply.V2.extendedData) {

                // If there was an error
                SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                            Reply.V2.extendedData);

            }
            DPRINT7(0, "Win2k RemoteAddEntry(%ws). Error %d, errCode %d, extData %d, problem %d, extErr %d, dsid %08x\n",
                    Req.EntInfList.Entinf.pName->StringName,
                    err,
                    Reply.V2.errCode,
                    Reply.V2.extendedData,
                    Reply.V2.problem,
                    Reply.V2.extendedErr,
                    Reply.V2.dsid);

        } else if(dwReplyVer == 3){

            // The unpacking and setting of the thread state error all
            // happens in this function.
            draDecodeDraErrorDataAndSetThError(Reply.V3.dwErrVer, 
                                               Reply.V3.pErrData, 
                                               ERROR_DS_REMOTE_CROSSREF_OP_FAILED,
                                               pTHS);

        }
    }

    // We should have ALOT more helpful information than we reported in Win2k!
    DPRINT7(0, "RemoteAddEntry(%ws), Error %d, dwRepError = %d, errCode %d, extErr %d, extData %d, dsid %08x\n",
            Req.EntInfList.Entinf.pName->StringName,
            err,
            (dwReplyVer == 3 && Reply.V3.pErrData) ? Reply.V3.pErrData->V1.dwRepError : 0,
            pTHS->errCode,
            Win32ErrorFromPTHS(pTHS),
            GetTHErrorExtData(pTHS),
            GetTHErrorDSID(pTHS)
            );

    if ( ERROR_SUCCESS == err ) {
        if ( infoList ) {
            *infoList = (dwReplyVer == 3) ? Reply.V3.infoList : Reply.V2.infoList;
        }
    } else {
        DPRINT2(0,"RemoteAdd failed, extended error was %u, DSID %08X\n",
                Win32ErrorFromPTHS(pTHStls),
                GetTHErrorDSID(pTHStls)
                );
    }

    return(pTHS->errCode);
}

//-----------------------------------------------------------------------
//
// Function Name:            BuildDefDSName
//
// Routine Description:
//
//    Builds a DSNAME from char*
//
// Author: RajNath
//
// Arguments:
//
//    PDSSNAME pDsa ,              Returned DSNAME, Its preallocaterd
//    char* DN             The name
//    GUID* guid               The Guid [Optional]
//
// Return Value:
//
//    VOID             No Return
//
//-----------------------------------------------------------------------

VOID
BuildDefDSName(PDSNAME pDsa,char* DN,GUID* guid,BOOL flag)
{
    GUID ng={0,0,0,0};;
    if (flag) {
        ng=GenGuid();
    }
    else if (guid!=NULL) {
        ng=*guid;
    }

    pDsa->NameLen  =strlen(DN);
    pDsa->structLen=DSNameSizeFromLen(pDsa->NameLen);

    MultiByteToWideChar(CP_ACP,
                        0,
                        DN,
                        pDsa->NameLen,
                        pDsa->StringName,
                        pDsa->NameLen);

    pDsa->StringName[pDsa->NameLen]=L'\0';

    CopyMemory(&(pDsa->Guid),&ng,sizeof(GUID));
    pDsa->SidLen = 0;
}

//-----------------------------------------------------------------------
//
// Function Name:            BuildDefDSName
//
// Routine Description:
//
//    Builds a DSNAME from char*
//
// Author: RajNath
//
// Arguments:
//
//    PDSSNAME pDsa ,              Returned DSNAME, Its preallocaterd
//    WCHAR* DN             The name
//    GUID* guid               The Guid [Optional]
//
// Return Value:
//
//    VOID             No Return
//
//-----------------------------------------------------------------------
VOID
BuildDefDSName(PDSNAME pDsa,WCHAR* DN,GUID* guid,BOOL flag)
{
    GUID ng={0,0,0,0};;
    if (flag) {
        ng=GenGuid();
    }
    else if (guid!=NULL) {
        ng=*guid;
    }

    pDsa->NameLen  =wcslen(DN);
    pDsa->structLen=DSNameSizeFromLen(pDsa->NameLen);

    wcscpy(pDsa->StringName,DN);
    pDsa->StringName[pDsa->NameLen]=L'\0';

    CopyMemory(&(pDsa->Guid),&ng,sizeof(GUID));
}

//
unsigned cssdcSavedLen = 0;
char *   cssdcSavedStr = NULL;
PSECURITY_DESCRIPTOR cssdcSavedSD = NULL;
ULONG    cssdcSavedSize = 0;

BOOL
CachedStringSDConverter(char *strval,
                        PSECURITY_DESCRIPTOR *ppbuf,
                        ULONG *posiz)
{
    unsigned len;
    BOOL flag;

    len = strlen(strval);

    if (   (len == cssdcSavedLen)
        && (0 == memcmp(strval, cssdcSavedStr, len))) {
        // We can use the existing cached SD
        flag = TRUE;
    }
    else {
        // Not the same SD as last time, so cache a new one.
        if (cssdcSavedSD) {
            LocalFree(cssdcSavedSD);
        }
        if (cssdcSavedStr) {
            LocalFree(cssdcSavedStr);
            cssdcSavedStr = NULL;
        }
        flag = ConvertStringSDToSDRootDomainA
          (
           gpRootDomainSid,
           strval,
           SDDL_REVISION_1,
           &cssdcSavedSD,
           &cssdcSavedSize
           );
        if (flag) {
            // if we succeeded, remember the arguments
            cssdcSavedStr = (char *) LocalAlloc(0, len);
            if (cssdcSavedStr) {
                cssdcSavedLen = len;
                memcpy(cssdcSavedStr, strval, len);
            }
            else {
                cssdcSavedLen = 0;
            }
        }
        else {
            // if we failed, forget everything
            cssdcSavedSD = NULL;
            cssdcSavedLen = 0;
            cssdcSavedStr = NULL;
        }
    }

    if (flag) {
        // No matter how we got here, if flag is set then we want to copy
        // the cached SD.
        *ppbuf = LocalAlloc(0, cssdcSavedSize);
        if (*ppbuf) {
            memcpy(*ppbuf, cssdcSavedSD, cssdcSavedSize);
            *posiz = cssdcSavedSize;
        }
        else {
            flag = FALSE;
        }
    }
    return flag;
}
//

//-----------------------------------------------------------------------
//
// Function Name:            CreateAttr
//
// Routine Description:
//
//    Converts a string to its actual type
//
// Author: RajNath
//
// Arguments:
//
//    ATTR* attr,              OUT value, Preallocated space
//    ULONG ndx,               Counter - IN OUT Param
//    ATTCACHE* pAC,           The Attribute class of this string
//    strval,                  String representation of the attribute value
//
//
//
// Return Value:
//
//    VOID             No Return, Exception on Failure
//
//-----------------------------------------------------------------------

VOID
CreateAttr(ATTR* attr,ULONG& ndx,ATTCACHE* pAC,char* strval)
{
    THSTATE *pTHS = pTHStls;
    UCHAR* obuf;
    ULONG  osiz;
    WCHAR  *Widepp = NULL;

    //
    // Some Syntaxes need to be preprocessed becuase they are in
    // a human readable form...eg OM_S_OBJECT_IDENTIFIER_STRING
    //
    char* pp=PreProcessInifileShortcuts(strval,pAC, &Widepp);


    //
    // Some Attributes need to be preprocessed becuase they are in
    // a human readable form...eg ATT_NT_SECURITY_DESCRIPTOR
    //
    switch (pAC->id) {
    case ATT_SCHEMA_ID_GUID:
    case ATT_ATTRIBUTE_SECURITY_GUID:
        {
            // Need to byte swap (character swap) the string for little
            // endian machine representation.  Note that we use the
            // string directly w/o swapping when generating ntdsguid.c
            // which is correct as the compiler will do the swap when
            // constructing the static value.

            // To be clear - the values in schema.ini are generated
            // programatically by UuidCreate() followed by UuidToString()
            // and the resulting string is written to schema.ini.
            // UuidToString already does the byte swap so that with
            // the insertion of require braces and commas, the string
            // can be used as a static initializer - as we do in ntdsguid.c.
            // However, byte swapping is required in order to construct
            // an array of bytes which will be identical to the array
            // of bytes found in memory for something created via the
            // static initializer.

            DWORD   i;
            CHAR    c;

            // Validate string.

            Assert((34 == strlen(strval)) &&
                   ('\\' == strval[0]) &&
                   (('x' == strval[1]) || ('X' == strval[1])));

            for ( i = 2; i < 34; i++ )
            {
                c = strval[i];

                Assert(((c >= '0') && (c <= '9')) ||
                       ((c >= 'a') && (c <= 'f')) ||
                       ((c >= 'A') && (c <= 'F')))
            }

            // Do the swap.  String representation requires two bytes per
            // byte of resulting data, thus alias a USHORT array on top
            // of the string data.

            USHORT *data = (USHORT *) &strval[2];
            USHORT us;

            us = data[3];
            data[3] = data[0];
            data[0] = us;
            us = data[2];
            data[2] = data[1];
            data[1] = us;
            us = data[5];
            data[5] = data[4];
            data[4] = us;
            us = data[7];
            data[7] = data[6];
            data[6] = us;

            StrToAttrib(strval, NULL, pAC, &obuf,osiz);
        }

        break;

    case ATT_NT_SECURITY_DESCRIPTOR:
        {
            DWORD err;
            BOOL  flag = TRUE;
            WCHAR strsecdesc[1024];

            flag = CachedStringSDConverter(strval,
                                           (PSECURITY_DESCRIPTOR*)&obuf,
                                           &osiz);

            if (!flag)
            {
                err = GetLastError();
                DPRINT2(0,
                        "Security descriptor(%s) conversion failed, error %x\n",
                        strval,err);
                XINVALIDINIFILE();
            }

            UCHAR* buff=(UCHAR*)XCalloc(1,osiz);
            CopyMemory(buff,obuf,osiz);

            LocalFree(obuf); // Converted SD is LocalAlloced
            obuf=buff;
        }
        break;
    case ATT_OBJECT_CATEGORY:
    case ATT_DEFAULT_OBJECT_CATEGORY:
        {
            // These two attributes are DS-DN syntaxed, but in schema.ini,
            // they are just specified as the cn. We need to form the whole
            // DN before we pass it off


            PWCHAR pwbBuf;
            DWORD  cwbBufSize;
            PWCHAR pTmpBuf = NULL;
            DWORD  tmpSize = 0;
            DWORD  err;
            int i = 0;


            //
            // First need to allocate a buffer of appropriate size.  Start by
            // counting the sizes of all the parts in characters.
            //
            cwbBufSize = sizeof("CN=,");

            if (!gInstallHasDoneSchemaMove) {
                cwbBufSize += sizeof("CN=Schema,O=Boot");
            } else {
                err = GetConfigParamAllocW(MAKE_WIDE(SCHEMADNNAME), (PVOID *)&pTmpBuf, &tmpSize);
                if (ERROR_OUTOFMEMORY == err) {
                    DPRINT(0, "GetConfigParamAlloc could not allocate enough memory.\n");
                    XOUTOFMEMORY();
                } else if (err) {
                    DPRINT1(0,
                            "GetConfigParam failed, error 0x%x\n",
                            err);
                    XINVALIDINIFILE();
                }
                Assert(!(tmpSize % 2));  // Should get an even number of bytes
                                         // since we are expecting a Wide Char string.
                cwbBufSize += tmpSize / sizeof(WCHAR);
            }

            // 
            // tmpSize will be in characters this time.
            //
            tmpSize = MultiByteToWideChar(CP_ACP,
                                          0,
                                          strval,
                                          strlen(strval),
                                          NULL,
                                          0);
            if (0 == tmpSize) {
                DPRINT1(0,
                        "MultiByteToWideChar failed, error 0x%x\n",
                        GetLastError());
                if (pTmpBuf) free(pTmpBuf);
                XINVALIDINIFILE();
            }

            cwbBufSize += tmpSize;

            //
            // Now allocate the buffer.
            //
            pwbBuf = (PWCHAR) XCalloc(cwbBufSize, sizeof(WCHAR));
            
            wcscpy(pwbBuf, L"CN=");
            i += 3;
            MultiByteToWideChar(CP_ACP,
                                0,
                                strval,
                                strlen(strval),
                                &pwbBuf[i],
                                cwbBufSize - 3);
            i += strlen(strval);
            wcscpy(&pwbBuf[i++],L",");
            if(!gInstallHasDoneSchemaMove) {
                // The schema is still in the boot dit configuration.  Hardcode
                // the boot schema dn
                wcscpy(&pwbBuf[i],L"CN=Schema,O=Boot");
            }
            else {
                wcscpy(&pwbBuf[i],pTmpBuf);
                free(pTmpBuf); pTmpBuf = NULL;
            }

            // Ok, we have a null-terminated string. Now pass this
            // to StrToAttrib
            StrToAttrib(NULL, pwbBuf, pAC, &obuf,osiz);
            XFree(pwbBuf);
        }
        break;

    default:
        {
            if ( Widepp )
            {
                pp = NULL;
            }

            StrToAttrib(pp, Widepp, pAC, &obuf,osiz);
        }
        break;
    }


    //
    // See if we already have a ATTR for this type
    //
    for (ULONG i=0;i<ndx;i++)
    {
        if (pAC->id==attr[i].attrTyp)
        {
            attr[i].AttrVal.pAVal=
                (ATTVAL*)XRealloc(attr[i].AttrVal.pAVal,
                                  (attr[i].AttrVal.valCount+1)*sizeof(ATTRVAL));
            break;
        }
    }

    if (i==ndx)
    {
        attr[i].AttrVal.pAVal=(ATTVAL*)XCalloc(1,sizeof(ATTRVAL));
        ndx++;
    }

    attr[i].attrTyp=pAC->id;
    attr[i].AttrVal.pAVal[attr[i].AttrVal.valCount].pVal=obuf;
    attr[i].AttrVal.pAVal[attr[i].AttrVal.valCount].valLen=osiz;

    if ( ATT_INVOCATION_ID == attr[i].attrTyp )
    {
        // rajnath : dirty hack to fix Invocation-ID on machine object
        memcpy(attr[i].AttrVal.pAVal[attr[i].AttrVal.valCount].pVal,
               &pTHS->InvocationID,
               sizeof(pTHS->InvocationID));
    }

    attr[i].AttrVal.valCount++;
}


//-----------------------------------------------------------------------
//
// Function Name:            FreeAttrBlock
//
// Routine Description:
//
//    Frees memory associated with a AttrBlock
//
// Author: RajNath
//
// Arguments:
//
//
// Return Value:
//
//    VOID             No Return
//
//-----------------------------------------------------------------------

VOID FreeAttrBlk(ATTR* Attr,ULONG Count)
{
    for (ULONG i=0;i<Count;i++)
    {
        for (ULONG j=0;j<Attr[i].AttrVal.valCount;j++)
        {
            XFree(Attr[i].AttrVal.pAVal[j].pVal);
        }
        XFree(Attr[i].AttrVal.pAVal);
    }
}



//-----------------------------------------------------------------------
//
// Function Name:            StrToAttrib
//
// Routine Description:
//
//    Helper Function for converting String Value into  its proper type
//    Now even handles useful input strings.
//
// Arguments:
//
//    char* strval             The string value
//    DWORD omsyntax               OM Syntax of the attribute
//    DWORD syntax,            Syntax
//    UCHAR** ptr,             Returned value
//    DWORD& siz               The size of the returned value
//
//
// Return Value:
//
//    VOID             No Return, Exception on failure
//
//-----------------------------------------------------------------------

VOID StrToAttrib
(
   char*     strval,
   WCHAR*    wstrval,
   ATTCACHE  *pAC,
   UCHAR**   ptr,
   DWORD&    siz
)
{

    PWCHAR Buffer2 = NULL;
    PCHAR  IntegerBuffer = NULL;
    DWORD size;

    if ( pAC->OMsyntax == OM_S_OBJECT )
    {
        //
        // This function supports only wide characters for object names
        //
        if ( !wstrval )
        {
            //
            // Make the string wide char
            //
            size = MultiByteToWideChar(CP_ACP,
                                       0,
                                       strval,
                                       -1,
                                       NULL,
                                       0);

            if (0 == size) {
                DPRINT2(0, "StrToAttrib: MultiByteToWideChar failed with %d, line %d\n", GetLastError(), __LINE__);
                XINVALIDINIFILE();
            }
            
            Buffer2 = (PWCHAR) XCalloc(size, sizeof(WCHAR));

            MultiByteToWideChar(CP_ACP,
                                0,
                                strval,
                                -1,
                                Buffer2,
                                size);
            wstrval = Buffer2;

        }
    }
    else if ( pAC->OMsyntax == OM_S_UNICODE_STRING )
    {
        // This function supports both for unicode string
        Assert( wstrval || strval );
    }
    else if ( pAC->OMsyntax == OM_S_INTEGER )
    {
        // Convert to mbcs if necessary. 
        if (strval == NULL) {

            DWORD ret;
            Assert(wstrval);
            size = wcslen(wstrval);
            IntegerBuffer = (PCHAR) XCalloc(size + 1, sizeof(CHAR));
            ret = (DWORD) wcstombs(IntegerBuffer, 
                                   wstrval, 
                                   (size+1) * sizeof(CHAR));
            if (ret != (size * sizeof(CHAR))) {
                XINVALIDINIFILE();
            }
            strval = IntegerBuffer;
        }
    }
    else
    {
        //
        // This function supports only ascii for other types
        //
        Assert( NULL == wstrval );
        Assert( strval );
    }


    switch(pAC->OMsyntax)
    {

        case OM_S_BOOLEAN:
        case OM_S_INTEGER:
        case OM_S_ENUMERATION:
        {

            /* all basically integers */
            *ptr=(UCHAR*)XCalloc(1,sizeof(SYNTAX_INTEGER));
            // first, find the sign
            if(*strval == '-') {
                *((LONG *)(*ptr)) = strtol(strval, (char **)NULL, 0);
            }
            else {
                *((ULONG *)(*ptr)) = strtoul(strval, (char**)NULL, 0);
            }
            siz=sizeof(SYNTAX_INTEGER);
        }
        break;

        case OM_S_I8:
        {
          /* Large Interger */
            int len;
            SYNTAX_I8 *pInt;
            LONG sign=1;
            int i;

            *ptr=(UCHAR*)XCalloc(1,sizeof(SYNTAX_I8));
            pInt = (SYNTAX_I8 *)(*ptr);
            len = strlen(strval);

            pInt->QuadPart = 0;
            i=0;
            if(strval[i] == '-') {
                sign = -1;
                i++;
            }

            if(i==len) {
                //  no string, or just a '-'
                XINVALIDINIFILE();
            }

            for(;i<len;i++) {
                // Parse the string one character at a time to detect any
                // non-allowed characters.
                if((strval[i] < '0') || (strval[i] > '9')) {
                   XINVALIDINIFILE();
                }

                pInt->QuadPart = ((pInt->QuadPart * 10) +
                                  strval[i] - '0');
            }
            pInt->QuadPart *= sign;

            siz=sizeof(SYNTAX_I8);
        }
        break;

        case OM_S_OCTET_STRING:
        {

            OID_t Obj;

            if (StringToOID(strval,&Obj))
            {
                XINVALIDINIFILE();
            }

            *ptr = (UCHAR*)Obj.elements;
            siz  = Obj.length;
        }
        break;

        case OM_S_OBJECT_IDENTIFIER_STRING:
        {

            ATTRTYP at;
            if (OidStrToAttrType(pTHStls, TRUE, strval, &at))
            {
                XINVALIDINIFILE();
            }

            *ptr=(UCHAR*)XCalloc(1,sizeof(ULONG));
            *(ULONG *)(*ptr)=at;
            siz=sizeof(ULONG);
        }
        break;


        case OM_S_TELETEX_STRING:
        case OM_S_IA5_STRING:
        case OM_S_PRINTABLE_STRING:
        {

            *ptr = (UCHAR*)XStrdup(strval);
             siz = strlen(strval);
        }
        break;

        case OM_S_UNICODE_STRING:
        {
            WCHAR* wide;
            ULONG  Length;

            if ( wstrval )
            {
                Length = wcslen( wstrval );
                wide= (WCHAR*) XCalloc(1, (Length+1)*sizeof(WCHAR) );
                wcscpy( wide, wstrval );
            }
            else
            {
                Assert( strval );
                Length = strlen( strval );
                wide= (WCHAR*) XCalloc(1, (Length+1)*sizeof(WCHAR) );
                MultiByteToWideChar(CP_ACP,
                                    0,
                                    strval,
                                    Length + 1,
                                    wide,
                                    Length + 1);
            }

            *ptr = (UCHAR*)wide;
             siz = sizeof(WCHAR)*Length;
        }
        break;

        case OM_S_OBJECT:
        {

            switch(pAC->syntax) {
            case SYNTAX_DISTNAME_BINARY_TYPE:
                {
                    PDSNAME pdsn=NULL;
                    SYNTAX_DISTNAME_STRING* pDN_Addr;
                    ULONG stringLength=0;
                    SYNTAX_ADDRESS *pAddress=NULL;
                    ULONG i,j;
                    BOOL fDone=FALSE;

                    // Get the length of the string portion

                    for(i=0;!fDone && i<wcslen(wstrval);i++) {
                        // Parse the string one character at a time to detect
                        // any non-allowed characters.
                        if(wstrval[i] == L':') {
                            fDone = TRUE;
                            continue;
                        }

                        if(!(((wstrval[i] >= L'0') && (wstrval[i] <= L'9')) ||
                             ((wstrval[i] >= L'a') && (wstrval[i] <= L'f')) ||
                             ((wstrval[i] >= L'A') && (wstrval[i] <= L'F')))) {
                            XINVALIDINIFILE();
                        }

                        stringLength = (stringLength * 10) + wstrval[i] - L'0';
                    }
                    if(!fDone) {
                        // Didn't find the ':'
                        XINVALIDINIFILE();
                    }

                    // Make sure there is a ':' between the string and the dn
                    if(wstrval[i+stringLength] != L':') {
                        XINVALIDINIFILE();
                    }


                    if(stringLength & 1) {
                        // This must be even
                        XINVALIDINIFILE();
                    }
                    stringLength /= 2;

                    // Now, get the string
                    pAddress = (SYNTAX_ADDRESS *)
                        XCalloc(1, STRUCTLEN_FROM_PAYLOAD_LEN( stringLength ));




                    for(j=0;j<stringLength;j++, i += 2) {
                        // get the next two characters as a byte.
                        WCHAR acTmp[3];

                        acTmp[0] = towlower(wstrval[i]);
                        acTmp[1] = towlower(wstrval[i +  1 ]);
                        acTmp[2] = L'\0';

                        if(iswxdigit(acTmp[0]) && iswxdigit(acTmp[1])) {
                            pAddress->byteVal[j] = (UCHAR)wcstol(acTmp,
                                                                 NULL,
                                                                 16);
                        }
                        else {
                            XINVALIDINIFILE();
                        }
                    }

                    pAddress->structLen = STRUCTLEN_FROM_PAYLOAD_LEN( stringLength );
                    // Now, the DSNAME


                    i++;
                    
                    size = (DWORD)DSNameSizeFromLen(wcslen(&wstrval[i]));
                    pdsn = (PDSNAME) XCalloc(1, size);
                    BuildDefDSName(pdsn,&wstrval[i],NULL);

                    // Now, synthesize

                    pDN_Addr = (SYNTAX_DISTNAME_STRING*)
                        XCalloc(1,
                                (USHORT)DERIVE_NAME_DATA_SIZE(pdsn, pAddress));

                    BUILD_NAME_DATA( pDN_Addr, pdsn, pAddress );

                    *ptr = (UCHAR*)pDN_Addr;
                    siz  = (USHORT)DERIVE_NAME_DATA_SIZE(pdsn, pAddress);
                    XFree(pdsn);
                }

                break;

                case SYNTAX_DISTNAME_STRING_TYPE:
                {

                    Assert(!"SYNTAX_DISTNAME_STRING_TYPE not supported");
                    XINVALIDINIFILE();
#if 0
// Obviously this code has never been tested (See above assert), but I
// am leaving it in as a useful starting point if this functionality is
// ever needed. But be careful, the code does not support UNICODE chars.

                    PDSNAME pdsn=NULL;
                    SYNTAX_DISTNAME_STRING* pDN_Addr;
                    ULONG stringLength=0;
                    SYNTAX_ADDRESS *pAddress=NULL;
                    ULONG i;
                    BOOL fDone=FALSE;

                    // Get the length of the string portion

                    for(i=0;!fDone && i<strlen(strval);i++) {
                        // Parse the string one character at a time to detect
                        // any non-allowed characters.
                        if(strval[i] == ':') {
                            fDone = TRUE;
                            continue;
                        }

                        stringLength = (stringLength * 10) + strval[i] - '0';
                    }
                    if(!fDone) {
                        // Didn't find the ':'
                        XINVALIDINIFILE();
                    }

                    // Make sure there is a ':' between the string and the dn
                    if(strval[i+stringLength] != ':') {
                        XINVALIDINIFILE();
                    }


                    // Now, get the string
                    pAddress = (SYNTAX_ADDRESS *)
                        XCalloc(1, STRUCTLEN_FROM_PAYLOAD_LEN( stringLength ));


                    // What is stringLength ???

                    memcpy(pAddress->uVal,
                           &wstrval[i],
                           stringLength);

                    pAddress->structLen = STRUCTLEN_FROM_PAYLOAD_LEN( stringLength );

                    // Now, the DSNAME


                    size = DSNameSizeFromLen(strlen(&strval[i + stringLength + 1]));
                    pdsn = XCalloc(1, size);

                    BuildDefDSName(pdsn,&strval[i + stringLength + 1],NULL);

                    // Now, synthesize

                    pDN_Addr = (SYNTAX_DISTNAME_STRING*)
                        XCalloc(1,
                                (USHORT)DERIVE_NAME_DATA_SIZE(pdsn, pAddress));

                    BUILD_NAME_DATA( pDN_Addr, pdsn, pAddress );

                    *ptr = (UCHAR*)pDN_Addr;
                    siz  = (USHORT)DERIVE_NAME_DATA_SIZE(pdsn, pAddress);
                    XFree(pdsn);
#endif 0 SYNTAX_DISTNAME_STRING_TYPE NOT SUPPORTED
                }
                break;

            case SYNTAX_ADDRESS_TYPE:
                {
                    Assert(!"SYNTAX_ADDRESS_TYPE not supported");
                    XINVALIDINIFILE();
#if 0
// Obviously this code has never been tested (See above assert), but I
// am leaving it in as a useful starting point if this functionality is
// ever needed.

                    SYNTAX_ADDRESS* pNodeAddr=(SYNTAX_ADDRESS*)
                        XCalloc(1, STRUCTLEN_FROM_PAYLOAD_LEN( 0 ));

                    pNodeAddr->structLen = STRUCTLEN_FROM_PAYLOAD_LEN( 0 );

                    *ptr = (UCHAR*)pNodeAddr;
                    siz  = STRUCTLEN_FROM_PAYLOAD_LEN( 0 );
#endif 0 SYNTAX_ADDRESS_TYPE NOT SUPPORTED
                }
                break;

            case SYNTAX_DISTNAME_TYPE:
                {
                    ULONG namelen=wcslen(wstrval)+1;
                    ULONG strulen=DSNameSizeFromLen( namelen );

                    PDSNAME ds=(PDSNAME)XCalloc(1,strulen);

                    BuildDefDSName(ds,wstrval,NULL);
                    *ptr=(UCHAR*)ds;
                    siz=strulen;

                }
                break;

                default:
                    XINVALIDINIFILE()
                    break;
            }
        }
        break;
    default:
        XINVALIDINIFILE()
            break;
    }
    if (Buffer2) {
        XFree(Buffer2);
    }
    if (IntegerBuffer) {
        XFree(IntegerBuffer);
    }
}

DWORD
StrToOctet(char * String)
{
    DWORD u, index = 0, count;
    char * t = String;

    /* first, check for string = "0".  This is a special case. */
    if ((*t == '0') && (t[1] == '\0')) {
        String[0] = 0;
        return 1;
    }

    /* Now, skip over initial \x or \X, if it exists. */
    if(*t == '\\') {
        t++;
        if((*t != 'x') && (*t != 'X')) {
            XINVALIDINIFILE();
        }
        t++;
    }

    while (*t != '\0') {
        u = 0;
        for (count=0; count<2; count++) {
            if ((*t >= 'A') && (*t <= 'F'))
                u = u * 16 + (unsigned)*t - 'A' + 10;
            else if ((*t >= 'a') && (*t <= 'f'))
                u = u * 16 + (unsigned)*t - 'a' + 10;
            else if ((*t >= '0') && (*t <= '9'))
                u = u * 16 + (unsigned)*t - '0';
            else {
                XINVALIDINIFILE();
            }

            t++;
        }

        String[index]=(char)u;
        index++;

    }

    return index;
}

BOOL
GetDefaultReplScheduleString(char *pStr, ULONG cb)
{
    // Each byte of SCHEDULE will translate into two chars in the string form
    // and we prepend that with "\x" to say that it is a hex string. And we put
    // a null-terminator.
    if (cb < (g_sched.Size * 2 + 3)) {
        return FALSE;
    }

    // pre-pend the "\x" first
    *pStr++ = '\\';
    *pStr++ = 'x';

    ULONG i;

    // append the schedule header part
    BYTE *pb = (BYTE *) &g_sched;
    for (i = 0; i < sizeof(SCHEDULE); i++) {
        sprintf(pStr, "%02x", *pb++);
        pStr += 2;
    }

    // append the data part
    pb = g_defaultSchedDBData;
    for (i = 0; i < SCHEDULE_DATA_ENTRIES; i++) {
        sprintf(pStr, "%02x", *pb++);
        pStr += 2;
    }

    // null-terminate
    *pStr = '\0';

    return TRUE;
}

//-----------------------------------------------------------------------
//
// Function Name:            PreProcessInifileShortcuts
//
// Routine Description:
//
//    Converts inifile values into the actual string values.
//    eg ref to Attribute/Class Schema Names get converted into equiv OIDs
//       ref to Registry/Environment var get converted into there actual
//               string value.
//
// Author: RajNath
//
// Arguments:
//
//    char* strval,            The String Value Read In
//    ATTCACHE* pAC,             The Attribute of this value
//
//
// Return Value:
//
//    char*                NULL on Failure
//
//-----------------------------------------------------------------------

char*
PreProcessInifileShortcuts
(
   char* strval,
   ATTCACHE* pAC,
   WCHAR **Widepp
)
{
    static char StaticBuff[512];
    static char bData[512];

    static WCHAR wStaticBuff[512];
    static WCHAR wbData[512];

    char*  ret=StaticBuff;

    *Widepp = NULL;

    ret[0]='\0';


    //
    // Lets see if we need to read registry or env
    //
    if (strncmp(EMBEDDED,strval,sizeof(EMBEDDED)-1)==0)
    {
        LONG  err;
        DWORD dwType = REG_SZ;
        DWORD cbData = sizeof(wbData);
        DWORD index = 0;

        WCHAR KeyName[512];
        ULONG KeyLength;

        // There should be an embedded regentry in here.

        while(strval[index + sizeof(EMBEDDED) - 1] != '<') {
            mbtowc( &wbData[index], &strval[index + sizeof(EMBEDDED) - 1], sizeof(CHAR) );
            index++;
        }
        cbData -= index;

        MultiByteToWideChar(CP_ACP,
                            0,
                            &strval[sizeof(EMBEDDED) + index],
                            strlen(&strval[sizeof(EMBEDDED) + index])+1,
                            KeyName,
                            512);

        err =  GetConfigParamW(KeyName,
                               &wbData[index],
                               cbData);

        if (err!=0)
        {
            DPRINT2(0, "Could Not Read Registry %s REG_SZ. Error %d\n",
                    &strval[sizeof(EMBEDDED)-1],GetLastError());
            XINVALIDINIFILE();
        };

        *Widepp = wbData;

        strval=bData;


    }
    else if (strncmp(REGENTRY,strval,sizeof(REGENTRY)-1)==0)
    {
        LONG  err;
        DWORD cbData = sizeof(wbData);
        CHAR  *TempString = &strval[sizeof(REGENTRY)-1];

        WCHAR KeyName[512];
        ULONG KeyLength;


        MultiByteToWideChar(CP_ACP,
                            0,
                            TempString,
                            strlen(TempString)+1,
                            KeyName,
                            512);

        err =  GetConfigParamW( KeyName, wbData, cbData );

        if (err!=0)
        {
            DPRINT2(0, "Could Not Read Registry %s REG_SZ. Error %d\n",
                    &strval[sizeof(REGENTRY)-1],GetLastError());
            XINVALIDINIFILE();
        }

        *Widepp = wbData;
        strval=bData;

    }
    else if (strncmp(ENVENTRY,strval,sizeof(ENVENTRY)-1)==0)
    {
        LONG  err;

        // Get OBJECT/UNICODE-syntaxed values in Unicode, get everything else
        // in ascii only

        if ( (pAC->OMsyntax == OM_S_OBJECT)
                || (pAC->OMsyntax == OM_S_UNICODE_STRING) ) {
            WCHAR EnvVarName[512];
            MultiByteToWideChar( CP_ACP,
                                 0,
                                 &strval[sizeof(ENVENTRY)-1],
                                 strlen(&strval[sizeof(ENVENTRY)-1]) + 1,
                                 EnvVarName,
                                 512);

            err = GetEnvironmentVariableW(EnvVarName,
                                         wbData,
                                         sizeof(wbData)/sizeof(WCHAR));
        }
        else {
            err = GetEnvironmentVariable(&strval[sizeof(ENVENTRY)-1],bData,
                                         sizeof(bData));
        }

        if (err == 0 )
        {
            DPRINT1(0, "Could Not Read Environment Var %s \n",
                    &strval[sizeof(ENVENTRY)-1]);
            XINVALIDINIFILE();
        }

        *Widepp = wbData;
        strval = bData;
    }
    else if (strncmp(SYSDEFENTRY, strval, sizeof(SYSDEFENTRY)-1) == 0)
    {
        // right now REPLSCHEDULE is the only SYSDEFENTRY in schema.ini
        // we might add more in this category if needed
        if (_stricmp(REPLSCHEDULE, &strval[sizeof(SYSDEFENTRY)-1]) == 0)
        {
            // use the default repl schedule
            if (!GetDefaultReplScheduleString(bData, 512))
            {
                XINVALIDINIFILE();
            }

            strval = bData;
        }
        else
        {
            // SYSDEFENTRY with empty value
            XINVALIDINIFILE();
        }
    }


    //
    // Translate Attribute/Schema Class Names to OIDs
    //
    switch(pAC->OMsyntax) {

    case OM_S_BOOLEAN:
        {
            // In Inifile its TRUE/FALSE
            BOOL num=(_stricmp(strval,"FALSE")!=0);
            sprintf(ret,"%d",num);
            break;
        }

    case OM_S_OBJECT_IDENTIFIER_STRING:
        //In Inifile we may put the name of object instead eg in MAY-CONTAIN
        //These are either Attr or class objs
        if (strval[0]!='\\') {
            OID_t OID;
            OID.length = 0;
            OID.elements = NULL;
            ATTCACHE *pACtemp=NULL;
            CLASSCACHE *pCCtemp=NULL;
            DWORD i;

            if(pACtemp =
               SCGetAttByName(pTHStls, strlen(strval), (PUCHAR) strval)) {
                // Yep.  Put into ret the \x000000 form of the attribute id.
                AttrTypeToOid(pACtemp->id, &OID);

            }
            else if(pCCtemp =
                    SCGetClassByName(pTHStls, strlen(strval), (PUCHAR)strval)) {
                // Yep.  Put into ret the \x000000 form of the class id
                AttrTypeToOid(pCCtemp->ClassId, &OID);
            }
            else {
                DPRINT1(0, "%s is not a Class or Attribute\n",strval);
                XINVALIDINIFILE();
            }

            ret[0]='\\';
            ret[1]='x';

            for(i=0;i<OID.length;i++) {
                sprintf(&ret[2+2*i],"%02X",((PUCHAR)OID.elements)[i]);
            }
            ret[2+2*i]=0;
        }
        else {
            ret=strval;
        }
        break;

    default:
        ret=strval;
        break;
    }

    return ret;
}


NTSTATUS
CallCoreToAddObj(ADDARG* addarg, BOOL fVerbose)
{
     NTSTATUS NtStatus = STATUS_SUCCESS;
     ULONG err;
     ADDRES *pAddRes;

     TIMECALL(DirAddEntry(addarg, &pAddRes),err);

    //
    // Discard the thread's error state to avoid impacting 
    // other calls to the Dir* routines. Otherwise, the other
    // calls will return this error (return (pTHS->errCode))
    // even if they finished w/o error. Clearing the thread's
    // error state does not affect pAddRes or err.
    //
    if ( err != 0 ) {
        THClearErrors();
    }

     if ( err || fVerbose )
     {
         // Display error messages
         DPRINT2(0,"DirAddEntry(%ws). Error %d\n",
             addarg->pObject->StringName,
             err);
     }

     if (err) {
         DUMP_ERROR_INFO();
     }


     if ( pAddRes )
     {
         NtStatus = DirErrorToNtStatus(err, &pAddRes->CommRes);
     }
     else
     {
         NtStatus = STATUS_NO_MEMORY;
     }

     return NtStatus;
}

GUID
GenGuid()
{
    GUID guid={0,0,0,0};
    if (fGenGuid)
    {
        gNext.Data1++;
        guid=gNext;
    }

    return guid;
}

DWORD
AppendRDNStr(
    IN WCHAR *BaseName,
    IN unsigned ccBaseName,
    IN OUT WCHAR *NewName,
    IN unsigned ccNewName,
    IN WCHAR *Rdn,
    IN unsigned ccRdn,
    IN ATTRTYP AttrType
    )
{
    DSNAME *BaseDsName;
    DSNAME *NewDsName;
    int err;
    unsigned ccNeeded = ccBaseName + ccRdn + 20;

    BaseDsName = (DSNAME*)XCalloc(1, DSNameSizeFromLen(ccBaseName));
    NewDsName =  (DSNAME*)XCalloc(1, DSNameSizeFromLen(ccNeeded));

    BuildDefDSName( BaseDsName,
                    BaseName,
                    NULL,  // no guid
                    FALSE ); // don't generate guid


    err = AppendRDN(BaseDsName,
                    NewDsName,
                    DSNameSizeFromLen(ccNeeded),
                    Rdn,
                    0,
                    AttrType);
    Assert(err == 0);

    if (ccNewName >= NewDsName->NameLen) {
        memcpy(NewName,
               NewDsName->StringName,
               NewDsName->NameLen * sizeof(WCHAR));
        err = 0;
    }
    else {
        err = NewDsName->NameLen;
        Assert(err == 0);
    }

    XFree(BaseDsName);
    XFree(NewDsName);

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ldap\netmon_parser\ldap_ber.c ===
//==========================================================================================================================
//  MODULE: LDAP_BER.c
//
//  Description: Lightweight Directory Access Protocol (LDAP) Parser
//
//  Helpers for BER in the Bloodhound parser for LDAP
//                                                                                                                 
//  Note: info for this parser was gleaned from:
//  rfc 1777, March 1995
//  recommendation x.209 BER for ASN.1
//  recommendation x.208 ASN.1
//
//  Modification History                                                                                           
//                                                                                                                 
//  Arthur Brooking     05/08/96        Created from GRE Parser
//==========================================================================================================================
#include "LDAP.h"

// needed constants
#define	BER_TAG_MASK        0x1f
#define	BER_FORM_MASK       0x20
#define BER_CLASS_MASK      0xc0
#define GetBerTag(x)    (x & BER_TAG_MASK)
#define GetBerForm(x)   (x & BER_FORM_MASK)
#define GetBerClass(x)  (x & BER_CLASS_MASK)

// forms
#define BER_FORM_PRIMATIVE          0x00
#define BER_FORM_CONSTRUCTED        0x20

// classes
#define BER_CLASS_UNIVERSAL         0x00
#define BER_CLASS_APPLICATION       0x40	
#define BER_CLASS_CONTEXT_SPECIFIC  0x80

// Standard BER tags    
#define BER_TAG_INVALID         0x00
#define BER_TAG_BOOLEAN         0x01
#define BER_TAG_INTEGER         0x02
#define	BER_TAG_BITSTRING       0x03
#define BER_TAG_OCTETSTRING     0x04
#define BER_TAG_NULL            0x05
#define	BER_TAG_ENUMERATED      0x0a
#define BER_TAG_SEQUENCE        0x30
#define BER_TAG_SET             0x31

// Length field identifiers
#define BER_LEN_IND_MASK        0x80
#define GetBerLenInd(x)         (x & BER_LEN_IND_MASK)
#define BER_LEN_IMMEDIATE       0x00
#define BER_LEN_INDEFINITE      0x80

#define BER_LEN_MASK            (~BER_LEN_IND_MASK)
#define GetBerLen(x)            (x & BER_LEN_MASK)

// local function prototypes
BOOL BERGetLength( ULPBYTE pInitialPointer, 
                   ULPBYTE *ppContents, 
                   LPDWORD pHeaderLength,
                   LPDWORD pDataLength, 
                   ULPBYTE *ppNext);

//==========================================================================================================================
// BERGetInteger - given a pointer, decode it as an integer; applies to INTEGER, BOOL, and ENUMERATED
//==========================================================================================================================
BOOL _cdecl BERGetInteger( ULPBYTE  pCurrentPointer,
                           ULPBYTE *ppValuePointer,
                           LPDWORD pHeaderLength,
                           LPDWORD pDataLength,
                           ULPBYTE *ppNext)
{
    BOOL ReturnCode = TRUE;

    // ----------
    // IDENTIFIER
    // ----------
    // make sure that it is universal
    if( GetBerClass( *pCurrentPointer ) != BER_CLASS_UNIVERSAL )
    {
        // it is not universal
#ifdef DEBUG
        dprintf("BERGetInteger:Integer identifier not universal\n");
#endif
        ReturnCode = FALSE;
    }

    // make sure it is a primative
    if( GetBerForm(*pCurrentPointer) != BER_FORM_PRIMATIVE )
    {
        // it is not a primative
#ifdef DEBUG
        dprintf("BERGetInteger:Integer identifier not primative\n");
#endif
        ReturnCode = FALSE;
    }

    // make sure that it can be put into a dword 
    if( GetBerTag(*pCurrentPointer) != BER_TAG_BOOLEAN &&
        GetBerTag(*pCurrentPointer) != BER_TAG_INTEGER &&
        GetBerTag(*pCurrentPointer) != BER_TAG_ENUMERATED )
    {
        // it is not a type compatable with a dword
#ifdef DEBUG
        dprintf("BERGetInteger:Integer identifier not INT/BOOL/ENUM (0x%X)\n", 
                 GetBerTag(*pCurrentPointer));
#endif
        ReturnCode = FALSE;
    }

    // we will procede normally even if the identifier did not check out...
    pCurrentPointer++;

    //-------
    // LENGTH
    //-------
    // decode the length and step over it...
    if( BERGetLength( pCurrentPointer, ppValuePointer, pHeaderLength, pDataLength, ppNext)  == FALSE )
    {
        ReturnCode = FALSE;
    }

    // we are now done
    return ReturnCode;
}

//==========================================================================================================================
// BERGetString - given a pointer, decode it as a string
//==========================================================================================================================
BOOL _cdecl BERGetString( ULPBYTE  pCurrentPointer,
                          ULPBYTE *ppValuePointer,
                          LPDWORD pHeaderLength,
                          LPDWORD pDataLength,
                          ULPBYTE *ppNext)
{
    BOOL ReturnCode = TRUE;

    // ----------
    // IDENTIFIER
    // ----------
    // make sure that it is universal
    if( GetBerClass( *pCurrentPointer ) != BER_CLASS_UNIVERSAL )
    {
        // it is not universal
#ifdef DEBUG
        dprintf("BERGetString:String identifier not universal\n");
#endif
        ReturnCode = FALSE;
    }

    // make sure it is a primative
    if( GetBerForm(*pCurrentPointer) != BER_FORM_PRIMATIVE )
    {
        // it is not a primative
#ifdef DEBUG
        dprintf("BERGetString:String identifier not primative\n");
#endif
        ReturnCode = FALSE;
    }

    // make sure that it is a string type
    if( GetBerTag(*pCurrentPointer) != BER_TAG_BITSTRING &&
        GetBerTag(*pCurrentPointer) != BER_TAG_OCTETSTRING )
    {
        // it is not a type compatable with a dword
#ifdef DEBUG
        dprintf("BERGetString:String identifier not string type (0x%X)\n", 
                 GetBerTag(*pCurrentPointer));
#endif
        ReturnCode = FALSE;
    }

    // we will procede normally even if the identifier did not check out...
    pCurrentPointer++;

    //-------
    // LENGTH
    //-------
    // decode the length and step over it...
    if( BERGetLength( pCurrentPointer, ppValuePointer, pHeaderLength, pDataLength, ppNext) == FALSE )
    {
        ReturnCode = FALSE;
    }

    // we are now done
    return ReturnCode;
}

//==========================================================================================================================
// BERGetheader - given a pointer, decode it as a choice header
//==========================================================================================================================
BOOL _cdecl BERGetHeader( ULPBYTE  pCurrentPointer,
                          ULPBYTE  pTag,
                          LPDWORD pHeaderLength,
                          LPDWORD pDataLength,
                          ULPBYTE *ppNext)
{
    BOOL ReturnCode = TRUE;
    BYTE  Dummy;
    LPBYTE pDummy = &Dummy;

    // ----------
    // IDENTIFIER
    // ----------
    // make sure it is a constructed
   /* if( GetBerForm(*pCurrentPointer) != BER_FORM_CONSTRUCTED )
    {
        // it is not a constructed
#ifdef DEBUG
        dprintf("BERGetChoice:Choice identifier not constructed\n");
#endif
        ReturnCode = FALSE;
    } */

    // pull out the tag
    *pTag = GetBerTag(*pCurrentPointer);

    // we will procede normally even if the identifier did not check out...
    pCurrentPointer++;

    //-------
    // LENGTH
    //-------
    // decode the length and step over it...
    // note that the Next pointer being passed back is really a pointer to the
    // header contents
    if( BERGetLength( pCurrentPointer, ppNext, pHeaderLength, pDataLength, &pDummy) == FALSE )
    {
        ReturnCode = FALSE;
    }


    // we are now done
    return ReturnCode;
}

//==========================================================================================================================
// BERGetLength - given a pointer, decode it as the length portion of a BER entry
//==========================================================================================================================
BOOL BERGetLength( ULPBYTE pInitialPointer, 
                   ULPBYTE *ppContents, 
                   LPDWORD pHeaderLength,
                   LPDWORD pDataLength, 
                   ULPBYTE *ppNext)
{
    ULPBYTE pTemp;
    DWORD  ReturnCode = 0;
    DWORD  LengthLength;
    DWORD  i;

    // is this a marker for an indefinite (i.e. has an end marker)
    if( *pInitialPointer == BER_LEN_INDEFINITE )
    {
        // the header length is two (id and length bytes)
        *pHeaderLength = 2;

        // the contents start just after the marker
        *ppContents = pInitialPointer + 1;

        // walk to find 2 null or fault
        pTemp = pInitialPointer;
        try
        {
            do
            {
                // step to the next spot
                pTemp++;

            } while( *(pTemp)   != 0 ||
                     *(pTemp+1) != 0 );
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            // if we faulted, then pCurrent points to the last
            // legal spot
            // we can just fall thru
            // SUNDOWN HACK - cast to DWORD
            *pDataLength = (DWORD)(pTemp - *ppContents);
            *ppNext = pTemp;
            return FALSE;
        }

        // the last thing in this data is the second null byte
        // SUNDOWN HACK - cast to DWORD
        *pDataLength = (DWORD)((pTemp + 1) - *ppContents);

        // the next field will start after the second null
        *ppNext = pTemp+2;
        return TRUE;
    }

    // is this a definite short form (immediate) value
    if( GetBerLenInd( *pInitialPointer ) == BER_LEN_IMMEDIATE )
    {
        // this byte contains the length
        *pHeaderLength = 2;
        *pDataLength = GetBerLen( *pInitialPointer );
        *ppContents = pInitialPointer + 1;
        *ppNext = *ppContents + *pDataLength;
        return TRUE;
    }

    // this must be a definite long form (indirect) value,
    // it indicates how many bytes of length data follow
    LengthLength = GetBerLen( *pInitialPointer );

    // we can now calculate the header length:
    // 1 byte for id, 1 byte for the definite indicator, and x for the actual length
    *pHeaderLength = 1 + 1 + LengthLength;

    // move to the first byte of the true length
    pInitialPointer++;
    
    // the contents start just after the length
    *ppContents = pInitialPointer + LengthLength;

    // construct the value
    *pDataLength = 0;
    for( i = 0; i < LengthLength; i++)
    {
        // have we run over the size of a dword?
        if( i >= sizeof(DWORD) )
        {
            // this had better be a zero
            if( pInitialPointer[i] != 0 )
            {
#ifdef DEBUG
                dprintf("BERGetLength:Length Length too long to fit in a dword(0x%X)\n", 
                         LengthLength - i );
#endif
                *pDataLength = (DWORD)-1;
                *ppNext = pInitialPointer + *pDataLength;
                return FALSE;
            }

            // skip to the next one
            continue;
        }

        // we are still within a DWORD
        *pDataLength += pInitialPointer[i] << ((LengthLength - 1) - i );
    }

    // we escaped, no problems
    // the next field starts just after this one's content
    *ppNext = *ppContents + *pDataLength;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\boot\install.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       install.cxx
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Installs the DIT Fresh or through replication.

    The general idea here is that when InstallBaseNTDS is called, both the
    dblayer and replication client components have been initialized, so that we
    call can call Dir* and DirReplica* functions to fill the database with
    entries from either an existing dsa or we can create entries from fresh.

    Using the Dir* and DirReplica* primitives, InstallBaseNTDS is responsible
    for locally creating three naming contexts: the schema, the configuration
    and the first authoritative domain.  There are three ways this is done
    today: 

    1) create all three based on the definition file schema.ini (use Dir* api)
    2) replicate all three naming contexts (use DirReplica* api)
    3) replicate just the schema and configuration naming contexts and create 
       the domain naming context (use both sets of Api)

    As well InstallBaseNTDS creates an NTDS-DSA in every case for this new dsa
    that is being created.

    A note about error spaces:
    --------------------------

    The only client of InstallBaseNTDS is DoInitialize(), which is ultimately
    called by an NT subsystem, so we need to return somewhat accurate status of
    the install operation via an ntstatus code.   More extensive error reporting
    should be done via the event log and a log file if appropriate.

Author:

    Rajivendra Nath (RajNath) 07-Jul-1996

Revision History:

    Colin Brace  (ColinBr) August 11, 1997.

        Cleanup - first pass before beta 1.

        . make the return value of InstallBaseNTDS, the entry point into this
        module, boot.lib, return a valid NTSTATUS
        . function comments when possible

    BUGBUG : beta2 more cleanup required.
        . get rid of static buffers if possible

--*/
#include <ntdspchX.h>

//
// This header has definitions global to the boot.lib module
//
#include "SchGen.HXX"

extern "C"
{
    #include <ntlsa.h>
    #include <lsarpc.h>
    #include <lsaisrv.h>
    // DB layer based password encryption
    #include <wxlpc.h>
    #include <pek.h>
    #include <dsrolep.h> //for DSROLE_DC_IS_GC flag
    
    #include <drserr.h>
    #include <dns.h>
    #include <sdprop.h>
    #include "dsaapi.h"
    #include "tchar.h"
    #include "drsuapi.h"
    #include "drancrep.h"
    #include "drautil.h"
    #include "dsevent.h"
    #include "mappings.h"
    #include "fileno.h"

    #include <ntdsetup.h>
    #include <lmcons.h>
    #include <lmaccess.h>


    //
    // Set when we're adding new objects as a part of installation to
    // bypass SAM loopbacks.
    extern BOOL gfDoSamChecks;

    // dsatools.h is too complicated to include
    VOID
    SetInstallStatusMessage (
        IN  DWORD  MessageId,
        IN  WCHAR *Insert1, OPTIONAL
        IN  WCHAR *Insert2, OPTIONAL
        IN  WCHAR *Insert3, OPTIONAL
        IN  WCHAR *Insert4, OPTIONAL
        IN  WCHAR *Insert5  OPTIONAL
        );

    VOID
    SetInstallErrorMessage (
        IN  DWORD  WinError,
        IN  DWORD  MessageId,
        IN  WCHAR *Insert1, OPTIONAL
        IN  WCHAR *Insert2, OPTIONAL
        IN  WCHAR *Insert3, OPTIONAL
        IN  WCHAR *Insert4  OPTIONAL
        );

    extern int ComputeCacheClassTransitiveClosure(BOOL fForce);
    extern int SCUpdateSchema();

#define SET_INSTALL_ERROR_MESSAGE0( err, msgid ) \
    SetInstallErrorMessage( (err), (msgid), NULL, NULL, NULL, NULL )
    
#define SET_INSTALL_ERROR_MESSAGE1( err, msgid, a ) \
    SetInstallErrorMessage( (err), (msgid), (a), NULL, NULL, NULL )

#define SET_INSTALL_ERROR_MESSAGE2( err, msgid, a, b ) \
    SetInstallErrorMessage( (err), (msgid), (a), (b), NULL, NULL )
    

    DWORD
        DBInitialSetup(
                WCHAR *pDN
                );

    extern DSA_CALLBACK_CANCEL_TYPE gpfnInstallCancelOk;

    extern void
    RebuildAnchor(void * pv,
                  void ** ppvNext,
                  DWORD * pcSecsUntilNextIteration );


    extern SCHEMAPTR *CurrSchemaPtr;

    ULONG
    DrspGetCredentials(
        OUT PSEC_WINNT_AUTH_IDENTITY_W *ppCred
        );

    VOID
    DrspFreeCredentials(
        PSEC_WINNT_AUTH_IDENTITY_W pCred
        );

}

BOOL gInstallHasDoneSchemaMove = FALSE;

//
// Prepare this file for the ds DPRINT subsystem use
//
#define DEBSUB "INSTALL:"

#define FILENO FILENO_INSTALL

//
// found in addobj.cxx
//
extern NTSTATUS
AddOneObjectEx(NODE* NewNode,
               WCHAR* DN,
               UUID * pObjectGuid,
               WCHAR* DN2,
               BOOL fVerbose = TRUE );

//
// Exported APIS
//

extern "C"
{
    BOOL     isDitFromGC(IN  PDS_INSTALL_PARAM   InstallInParams,
                         OUT PDS_INSTALL_RESULT  InstallOutParams);
    DWORD    SetDittoGC();
    NTSTATUS InstallBaseNTDS(IN  PDS_INSTALL_PARAM   InstallInParams,
                             OUT PDS_INSTALL_RESULT  InstallOutParams);
}

struct
{
    
    PTCHAR NTDSIniFile;

    PWCHAR RootDomainDNName;
    
    PWCHAR SrcRootDomainSrv;

    PWCHAR ConfigNCDNName;

    PWCHAR SrcConfigNCSrv;

    PWCHAR DsaDNName;

    PWCHAR SchemaDNName;

    PWCHAR SourceDsaDnsDomainName;

    PTCHAR IniDefaultConfigNCDit;
    
    PTCHAR IniDefaultRootDomainDit;
    
    PTCHAR IniDefaultSchemaNCDit;

    PTCHAR IniDefaultLocalConnection;

    PTCHAR IniDefaultRemoteConnection;
    
    PWCHAR LocalConnectionDNName;
    
    PWCHAR RemoteConnectionDNName;

    PTCHAR IniDefaultNewDomainCrossRef;
    
    PWCHAR NewDomainCrossRefDNName;

    PTCHAR IniDefaultMachine;

}   gNames = {0};

//
// Forward definitions
//
NTSTATUS
DirReplicaErrorToNtStatus(
    IN ULONG DirReplicaError
    );

NTSTATUS
CreateNtdsDsaObject
(
    WCHAR* DsaDNName,
    WCHAR* RootConfigNCDNName,
    WCHAR* ConfigNCDNName,
    WCHAR* SchemaContainer
);


DWORD
ConvertMachineAccount(
    IN  PDS_INSTALL_PARAM   InstallInParams,
    OUT PDS_INSTALL_RESULT  InstallOutParams
    );

VOID
ZapTempRegKeys(
    VOID
    );

NTSTATUS
CreateSchemaNCObject(WCHAR* SchemaNCDNName);

NTSTATUS
CreateDefaultSchemaNCDIT(WCHAR* SchemaNCDNName);

NTSTATUS
CreateConfigNCObject(WCHAR* ConfigNCDNName);

NTSTATUS
CreateDefaultConfigNCDIT(WCHAR* ConfigNCDNName);

NTSTATUS
CreateRootDomainObject(WCHAR* RootConfigNCDNName,
                       GUID *pGuid,
                       IN OUT CROSS_REF *pCR);

NTSTATUS
CreateDefaultRootDomainDIT(WCHAR* RootConfigNCDNName);

DWORD
CreateChildDomainCrossRef(
    OUT PDS_INSTALL_RESULT  InstallOutParams,
    IN GUID * pGuid,
    IN CROSS_REF *pCR,
    OUT GUID* ntdsaGuid
    );

NTSTATUS
CreateConnectionObjects();

DWORD 
CheckForDuplicateDomainSid();


DWORD
GetDatabaseFacts(
    LPCWSTR RestorePath,
    PULONG State
    );

NTSTATUS
CreateDummyNtdsDsaObject();

DWORD
DeleteDummyNtdsDsaObject();

NTSTATUS
UpdateReplicationEpochAndHiddenDSA(
    IN DSNAME *pDSADN,
    IN DWORD  ReplicationEpoch,
    IN BOOL   fUpdateHiddenTable
    );

DWORD
CreateRemoteNtdsDsaObject(
    OUT GUID* NtdsDsaGuid OPTIONAL
    );

DWORD
ForceChangeToDomainCrossRef(
    IN DSNAME* pdnCrossRefObj,
    IN WCHAR*  wszDomainDn,
    IN GUID*   pDomainGuid
    );

NTSTATUS
InitializeNTDSSetup();

NTSTATUS 
HandleKeys(
    PVOID BootKey OPTIONAL,
    DWORD cbBootKey OPTIONAL
    );
    
NTSTATUS
CheckReplicationEpoch(
    IN DWORD ReplicationEpoch
    );

NTSTATUS
CheckTombstone();

NTSTATUS
ClearNonReplicatedAttributes();

VOID
InstallFreeGlobals( VOID );


NTSTATUS
InitializeNTDSSetup()
{
    THSTATE *pTHS = pTHStls;
    ULONG err=0;
    char fp[MAX_PATH];
    DWORD dwType;
    HKEY  hk;

    struct
    {
        VOID*  Key;
        VOID** ValueBuffer;
        ULONG  Size;
        BOOLEAN fUnicode;

    } ActionArray [] =
    {
        { NTDSINIFILE,                        (VOID**)&gNames.NTDSIniFile,                   0, FALSE  },
        { INIDEFAULTROOTDOMAINDIT,            (VOID**)&gNames.IniDefaultRootDomainDit,       0, FALSE  },
        { MAKE_WIDE(ROOTDOMAINDNNAME),        (VOID**)&gNames.RootDomainDNName,              0, TRUE   },
        { INIDEFAULTCONFIGNCDIT,              (VOID**)&gNames.IniDefaultConfigNCDit,         0, FALSE  },
        { INIDEFAULTSCHEMANCDIT,              (VOID**)&gNames.IniDefaultSchemaNCDit,         0, FALSE  },
        { MAKE_WIDE(CONFIGNCDNNAME),          (VOID**)&gNames.ConfigNCDNName,                0, TRUE   },
        { MAKE_WIDE(SRCROOTDOMAINSRV),        (VOID**)&gNames.SrcRootDomainSrv,              0, TRUE   },
        { MAKE_WIDE(SRCCONFIGNCSRV),          (VOID**)&gNames.SrcConfigNCSrv,                0, TRUE   },
        { MAKE_WIDE(MACHINEDNNAME),           (VOID**)&gNames.DsaDNName,                     0, TRUE   },
        { INIDEFAULTLOCALCONNECTION,          (VOID**)&gNames.IniDefaultLocalConnection,     0, FALSE  },
        { INIDEFAULTREMOTECONNECTION,         (VOID**)&gNames.IniDefaultRemoteConnection,    0, FALSE  },
        { MAKE_WIDE(LOCALCONNECTIONDNNAME),   (VOID**)&gNames.LocalConnectionDNName,         0, TRUE   },
        { MAKE_WIDE(REMOTECONNECTIONDNNAME),  (VOID**)&gNames.RemoteConnectionDNName,        0, TRUE   },
        { INIDEFAULTNEWDOMAINCROSSREF,        (VOID**)&gNames.IniDefaultNewDomainCrossRef,   0, FALSE  },
        { MAKE_WIDE(NEWDOMAINCROSSREFDNNAME), (VOID**)&gNames.NewDomainCrossRefDNName,       0, TRUE   },
        { MAKE_WIDE(SCHEMADNNAME),            (VOID**)&gNames.SchemaDNName,                  0, TRUE   },
        { INIDEFAULTMACHINE,                  (VOID**)&gNames.IniDefaultMachine,             0, FALSE  },
        { MAKE_WIDE(SOURCEDSADNSDOMAINNAME),  (VOID**)&gNames.SourceDsaDnsDomainName,        0, TRUE   }
    };

    ULONG Index, Count = sizeof(ActionArray) / sizeof(ActionArray[0]);
    
    if ((err = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hk))) {
        DPRINT1(0, "RegOpenKey failed with %d line %d\n", err);
        return err;
    }

    for ( Index = 0; Index < Count; Index++ )
    {

        if ( ActionArray[Index].fUnicode )
        {
            err = RegQueryValueExW(hk, 
                                   (WCHAR *)ActionArray[Index].Key,
                                   NULL, 
                                   &dwType,
                                   (LPBYTE) NULL,
                                   &ActionArray[Index].Size);
            if (!err) {
                *ActionArray[Index].ValueBuffer = XCalloc(1, ActionArray[Index].Size);
                err = RegQueryValueExW(hk,
                                       (WCHAR *)ActionArray[Index].Key,
                                       NULL,
                                       &dwType,
                                       (LPBYTE) *ActionArray[Index].ValueBuffer,
                                       &ActionArray[Index].Size);
            } else {
                DPRINT2(0, "RegQueryValueExW failed with err = %d for key %S\n", err, ActionArray[Index].Key);
            }

        }
        else
        {
            err = RegQueryValueEx(hk, 
                                  (CHAR *)ActionArray[Index].Key,
                                  NULL, 
                                  &dwType,
                                  (LPBYTE) NULL,
                                  &ActionArray[Index].Size);
            if (!err) {
                *ActionArray[Index].ValueBuffer = XCalloc(1, ActionArray[Index].Size);
                err = RegQueryValueEx(hk,
                                      (CHAR *)ActionArray[Index].Key,
                                      NULL,
                                      &dwType,
                                      (LPBYTE) *ActionArray[Index].ValueBuffer,
                                      &ActionArray[Index].Size);
            } else {
                DPRINT2(0, "RegQueryValueEx failed with err = %d for key %s\n", err, ActionArray[Index].Key);
            }
        }


        if ( err != ERROR_SUCCESS && err != ERROR_FILE_NOT_FOUND )
        {
            RegCloseKey(hk);
            DPRINT(0, "Error reading registry values.  returning early\n");
            return STATUS_UNSUCCESSFUL;
        }
    }

    RegCloseKey(hk);
    
    if (!SetIniGlobalInfo(gNames.NTDSIniFile))
    {
        unsigned long err = GetLastError();
        DPRINT2(0,"NTDS:%ws:Invalid Inifile, error %d\n",fp, err);
        return STATUS_UNSUCCESSFUL;
    }
    
    //
    // We no longer need gNames.NTDSIniFile
    //
    XFree(gNames.NTDSIniFile); 
    gNames.NTDSIniFile = NULL;

    // Set Phase to indicate install

    DsaSetIsInstalling();


    // Set the invocation id for this setup in the Core so that the objects
    // are properly stamped;
    // FALSE => There is no old invocation ID to be retired.

    //In the install From media case we had our InvocationID create
    //by HandleRestore()
    if (!DsaIsInstallingFromMedia()) {
        InitInvocationId(pTHS, FALSE, NULL);
    }

    return STATUS_SUCCESS;

}

NTSTATUS
CreateSchemaNCObject(WCHAR* SchemaNCDNName)
{
    NTSTATUS NtStatus;
    ULONG len;
    ULONG size;
    DSNAME *pSchemaDN;

    NODE Node(gNames.IniDefaultSchemaNCDit);

    if ( !Node.Initialize() )
    {
        // Go right to the debugger for this one
        KdPrint(("NTDS: schema.ini file is corrupt\n"));
        return STATUS_UNSUCCESSFUL;
    }

    NtStatus = AddOneObjectEx(&Node,SchemaNCDNName,NULL,NULL);

    if (NtStatus) {
            return NtStatus;
    }

    len = wcslen(SchemaNCDNName);
    size = DSNameSizeFromLen(len);
    pSchemaDN = (PDSNAME) XCalloc( 1, size );

    BuildDefDSName( pSchemaDN,
                    SchemaNCDNName,
                    NULL,
                    FALSE );  // don't generate guid

    RegisterActiveContainer(pSchemaDN,
                            ACTIVE_CONTAINER_SCHEMA);


    XFree(pSchemaDN);
    return NtStatus;

}

//-----------------------------------------------------------------------
//
// Function Name:            CreateConfigNCObject
//
// Routine Description:
//
//    Creates the Config NC Object
//
// Author: RajNath
//
// Arguments:
//
//
//
// Return Value:
//
//    ULONG                Zero On Succeess
//
//-----------------------------------------------------------------------

NTSTATUS
CreateConfigNCObject(WCHAR* ConfigNCDNName)
{
    NTSTATUS NtStatus;


    NODE Node(gNames.IniDefaultConfigNCDit);

    if ( !Node.Initialize() )
    {
        // Go right to the debugger for this one
        KdPrint(("NTDS: schema.ini file is corrupt\n"));
        return STATUS_UNSUCCESSFUL;
    }

    NtStatus = AddOneObjectEx(&Node,ConfigNCDNName,NULL,NULL);

    return NtStatus;
}



//-----------------------------------------------------------------------
//
// Function Name:            CreateRootDomainObject
//
// Routine Description:
//
//    Creates The root domain object
//
// Author: RajNath
//
// Arguments:
//
//    TCHAR* RootDomainDNName             Name of the object
//
// Return Value:
//
//    ULONG                Zero On Succeess
//
//-----------------------------------------------------------------------

typedef struct ClassMapping {
    ATTRTYP     type;
    char        *objectClass;
} ClassMapping;

ClassMapping rDomainMappings[] = {
    { ATT_LOCALITY_NAME,            "domainLocality" },
    { ATT_ORGANIZATION_NAME,        "domainOrganization" },
    { ATT_ORGANIZATIONAL_UNIT_NAME, "domainOrganizationalUnit" },
    { ATT_COUNTRY_NAME,             "domainCountry" },
    { ATT_DOMAIN_COMPONENT,         "domainDNS" }
};

DWORD cDomainMappings = sizeof(rDomainMappings) / sizeof(rDomainMappings[0]);

NTSTATUS
CreateRootDomainObject(WCHAR* RootDomainDNName,
                       GUID *pDomainGuid,
                       CROSS_REF *pCR
                       )
{
    NTSTATUS    NtStatus;
    ULONG       err=0;
    WCHAR       *tag;
    WCHAR       *equalSign;
    ATTRTYP     type;
    CHAR        *objectClass = NULL;   
    unsigned    cChar;
    WCHAR       *wTag;

    DSNAME*     domainobj = NULL;
    MODIFYARG   modarg;
    MODIFYRES   *modres = NULL;
    ATTRVAL     AttrVal;
    PPOLICY_DNS_DOMAIN_INFO  DnsDomainInfo = NULL;
    ULONG       Size, Length;

    NODE Node(gNames.IniDefaultRootDomainDit);


    if ( !Node.Initialize() )
    {
        return STATUS_UNSUCCESSFUL;
    }

    // Schema.ini sets DEFAULTROOTDOMAIN's Object-Class to
    // domainDNS.  This is only correct for a DC= type
    // root domain.  So assign the right Object-Class
    // based on the first tag in the DN.

    if ( (NULL == (equalSign = wcschr(RootDomainDNName, '='))) ||
         (RootDomainDNName == equalSign) )
    {
        return(STATUS_OBJECT_NAME_INVALID);
    }

    // Strip leading/trailing spaces if there are any.
    tag = RootDomainDNName;
    while ( ' ' == *tag ) tag++;
    equalSign--;
    while ( ' ' == *equalSign ) equalSign--;
    cChar = (UINT) (equalSign - tag + 1);

    // Map tag to ATTRTYPE.
    wTag = tag;
    type = KeyToAttrType(pTHStls, wTag, cChar);

    // Map ATTRTYPE to Object-Class.
    for ( DWORD i = 0; i < cDomainMappings; i++ )
    {
        if ( type == rDomainMappings[i].type )
        {
            objectClass = rDomainMappings[i].objectClass;
            break;
        }
    }

    // Bail if we couldn't map it.
    if ( i == cDomainMappings )
        return(STATUS_UNSUCCESSFUL);

    //
    // The GUID for the NC head must match the GUID for the Nc-Name on
    // the cross ref. There are 3 possiblities
    // 
    //   1. This is the creation of first domain in the enterprise. In this
    //      the cross ref is not created ( routine is simply called with a NULL
    //      for the cross ref parameter. ). We invent a new GUID or use the
    //      the user guid above.
    //
    //   2. This is the creation of a child. ie the cross ref has been created on
    //      a remote machine, and the NC name property points to a phantom with a 
    //      guid. In this case use the guid from the cross ref
    //
    //   3. This is a creation of a new tree. ie cross ref has been created on a 
    //      remote machine, but does not as yet have a guid. In this case create
    //      a new guid
    //

    
    if (pCR && !fNullUuid(&(pCR->pNC->Guid))) {
        // This is case 2 above,use the guid in the cross ref
        *pDomainGuid = pCR->pNC->Guid;
    }
    else {
        // Case 3. or 1. above
        DsUuidCreate(pDomainGuid);

        if (pCR)
        {
            // case 3. above, set the GUID in the cross ref
            memcpy(&pCR->pNC->Guid,pDomainGuid,sizeof(GUID));
        }
        
    }

    Node.ReplaceKeyValuePair("objectClass", objectClass);
    NtStatus = AddOneObjectEx(&Node, RootDomainDNName, pDomainGuid, NULL ); 

    //
    // Whack the sid on the object so the meta data will
    // be bumped.  This is so the sid will properly replicate off the machine
    //
    memset( &modarg, 0, sizeof(modarg) );
    memset( &AttrVal, 0, sizeof(AttrVal) );

    NtStatus = LsaIQueryInformationPolicyTrusted(PolicyDnsDomainInformation,
                    (PLSAPR_POLICY_INFORMATION*) &DnsDomainInfo );

    if ( !NT_SUCCESS( NtStatus ) ) {
        return NtStatus;
    }

    Length = wcslen( RootDomainDNName );
    Size = DSNameSizeFromLen( Length );
    domainobj = (DSNAME*) XCalloc( 1, Size );
    domainobj->structLen = Size;
    domainobj->NameLen = Length;
    wcscpy( domainobj->StringName, RootDomainDNName );

    modarg.pObject = domainobj;
    modarg.count = 1;
    modarg.FirstMod.pNextMod = NULL;
    modarg.FirstMod.choice = AT_CHOICE_ADD_ATT;
    modarg.FirstMod.AttrInf.attrTyp = ATT_OBJECT_SID;
    modarg.FirstMod.AttrInf.AttrVal.valCount = 1;
    modarg.FirstMod.AttrInf.AttrVal.pAVal = &AttrVal;
    AttrVal.valLen  = RtlLengthSid( DnsDomainInfo->Sid );
    AttrVal.pVal = (BYTE*) DnsDomainInfo->Sid;
    InitCommarg(&modarg.CommArg);

    err = DirModifyEntry( &modarg, &modres );

    if ( err )
    {
        if ( modres )
        {
            NtStatus = DirErrorToNtStatus( err, &modres->CommRes );
        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
        }
    }

    if ( DnsDomainInfo )
    {
        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION) DnsDomainInfo );
    }

    XFree(domainobj);
    
    return NtStatus;
}



//-----------------------------------------------------------------------
 //
// Function Name:            CreateNtdsDsaObject
//
// Routine Description:
//
//    Creates The NTDS-DSA Object
//
// Author: RajNath
//
// Arguments:
//
//    DsaDNName,                   Name of the Machine object
//    RootDomainDNName             Name of the Root Domain
//    ConfigNCDNName               Nameof the Config NC
//    SchemaContainer              Location of the schema container
//
//
//
// Return Value:
//
//    int              Zero On Success
//
//-----------------------------------------------------------------------
NTSTATUS
CreateNtdsDsaObject
(
    WCHAR* DsaDNName,
    WCHAR* RootDomainDNName,
    WCHAR* ConfigNCDNName,
    WCHAR* SchemaContainer
)
{
    // Historically, this routine created strictly an MSFT-DSA object.
    // For beta 2, we are moving to a full server-centric Sites container
    // model and thus have one generic Server container under which live
    // instances of classes inheriting from Application-Settings.  In the
    // DS case, NTDS-DSA inherits from Application-Settings, and setup
    // should insure that each NTDS-DSA instance is called "NTDS Settings".

    THSTATE *   pTHS = pTHStls;
    NTSTATUS    NtStatus;
    ULONG       err;
    NODE        NodeServer("DEFAULTANYSERVER");
    NODE        NodeServers("Servers");
    NODE        NodeDSA(gNames.IniDefaultMachine);
    WCHAR        *buf1 = NULL, *buf2 = NULL;
    DSNAME      *pDSName1, *pDSName2;
    DWORD       cBytes;
    PDSNAME     pdsa=NULL;


    // First see if we need to create the Server object.  Note that it
    // may already exist if this was a non-DC which had DS-enabled services
    // that needed to be registered in the DS, thus the Server object
    // was created as well.  By definition, the Server is the immediate
    // parent of the NTDS-DSA object, thus we can derive its name by
    // trimming the NTDS-DSA object name by 1.

    // Use do/while so we can break instead of goto.

    do
    {
        if ( !NodeServers.Initialize() )
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        _try
        {
            //
            // Creates the "Servers" object if it doesn't exist
            //
            cBytes = (DWORD)DSNameSizeFromLen(wcslen(DsaDNName));
            buf1 = (WCHAR *) XCalloc(1,cBytes);
            buf2 = (WCHAR *) XCalloc(1,cBytes);
            pDSName1 = (DSNAME *) buf1;
            pDSName2 = (DSNAME *) buf2;
            pDSName1->structLen = cBytes;
            pDSName1->NameLen = wcslen(DsaDNName);
            wcscpy( pDSName1->StringName, DsaDNName );

            TrimDSNameBy(pDSName1, 2, pDSName2);

            NtStatus = AddOneObjectEx(&NodeServers,  pDSName2->StringName,  NULL,  NULL);

            //
            // Ignore the ignore the error; if there was a real problem it
            // will be cause when we try to create the ntdsa object
            //
            XFree(buf1); buf1 = NULL;
            XFree(buf2); buf2 = NULL;

            NtStatus = STATUS_SUCCESS;

        }
        _except(err=GetExceptionCode(),EXCEPTION_EXECUTE_HANDLER)
        {
            if (INVALIDINIFILE == err) {
                NtStatus = STATUS_UNSUCCESSFUL;
            } else if (err == OUTOFMEMORY) {
                NtStatus = STATUS_NO_MEMORY;
            } else {
                // The error space of this error is unknown
                NtStatus = STATUS_UNSUCCESSFUL;
            }

            if (buf1) {
                XFree(buf1); buf1 = NULL;
            }
            if (buf2) {                
                XFree(buf2); buf2 = NULL;
            }
            break;
        }

        if ( !NodeServer.Initialize() )
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        _try
        {



            //
            // This creates the server object, if it doesn't exist
            //
            cBytes = (DWORD)DSNameSizeFromLen(wcslen(DsaDNName));
            buf1 = (WCHAR *) XCalloc(1,cBytes);
            buf2 = (WCHAR *) XCalloc(1,cBytes);
            pDSName1 = (DSNAME *) buf1;
            pDSName2 = (DSNAME *) buf2;
            pDSName1->structLen = cBytes;
            pDSName1->NameLen = wcslen(DsaDNName);
            wcscpy( pDSName1->StringName, DsaDNName );

            TrimDSNameBy(pDSName1, 1, pDSName2);

            NtStatus = AddOneObjectEx(&NodeServer,  pDSName2->StringName,  NULL,  NULL);

            //
            // Ignore the ignore the error; if there was a real problem it
            // will be cause when we try to create the ntdsa object
            //
            XFree(buf1); buf1 = NULL;
            XFree(buf2); buf2 = NULL;
            NtStatus = STATUS_SUCCESS;

        }
        _except(err=GetExceptionCode(),EXCEPTION_EXECUTE_HANDLER)
        {
            if (INVALIDINIFILE == err) {
                NtStatus = STATUS_UNSUCCESSFUL;
            } else if (err == OUTOFMEMORY) {
                NtStatus = STATUS_NO_MEMORY;
            } else {
                // The error space of this error is unknown
                NtStatus = STATUS_UNSUCCESSFUL;
            }

            if (buf1) {
                XFree(buf1); buf1 = NULL;
            }
            if (buf2) {                
                XFree(buf2); buf2 = NULL;
            }
            break;
        }

        //
        // Create the NTDS-DSA object.
        //

        if ( !NodeDSA.Initialize() )
        {
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        _try
        {
            NtStatus = AddOneObjectEx(&NodeDSA,
                                      DsaDNName,
                                      &pTHS->InvocationID,
                                      NULL);

            if ( !NT_SUCCESS(NtStatus) )
            {
                break;
            }
        }
        _except(err=GetExceptionCode(),EXCEPTION_EXECUTE_HANDLER)
        {
            if (INVALIDINIFILE == err) {
                NtStatus = STATUS_UNSUCCESSFUL;
            } else if (err == OUTOFMEMORY) {
                NtStatus = STATUS_NO_MEMORY;
            } else {
                // The error space of this error is unknown
                NtStatus = STATUS_UNSUCCESSFUL;
            }

            break;
        }

        //
        // Set The State On the Hidden Record
        //

        cBytes = (DWORD)DSNameSizeFromLen(wcslen(DsaDNName));
        pdsa = (PDSNAME) XCalloc( 1, cBytes );
        BuildDefDSName(pdsa, DsaDNName, &pTHS->InvocationID);

        err=DBReplaceHiddenDSA(pdsa);
        ASSERT(err == 0);
        if (err) {
            NtStatus = STATUS_UNSUCCESSFUL;
            XFree(pdsa); pdsa = NULL;
            break;
        }
        XFree(pdsa); pdsa = NULL;
    }
    while ( FALSE );

    if ( !NT_SUCCESS(NtStatus) )
    {
        DPRINT1(0,"NTDS:AddOneObjectEx(MACHINEOBJECT). Error 0x%x\n",NtStatus);
    }

    return NtStatus;
}

NTSTATUS
CreateConnectionObjects()
//
// Create NTDS-Connection objects representing bi-directional
// replication between the remote server and the local server.
//
{
    NTSTATUS NtStatus;

    ULONG   err = 0;
    NODE    nodeLocalConnection(  gNames.IniDefaultLocalConnection  );
    NODE    nodeRemoteConnection( gNames.IniDefaultRemoteConnection );

    if (    !nodeLocalConnection.Initialize()
         || !nodeRemoteConnection.Initialize()
       )
    {
        NtStatus = STATUS_UNSUCCESSFUL;
    }
    else
    {
        _try
        {
            NtStatus = AddOneObjectEx( &nodeLocalConnection, gNames.LocalConnectionDNName, NULL, NULL );

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = AddOneObjectEx( &nodeRemoteConnection, gNames.RemoteConnectionDNName, NULL, NULL );
            }
        }
        _except( err=GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER )
        {

            if (INVALIDINIFILE == err) {
                NtStatus = STATUS_UNSUCCESSFUL;
            } else if (err == OUTOFMEMORY) {
                NtStatus = STATUS_NO_MEMORY;
            } else {
                NtStatus = STATUS_UNSUCCESSFUL;
            }

            DPRINT1( 0, "Exception 0x%x adding connection objects.\n", err );
        }
    }

    return NtStatus;
}

NTSTATUS
CreateDefaultSchemaNCDIT(WCHAR* SchemaNCDNName)
{
    NTSTATUS NtStatus;
    NODE*  Node=NULL;
    ULONG  err=0;
    TCHAR  entdit[MAX_PATH];
    TCHAR  schemafile[MAX_PATH];

    _try
    {
        _try
        {
            Node = new NODE(gNames.IniDefaultSchemaNCDit);

            if (Node==NULL || !(Node->Initialize()))
            {
                return STATUS_UNSUCCESSFUL;
            }

            NtStatus = WalkTree(Node,SchemaNCDNName,NULL,FALSE);

        }
        _except(err=GetExceptionCode(),EXCEPTION_EXECUTE_HANDLER)
        {

            if (INVALIDINIFILE == err) {
                NtStatus = STATUS_UNSUCCESSFUL;
            } else if (err == OUTOFMEMORY) {
                NtStatus = STATUS_NO_MEMORY;
            } else {
                NtStatus = STATUS_UNSUCCESSFUL;
            }
            DPRINT1(0,"NTDS:WalkTree Generated Exception %x\n",err);
        }

    }
    _finally
    {
        if (Node!=NULL)
        {
            delete Node;
        }
    }

    return NtStatus;

}

//-----------------------------------------------------------------------
//
// Function Name:            CreateDefaultRootDomainDIT
//
// Routine Description:
//
//    Creates The Root Domain Tree on a fresh install
//
// Author: RajNath
//
// Arguments:
//
//    TCHAR* RootDomainName,               Name of the Root Domain
//
// Return Value:
//
//    ULONG                Zero On Succeess
//
//-----------------------------------------------------------------------

NTSTATUS
CreateDefaultRootDomainDIT(WCHAR* RootDomainDNName)
{
    NTSTATUS NtStatus;

    NODE*  Node=NULL;
    ULONG  err=0;
    TCHAR  entdit[MAX_PATH];
    TCHAR  schemafile[MAX_PATH];

    _try
    {

        _try
        {
            Node = new NODE(gNames.IniDefaultRootDomainDit);

            if (Node==NULL || !(Node->Initialize()))
            {
                return STATUS_UNSUCCESSFUL;
            }

            NtStatus = WalkTree(Node,RootDomainDNName,NULL);

        }
        _except(err=GetExceptionCode(),EXCEPTION_EXECUTE_HANDLER)
        {

            if (INVALIDINIFILE == err) {
                NtStatus = STATUS_UNSUCCESSFUL;
            } else if (err == OUTOFMEMORY) {
                NtStatus = STATUS_NO_MEMORY;
            } else {
                NtStatus = STATUS_UNSUCCESSFUL;
            }
            DPRINT1(0,"NTDS:WalkTree Generated Exception %x\n",err);
        }

    }
    _finally
    {
        if (Node!=NULL)
        {
            delete Node;
        }
    }

    return NtStatus;

}

NTSTATUS
CreateDefaultConfigNCDIT(WCHAR* ConfigNCDNName)
{
    NTSTATUS NtStatus;
    NODE*  Node=NULL;
    ULONG  err=0;
    TCHAR  entdit[MAX_PATH];
    TCHAR  schemafile[MAX_PATH];

    _try
    {

        _try
        {
            Node = new NODE(gNames.IniDefaultConfigNCDit);

            if (Node==NULL || !(Node->Initialize()))
            {
                return STATUS_UNSUCCESSFUL;
            }

            NtStatus = WalkTree(Node,ConfigNCDNName,NULL);

        }
        _except((err=GetExceptionCode(),EXCEPTION_EXECUTE_HANDLER))
        {

            if (INVALIDINIFILE == err) {
                NtStatus = STATUS_UNSUCCESSFUL;
            } else if (err == OUTOFMEMORY) {
                NtStatus = STATUS_NO_MEMORY;
            } else {
                NtStatus = STATUS_UNSUCCESSFUL;
            }
            DPRINT1(0,"NTDS:WalkTree Generated Exception %x\n",err);
        }

    }
    _finally
    {
        if (Node!=NULL)
        {
            delete Node;
        }
    }

    return NtStatus;
}

extern void DestroyInstallHeap(void);
extern void CleanupIniCache();

// Following two routines required because THSave/THRestore are no-ops during
// install because SAM is in registry mode at that time.  So define our own
// variants for use during install.

PVOID
InstallTHSave( void )
{
    PVOID pv = TlsGetValue(dwTSindex);
    TlsSetValue(dwTSindex, 0);
#ifndef MACROTHSTATE
    pTHStls = NULL;
#endif
    return(pv);
}

VOID
InstallTHRestore(
    PVOID pv)
{
    Assert(NULL == pTHStls);
    TlsSetValue(dwTSindex, pv);
#ifndef MACROTHSTATE
    pTHStls = (THSTATE *) pv;
#endif
}


DWORD
GetSourceDsaGuidBasedDnsName(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  LPWSTR      SrcRootDomainSrv,
    OUT GUID *      puuidSourceDsaObjGuid,
    OUT LPWSTR *    ppszSourceDsaGuidBasedDnsName
    )
/*++

Routine Description:

    Retrieve the repsFrom for the given NC and derive the GUID-based DNS name
    of the source DSA.

Parameters:

    pTHS (IN)
    
    pNC (IN) - NC from which to read repsFrom.
    
    pszSourceDsaDnsDomainName (IN) - The Dns name of source DSA, used to find the
        correct Guid info.
    
    puuidSourceDsaObjGuid (OUT) - On successful return, holds the objectGuid of
        the source's ntdsDsa object.
        
    ppszSourceDsaGuidBasedDnsName (OUT) - On successful return, holds the GUID-
        based DNS name of the source DSA. 

Return Values:

    0 or Win32 error.

--*/
{

    ULONG           err;
    DSNAME          DN = {0};
    GUID            ServerGuid;

    ZeroMemory((PVOID)&ServerGuid,sizeof(GUID));
    
    err = GetConfigParam(SOURCEDSAOBJECTGUID,
                         (PVOID)&ServerGuid,
                         sizeof(GUID));
    if(ERROR_SUCCESS != err) {
        DPRINT1(0, "Failed get %ws from registry.\n",TEXT(SOURCEDSAOBJECTGUID));
        goto cleanup;
    }

    DN.structLen = DSNameSizeFromLen(0);
    DN.Guid = ServerGuid;

    *ppszSourceDsaGuidBasedDnsName = DSaddrFromName(pTHS, &DN);
    if (NULL == *ppszSourceDsaGuidBasedDnsName) {
        DPRINT(0, "Failed to derive source DSA's GUID-based DNS name!\n");
        err = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    *puuidSourceDsaObjGuid = ServerGuid;

    cleanup:
    return err;
}


NTSTATUS
InstallBaseNTDS(IN  PDS_INSTALL_PARAM   InstallInParams,
                OUT PDS_INSTALL_RESULT  InstallOutParams)
/*++

Routine Description:

    This routine is the workhorse for the directory service installation. It is
    called in two process contexts:

    1) from within the lsass.exe as part of a running system.  Under this
    scenario the dit is assumed to be in such a state so that a new schema can
    be added and domain objects can be added

    2) from mkdit.exe.

Parameters:

    None.

Return Values:

    STATUS_SUCCESS; appropriate nt status mapped from Dir* or DirReplica* call

--*/
{

    NTSTATUS NtStatus;
    ULONG    DirError, DirReplicaErr, WinError;
    ULONG    err=0;
    VOID     *pOutBuf = NULL;
    DWORD    errHeap;
    LPWSTR   pszGuidBasedDnsName = NULL;
    DSNAME   *pDsa = NULL;
    DSNAME   *pNC = NULL; 
    ULONG    size;

    // The call chain of DirReplicaAdd==>DoOpDRS==>DispatchPao==>InitDraThread
    // calls InitTHSTATE unilaterally - even if you have a thread state active.
    // This is the correct design for the DRA subsystem - InstallBaseNTDS is
    // the anomaly in that it may have a thread state when it makes the call.
    // In order to avoid duplicate InitTHSTATE on a single thread, we will
    // save the thread state prior to calling DirReplicaAdd, let DirReplicaAdd
    // create its own thread state, nuke that thread state on DirReplicaAdd
    // return, and then restore our saved thread state.  Ergo, we must declare:
    VOID *pSaveTHS;

    BOOL fReplicaInstall = FALSE;

    // This is the guid of the ntdsa object when created remotely. We need this
    // so we can set the ntdsa object in the hidden record. (We need it in the
    // hidden record so at boot we can find our ntdsa object)
    GUID ntdsaGuid;

    ASSERT(InstallInParams);
    ASSERT(InstallOutParams);

    gfDoSamChecks = FALSE;
    gUpdatesEnabled = TRUE;

    RtlZeroMemory( &gNames, sizeof( gNames ) );
    RtlZeroMemory( &ntdsaGuid, sizeof(ntdsaGuid) );

    //
    // Tell our caller that we can be cancelled now; also if a cancel has
    // happened in the meantime, then cancel now
    //
    Assert( gpfnInstallCancelOk || !gfRunningInsideLsa );
    if ( gpfnInstallCancelOk )
    {
        WinError = gpfnInstallCancelOk( TRUE );
        if ( ERROR_SUCCESS != WinError )
        {
            SET_INSTALL_ERROR_MESSAGE0( ERROR_CANCELLED,
                                       DIRMSG_INSTALL_DS_CORE_INSTALL_FAILED );
            return STATUS_CANCELLED;
        }
    }
    if ( DsaIsInstallingFromMedia() ) {
        NtStatus = ClearNonReplicatedAttributes();
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }

        NtStatus = CheckTombstone();
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        } 

        NtStatus = CheckReplicationEpoch(InstallInParams->ReplicationEpoch);
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }
    
        NtStatus = HandleKeys(InstallInParams->BootKey,InstallInParams->cbBootKey);
        if (!NT_SUCCESS(NtStatus)) {
            return NtStatus;
        }
    }

    // Initialize the root domain DNS name in the Anchor
    // The RPC SPN code and DsAddrFromName use it
    gAnchor.pwszRootDomainDnsName
        = (LPWSTR) malloc(MAX_PATH * sizeof(WCHAR));
    if (NULL == gAnchor.pwszRootDomainDnsName) {
        SET_INSTALL_ERROR_MESSAGE0(ERROR_OUTOFMEMORY, DIRMSG_INSTALL_FAILED_GENERAL);
        return STATUS_NO_MEMORY;
    }

    WinError = GetConfigParamW(MAKE_WIDE(ROOTDOMAINDNSNAME),
                               gAnchor.pwszRootDomainDnsName,
                               MAX_PATH);
    if (WinError) {
        SET_INSTALL_ERROR_MESSAGE0(WinError, DIRLOG_INSTALL_FAILED_REGISTRY);
        return STATUS_REGISTRY_IO_FAILED;
    }

    _try
    {
        //
        // Read values in from the registry and set the values
        // in variable global to this module (boot.lib)
        //
        NtStatus = InitializeNTDSSetup();

        if (!NT_SUCCESS(NtStatus)) {
            DPRINT1(0,"InitializeNTDSSetup failed with 0x%x\n", NtStatus);
            _leave;
        }

        if ( gNames.SrcRootDomainSrv && L'\0' != gNames.SrcRootDomainSrv[ 0 ] )
        {
            fReplicaInstall = TRUE;
        }

        if ( !gNames.SrcConfigNCSrv || L'\0' == gNames.SrcConfigNCSrv[ 0 ] )
        {
            GUID UnusedGuid;
            CROSS_REF *pUnusedCR;
            // First DS in the enterprise - i.e. not a replicated install.
            // Need to create NC objects root to leaf so that AddCatalogInfo()
            // succeeds when it tries to modify the parent NC's ATT_SUB_REFS
            // property.

            // Make sure the gInstallHasDoneSchemaMove is false (setting once
            // globally causes problems if dcpromo fails after schema rename
            // and is restarted without reboot. The flag then stays on as true
            // causing phantoms of schema objects to be created during 
            // object-category value adds, causing a jet exception later
            // when the boot schema object is being renamed to the same name
            // as this phantom)

            gInstallHasDoneSchemaMove = FALSE;

            NtStatus = CreateRootDomainObject(gNames.RootDomainDNName,
                                              &UnusedGuid,
                                              NULL);

            if (!NT_SUCCESS(NtStatus))
            {
                DPRINT2(0,"CreateRootDomainObject(%ws). Error 0x%x\n",
                gNames.RootDomainDNName,NtStatus);

                SET_INSTALL_ERROR_MESSAGE1( RtlNtStatusToDosError( NtStatus ),
                                            DIRMSG_INSTALL_FAILED_TO_CREATE_OBJECT,
                                            gNames.RootDomainDNName );

                return NtStatus;
            }

            NtStatus = CreateConfigNCObject(gNames.ConfigNCDNName);

            if (!NT_SUCCESS(NtStatus))
            {
                DPRINT2(0,"CreateConfigNCObject(%s). Error 0x%x\n",
                gNames.ConfigNCDNName, NtStatus);

                SET_INSTALL_ERROR_MESSAGE1( RtlNtStatusToDosError( NtStatus ),
                                            DIRMSG_INSTALL_FAILED_TO_CREATE_OBJECT,
                                            gNames.ConfigNCDNName );

                return NtStatus;
            }

            NtStatus = CreateSchemaNCObject(gNames.SchemaDNName);

            if (!NT_SUCCESS(NtStatus))
            {
                DPRINT2(0,"CreateSchemaNCObject(%s). Error 0x%x\n",
                gNames.SchemaDNName, NtStatus);

                SET_INSTALL_ERROR_MESSAGE1( RtlNtStatusToDosError( NtStatus ),
                                            DIRMSG_INSTALL_FAILED_TO_CREATE_OBJECT,
                                            gNames.SchemaDNName );

                return NtStatus;
            }

            UpdateCreateNCInstallMessage(gNames.SchemaDNName,
                                         UPDATE_SCHEMA_NC_INDEX );
            
            if(DBInitialSetup(gNames.SchemaDNName)) {
                DPRINT2(0,"Move initial schema (%S). Error 0x%x\n",
                        gNames.SchemaDNName, NtStatus);

                NtStatus = STATUS_UNSUCCESSFUL;
                SET_INSTALL_ERROR_MESSAGE1(RtlNtStatusToDosError( NtStatus ),
                                           DIRMSG_INSTALL_FAILED_TO_MOVE_BOOT_SCHEMA,
                                           gNames.SchemaDNName );

                return NtStatus;
            }
            
            gInstallHasDoneSchemaMove = TRUE;

            UpdateCreateNCInstallMessage( gNames.ConfigNCDNName, 
                                          UPDATE_CONFIG_NC_INDEX );

            NtStatus  =  CreateDefaultConfigNCDIT(gNames.ConfigNCDNName);

            if (!NT_SUCCESS(NtStatus))
            {
                DPRINT2(0,"CreateConfigNCDIT(%s). Error 0x%x\n",
                gNames.ConfigNCDNName, NtStatus);

                SET_INSTALL_ERROR_MESSAGE1( RtlNtStatusToDosError( NtStatus ),
                                            DIRMSG_INSTALL_FAILED_NC_CREATE,
                                            gNames.ConfigNCDNName );

                return NtStatus;
            }

            UpdateCreateNCInstallMessage( gNames.RootDomainDNName, 
                                          UPDATE_DOMAIN_NC_INDEX );

            NtStatus  =  CreateDefaultRootDomainDIT(gNames.RootDomainDNName);

            if (!NT_SUCCESS(NtStatus))
            {
                DPRINT2(0,"CreateDefaultRootDomainDIT(%s). Error 0x%x\n",
                gNames.RootDomainDNName, NtStatus);

                SET_INSTALL_ERROR_MESSAGE1( RtlNtStatusToDosError( NtStatus ),
                                            DIRMSG_INSTALL_FAILED_NC_CREATE,
                                            gNames.RootDomainDNName );

                return NtStatus;
            }

            // Create machine object.

            SetInstallStatusMessage( DIRMSG_INSTALL_CREATING_LOCAL_DS,
                                    NULL, NULL, NULL, NULL, NULL );

            NtStatus = CreateNtdsDsaObject(gNames.DsaDNName,
                                           gNames.RootDomainDNName,
                                           gNames.ConfigNCDNName,
                                           gNames.SchemaDNName);

            if (!NT_SUCCESS(NtStatus))
            {
                DPRINT1(0,"CreateNtdsDsaObject failed. Error 0x%x\n", NtStatus);

                SET_INSTALL_ERROR_MESSAGE1( RtlNtStatusToDosError( NtStatus ),
                                            DIRMSG_INSTALL_FAILED_TO_CREATE_NTDSA_OBJECT,
                                            gNames.DsaDNName );

                return NtStatus;
            }

        }
        else
        {
            // Replicated install case.  Schema and Configuration NC always come
            // from the same machine.  Domain info may come from another machine
            // or be created locally if this is the first instance of a child
            // domain.
            // We always use compression initially because we don't yet know
            // what the network connection to the other server is like yet.
            // If it's a fast link we'll have wasted a few CPU cycles (and the
            // KCC will later remove the compression flag from the replica
            // flags), but if it's a slow link then usign compression will have
            // saved 90% of the network bandwidth that would have been required

            ULONG     ulOptions =  DRS_WRIT_REP
                                 | DRS_INIT_SYNC
                                 | DRS_PER_SYNC
                                 | DRS_USE_COMPRESSION;
            REPLTIMES repltimes;
            WCHAR *   RemoteServer;
            ULONG     Length;
            LPWSTR    pszSourceDsaGuidBasedDnsName = NULL;
            UUID      uuidSourceDsaObjGuid = {0};
            LPWSTR    pszSourceDsaDnsDomainName = NULL;
            
            for (int i=0;i< 84;i++)
            {
               repltimes.rgTimes[i] = 0xff;        // Every 15 minutes
            }

            if (gNames.SourceDsaDnsDomainName && *gNames.SourceDsaDnsDomainName) {
                // We were given the source's DNS domain name -- this allows us
                // to perform mutual auth.
                pszSourceDsaDnsDomainName = gNames.SourceDsaDnsDomainName;
            }

            // Make sure the gInstallHasDoneSchemaMove is false (setting once
            // globally causes problems if dcpromo fails after schema rename
            // and is restarted without reboot. The flag then stays on as true
            // causing phantoms of schema objects to be created during 
            // object-category value adds, causing a jet exception later
            // when the boot schema object is being renamed to the same name
            // as this phantom)

            gInstallHasDoneSchemaMove = FALSE;
            // Delete the boot schema, we never needed it.
            if(!DsaIsInstallingFromMedia() && DBInitialSetup(NULL)) {
                NtStatus = STATUS_UNSUCCESSFUL;
                DPRINT1(0,"Delete initial schema. Error 0x%x\n", NtStatus);
                
                SET_INSTALL_ERROR_MESSAGE1(RtlNtStatusToDosError( NtStatus ),
                                           DIRMSG_INSTALL_FAILED_TO_MOVE_BOOT_SCHEMA,
                                           NULL );

                return NtStatus;
            }
            gInstallHasDoneSchemaMove = TRUE;

            // Initialize the DRA.
            if (WinError = InitDRA(pTHStls)) {
                // This should never happen -- currently always returns 0 if
                // DsaIsInstalling().  Therefore we don't make any special
                // effort to report a descriptive message.
                Assert(!"DRA Initialize failed!");
                LogUnhandledError(WinError);
                NtStatus = STATUS_UNSUCCESSFUL;
                SET_INSTALL_ERROR_MESSAGE0(NtStatus, DIRMSG_INSTALL_FAILED_GENERAL);
                return NtStatus;
            }

            if (DsaIsInstallingFromMedia()) {
                //Update the pDSADN to a temp value
                NtStatus = CreateDummyNtdsDsaObject();
    
                if (!NT_SUCCESS(NtStatus))
                {
                    DPRINT1(0,"CreateNtdsDsaObject failed. Error 0x%x\n", NtStatus);
    
                    return NtStatus;
                }

            }

            //If the replicationEpoch is not zero, then it is nessary to 
            //update the value to equal that of the server that the NtdsDsa
            //object will be created on.  The remote call will fail with
            //Mismatched replication epochs if this is not done.
           
            NtStatus = UpdateReplicationEpochAndHiddenDSA(gAnchor.pDSADN,
                                                          InstallInParams->ReplicationEpoch,
                                                          FALSE);
    
            if (!NT_SUCCESS(NtStatus))
            {
                DPRINT1(0,"UpdateReplicationEpochAndHiddenDSA failed. Error 0x%x\n", NtStatus);

                return NtStatus;
            } 
            
            if ( fReplicaInstall )
            {
                //
                //  Try to add the server remotely
                //
                SetInstallStatusMessage( DIRMSG_CREATING_REMOTE_NTDSA,
                                         gNames.SrcConfigNCSrv, NULL, NULL,
                                         NULL, NULL );

                WinError = CreateRemoteNtdsDsaObject( &ntdsaGuid );
                if ( ERROR_DS_DRA_NOT_SUPPORTED == WinError )
                {
                    // Fine - we'll add the object locally
                    WinError = ERROR_SUCCESS;
                }

                else if ( ERROR_SUCCESS != WinError )
                {
                    // This is fatal
                    SET_INSTALL_ERROR_MESSAGE2( WinError,
                                                DIRMSG_FAILED_TO_CREATE_REMOTE_NTDSA,
                                                gNames.DsaDNName,
                                                gNames.SrcConfigNCSrv );
    
                    return STATUS_UNSUCCESSFUL;
                } else  {

                    //
                    // Note that the server object has been created
                    // so that it can be removed if a failure occurs later
                    // on
                    //
                    Assert( ERROR_SUCCESS == WinError );
                    InstallOutParams->InstallOperationsDone |= NTDS_INSTALL_SERVER_CREATED;
                    
                }

            }

            SetInstallStatusMessage( DIRMSG_INSTALL_REPLICATING_SCHEMA,
                                    NULL, NULL, NULL, NULL, NULL );

            size = (ULONG)DSNameSizeFromLen(wcslen(gNames.SchemaDNName));
            pNC = (PDSNAME) XCalloc( 1, size );
            BuildDefDSName(pNC,gNames.SchemaDNName,NULL);
            
            pSaveTHS = InstallTHSave();
            DirReplicaErr = DirReplicaAdd(pNC,
                                          NULL,
                                          NULL,
                                          gNames.SrcConfigNCSrv,
                                          pszSourceDsaDnsDomainName,
                                          &repltimes,
                                          ulOptions);
            
            XFree(pNC); pNC = NULL;
            THDestroy();
            InstallTHRestore(pSaveTHS);

            if (DirReplicaErr != DRAERR_Success)
            {
                DPRINT3(0, "DirReplicaAdd(%ls,%ls) Failed. Error %d\n",
                        gNames.SchemaDNName, gNames.SrcConfigNCSrv,
                        DirReplicaErr);

                //
                // Set the error message with the win32 value, too
                // (DirReplicaErr is a winerror)
                //
                SET_INSTALL_ERROR_MESSAGE2( DirReplicaErr,
                                            DIRMSG_INSTALL_FAILED_REPLICATION,
                                            gNames.SchemaDNName,
                                            gNames.SrcConfigNCSrv );

                return DirReplicaErrorToNtStatus(DirReplicaErr);
            }
            else
            {
                PDSNAME pDMDSave;

                DPRINT2(0, "DirReplicaAdd(%ls,%ls) Succeeded\n",
                        gNames.SchemaDNName, gNames.SrcConfigNCSrv);

                SetInstallStatusMessage(DISMSG_INSTALL_SCHEMA_COMPELETE,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL);
                // While replicating the schemaNC, the in-memory schema
                // cache was updated without re-reading the contents of
                // the DIT (See AddObjCaching). This protocol has been
                // left in place even though it doesn't quite work
                // with the new schema defunct, reuse, and delete code.
                // Still, it should be okay because the schemaNC must
                // be replicatable w/the shipped schema and not depend
                // on changes in the parent. If replicating the schemaNC
                // depends on changes from the parent then, since
                // replication order is not guaranteed, the wrong schema
                // objects may replicate in at the wrong time and
                // replication fails.
                //
                // But defuncted and colliding schema objects must be
                // properly encached before replicating other NCs.
                // So reload the schema cache from the newly replicated
                // schemaNC in the DIT.
                //
                // There should be enough infrastructure in place to
                // successfully reload the schema cache because the
                // cache was successfully loaded earlier by Install().
                //
                // Be careful to maintain current state like the other code
                // in this function.
                //

                // name of the newly-replicated schemaNC
                size = (ULONG)DSNameSizeFromLen(wcslen(gNames.SchemaDNName));
                pNC = (PDSNAME) XCalloc( 1, size );
                BuildDefDSName(pNC,gNames.SchemaDNName,NULL);

                // Save current thread state
                pSaveTHS = InstallTHSave();

                // Set schemaNC name to the newly replicated schemaNC.
                pDMDSave = gAnchor.pDMD;
                gAnchor.pDMD = pNC;

                // reload the schema (allocates and frees thread state)
                DirReplicaErr = SCUpdateSchema();

                // just to be safe, reset schemaNC's name and forest version
                gAnchor.pDMD = pDMDSave;

                // restore thread state
                XFree(pNC); pNC = NULL;
                InstallTHRestore(pSaveTHS);

                // Did it work?
                if (DirReplicaErr != DRAERR_Success) {
                    DPRINT3(0, "ReloadSchemaCache(%ls,%ls) Failed. Error %d\n",
                            gNames.SchemaDNName, gNames.SrcConfigNCSrv,
                            DirReplicaErr);
                    //
                    // Set the error message with the win32 value, too
                    // (DirReplicaErr is a winerror)
                    //
                    SET_INSTALL_ERROR_MESSAGE2( DirReplicaErr,
                                                DIRMSG_INSTALL_FAILED_SCHEMA_RELOAD,
                                                gNames.SchemaDNName,
                                                gNames.SrcConfigNCSrv );

                    return DirReplicaErrorToNtStatus(DirReplicaErr);
                } else {
                    DPRINT2(0, "ReloadSchemaCache(%ls,%ls) Succeeded\n",
                            gNames.SchemaDNName, gNames.SrcConfigNCSrv);

                    SetInstallStatusMessage(DISMSG_RELOAD_SCHEMA_COMPELETE,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL);
                }
            }

            // Now the configuration container.

            SetInstallStatusMessage( DIRMSG_INSTALL_REPLICATING_CONFIG,
                                    NULL, NULL, NULL, NULL, NULL );

            size = (ULONG)DSNameSizeFromLen(wcslen(gNames.ConfigNCDNName));
            pNC = (PDSNAME) XCalloc( 1, size );
            BuildDefDSName(pNC,gNames.ConfigNCDNName,NULL);

            pSaveTHS = InstallTHSave();
            DirReplicaErr = DirReplicaAdd(pNC,
                                          NULL,
                                          NULL,
                                          gNames.SrcConfigNCSrv,
                                          pszSourceDsaDnsDomainName,
                                          &repltimes,
                                          ulOptions);

            XFree(pNC); pNC = NULL;
            THDestroy();
            InstallTHRestore(pSaveTHS);

            if (DirReplicaErr)
            {
                DPRINT3(0, "DirReplicaAdd(%ls,%ls) Failed. Error %d\n",
                        gNames.ConfigNCDNName, gNames.SrcConfigNCSrv,
                        DirReplicaErr);

                //
                // Set the error message with the win32 value, too
                // (DirReplicaErr is a winerror)
                //
                SET_INSTALL_ERROR_MESSAGE2( DirReplicaErr,
                                            DIRMSG_INSTALL_FAILED_REPLICATION,
                                            gNames.ConfigNCDNName,
                                            gNames.SrcConfigNCSrv );

                return DirReplicaErrorToNtStatus(DirReplicaErr);
            }
            else
            {
                SetInstallStatusMessage(DISMSG_INSTALL_CONFIGURATION_COMPELETE,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL);

                DPRINT2(0, "DirReplicaAdd(%ls,%ls) Succeeded\n",
                        gNames.ConfigNCDNName, gNames.SrcConfigNCSrv);
            }

            // Now the domain NC.

            if ( !gNames.SrcRootDomainSrv || '\0' == gNames.SrcRootDomainSrv[ 0 ] )
            {
                GUID DomainGuid = {0, 0, 0, 0};
                CROSS_REF *pCR;
                COMMARG CommArg;

                // First DC in the child domain.  Just create the domain
                // object and let dsupgrad populate the domain later.
                // Note that "gNames.RootDomainDNName" is misleading - this
                // is really the name of the child domain.
        
                //
                // See if we we have a cross ref locally
                //
                InitCommarg(&CommArg);
                CommArg.Svccntl.dontUseCopy = FALSE;
        
                size = (ULONG)DSNameSizeFromLen(wcslen(gNames.RootDomainDNName));
                pNC = (PDSNAME) XCalloc( 1, size );
                BuildDefDSName(pNC,
                               gNames.RootDomainDNName,
                               NULL,    // No Guid
                               FALSE ); // And don't generate one
        
                pCR = FindExactCrossRef(pNC,
                                        &CommArg);

                if (pCR && !fNullUuid(&(pCR->pNC->Guid))) {
                    // This NC is known, and it already has a GUID.  Use it.
                    DomainGuid = pCR->pNC->Guid;
                }

                //
                //  N.B. We need to create the cross ref first so that we
                //  can use whateven guid is generated on the NC subref/phantom
                //  to create the real NC head locally
                //

                // Create corresponding Cross-Ref object in the partitions
                // container.

                err = CreateChildDomainCrossRef(InstallOutParams,
                                                NULL,
                                                pCR,
                                                &ntdsaGuid);


                if (err != ERROR_SUCCESS)
                {
                    DPRINT1(0,"CreateChildDomainCrossRef(). Error 0x%x\n",err);

                    SET_INSTALL_ERROR_MESSAGE1( err,
                                                DIRMSG_INSTALL_FAILED_TO_CREATE_DOMAIN_OBJECT,
                                                gNames.RootDomainDNName );

                    return DirReplicaErrorToNtStatus(err);
                }

                //
                // At this point, we have an update version version of domains
                // are in the enterprise.  Check to make sure the sid we are
                // about to add, doesn't already exist
                //
                err = CheckForDuplicateDomainSid();
                if ( err ) {

                    DPRINT( 0, "This domain sid is already in use!" );

                    SET_INSTALL_ERROR_MESSAGE0( err,
                                                DIRMSG_DOMAIN_SID_EXISTS );

                    return STATUS_UNSUCCESSFUL;
                }

                // We should now have the cross ref object locally if the function
                // above succeeded
                pCR = FindExactCrossRef(pNC, &CommArg);
                Assert( pCR );

                XFree(pNC); pNC = NULL;

                UpdateCreateNCInstallMessage( gNames.RootDomainDNName, 
                                              UPDATE_DOMAIN_NC_INDEX );

                NtStatus = CreateRootDomainObject(gNames.RootDomainDNName,
                                                  &DomainGuid,
                                                  pCR);

                if (!NT_SUCCESS(NtStatus))
                {
                    DPRINT2(0,"CreateRootDomainObject(%s). Error 0x%x\n",
                    gNames.RootDomainDNName,NtStatus);

                    //
                    // Set the error message with the win32 value, too
                    // (DirReplicaErr is a winerror)
                    //
                    SET_INSTALL_ERROR_MESSAGE1( RtlNtStatusToDosError( NtStatus ),
                                                DIRMSG_INSTALL_FAILED_TO_CREATE_DOMAIN_OBJECT,
                                                gNames.RootDomainDNName );

                    return err;
                }

                NtStatus  =  CreateDefaultRootDomainDIT(gNames.RootDomainDNName);
                if (!NT_SUCCESS(NtStatus))
                {
                    DPRINT2(0,"CreateDefaultRootDomainDIT(%s). Error 0x%x\n",
                    gNames.RootDomainDNName,NtStatus);

                    SET_INSTALL_ERROR_MESSAGE1( RtlNtStatusToDosError( NtStatus ),
                                                DIRMSG_INSTALL_FAILED_NC_CREATE,
                                                gNames.RootDomainDNName );
                    return NtStatus;
                }

                //
                // Force a change to the cross ref so it replicates out
                // 
                WinError  =  ForceChangeToDomainCrossRef( pCR->pObj,
                                                          gNames.RootDomainDNName,
                                                          &DomainGuid );
                if ( ERROR_SUCCESS != WinError )
                {
                    DPRINT2(0,"ForceChangeToDomainCrossRef(%s). Error %d\n",
                    gNames.RootDomainDNName,WinError);

                    SET_INSTALL_ERROR_MESSAGE1( WinError,
                                                DIRMSG_INSTALL_FAILED_NC_CREATE,
                                                gNames.RootDomainDNName );
                    return STATUS_UNSUCCESSFUL;
                }

                // Since this is a new child/tree in a existing forest
                // the NtdsDsa object was created in CreateChildDomainCrossRef()
                // The NtdsDsa will have it's replicationEpoch updated at this point
                // The Hidden table will be updated at this time to point to newly
                // replicated Ntds settings object.
                size = DSNameSizeFromLen( 0 );

                pDsa = (DSNAME*) XCalloc( 1, size );
                pDsa->structLen = size;
                RtlCopyMemory( &pDsa->Guid, &ntdsaGuid, sizeof(GUID) );

                NtStatus = UpdateReplicationEpochAndHiddenDSA(pDsa,
                                                              InstallInParams->ReplicationEpoch,
                                                              TRUE);
        
                if (!NT_SUCCESS(NtStatus))
                {
                    DPRINT1(0,"UpdateReplicationEpochAndHiddenDSA failed. Error 0x%x\n", NtStatus);
    
                    return NtStatus;
                }
                XFree(pDsa); pDsa = NULL;

            }
            else
            {
                // Replicate the domain NC.

                if (DsaIsInstallingFromMedia()) {
                    //Remove the temp NTDS Setting Object
                    //No longer need since the ntds has been replicated down
                    //with the configNC
                    err = DeleteDummyNtdsDsaObject();
                    Assert(err == 0);
                    if (err)
                    {
                        // This shouldn't happen because
                        // We create this object
                        WinError = err;
                        _leave;
                    }
                }

                //At this point the Ntds Settings object has been replicated
                //from the helper server. The ReplicationEpoch must be updated 
                //to have the same value as the helper server so that the newly 
                //created server can replicate with the other DCs in the enterprise.
                //The Hiddle Table will be update to point to the new Dsa

                size = DSNameSizeFromLen( 0 );

                pDsa = (DSNAME*) XCalloc( 1, size );
                pDsa->structLen = size;
                RtlCopyMemory( &pDsa->Guid, &ntdsaGuid, sizeof(GUID) );

                NtStatus = UpdateReplicationEpochAndHiddenDSA(pDsa,
                                                              InstallInParams->ReplicationEpoch,
                                                              TRUE);
        
                if (!NT_SUCCESS(NtStatus))
                {
                    DPRINT1(0,"UpdateReplicationEpochAndHiddenDSA failed. Error 0x%x\n", NtStatus);
    
                    return NtStatus;
                }
                XFree(pDsa); pDsa = NULL;

                //
                // Convert the machine account to a domain controller machine
                // account so that it will be replicated down during the
                // critical replication.
                //
                err = ConvertMachineAccount(InstallInParams,
                                            InstallOutParams);
                if (err) {
                    //
                    // Fatal error; global error has already been set
                    //
                    return STATUS_UNSUCCESSFUL;
                }

                SetInstallStatusMessage( DIRMSG_INSTALL_REPLICATING_DOMAIN,
                                        NULL, NULL, NULL, NULL, NULL );

                size = (ULONG)DSNameSizeFromLen(wcslen(gNames.RootDomainDNName));
                pNC = (PDSNAME) XCalloc( 1, size );
                BuildDefDSName(pNC,gNames.RootDomainDNName,NULL);

                ulOptions |= DRS_CRITICAL_ONLY;
                DPRINT(0,"Replicating only critical objects from Domain NC.\n" );
                pSaveTHS = InstallTHSave();
                DirReplicaErr = DirReplicaAdd(pNC,
                                              NULL,
                                              NULL,
                                              gNames.SrcRootDomainSrv,
                                              pszSourceDsaDnsDomainName,
                                              &repltimes,
                                              ulOptions);
                
                XFree(pNC); pNC = NULL;
                THDestroy();
                InstallTHRestore(pSaveTHS);

                if (DirReplicaErr)
                {
                    DPRINT3(0, "DirReplicaAdd(%ls,%ls) Failed. Error %d\n",
                            gNames.RootDomainDNName, gNames.SrcRootDomainSrv,
                            DirReplicaErr);


                    SET_INSTALL_ERROR_MESSAGE2( DirReplicaErr,
                                                DIRMSG_INSTALL_FAILED_REPLICATION,
                                                gNames.RootDomainDNName,
                                                gNames.SrcRootDomainSrv );

                    return DirReplicaErrorToNtStatus(DirReplicaErr);
                }
                else
                {
                    SetInstallStatusMessage(DISMSG_INSTALL_CRITICAL_COMPELETE,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL);

                    DPRINT2(0, "DirReplicaAdd(%ls,%s) Succeeded\n",
                            gNames.RootDomainDNName, gNames.SrcRootDomainSrv);
                }
            }

            Assert(!fNullUuid(&ntdsaGuid));
                
            // Derive our GUID-based DNS name.
            {
                DSNAME DN = {0};

                DN.Guid = ntdsaGuid;
                DN.structLen = DSNameSizeFromLen(0);

                pszGuidBasedDnsName = DSaddrFromName(pTHStls, &DN);
                if (NULL == pszGuidBasedDnsName) {
                    SET_INSTALL_ERROR_MESSAGE0(ERROR_OUTOFMEMORY,
                                               DIRLOG_INSTALL_FAILED_GENERAL);
                    return STATUS_NO_MEMORY;
                }
            }
            
            if (0 == WinError) {
                Assert(!pNC);
                // Add repsTo for schema NC on the source DSA to enable change
                // notifications.
                size = (ULONG)DSNameSizeFromLen(wcslen(gNames.SchemaDNName));
                pNC = (PDSNAME) XCalloc( 1, size );
                BuildDefDSName(pNC, gNames.SchemaDNName, NULL);
    
                WinError = I_DRSUpdateRefs(pTHStls,
                                           gNames.SrcConfigNCSrv,
                                           pNC,
                                           pszGuidBasedDnsName,
                                           &ntdsaGuid,
                                           DRS_WRIT_REP
                                             | DRS_ADD_REF
                                             | DRS_DEL_REF);
                
                // Derive source DSA's GUID-based DNS name.
                if (0 == WinError) {
                    WinError = GetSourceDsaGuidBasedDnsName(pTHStls,
                                                            pNC,
                                                            gNames.SrcRootDomainSrv,
                                                            &uuidSourceDsaObjGuid,
                                                            &pszSourceDsaGuidBasedDnsName);
                }

                // Update repsFrom with source's GUID-based DNS name.
                if (0 == WinError) {
                    WinError = DirReplicaModify(pNC,
                                                &uuidSourceDsaObjGuid,
                                                NULL,
                                                pszSourceDsaGuidBasedDnsName,
                                                NULL,
                                                0,
                                                DRS_UPDATE_ADDRESS,
                                                0);
                }
            }

            if (0 == WinError) {
                XFree(pNC); pNC = NULL;
                // Add repsTo for config NC.
                size = (ULONG)DSNameSizeFromLen(wcslen(gNames.ConfigNCDNName));
                pNC = (PDSNAME) XCalloc( 1, size );
                BuildDefDSName(pNC, gNames.ConfigNCDNName, NULL);

                WinError = I_DRSUpdateRefs(pTHStls,
                                           gNames.SrcConfigNCSrv,
                                           pNC,
                                           pszGuidBasedDnsName,
                                           &ntdsaGuid,
                                           DRS_WRIT_REP
                                             | DRS_ADD_REF
                                             | DRS_DEL_REF);
                
                // Update repsFrom with source's GUID-based DNS name.
                if (0 == WinError) {
                    WinError = DirReplicaModify(pNC,
                                                &uuidSourceDsaObjGuid,
                                                NULL,
                                                pszSourceDsaGuidBasedDnsName,
                                                NULL,
                                                0,
                                                DRS_UPDATE_ADDRESS,
                                                0);
                }
            }

            if ((0 == WinError)
                && (L'\0' != gNames.SrcRootDomainSrv[0])) {
                XFree(pNC); pNC = NULL;
                // Add repsTo for domain NC, if needed.
                size = (ULONG)DSNameSizeFromLen(wcslen(gNames.RootDomainDNName));
                pNC = (PDSNAME) XCalloc( 1, size );
                BuildDefDSName(pNC, gNames.RootDomainDNName, NULL);

                WinError = I_DRSUpdateRefs(pTHStls,
                                           gNames.SrcRootDomainSrv,
                                           pNC,
                                           pszGuidBasedDnsName,
                                           &ntdsaGuid,
                                           DRS_WRIT_REP
                                             | DRS_ADD_REF
                                             | DRS_DEL_REF);
                
                // Update repsFrom with source's GUID-based DNS name.
                if (0 == WinError) {
                    WinError = DirReplicaModify(pNC,
                                                &uuidSourceDsaObjGuid,
                                                NULL,
                                                pszSourceDsaGuidBasedDnsName,
                                                NULL,
                                                0,
                                                DRS_UPDATE_ADDRESS,
                                                0);
                }
            }

            if (0 != WinError) {
                // Failed to add repsTo / update repsFrom.
                SET_INSTALL_ERROR_MESSAGE2(WinError,
                                           DIRMSG_INSTALL_FAILED_REPLICATION,
                                           pNC->StringName,
                                           gNames.SrcConfigNCSrv);
                XFree(pNC); pNC = NULL;
                return DirReplicaErrorToNtStatus(WinError);
            }
            XFree(pNC); pNC = NULL;

        }
    }
    _finally
    {
        gfDoSamChecks = TRUE;

        if (pNC) {
            XFree(pNC); pNC = NULL;
        }
        if (pDsa) {
            XFree(pDsa); pDsa = NULL;
        }
        
        InstallFreeGlobals();

        if (!NT_SUCCESS(NtStatus))
        {
            DPRINT1(0,"NTDS:InstallNTDS(). Error Code=0x%x\n", NtStatus );
        }

        CleanupIniCache();
        DestroyInstallHeap();

        //
        // Remove unused reg keys
        //

        ZapTempRegKeys( );

        //
        // Tell our caller don't cancel at this point
        //
        Assert( gpfnInstallCancelOk || !gfRunningInsideLsa );
        if ( gpfnInstallCancelOk )
        {
            WinError = gpfnInstallCancelOk( FALSE );  // FALSE -> don't shutdown
            if ( ERROR_SUCCESS != WinError )
            {
                SET_INSTALL_ERROR_MESSAGE0( ERROR_CANCELLED,
                                           DIRMSG_INSTALL_DS_CORE_INSTALL_FAILED );
                NtStatus =  STATUS_CANCELLED;
            }
        }
    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        //
        // Set a catch all error message
        //
        SET_INSTALL_ERROR_MESSAGE0( ERROR_DS_NOT_INSTALLED,
                                    DIRMSG_INSTALL_DS_CORE_INSTALL_FAILED );

    }

    return NtStatus;
}


VOID
ZapTempRegKeys(
    VOID
    )
{
    struct {
        TCHAR*  Key;

    } actionArray[] = {
        TEXT(INIDEFAULTSCHEMANCDIT),
        TEXT(INIDEFAULTCONFIGNCDIT),
        TEXT(INIDEFAULTROOTDOMAINDIT),
        TEXT(INIDEFAULTNEWDOMAINCROSSREF),
        TEXT(INIDEFAULTMACHINE),
        TEXT(INIDEFAULTLOCALCONNECTION),
        TEXT(INSTALLSITEDN),
        TEXT(ROOTDOMAINSID),
        TEXT(GPO_DOMAIN_FILE_PATH),
        TEXT(GPO_DOMAIN_LINK),
        TEXT(GPO_DC_FILE_PATH),
        TEXT(GPO_DC_LINK),
        TEXT(GPO_USER_NAME),
        TEXT(INIDEFAULTREMOTECONNECTION),
        TEXT(TRUSTEDCROSSREF),
        TEXT(NTDSINIFILE),
        TEXT(LOCALMACHINEACCOUNTDN),
        TEXT(SCHEMADNNAME),
        TEXT(FORESTBEHAVIORVERSION),
        TEXT(RESTOREPATH)
    };

    DWORD count = sizeof(actionArray) / sizeof(actionArray[0]);
    DWORD i;
    DWORD err;
    HKEY  keyHandle;

    //
    // Open the parent key
    //

    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      TEXT(DSA_CONFIG_SECTION),
                      0,
                      KEY_ALL_ACCESS,
                      &keyHandle);

    if (err != ERROR_SUCCESS) {
        return;
    }

    for (i = 0; i < count; i++) {
        err = RegDeleteValue(keyHandle, actionArray[i].Key);
    }

    RegCloseKey(keyHandle);

    return;

} // ZapTempRegKeys

DWORD
CreateChildDomainCrossRef(
    OUT PDS_INSTALL_RESULT  InstallOutParams,
    GUID *pDomainGuid,
    CROSS_REF *pCR,
    OUT GUID *ntdsaGuid
    )
//
// Create Cross-Ref object corresponding to the domain we're now adding to the
// pre-existing DS enterprise.
//
{
    ULONG   err = 0;
    NODE    nodeNewDomainCrossRef( gNames.IniDefaultNewDomainCrossRef );
    NODE    nodeNewNtdsa( gNames.IniDefaultMachine );
    ADDENTRY_REPLY_INFO *infoList  = NULL;
    PPOLICY_DNS_DOMAIN_INFO  DnsDomainInfo = NULL;
    BOOL    fCrossRefAlreadyExisted = FALSE;
    DSNAME  *pNewCR    = NULL;
    DSNAME  *pNewNtdsa = NULL;
    THSTATE *pTHS = pTHStls;

    if ( !nodeNewDomainCrossRef.Initialize() )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    if ( !nodeNewNtdsa.Initialize() )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    _try
    {
        //
        // Build the attr block necessary to build the ntdsa and cross ref
        // object and put it all in an entinflist struct.
        //
        ATTR       attarray[50];
        ATTR       attarray2[50];
        YAHANDLE yh, yh2;
        ATTCACHE* pAC;
        char* strval;
        ULONG count=0, i, size;
        ATTRBLOCK ab;
        LPWSTR pszServerAddress;
        ENTINFLIST CrossRefEntInfList;
        ENTINFLIST NtdsaEntInfList;

        ZeroMemory(attarray,sizeof(attarray));
        ZeroMemory(attarray2,sizeof(attarray2));
        ZeroMemory(&CrossRefEntInfList, sizeof(CrossRefEntInfList));
        ZeroMemory(&NtdsaEntInfList, sizeof(NtdsaEntInfList));

        //
        // Get the domain sid as we need to set it on the ncName attribute
        // of the cross ref
        //
        {
            NTSTATUS NtStatus;
            NtStatus = LsaIQueryInformationPolicyTrusted(PolicyDnsDomainInformation,
                                                         (PLSAPR_POLICY_INFORMATION*) &DnsDomainInfo );
            if ( !NT_SUCCESS( NtStatus ) ) {
                err = RtlNtStatusToDosError( NtStatus );
                _leave;
            }
        }

        // Set the list and defaults correctly
        CrossRefEntInfList.pNextEntInf = &NtdsaEntInfList;
        NtdsaEntInfList.pNextEntInf = NULL;
        CrossRefEntInfList.Entinf.ulFlags = 0;  // not used
        NtdsaEntInfList.Entinf.ulFlags = 0;  // not used

        // Build the cross ref info
        size = (ULONG)DSNameSizeFromLen(wcslen(gNames.NewDomainCrossRefDNName));
        pNewCR = (PDSNAME) THAllocEx(pTHS, size);
        BuildDefDSName(pNewCR,
                       gNames.NewDomainCrossRefDNName,
                       NULL,
                       0);

        while (pAC = nodeNewDomainCrossRef.GetNextAttribute(yh,&strval)) {
            CreateAttr(attarray,count,pAC,strval);
        }
        
        CrossRefEntInfList.Entinf.pName = pNewCR;
        CrossRefEntInfList.Entinf.AttrBlock.attrCount = count;
        CrossRefEntInfList.Entinf.AttrBlock.pAttr = attarray;


#if 0
        //
        //  N.B. Specifing the guid and sid remotely makes recovery from
        //  failure very difficult and can easily lead to duplicate (domain) 
        //  sids.
        //
        //  By ship time, this code can be removed. colinbr 10/13/98.
        //

        // whack the guid of the nc head
        for (i=0; i<count; i++) {
            if (attarray[i].attrTyp == ATT_NC_NAME) {
                NTSTATUS IgnoreStatus;

                Assert(attarray[i].AttrVal.valCount == 1);
                ((DSNAME*)(attarray[i].AttrVal.pAVal[0].pVal))->Guid =
                  *pDomainGuid;

                IgnoreStatus = RtlCopySid(  sizeof(NT4SID),
                                           &((DSNAME*)(attarray[i].AttrVal.pAVal[0].pVal))->Sid,
                                            DnsDomainInfo->Sid );
                Assert( NT_SUCCESS( IgnoreStatus ) );
                ((DSNAME*)(attarray[i].AttrVal.pAVal[0].pVal))->SidLen = RtlLengthSid( DnsDomainInfo->Sid );

            }
        }

#endif

        // build the ntdsa info
        count = 0;
        size = (ULONG)DSNameSizeFromLen(wcslen(gNames.DsaDNName));
        pNewNtdsa = (PDSNAME) THAllocEx(pTHS, size);
        BuildDefDSName(pNewNtdsa,
                       gNames.DsaDNName,
                       NULL,
                       0);

        while (pAC = nodeNewNtdsa.GetNextAttribute(yh2,&strval)) {
            CreateAttr(attarray2,count,pAC,strval);
        }
        
        NtdsaEntInfList.Entinf.pName = pNewNtdsa;
        NtdsaEntInfList.Entinf.AttrBlock.attrCount = count;
        NtdsaEntInfList.Entinf.AttrBlock.pAttr = attarray2;

        if (pCR) {
            // A Cross-Ref already exists for this NC, we're just
            // converting it from its disabled state.  We can do this
            // at any server in the enterprise, so we might as well
            // do it at the one we're already bound to
            pszServerAddress = gNames.SrcConfigNCSrv;
            fCrossRefAlreadyExisted = TRUE;
        }
        else {
            // No Cross-Ref object exists yet, which means that we
            // need to create it de novo, which can only be done at
            // the DSA which holds the partition master role.  We get
            // that by taking the name of the new CR object, computing
            // its parent's name, reading the FSMO-Role-Owner attribute
            // from the parent (yielding the DN of the role-owning DSA).
            // Ordinarily we could then just convert that DN into a
            // network address via DSaddrFromName, but that routine
            // won't work this early in the game (it requires extra
            // ganchor stuff to be set up), so we instead read the DNS
            // host address from the server object for the role holder
            // (its parent) and hope that the server has not been renamed
            // recently.
            DSNAME *pContainer = (DSNAME*)THAllocEx(pTHS, pNewCR->structLen);
            TrimDSNameBy(pNewCR, 1, pContainer);

            // The code previously here was packaged up in this function 
            // for code reuse purposes.
            err = GetFsmoDnsAddress(pTHS, pContainer, &pszServerAddress, NULL); 
            if(err){
                DPRINT1(1,"GetNamingFSMOAddress (which means DirRead()) returned %u\n", err);
                __leave;
            }

            DPRINT1(1, "DNS addr of role owner is '%S'\n",
                    pszServerAddress);

        }
        
        Assert(pszServerAddress);
        
        //
        // Remotely add the cross-ref and the ntdsa object.
        //

        err = RemoteAddOneObjectSimply(pszServerAddress,
                                       NULL, // No client creds needed
                                       &CrossRefEntInfList,
                                       &infoList);
        if(pTHS->errCode){
            // RemoteAddOneObjectSimply() sets the thread state error and
            // returns pTHS->errCode.  So crack out the real Win32 error
            // out of the thread error state, clear the errors and continue
            Assert(err == pTHS->errCode);
            err = Win32ErrorFromPTHS(pTHS);
            if(err == ERROR_DS_REMOTE_CROSSREF_OP_FAILED){
                // Note: Usually you can just use Win32ErrorFromPTHS(), but
                // if the remote side of the RemoteAddObject routine 
                // got a typical thread error state set, then this function
                // sets that this was a remote crossRef creation that failed in
                // the regular extendedErr and moves the error that caused the 
                // remote add op to fail in the extendedData field.
                err = GetTHErrorExtData(pTHS);
            }
            Assert(err);
            THClearErrors();
        }
        if (err) {
            __leave;
        }
        // Both the domain and the server object have been created
        InstallOutParams->InstallOperationsDone |= NTDS_INSTALL_SERVER_CREATED;
        if ( !fCrossRefAlreadyExisted ) {
            InstallOutParams->InstallOperationsDone |= NTDS_INSTALL_DOMAIN_CREATED;
        }
        
        // 
        // Now replicate the cross-ref back.
        //

        err = ReplicateCrossRefBack(pNewCR, 
                                    pszServerAddress);
        DPRINT1(0,
                "Remotely sync'ed Cross-Ref with status %u\n",
                err);
        if ( 0 == err ) {
            // We have succeeded!
            if ( ntdsaGuid ) {
                *ntdsaGuid = infoList[1].objGuid;
            }
        }

        if(err){
            __leave;
        }

    }
    _except( err=GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER )
    {
        if (INVALIDINIFILE == err) {
            err = ERROR_GEN_FAILURE;
        } else if (err == OUTOFMEMORY) {
            err = ERROR_NOT_ENOUGH_MEMORY;
        } else {
            err = ERROR_GEN_FAILURE;
        }
        DPRINT1(
            0,
            "Exception %x adding new domain cross-ref object.\n",
            err
            );
    }

Cleanup:

    if (ERROR_SUCCESS != err) {
        SET_INSTALL_ERROR_MESSAGE1(err,
                                   DIRMSG_INSTALL_FAILED_TO_CREATE_OBJECT,
                                   gNames.NewDomainCrossRefDNName);

    }

    if ( DnsDomainInfo )
    {
        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION) DnsDomainInfo );
    }
    if (pNewCR) {    
        THFree(pNewCR);
    }
    if (pNewNtdsa) {    
        THFree(pNewNtdsa);
    }

    return err;
}

NTSTATUS
DirReplicaErrorToNtStatus(
    IN ULONG DirReplicaError
    )
/*++

Description:

    This routine roughly translates all DirReplicaErr errors to thier
    approximate nt status codes.

Parameters:

    DirReplicaError : a drs error code as defined in ds\inc\drserr.h

Return Values:

    See function definition

--*/
{
    switch (DirReplicaError) {

        case DRAERR_Success:
            return STATUS_SUCCESS;

        case DRAERR_Generic:
            return STATUS_UNSUCCESSFUL;

        case DRAERR_InvalidParameter:
            return STATUS_INVALID_PARAMETER;

        case DRAERR_Busy:
            return STATUS_DS_BUSY;

        case DRAERR_DNExists:
            return  STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS;

        case DRAERR_BadDN:
            return STATUS_OBJECT_NAME_INVALID;

        // [wlees May 26, 1998] Here is my guess at the likely connection
        // related errors.  Since the I_DRSxxx interface now returns Win32
        // errors, we cannot completely predict all the errors that could
        // be returned.  Can we consider converting this framework to win32??
        case RPC_S_SERVER_UNAVAILABLE:
        case RPC_S_INVALID_BINDING:
        case RPC_S_PROTSEQ_NOT_SUPPORTED:
        case RPC_S_INVALID_NET_ADDR:
        case RPC_S_NO_ENDPOINT_FOUND:
        case RPC_S_NO_PROTSEQS_REGISTERED:
        case RPC_S_NOT_LISTENING:
        case RPC_S_NO_BINDINGS:
        case RPC_S_NO_PROTSEQS:
        case RPC_S_OUT_OF_RESOURCES:
        case RPC_S_SERVER_TOO_BUSY:
        case RPC_S_CALL_FAILED:
        case RPC_S_CALL_FAILED_DNE:
        case RPC_S_PROTOCOL_ERROR:
        case RPC_S_INVALID_TAG:
        case RPC_S_UNKNOWN_AUTHN_TYPE:
        case RPC_S_PROCNUM_OUT_OF_RANGE:
        case RPC_S_BINDING_HAS_NO_AUTH:
        case RPC_S_UNKNOWN_AUTHN_SERVICE:
        case RPC_S_UNKNOWN_AUTHN_LEVEL:
        case RPC_S_INVALID_AUTH_IDENTITY:
        case RPC_S_UNKNOWN_AUTHZ_SERVICE:
        case RPC_S_INTERFACE_NOT_FOUND:
        case RPC_S_NO_CONTEXT_AVAILABLE:
        case RPC_S_INTERNAL_ERROR:
        case RPC_X_NULL_REF_POINTER:
        case ERROR_NO_SUCH_PACKAGE:
        case RPC_S_SEC_PKG_ERROR:
            return STATUS_CONNECTION_REFUSED;

        case DRAERR_OutOfMem:
        case ERROR_NOT_ENOUGH_MEMORY:
            return STATUS_NO_MEMORY;

        case DRAERR_AccessDenied:
        case ERROR_ACCESS_DENIED:
            return STATUS_ACCESS_DENIED;

        case DRAERR_NameCollision:
            return STATUS_OBJECT_NAME_COLLISION;

        case DRAERR_Shutdown:
            return STATUS_DLL_INIT_FAILED_LOGOFF;

        case DRAERR_BadNC:
        case DRAERR_InternalError:
        case DRAERR_InconsistentDIT:
        case DRAERR_BadInstanceType:
        case DRAERR_MailProblem:
        case DRAERR_RefAlreadyExists:
        case DRAERR_RefNotFound:
        case DRAERR_ObjIsRepSource:
        case DRAERR_DBError:
        case DRAERR_NoReplica:
        case DRAERR_SchemaMismatch:
        case DRAERR_RPCCancelled:
        case DRAERR_SourceDisabled:
        case DRAERR_SinkDisabled:
        case DRAERR_SourceReinstalled:
            return STATUS_UNSUCCESSFUL;

        default:
//            ASSERT(FALSE);
            DPRINT1( 0, "install.cxx::DirReplicaErrortoNtStatus encountered an error which it did not recognize %d\n", DirReplicaError );
            return STATUS_UNSUCCESSFUL;
    }

    ASSERT(FALSE);
    return STATUS_UNSUCCESSFUL;

}

DWORD
CreateRemoteNtdsDsaObject(
    OUT GUID* NtdsDsaGuid OPTIONAL
    )
//
// This routine attempts to remotely add an ntds object on the
// source server
{
    DWORD err = ERROR_SUCCESS;
    NODE  nodeNewNtdsaObject( gNames.IniDefaultMachine );

    // First the ntdsa object
    if ( !nodeNewNtdsaObject.Initialize() )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    err = RemoteAddOneObject(  gNames.SrcConfigNCSrv,
                               &nodeNewNtdsaObject,
                               gNames.DsaDNName,
                               NtdsDsaGuid,
                               NULL );

    return err;
}

DWORD
ForceChangeToCrossRef( 
    IN DSNAME *  pdnCrossRefObj,
    IN WCHAR *   wszNcDn,
    IN GUID *    pDomainGuid,
    IN ULONG     cbSid,      OPTIONAL
    IN PSID      pSid        OPTIONAL
    )
/*++

Routine Description:

    This routine writes the full dsname (string name, sid and guid) out to the
    cross ref object so it will replicate out.  The algorithm is as follows:
    
    1) create a Infrastructure object in the configuration container with the
       attribute DN-Reference-Update that points to the full dsname of the
       the new nc head
       
    2) this object is deleted
       
    The magic comes in when this information is replicated out.
    
    When a source DC (X) tries to add the configuration container hosted on this
    DC (Y), the tombstone of the infrastructure object will replicate out.  On
    server X, the value of DN-Reference-Update will force the phantom created 
    by the string-name only ncname value on X to be updated with the guid
    and the sid of the new ncname
    
    Furthermore, server X will catch this update and update the in memory cross
    ref list.    

    NOTE: This will ruin your DB currency!
    
Parameters:

    pdnCrossRefObj - the dsname of the cross ref
    
    wszNcDn  - the string name of the NC.
    
    pDomainGuid  - the guid of the NC.
    
    cbSid  - the length of the Sid pointed to by pSid, could be 0.
    
    pSid  - the Sid of the domain, if just an NC, then will be NULL.

Return Values:

    Returns a DirError, and more error info is in the THSTATE pTHStls.

--*/
{
    ULONG            DirError = 0;
    THSTATE *        pTHS = pTHStls;

    ADDARG           addarg;
    REMOVEARG        remarg;
    COMMRES          CommRes;

    CLASSCACHE *     pCC;

    DSNAME *         pdnNc = NULL;
    ULONG            ccLen;
    ULONG            cbSize;

    ATTRBLOCK        AttrBlock;
    ATTR *           pAttr = 0;

    WCHAR *          wszConfigDn = NULL;

#define ATTR_COUNT 3
    ATTRVAL          AttrVal[ATTR_COUNT];

    DSNAME *         pdnDelDsName = NULL;
    LPWSTR           wszDelDn = NULL;
    DSNAME *         pdnParent = NULL;
    DWORD            objClass = CLASS_INFRASTRUCTURE_UPDATE;

    LPWSTR           wszDelRdn = L"CN=CRUpdate,CN=LostAndFoundConfig,";

    // parameter check
    Assert( pdnCrossRefObj );
    Assert( wszNcDn );
    Assert( pDomainGuid );
    Assert( (!cbSid && !pSid) || (cbSid && pSid) );
    Assert( !pSid || RtlValidSid( pSid ) );
    Assert( pTHS && VALID_THSTATE(pTHS) );
    Assert( !pTHS->errCode );


    //
    // Do the prep work, there's lots to do.
    //
    // -----------------------------------------------------------

    //
    // Prepare the full nCName of the new domain
    //

    // Alloca DSNAME
    ccLen = wcslen( wszNcDn );
    cbSize  = DSNameSizeFromLen( ccLen );
    pdnNc = (DSNAME*) THAllocEx(pTHS, cbSize );
    RtlZeroMemory( pdnNc, cbSize );
    // Set Size
    pdnNc->structLen = cbSize;
    // Set GUID
    memcpy( &pdnNc->Guid, pDomainGuid, sizeof(GUID) );
    // Set DN String name
    pdnNc->NameLen = ccLen;
    wcscpy( pdnNc->StringName, wszNcDn );
    // Set SID if present.
    if(pSid){
        cbSize = RtlLengthSid( pSid );
        pdnNc->SidLen = cbSize;
        RtlCopySid( cbSize, (PSID)&pdnNc->Sid, (PSID)pSid);
    } else {
        pdnNc->SidLen = 0;
    }

    //
    // Create the temporary dn
    //

    // Find the DN for the Configuration NC.
    if(DsaIsInstalling()){
        wszConfigDn = gNames.ConfigNCDNName;
    } else {
        Assert(gAnchor.pConfigDN);
        wszConfigDn = gAnchor.pConfigDN->StringName;
    }
    Assert(wszConfigDn);

    // Concatinate to DelRDN.
    ccLen = wcslen( wszDelRdn ) + wcslen( wszConfigDn ) + 1;
    wszDelDn = (WCHAR*) THAllocEx(pTHS, ccLen * sizeof(WCHAR) );
    wcscpy( wszDelDn, wszDelRdn );
    wcscat( wszDelDn, wszConfigDn );

    // Make a DSNAME out of the wchar str for the delete DN.
    cbSize = DSNameSizeFromLen(ccLen);
    pdnDelDsName = (PDSNAME) THAllocEx(pTHS, cbSize );
    memset(pdnDelDsName, 0, cbSize);

    BuildDefDSName( pdnDelDsName,
                    wszDelDn,
                    NULL,
                    FALSE );  // don't generate guid


    //
    // Make the add args
    //
    memset( &AttrBlock, 0, sizeof(AttrBlock) );
    memset( &AttrVal, 0, sizeof(AttrVal) );

    // ISSUE-2000/08/03-BrettSh Must THAlloc ATTRs, 
    // This is because core assumes that it can do a THReAlloc.  This is the 
    // second place where I've seen this behavior, and I am wondering how many
    // instances we need before we fix the core to not make the assumption 
    // that it's THAlloc'd.  Note that this is never freed.  The advantage of
    // the current method, is if there is room for an inplace THReAlloc, then
    // it is more efficient, because most operations require a ReAlloc in
    // mdupdate.c:CheckAddSecurity() for the Security Descriptor attribute.  
    // A similar BUGBUG exists in draserv.c:AddNewDomainCrossRef()  The
    // advantage of changing this, would be clearer and more maintainable
    // code.
    pAttr = (ATTR*) THAllocEx(pTHS, sizeof(ATTR) * ATTR_COUNT);
    AttrBlock.attrCount = ATTR_COUNT;
    AttrBlock.pAttr = pAttr;

    pAttr[0].attrTyp = ATT_OBJECT_CLASS;
    pAttr[0].AttrVal.valCount = 1;
    pAttr[0].AttrVal.pAVal = &AttrVal[0];
    AttrVal[0].valLen = sizeof(DWORD);
    AttrVal[0].pVal = (BYTE*) &objClass;

    pAttr[1].attrTyp = ATT_DN_REFERENCE_UPDATE;
    pAttr[1].AttrVal.valCount = 1;
    pAttr[1].AttrVal.pAVal = &AttrVal[1];
    AttrVal[1].valLen = pdnNc->structLen;
    AttrVal[1].pVal = (BYTE*) pdnNc;

    // Note: the object category returned is wrt O=Boot; however
    // it doesn't really matter as this object is going to be deleted
    // and this attribute is stripped.
    if (!(pCC = SCGetClassById(pTHStls, CLASS_INFRASTRUCTURE_UPDATE))) {
        SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION, 
                    ERROR_DS_OBJ_CLASS_NOT_DEFINED);
        Assert(pTHS->errCode);
        goto Cleanup;
    }

    pAttr[2].attrTyp = ATT_OBJECT_CATEGORY;
    pAttr[2].AttrVal.valCount = 1;
    pAttr[2].AttrVal.pAVal = &AttrVal[2];
    AttrVal[2].valLen = pCC->pDefaultObjCategory->structLen;
    AttrVal[2].pVal = (BYTE*) pCC->pDefaultObjCategory;

    //
    // Add the entry
    //
    // -----------------------------------------------------------

    // Create addarg
    memset( &addarg, 0, sizeof(addarg) );
    memset( &CommRes, 0, sizeof(CommRes) );
    addarg.pObject = pdnDelDsName;
    memcpy( &addarg.AttrBlock, &AttrBlock, sizeof( addarg.AttrBlock ) );
    InitCommarg( &addarg.CommArg );
    addarg.CommArg.Svccntl.dontUseCopy = TRUE;

    // Do name resolution
    pdnParent = (DSNAME *) THAllocEx(pTHS, addarg.pObject->structLen);
    TrimDSNameBy(addarg.pObject, 1, pdnParent);
    DirError = DoNameRes(pTHS,
                         0,
                         pdnParent,
                         &addarg.CommArg,
                         &CommRes,
                         &addarg.pResParent);
    if (DirError) {
        Assert(!"This should never be the case, if we failed to add the parent of this object, then all of dcpromo should've failed.");
        Assert(pTHS->errCode);
        goto Cleanup;
    }

    // Do actual add
    LocalAdd(pTHS, &addarg, FALSE);
    if ( 0 != pTHS->errCode )  {
        // The LocalAdd failed.
        goto Cleanup;
    }

    //
    // Ok, now delete the object
    //
    // -----------------------------------------------------------

    // Create remarg
    memset( &remarg, 0, sizeof(remarg) );
    memset( &CommRes, 0, sizeof(CommRes) );
    remarg.pObject = pdnDelDsName;
    InitCommarg( &remarg.CommArg );

    // Do name resolution.
    DirError = DoNameRes(pTHS,
                         NAME_RES_IMPROVE_STRING_NAME,
                         remarg.pObject,
                         &remarg.CommArg,
                         &CommRes,
                         &remarg.pResObj);
    if(DirError){
        Assert(!"I am kind of curious how this could happen, since we just successfully added the object we're trying to resolve.");
        Assert(pTHS->errCode);
        goto Cleanup;
    }

    // Do actual delete/remove
    LocalRemove(pTHS, &remarg);

    // Process error
    if ( 0 != pTHS->errCode ) {
        goto Cleanup;
    }

    DPRINT1(1, "Added (and Removed) an infrastructureUpdate to fix GUID on a crossRef for %ws\n",
            wszNcDn);

    //
    // That's it
    //

Cleanup:

    if(pdnNc) { THFreeEx(pTHS, pdnNc); }
    if(pdnDelDsName) { THFreeEx(pTHS, pdnDelDsName); }
    if(wszDelDn) { THFreeEx(pTHS, wszDelDn); }

    return(pTHS->errCode);

}


DWORD
ForceChangeToDomainCrossRef(
    IN DSNAME*   pdnCrossRefObj,
    IN WCHAR*    wszDomainDn,
    IN GUID*     pDomainGuid
    )
/*++

Routine Description:

    This function encapsulates the function ForceChangeToCrossRef() into
    a single transaction.  This function also queries LSA for the domain
    SID to be passed into ForceChangeToCrossRef(). 
    
Parameters:

    pdnCrossRefObj - the dsname of the cross ref
    
    wszNcDn  - the string name of the NC.
    
    pDomainGuid  - the guid of the NC.
    
Return Values:

    A value from winerror.h; only a resource error
    
--*/
{
    DWORD        WinError = ERROR_SUCCESS;
    NTSTATUS     NtStatus = STATUS_SUCCESS;
    ULONG        DirError = 0;

    PPOLICY_DNS_DOMAIN_INFO  DnsDomainInfo = NULL;
    
    ULONG        cbSid = 0;
    PSID         pSid = NULL;
    BOOL         fTrans = FALSE;
    ULONG        dwException, ulErrorCode, dsid;
    PVOID        dwEA;
    COMMRES      CommRes;
   
    // parameter check
    Assert( pdnCrossRefObj );
    Assert( wszDomainDn );
    Assert( pDomainGuid );

    if(!SDP_EnterAddAsReader()) {
        // The only valid reason to fail to enter as reader is if we are
        // shutting down.
        Assert(eServiceShutdown);
        return  ErrorOnShutdown();
    }
    __try{
        __try{

            //
            // Get the domain sid as we need to set it on the ncName attribute
            // of the cross ref
            //
            NtStatus = LsaIQueryInformationPolicyTrusted(PolicyDnsDomainInformation,
                            (PLSAPR_POLICY_INFORMATION*) &DnsDomainInfo );

            if ( !NT_SUCCESS( NtStatus ) ) {
                WinError = RtlNtStatusToDosError( NtStatus );
                __leave;
            }
            Assert( DnsDomainInfo && RtlValidSid( DnsDomainInfo->Sid ) );

            // Start transaction.
            fTrans = TRUE;
            SYNC_TRANS_WRITE();

            // Do actual change to CrossRef.
            DirError = ForceChangeToCrossRef(pdnCrossRefObj, wszDomainDn, pDomainGuid,
                                             RtlLengthSid(DnsDomainInfo->Sid), 
                                             DnsDomainInfo->Sid);
            memset(&CommRes, 0, sizeof(CommRes));
            CommRes.errCode = pTHStls->errCode;
            CommRes.pErrInfo = pTHStls->pErrInfo;
            WinError = DirErrorToWinError( DirError, &CommRes);

        } __finally {

            // End transaction.
            if(fTrans){
                CLEAN_BEFORE_RETURN(pTHStls->errCode);
                if(0 == pTHStls->errCode){
                    DPRINT1(0, "Commited nCName attribute infrastructureUpdate for crossRef of %ws\n",
                            wszDomainDn);
                }
            }

            if ( DnsDomainInfo ) {
                LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION) DnsDomainInfo );
            }



        }
    } __except(GetExceptionData(GetExceptionInformation(), &dwException,
                                &dwEA, &ulErrorCode, &dsid)) {
              
          HandleDirExceptions(dwException, ulErrorCode, dsid);

    }
    SDP_LeaveAddAsReader();

    return WinError;


}

DWORD
CheckForDuplicateDomainSid(
    VOID
    )
/*++

Routine Description:

    This routine determines if the domain sid that is about to used is already
    in use in the enterprise. It does this by walking the cross ref list and
    comparing domain sids with the domain sid we are about to use.

Parameters:

Return Values:

    A value from winerror.h; only a resource error

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DWORD err = 0;
    PPOLICY_DNS_DOMAIN_INFO  DnsDomainInfo = NULL;
    DSNAME *DomainDsName = NULL;
    ULONG Size, Length;

    NtStatus = LsaIQueryInformationPolicyTrusted(PolicyDnsDomainInformation,
                    (PLSAPR_POLICY_INFORMATION*) &DnsDomainInfo );

    if ( !NT_SUCCESS( NtStatus ) ) {
        err = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }
    Assert( RtlValidSid( DnsDomainInfo->Sid ) );

    //
    // Prepare a sid only dsname
    //
    Size  = DSNameSizeFromLen( 0 );
    DomainDsName = (DSNAME*) XCalloc( 1, Size );
    RtlZeroMemory( DomainDsName, Size );
    DomainDsName->structLen = Size;
    Length = RtlLengthSid( DnsDomainInfo->Sid );
    DomainDsName->SidLen = Length;
    RtlCopySid( Length, (PSID)&DomainDsName->Sid, (PSID)DnsDomainInfo->Sid);

    NtStatus = SampDoesDomainExist( DomainDsName );

    err = RtlNtStatusToDosError( NtStatus );

Cleanup:


    if ( DnsDomainInfo ) {

        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyDnsDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION) DnsDomainInfo );

    }
    if (DomainDsName) {
        XFree(DomainDsName);
    }

    return err;
}

NTSTATUS
CheckReplicationEpoch(
    DWORD ReplicationEpoch
    )
/*++

Routine Description:

    This routine will compare the replication Epoch of the current dit with
    the Value that is passed in.  If the Values match return STATUS_SUCCESS else
    STATUS_UNSUCCESSFUL

Parameters:

    ReplicationEpoch - The Value to compare the dit's ReplicationEpoch to.

Return Values:

    A value from winerror.h; only a resource error

--*/
{
    THSTATE         *pTHS = pTHStls;
    DWORD           dbErr = ERROR_SUCCESS;
    DWORD           WinErr = ERROR_SUCCESS;
    ULONG           ulDitReplicationEpoch = 0;
    ULONG           ulValue = 0;
    BOOL            fCommit = TRUE;
    ATTCACHE*       ac;

    DWORD dwException = 0;
    PVOID dwExceptionAddress = NULL;
    ULONG ulErrorCode  = 0;
    ULONG dsid = 0;

    __try {
        //retrieve the replicationEpoch from the DS
        DBOpen2(TRUE, &pTHS->pDB);
         __try {
           
            ASSERT( gAnchor.pDSADN != NULL );
            // seek to local dsa object
            dbErr = DBFindDSName( pTHS->pDB, gAnchor.pDSADN );
    
            if ( 0 == dbErr )
            {
                
                dbErr = DBGetSingleValue(
                            pTHS->pDB,
                            ATT_MS_DS_REPLICATIONEPOCH,
                            &ulValue,
                            sizeof( DWORD ),
                            NULL
                            );
                switch (dbErr) {
                     case DB_ERR_NO_VALUE:
                        //If there was no value found then use the value we already have
                        dbErr = 0;
                        ulDitReplicationEpoch = 0;
                        break;
                     case 0:
                        // success! we got the value in ulValue use the smaller of the two
                        ulDitReplicationEpoch = ulValue;
                        break;
                     default:
                        // Some other error!
                        __leave;
                 } /* switch */
            }
        }
        __finally {
    
            DBClose(pTHS->pDB,fCommit);
    
        }
    }
    __except(GetExceptionData(GetExceptionInformation(),
                          &dwException,
                          &dwExceptionAddress,
                          &ulErrorCode,
                          &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        dbErr = DB_ERR_EXCEPTION;
    }

    if (dbErr != 0) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //if the replicationEpoch don't match then fail.
    if (ReplicationEpoch != ulDitReplicationEpoch) {
        WCHAR wszReplicationEpoch[9];
        WCHAR wszDitReplicationEpoch[9];

        swprintf(wszReplicationEpoch,L"%d",ReplicationEpoch);
        swprintf(wszDitReplicationEpoch,L"%d",ulDitReplicationEpoch);

        SET_INSTALL_ERROR_MESSAGE2(ERROR_DS_LOCAL_ERROR,
                                   DIRMSG_REPLICATION_EPOCH_NOT_MATCHED,
                                   wszDitReplicationEpoch,
                                   wszReplicationEpoch);
        return STATUS_UNSUCCESSFUL;
        
    }
    return STATUS_SUCCESS;

}

NTSTATUS
ClearNonReplicatedAttributes()
/*++

Routine Description:

    This routine will Delete all non-replicated attributes from the restored
    Database during an IFM install.  There are a few attributes that should not
    be deleted.  A list of such attributes is mantained in the function.  Additional
    attributes should be added as needed.

Parameters:

    

Return Values:

    A value from ntstatus.h; only a resource error

--*/
{
    THSTATE         *pTHS = pTHStls;
    DWORD           dbErr = ERROR_SUCCESS;
    NTSTATUS        Status = STATUS_SUCCESS;
    ATTCACHE        **pACBuf = NULL;
    unsigned        cAtts = 0;
    ULONG           i = 0;
    ULONG           j = 0;
    BOOLEAN         shouldDelete = TRUE;

    ULONG AttrsNotToDelete[] = {
        ATT_DS_CORE_PROPAGATION_DATA,
        ATT_OBJ_DIST_NAME, 
        ATT_MS_DS_REPLICATIONEPOCH,
        ATT_OBJECT_GUID, 
        ATT_PARTIAL_ATTRIBUTE_DELETION_LIST, 
        ATT_PARTIAL_ATTRIBUTE_SET, 
        ATT_PREFIX_MAP, 
        ATT_REPL_PROPERTY_META_DATA, 
        ATT_REPL_UPTODATE_VECTOR, 
        ATT_SUB_REFS, 
        ATT_USN_CHANGED, 
        ATT_USN_CREATED, 
        ATT_WHEN_CHANGED,
        ATT_PEK_LIST,
        ATT_BRIDGEHEAD_SERVER_LIST_BL,
        ATT_FRS_COMPUTER_REFERENCE_BL, 
        ATT_FRS_MEMBER_REFERENCE_BL,
        ATT_MS_EXCH_OWNER_BL,
        ATT_MS_MMS_MA_STAGING_BL,
        ATT_MS_MMS_PROVISIONING_BL,
        ATT_MS_MMS_ASSOCIATED_BL,
        ATT_MS_MMS_SCOPE_BL,
        ATT_MS_MMS_JOIN_BL,
        ATT_NETBOOT_SCP_BL,
        ATT_NON_SECURITY_MEMBER_BL,
        ATT_QUERY_POLICY_BL,
        ATT_SERVER_REFERENCE_BL,
        ATT_SITE_OBJECT_BL
        };

    //get the list of attribute
    dbErr = SCEnumNamedAtts(&cAtts,
                            &pACBuf);
    if (dbErr) {
        DPRINT1(0,"scGetAttributeTypes: SCEnumNamedAtts failed: %x\n",dbErr);
        goto Cleanup;
    }


    
    for (i = 0;i < cAtts;i++) {
        shouldDelete = TRUE;
        //check to see if the attribute is not replicated
        if ( pACBuf[i]->bIsNotReplicated ) {
            j = 0;
            while ( j < (sizeof(AttrsNotToDelete)/sizeof(AttrsNotToDelete[0])) ) {
                //check to see if we should not delete this attribute
                if ( pACBuf[i]->id == AttrsNotToDelete[j] ) {
                    shouldDelete = FALSE;
                    break;
                }
                j++;
            }
        } else {
            shouldDelete = FALSE;
        }

        if (shouldDelete) {
            dbErr = DBDeleteCol (pACBuf[i]->id,
                                 pACBuf[i]->syntax);
            if ( JET_errSuccess != dbErr ) {
                LogEvent(DS_EVENT_CAT_SCHEMA,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_SCHEMA_DELETE_COLUMN_FAIL,
                         szInsertUL(pACBuf[i]->jColid), szInsertUL(pACBuf[i]->id), szInsertUL(dbErr));
                //Log the error
                if ( ( JET_errColumnNotFound == dbErr ) || ( JET_errColumnInUse == dbErr ) ) {
                    dbErr = JET_errSuccess;
                    //keep going
                } else {
                    goto Cleanup;
                    // Fail
                }
            } else {
                dbErr = DBAddCol (pACBuf[i]);
                if ( JET_errSuccess != dbErr ) {
                    // failed to add the colum fail
                    goto Cleanup;
                }
            }
        }
    }
    

    Cleanup:
    if (pACBuf) {
        THFreeEx(pTHS,pACBuf);
    }

    if ( 0 != dbErr ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;   
}


NTSTATUS
CheckTombstone()
//This function will read the tombstone and determine if the database
//is recent.  Otherwise it will fail the promotion.
{
    THSTATE         *pTHS = pTHStls;
    DWORD           dbErr = ERROR_SUCCESS;
    DWORD           WinErr = ERROR_SUCCESS;
    ULONG           ulTombstoneLifetimeDays;
    DSTIME          Lastchange;
    DSTIME          Time = DBTime();
    ULONG           ulValue;
    BOOL            fCommit = FALSE;
    ATTCACHE*       ac;

    DWORD dwException = 0;
    PVOID dwExceptionAddress = NULL;
    ULONG ulErrorCode  = 0;
    ULONG dsid = 0;

    //Get the value of the tombstone from the Replcia Server
    WinErr = GetConfigParam(TEXT(TOMB_STONE_LIFE_TIME),
                           (PVOID)&ulTombstoneLifetimeDays,
                           sizeof(DWORD));
    if (WinErr != ERROR_SUCCESS) {
        LogAndAlertUnhandledError(1);
        DPRINT1( 0, "Couldn't read the tombstone lifetime of domain for the registry: %d", dbErr);
        return dbErr;
    }
   
    __try {
        //retrive the Tombstone lifetime that is stored in the restored dit
        DBOpen2(TRUE, &pTHS->pDB);
         __try {
           
            ASSERT( gAnchor.pDsSvcConfigDN != NULL );
            // seek to enterprise-wide DS config object
            dbErr = DBFindDSName( pTHS->pDB, gAnchor.pDsSvcConfigDN );
    
            if ( 0 == dbErr )
            {
                // Read the garbage collection period and tombstone lifetime from
                // the config object. If either is absent, use defaults.
    
                dbErr = DBGetSingleValue(
                            pTHS->pDB,
                            ATT_TOMBSTONE_LIFETIME,
                            &ulValue,
                            sizeof( DWORD ),
                            NULL
                            );
                switch (dbErr) {
                     case DB_ERR_NO_VALUE:
                        //If there was no value found then use the value we already have
                        DPRINT(1, "Lifetime not found in local DS: using value from replica or default");
                        dbErr = 0;
                        break;
                     case 0:
                        // success! we got the value in ulValue use the smaller of the two
                        if(ulTombstoneLifetimeDays>ulValue)
                            ulTombstoneLifetimeDays=ulValue;
                        break;
                     default:
                        // Some other error!
                        __leave;
                 } /* switch */
            }
        }
        __finally {
            DBClose(pTHS->pDB,fCommit);
        }
    
    
        //check the time of the last USN change
        DBOpen2(TRUE, &pTHS->pDB);
        __try {
           
            ac = SCGetAttById(pTHS, ATT_USN_CHANGED);
            if (ac==NULL) {
                // messed up schema
                DPRINT(0, "Couldn't find ATT_USN_CHANGED\n");
                dbErr = ERROR_DS_MISSING_EXPECTED_ATT;
                __leave;
            }
    
            dbErr = DBSetCurrentIndex(pTHS->pDB,
                                      (eIndexId)0,
                                      ac,
                                      FALSE
                                      );
            if (0 != dbErr) {
                _leave;
            }
    
            dbErr = DBMove(pTHS->pDB,
                           FALSE,
                           DB_MoveLast
                           );
            if (0 != dbErr) {
                _leave;
            }
    
            dbErr = DBGetSingleValue(pTHS->pDB,
                                   ATT_WHEN_CHANGED,
                                   &Lastchange,
                                   sizeof(DSTIME),
                                   NULL);
            if (0 != dbErr) {
                _leave;
            }
        }
        __finally {
            if (0 == dbErr) {
                fCommit = FALSE;
            }
            DBClose(pTHS->pDB,fCommit);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(),
                          &dwException,
                          &dwExceptionAddress,
                          &ulErrorCode,
                          &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //Get the time that has passed since the last time that we had changed
    //the value in the DS
    if (dbErr == 0){
        Time -= Lastchange;
        Time /= DAYS_IN_SECS;
    } else {
        LogAndAlertUnhandledError(1);
        return(STATUS_INTERNAL_ERROR);
    }


    //if more days have gone by than the tombstone will fail the promote
    if (Time>ulTombstoneLifetimeDays) {
        WCHAR TimeSincebackup[6];
        WCHAR Tombstonelife[6];

        swprintf(TimeSincebackup,L"%I64d",Time);
        swprintf(Tombstonelife,L"%d",ulTombstoneLifetimeDays);

        SET_INSTALL_ERROR_MESSAGE2(ERROR_DS_LOCAL_ERROR,
                                   DIRLOG_DS_TOO_OLD,
                                   TimeSincebackup,
                                   Tombstonelife);
        return STATUS_UNSUCCESSFUL;
        
    }
    return STATUS_SUCCESS;
}


NTSTATUS
HandleKeys(PVOID Bootkey OPTIONAL, DWORD cbBootKey)
//This function is for the install from media case.  It will get the syskey
//from the restored information.  It will use this key to decrypt the old
//PEK.  Then it will reincrypt the PEK with the local syskey. 
{
    DWORD err=ERROR_SUCCESS;
    DWORD Status=STATUS_SUCCESS;
    DWORD State=0;
    WCHAR Path[MAX_PATH];
    DWORD cbPath=MAX_PATH;
    HKEY phkResult;
    BYTE SysKey[16];
    ULONG cbSysKey=sizeof(SysKey)/sizeof(SysKey[0]);
    DWORD type = REG_SZ;
    BOOLEAN fWasEnabled;
    BOOLEAN ErrorNotSet=TRUE;
    
    memset(Path, 0, sizeof(WCHAR)*MAX_PATH);
    GetConfigParamW(MAKE_WIDE(TEXT(RESTOREPATH)), (PVOID)Path, sizeof(WCHAR)*MAX_PATH);

    cbPath=wcslen(Path);

    if (err != ERROR_SUCCESS) {
        DPRINT1(0, "RegCloseKey failed with %d", err);
        goto cleanup;

    }

    Path[cbPath]=L'\0';
    err = GetDatabaseFacts(Path,
                           &State);
    if(err != ERROR_SUCCESS){
        DPRINT1( 0, "Unable to determine location of Syskey: %ul\n", err);
        goto cleanup;
    }

    //
    // Enable restore privilege
    //
    err = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                   TRUE,           // Enable
                                   FALSE,          // not client; process wide
                                   &fWasEnabled );
    ASSERT( NT_SUCCESS( err ) );

    wcscat(Path,L"\\Registry\\system");

    err = RegLoadKeyW(HKEY_LOCAL_MACHINE,   
                      IFM_SYSTEM_KEY, 
                      Path   
                        );
    if (err != ERROR_SUCCESS) {
        DPRINT1(0, "RegLoadKeyW failed with %d retrying\n", err);
        RegUnLoadKeyW(
                  HKEY_LOCAL_MACHINE,    
                  IFM_SYSTEM_KEY   
                );
        err = RegLoadKeyW(
                  HKEY_LOCAL_MACHINE,  
                  IFM_SYSTEM_KEY,
                  Path
                    );
        if (err != ERROR_SUCCESS) {
            DPRINT1(0, "RegLoadKeyW failed with %d\n", err);    
        }
    }  

    err = RegOpenKeyExW(
              HKEY_LOCAL_MACHINE,         // handle to open key
              IFM_SYSTEM_KEY,  // subkey name
              0,   // reserved
              KEY_READ, // security access mask
              &phkResult    // handle to open key
            );

    if (err != ERROR_SUCCESS) {
        DPRINT1(0, "RegOpenKeyExW[ifmSystem] failed with %d", err);
        goto cleanup;
    }

    if ( (State&DSROLE_KEY_STORED)==DSROLE_KEY_STORED ) {
        Status = WxReadSysKeyEx(
                phkResult,
                &cbSysKey,
                (PVOID)SysKey
                );
        if (!NT_SUCCESS(Status)) {
            DPRINT1(0, "WxReadSysKeyEx failed with %d", Status);
            goto cleanup;
        }
    } else if ( (State&DSROLE_KEY_DISK)==DSROLE_KEY_DISK ) {
        Status = WxLoadSysKeyFromDisk(SysKey,
                                      &cbSysKey);
        if (!NT_SUCCESS(Status)) {
            SET_INSTALL_ERROR_MESSAGE0(RtlNtStatusToDosError(Status),
                                       DIRLOG_FAILED_BOOT_OPTION_SETUP_DISK);
            ErrorNotSet=FALSE;
            DPRINT1(0, "WxLoadSysKeyFromDisk failed with %d", Status);
            goto cleanup;
        }
    } else if ( (State&DSROLE_KEY_PROMPT)==DSROLE_KEY_PROMPT ) {
        if (Bootkey) {
            CopyMemory(SysKey,Bootkey,SYSKEY_SIZE);
            cbSysKey=cbBootKey;
        } else {
            DPRINT(0, "No BootKey was entered\n");
            goto cleanup;    
        }

    }

    
    Status = PEKInitialize(gAnchor.pDomainDN,
                           DS_PEK_READ_KEYSET,
                           (PVOID)SysKey,
                           cbSysKey
                           );
    if (!NT_SUCCESS(Status)) {
        DPRINT1(0, "PEKInitialize failed with %d", Status);
        goto cleanup;
    }

    Status = WxReadSysKey(
            &cbSysKey,
            (PVOID)SysKey
            );
    if (!NT_SUCCESS(Status)) {
        DPRINT1(0, "WxReadSysKey failed with %d", Status);
        goto cleanup;
    }

    Status = PEKChangeBootOption(WxStored,
                                 0,
                                 (PVOID)SysKey,
                                 cbSysKey);
    if (!NT_SUCCESS(Status)) {
        DPRINT1(0, "PEKChangeBootOption failed with %d", Status);
        goto cleanup;
    }


   cleanup:

   {
       DWORD temperror=ERROR_SUCCESS;
       temperror = RegCloseKey(phkResult);
       if (!NT_SUCCESS(Status)) {
          DPRINT1(0, "RegCloseKey failed with %d", Status);
       }
   }

    RegUnLoadKeyW(
                  HKEY_LOCAL_MACHINE,   
                  IFM_SYSTEM_KEY 
                );

    //
    // Disable the restore privilege
    //
   {
    DWORD temperror;
    temperror = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,
                                   FALSE,          // Disable
                                   FALSE,          // not client; process wide
                                   &fWasEnabled );
    ASSERT( NT_SUCCESS( temperror ) );
   }

    if(Status!=STATUS_SUCCESS){
        if(ErrorNotSet) {
            SET_INSTALL_ERROR_MESSAGE0( RtlNtStatusToDosError(Status), 
                                        DIRLOG_FAILED_BOOT_OPTION_SETUP);
        }
        return Status;
    }

    if(err!=ERROR_SUCCESS){
        if(ErrorNotSet) {
            SET_INSTALL_ERROR_MESSAGE0( err, 
                                        DIRLOG_FAILED_BOOT_OPTION_SETUP);
        }
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

DWORD
SetDittoGC()
/*++

Routine Description:

    This function will add the GC option to the 
    options field on the pDSADN.    
    
    
Return Values:

    A value from winerror.h

--*/
{
    THSTATE         *pTHS = pTHStls;
    DWORD           dbErr = ERROR_SUCCESS;
    DWORD           res =ERROR_SUCCESS;
    ULONG           ulValue=0;
    BOOL            fCommit = FALSE;

    DWORD dwException = 0;
    PVOID dwExceptionAddress = NULL;
    ULONG ulErrorCode  = 0;
    ULONG dsid = 0;

    __try {
        DBOpen2(TRUE, &pTHS->pDB);
         __try {
    
            ASSERT( gAnchor.pDSADN != NULL );
            
            dbErr = DBFindDSName( pTHS->pDB, gAnchor.pDSADN );
            DPRINT1( 2, "DBFindDSName : %d \n",dbErr);
    
            if ( 0 == dbErr )
            {
                //get the option attribute and add the GC option to it
                res = DBGetSingleValue(
                            pTHS->pDB,
                            ATT_OPTIONS,
                            (PVOID)&ulValue,
                            sizeof( DWORD ),
                            NULL
                            );
                DPRINT1( 2, "DBGetSingleValue : %d \n",dbErr);
    
                dbErr = dbInitRec(pTHS->pDB);
                DPRINT1( 2, "dbInitRec : %d \n",dbErr);
                if(dbErr != 0){
                    DPRINT( 0, "The transaction could not be started.\n");
                    _leave;
                }
    
                switch (res) {
                    case 0:
                        // success! we got the value in ulValue
                        ulValue |= NTDSDSA_OPT_IS_GC;
                        dbErr = DBReplaceAttVal(pTHS->pDB,
                                                1,
                                                ATT_OPTIONS,
                                                sizeof( DWORD ),
                                                (PVOID)&ulValue);
                        DPRINT1( 2, "DBReplaceAttVal : %d \n",dbErr);
                        if(dbErr != 0){
                            DPRINT( 0, "The option field value couldn't be changed on the pDSADN\n");
                            _leave;
                        }
                        break;
                    case DB_ERR_ATTRIBUTE_DOESNT_EXIST:
                        //The attribute was not found so we will add it and the GC option
                        dbErr = DBAddAtt(pTHS->pDB,
                                         ATT_OPTIONS,
                                         SYNTAX_OBJECT_ID_TYPE);
                        DPRINT1( 2, "DBAddAtt : %d \n",dbErr);
                        if(dbErr != 0){
                            DPRINT( 0, "The option field couldn't be added to the pDSADN\n");
                            _leave;
                        }
                    case DB_ERR_NO_VALUE:
                        ulValue = NTDSDSA_OPT_IS_GC;
                        dbErr =  DBAddAttVal(pTHS->pDB,
                                    ATT_OPTIONS,
                                    sizeof( DWORD ),
                                    (PVOID)&ulValue
                                    );
                        DPRINT1( 2, "DBAddAttVal : %d \n",dbErr);
                        if (dbErr != 0) {
                            _leave;
                        }
                        
                        break;
                    default:
                        dbErr = res;
                        // Some other error!
                        __leave;
                 } /* switch */
    
                 //
                 // Update the record
                 //
        
                 dbErr = DBUpdateRec(pTHS->pDB);
                 DPRINT1( 2, "DBUpdateRec : %d \n",dbErr);
                 if (0!=dbErr)
                 {
                     __leave;
                 }
    
            }
        }
        __finally {
            if (dbErr == 0) {
                fCommit=TRUE;    
            } else {
                DBCancelRec(pTHS->pDB);
            }
    
            DBClose(pTHS->pDB,fCommit);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(),
                          &dwException,
                          &dwExceptionAddress,
                          &ulErrorCode,
                          &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        dbErr = DB_ERR_EXCEPTION;
    }

    if (dbErr != 0) {
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    return ERROR_SUCCESS;

}

DWORD
CheckGCness(PBOOL isGC)
/*++

Routine Description:

    This function will read the dit to see if it says its a GC    
    
    
Return Values:

    A value from winerror.h

--*/
{
    THSTATE         *pTHS = pTHStls;
    DWORD           dbErr = ERROR_SUCCESS;
    ULONG           ulValue=0;
    BOOL            fCommit = FALSE;
    
    DWORD dwException = 0;
    PVOID dwExceptionAddress = NULL;
    ULONG ulErrorCode  = 0;
    ULONG dsid = 0;

    *isGC = FALSE;

    __try {
        DBOpen2(TRUE, &pTHS->pDB);
         __try {
           
            ASSERT( gAnchor.pDSADN != NULL );
            // seek to enterprise-wide DS config object
            dbErr = DBFindDSName( pTHS->pDB, gAnchor.pDSADN );
    
            if ( 0 == dbErr )
            {
                
                dbErr = DBGetSingleValue(
                            pTHS->pDB,
                            ATT_OPTIONS,
                            (PVOID)&ulValue,
                            sizeof( DWORD ),
                            NULL
                            );
                switch (dbErr) {
                     case 0:
                        // success! we got the value in ulValue use the smaller of the two
                        if(NTDSDSA_OPT_IS_GC==(ulValue&NTDSDSA_OPT_IS_GC)){
                            *isGC=TRUE;
                        }
                        break;
                     default:
                        // Some other error!
                        __leave;
                 } /* switch */
            
            }
        }
        __finally {
            DBClose(pTHS->pDB,fCommit);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(),
                          &dwException,
                          &dwExceptionAddress,
                          &ulErrorCode,
                          &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        dbErr = DB_ERR_EXCEPTION;
    }

    if (dbErr != 0) {
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    return ERROR_SUCCESS;

}


BOOL
isDitFromGC(IN  PDS_INSTALL_PARAM   InstallInParams,
            OUT PDS_INSTALL_RESULT  InstallOutParams)
/*++

Routine Description:

    This funtion will determine if a Dit can be made a GC and if the user wanted one.

Arguments:

    GCRequested - did the user want a GC


Return Values:

    ERROR_SUCCESS - Success

--*/{
    DWORD   State=0;
    BOOLEAN RegIsGC=FALSE;
    DWORD   Win32Err=ERROR_SUCCESS;
    WCHAR   RestorePath[MAX_PATH];
    BOOL    AmGC=FALSE;

    ASSERT(InstallInParams);
    ASSERT(InstallOutParams);

    memset(RestorePath, 0, sizeof(WCHAR)*MAX_PATH);
    GetConfigParamW(MAKE_WIDE(TEXT(RESTOREPATH)), (PVOID)RestorePath, sizeof(WCHAR)*MAX_PATH);
    
    Win32Err = GetDatabaseFacts(RestorePath,
                                &State);
    if(Win32Err != ERROR_SUCCESS){
        DPRINT1( 0, "Unable to determine if GC from Registry: %ul\n", Win32Err);
    } else {
        if ( (State&DSROLE_DC_IS_GC) == DSROLE_DC_IS_GC) {
            RegIsGC = TRUE;
        }
    }

    ASSERT((!RegIsGC && !InstallInParams->fPreferGcInstall) || RegIsGC);

    Win32Err = CheckGCness(&AmGC);
    if(Win32Err != ERROR_SUCCESS){
        DPRINT1( 0, "Unable to determine if GC from Database: %ul\n", Win32Err);
        return FALSE;
    }
    
    if (InstallInParams->fPreferGcInstall && !AmGC) {
        InstallOutParams->ResultFlags = DSINSTALL_IFM_GC_REQUEST_CANNOT_BE_SERVICED;
        DPRINT( 0, "Can not create GC as requested\n");
    }
    
    return AmGC && RegIsGC && InstallInParams->fPreferGcInstall;
}


DWORD
GetDatabaseFacts(LPCWSTR RestorePath,
                 PULONG State)
/*++

Routine Description:

    This routine gathers information about boot options and the GC state of the
    Backup
Arguments:

    lpRestorePath - The location of the restored files.

    lpState - The return Values that report How the syskey is stored and If the back was likely
              taken form a GC or not.


Return Values:

    ERROR_SUCCESS - Success

--*/
{
    WCHAR regsystemfilepath[MAX_PATH];
    DWORD controlset=0;
    DWORD BootType=0;
    DWORD GCready=0;
    DWORD type=REG_DWORD;
    DWORD size=sizeof(DWORD);
    ULONG cbregsystemfilepath=MAX_PATH*2;
    HKEY  LsaKey=NULL;
    HKEY  phkOldlocation=NULL;
    DWORD Win32Err=ERROR_SUCCESS;
    BOOLEAN fWasEnabled=FALSE;
    NTSTATUS Status=STATUS_SUCCESS;


    //set up the location of the system registry file

    wcscpy(regsystemfilepath,RestorePath);
    wcscat(regsystemfilepath,L"\\registry\\system");

    //
    // Get the source path of the database and the log files from the old
    // registry
    //
    Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                                 TRUE,           // Enable
                                 FALSE,          // not client; process wide
                                 &fWasEnabled );
    ASSERT( NT_SUCCESS( Status ) );
    
    

    Win32Err = RegLoadKeyW(
                      HKEY_LOCAL_MACHINE,        
                      IFM_SYSTEM_KEY, 
                      regsystemfilepath);

    if (Win32Err != ERROR_SUCCESS) {
        DPRINT1( 0, "Failed to load key: %lu retrying\n",
                          Win32Err );
        RegUnLoadKeyW(
                  HKEY_LOCAL_MACHINE,
                  IFM_SYSTEM_KEY);
        Win32Err = RegLoadKeyW(
                      HKEY_LOCAL_MACHINE,        
                      IFM_SYSTEM_KEY, 
                      regsystemfilepath);
        if (Win32Err != ERROR_SUCCESS) {
            DPRINT1( 0, "Failed to load key: %lu\n",
                          Win32Err );
        }

    } 

    //find the default controlset
    Win32Err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                  L"ifmSystem\\Select",
                  0,
                  KEY_READ,
                  & LsaKey );

    if (Win32Err != ERROR_SUCCESS)
    {
        DPRINT1( 0, "Failed to open key: %lu\n",
                          Win32Err );
        goto cleanup;
    }

    Win32Err = RegQueryValueExW( 
                LsaKey,
                L"Default",
                0,
                &type,
                (PUCHAR) &controlset,
                &size
                );

    if (Win32Err != ERROR_SUCCESS)
    {
        DPRINT1( 0,  "Couldn't Discover proper controlset: %lu\n",
                          Win32Err );
        goto cleanup;
    }

    Win32Err = RegCloseKey(LsaKey);
    LsaKey=NULL;
    if (Win32Err != ERROR_SUCCESS) {
        DPRINT1( 0, "RegCloseKey failed with %d\n",
                      Win32Err );
        goto cleanup;
    }

    //Find the boot type
    if (controlset == 1) {
        Win32Err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                      L"ifmSystem\\ControlSet001\\Control\\Lsa",
                      0,
                      KEY_READ,
                      & LsaKey );
    } else {
        Win32Err = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                      L"ifmSystem\\ControlSet002\\Control\\Lsa",
                      0,
                      KEY_READ,
                      & LsaKey );
    }

    if (Win32Err != ERROR_SUCCESS)
    {
        DPRINT1(0, "Failed to open key: %lu\n",
                          Win32Err );
        goto cleanup;
    }

    Win32Err = RegQueryValueExW( 
                LsaKey,
                L"SecureBoot",
                0,
                &type,
                (PUCHAR) &BootType,
                &size
                );

    if (Win32Err != ERROR_SUCCESS)
    {
        DPRINT1(0, "Couldn't Discover Boot Options: %lu\n",
                          Win32Err );
        goto cleanup;
    }

    Win32Err = RegCloseKey(LsaKey);
    LsaKey=NULL;
    if (Win32Err != ERROR_SUCCESS) {
        DPRINT1(0, "RegCloseKey failed with %d\n",
                      Win32Err );
        goto cleanup;
    }
    
    //find if a GC or not
    if (controlset == 1) {
        Win32Err = RegOpenKeyExW(
                      HKEY_LOCAL_MACHINE,        
                      L"ifmSystem\\ControlSet001\\Services\\NTDS\\Parameters",  
                      0,
                      KEY_READ,
                      &phkOldlocation 
                    );
    } else {
        Win32Err = RegOpenKeyExW(
                      HKEY_LOCAL_MACHINE,        
                      L"ifmSystem\\ControlSet002\\Services\\NTDS\\Parameters",  
                      0,
                      KEY_READ,
                      &phkOldlocation 
                    );
    }

    if (Win32Err != ERROR_SUCCESS) {
        DPRINT1(0, "RegOpenKeyExW failed to discover the GC state of the database %d\n",
                      Win32Err );
        goto cleanup;
    }

    Win32Err = RegQueryValueExW(
                      phkOldlocation,           
                      L"Global Catalog Promotion Complete", 
                      0,
                      &type,       
                      (PUCHAR)&GCready,        
                      &size);
    if (Win32Err != ERROR_SUCCESS && ERROR_FILE_NOT_FOUND != Win32Err) {
        DPRINT1(0, "RegQueryValueEx failed to discover the GC state of the database %d\n",
                      Win32Err );
        goto cleanup;

    }

    Win32Err = RegCloseKey(phkOldlocation);
    phkOldlocation=NULL;
    if (Win32Err != ERROR_SUCCESS) {
        DPRINT1(0, "RegCloseKey failed with %d\n",
                      Win32Err );
    }

    *State=0;
    if (GCready) {
        *State |= DSROLE_DC_IS_GC;
    }

    if (BootType == 1) {
        *State |= DSROLE_KEY_STORED;
    } else if ( BootType == 2) {
        *State |= DSROLE_KEY_PROMPT;
    } else if ( BootType == 3) {
        *State |= DSROLE_KEY_DISK;
    } else {
        DPRINT(0, "Didn't discover Boot type Error Unknown\n");    
    }


    cleanup:

    if ( LsaKey ) {
        Win32Err = RegCloseKey(LsaKey);
        LsaKey=NULL;
        if ( Win32Err != ERROR_SUCCESS ) {
            DPRINT1(0, "RegCloseKey failed with %d\n",
                          Win32Err );
        }
    }

    if ( phkOldlocation ) {
        Win32Err = RegCloseKey(phkOldlocation);
        phkOldlocation=NULL;
        if ( Win32Err != ERROR_SUCCESS ) {
            DPRINT1(0, "RegCloseKey failed with %d\n",
                          Win32Err );
        }
    }
    
    Win32Err = RegUnLoadKeyW(
                  HKEY_LOCAL_MACHINE,
                  IFM_SYSTEM_KEY);
    if ( Win32Err != ERROR_SUCCESS) {
        DPRINT1(0, "RegUnLoadKeyW failed with %d\n",
                      Win32Err );
    }
    
    Status = RtlAdjustPrivilege( SE_RESTORE_PRIVILEGE,
                       FALSE,          // Disable
                       FALSE,          // not client; process wide
                       &fWasEnabled );
    ASSERT( NT_SUCCESS( Status ) );
    return Win32Err;

}

VOID
InstallFreeGlobals(
     VOID
    )
/*++

Routine Description:

    This routine free's the memory associated with global variables needed for setup.
    In particular the gNames struct.
    
Arguments:

    None.

Return Values:

    None.
    
--*/
{
    //
    // Free all the members of the gNames struct and then NULL all the pointers.
    //
    if (gNames.NTDSIniFile) {
        XFree(gNames.NTDSIniFile);
    }
    if (gNames.RootDomainDNName) {
        XFree(gNames.RootDomainDNName);
    }   
    if (gNames.SrcRootDomainSrv) {
        XFree(gNames.SrcRootDomainSrv);
    }
    if (gNames.ConfigNCDNName) {
        XFree(gNames.ConfigNCDNName);
    }
    if (gNames.SrcConfigNCSrv) {
        XFree(gNames.SrcConfigNCSrv);
    }
    if (gNames.DsaDNName) {
        XFree(gNames.DsaDNName);
    }
    if (gNames.SchemaDNName) {
        XFree(gNames.SchemaDNName);
    }
    if (gNames.SourceDsaDnsDomainName) {
        XFree(gNames.SourceDsaDnsDomainName);
    }
    if (gNames.IniDefaultConfigNCDit) {
        XFree(gNames.IniDefaultConfigNCDit);
    }
    if (gNames.IniDefaultRootDomainDit) {
        XFree(gNames.IniDefaultRootDomainDit);
    }
    if (gNames.IniDefaultSchemaNCDit) {
        XFree(gNames.IniDefaultSchemaNCDit);
    }
    if (gNames.IniDefaultLocalConnection) {
        XFree(gNames.IniDefaultLocalConnection);
    }
    if (gNames.IniDefaultRemoteConnection) {
        XFree(gNames.IniDefaultRemoteConnection);
    }
    if (gNames.LocalConnectionDNName) {
        XFree(gNames.LocalConnectionDNName);
    }
    if (gNames.RemoteConnectionDNName) {
        XFree(gNames.RemoteConnectionDNName);
    }
    if (gNames.IniDefaultNewDomainCrossRef) {
        XFree(gNames.IniDefaultNewDomainCrossRef);
    }
    if (gNames.NewDomainCrossRefDNName) {
        XFree(gNames.NewDomainCrossRefDNName);
    }
    if (gNames.IniDefaultMachine) {
        XFree(gNames.IniDefaultMachine);
    }
    memset(&gNames, 0, sizeof(gNames));

    return;
}

NTSTATUS
UpdateReplicationEpochAndHiddenDSA(
    IN DSNAME *pDSADN,
    IN DWORD  ReplicationEpoch,
    IN BOOL   fUpdateHiddenTable
    )
/*++

Routine Description:

    This routine will update the Replication Epoch on the Ntds Setting object.
    This routine will update the Hidden table if the fUpdateHiddenTable is Set.
    
Arguments:

    ReplicationEpoch - The value to set the replication Epoch to.  If zero nothing
                       to set
    
    pDSADN - This is a DSNAME of the Ntds Setting Object the hidden Table will
             be updated to point to it and the replicationEpoch will be upated
             on it.
             
    fUpdateHiddenTable - Indicates if the hidden table should be update to point
                         to the ntds settings object that was passed in.
             

Return Values:

    STATUS_SUCCESS.
    
--*/
{
    THSTATE         *pTHS = pTHStls;
    DWORD           dbErr = ERROR_SUCCESS;
    DWORD           err = ERROR_SUCCESS;
    DWORD           res = ERROR_SUCCESS;
    ULONG           ulValue=0;
    BOOL            fCommit = FALSE;

    DWORD dwException = 0;
    PVOID dwExceptionAddress = NULL;
    ULONG ulErrorCode  = 0;
    ULONG dsid = 0;

    if (fUpdateHiddenTable) {
        err = DBReplaceHiddenDSA( pDSADN );
        Assert(err == 0);
        if (err)
        {
            // This shouldn't happen
            return STATUS_NO_MEMORY;
        }
    }
    
    if (ReplicationEpoch == 0) {
        // Nothing needs to be done.
        return STATUS_SUCCESS;
    }

    __try {
        DBOpen2(TRUE, &pTHS->pDB);
         __try {                             
    
            ASSERT( pDSADN != NULL );
            
            dbErr = DBFindDSName( pTHS->pDB, pDSADN );
            DPRINT1( 2, "DBFindDSName : %d \n",dbErr);
    
            if ( 0 == dbErr )
            {
                res = DBGetSingleValue(
                            pTHS->pDB,
                            ATT_MS_DS_REPLICATIONEPOCH,
                            (PVOID)&ulValue,
                            sizeof( DWORD ),
                            NULL
                            );
                DPRINT1( 2, "DBGetSingleValue : %d \n",dbErr);
    
                dbErr = dbInitRec(pTHS->pDB);
                DPRINT1( 2, "dbInitRec : %d \n",dbErr);
                if(dbErr != 0){
                    DPRINT( 0, "The transaction could not be started.\n");
                    _leave;
                }
    
                switch (res) {
                    case 0:
                        // success! we got the value in ulValue
                        ulValue = ReplicationEpoch;
                        dbErr = DBReplaceAttVal(pTHS->pDB,
                                                1,
                                                ATT_MS_DS_REPLICATIONEPOCH,
                                                sizeof( DWORD ),
                                                (PVOID)&ulValue);
                        DPRINT1( 2, "DBReplaceAttVal : %d \n",dbErr);
                        if(dbErr != 0){
                            DPRINT( 0, "The ReplicationEpoch value couldn't be changed on the pDSADN\n");
                            _leave;
                        }
                        break;
                    case DB_ERR_ATTRIBUTE_DOESNT_EXIST:
                        //The attribute was not found so we will add it
                        dbErr = DBAddAtt(pTHS->pDB,
                                         ATT_MS_DS_REPLICATIONEPOCH,
                                         SYNTAX_OBJECT_ID_TYPE);
                        DPRINT1( 2, "DBAddAtt : %d \n",dbErr);
                        if(dbErr != 0){
                            DPRINT( 0, "The ReplicationEpoch couldn't be added to the pDSADN\n");
                            _leave;
                        }
                    case DB_ERR_NO_VALUE:
                        ulValue = ReplicationEpoch;
                        dbErr =  DBAddAttVal(pTHS->pDB,
                                    ATT_MS_DS_REPLICATIONEPOCH,
                                    sizeof( DWORD ),
                                    (PVOID)&ulValue
                                    );
                        DPRINT1( 2, "DBAddAttVal : %d \n",dbErr);
                        if (dbErr != 0) {
                            _leave;
                        }
                        
                        break;
                    default:
                        dbErr = res;
                        // Some other error!
                        __leave;
                 } /* switch */
    
                 //
                 // Update the record
                 //
        
                 dbErr = DBUpdateRec(pTHS->pDB);
                 DPRINT1( 2, "DBUpdateRec : %d \n",dbErr);
                 if (0!=dbErr)
                 {
                     __leave;
                 }
    
            }
        }
        __finally {
            if (dbErr == 0) {
                fCommit=TRUE;    
            } else {
                DBCancelRec(pTHS->pDB);
            }
    
            DBClose(pTHS->pDB,fCommit);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(),
                          &dwException,
                          &dwExceptionAddress,
                          &ulErrorCode,
                          &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        dbErr = DB_ERR_EXCEPTION;
    }

    if (0 != dbErr) {

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    if (!dbErr) {
        gAnchor.pLocalDRSExtensions->dwReplEpoch = ReplicationEpoch;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
CreateDummyNtdsDsaObject()
/*++

Routine Description:

    This routine will create a tempory Ntds Setting object on the
    local machine so that it can replicate the schema and configuration
    containers this object will later be deleted by DeleteDummyNtdsDsaObject().
    
Arguments:

    None.

Return Values:

    None.
    
Comments:
    
    (dmitrydu) - 9/1/00
    We Will have a need to create this object only for Install from Media (IFM) 
    promotions.  After we restore the DS during the promotion our hidden 
    table points to the DSA of the machine the backup was taken from. We 
    can't change it to point to the new machines DSA because the DSA is 
    created on a remote server and we will not have this object until after 
    we replicate in the configuration NC.  If we attempt to replicate a NC from 
    the machine the backup was taken our gAnchor.pDSADN will equal that of the 
    machine we are trying to replicate from.  That machine will return the 
    error ERROR_DS_CLIENT_LOOP.  From this the promotion will fail. We can't 
    change manually can the gAnchor.pDSADN because the hidden table points to 
    the DNT of the old DSA.  Every time RebuildAchor is called it will reset 
    the gAnchor.pDSADN back to the old DSA (this does happen in-between 
    replicating NC's).  This is were the need for a temporary object comes in. 
    We need to create this object so that we can update the hidden table to 
    point to the DNT of this temp object.  Once the object is created and 
    the hidden table updated we should call RebuildAnchor to update the 
    gAnchor.pDSADNto point to the new object.  After will replicate in the 
    configuration NC there is no longer a need for the temporary object.  
    We should update the Hidden table to point to the DSA of the machine and 
    rebuild the anchor.  Then we should delete the temporary object since we 
    have no farther need for it.
    
--*/
{
    void   * pDummy = NULL;
    DWORD    dummyDelay = 0;
    NTSTATUS status = STATUS_SUCCESS;
    DWORD    WinErr = ERROR_SUCCESS;
    PWCHAR   TempDsaPrefix = NULL;
    PWCHAR   DsaDNName = NULL;
    DSNAME * DsaTempDSName = NULL;
    DSNAME * DsaTempDSName2 = NULL;
    UUID     DsaUUID;
    ULONG    DsnameSize=0;

    if(WinErr = UuidCreate(&DsaUUID)){
        status = STATUS_NO_MEMORY;
        goto cleanup;
    }
    if(WinErr = UuidToStringW(&DsaUUID,&TempDsaPrefix)){
        status = STATUS_NO_MEMORY;
        goto cleanup;
    }
    
    DsnameSize=(ULONG)DSNameSizeFromLen(wcslen( gNames.DsaDNName) );
    DsaTempDSName = (DSNAME*)malloc(DsnameSize);
    if (!DsaTempDSName) {
        status = STATUS_NO_MEMORY;
        goto cleanup;
    }
    DsaTempDSName2 = (DSNAME*)malloc(DsnameSize);
    if (!DsaTempDSName2) {
        status = STATUS_NO_MEMORY;
        goto cleanup;
    }
    ZeroMemory((PUCHAR)DsaTempDSName,DsnameSize);
    ZeroMemory((PUCHAR)DsaTempDSName2,DsnameSize);
    BuildDefDSName(DsaTempDSName,gNames.DsaDNName,NULL,FALSE);
    
    TrimDSNameBy(DsaTempDSName, 2, DsaTempDSName2);

    DsaDNName = (PWCHAR)malloc((DsaTempDSName->NameLen + wcslen(L"CN=NTDS Settings,CN=,") + wcslen(TempDsaPrefix) + 1) * sizeof(WCHAR));
    if (!DsaDNName) {
        status = STATUS_NO_MEMORY;
        goto cleanup;
    }
    //construct the temp name of the NTDS Setting object
    wcscpy(DsaDNName,L"CN=NTDS Settings,CN=");
    wcscat(DsaDNName,TempDsaPrefix);
    wcscat(DsaDNName,L",");
    wcscat(DsaDNName,DsaTempDSName2->StringName);

    status = CreateNtdsDsaObject(DsaDNName,
                                 gNames.RootDomainDNName,
                                 gNames.ConfigNCDNName,
                                 gNames.SchemaDNName);

    if (NT_SUCCESS(status)) {
        RebuildAnchor(NULL, &pDummy, &dummyDelay);
    }
    
    cleanup:

    if (!NT_SUCCESS(status)) {
        SET_INSTALL_ERROR_MESSAGE1( RtlNtStatusToDosError( status ),
                                    DIRMSG_INSTALL_FAILED_TO_CREATE_NTDSA_OBJECT,
                                    DsaDNName );
    }

    if (NULL != DsaDNName) {
        free(DsaDNName);
    }
    if (NULL != TempDsaPrefix) {
        RpcStringFreeW(&TempDsaPrefix);
    }
    if (NULL != DsaTempDSName) {
        free(DsaTempDSName);
    }
    if (NULL != DsaTempDSName2) {
        free(DsaTempDSName2);
    }

    return status;
}

DWORD
DeleteDummyNtdsDsaObjectHelper(DSNAME *objtodel)
/*++

Routine Description:

    This routine will delete the NTDS Setting object that was
    used by the IFM promotion as well as the parent of the object.
    
    This helper does the deletes.
    
Arguments:

    None.

Return Values:

    None.
    
--*/
{
    
    THSTATE *  pTHS = pTHStls;
    REMOVEARG  remarg;
    COMMRES    CommRes;
    ULONG      DirError = 0;
    BOOL       fCommit = FALSE;

    DWORD dwException = 0;
    PVOID dwExceptionAddress = NULL;
    ULONG ulErrorCode  = 0;
    ULONG dsid = 0;
    
    // Create remarg                                                                           
    memset( &remarg, 0, sizeof(remarg) );
    memset( &CommRes, 0, sizeof(CommRes) );
    remarg.pObject = objtodel;                                                                 
    InitCommarg( &remarg.CommArg );

    __try {
        DBOpen2(TRUE, &pTHS->pDB);
         __try {
                // Do name resolution.                                                                     
            DirError = DoNameRes(pTHS,                                                                     
                                 NAME_RES_IMPROVE_STRING_NAME,                                             
                                 remarg.pObject,                                                           
                                 &remarg.CommArg,                                                          
                                 &CommRes,                                                                 
                                 &remarg.pResObj);                                                         
            if(DirError){                                                                                  
                __leave;
            }
                                                                                                           
                                                                   
            // Do actual delete/remove                                                                     
            LocalRemove(pTHS, &remarg);                                                                    
        }
        __finally {
            if (0 == pTHS->errCode && 0 == DirError) {
                fCommit = TRUE;
            }
            DBClose(pTHS->pDB,fCommit);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(),
                          &dwException,
                          &dwExceptionAddress,
                          &ulErrorCode,
                          &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        DirError = DB_ERR_EXCEPTION;
    }

    if (DB_ERR_EXCEPTION == DirError) {
        return ERROR_NO_SYSTEM_RESOURCES;
    }
                                                                                                   
    if (0 == pTHS->errCode && 0 == DirError) {
        return ERROR_SUCCESS;
    } else {
        return ERROR_DS_CANT_DELETE;
    }
}


DWORD
DeleteDummyNtdsDsaObject()
/*++

Routine Description:

    This routine will delete the NTDS Setting object that was
    used by the IFM promotion as well as the parent of the object.
    
Arguments:

    None.

Return Values:

    None.
    
--*/
{
    DSNAME  *  pDSADNParent = NULL;
    DWORD   WinError = ERROR_SUCCESS;

    pDSADNParent = (DSNAME*)malloc(gAnchor.pDSADN->structLen);
    if (!pDSADNParent) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    TrimDSNameBy(gAnchor.pDSADN, 1, pDSADNParent);

    WinError = DeleteDummyNtdsDsaObjectHelper(gAnchor.pDSADN);
    if (ERROR_SUCCESS != WinError) {
        goto cleanup;
    }

    WinError = DeleteDummyNtdsDsaObjectHelper(pDSADNParent);
    if (ERROR_SUCCESS != WinError) {
        goto cleanup;
    }

    cleanup:

    if (NULL != pDSADNParent) {
        free(pDSADNParent);
    }
    
    return WinError;

}


DWORD
ConvertMachineAccount(
    IN  PDS_INSTALL_PARAM   InstallInParams,
    OUT PDS_INSTALL_RESULT  InstallOutParams
    )
/*++

Routine Description:

    This routine changes the User Account Control setting on the
    local machine's machine account in the domain.  Note that this
    must be done prior to replicating in the critical objects so that
    the machine account is brought down.  (Make the machine account object
    a DC, makes the object "critical").

Arguments:
    
    InstallInParams --  caller supplied information
    
    InstallOutParams -- updated to indicate whether the machine account
                        was morphed.

Return Values:

    ERROR_SUCCESS, a fatal winerror otherwise.          
    
--*/
{
    DWORD WinError = NULL;
    PSEC_WINNT_AUTH_IDENTITY_W pCreds = NULL;
    LPWSTR AccountDn = NULL;
    HMODULE hMod = NULL;
    NTDSETUP_NtdsSetReplicaMachineAccount  pfnSetMachineAccount = NULL;

    //
    // Get the NTDSETUP dll
    //
    hMod = LoadLibrary("ntdsetup");
    if (hMod) {
        pfnSetMachineAccount = (NTDSETUP_NtdsSetReplicaMachineAccount)
                                GetProcAddress(hMod,
                                               NTDSETUP_SET_MACHINE_ACCOUNT_FN);
    }
    if (NULL == pfnSetMachineAccount) {
        WinError = GetLastError();
        goto Exit;
    }

    //
    // Pull the credentials in
    //
    WinError = DrspGetCredentials(&pCreds);
    if (ERROR_SUCCESS != WinError) {
        goto Exit;
    }

    //
    // Call out to setup the machine account
    //

    WinError =  (*pfnSetMachineAccount)(pCreds,
                                        InstallInParams->ClientToken,
                                        gNames.SrcRootDomainSrv,
                                        InstallInParams->AccountName,
                                        UF_SERVER_TRUST_ACCOUNT,
                                        &AccountDn);

    if (WinError == ERROR_SUCCESS) {

        //
        // Indicate this operation was done so that it can be undone
        // if necessary.
        //
        InstallOutParams->InstallOperationsDone |= NTDS_INSTALL_SERVER_MORPHED;

    }

Exit:

    if (AccountDn) {

        RtlFreeHeap(RtlProcessHeap(), 0, AccountDn);
    }

    if (pCreds) {
        DrspFreeCredentials(pCreds);
        pCreds = NULL;
    }

    if (hMod) {
        FreeLibrary(hMod);
    }

    if (ERROR_SUCCESS != WinError) {

        SET_INSTALL_ERROR_MESSAGE1( WinError,
                                    DIRMSG_SETUP_MACHINE_ACCOUNT_NOT_MORPHED,
                                    InstallInParams->AccountName );

    }

    return WinError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\boot\parseini.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1989 - 1999
//
//  File:       ParseIni.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Parses Schema Initialization File

Author:

    Rajivendra Nath (RajNath) 18-Aug-1989

Revision History:

--*/

#include <ntdspchX.h>


#include "SchGen.HXX"

#define DEBSUB "PARSEINI:"

#define CONFIGURATIONNODE "DIT CONFIGURATION INFO"
#define SCHEMACONTAINER   "SCHEMA_CONTAINER"
#define MACHINENODE       "MACHINE_OBJECT"

extern char gDsaname[64];
extern char gSchemaname[64];


GUID dsInitialObjectGuid=
{0,0,0,{'\0','\x52','\x61','\x6A','\x4E','\x61','\x74','\x68'}};




BOOL YAHANDLE::Initialize(INISECT* is,char* Key)
{
    m_ini=is;
    m_ndx=0;
    m_IsInitialized=TRUE;
    m_stk=0;

    if (Key)
    {
        if (m_str)
        {
            XFree(m_str);
            m_str=NULL;
        }

        m_str=XStrdup(Key);
    }

    return TRUE;
};

BOOL YAHANDLE::Initialize2(INISECT* is,char* Key,DWORD Ndx)
{
    BOOL ret;
    ret=Initialize(is,Key);
    m_ndx=Ndx;
    return ret;
}
////////////////////////////////////////////////
// Iterator for the INISECT Class's Keys
////////////////////////////////////////////////
char*
INISECT::GetNextKey(YAHANDLE& Handle,char* Key,char** RetKey)
{
    char* retchr=NULL;

    if (Handle.m_IsInitialized == 0 || (Handle.m_str==NULL && Key!=NULL))
    {
        Handle.Initialize(this,Key);
    }

    if (Handle.m_str==NULL)
    {
        if (Handle.m_ndx<m_KeyCount)
        {
            retchr=m_ValArray[Handle.m_ndx];
            if (RetKey!=NULL)
            {
                *RetKey=m_KeyArray[Handle.m_ndx];
            }
            Handle.m_ndx++;
        }
    }
    else
    {
        for (DWORD i=Handle.m_ndx;i<m_KeyCount;i++)
        {
            if (_strcmpi(Handle.m_str,m_KeyArray[i])==0)
            {
                retchr=m_ValArray[i];

                if (RetKey!=NULL)
                {
                    *RetKey=m_KeyArray[Handle.m_ndx];
                }

                break;

            }
        }

        Handle.m_ndx=i+1;
    }


    return retchr;
}



////////////////////////////////////////////////
// INISECT Class Implementation
////////////////////////////////////////////////
char    gIniFile[MAX_PATH];

BOOL
SetIniGlobalInfo(char* IniFileName)
{
    strcpy(gIniFile,IniFileName);
        
    strcpy(gSchemaname,"Schema");
    strcpy(gDsaname,   "BootMachine");
    
    return TRUE;
}

extern DWORD GetPrivateProfileSectionEx(
    CHAR    *sectionName,   // IN
    CHAR    **ppBuffer,     // OUT
    CHAR    *iniFile);      // IN


INISECT::INISECT(char* SectionName):
    m_cIniFile(gIniFile)
{
    DWORD ssize=128;

    DWORD SectionSize=ssize-2;
    BOOL  Done=FALSE;

    m_Buffer = NULL;
    m_KeyCount=0;
    m_KeyArray=NULL;
    m_ValArray=NULL;

    m_cSectName = _strdup(SectionName);

    if (m_cSectName==NULL)
    {

        XOUTOFMEMORY(); //Exception...
    }

    SectionSize = GetPrivateProfileSectionEx(
                                m_cSectName,
                                &m_Buffer,
                                m_cIniFile);
    if (SectionSize == 0)
    {
        XFree(m_Buffer);
        m_Buffer = NULL;
        DPRINT1(0, "INISECT::INISECT(%s) Failed. Error NoSuchSection\n", SectionName);
        return;
    }
    else
    {
        m_BuffSize=SectionSize;

        for (char* ptr=m_Buffer;*ptr!='\0';ptr+=strlen(ptr)+1)
        {
            char* eql=strchr(ptr,'=');
            if (eql==NULL)
            {
                DPRINT2(0, "INISECT::INISECT(%s). Bad Line %s in IniFile Ignoring\n", SectionName,m_Buffer);
                return;
            }
            m_KeyCount++;
            *eql='\0';
            ptr+=strlen(ptr)+1;
        }
    }

    m_ValArray=(char**)XCalloc(m_KeyCount,sizeof(char*));
    m_KeyArray=(char**)XCalloc(m_KeyCount,sizeof(char*));

    char* tptr=m_Buffer;

    for (DWORD i=0;i<m_KeyCount;i++)
    {
        m_KeyArray[i]=tptr;
        tptr+=strlen(tptr)+1;
        m_ValArray[i]=tptr;
        tptr+=strlen(tptr)+1;
    }
}

void 
INISECT::ReplaceKeyValuePair(
    char* KeyName, 
    char* KeyValue
    )
{
    // This routine replaces a Key/Value pair.  
    // It exists solely for the benefit of
    // CreateRootDomainObject() which needs to set
    // the Object-Class based on the tag of the 
    // domain name being installed.

    // Should only be called on an initialized instance.
    Assert(IsInitialized());
    // schema.ini key/value pairs should have been read.
    Assert(m_KeyCount > 0);

    // Look for existing key.

    for ( DWORD i = 0; i < m_KeyCount; i++ )
    {
        if ( 0 == _stricmp(KeyName, m_KeyArray[i]) )
        {
            break;
        }
    }

    if ( i == m_KeyCount )
    {
        // Key not found.  Subsequent AddOneObject()
        // where Object-Class doesn't match the 
        // RDN-Att-ID will fail.

        return;
    }

    m_ValArray[i] = KeyValue;
}

char*
INISECT::GetOneKey(char* KeyName)
{
    YAHANDLE handle;

    return GetNextKey(handle,KeyName);
}

char*
INISECT::XGetOneKey(char* KeyName)
{
    char* ret=GetOneKey(KeyName);
    if (ret==NULL)
    {
        DPRINT1(0, "INISECT::XGetOneKey(%s) Failed. Error NoSuchKey\n", KeyName);
        XINVALIDINIFILE();
    }

    return ret;
}

char*
INISECT::XGetNextKey(YAHANDLE& Handle,char* Key,char** RetKey)
{
    char* ret=GetNextKey(Handle,Key,RetKey);
    if (ret==NULL)
    {
        DPRINT1(0, "INISECT::XGetNextKey(%s) Failed. Error NoSuchKey\n", Key);
        XINVALIDINIFILE();
    }

    return ret;
}



INISECT::~INISECT()
{
    if (m_Buffer!=NULL)
    {
        XFree(m_Buffer);
    }

    if (m_KeyArray!=NULL)
    {
        XFree(m_KeyArray);
    }

    if (m_ValArray!=NULL)
    {
        XFree(m_ValArray);
    }
    // PREFIX: Allocated with _strdup so free w/free().
    if (m_cSectName)
    {
        free(m_cSectName);
        m_cSectName = NULL;
    }
}


///////////////////////////////////////////////////
// NODE Class Implementation
///////////////////////////////////////////////////
NODE::NODE( char* startnode):
    INISECT(startnode),
    m_ChildrenCount(0),
    m_Children(NULL),
    m_Parent(NULL),
    m_Cached(FALSE)
{
    m_NodeName = m_cSectName;
}

NODE::~NODE()
{

    for (DWORD i=0;i<m_ChildrenCount;i++)
    {
        if (m_Children[i]->m_Cached!=TRUE)
        {
            delete m_Children[i];
        }

    }

    if (m_Children!=NULL)
    {
        XFree(m_Children);
    }
}

NODE*
NODE::InitChildList()
{
    NODE* node;
    //
    // Initialize if not
    //
    if (m_Children == NULL)
    {
        char* child;
        YAHANDLE handle;

        for (;(child=GetNextKey(handle,CHILDKEY))!=NULL;m_ChildrenCount++);

        m_Children=(NODE**)XCalloc(m_ChildrenCount,sizeof(NODE*));

        handle.Reset();

        for(int i=0;(child=GetNextKey(handle,CHILDKEY))!=NULL;i++)
        {
            m_Children[i]= new NODE(child);
            CHECKVALIDNODE(m_Children[i]);
            m_Children[i]->m_Parent=this;
        }
    }

    return m_Children[0];
}

#define INITALLOCCOUNT 128

NODE*
NODE::GetNextChild(YAHANDLE& handle)
{
    NODE* node=NULL;

//    if (m_Children==NULL)
//    {
//        InitChildList();
//    }

    if (!handle.m_IsInitialized)
    {
        handle.Initialize(this);
    }

    if (m_Children==NULL)
    {
        m_Children=(NODE**)XCalloc(INITALLOCCOUNT,sizeof(NODE*));
        m_ChildrenBuffSize=INITALLOCCOUNT;
    }

    if (m_Children[handle.m_ndx]==NULL)
    {
        YAHANDLE ah;
        char* child;
        ah.Initialize2(handle.m_ini,CHILDKEY,handle.m_stk);

        child=GetNextKey(ah,CHILDKEY);

        handle.m_stk=ah.m_ndx;

        if (child==NULL)
        {
            return NULL;
        }

        node = new NODE(child);

        if (!node->Initialize())
        {
            XINVALIDINIFILE();
        }

        m_Children[handle.m_ndx++]=node;

        if (handle.m_ndx==m_ChildrenBuffSize)
        {
            m_ChildrenBuffSize+=INITALLOCCOUNT;
            m_Children=(NODE**)XRealloc(m_Children,m_ChildrenBuffSize*sizeof(NODE*));

            ZeroMemory(&m_Children[m_ChildrenBuffSize-INITALLOCCOUNT],INITALLOCCOUNT*sizeof(NODE*));
        }

    }
    else
    {
        node = m_Children[handle.m_ndx++];
    }


    return node;
}

BOOL
NODE::Initialize()
{

    if (!(INISECT::IsInitialized()))
    {
        return FALSE;
    }

    return TRUE;
}


ATTCACHE *
NODE::GetNextAttribute(YAHANDLE& Handle,char** Attrib)
{
    char     *attrname;
    ATTCACHE *pAC=NULL;
    
    while(*Attrib = GetNextKey(Handle,NULL,&attrname)) {
        if( strcmp(attrname,CHILDKEY)==0 ) {
            // This determines the DIT struct and is not an attrib.
            continue;
        }
        if ( strcmp(attrname,RDNOFOBJECTKEY)==0) {
            // this is not a real att, but a key to specify what
            // the object name should be if different from the 
            // section name
            continue;
        }
        pAC = SCGetAttByName(pTHStls, strlen(attrname), (PUCHAR) attrname);

        if(!pAC) {
            DPRINT1(0,
                    "NODE::GetNextAttribute(%s) Failed to find ATTCACHE*\n",
                    attrname);
            
            XINVALIDINIFILE();
        }
        break;
    }
    
    return pAC;
}

CLASSCACHE*
NODE::GetClass()
{
    char       *classname=GetOneKey(CLASSKEY);
    CLASSCACHE *pCC=NULL;

    if(!classname) {
        classname = GetOneKey(DASHEDCLASSKEY);
    }

    if(!classname) {
        DPRINT1(0,
                "NODE::GetClass(node-name %s) Failed to find CLASSCACHE*\n",
                m_NodeName);
        
        XINVALIDINIFILE();
    }
        
    pCC = SCGetClassByName(pTHStls, strlen(classname), (PUCHAR) classname);
    
    if(!pCC) {
        DPRINT1(0,
                "NODE::GetClass(%s) Failed to find CLASSCACHE*\n",
                classname);
        
        XINVALIDINIFILE();
    }

    return pCC;
}


CHAR*
NODE::GetRDNOfObject()
{
    // GetOneKey returns NULL if not found
    return GetOneKey(RDNOFOBJECTKEY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dbconstr.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dbconstr.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <dsatools.h>                   // For pTHStls
#include <mdlocal.h>                    // IsRoot
#include <ntseapi.h>
#include <lmaccess.h>                   // For useraccountcontrol flags

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>
#include "ntdsctr.h"

// Headers for Sam call to get reverse membership
#include <samrpc.h>
#include <ntlsa.h>
#include <samisrv.h>
#include "mappings.h"

// Assorted DSA headers
#include "dsevent.h"
#include "objids.h"        /* needed for ATT_MEMBER and ATT_IS_MEMBER_OFDL */
#include <dsexcept.h>
#include <filtypes.h>      /* Def of FI_CHOICE_???                  */
#include <anchor.h>
#include <permit.h>
#include <cracknam.h>  // for CrackedNAmes
#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DBCONSTR:" /* define the subsystem for debugging */

// DBLayer includes
#include "dbintrnl.h"

// draLayer includes
#include "draconstr.h"

// replIncludes
#include "ReplStructInfo.hxx"

#include <fileno.h>
#define  FILENO FILENO_DBCONSTR

// Flag values for reverse membership computations
#define FLAG_NO_GC_ACCEPTABLE      0
#define FLAG_NO_GC_NOT_ACCEPTABLE  1
#define FLAG_GLOBAL_AND_UNIVERSAL  2

// These #defines are used in creating attributeType strings and objectClasses
// strings.
#define NAME_TAG                  L" NAME '"
#define NAME_TAG_SIZE             (sizeof(NAME_TAG) - sizeof(WCHAR))
#define SYNTAX_TAG                L"' SYNTAX '"
#define SYNTAX_TAG_SIZE           (sizeof(SYNTAX_TAG) - sizeof(WCHAR))
#define SINGLE_TAG                L" SINGLE-VALUE"
#define SINGLE_TAG_SIZE           (sizeof(SINGLE_TAG) - sizeof(WCHAR))
#define NO_MOD_TAG                L" NO-USER-MODIFICATION"
#define NO_MOD_TAG_SIZE           (sizeof(NO_MOD_TAG) - sizeof(WCHAR))
#define MAY_TAG                   L" MAY ("
#define MAY_TAG_SIZE              (sizeof(MAY_TAG) - sizeof(WCHAR))
#define ABSTRACT_CLASS_TAG        L" ABSTRACT"
#define ABSTRACT_CLASS_TAG_SIZE   (sizeof(ABSTRACT_CLASS_TAG) - sizeof(WCHAR))
#define AUXILIARY_CLASS_TAG       L" AUXILIARY"
#define AUXILIARY_CLASS_TAG_SIZE  (sizeof(AUXILIARY_CLASS_TAG) - sizeof(WCHAR))
#define STRUCTURAL_CLASS_TAG      L" STRUCTURAL"
#define STRUCTURAL_CLASS_TAG_SIZE (sizeof(STRUCTURAL_CLASS_TAG) - sizeof(WCHAR))
#define MUST_TAG                  L" MUST ("
#define MUST_TAG_SIZE             (sizeof(MUST_TAG) - sizeof(WCHAR))
#define SUP_TAG                   L"' SUP "
#define SUP_TAG_SIZE              (sizeof(SUP_TAG) - sizeof(WCHAR))
#define AUX_TAG                   L" AUX ( "
#define AUX_TAG_SIZE              (sizeof(AUX_TAG) - sizeof(WCHAR))
#define INDEXED_TAG               L" INDEXED"
#define INDEXED_TAG_SIZE          (sizeof(INDEXED_TAG) - sizeof(WCHAR))
#define SYSTEM_ONLY_TAG           L" SYSTEM-ONLY "
#define SYSTEM_ONLY_TAG_SIZE      (sizeof(SYSTEM_ONLY_TAG) - sizeof(WCHAR))
#define RANGE_LOWER_TAG           L"' RANGE-LOWER '"
#define RANGE_LOWER_TAG_SIZE      (sizeof(RANGE_LOWER_TAG) - sizeof(WCHAR))
#define RANGE_UPPER_TAG           L"' RANGE-UPPER '"
#define RANGE_UPPER_TAG_SIZE      (sizeof(RANGE_UPPER_TAG) - sizeof(WCHAR))
#define CLASS_GUID_TAG            L"' CLASS-GUID '"
#define CLASS_GUID_TAG_SIZE       (sizeof(CLASS_GUID_TAG) - sizeof(WCHAR))
#define PROP_GUID_TAG             L"' PROPERTY-GUID '"
#define PROP_GUID_TAG_SIZE        (sizeof(PROP_GUID_TAG) - sizeof(WCHAR))
#define PROP_SET_GUID_TAG         L"' PROPERTY-SET-GUID '"
#define PROP_SET_GUID_TAG_SIZE    (sizeof(PROP_SET_GUID_TAG) - sizeof(WCHAR))
#define END_TAG                   L" )"
#define END_TAG_SIZE              (sizeof(END_TAG) - sizeof(WCHAR))

typedef struct wchar_syntax {
    ULONG    length;
    WCHAR    *value;
} wchar_syntax;

typedef struct SyntaxVal {
    wchar_syntax   name;
    wchar_syntax   oid;
} SyntaxVal;

#define DEFINE_WCHAR_STRING(x) {(sizeof(x)-sizeof(WCHAR)),(WCHAR *)x}

// These are used as the string to use when describing attribute syntaxes in the
// schema.
SyntaxVal SyntaxStrings[] = {
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"Boolean"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.7") },
    { DEFINE_WCHAR_STRING(L"INTEGER"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.27") },
    { DEFINE_WCHAR_STRING(L"BitString"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.6") },
    { DEFINE_WCHAR_STRING(L"OctetString"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.40") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"OID"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.38") },
    { DEFINE_WCHAR_STRING(L"CaseIgnoreString"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.905") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"Integer"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.27") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"Undefined"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1222") },
    { DEFINE_WCHAR_STRING(L"NumericString"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.36") },
    { DEFINE_WCHAR_STRING(L"PrintableString"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.44") },
    { DEFINE_WCHAR_STRING(L"CaseIgnoreString"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.905") },
    { DEFINE_WCHAR_STRING(L"CaseIgnoreString"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.905") },
    { DEFINE_WCHAR_STRING(L"IA5String"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.26") },
    { DEFINE_WCHAR_STRING(L"UTCTime"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.53") },
    { DEFINE_WCHAR_STRING(L"GeneralizedTime"),
          DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.24") },
    { DEFINE_WCHAR_STRING(L"CaseIgnoreString"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.905") },
    { DEFINE_WCHAR_STRING(L"CaseIgnoreString"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.905") },
    { DEFINE_WCHAR_STRING(L"CaseExactString"),
          DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1362") }
};

SyntaxVal SyntaxDN =
                { DEFINE_WCHAR_STRING(L"DN"),
                  DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.12") };
SyntaxVal SyntaxORName =
                { DEFINE_WCHAR_STRING(L"ORName"),
                  DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.1221") };
SyntaxVal SyntaxDNBlob =
                { DEFINE_WCHAR_STRING(L"DNWithOctetString"),
                  DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.903") };
SyntaxVal SyntaxDNString =
                { DEFINE_WCHAR_STRING(L"DNWithString"),
                  DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.904") };
SyntaxVal SyntaxPresentationAddress =
                { DEFINE_WCHAR_STRING(L"PresentationAddress"),
                  DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.43") };
SyntaxVal SyntaxAccessPoint =
                { DEFINE_WCHAR_STRING(L"AccessPointDN"),
                  DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.2") };
SyntaxVal SyntaxDirectoryString =
                { DEFINE_WCHAR_STRING(L"DirectoryString"),
                  DEFINE_WCHAR_STRING(L"1.3.6.1.4.1.1466.115.121.1.15") };
SyntaxVal SyntaxInteger8 =
                { DEFINE_WCHAR_STRING(L"INTEGER8"),
                  DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.906") };
SyntaxVal SyntaxObjectSD =
                { DEFINE_WCHAR_STRING(L"ObjectSecurityDescriptor"),
                  DEFINE_WCHAR_STRING(L"1.2.840.113556.1.4.907") };

OID_IMPORT(MH_C_OR_NAME);
OID_IMPORT(DS_C_ACCESS_POINT);


// Forward declaration of internal functions

DWORD dbGetEntryTTL(DBPOS *pDB, ATTR *pAttr);
DWORD dbGetSubschemaAtt(THSTATE *pTHS, ATTCACHE *pAC, ATTR *pAttr);
DWORD dbGetSubSchemaSubEntry(THSTATE *pTHS, ATTR *pAttr, BOOL fExternal);
DWORD dbGetCanonicalName(THSTATE *pTHS, DSNAME *pDSName, ATTR *pAttr);
DWORD dbGetAllowedChildClasses(THSTATE *pTHS,
                               DSNAME *pDSName,
                               ATTR *pAttr,
                               DWORD flag);
DWORD dbGetAllowedAttributes(THSTATE *pTHS,
                             DSNAME *pDSName,
                             ATTR *pAttr,
                             BOOL fSecurity);
DWORD dbGetFromEntry(DBPOS *pDB, ATTR *pAttr);
DWORD dbGetCreateTimeStamp(DBPOS *pDB, ATTR *pAttr);
DWORD dbGetModifyTimeStamp(DBPOS *pDB, ATTR *pAttr);
DWORD dbGetReverseMemberships(THSTATE *pTHS, DSNAME *pObj, ATTR *pAttr, ULONG Flag);
DWORD dbGetObjectClasses(THSTATE *pTHS, ATTR *pAttr, BOOL bExtendedFormat);
DWORD dbGetAttributeTypes(THSTATE *pTHS, ATTR *pAttr, BOOL bExtendedFormat);
DWORD dbGetDitContentRules(THSTATE *pTHS, ATTR *pAttr, BOOL bExtendedFormat);
DWORD dbGetSubSchemaModifyTimeStamp(THSTATE *pTHS, ATTR *pAttr);
DWORD dbClassCacheToObjectClassDescription(THSTATE *pTHS,
                                           CLASSCACHE *pCCs,
                                           BOOL bExtendedFormat,
                                           ATTRVAL *pAVal);
DWORD dbAttCacheToAttributeTypeDescription(THSTATE *pTHS,
                                           ATTCACHE *pCC,
                                           BOOL bExtendedFormat,
                                           ATTRVAL *pAVal);
DWORD dbClassCacheToDitContentRules(THSTATE *pTHS,
                                    CLASSCACHE *pCC,
                                    BOOL bExtendedFormat,
                                    CLASSCACHE **pAuxCC,
                                    DWORD        auxCount,
                                    ATTRVAL *pAVal);
DWORD dbAuxClassCacheToDitContentRules(THSTATE *pTHS,
                                       CLASSCACHE *pCC,
                                       CLASSCACHE **pAuxCC,
                                       DWORD        auxCount,
                                       PWCHAR  *pAuxBuff,
                                       DWORD   *pcAuxBuff);
DWORD dbGetGroupRid(THSTATE *pTHS, DSNAME *pDSName, ATTR *pAttr);
DWORD dbGetObjectStructuralClass(THSTATE *pTHS, DSNAME *pDSName,ATTR *pAttr);
DWORD dbGetObjectAuxiliaryClass(THSTATE *pTHS, DSNAME *pDSName,ATTR *pAttr);

DWORD
dbGetSDRightsEffective (
        THSTATE *pTHS,
        DBPOS   *pDB,
        DSNAME *pDSName,
        ATTR   *pAttr
        );
DWORD
dbGetUserAccountControlComputed(
        THSTATE *pTHS,
        DSNAME  * pObjDSName,
        ATTR    *pAttr);
DWORD
dbGetApproxSubordinates(THSTATE * pTHS,
                        DSNAME  * pObjDSName,
                        ATTR    * pAttr);
/* End of forward declarations */

DWORD
dbGetConstructedAtt(
    DBPOS **ppDB,
    ATTCACHE *pAC,
    ATTR *pAttr,
    DWORD dwBaseIndex,
    PDWORD pdwNumRequested,
    BOOL fExternal
)

/*+++

  Routine Description:
     Compute the value of the constructed att pointed to by the attcache pAC

  Arguments:
     ppDB - pointer to DBPOS positioned on current object
     pAC - attcache for the constructed att
     pAttr - Pointer to ATTR to fill up with the value(s). The ATTR
             structure must be pre-allocated, The routines will allocate
             (THAllocEx) space for values as necessary
     fExternal - If the internal or external form of the value is wanted
                 This is relevant only for the constructed att
                 subschemasubentry which has a DS-DN syntax; for all
                 else the internal and external forms are the same and
                 the flag is ignored
  Return Value:
     0 on success, DB_ERR_NO_VALUE on success with no values to return,
     a DB ERROR on error

---*/

{
    DBPOS    *pDB = (*ppDB);
    THSTATE  *pTHS;
    ULONG     len;
    DWORD     err = 0;
    DSNAME   *pObjDSName;

    pTHS = pDB->pTHS;

    // Get the DSNAME
    err = DBGetAttVal(pDB, 1, ATT_OBJ_DIST_NAME,
                      DBGETATTVAL_fREALLOC,
                      0,
                      &len,
                      (UCHAR **) &pObjDSName);
    if (err) {
         DPRINT1(0,"dbGetConstructedAtt: Error getting obj-dist-name %x\n",
                 err);
         return err;
    }

    // see if it is the subschemasubentry. If so, go to
    // routine to get subschemasubentry atts

    if(pDB->DNT == gAnchor.ulDntLdapDmd) {
        err = dbGetSubschemaAtt(pTHS, pAC, pAttr);
        return err;
    }

    // ok it is a normal object
    // Check what attribute is wanted and call apprrpriate
    // routine
    DPRINT2(1, "{BASE=%ws}{ATTRID=%x}\n", pObjDSName->StringName, pAC->id);
    switch (pAC->id) {
    case ATT_SUBSCHEMASUBENTRY:
        err = dbGetSubSchemaSubEntry(pTHS, pAttr, fExternal);
        break;
    case ATT_CANONICAL_NAME:
        err = dbGetCanonicalName(pTHS, pObjDSName, pAttr);
        break;
    case ATT_ALLOWED_CHILD_CLASSES:
        err = dbGetAllowedChildClasses(pTHS, pObjDSName, pAttr, 0);
        break;
    case ATT_SD_RIGHTS_EFFECTIVE:
        err = dbGetSDRightsEffective(pTHS,
                                     pDB,
                                     pObjDSName,
                                     pAttr);
        break;
    case ATT_ALLOWED_CHILD_CLASSES_EFFECTIVE:
        err = dbGetAllowedChildClasses(pTHS,
                                       pObjDSName,
                                       pAttr,
                                       SC_CHILDREN_USE_SECURITY);
        break;
    case ATT_ALLOWED_ATTRIBUTES:
        err = dbGetAllowedAttributes(pTHS, pObjDSName, pAttr, FALSE);
        break;
    case ATT_ALLOWED_ATTRIBUTES_EFFECTIVE:
        err = dbGetAllowedAttributes(pTHS, pObjDSName, pAttr, TRUE);
        break;

    case ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS_BINARY:
    case ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS_BINARY:
    case ATT_MS_DS_NC_REPL_CURSORS_BINARY:
    case ATT_MS_DS_REPL_ATTRIBUTE_META_DATA_BINARY:
    case ATT_MS_DS_REPL_VALUE_META_DATA_BINARY:
        DPRINT (1, "Getting BINARY repl attrs\n");
        DPRINT3(1, "dbGetConstructedAtt = %x %d-%d\n", pAC->id, dwBaseIndex, *pdwNumRequested);
        err = draGetLdapReplInfo(pTHS,
                                 pAC->aliasID,
                                 pObjDSName,
                                 dwBaseIndex,
                                 pdwNumRequested,
                                 FALSE,
                                 pAttr);
        if (pAttr) {
            pAttr->attrTyp = pAC->id;
        }

        break;

    case ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS:
    case ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS:
    case ATT_MS_DS_NC_REPL_CURSORS:
    case ATT_MS_DS_REPL_ATTRIBUTE_META_DATA:
    case ATT_MS_DS_REPL_VALUE_META_DATA:
        DPRINT (1, "Getting XML repl attrs\n");
        DPRINT3(1, "dbGetConstructedAtt = %x %d-%d\n", pAC->id, dwBaseIndex, *pdwNumRequested);
        err = draGetLdapReplInfo(pTHS,
                                 pAC->id,
                                 pObjDSName,
                                 dwBaseIndex,
                                 pdwNumRequested,
                                 TRUE,
                                 pAttr);
        break;
    case ATT_POSSIBLE_INFERIORS:
        err = dbGetAllowedChildClasses(pTHS,
            pObjDSName,
            pAttr,
            SC_CHILDREN_USE_GOVERNS_ID);
        break;
    case ATT_FROM_ENTRY:
        err = dbGetFromEntry(pDB, pAttr);
        break;
    case ATT_CREATE_TIME_STAMP:
        err = dbGetCreateTimeStamp(pDB, pAttr);
        break;
    case ATT_MODIFY_TIME_STAMP:
        err = dbGetModifyTimeStamp(pDB, pAttr);
        break;
    case ATT_TOKEN_GROUPS:
        err = dbGetReverseMemberships(pTHS, pObjDSName, pAttr,
                                      FLAG_NO_GC_NOT_ACCEPTABLE);

        // pTHS->pDB may have changed, make sure to send back the
        // correct pDB so that dbGetConstructdAtt doesn't choke
        // if there are other constructed atts to be computed after
        // this
        if ( (*ppDB) != pTHS->pDB) {
            (*ppDB) = pTHS->pDB;
        }
        break;
    case ATT_TOKEN_GROUPS_GLOBAL_AND_UNIVERSAL:
        // return global/universal sids as if this DC were in native mode
        err = dbGetReverseMemberships(pTHS, pObjDSName, pAttr,
                                        FLAG_NO_GC_NOT_ACCEPTABLE
                                      | FLAG_GLOBAL_AND_UNIVERSAL);

        // pTHS->pDB may have changed, make sure to send back the
        // correct pDB so that dbGetConstructdAtt doesn't choke
        // if there are other constructed atts to be computed after
        // this
        if ( (*ppDB) != pTHS->pDB) {
            (*ppDB) = pTHS->pDB;
        }
        break;
    case ATT_TOKEN_GROUPS_NO_GC_ACCEPTABLE:
        err = dbGetReverseMemberships(pTHS, pObjDSName, pAttr,
                                      FLAG_NO_GC_ACCEPTABLE);
        // pTHS->pDB may have changed, make sure to send back the
        // correct pDB so that dbGetConstructdAtt doesn't choke
        // if there are other constructed atts to be computed after
        // this
        if ( (*ppDB) != pTHS->pDB) {
            (*ppDB) = pTHS->pDB;
        }
        break;
    case ATT_PRIMARY_GROUP_TOKEN:
        err = dbGetGroupRid(pTHS, pObjDSName, pAttr);
        break;

    case ATT_STRUCTURAL_OBJECT_CLASS:
        err = dbGetObjectStructuralClass(pTHS, pObjDSName, pAttr);
        break;

    case ATT_MS_DS_AUXILIARY_CLASSES:
        err = dbGetObjectAuxiliaryClass(pTHS, pObjDSName, pAttr);
        break;

    case  ATT_MS_DS_USER_ACCOUNT_CONTROL_COMPUTED:
        err = dbGetUserAccountControlComputed( pTHS, pObjDSName, pAttr);
        break;

    case ATT_MS_DS_APPROX_IMMED_SUBORDINATES:
        err = dbGetApproxSubordinates(pTHS, pObjDSName, pAttr);
        break;

    default:
        // Check for EntryTTL. The Attid for EntryTTL may vary DC to DC
        // because its prefix is not one of the predefined prefixes
        // that were defined before shipping W2K (see prefix.h).
        // The attid for EntryTTL is set in the SCHEMAPTR when the
        // schema is loaded.
        if (pAC->id == ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->EntryTTLId) {
            err = dbGetEntryTTL(pDB, pAttr);
        } else {
            err = DB_ERR_NO_VALUE;
        }
    }
    if (err && err != DB_ERR_NO_VALUE) {
        DPRINT2(0,"Error finding constructed att %x: %x\n", pAC->id, err);
    }

    return err;
}

DWORD
dbGetSubschemaAtt(
    THSTATE *pTHS,
    ATTCACHE *pAC,
    ATTR *pAttr
)

/*+++

  Routine Description:
    Gets a constructed att for the subschemasubentry

  Arguments:
    pAC - AttCache of the constructed att
    pAttr - ATTR structure to fill up with the value(s)

  Return Value:
    0 on success, DB_ERR_NO_VALUE on succes with no values to return,
    a DB ERROR on failure

---*/

{
    ULONG err = 0;

   switch (pAC->id) {
     case ATT_OBJECT_CLASSES:
       err = dbGetObjectClasses(pTHS, pAttr, FALSE);
       break;
     case ATT_EXTENDED_CLASS_INFO:
       err = dbGetObjectClasses(pTHS, pAttr, TRUE);
       break;
     case ATT_ATTRIBUTE_TYPES:
       err = dbGetAttributeTypes(pTHS, pAttr, FALSE);
       break;
     case ATT_EXTENDED_ATTRIBUTE_INFO:
       err = dbGetAttributeTypes(pTHS, pAttr, TRUE);
       break;
     case ATT_DIT_CONTENT_RULES:
       err = dbGetDitContentRules(pTHS, pAttr, TRUE);
       break;
     case ATT_MODIFY_TIME_STAMP:
       err = dbGetSubSchemaModifyTimeStamp(pTHS, pAttr);
       break;
     default:
       err = DB_ERR_NO_VALUE;
   }

   return err;
}



/*+++

   The Routines below each compute a particular constructed att.

   They all return 0  on success, a DB ERROR on failure

---*/


DWORD
dbGetSubSchemaSubEntry(
    THSTATE *pTHS,
    ATTR *pAttr,
    BOOL fExternal
)

/*+++

   Compute the subschemasubentry attribute

---*/

{
    ULONG DNT = 0, len = gAnchor.pLDAPDMD->structLen;

    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, sizeof(ATTRVAL));
    if ( !fExternal ) {
       // they just want the DNT

       DBPOS *pDB;
       int err = 0;

       DBOpen2(FALSE, &pDB);
       __try {
           if( err = DBFindDSName(pDB, gAnchor.pLDAPDMD) ) {
               DPRINT(0, "Cannot find LDAP DMD in dit\n");
              __leave;
           }
           else {
             DNT = pDB->DNT;
           }
       }
       __finally {
           DBClose(pDB, FALSE);
       }
       if (err) {
          return err;  // this is already a DB ERROR
       }
       // no error, so we got a dnt.
       Assert(DNT);

       pAttr->AttrVal.pAVal[0].valLen = sizeof(ULONG);
       pAttr->AttrVal.pAVal[0].pVal = (PUCHAR) THAllocEx(pTHS, sizeof(ULONG));
       memcpy(pAttr->AttrVal.pAVal[0].pVal, &DNT, sizeof(ULONG));
    }
    else {
       // Send bak the DSNAME
       pAttr->AttrVal.pAVal[0].valLen = len;
       pAttr->AttrVal.pAVal[0].pVal = (PUCHAR) THAllocEx(pTHS, len);
       memcpy(pAttr->AttrVal.pAVal[0].pVal, gAnchor.pLDAPDMD, len);
    }

    return 0;
}

DWORD
dbGetCanonicalName(
    THSTATE *pTHS,
    DSNAME *pDSName,
    ATTR *pAttr
)

/*+++

   Compute the canonical name

---*/

{
    WCHAR       *pNameString[1];
    WCHAR       *pName;
    PDS_NAME_RESULTW pResults = NULL;
    DWORD       err = 0, NameSize;

    // turn the DS name into a canonical name

    pNameString[0] = (WCHAR *)&(pDSName->StringName);

    err = DsCrackNamesW( (HANDLE) -1,
                         (DS_NAME_FLAG_PRIVATE_PURE_SYNTACTIC |
                             DS_NAME_FLAG_SYNTACTICAL_ONLY),
                         DS_FQDN_1779_NAME,
                         DS_CANONICAL_NAME,
                         1,
                         pNameString,
                         &pResults);

    if ( err                                // error from the call
          || !(pResults->cItems)            // no items returned
          || (pResults->rItems[0].status)   // DS_NAME_ERROR returned
          || !(pResults->rItems[0].pName)   // No name returned
       ) {

        DPRINT(0,"dbGetCanonicalName: error cracking name\n");
        if (pResults) {
           DsFreeNameResultW(pResults);
        }
        return DB_ERR_UNKNOWN_ERROR;
    }

    pName = pResults->rItems[0].pName;
    NameSize = sizeof(WCHAR) * wcslen(pName);

    // Ok, put it in the ATTR structure.
    // Allocate memory from thread heap and copy

    pAttr->AttrVal.valCount = 1;

    // Do the following in try-finally so that we can free pResults
    // even if THAllocEx excepts

    __try {
       pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, sizeof(ATTRVAL));
       pAttr->AttrVal.pAVal[0].valLen = NameSize;
       pAttr->AttrVal.pAVal[0].pVal = (PUCHAR) THAllocEx(pTHS, NameSize);
       memcpy(pAttr->AttrVal.pAVal[0].pVal, pName, NameSize);
    }
    __finally {
       DsFreeNameResultW(pResults);
       pResults = NULL;
    }


    return 0;
}



DWORD
dbGetSDRightsEffective (
        THSTATE *pTHS,
        DBPOS   *pDB,
        DSNAME *pDSName,
        ATTR   *pAttr
        )
/*+++

  Compute the allowed access to the SD on this object.

---*/

{
    PSECURITY_DESCRIPTOR pNTSD = NULL;
    DWORD                cbAllocated, cbUsed;
    OBJECT_TYPE_LIST     objList[1];
    DWORD                dwResults[1];
    ATTRTYP              classId;
    CLASSCACHE          *pCC;
    ULONG                error;
    ULONG                SecurityInformation = 0;

    // Get the SD from the current object.
    error = DBGetAttVal(pDB, 1, ATT_NT_SECURITY_DESCRIPTOR, 0, 0, &cbUsed, (UCHAR**) &pNTSD);
    if (error) {
        // Some error we don't handle.  Raise the same exception
        // JetRetrieveColumnSuccess raises.
        RaiseDsaExcept(DSA_DB_EXCEPTION,
                       error,
                       0,
                       DSID(FILENO,__LINE__),
                       DS_EVENT_SEV_MINIMAL);
    }

    cbUsed = 0;
    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl,objclassid,
                             &classId, sizeof(classId), &cbUsed, 0, NULL);

    pCC = SCGetClassById(pTHS, classId);

    // Now, create the list
    objList[0].Level = ACCESS_OBJECT_GUID;
    objList[0].Sbz = 0;
    objList[0].ObjectType = &(pCC->propGuid);

    // Check access in this Security descriptor. If an error occurs during
    // the process of checking permission access is denied.

    dwResults[0] = 0;
    error = CheckPermissionsAnyClient(
            pNTSD,                      // security descriptor
            pDSName,                    // DSNAME of the object
            WRITE_DAC,
            objList,                    // Object Type List
            1,
            NULL,
            dwResults,
            CHECK_PERMISSIONS_WITHOUT_AUDITING,
            NULL                        // authz client context (grab from THSTATE)
            );

    if(error) {
        THFreeEx(pTHS,pNTSD);
        DPRINT2(1,
                "CheckPermissions returned %d. Access = %#08x denied.\n",
                error,
                WRITE_DAC);

        LogEvent(DS_EVENT_CAT_SECURITY,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_SECURITY_CHECKING_ERROR,
                 szInsertUL(error),
                 NULL,
                 NULL);


        return ERROR_DS_SECURITY_CHECKING_ERROR;         // All Access Denied
    }
    if(dwResults[0] == 0) {
        SecurityInformation |= DACL_SECURITY_INFORMATION;
    }

    dwResults[0] = 0;
    error = CheckPermissionsAnyClient(
            pNTSD,                      // security descriptor
            pDSName,                    // DSNAME of the object
            WRITE_OWNER,
            objList,                    // Object Type List
            1,
            NULL,
            dwResults,
            CHECK_PERMISSIONS_WITHOUT_AUDITING,
            NULL                        // authz client context (grab from THSTATE)
            );

    if(error) {
        THFreeEx(pTHS,pNTSD);
        DPRINT2(1,
                "CheckPermissions returned %d. Access = %#08x denied.\n",
                error,
                WRITE_OWNER);

        LogEvent(DS_EVENT_CAT_SECURITY,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_SECURITY_CHECKING_ERROR,
                 szInsertUL(error),
                 NULL,
                 NULL);


        return ERROR_DS_SECURITY_CHECKING_ERROR;         // All Access Denied
    }
    if(dwResults[0] == 0) {
        SecurityInformation |= (OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION  );
    }

    dwResults[0] = 0;
    error = CheckPermissionsAnyClient(
            pNTSD,                      // security descriptor
            pDSName,                    // DSNAME of the object
            ACCESS_SYSTEM_SECURITY,
            objList,                    // Object Type List
            1,
            NULL,
            dwResults,
            CHECK_PERMISSIONS_WITHOUT_AUDITING,
            NULL                        // authz client context (grab from THSTATE)
            );

    THFreeEx(pTHS,pNTSD);
    if(error) {
        DPRINT2(1,
                "CheckPermissions returned %d. Access = %#08x denied.\n",
                error,
                ACCESS_SYSTEM_SECURITY);

        LogEvent(DS_EVENT_CAT_SECURITY,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_SECURITY_CHECKING_ERROR,
                 szInsertUL(error),
                 NULL,
                 NULL);


        return ERROR_DS_SECURITY_CHECKING_ERROR;         // All Access Denied
    }
    if(dwResults[0] == 0) {
        SecurityInformation |= SACL_SECURITY_INFORMATION;
    }

    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
    pAttr->AttrVal.pAVal->pVal = (PUCHAR) THAllocEx(pTHS, sizeof(ULONG));
    *((PULONG)(pAttr->AttrVal.pAVal->pVal)) = SecurityInformation;

    return 0;
}


DWORD
dbGetGroupRid(
    THSTATE *pTHS,
    DSNAME *pDSName,
    ATTR *pAttr
)

/*+++

   Return the Rid of the group

   Return Values:

   0 on success,  DB_ERR_NO_VALUE on succes with no values to return,
   a DB_ERR on failure.

---*/
{

   DBPOS *pDB = pTHS->pDB;
   ULONG i, err = 0, objClass, objRid, cbSid = 0;
   NT4SID domSid, *pSid = NULL;
   CLASSCACHE *pCC;
   BOOL fGroup = FALSE;

   // check if this is indeed a group
   err = DBGetSingleValue(pDB,
                          ATT_OBJECT_CLASS,
                          &objClass,
                          sizeof(objClass),
                          NULL);

   if (err) {
       DPRINT1(0,"dbGetGroupRid: Error retrieving object class %d \n", err);
       return err;
   }

   if (objClass != CLASS_GROUP) {

       // not a Group directly, Check if it inherits from group
       pCC = SCGetClassById(pTHS, objClass);
       if (!pCC) {
           // Unable to get class schema!
           DPRINT1(0,"dbGetGroupRid: Unable to retrieve class cache for class %d", objClass);
           LogUnhandledError(ERROR_DS_OBJECT_CLASS_REQUIRED);
           return DB_ERR_UNKNOWN_ERROR;
       }

       // check if any of the subClassOf values is CLASS_GROUP
       for (i=0; i<pCC->SubClassCount; i++) {
          if ( (pCC->pSubClassOf)[i] == CLASS_GROUP ) {
             fGroup = TRUE;
             break;
          }
       }
   }
   else {
       fGroup = TRUE;
   }

   if (!fGroup) {
      // can query only on a group
      return DB_ERR_NO_VALUE;
   }

   // ok, it is a group. Get the object sid

   err = DBGetAttVal(
                pTHS->pDB,
                1,
                ATT_OBJECT_SID,
                DBGETATTVAL_fREALLOC,
                0,
                &cbSid,
                (PUCHAR *) &pSid);

   if (err) {
       DPRINT1(0,"dbGetGroupRid: Error retrieving object sid %d \n", err);
       return err;
   }

   SampSplitNT4SID(pSid, &domSid, &objRid);

   pAttr->AttrVal.valCount = 1;
   pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx(pTHS, sizeof(ATTRVAL));
   pAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
   pAttr->AttrVal.pAVal->pVal = (PUCHAR)THAllocEx(pTHS, sizeof(ULONG));
   memcpy(pAttr->AttrVal.pAVal->pVal, &objRid, sizeof(ULONG));

   return 0;
}

DWORD
dbGetObjectStructuralClass(
    THSTATE *pTHS,
    DSNAME *pDSName,
    ATTR *pAttr)
/*++

   return the structuralObjectClass for the object

   Return Values:

   0 on success,  DB_ERR_NO_VALUE on success with no values to return,
   a DB_ERR on failure.

---*/
{
    DWORD err;
    CLASSCACHE *pCC;
    DWORD  classId;
    DWORD cntClasses, i;

    if ( (err = DBGetSingleValue (pTHS->pDB, ATT_OBJECT_CLASS, &classId, sizeof (classId), NULL)) ||
         !(pCC = SCGetClassById(pTHS, classId)) ) {

        return SetSvcError(SV_PROBLEM_DIR_ERROR,
                           ERROR_DS_MISSING_EXPECTED_ATT);
    }

    pAttr->AttrVal.valCount = cntClasses = pCC->SubClassCount+1;
    pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx(pTHS, cntClasses * sizeof(ATTRVAL));

    pAttr->AttrVal.pAVal[0].valLen = sizeof (classId);
    pAttr->AttrVal.pAVal[0].pVal = THAllocEx (pTHS, sizeof (classId));
    *((DWORD *)pAttr->AttrVal.pAVal[0].pVal) = classId;

    for (i=0; i<pCC->SubClassCount; i++) {
        pAttr->AttrVal.pAVal[i+1].valLen = sizeof (classId);
        pAttr->AttrVal.pAVal[i+1].pVal = THAllocEx (pTHS, sizeof (classId));
        *((DWORD *)pAttr->AttrVal.pAVal[i+1].pVal) = pCC->pSubClassOf[i];
    }

    return 0;
}

DWORD
dbGetObjectAuxiliaryClass(
    THSTATE *pTHS,
    DSNAME *pDSName,
    ATTR *pAttr)
/*++

   return the auxiliaryClasses for the object

   Return Values:

   0 on success,  DB_ERR_NO_VALUE on success with no values to return,
   a DB_ERR on failure.

---*/

{
    DWORD          err;
    CLASSCACHE    *pCC;
    DWORD          classId;
    DWORD          cntClasses, i, k;
    ATTCACHE      *pObjclassAC = NULL;
    ATTRTYP       *pObjClasses = NULL;
    DWORD          cObjClasses, cObjClasses_alloced;


    // get the needed information for the objectClass on this object
    if (! (pObjclassAC = SCGetAttById(pTHS, ATT_OBJECT_CLASS)) ) {
        return SetSvcError(SV_PROBLEM_DIR_ERROR,
                           DIRERR_MISSING_EXPECTED_ATT);
        // Bad error, couldn't get objectClass .
    }

    cObjClasses_alloced = 0;

    if (ReadClassInfoAttribute (pTHS->pDB,
                                pObjclassAC,
                                &pObjClasses,
                                &cObjClasses_alloced,
                                &cObjClasses,
                                NULL) ) {
        return pTHS->errCode;
    }

    if (!cObjClasses) {
        return SetSvcError(SV_PROBLEM_DIR_ERROR,
                           DIRERR_MISSING_EXPECTED_ATT);
        // Bad error, couldn't get class data.
    }

    classId = pObjClasses[0];
    if (! (pCC = SCGetClassById(pTHS, classId)) ) {
        return SetSvcError(SV_PROBLEM_DIR_ERROR,
                           DIRERR_MISSING_EXPECTED_ATT);
        // Bad error, couldn't get objectClass .
    }

    // no auxClasses
    if ((pCC->SubClassCount+1) == cObjClasses) {
        return DB_ERR_NO_VALUE;
    }

    // ok, construct a valid response
    pAttr->AttrVal.valCount = cntClasses = cObjClasses-pCC->SubClassCount-1;
    pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx(pTHS, cntClasses * sizeof(ATTRVAL));

    for (k=0, i=pCC->SubClassCount; i<(cObjClasses-1); i++, k++) {
        pAttr->AttrVal.pAVal[k].valLen = sizeof (classId);
        pAttr->AttrVal.pAVal[k].pVal = THAllocEx (pTHS, sizeof (classId));
        *((DWORD *)pAttr->AttrVal.pAVal[k].pVal) = pObjClasses[i];
    }

    return 0;
}

DWORD
dbGetAllowedChildClasses(
    THSTATE *pTHS,
    DSNAME *pDSName,
    ATTR *pAttr,
    DWORD flag
)

/*+++

   Compute allowedChildClasses, allowedChildClassesEffective, and
   possibleInferiors. Which one is computed depends on the value of
   flag passed in

   Return Values:

     0                  - success
     DB_ERR_NO_VALUE    - success but no values to return.

     Anything else is an error.

---*/

{
    ULONG        count=0, err = 0, i;
    CLASSCACHE   **pCCs;

    // make the call to get legal children
    err = SCLegalChildrenOfName(
                    pDSName,
                    flag,
                    &count,
                    &pCCs);

    if (err) {
       DPRINT1(0,"dbGetAllowedChildClasses: Error from SCLegalChildrenOfName %x\n", err);

       // If we are searching for possibleInferiors, which is defined only
       // on class-schema objects, return as if no value. Anything else
       // is an unknown error (exactly what we do in ldap head now)

       if (flag & SC_CHILDREN_USE_GOVERNS_ID) {
         // set count to 0 and do nothing
         count = 0;
       }
       else {
         return DB_ERR_UNKNOWN_ERROR;
       }
    }

    if (count) {
       // fill up the ATTR structure with the values
       // This is an OID-valued attribute, so just put in the class id

       pAttr->AttrVal.valCount = count;
       pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, count*sizeof(ATTRVAL));
       for (i=0; i<count; i++) {
          pAttr->AttrVal.pAVal[i].valLen = sizeof(ULONG);
          pAttr->AttrVal.pAVal[i].pVal = (PUCHAR) THAllocEx(pTHS, sizeof(ULONG));
          memcpy(pAttr->AttrVal.pAVal[i].pVal, &((*pCCs)->ClassId), sizeof(ULONG));
          pCCs++;
       }
    }
    else {
         // no values
        return DB_ERR_NO_VALUE;
    }
    return 0;
}



DWORD
dbGetAllowedAttributes(
    THSTATE *pTHS,
    DSNAME *pDSName,
    ATTR *pAttr,
    BOOL fSecurity
)

/*+++

   Compute allowedAttributes and allowedAttributesEffective
   Which one is computed depends on the value of fSecurity passed in

   Return Values:

     0                  - success
     DB_ERR_NO_VALUE    - success but no values to return.

     Anything else is an error.

---*/

{
    ULONG      count=0, err = 0, i;
    ATTCACHE   **pACs;

    // make the call to get legal children
    err = SCLegalAttrsOfName(
                    pDSName,
                    fSecurity,
                    &count,
                    &pACs);

    if (err) {
       DPRINT1(0,"dbGetAllowedAttributes: Error from SCLegalAttrsOfName %x\n", err);
       return DB_ERR_UNKNOWN_ERROR;
    }

    if (count) {
       // Fill up the ATTR structure with the values
       // This is an OID-valued attribute, so just return the att id

       pAttr->AttrVal.valCount = count;
       pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, count*sizeof(ATTRVAL));
       for (i=0; i<count; i++) {
          pAttr->AttrVal.pAVal[i].valLen = sizeof(ULONG);
          pAttr->AttrVal.pAVal[i].pVal = (PUCHAR) THAllocEx(pTHS, sizeof(ULONG));
          memcpy(pAttr->AttrVal.pAVal[i].pVal, &((*pACs)->id), sizeof(ULONG));
          pACs++;
       }
    }
    else {
        // no values
        return DB_ERR_NO_VALUE;
    }
    return 0;
}


DWORD
dbGetFromEntry(
    DBPOS *pDB,
    ATTR *pAttr
)

/*+++

  Compute fromEntry

---*/

{
    THSTATE  *pTHS=pDB->pTHS;
    ULONG iType, err=0;
    BOOL fromEntry;

    err = DBGetSingleValue(pDB,
                        ATT_INSTANCE_TYPE,
                        &iType,
                        sizeof(iType),
                        NULL);
    if (err) {
        DPRINT(0, "Can't retrieve instance type\n");
        return err;
    }
    if(iType & IT_WRITE) {
      fromEntry = TRUE;
    }
    else {
      fromEntry = FALSE;
    }

    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal[0].valLen = sizeof(BOOL);
    pAttr->AttrVal.pAVal[0].pVal = THAllocEx(pTHS, sizeof(BOOL));
    memcpy(pAttr->AttrVal.pAVal[0].pVal, &fromEntry, sizeof(BOOL));

    return 0;
}

DWORD
dbGetCreateTimeStamp(
    DBPOS *pDB,
    ATTR *pAttr
)

/*+++

  Compute createTimeStamp (the value of ATT_WHEN_CREATED)

---*/
{
    THSTATE  *pTHS=pDB->pTHS;
    DSTIME createTime;
    ULONG err=0;

    err = DBGetSingleValue(pDB,
                        ATT_WHEN_CREATED,
                        &createTime,
                        sizeof(createTime),
                        NULL);
    if (err) {
        // WHEN_CREATED must be there
        DPRINT(0, "Can't retrieve when_created\n");
        return err;
    }

    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx(pTHS, sizeof(ATTRVAL ));
    pAttr->AttrVal.pAVal->valLen = sizeof(DSTIME);
    pAttr->AttrVal.pAVal->pVal = (PUCHAR)THAllocEx(pTHS, sizeof(DSTIME));
    memcpy(pAttr->AttrVal.pAVal->pVal, &createTime, sizeof(DSTIME));

    return 0;
}

DWORD
dbGetEntryTTL(
    DBPOS *pDB,
    ATTR *pAttr
)

/*+++

  Compute EntryTTL (the value of ATT_MS_DS_ENTRY_TIME_TO_DIE)

---*/
{
    THSTATE *pTHS=pDB->pTHS;
    DSTIME  TimeToDie;
    LONG    Secs;
    ULONG   err=0;

    err = DBGetSingleValue(pDB,
                           ATT_MS_DS_ENTRY_TIME_TO_DIE,
                           &TimeToDie,
                           sizeof(TimeToDie),
                           NULL);
    if (err) {
        // ATT_MS_DS_ENTRY_TIME_TO_DIE not present
        return err;
    }

    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx(pTHS, sizeof(ATTRVAL ));
    pAttr->AttrVal.pAVal->valLen = sizeof(LONG);
    pAttr->AttrVal.pAVal->pVal = (PUCHAR)THAllocEx(pTHS, sizeof(DSTIME));
    TimeToDie -= DBTime();
    if (TimeToDie < 0) {
        // object expired some time ago
        Secs = 0;
    } else if (TimeToDie > MAXLONG) {
        // object will expire in the far distant future
        Secs = MAXLONG;
    } else {
        // object will expire later
        Secs = (LONG)TimeToDie;
    }
    memcpy(pAttr->AttrVal.pAVal->pVal, &Secs, sizeof(LONG));

    return 0;
}


DWORD
dbGetModifyTimeStamp(
    DBPOS *pDB,
    ATTR *pAttr
)

/*+++

  Compute modifyTimeStamp (the value of ATT_WHEN_CHANGED)

---*/
{

    THSTATE  *pTHS=pDB->pTHS;
    DSTIME changeTime;
    ULONG err=0;

    err = DBGetSingleValue(pDB,
                        ATT_WHEN_CHANGED,
                        &changeTime,
                        sizeof(changeTime),
                        NULL);
    if (err) {
        // WHEN_CHANGED must be there
        DPRINT(0, "Can't retrieve when_changed\n");
        return err;
    }

    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx(pTHS, sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal->valLen = sizeof(DSTIME);
    pAttr->AttrVal.pAVal->pVal = (PUCHAR)THAllocEx(pTHS, sizeof(DSTIME));
    memcpy(pAttr->AttrVal.pAVal->pVal, &changeTime, sizeof(DSTIME));

    return 0;
}

DWORD
dbGetReverseMemberships(
    THSTATE *pTHS,
    DSNAME *pObj,
    ATTR *pAttr,
    ULONG Flag
)

/*+++

  Compute the transitive reverse membership of an user object

    Return Values:

    0                - success
    DB_ERR_NO_VALUE  - success but no values to return

    DB_ERR_*         - failure

---*/
{
    ULONG err, cSid, len, sidLen, i;
    ULONG dntSave;
    PSID *pSid = NULL;
    NTSTATUS status;
    ULONG SamFlags;
    BOOLEAN MixedDomain;

    ULONG iClass;

    CLASSCACHE *pCC;
    ATTRTYP attrType;

    // Make the sam call to get the reverse memberships

    // This is never called from SAM. If it ever changes, the assert
    // below may be hit, in which case we should save and restore
    // the correct values

    Assert(!pTHS->fSAM && !pTHS->fDSA);
    Assert(!pTHS->fSamDoCommit);


    // Check to see if this is referenced by SAM.
    // if it is not, return before closing/starting a transaction

    if ( 0 == DBGetSingleValue(
                    pTHS->pDB,
                    ATT_OBJECT_CLASS,
                    &attrType,
                    sizeof(attrType),
                    NULL) )
    {
        if ( !(pCC = SCGetClassById(pTHS, attrType)) )
        {
            // Failed to get the class cache pointer.
            LogUnhandledError(DIRERR_OBJECT_CLASS_REQUIRED);

            return DB_ERR_UNKNOWN_ERROR;
        }
    }
    else {
        // Failed to get the object class
        LogUnhandledError(DIRERR_OBJECT_CLASS_REQUIRED);

        return DB_ERR_UNKNOWN_ERROR;
    }


    if (!SampSamClassReferenced (pCC, &iClass)) {
        return DB_ERR_NO_VALUE;
    }


    // Note that we allow this attribute only on base searches.
    // Also, all non-constructed atts are already evaluated
    // (constructed atts are evalauted last), so the currency may be
    // needed after we come back for other constructed atts only

    dntSave = pTHS->pDB->DNT;

    // Assert that we have a read-only transaction, since we
    // will close the transaction before making the SAM call (which
    // may have to go off machine), and SAM will reopen a read-only
    // transaction that we may use later

    Assert(pTHS->transType == SYNC_READ_ONLY);
    Assert(!pTHS->errCode);
    // SampGetGroupsForToken closes any open transactions with a DBClose, so
    // do a _CLEAN_BEFORE_RETURN here to match the routine that started
    // the transaction
    _CLEAN_BEFORE_RETURN(pTHS->errCode, FALSE);

    // SampGetGroupsForToken assumes an open transaction.
    DBOpen(&pTHS->pDB);
    __try {
        // Return global/universal sids as if this DC were in native mode
        if (Flag & FLAG_GLOBAL_AND_UNIVERSAL) {
            SamFlags = 0;
        } else {
            // When in mixed mode, return the sids as if this were an NT4 DC
            status = SamIMixedDomain2(&gAnchor.pDomainDN->Sid,
                                      &MixedDomain);
            if (!NT_SUCCESS(status)) {
                __leave;
            }
            if (MixedDomain) {
                SamFlags = SAM_GET_MEMBERSHIPS_TWO_PHASE | SAM_GET_MEMBERSHIPS_MIXED_DOMAIN;
            } else {
                SamFlags = SAM_GET_MEMBERSHIPS_TWO_PHASE;
            }
        }
        status = SampGetGroupsForToken(pObj,
                                       SamFlags,
                                      &cSid,
                                      &pSid);
    }
    __finally {
       // Reset certain values set by the transaction opened by Sam
       // so that we have a non-sam transaction
       pTHS->fSamDoCommit = FALSE;
       pTHS->fSAM = FALSE;
       pTHS->fDSA = FALSE;
       if (pTHS->pDB) {
           DBClose(pTHS->pDB, TRUE);
       }
    }

    // Make sure to reopen a read transaction if none exists so
    // that we can restore currency in case we need to for other
    // constructed atts and so that CLEAN_RETURN in dirsearch will
    // not complain
    if (pTHS->pDB == NULL) {
        SYNC_TRANS_READ();
    }

    // At this point, if the call was successful, we should have a
    // transaction opened by SAM (or by the code above).

    if (NT_SUCCESS(status)) {
       Assert(pTHS->pDB && (pTHS->transType == SYNC_READ_ONLY));
       if (status == STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY) {
          // cannot go to a gc to evaluate universal group
          // memberships, but otherwise succeeded.
          // Return error based on what the user asked for
          if (Flag & FLAG_NO_GC_NOT_ACCEPTABLE) {
             // not acceptable, return error
             return DB_ERR_UNKNOWN_ERROR;
          }
       }
    }
    else {
        return DB_ERR_UNKNOWN_ERROR;
    }

    // restore currency
    DBFindDNT(pTHS->pDB, dntSave);

    // Send the values back
    pAttr->AttrVal.valCount = cSid;
    pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, cSid*sizeof(ATTRVAL));
    for (i=0; i< cSid; i++) {
        sidLen = RtlLengthSid(pSid[i]);
        pAttr->AttrVal.pAVal[i].valLen = sidLen;
        pAttr->AttrVal.pAVal[i].pVal = (PUCHAR) THAllocEx(pTHS, sidLen);
        memcpy(pAttr->AttrVal.pAVal[i].pVal, pSid[i], sidLen);
    }

    // free the sam-allocated sid array. The individual sids are
    // THAlloc'ed, so no need to free them explicitly
    if (cSid) {
        // at least one sid returned, so something allocated
        Assert(pSid);
        THFreeEx(pTHS, pSid);
    } else {
        return DB_ERR_NO_VALUE;
    }

    return 0;
}



DWORD
dbGetObjectClasses(
    THSTATE *pTHS,
    ATTR *pAttr,
    BOOL bExtendedFormat
)

/*+++

  Compute the objectClasses and extendedClassInfo attributes
  of subschemasubentry

---*/

{
   ULONG err = 0, count = 0, i;
   CLASSCACHE           **pCCs, *pCC;

   err = SCEnumNamedClasses(&count,&pCCs);
   if (err) {
      DPRINT1(0,"scGetObjectClasses: SCEnumNamedClasses failed: %x\n",err);
      return DB_ERR_UNKNOWN_ERROR;
   }

   pAttr->AttrVal.valCount = count;
   pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, count*sizeof(ATTRVAL));

   for(i=0; i<count; i++) {
       // for each class cache, convert to the appropriate
       // unicode string value

       err = dbClassCacheToObjectClassDescription (
                        pTHS,
                        *pCCs,
                        bExtendedFormat,
                        &(pAttr->AttrVal.pAVal[i]));
       if (err) {
          DPRINT1(0,"dbGetObjectClasses: Failed to convert class caches: %x\n", err);
          return DB_ERR_UNKNOWN_ERROR;
       }
       pCCs++;
    }

    return 0;
}



DWORD
dbGetAttributeTypes(
    THSTATE *pTHS,
    ATTR *pAttr,
    BOOL bExtendedFormat
)

/*+++

  Compute the attributeTypes and extendedattributeInfo attributes
  of subschemasubentry

---*/

{
   ULONG err = 0, count = 0, i;
   ATTCACHE             **pACs;

   err = SCEnumNamedAtts(&count,&pACs);
   if (err) {
      DPRINT1(0,"scGetAttributeTypes: SCEnumNamedAtts failed: %x\n",err);
      return DB_ERR_UNKNOWN_ERROR;
   }

   pAttr->AttrVal.valCount = count;
   pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, count*sizeof(ATTRVAL));

   for(i=0; i<count; i++) {
       // for each attcache, convert to appropriate
       // unicode string value

       err = dbAttCacheToAttributeTypeDescription (
                        pTHS,
                        *pACs,
                        bExtendedFormat,
                        &(pAttr->AttrVal.pAVal[i]));
       if (err) {
          DPRINT1(0,"dbGetAttributeTypes: Failed to convert att caches: %x\n",
err);
          return DB_ERR_UNKNOWN_ERROR;
       }
       pACs++;
    }

    return 0;
}



DWORD
dbGetDitContentRules(
    THSTATE *pTHS,
    ATTR *pAttr,
    BOOL bExtendedFormat
)

/*+++

  Compute the ditContentRule attributes of subschemasubentry

---*/

{
   ULONG        err = 0, count = 0, valCount = 0, i, auxCount;
   CLASSCACHE  **pCCs, *pCC, **pAuxCCs;
   PWCHAR       pAuxBuff = NULL;
   DWORD        cAuxBuff = 0;
   SCHEMAPTR   *pSchemaPtr;

   pSchemaPtr = (SCHEMAPTR*)(pTHS->CurrSchemaPtr);

   if (!pSchemaPtr->pDitContentRules) {
       EnterCriticalSection(&csDitContentRulesUpdate);
       __try {
           if (!pSchemaPtr->pDitContentRules) {

               DPRINT (1, "Calculating ditContentRules\n");

               err = SCEnumNamedClasses(&count,&pCCs);
               if (err) {
                  DPRINT1(0,"scGetDitContentRules: SCEnumNamedClasses failed: %x\n",err);
                  err = DB_ERR_UNKNOWN_ERROR;
                  __leave;
               }

               err = SCEnumNamedAuxClasses(&auxCount, &pAuxCCs);
               if (err) {
                  DPRINT1(0,"scGetDitContentRules: SCEnumNamedAuxClasses failed: %x\n",err);
                  err = DB_ERR_UNKNOWN_ERROR;
                  __leave;
               }


               if (count) {
                   // allocate memory for max
                   pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS, count*sizeof(ATTRVAL));

                  // Ok, we have at least one value to return.
                  // We may not have something to return for all remaining classes,
                  // so count may not be the actual no.of values returned. We will
                  // allocate memory for max though.


                  for(i=0; i<count; i++) {

                      err = dbClassCacheToDitContentRules(
                                       pTHS,
                                       *pCCs,
                                       bExtendedFormat,
                                       pAuxCCs,
                                       auxCount,
                                       &(pAttr->AttrVal.pAVal[valCount]));

                      if (err) {
                         DPRINT1(0,"dbGetDitContentRules: Failed to convert class caches: %x\n", err);
                         err = DB_ERR_UNKNOWN_ERROR;
                         __leave;
                      }

                      valCount++;
                      pCCs++;
                  }

                  pAttr->AttrVal.valCount = valCount;
                }
                else {
                  // no values to return

                  pAttr->AttrVal.valCount = 0;
                  pAttr->AttrVal.pAVal = NULL;
                }

                if (SCCallocWrn(&pSchemaPtr->pDitContentRules, 1, sizeof (ATTRVALBLOCK))) {
                    err = DB_ERR_UNKNOWN_ERROR;
                    __leave;
                }

                pSchemaPtr->pDitContentRules->valCount = pAttr->AttrVal.valCount;

                if (pAttr->AttrVal.valCount) {
                    if (SCCallocWrn(&pSchemaPtr->pDitContentRules->pAVal,
                        pAttr->AttrVal.valCount, sizeof(ATTRVAL))) {
                        SCFree(&pSchemaPtr->pDitContentRules);
                        err = DB_ERR_UNKNOWN_ERROR;
                        __leave;
                    }

                    for (i=0; i<pAttr->AttrVal.valCount; i++) {
                        if (SCCallocWrn(&pSchemaPtr->pDitContentRules->pAVal[i].pVal,
                                     1, pAttr->AttrVal.pAVal[i].valLen)) {
                            err = DB_ERR_UNKNOWN_ERROR;
                            __leave;
                        }
                        pSchemaPtr->pDitContentRules->pAVal[i].valLen =
                            pAttr->AttrVal.pAVal[i].valLen;
                        memcpy(pSchemaPtr->pDitContentRules->pAVal[i].pVal,
                               pAttr->AttrVal.pAVal[i].pVal,
                               pAttr->AttrVal.pAVal[i].valLen);
                    }
                }
           }

       }
       __finally {
          LeaveCriticalSection(&csDitContentRulesUpdate);
       }
   }

   if (!err && pSchemaPtr->pDitContentRules) {
       DPRINT (1, "Using cached ditContentRules\n");

       if (pSchemaPtr->pDitContentRules->valCount) {
           pAttr->AttrVal.pAVal =
               THAllocEx(pTHS,
                         pSchemaPtr->pDitContentRules->valCount * sizeof(ATTRVAL));

           pAttr->AttrVal.valCount = pSchemaPtr->pDitContentRules->valCount;

           for (i=0; i<pAttr->AttrVal.valCount; i++) {
               pAttr->AttrVal.pAVal[i].pVal =
                   THAllocEx(pTHS, pSchemaPtr->pDitContentRules->pAVal[i].valLen);
               pAttr->AttrVal.pAVal[i].valLen =
                   pSchemaPtr->pDitContentRules->pAVal[i].valLen;
               memcpy (pAttr->AttrVal.pAVal[i].pVal,
                       pSchemaPtr->pDitContentRules->pAVal[i].pVal,
                       pAttr->AttrVal.pAVal[i].valLen);
           }
       }
       else {
           pAttr->AttrVal.valCount = 0;
           pAttr->AttrVal.pAVal = NULL;
       }
   }
   else {
       err = DB_ERR_UNKNOWN_ERROR;
   }

   return err;
}



DWORD
dbGetSubSchemaModifyTimeStamp(
    THSTATE *pTHS,
    ATTR *pAttr
)

/*+++

  Compute the modifyTimeStamp attribute of subschemasubentry

---*/

{
    DSTIME  timestamp;

    timestamp = SCGetSchemaTimeStamp();
    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx(pTHS, sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal->valLen = sizeof(DSTIME);
    pAttr->AttrVal.pAVal->pVal = (PUCHAR)THAllocEx(pTHS, sizeof(DSTIME));
    memcpy(pAttr->AttrVal.pAVal->pVal, &timestamp, sizeof(DSTIME));

    return 0;
}



DWORD
dbClassCacheToObjectClassDescription(
    THSTATE *pTHS,
    CLASSCACHE *pCC,
    BOOL bExtendedFormat,
    ATTRVAL *pAVal
)

/*+++

   Take a classcache and return the unicode string for the
   class description format for subschemasubentry

---*/
{
    WCHAR      *Buff;
    PUCHAR     pString;
    WCHAR      wBuff[512];
    unsigned   len=0, size = 0, stringLen, i;
    int        oidlen;
    ULONG      BuffSize = 512, *pul;
    CLASSCACHE *pCCSuper;
    ATTCACHE   *pAC=NULL;

    Buff = (WCHAR *)THAllocEx(pTHS, BuffSize);

    Buff[0] = L'(';
    Buff[1] = L' ';
    len = 2;

    oidlen = AttrTypToString (pTHS, pCC->ClassId, wBuff, 512);
    if(oidlen < 0) {
        DPRINT1(0,"dbClassCacheToObjectClassDescription: Failed to convert ClassId %x\n", pCC->ClassId);
        return DB_ERR_UNKNOWN_ERROR;
    } else {

        //  Make absolutely sure the buffer is big enough

        if( (len + oidlen)*sizeof(WCHAR) >= BuffSize) {
            BuffSize = 2*(max(BuffSize,(oidlen*sizeof(WCHAR))));
            Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
        }
        // copy the OID, start from 4 to avoid the OID. in front
        memcpy(&Buff[len], &wBuff[4], (oidlen-4)*sizeof(WCHAR));
        len += oidlen - 4;
    }

    if( len*sizeof(WCHAR) + NAME_TAG_SIZE >=BuffSize) {
        BuffSize = 2*(max(BuffSize,NAME_TAG_SIZE));
        Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
    }
    memcpy(&Buff[len],NAME_TAG,NAME_TAG_SIZE);
    len += NAME_TAG_SIZE / sizeof(WCHAR);

    if((len + pCC->nameLen)*sizeof(WCHAR) >=BuffSize) {
        BuffSize += 2*(max(BuffSize,pCC->nameLen));
        Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
    }

    // convert the name to wide-char
    mbstowcs(&Buff[len],pCC->name,pCC->nameLen);
    len += pCC->nameLen;

    if(!bExtendedFormat) {
        // This is the base format defined in the specs
        if(pCC->ClassId != CLASS_TOP) {

            // Skip superclass iff TOP
            if(len*sizeof(WCHAR) + SUP_TAG_SIZE >=BuffSize) {
                BuffSize += 2*(max(BuffSize,SUP_TAG_SIZE));
                Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            memcpy(&Buff[len],SUP_TAG,SUP_TAG_SIZE);
            len += SUP_TAG_SIZE / sizeof(WCHAR);

            // Get the classes superclass;
            if(!(pCCSuper = SCGetClassById(pTHS, pCC->pSubClassOf[0]))) {
                DPRINT1(0,"dbClassCacheToObjectClassDescription: SCGetClassById failed for class %x\n", pCC->pSubClassOf[0]);

                return DB_ERR_UNKNOWN_ERROR;
            }

            if((len + pCCSuper->nameLen + 1)*sizeof(WCHAR) >=BuffSize) {
                BuffSize += 2*(max(BuffSize, (pCCSuper->nameLen)*sizeof(WCHAR)));
                Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            mbstowcs(&Buff[len],pCCSuper->name,pCCSuper->nameLen);
            len += pCCSuper->nameLen;
        }
        else {
            // Still need to put in a space
            if((len + 2)*sizeof(WCHAR) >= BuffSize) {
                BuffSize += 2*(max(BuffSize,SUP_TAG_SIZE));
                Buff=(WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            Buff[len++] = L'\'';
            Buff[len++] = L' ';
        }

        switch(pCC->ClassCategory) {
        case DS_88_CLASS:
        case DS_STRUCTURAL_CLASS:
            if( (len+1)*sizeof(WCHAR) + STRUCTURAL_CLASS_TAG_SIZE >=BuffSize) {
                BuffSize += 2*(max(BuffSize,STRUCTURAL_CLASS_TAG_SIZE));
                Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            memcpy(&Buff[len],STRUCTURAL_CLASS_TAG,STRUCTURAL_CLASS_TAG_SIZE);
            len += STRUCTURAL_CLASS_TAG_SIZE / sizeof(WCHAR);
            break;
        case DS_AUXILIARY_CLASS:
            if( (len+1)*sizeof(WCHAR) + AUXILIARY_CLASS_TAG_SIZE >=BuffSize) {
                BuffSize += 2*(max(BuffSize,AUXILIARY_CLASS_TAG_SIZE));
                Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            memcpy(&Buff[len],AUXILIARY_CLASS_TAG,AUXILIARY_CLASS_TAG_SIZE);
            len += AUXILIARY_CLASS_TAG_SIZE / sizeof(WCHAR);
            break;
        case DS_ABSTRACT_CLASS:
            if( (len+1)*sizeof(WCHAR) + ABSTRACT_CLASS_TAG_SIZE >=BuffSize) {
                BuffSize += 2*(max(BuffSize,ABSTRACT_CLASS_TAG_SIZE));
                Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            memcpy(&Buff[len],ABSTRACT_CLASS_TAG,ABSTRACT_CLASS_TAG_SIZE);
            len += ABSTRACT_CLASS_TAG_SIZE / sizeof(WCHAR);
            break;
        }

        if(pCC->MyMustCount) {
            // Has must haves.
            if( (len+1)*sizeof(WCHAR) + MUST_TAG_SIZE >=BuffSize) {
                BuffSize += 2*(max(BuffSize,MUST_TAG_SIZE));
                Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            memcpy(&Buff[len],MUST_TAG,MUST_TAG_SIZE);
            len += MUST_TAG_SIZE / sizeof(WCHAR);

            // Deal with the list here.
            pul = pCC->pMyMustAtts;
            // Deal with first object, which is slightly different
            if(!(pAC = SCGetAttById(pTHS, *pul))) {
                DPRINT1(0,"dbClassCacheToObjectClassDescription: SCGetAttById failed for  attribute %x\n", *pul);
                return DB_ERR_UNKNOWN_ERROR;
            }
            if((len + pAC->nameLen + 2)*sizeof(WCHAR) >=BuffSize) {
                BuffSize += 2*(max(BuffSize,(pAC->nameLen)*sizeof(WCHAR)));
                Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            mbstowcs(&Buff[len],pAC->name,pAC->nameLen);
            len += pAC->nameLen;
            Buff[len++] = L' ';

            // Now, the rest
            for(i=1;i<pCC->MyMustCount;i++) {
                pul++;
                if(!(pAC = SCGetAttById(pTHS, *pul))) {
                DPRINT1(0,"dbClassCacheToObjectClassDescription: SCGetAttById failed for  attribute %x\n", *pul);
                return DB_ERR_UNKNOWN_ERROR;
            }
                if((len + pAC->nameLen + 5)*sizeof(WCHAR)>=BuffSize) {
                    BuffSize += 2*(max(BuffSize,(pAC->nameLen + 5)*sizeof(WCHAR)));
                    Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
                }
                Buff[len++] = L'$';
                Buff[len++] = L' ';
                mbstowcs(&Buff[len],pAC->name,pAC->nameLen);
                len += pAC->nameLen;
                Buff[len++] = L' ';
            }
            Buff[len++] = L')';
        }

        if(pCC->MyMayCount) {
            // Has may haves.
            if( (len+1)*sizeof(WCHAR) + MAY_TAG_SIZE >=BuffSize) {
                BuffSize += 2*(max(BuffSize,MAY_TAG_SIZE));
                Buff=(WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            memcpy(&Buff[len],MAY_TAG,MAY_TAG_SIZE);
            len += MAY_TAG_SIZE / sizeof(WCHAR);
            // Deal with the list here.
            pul = pCC->pMyMayAtts;

            // Deal with first object, which is slightly different
            if(!(pAC = SCGetAttById(pTHS, *pul))) {
                DPRINT1(0,"dbClassCacheToObjectClassDescription: SCGetAttById failed for  attribute %x\n", *pul);
                return DB_ERR_UNKNOWN_ERROR;
            }
            if((len + pAC->nameLen + 2)*sizeof(WCHAR) >=BuffSize) {
                BuffSize += 2*(max(BuffSize,(pAC->nameLen)*sizeof(WCHAR)));
                Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            mbstowcs(&Buff[len],pAC->name,pAC->nameLen);
            len += pAC->nameLen;
            Buff[len++] = L' ';

            // Now, the rest
            for(i=1;i<pCC->MyMayCount;i++) {
                pul++;
                if(!(pAC = SCGetAttById(pTHS, *pul))) {
                DPRINT1(0,"dbClassCacheToObjectClassDescription: SCGetAttById failed for  attribute %x\n", *pul);
                return DB_ERR_UNKNOWN_ERROR;
            }
                if((len + pAC->nameLen + 5)*sizeof(WCHAR) >=BuffSize) {
                    BuffSize += 2*(max(BuffSize,(pAC->nameLen + 5)*sizeof(WCHAR)));
                    Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
                }
                Buff[len++] = L'$';
                Buff[len++] = L' ';
                mbstowcs(&Buff[len],pAC->name,pAC->nameLen);
                len += pAC->nameLen;
                Buff[len++] = L' ';
            }
            Buff[len++] = L')';
        }
    }
    else {
        // This is the Extended Format defined so I can hand back property
        // page identifiers and anything else I think of
        BYTE      *pByte;
        unsigned  i;
        CHAR      acTemp[256];
        CHAR      acTempLen = 1;

        // Now, the class guid

        pByte = (BYTE *)&(pCC->propGuid);
        for(i=0;i<sizeof(GUID);i++) {
            sprintf(&acTemp[i*2],"%02X",pByte[i]);
        }
        acTempLen=2*sizeof(GUID);
        if(CLASS_GUID_TAG_SIZE + (len + acTempLen + 1)*sizeof(WCHAR)>=BuffSize) {
            BuffSize += 2*(max(BuffSize, CLASS_GUID_TAG_SIZE +
                                           (acTempLen + 1)*sizeof(WCHAR)));
            Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
        }
        memcpy(&Buff[len],CLASS_GUID_TAG,CLASS_GUID_TAG_SIZE);
        len+= CLASS_GUID_TAG_SIZE / sizeof(WCHAR);
        mbstowcs(&Buff[len], acTemp, acTempLen);
        len += acTempLen;
        Buff[len] = L'\'';
        len++;
    }

    if( len*sizeof(WCHAR) + END_TAG_SIZE >=BuffSize) {
         BuffSize += 2*(max(BuffSize,END_TAG_SIZE));
         Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
    }
    memcpy(&Buff[len],END_TAG,END_TAG_SIZE);

    pAVal->pVal = (PUCHAR) Buff;

    pAVal->valLen = len*sizeof(WCHAR) + END_TAG_SIZE;

    return 0;
}



DWORD
dbAttCacheToAttributeTypeDescription(
    THSTATE *pTHS,
    ATTCACHE *pAC,
    BOOL bExtendedFormat,
    ATTRVAL *pAVal
)

/*+++

   Take a attcache and return the unicode string for the
   attribute description format for subschemasubentry

---*/

{
    WCHAR    *Buff;
    WCHAR    *pString;
    WCHAR    wBuff[512];
    unsigned len=0, size = 0, stringLen, i;
    int      oidlen;
    ULONG    BuffSize = 512, *pul;

    Buff = (WCHAR *)THAllocEx(pTHS, BuffSize);

    Buff[0] = L'(';
    Buff[1] = L' ';
    len = 2;

    oidlen = AttrTypToString(pTHS, pAC->Extid, wBuff, 512);
    if(oidlen < 0) {
        DPRINT1(0,"dbAttCacheToObjectClassDescription: Failed to convert Id %x\n", pAC->id);
        return DB_ERR_UNKNOWN_ERROR;
    } else {

        //  Make absolutely sure the buffer is big enough
        if( (len + oidlen)*sizeof(WCHAR) >= BuffSize) {
            BuffSize = 2*(max(BuffSize,(oidlen*sizeof(WCHAR))));
            Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
        }
        // copy the OID, start from 4 to avoid the OID. in front
        memcpy(&Buff[len], &wBuff[4], (oidlen-4)*sizeof(WCHAR));
        len += oidlen - 4;
    }

    if( len*sizeof(WCHAR) + NAME_TAG_SIZE >=BuffSize) {
        BuffSize = 2*(max(BuffSize,NAME_TAG_SIZE));
        Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
    }
    memcpy(&Buff[len],NAME_TAG,NAME_TAG_SIZE);
    len += NAME_TAG_SIZE / sizeof(WCHAR);

    if((len + pAC->nameLen)*sizeof(WCHAR) >=BuffSize) {
        BuffSize += 2*(max(BuffSize,pAC->nameLen));
        Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
    }

    // convert the name to wide-char
    mbstowcs(&Buff[len],pAC->name,pAC->nameLen);
    len += pAC->nameLen;

    if(!bExtendedFormat) {
        // This is the normal format, defined in the standards
        if(len*sizeof(WCHAR) + SYNTAX_TAG_SIZE >=BuffSize) {
            BuffSize += 2*(max(BuffSize,SYNTAX_TAG_SIZE));
            Buff=(WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
        }
        memcpy(&Buff[len],SYNTAX_TAG,SYNTAX_TAG_SIZE);
        len += SYNTAX_TAG_SIZE / sizeof(WCHAR);

        if(pAC->OMsyntax == 127) {
            switch(pAC->syntax) {
            case SYNTAX_DISTNAME_TYPE:
                // DS_C_DS_DN
                pString = SyntaxDN.oid.value;
                stringLen = SyntaxDN.oid.length;
                break;

            case SYNTAX_DISTNAME_BINARY_TYPE:
                if(OIDcmp(&pAC->OMObjClass, &MH_C_OR_NAME)) {
                    // MH_C_OR_NAME
                    pString = SyntaxORName.oid.value;
                    stringLen = SyntaxORName.oid.length;
                }
                else {
                    pString = SyntaxDNBlob.oid.value;
                    stringLen = SyntaxDNBlob.oid.length;
                }
                break;

            case SYNTAX_ADDRESS_TYPE:
                // DS_C_PRESENTATION_ADDRESS
                pString = SyntaxPresentationAddress.oid.value;
                stringLen = SyntaxPresentationAddress.oid.length;
                break;

            case SYNTAX_DISTNAME_STRING_TYPE:
                if(OIDcmp(&pAC->OMObjClass, &DS_C_ACCESS_POINT)) {
                    // DS_C_ACCESS_POINT
                    pString = SyntaxAccessPoint.oid.value;
                    stringLen = SyntaxAccessPoint.oid.length;
                }
                else {
                    pString = SyntaxDNString.oid.value;
                    stringLen = SyntaxDNString.oid.length;
                }
                break;

            case SYNTAX_OCTET_STRING_TYPE:
                // This had better be a replica-link valued object, since that
                // is all we support.
                pString = SyntaxStrings[OM_S_OCTET_STRING].name.value;
                stringLen = SyntaxStrings[OM_S_OCTET_STRING].name.length;
                break;
            default:
                pString = SyntaxStrings[OM_S_NO_MORE_SYNTAXES].name.value;
                stringLen = SyntaxStrings[OM_S_NO_MORE_SYNTAXES].name.length;
                break;
            }
        }
        else if(pAC->OMsyntax == 64) {
            pString = SyntaxDirectoryString.oid.value;
            stringLen = SyntaxDirectoryString.oid.length;
        }
        else if(pAC->OMsyntax == 65) {
            pString = SyntaxInteger8.oid.value;
            stringLen = SyntaxInteger8.oid.length;
        }
        else if(pAC->OMsyntax == 66) {
            pString = SyntaxObjectSD.oid.value;
            stringLen = SyntaxObjectSD.oid.length;
        }
        else if(pAC->OMsyntax > 27) {
            pString = SyntaxStrings[OM_S_NO_MORE_SYNTAXES].oid.value;
            stringLen = SyntaxStrings[OM_S_NO_MORE_SYNTAXES].oid.length;
        }
        else {
            pString = SyntaxStrings[pAC->OMsyntax].oid.value;
            stringLen= SyntaxStrings[pAC->OMsyntax].oid.length;
        }

        if((len+1)*sizeof(WCHAR) + stringLen>=BuffSize) {
            BuffSize += 2*(max(BuffSize,stringLen));
            Buff=(WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
        }
        memcpy(&Buff[len], pString, stringLen);

        len += stringLen / sizeof(WCHAR);

        Buff[len] = L'\'';
        len++;

        if(pAC->isSingleValued) {
            if(len*sizeof(WCHAR) + SINGLE_TAG_SIZE >=BuffSize) {
                BuffSize += 2*(max(BuffSize,SINGLE_TAG_SIZE));
                Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            memcpy(&Buff[len],SINGLE_TAG,SINGLE_TAG_SIZE);
            len += SINGLE_TAG_SIZE / sizeof(WCHAR);
        }

        if(pAC->bSystemOnly) {
            if(len*sizeof(WCHAR) + NO_MOD_TAG_SIZE >= BuffSize) {
                BuffSize += 2*(max(BuffSize,NO_MOD_TAG_SIZE));
                Buff=(WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            memcpy(&Buff[len],
                   NO_MOD_TAG,
                   NO_MOD_TAG_SIZE);
            len += NO_MOD_TAG_SIZE / sizeof(WCHAR);
        }
    }
    else {
        // This is the Extended Format defined so I can hand back index
        // information, range information, and anything else I think of

        BYTE      *pByte;
        unsigned  i;
        WCHAR     acTemp[256];
        int       acTempLen = 0, acTempSize = 0;

        if(pAC->rangeLowerPresent) {
            // First, make a string with the range lower
            swprintf((WCHAR *)acTemp, L"%d", pAC->rangeLower);
            acTempLen = wcslen(acTemp);
            acTempSize = acTempLen * sizeof(WCHAR);

            if(len*sizeof(WCHAR) + RANGE_LOWER_TAG_SIZE + acTempSize>=BuffSize) {
                BuffSize += 2*(max(BuffSize,RANGE_LOWER_TAG_SIZE+acTempSize));
                Buff=(WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            memcpy(&Buff[len],RANGE_LOWER_TAG,RANGE_LOWER_TAG_SIZE);
            len+= RANGE_LOWER_TAG_SIZE / sizeof(WCHAR);
            memcpy(&Buff[len],acTemp,acTempSize);
            len+= acTempLen;
        }

        if(pAC->rangeUpperPresent) {
            // First, make a string with the range upper
            swprintf((WCHAR *)acTemp, L"%d", pAC->rangeUpper);
            acTempLen = wcslen(acTemp);
            acTempSize = acTempLen * sizeof(WCHAR);

            if(len*sizeof(WCHAR) + RANGE_UPPER_TAG_SIZE + acTempSize  >=BuffSize) {
                BuffSize += 2*(max(BuffSize,RANGE_UPPER_TAG_SIZE+acTempSize));
                Buff=(WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            memcpy(&Buff[len],RANGE_UPPER_TAG,RANGE_UPPER_TAG_SIZE);
            len+= RANGE_UPPER_TAG_SIZE / sizeof(WCHAR);
            memcpy(&Buff[len],acTemp,acTempSize);
            len+= acTempLen;
        }

        // Now the property GUID

        pByte = (BYTE *)&(pAC->propGuid);
        for(i=0;i<sizeof(GUID);i++) {
            swprintf(&acTemp[i*2],L"%02X",pByte[i]);
        }
        acTempLen=2*sizeof(GUID);
        if(PROP_GUID_TAG_SIZE + (len + acTempLen + 1)*sizeof(WCHAR)
                                   >= BuffSize) {
            BuffSize += 2*(max(BuffSize, PROP_GUID_TAG_SIZE +
                                           (acTempLen + 1)*sizeof(WCHAR)));
            Buff=(WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
        }
        memcpy(&Buff[len],PROP_GUID_TAG,PROP_GUID_TAG_SIZE);
        len+= PROP_GUID_TAG_SIZE / sizeof(WCHAR);
        memcpy(&Buff[len], acTemp, acTempLen*sizeof(WCHAR));
        len += acTempLen;

        // Now the property set GUID

        pByte = (BYTE *)&(pAC->propSetGuid);
        for(i=0;i<sizeof(GUID);i++) {
            swprintf(&acTemp[i*2],L"%02X",pByte[i]);
        }
        acTempLen=2*sizeof(GUID);
        if(PROP_SET_GUID_TAG_SIZE + (len + acTempLen + 1)*sizeof(WCHAR)
                             >= BuffSize) {
            BuffSize += 2*(max(BuffSize, PROP_SET_GUID_TAG_SIZE +
                                           (acTempLen + 1)*sizeof(WCHAR)));
            Buff=(WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
        }
        memcpy(&Buff[len],PROP_SET_GUID_TAG,PROP_SET_GUID_TAG_SIZE);
        len+= PROP_SET_GUID_TAG_SIZE / sizeof(WCHAR);
        memcpy(&Buff[len], acTemp, acTempLen*sizeof(WCHAR));
        len += acTempLen;
        Buff[len] = L'\'';
        len++;


        if(pAC->fSearchFlags & fATTINDEX) {
            if(len*sizeof(WCHAR) + INDEXED_TAG_SIZE >=BuffSize) {
                BuffSize += 2*(max(BuffSize,INDEXED_TAG_SIZE));
                Buff=(WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            memcpy(&Buff[len],INDEXED_TAG,INDEXED_TAG_SIZE);
            len += INDEXED_TAG_SIZE / sizeof(WCHAR);
        }

        if(pAC->bSystemOnly) {
            if(len*sizeof(WCHAR) + SYSTEM_ONLY_TAG_SIZE >=BuffSize) {
                BuffSize += 2*(max(BuffSize,SYSTEM_ONLY_TAG_SIZE));
                Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            memcpy(&Buff[len],SYSTEM_ONLY_TAG,SYSTEM_ONLY_TAG_SIZE);
            len += SYSTEM_ONLY_TAG_SIZE / sizeof(WCHAR);
        }

    }

    if( len*sizeof(WCHAR) + END_TAG_SIZE >=BuffSize) {
         BuffSize += 2*(max(BuffSize,END_TAG_SIZE));
         Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
    }
    memcpy(&Buff[len],END_TAG,END_TAG_SIZE);

    // Return the value

    pAVal->pVal = (PUCHAR) Buff;

    pAVal->valLen = len*sizeof(WCHAR) + END_TAG_SIZE;

    return 0;
}


DWORD
dbClassCacheToDitContentRules(
    THSTATE *pTHS,
    CLASSCACHE *pCC,
    BOOL bExtendedFormat,
    CLASSCACHE **pAuxCC,
    DWORD        auxCount,
    ATTRVAL *pAVal
)

/*+++

   Take a classcache and return the unicode string for the
   dit content rule description format for subschemasubentry.

   RFC2252 specifies:

      DITContentRuleDescription = "("
          numericoid   ; Structural ObjectClass identifier
          [ "NAME" qdescrs ]
          [ "DESC" qdstring ]
          [ "OBSOLETE" ]
          [ "AUX" oids ]    ; Auxiliary ObjectClasses
          [ "MUST" oids ]   ; AttributeType identifiers
          [ "MAY" oids ]    ; AttributeType identifiers
          [ "NOT" oids ]    ; AttributeType identifiers
         ")"

   We use se the passed in pAuxBuf to generate the AUX specific part of the rule
   cAuxBuff is the number of characters of pAuxBuff buffer.

---*/

{
    WCHAR *Buff;
    WCHAR wBuff[512];
    unsigned len=0, i, k;
    int  oidlen;
    ULONG BuffSize = 512;
    CLASSCACHE *pCCAux, *pCCparent;
    ATTCACHE   *pAC;
    ATTRTYP *pMustHave = NULL, *pMayHave = NULL, *pAttr;
    DWORD    cMustHave=0, cMayHave=0;
    DWORD   err;
    PWCHAR  pAuxBuff = NULL;
    DWORD   cAuxBuff;

    // we want to find the mustHave attributes that are added
    // on this class (pCC) by the various static auxClasses
    // that have been added to this class somewhere in the hierarchy
    //
    // what we have todo inorder to find these attributes, is for
    // each class in the hierarchy, find the specific must have for
    // this particular class, and remove them from the union of all.
    // this way we will end up with only the attributes that were
    // added as an effect of the addition of the auxClass.
    // attributes that are also present in the auxClass, will
    // not be reported
    //
    if (pCC->MustCount) {
        cMustHave = pCC->MustCount;
        pMustHave = THAllocEx (pTHS, cMustHave * sizeof (ATTRTYP));
        memcpy(pMustHave, pCC->pMustAtts, cMustHave * sizeof (ATTRTYP));

        // start by using the current class
        //
        pCCparent=pCC;
        while (pCCparent) {
            for (i=0; i<pCCparent->MyMustCount; i++) {
                for (k=0; k<cMustHave; k++) {

                    // remove the entry if it already there
                    if (pMustHave[k]==pCCparent->pMyMustAtts[i]) {

                        // if the last entry, just adjust the counter
                        if (k==(cMustHave-1)) {
                            cMustHave--;
                        }
                        // otherwise move the rest of the entries
                        else {
                            memmove(&pMustHave[k],
                                    &pMustHave[k+1],
                                    (cMustHave - k - 1)*sizeof(ATTRTYP));
                            cMustHave--;
                        }
                    }
                }
            }

            // get the parent class, if availbale
            if (pCCparent->SubClassCount) {
                if(!(pCCparent = SCGetClassById(pTHS, pCCparent->pSubClassOf[0]))) {
                   DPRINT1(0,"dbClassCacheToDitContentRules: SCGetClassById failed for class %x\n",
                           pCCparent->pSubClassOf[0]);
                   return DB_ERR_UNKNOWN_ERROR;
                }
            }
            else {
                break;
            }
        }

        qsort(pMustHave, cMustHave, sizeof(ATTRTYP), CompareAttrtyp);
    }

    // same as before, but for MAY have attributes
    if (pCC->MayCount) {
        cMayHave = pCC->MayCount;
        pMayHave = THAllocEx (pTHS, cMayHave * sizeof (ATTRTYP));
        memcpy(pMayHave, pCC->pMayAtts, cMayHave * sizeof (ATTRTYP));

        pCCparent=pCC;

        while (pCCparent) {
            for (i=0; i<pCCparent->MyMayCount; i++) {
                for (k=0; k<cMayHave; k++) {
                    if (pMayHave[k]==pCCparent->pMyMayAtts[i]) {
                        if (k==(cMayHave-1)) {
                            cMayHave--;
                        }
                        else {
                            memmove(&pMayHave[k],
                                    &pMayHave[k+1],
                                    (cMayHave - k - 1)*sizeof(ATTRTYP));
                            cMayHave--;
                        }
                    }
                }
            }

            if (pCCparent->SubClassCount) {
                if(!(pCCparent = SCGetClassById(pTHS, pCCparent->pSubClassOf[0]))) {
                   DPRINT1(0,"dbClassCacheToDitContentRules: SCGetClassById failed for class %x\n", pCCparent->pSubClassOf[0]);
                   return DB_ERR_UNKNOWN_ERROR;
                }
            }
            else {
                break;
            }
        }

        qsort(pMayHave, cMayHave, sizeof(ATTRTYP), CompareAttrtyp);
    }

    // now start converting to text

    Buff = (WCHAR *)THAllocEx(pTHS, BuffSize);

    Buff[0] = L'(';
    Buff[1] = L' ';
    len = 2;

    oidlen = AttrTypToString(pTHS, pCC->ClassId, wBuff, 512);

    if(oidlen < 0) {
        DPRINT1(0,"dbClassCacheToDitContentRules: Failed to convert ClassId %x\n", pCC->ClassId);
        return DB_ERR_UNKNOWN_ERROR;
    } else {

        //  Make absolutely sure the buffer is big enough

        if( (len + oidlen)*sizeof(WCHAR) >= BuffSize) {
            BuffSize = 2*(max(BuffSize,(oidlen*sizeof(WCHAR))));
            Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
        }
        // copy the OID, start from 4 to avoid the OID. in front

        memcpy(&Buff[len], &wBuff[4], (oidlen-4)*sizeof(WCHAR));
        len += oidlen - 4;
    }

    if( len*sizeof(WCHAR) + NAME_TAG_SIZE >=BuffSize) {
        BuffSize = 2*(max(BuffSize,NAME_TAG_SIZE));
        Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
    }
    memcpy(&Buff[len],NAME_TAG,NAME_TAG_SIZE);
    len += NAME_TAG_SIZE / sizeof(WCHAR);

    if((len + pCC->nameLen +3)*sizeof(WCHAR) >=BuffSize) {
        BuffSize += 2*(max(BuffSize,pCC->nameLen));
        Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
    }

    // convert the name to wide-char
    mbstowcs(&Buff[len],pCC->name,pCC->nameLen);
    len += pCC->nameLen;
    Buff[len++]='\'';


    // Now, the aux class which was passed in
    if ((pCC->ClassCategory == DS_STRUCTURAL_CLASS ||
         pCC->ClassCategory == DS_88_CLASS)) {

        if (err = dbAuxClassCacheToDitContentRules(pTHS,
                                                   pCC,
                                                   pAuxCC,
                                                   auxCount,
                                                   &pAuxBuff,
                                                   &cAuxBuff) ) {

            DPRINT1(0,"dbAuxClassCacheToDitContentRules: Failed to convert class caches: %x\n", err);
            return DB_ERR_UNKNOWN_ERROR;
        }

        if (cAuxBuff) {
            if((len+cAuxBuff)*sizeof(WCHAR) + 2 >=BuffSize) {
                BuffSize += 2*(max(BuffSize,cAuxBuff*sizeof(WCHAR)));
                Buff=(WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            memcpy(&Buff[len],pAuxBuff,cAuxBuff*sizeof(WCHAR));
            len += cAuxBuff;
        }

        if (pAuxBuff) {
            THFreeEx (pTHS, pAuxBuff);
            pAuxBuff = NULL;
        }
    }


    if (cMustHave) {
        // Now, the MUST have.
        if(len*sizeof(WCHAR) + MUST_TAG_SIZE + 2 >=BuffSize) {
            BuffSize += 2*(max(BuffSize,MUST_TAG_SIZE));
            Buff=(WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
        }
        memcpy(&Buff[len],MUST_TAG,MUST_TAG_SIZE);
        len += MUST_TAG_SIZE / sizeof(WCHAR);


        // Deal with first object, which is slightly different
        pAttr = pMustHave;

        if(!(pAC = SCGetAttById(pTHS, *pAttr))) {
            DPRINT1(0,"dbClassCacheToDitContentRules: SCGetAttById for class %x\n", (*pAttr));
            return DB_ERR_UNKNOWN_ERROR;
        }
        if((len + pAC->nameLen + 4)*sizeof(WCHAR) >=BuffSize) {
            BuffSize += 2*(max(BuffSize, (pAC->nameLen)*sizeof(WCHAR)));
            Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
        }
        mbstowcs(&Buff[len], pAC->name, pAC->nameLen);
        len += pAC->nameLen;
        Buff[len++] = L' ';

        // Now, the rest
        for(i=1;i<cMustHave;i++) {
            pAttr++;
            if(!(pAC = SCGetAttById(pTHS, *pAttr))) {
               DPRINT1(0,"dbClassCacheToDitContentRules: SCGetAttById failed for class %x\n", *pAttr);
               return DB_ERR_UNKNOWN_ERROR;
            }
            if((len + pAC->nameLen + 6)*sizeof(WCHAR) >=BuffSize) {
                BuffSize += 2*(max(BuffSize,(pAC->nameLen + 6)*sizeof(WCHAR)));
                Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            Buff[len++] = L'$';
            Buff[len++] = L' ';
            mbstowcs(&Buff[len], pAC->name, pAC->nameLen);
            len += pAC->nameLen;
            Buff[len++] = L' ';
        }
        Buff[len++] = L')';
    }



    if (cMayHave) {
        // Now, the MAY have.
        if(len*sizeof(WCHAR) + MAY_TAG_SIZE + 2 >=BuffSize) {
            BuffSize += 2*(max(BuffSize,MAY_TAG_SIZE));
            Buff=(WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
        }
        memcpy(&Buff[len],MAY_TAG,MAY_TAG_SIZE);
        len += MAY_TAG_SIZE / sizeof(WCHAR);


        // Deal with first object, which is slightly different
        pAttr = pMayHave;

        if(!(pAC = SCGetAttById(pTHS, *pAttr))) {
            DPRINT1(0,"dbClassCacheToDitContentRules: SCGetAttById for class %x\n", (*pAttr));
            return DB_ERR_UNKNOWN_ERROR;
        }
        if((len + pAC->nameLen + 4)*sizeof(WCHAR) >=BuffSize) {
            BuffSize += 2*(max(BuffSize, (pAC->nameLen)*sizeof(WCHAR)));
            Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
        }
        mbstowcs(&Buff[len], pAC->name, pAC->nameLen);
        len += pAC->nameLen;
        Buff[len++] = L' ';

        // Now, the rest
        for(i=1;i<cMayHave;i++) {
            pAttr++;
            if(!(pAC = SCGetAttById(pTHS, *pAttr))) {
               DPRINT1(0,"dbClassCacheToDitContentRules: SCGetAttById failed for class %x\n", *pAttr);
               return DB_ERR_UNKNOWN_ERROR;
            }
            if((len + pAC->nameLen + 6)*sizeof(WCHAR) >=BuffSize) {
                BuffSize += 2*(max(BuffSize,(pAC->nameLen + 6)*sizeof(WCHAR)));
                Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            Buff[len++] = L'$';
            Buff[len++] = L' ';
            mbstowcs(&Buff[len], pAC->name, pAC->nameLen);
            len += pAC->nameLen;
            Buff[len++] = L' ';
        }
        Buff[len++] = L')';
    }


    Buff[len++] = L')';

    Assert(Buff[len] == 0);


    if (pMustHave) {
        THFreeEx (pTHS, pMustHave);
    }

    if (pMayHave) {
        THFreeEx (pTHS, pMayHave);
    }

    // Return the value

    pAVal->pVal = (PUCHAR) Buff;

    pAVal->valLen = len*sizeof(WCHAR);

    return 0;
}


DWORD
dbAuxClassCacheToDitContentRules(
    THSTATE *pTHS,
    CLASSCACHE *pCC,
    CLASSCACHE **pAuxCC,
    DWORD        auxCount,
    PWCHAR  *pAuxBuff,
    DWORD   *pcAuxBuff
)

/*+++

    Return the AUX class string to be used in generating the ditContentRules
    for each class in dbClassCacheToDitContentRules.

    This string contains all the classes in the pAuxCC excpet pCC

    Takes is an array of all the available auxClasses (pAuxCC)
    returns a buffer of the string generated (pAuxBuff) as well the
    number of chars in this buffer (pcAuxBuff)

---*/

{
    WCHAR *Buff;
    unsigned len=0, i;
    ULONG BuffSize = 512;
    CLASSCACHE *pCCAux;

    Buff = (WCHAR *)THAllocEx(pTHS, BuffSize);

    if (auxCount) {
        // Now, the aux class.
        if(len*sizeof(WCHAR) + AUX_TAG_SIZE + 2 >=BuffSize) {
            BuffSize += 2*(max(BuffSize,AUX_TAG_SIZE));
            Buff=(WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
        }
        memcpy(&Buff[len],AUX_TAG,AUX_TAG_SIZE);
        len += AUX_TAG_SIZE / sizeof(WCHAR);


        // Deal with first object, which is slightly different
        i=0;
        if (pCC == pAuxCC[0]) {
            i = 1;
        }

        if (i == auxCount) {
            THFreeEx (pTHS, Buff);
            *pAuxBuff = NULL;
            *pcAuxBuff = 0;
            return 0;
        }

        pCCAux = pAuxCC[i];

        if((len + pCCAux->nameLen + 4)*sizeof(WCHAR) >=BuffSize) {
            BuffSize += 2*(max(BuffSize, (pCCAux->nameLen)*sizeof(WCHAR)));
            Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
        }
        mbstowcs(&Buff[len], pCCAux->name, pCCAux->nameLen);
        len += pCCAux->nameLen;
        Buff[len++] = L' ';

        i++;

        // Now, the rest
        for(; i<auxCount; i++) {

            pCCAux = pAuxCC[i];

            if (pCCAux == pCC) {
                continue;
            }

            if((len + pCCAux->nameLen + 6)*sizeof(WCHAR) >=BuffSize) {
                BuffSize += 2*(max(BuffSize,(pCCAux->nameLen + 6)*sizeof(WCHAR)));
                Buff = (WCHAR *)THReAllocEx(pTHS, Buff, BuffSize);
            }
            Buff[len++] = L'$';
            Buff[len++] = L' ';
            mbstowcs(&Buff[len], pCCAux->name, pCCAux->nameLen);
            len += pCCAux->nameLen;
            Buff[len++] = L' ';
        }

        Buff[len++] = L')';
    }

    Assert(Buff[len] == 0);


    // Return the value
    *pAuxBuff = Buff;
    *pcAuxBuff = len;

    return 0;
}

DWORD
dbGetUserAccountControlComputed(
    THSTATE *pTHS,
    DSNAME  *pObjDSName,
    ATTR    *pAttr
)
/*++

    Get the "userAccountControlComputed" attribute on the user object
    This requires  getting the bit of information if the user is locked
    out or if the user's password is expired

    Return Values:

    0                - success
    DB_ERR_NO_VALUE  - success but no value to return

    DB_ERR_*         - failure

--*/
{

    LARGE_INTEGER LockoutTime, PasswordLastSet,
                  LockoutDuration, MaxPasswordAge,
                  CurrentTime;
    NTSTATUS      NtStatus;
    ULONG         UserAccountControl;
    ULONG         *pUserAccountControlComputed =NULL;
    ULONG         err=0;

    //
    // Get the current time
    //

    NtStatus = NtQuerySystemTime(&CurrentTime);
    if (!NT_SUCCESS(NtStatus)){

        err = DB_ERR_UNKNOWN_ERROR;
        goto Error;
    }

    LockoutTime.QuadPart = 0;
    PasswordLastSet.QuadPart = 0;

    //
    // We are currently positioned on the user object, read the Lockout
    // time and Password last set attributes, Also read user account control
    //

    err = DBGetSingleValue(pTHS->pDB,
                        ATT_LOCKOUT_TIME,
                        &LockoutTime,
                        sizeof(LockoutTime),
                        NULL);
    if (DB_ERR_NO_VALUE == err) {
        //
        // It is O.K to not have a lockout time set on the user object,
        // it simply means that the user is not locked out.
        //

        err=0;

    } else if (err) {

        goto Error;
    }

     err = DBGetSingleValue(pTHS->pDB,
                        ATT_PWD_LAST_SET,
                        &PasswordLastSet,
                        sizeof(PasswordLastSet),
                        NULL);

    if (DB_ERR_NO_VALUE==err) {

        //
        // It is O.K to not have password last set on the user object,
        // it simply means that no password was ever set --> the initial
        // blank password is considered expired.
        //

        err = 0;

    } else if (err) {

        goto Error;
    }

    err = DBGetSingleValue(pTHS->pDB,
                        ATT_USER_ACCOUNT_CONTROL,
                        &UserAccountControl,
                        sizeof(UserAccountControl),
                        NULL);
    if (err) {

        goto Error;
    }


    //
    // Check to see if the given user is
    // in the domain hosted by us. Note that the
    // pObjDSName will have the string name filled in
    // and also have no issues with client supplied DSNames
    // such as spaces etc as it is freshly retrieved from
    // disk by the caller of this routine.
    //

    if (pTHS->pDB->NCDNT !=gAnchor.ulDNTDomain)
    {
        err = DB_ERR_NO_VALUE;
        goto Error;
    }

    MaxPasswordAge = gAnchor.MaxPasswordAge;
    LockoutDuration = gAnchor.LockoutDuration;

    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS,sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
    pAttr->AttrVal.pAVal->pVal = (PUCHAR)THAllocEx(pTHS, sizeof(ULONG));
    pUserAccountControlComputed = (PULONG)pAttr->AttrVal.pAVal->pVal;
    *pUserAccountControlComputed = 0;

    //
    // Compute the Password Expired bit
    // MaxPasswordAge is stored as a negative
    // delta offset

    if ((!(UserAccountControl & UF_DONT_EXPIRE_PASSWD)) &&
                                                // password on account never expires
        (!(UserAccountControl & UF_SMARTCARD_REQUIRED)) &&
                                                // don't expire password if smartcard
                                                // required -- passwords make no sense
                                                // in that case
        (!(UserAccountControl & UF_MACHINE_ACCOUNT_MASK)))
                                                // passwords don't expire for machines
                                                // reliability issues otherwise
                                                // machines are programmed to change
                                                // passwords periodically
    {
        if ( (0 == PasswordLastSet.QuadPart) ||
             ((0 != MaxPasswordAge.QuadPart) && // zero means no password aging
              (CurrentTime.QuadPart >PasswordLastSet.QuadPart - MaxPasswordAge.QuadPart))
           )
        {
            *pUserAccountControlComputed |= UF_PASSWORD_EXPIRED;
        }
    }

    //
    // Compute the account lockout out bit
    // Again lockout duration is a negative delta time
    //

     if (((LockoutTime.QuadPart - CurrentTime.QuadPart) >
                 LockoutDuration.QuadPart )  &&
          (0!=LockoutTime.QuadPart) && // zero means no lockout
          (!(UserAccountControl & UF_MACHINE_ACCOUNT_MASK)))
                                    // machine accounts do not get locked out
                                    // denial of service implications otherwise,
                                    // password cracking hard as 128 bit random
                                    // passwords chosen.
    {
        *pUserAccountControlComputed |= UF_LOCKOUT;
    }

Error:


    return(err);

}

DWORD
dbGetApproxSubordinates(THSTATE * pTHS,
                        DSNAME  * pObjDSName,
                        ATTR    * pAttr)
{
    ULONG * pNumSubords;
    ULONG oldRootDnt;
    KEY_INDEX *pKeyIndex;

    pAttr->AttrVal.valCount = 1;
    pAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS,sizeof(ATTRVAL));
    pAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
    pAttr->AttrVal.pAVal->pVal = (PUCHAR)THAllocEx(pTHS, sizeof(ULONG));
    pNumSubords = (PULONG)pAttr->AttrVal.pAVal->pVal;


    if (!IsAccessGrantedSimple(RIGHT_DS_LIST_CONTENTS, FALSE)) {
        *pNumSubords = 0;
        return 0;
    }

    oldRootDnt = pTHS->pDB->Key.ulSearchRootDnt;
    pTHS->pDB->Key.ulSearchRootDnt = pTHS->pDB->DNT;

    pKeyIndex = dbMakeKeyIndex(pTHS->pDB,
                               FI_CHOICE_SUBSTRING,
                               TRUE,    // bIsSIngleValued
                               dbmkfir_PDNT,
                               SZPDNTINDEX,
                               TRUE,    // fGetNumRecs
                               0,       // cIndexRanges
                               NULL);

    pTHS->pDB->Key.ulSearchRootDnt = oldRootDnt;
    *pNumSubords = pKeyIndex->ulEstimatedRecsInRange;

    dbFreeKeyIndex(pTHS, pKeyIndex);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dbescrow.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dbescrow.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file implements escrowed update semantics for the NT5 DS.  Jet
    escrowed updates can only be performed at certain times.  Escrowed updates
    for a given record may only occur outside the scope of a JetPrepareUpdate
    for the same record - even those of outer level transactions.  

    Caution - Jet asserts on such errors in the checked build, but
    does not return an error in either the checked or free build.
    So escrowed update errors can only be detected when using a 
    checked ese.dll or by running the refcount unit test.

    The approach is to cache knowledge of what escrowed updates are desired
    within a begin/end transaction scope, and then apply them just before
    the commit of the outermost transaction.

Author:

    DaveStr     03-Jul-97

Environment:

    User Mode - Win32

Revision History:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>                      

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <mdlocal.h>
#include <dsatools.h>                   // For pTHS
#include "ntdsctr.h"

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>

// Assorted DSA headers
#include <hiertab.h>
#include "anchor.h"
#include <dsevent.h>
#include <filtypes.h>                   // Def of FI_CHOICE_???
#include "objids.h"                     // Hard-coded Att-ids and Class-ids
#include "usn.h"
#include "drameta.h"
#include "debug.h"                      // standard debugging header
#define DEBSUB "DBESCROW:"              // define the subsystem for debugging

// DBLayer includes
#include "dbintrnl.h"

#include <fileno.h>
#define  FILENO FILENO_DBESCROW

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Miscellaneous defines and typedefs                                   //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#if DBG
#define DNT_INCREMENT           2
#else
#define DNT_INCREMENT           32
#endif

// Initially the DNTs are stored unsorted.  At some future point in time we
// may sort them, but even then linear search is better for small data sets.
// So we define a cutoff above which the DNTs are sorted.

#define LINEAR_SEARCH_CUTOFF    0xffffffff


extern HANDLE hevSDPropagationEvent;

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Function implementations                                             //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
dbEscrowReserveSpace(
    THSTATE     *pTHS,
    ESCROWINFO  *pInfo,
    DWORD       cDNT)

/*++

Routine Description:

    Reserves space for the requested number of DNTs in an ESCROWINFO.
    Uses dbAlloc which is expected to be an exception throwing allocator.
    Thus raises DSA_MEM_EXCEPTION if the space can not be reserved.

Arguments:

    pInfo - Address of ESCROWINFO in which to reserve space.

    cDNT - Count of DNTs to reserve space for.

Return Value:

    None.  Raises DSA_MEM_EXCEPTION on error.

--*/

{
    DWORD   cBytes;
    VOID    *pv;
    DWORD   increment;

    // Test against requested space required, but allocate max of 
    // request and DNT_INCREMENT.

    increment = (DNT_INCREMENT > cDNT) ? DNT_INCREMENT : cDNT;

    if ( NULL == pInfo->rItems )
    {
        Assert((0 == pInfo->cItems) && (0 == pInfo->cItemsMax));

        cBytes = increment * sizeof(ESCROWITEM);
        pInfo->rItems = (ESCROWITEM *) dbAlloc(cBytes);
        pInfo->cItemsMax = increment;
    }
    else if ( (pInfo->cItemsMax - pInfo->cItems) < cDNT )
    {
        cBytes = (pInfo->cItemsMax + increment) * sizeof(ESCROWITEM);
        pv = dbReAlloc(pInfo->rItems, cBytes);
        pInfo->rItems = (ESCROWITEM *) pv;
        pInfo->cItemsMax += increment;
    }

    DPRINT1(2, "Reserved space for %d ESCROWITEMs\n", increment);
}



ESCROWITEM * 
dbEscrowFindDNT(
    THSTATE     *pTHS,
    ESCROWINFO  *pInfo,
    DWORD       DNT,
    BOOL        fAllocateNewIfRequired)

/*++

Routine Description:

    Finds the requested ESCROWITEM in a THSTATE's escrow information.
    Optionally allocates room for an ESCROWITEM if desired/required.

Arguments:

    pInfo - Address of ESCROWINFO in which to find the DNT.

    DNT - DNT to find.

    fAllocateNewIfRequired - Allocation desired flag.

Return Value:

    Address of desired ESCROWITEM or NULL.

--*/

{
    DWORD   i;

    // Search for the DNT - linear search is more efficient for small tables.

    if ( pInfo->cItems <= LINEAR_SEARCH_CUTOFF )
    {
        for ( i = 0; i < pInfo->cItems; i++ )
        {
            if ( DNT == pInfo->rItems[i].DNT )
            {
                DPRINT1(2, "ESCROWITEM for DNT(%d) found\n", DNT);

                return(&pInfo->rItems[i]);
            }
        }
    }
    else
    {
        Assert(!"Sorted ESCROWINFO not implemented.");
    }

    // DNT not found.  

    if ( !fAllocateNewIfRequired )
    {
        return(NULL);
    }

    // Insert new DNT.

    dbEscrowReserveSpace(pTHS, pInfo, 1);

    i = pInfo->cItems;
    pInfo->rItems[i].DNT = DNT;
    pInfo->rItems[i].delta = 0;
    pInfo->rItems[i].ABRefdelta = 0;
    pInfo->cItems += 1;

    DPRINT1(2, "ESCROWITEM for DNT(%d) added\n", DNT);

    return(&pInfo->rItems[i]);
}

BOOL
dbEscrowPreProcessTransactionalData(
    DBPOS   *pDB,
    BOOL    fCommit)

/*++

Routine Description:

    Pre-processes a (nested) transaction's escrowed updates.  The !commit
    case is a no-op as everything gets thrown away during post processing.
    In the case of a nested transaction, we reserve space in the outer
    level transaction so that this level's escrowed updates can be merged
    up w/o allocation during post processing.  In the case of a level 0 
    transaction, the escrowed updates are actually applied to the database.

Arguments:

    pDB - Pointer to DBPOS for which the transaction is being ended.

    fCommit - Flag indicating whether to commit or not.

Return Value:

    True on success, FALSE or exception otherwise.

--*/

{
    THSTATE     *pTHS = pDB->pTHS;
    NESTED_TRANSACTIONAL_DATA *pData;
    ESCROWITEM  *pItem;
    DWORD       i;
    DWORD       err;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pDB));
    Assert(pTHS->JetCache.dataPtr);
    Assert(pTHS->transactionlevel > 0);

    pData = pTHS->JetCache.dataPtr;

    if ( !fCommit )
    {
        // Nothing to do - post processing will discard this level's DNTs.

        NULL;
    }
    else if ( pTHS->transactionlevel > 1 )
    {
        // Committing, to non-zero level.  Reserve space in outer level
        // transaction for this level's DNTs.

        dbEscrowReserveSpace(pTHS,
                             &(pData->pOuter->escrowInfo),
                             pData->escrowInfo.cItems);
    }
    else
    {
        // Committing, level 0 transaction.  Apply escrowed updates now.

        for ( i = 0; i < pData->escrowInfo.cItems; i++ )
        {

            if ((0 != pData->escrowInfo.rItems[i].delta ) ||
                (0 != pData->escrowInfo.rItems[i].ABRefdelta ))
            {
                // Can't use DBFindDNT as that does a DBCancelRec which 
                // does a JetPrepareUpdateEx - exactly what we need 
                // to avoid.

                DBSetCurrentIndex(pDB, Idx_Dnt, NULL, FALSE);
    
                JetMakeKeyEx(pDB->JetSessID, 
                             pDB->JetObjTbl, 
                             &pData->escrowInfo.rItems[i].DNT, 
                             sizeof(pData->escrowInfo.rItems[i].DNT), 
                             JET_bitNewKey);

                err = JetSeekEx(pDB->JetSessID,
                                pDB->JetObjTbl, 
                                JET_bitSeekEQ);

                if ( err )
                {
                    DsaExcept(DSA_DB_EXCEPTION,
                              err,
                              pData->escrowInfo.rItems[i].DNT);
                }

                if(pData->escrowInfo.rItems[i].delta) {
                    Assert(pData->escrowInfo.rItems[i].DNT != NOTOBJECTTAG);
                    JetEscrowUpdateEx(pDB->JetSessID,
                                      pDB->JetObjTbl,
                                      cntid,
                                      &pData->escrowInfo.rItems[i].delta,
                                      sizeof(pData->escrowInfo.rItems[i].delta),
                                      NULL,     // pvOld
                                      0,        // cbOldMax
                                      NULL,     // pcbOldActual
                                      0);       // grbit
                }
                

                
                if(pData->escrowInfo.rItems[i].ABRefdelta) {
                    Assert(gfDoingABRef);
                    if(gfDoingABRef) {
                        JetEscrowUpdateEx(pDB->JetSessID,
                                          pDB->JetObjTbl,
                                          abcntid,
                                          &pData->escrowInfo.rItems[i].ABRefdelta,
                                          sizeof(pData->escrowInfo.rItems[i].ABRefdelta),
                                          NULL,     // pvOld
                                          0,        // cbOldMax
                                          NULL,     // pcbOldActual
                                          0);       // grbit
                    }
                }
                
                DPRINT3(2, 
                        "Applied escrow update of delta(%d), ABRefdelta(%d) for DNT(%d)\n",
                        pData->escrowInfo.rItems[i].delta,
                        pData->escrowInfo.rItems[i].ABRefdelta,
                        pData->escrowInfo.rItems[i].DNT);
            }
        }
    }

    return TRUE;
}

VOID
dbEscrowPostProcessTransactionalData(
    DBPOS   *pDB,
    BOOL    fCommit,
    BOOL    fCommitted)

/*++

Routine Description:

    Post-processes a (nested) transaction's escrowed updates.  In the case 
    of !fCommit they are thrown away.  In the case of a nested transaction
    they are merged into the next outer level transaction's updates w/o 
    doing any exception throwing allocations.  In the case of an level 0 
    transaction, the escrowed updates were already applied to the database
    during pre-processing, so there is nothing to do.  This level's
    ESCROWINFO is cleaned up in all cases.

Arguments:

    fCommit - Flag indicating whether the transaction intended to commit.

    fCommitted - Flag indicating whether the transaction did commit.

Return Value:

    None.

--*/

{
    NESTED_TRANSACTIONAL_DATA *pData;
    ESCROWITEM  *pItem;
    DWORD       i;
    DWORD       err;
    DWORD       cMaxBeforeFind;
    THSTATE     *pTHS = pDB->pTHS;

    Assert(VALID_THSTATE(pTHS));
    Assert(pTHS->JetCache.dataPtr);

    pData = pTHS->JetCache.dataPtr;

    __try
    {
        if ( !fCommitted )
        {
            // Aborted transaction - throw away all the escrowed updates of
            // this (possibly nested) transaction.  But don't do it here
            // since discard of current transaction's ESCROWINFO is common
            // to all paths in this routine.

            NULL;
        }
        else if ( pTHS->transactionlevel > 0 )
        {
            // Committing, to non-zero level.  Propagate the escrowed
            // updates to the outer transaction.

            for ( i = 0; i < pData->escrowInfo.cItems; i++ )
            {
                cMaxBeforeFind = pData->pOuter->escrowInfo.cItemsMax;
                pItem = dbEscrowFindDNT(pTHS,
                                        &(pData->pOuter->escrowInfo), 
                                        pData->escrowInfo.rItems[i].DNT, 
                                        TRUE);

                // Due to reservation during pre-processing, the outer level's
                // ESCROWINFO should not need to have grown for this insertion.

                Assert(cMaxBeforeFind == pData->pOuter->escrowInfo.cItemsMax);
                Assert(    pItem 
                        && (pData->escrowInfo.rItems[i].DNT == pItem->DNT));

                pItem->delta += pData->escrowInfo.rItems[i].delta;
                pItem->ABRefdelta += pData->escrowInfo.rItems[i].ABRefdelta;
            }

        }
        else
        {
            // Committing, level 0 transaction.  Escrowed updates were
            // applied during pre-processing.

            // check for SD events and fireup SD propagator
            if(pDB->SDEvents) {
                if(!pTHS->fSDP) {
                    // We are committing any changes made to the SD Prop table,
                    // and we're not the SD propagator, so we need to signal
                    // the SD propagator that a change may have taken place
                    SetEvent(hevSDPropagationEvent);
                }
                IADJUST(pcSDEvents, pDB->SDEvents);
            }

        }
    }
    __finally
    {
        // Strip this transaction's ESCROWINFO out of the linked list.

        if ( NULL != pData->escrowInfo.rItems ) {
            dbFree(pData->escrowInfo.rItems);
        }
    }
}

VOID
dbEscrowPromote(
    DWORD   phantomDNT,
    DWORD   objectDNT)

/*++

Routine Description:

    For use when promoting a phantom to a real object.  Transfers the 
    deltas for the objectDNT to the phantomDNT.  Assumes both phantomDNT
    and objectDNT deltas were applied within the same transaction.

Arguments:

    phantomDNT - DNT of phantom being promoted.

    objectDNT - DNT of object whose delta is to be applied to the phantom.

Return Value:

    None.

--*/

{
    THSTATE     *pTHS = pTHStls;
    ESCROWITEM  *pPhantomItem;
    ESCROWITEM  *pObjectItem;
    ESCROWINFO  *pInfo;
    DWORD       i;

    Assert(VALID_THSTATE(pTHS));
    Assert(pTHS->JetCache.dataPtr);

    pInfo = &(pTHS->JetCache.dataPtr->escrowInfo);

    pObjectItem = dbEscrowFindDNT(pTHS, pInfo, objectDNT, FALSE);

    if ( NULL == pObjectItem )
    {
        DPRINT1(2, 
                "dbEscrowPromote - object DNT(%d) not found\n",
                objectDNT);
        return;
    }

    if (( 0 == pObjectItem->delta ) &&
        ( 0 == pObjectItem->ABRefdelta ))
    {
        DPRINT1(2, 
                "dbEscrowPromote - no deltas for object DNT(%d)\n",
                objectDNT);
        return;
    }

    DPRINT4(2,
            "dbEscrowPromote - moving delta(%d) abdelta(%d) from DNT(%d) to DNT(%d)\n",
            pObjectItem->delta,
            pObjectItem->ABRefdelta,
            objectDNT,
            phantomDNT);

    pPhantomItem = dbEscrowFindDNT(pTHS, pInfo, phantomDNT, TRUE);

    // dbEscrowFindDNT should either find/allocate an ESCROWITEM for us
    // or throw an exception - in which case we wouldn't be here.

    // Since the previous dbEscrowFindDNT call may have realloc'ed the array of
    // escrow items, the pObjectItem pointer we got before may be bad now.  Get
    // it again, just to be safe.
    pObjectItem = dbEscrowFindDNT(pTHS, pInfo, objectDNT, FALSE);    
    if ( NULL == pObjectItem )
    {
        DPRINT1(2, 
                "dbEscrowPromote - object DNT(%d) not found\n",
                objectDNT);
        return;
    }
    Assert(pObjectItem->delta || pObjectItem->ABRefdelta);
    
    Assert(pPhantomItem);
    Assert(phantomDNT == pPhantomItem->DNT);

    pPhantomItem->delta += pObjectItem->delta;
    pPhantomItem->ABRefdelta += pObjectItem->ABRefdelta;

    // Remove objectDNT from the cache.

    i = (DWORD)(pObjectItem - &pInfo->rItems[0]);

    Assert(i < pInfo->cItems);

    if ( 0 == i )
    {
        Assert(1 == pInfo->cItems);
        pInfo->cItems = 0;
    }
    else if ( i == (pInfo->cItems - 1) )
    {
        pInfo->cItems -= 1;
    }
    else
    {
        // Move last item into i-th slot.

        pInfo->cItems -= 1;
        pInfo->rItems[i] = pInfo->rItems[pInfo->cItems];

        // Resort if required.

        if ( pInfo->cItems > LINEAR_SEARCH_CUTOFF )
        {
            Assert(!"Sorted ESCROWINFO not implemented.");
        }
    }
}

VOID
DBAdjustRefCount(
        DBPOS       *pDB,        
        DWORD       DNT,
        long        delta
        )

/*++

Routine Description:

    Updates the transaction-relative escrow cache with the desired delta.

Arguments:

    DNT - DNT to update.

    delta - Delta by which to advance the reference count.

Return Value:

    None.

--*/

{
    THSTATE     *pTHS = pDB->pTHS;
    ESCROWITEM  *pItem;
    DWORD       i;

    Assert(VALID_THSTATE(pTHS));
    Assert(pTHS->JetCache.dataPtr);

    pItem = dbEscrowFindDNT(pTHS,
                            &(pTHS->JetCache.dataPtr->escrowInfo), 
                            DNT, 
                            TRUE);

    // dbEscrowFindDNT should either find/allocate an ESCROWITEM for us
    // or throw an exception - in which case we wouldn't be here.

    Assert(pItem);
    Assert(DNT == pItem->DNT);

    DPRINT4(2, "DNT %d pending refcount adjustment: %d + %d = %d\n",
            DNT, pItem->delta, delta, pItem->delta + delta);

    pItem->delta += delta;
}

VOID
DBAdjustABRefCount (
        DBPOS       *pDB,
        DWORD       DNT,
        long        delta
        )
     
/*++

Routine Description:

    Updates the transaction-relative escrow cache with the desired delta for a
    ABRefcount.

Arguments:

    DNT - DNT to update.

    delta - Delta by which to advance the reference count.

Return Value:

    None.
    Raises exception on error

--*/

{
    THSTATE     *pTHS = pDB->pTHS;
    ESCROWITEM  *pItem, *pWholeCount;
    DWORD       i;

    Assert(VALID_THSTATE(pTHS));
    Assert(pTHS->JetCache.dataPtr);
    Assert(DNT != INVALIDDNT);
    Assert(DNT != NOTOBJECTTAG);
    
    
    if(!gfDoingABRef) {
        return;
    }
    pItem = dbEscrowFindDNT(pTHS,
                            &(pTHS->JetCache.dataPtr->escrowInfo), 
                            DNT, 
                            TRUE);

    // dbEscrowFindDNT may realloc the escrow list, so before doing the
    // dbEscrowFindDNT for the NOTOBJECTTAG, deal with the pointer we just got.
    Assert(pItem);
    Assert(DNT == pItem->DNT);
    pItem->ABRefdelta += delta;

    pWholeCount = dbEscrowFindDNT(pTHS,
                                  &(pTHS->JetCache.dataPtr->escrowInfo), 
                                  NOTOBJECTTAG,
                                  TRUE);
    

    // dbEscrowFindDNT should either find/allocate an ESCROWITEM for us
    // or throw an exception - in which case we wouldn't be here.
    
    Assert(pWholeCount);
    Assert(NOTOBJECTTAG == pWholeCount->DNT);

    pWholeCount->ABRefdelta += delta;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dbeval.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbeval.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <mdlocal.h>
#include <dsatools.h>                   // For pTHStls
#include <attids.h>

#include <permit.h>

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>

// Assorted DSA headers
#include <filtypes.h>      /* Def of FI_CHOICE_???                  */
#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DBEV:" /* define the subsystem for debugging           */

// DBLayer includes
#include "dbintrnl.h"

#include <fileno.h>
#define  FILENO FILENO_DBEVAL



/* Some shorthand datastructure defines*/

#define PITEM     pFil->FilterTypes.Item
#define FAVA      FilTypes.ava
#define FSB       FilTypes.pSubstring
#define FPR       FilTypes.present
#define FSKIP     FilTypes.pbSkip

BOOL
dbEvalFilterSecurity (
        DBPOS *pDB,
        CLASSCACHE *pCC,
        PSECURITY_DESCRIPTOR pSD,
        PDSNAME pDN
        )
{
    THSTATE *pTHS = pDB->pTHS;
    Assert(VALID_DBPOS(pDB));

    if(pTHS->fDSA || pTHS->fDRA) {
        // DO not evaluate security
        return TRUE;
    }


    if(!pDB->Key.FilterSecuritySize) {
        // No Security to evaluate.
        return TRUE;
    }

    if(!pSD || !pCC || !pDN) {
        // Missing required attributes, this security check can't be performed.
        Assert(FALSE);
        return FALSE;
    }

    pDB->Key.pFilterSecurity[0].ObjectType = &pCC->propGuid;

    if(CheckPermissionsAnyClient(
            pSD,                        // security descriptor
            pDN,                        // DN of the object
            RIGHT_DS_READ_PROPERTY,     // access mask
            pDB->Key.pFilterSecurity,   // Object Type List
            pDB->Key.FilterSecuritySize, // Number of objects in list
            NULL,
            pDB->Key.pFilterResults,                 // access status array
            0,
            NULL                        // authz client context (grab from THSTATE)
            )){
        return FALSE;
    }

    // OK, we're done
    return TRUE;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Apply the supplied filter test to the current object.  Returns TRUE or
   FALSE.  The actual evaluation test is performed by the DBEval function.
*/


TRIBOOL
DBEvalFilter (
        DBPOS FAR *pDB,
        BOOL    fUseSearchTbl,
        FILTER *pFil
        )
{

   USHORT count;
   TRIBOOL retval;
   BOOL    undefinedPresent;

   DPRINT(2, "DBEvalFilter entered, apply filter test\n");

   Assert(VALID_DBPOS(pDB));

   if(pFil == NULL){    /* a NULL filter is automatically true */
      DPRINT(2,"No filter..return\n");
      return eTRUE;
   }

   DPRINT1(5,"Switch on filter choice <%u>\n", (USHORT)(pFil->choice));

   switch (pFil->choice){
     /* count number of filters are anded together.  If any are false
        the AND is false.
     */
     case FILTER_CHOICE_AND:
        DPRINT(5,"AND test\n");
        undefinedPresent = FALSE;
        count = pFil->FilterTypes.And.count;
        for (pFil = pFil->FilterTypes.And.pFirstFilter;
                                      count--;
                                     pFil = pFil->pNextFilter){

            retval = DBEvalFilter(pDB, fUseSearchTbl, pFil);

            Assert (VALID_TRIBOOL(retval));

            // if the AND has at least one false, it is false
            if (retval == eFALSE){
                DPRINT(5,"AND returns FALSE\n");
                return eFALSE;
            }
            // if the AND has at least one undefined, it is undefined
            else if (retval == eUNDEFINED){
                undefinedPresent = TRUE;
            }

        } /*for*/

        // the AND had one undefined, so it is undefined
        if (undefinedPresent) {
            DPRINT(5,"AND returns UNDEFINED\n");
            return eUNDEFINED;
        }

        DPRINT(5,"AND returns TRUE\n");
        return eTRUE;
        break;

     /* count number of filters are ORed together.  If any are true
        the OR is true.
     */
     case FILTER_CHOICE_OR:
        DPRINT(5,"OR test\n");
        undefinedPresent = FALSE;
        count = pFil->FilterTypes.Or.count;
        for (pFil = pFil->FilterTypes.Or.pFirstFilter;
                                      count--;
                                     pFil = pFil->pNextFilter){
           retval = DBEvalFilter(pDB, fUseSearchTbl, pFil);

           Assert (VALID_TRIBOOL(retval));

           if (retval == eTRUE) {
               DPRINT(5,"OR returns TRUE\n");
               return eTRUE;
           }
           else if (retval == eUNDEFINED) {
               undefinedPresent = TRUE;
           }
        } /*for*/

        // the OR had one undefined, so it is undefined
        if (undefinedPresent) {
            DPRINT(5,"OR returns UNDEFINED\n");
            return eUNDEFINED;
        }
        else {
            DPRINT(5,"OR returns FALSE\n");
            return eFALSE;
        }
        break;

     case FILTER_CHOICE_NOT:
        retval = DBEvalFilter(pDB, fUseSearchTbl, pFil->FilterTypes.pNot);

        Assert (VALID_TRIBOOL(retval));

        if (retval == eFALSE) {
          DPRINT(5,"NOT return TRUE\n");
          return eTRUE;
        }
        else if (retval == eTRUE) {
          DPRINT(5,"NOT return FALSE\n");
          return eFALSE;
        }
        else {
            DPRINT(5,"NOT return UNDEFINED\n");
            return eUNDEFINED;
        }
        break;

     /*  Apply the chosen test to the database attribute on the current
         object.
     */
     case FILTER_CHOICE_ITEM:
         DPRINT(5,"ITEM test\n");

        switch (pFil->FilterTypes.Item.choice){
        case FI_CHOICE_TRUE:
            DPRINT(5,"TRUE test\n");
            return eTRUE;
            break;

        case FI_CHOICE_FALSE:
            DPRINT(5,"FALSE test\n");
            return eFALSE;
            break;

        case FI_CHOICE_UNDEFINED:
            DPRINT(5,"UNDEFINED test\n");
            return eUNDEFINED;
            break;

        case FI_CHOICE_SUBSTRING:
            return
                dbEvalInt(pDB, fUseSearchTbl,
                          FI_CHOICE_SUBSTRING, PITEM.FSB->type
                          , 0   /*NA for substrings*/
                          , (UCHAR *) PITEM.FSB
                          , PITEM.FSKIP);
            break;

        case FI_CHOICE_EQUALITY:
        case FI_CHOICE_NOT_EQUAL:
        case FI_CHOICE_GREATER_OR_EQ:
        case FI_CHOICE_GREATER:
        case FI_CHOICE_LESS_OR_EQ:
        case FI_CHOICE_LESS:
        case FI_CHOICE_BIT_AND:
        case FI_CHOICE_BIT_OR:
            return
                dbEvalInt(pDB,
                          fUseSearchTbl,
                          pFil->FilterTypes.Item.choice,
                          PITEM.FAVA.type,
                          PITEM.FAVA.Value.valLen,
                          PITEM.FAVA.Value.pVal,
                          PITEM.FSKIP
                          );
            break;

        case FI_CHOICE_PRESENT:
            return
                dbEvalInt(pDB,
                          fUseSearchTbl,
                          FI_CHOICE_PRESENT, PITEM.FPR  /*just test for existance*/
                          , 0
                          , NULL
                          , PITEM.FSKIP);
            break;

        default:
            DPRINT(1, "Bad Filter Item..return \n"); /*set error*/
            return eFALSE;
            break;
        } /*FILITEM switch*/

    default:
        DPRINT(1, "Bad Filter choice..return \n"); /*set error*/
        return eFALSE;
        break;
   }  /*switch FILTER*/


}/* DBEvalFilter*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* The function applies the specified boolean operation on a given attribute
   type.  The supplied attribute value is compared against the attribute on
   the current database object.  Note that for multi-valued attributes, a
   TRUE result is returned if the operation is true for any of the attribute
   values.  For example, an equality test for a member JOE in a group of
   names is true if JOE is any value of the group.

   First the attribute is located in the object.  If the entire attribute
   is missing the evaluation is FALSE.  Otherwise, the client value is
   converted to internal form and is tested against each value in the
   attribute.  gDBSyntax performs the test according to the attribute syntax.
*/


TRIBOOL
dbEvalInt (
        DBPOS FAR *pDB,
        BOOL fUseSearchTbl,
        UCHAR Operation,
        ATTRTYP type,
            ULONG valLenFilter,
        UCHAR *pValFilter,
        BOOL *pbSkip
        )
{

    UCHAR   syntax;
    ULONG   attLenRec;
    UCHAR   *pAttValRec;
    BOOL    fDoneOne = FALSE;
    ULONG   NthValIndex;
    ATTCACHE *pAC;
    ULONG   bufSize;
    DWORD   flags;
    DWORD   err;

    Assert(VALID_DBPOS(pDB));

    if(Operation == FI_CHOICE_TRUE) {
        return eTRUE;
    }
    else if(Operation == FI_CHOICE_FALSE) {
        return eFALSE;
    }
    else if(Operation == FI_CHOICE_UNDEFINED) {
        return eUNDEFINED;
    }

    DPRINT3(2, "dbEvalInt entered, apply filter test operation <%u>"
            "att type <%lu>, val <%s>\n",
            Operation, type, asciiz(pValFilter,(USHORT)valLenFilter));

    // get each attribute value and apply the test.  A test is TRUE if any
    //  of the value tests are true.
    if(pbSkip && *pbSkip) {
        // No matter what is there, we have to pretend that the value is empty.
        if (Operation == FI_CHOICE_NOT_EQUAL) {
            return eTRUE;
        }
        return eFALSE;
    }

    pAC = SCGetAttById(pDB->pTHS, type);
    Assert(pAC != NULL);
    // although we guarantee that this is ok, better check
    if (!pAC) {
        return eUNDEFINED;
    }
    bufSize = 0;
    flags = DBGETATTVAL_fINTERNAL | DBGETATTVAL_fREALLOC;

    if(fUseSearchTbl) {
        flags |= DBGETATTVAL_fUSESEARCHTABLE;
    }

    // Get the first value to consider.
    NthValIndex = 1;
    if(pAC->ulLinkID) {
        err = DBGetNextLinkVal_AC (pDB, TRUE, pAC, flags, bufSize, &attLenRec,
                                   &pAttValRec);
    }
    else {
        err = DBGetAttVal_AC(pDB, NthValIndex, pAC, flags, bufSize, &attLenRec,
                             &pAttValRec);
    }


    while(!err) {
            DPRINT(5,"Applying test to next attribute value\n");

        bufSize = max(bufSize, attLenRec);

        fDoneOne = TRUE;

        switch(gDBSyntax[pAC->syntax].Eval(pDB, Operation, valLenFilter,
                                               pValFilter, attLenRec, pAttValRec)) {
            case TRUE:
                DPRINT(5,"An att value passed the compare test..return TRUE\n");
                THFree(pAttValRec);
                return eTRUE;

            case FALSE:
                DPRINT(5,"This att value failed test continue testing\n");
                break;

            default:
                DPRINT(5, "Eval syntax  compare failed ..return FALSE\n");
                THFree(pAttValRec);
                return eUNDEFINED;  /*return error stuff here*/
        }/*switch*/


        // Get the next value to consider.
        NthValIndex++;
        if(pAC->ulLinkID) {
            err = dbGetNthNextLinkVal (pDB, 1, &pAC, flags, bufSize, &pAttValRec,
                                       &attLenRec);
        }
        else {
            err = DBGetAttVal_AC(pDB, NthValIndex, pAC, flags, bufSize,
                                 &attLenRec, &pAttValRec);
        }
    } /*while*/

    if(bufSize)
        THFree(pAttValRec);

    DPRINT(2,"All attribute values failed the test..return FALSE\n");

    if(fDoneOne) {
        // We looked at at least one value, and it failed the test;
        // so, return FALSE;
        return eFALSE;
    }

    // We didn't look at any values.  If the comparison was !=, we passed;
    // otherwise, we failed.

    if (Operation == FI_CHOICE_NOT_EQUAL) {
        return eTRUE;
    }

    return eFALSE;
}  /* dbEvalInt*/



TRIBOOL
DBEval (
        DBPOS FAR *pDB,
        UCHAR Operation,
        ATTCACHE *pAC,
            ULONG valLenFilter,
        UCHAR *pValFilter
        )
{
    ULONG len;
    PUCHAR pVal;
    ULONG  ulFlags=0;


    Assert(VALID_DBPOS(pDB));

    if (DBIsSecretData(pAC->id))
       ulFlags|=EXTINT_SECRETDATA;

    gDBSyntax[pAC->syntax].ExtInt(pDB,
                                  DBSYN_INQ,
                                  valLenFilter,
                                  pValFilter,
                                  &len,
                                  &pVal,
                                  0,
                                  0,
                                  ulFlags);

    return dbEvalInt(pDB, FALSE, Operation, pAC->id, len, pVal,NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dbcache.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1989 - 1999
//
//  File:       dbcache.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:


DETAILS:

CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <mdlocal.h>
#include <dsatools.h>

#include <mdcodes.h>
#include <dsevent.h>
#include <dstaskq.h>
#include <dsexcept.h>
#include <filtypes.h>
#include "objids.h" /* Contains hard-coded Att-ids and Class-ids */
#include "debug.h"  /* standard debugging header */
#define DEBSUB "DBCACHE:" /* define the subsystem for debugging */

#include "dbintrnl.h"
#include "anchor.h"
#include <ntdsctr.h>

#include <fileno.h>
#define  FILENO FILENO_DBCACHE

#if DBG
// Debug only routine to aggressively check the dnread cache.  Only way to turn
// it on is to use a debugger to set the following BOOL to TRUE
BOOL gfExhaustivelyValidateDNReadCache = FALSE;
VOID
dbExhaustivelyValidateDNReadCache(
        THSTATE *pTHS
        );
#endif

// A reader/writer lock to control access to the Global DN read cache in the
// anchor.  See DBTransIn for a complete description of it's use.
RTL_RESOURCE        resGlobalDNReadCache;

CRITICAL_SECTION csDNReadLevel1List;
CRITICAL_SECTION csDNReadLevel2List;

#if DBG
ULONG ulDNRFindByDNT=0;
ULONG ulDNRFindByPDNTRdn=0;
ULONG ulDNRFindByGuid=0;
ULONG ulDNRCacheCheck=0;
ULONG ulDNRCacheKeepHold=0;
ULONG ulDNRCacheThrowHold=0;

// NOTE, we use ++ instead of interlocked or critsec because these are simple,
// debug only, internal perfcounters.  They are only visible with a debugger.
// The perf teams tells us that in cases where the occasional increment can
// afford to be lost, ++ instead of interlocked can make a measurable
// performance boost.
#define INC_FIND_BY_DNT      ulDNRFindByDNT++
#define INC_FIND_BY_PDNT_RDN ulDNRFindByPDNTRdn++
#define INC_FIND_BY_GUID     ulDNRFindByGuid++
#define INC_CACHE_CHECK      ulDNRCacheCheck++
#define INC_CACHE_KEEP_HOLD  ulDNRCacheKeepHold++
#define INC_CACHE_THROW_HOLD ulDNRCacheThrowHold++

#else

#define INC_FIND_BY_DNT
#define INC_FIND_BY_PDNT_RDN
#define INC_FIND_BY_GUID
#define INC_CACHE_CHECK
#define INC_CACHE_KEEP_HOLD
#define INC_CACHE_THROW_HOLD

#endif

d_memname *
dnCreateMemname(
        IN DBPOS * pDB,
        IN JET_TABLEID tblid
        );

#define SLOT(x,y) pTHS->LocalDNReadCache[x].slot[y]
#define HOLD(x)   pTHS->LocalDNReadCache[x].hold
#define INDEX(x)  pTHS->LocalDNReadCache[x].index
#define INCREMENTINDEX(x)                                            \
                  INDEX(x).DNT = ((INDEX(x).DNT + 1) % DN_READ_CACHE_SLOT_NUM)
#define NEXTSLOT(x) SLOT(x,INDEX(x).DNT)

typedef struct _DNT_COUNT {
    DWORD DNT;
    DWORD count;
} DNT_COUNT_STRUCT;

typedef struct _DNT_HOT_LIST {
    struct _DNT_HOT_LIST *pNext;
    DWORD                 cData;
    DNT_COUNT_STRUCT     *pData;
} DNT_HOT_LIST;

// MAX_LEVEL_1_HOT_DNTS is the maximum number of DNTs in a level 1 Hot list
#define MAX_GLOBAL_DNTS             128
#define MAX_LEVEL_1_HOT_DNTS         32
#define MAX_LEVEL_1_HOT_LIST_LENGTH 128
#define MAX_LEVEL_2_HOT_DNTS         64
#define MAX_LEVEL_2_HOT_LIST_LENGTH 128
// This is 5 minutes, expressed in ticks.
#define DNREADREBUILDDELAY (1000 * 60 * 5)

DNT_HOT_LIST *Level1HotList=NULL;
DWORD         Level1HotListCount = 0;
DNT_HOT_LIST *Level2HotList=NULL;
DWORD         Level2HotListCount = 0;
BOOL          bImmediatelyAggregateLevel1List = TRUE;
BOOL          bImmediatelyAggregateLevel2List = TRUE;
DWORD         gLastDNReadDNTUpdate = 0;



// The following critical section safeguards the following data structures.
CRITICAL_SECTION csDNReadGlobalCache;
DWORD           *pGlobalDNReadCacheDNTs = NULL;
DWORD            cGlobalDNTReadCacheDNTs = 0;


// The following critical section safeguards the following data structures.
CRITICAL_SECTION csDNReadInvalidateData;
// Start sequnce at 1 so that 0 is an invalid sequence.
volatile DWORD   gDNReadLastInvalidateSequence = 1;
volatile DWORD   gDNReadNumCurrentInvalidators = 0;


BOOL
dnAggregateInfo(
        DNT_HOT_LIST *pList,
        DWORD         maxOutSize,
        DNT_HOT_LIST **ppResult
        )
/*++

  This routine is called by dnRegisterHotList, below.

  This routine takes in a linked list of DNT_HOT_LIST structures and aggregates
  the data hanging off each structure.  That data contains DNT and count pairs.
  After aggregating all the data into a single structure (summing the counts),
  the single aggregate structure is trimmed to include no more than maxOutSize
  DNTs, dropping DNTs associated with lower counts.  The aggregate data is
  returned as a single DNT_HOT_LIST structure.  The data and DNT_HOT_LIST
  structure are allocated here, using malloc.  The returned data is sorted by
  DNT. The input list is freed.

  If anything goes wrong in this routine (primarily, failure to allocate
  memory), no data is returned and the input list is still freed.

  returns TRUE if all went well, FALSE otherwise.  If TRUE, the ppResult points
  to a pointer to the aggregated data.

--*/
{
    THSTATE *pTHS = pTHStls;
    DWORD Size;
    DWORD i,j;
    DNT_HOT_LIST *pTemp;
    DNT_COUNT_STRUCT *pData=NULL;
    BOOL bFound;
    DWORD  begin, end, middle;


    (*ppResult) =  malloc(sizeof(DNT_HOT_LIST));
    if(!(*ppResult)) {
        // This shouldn't happen.  Since it did, just free up the level 1 list
        // and return. Yes, we are losing information.
        while(pList) {
            pTemp = pList->pNext;
            free(pList->pData);
            free(pList);
            pList = pTemp;
        }
        return FALSE;
    }

    (*ppResult)->pNext = NULL;
    (*ppResult)->pData = NULL;
    (*ppResult)->cData = 0;

    // First, find the max size we'll need.
    Size=0;
    pTemp = pList;
    while(pTemp) {
        Size += pTemp->cData;
        pTemp = pTemp->pNext;
    }

    pData = malloc(Size * sizeof(DNT_COUNT_STRUCT));
    if(!pData) {
        // This shouldn't happen.  Since it did, just free up the level 1 list
        // and return. Yes, we are losing information.
        while(pList) {
            pTemp = pList->pNext;
            free(pList->pData);
            free(pList);
            pList = pTemp;
        }
        free(*ppResult);
        *ppResult = NULL;
        return FALSE;
    }

    // preload the first element with a 0 count.  This makes the binary search
    // below easier to code.
    pData[0].DNT = pList->pData[0].DNT;
    pData[0].count = 0;

    // OK, aggregate the info.
    // Note that we keep pData sorted by DNT, since we're sure it's big enough
    // to hold all the objects.

    Size = 1;
    pTemp = pList;
    j=0;
    while(pList) {
        pTemp = pList->pNext;
        j++;
        for(i=0;i<pList->cData;i++) {
            // Look up the correct node in the pData array. Since pData is
            // sorted by DNT, use a binary search.
            begin = 0;
            end = Size;
            middle = (begin + end) / 2;
            bFound = TRUE;
            while(bFound && (pData[middle].DNT != pList->pData[i].DNT)) {
                if(pData[middle].DNT > pList->pData[i].DNT) {
                    end = middle;
                }
                else {
                    begin = middle;
                }
                if(middle == (begin + end) / 2) {
                    bFound = FALSE;
                    if(pData[middle].DNT < pList->pData[i].DNT) {
                        middle++;
                    }
                }
                else {
                    middle = (begin + end)/2;
                }
            }
            if(!bFound) {
                if(middle < Size) {
                    memmove(&pData[middle + 1],
                            &pData[middle],
                            (Size - middle) * sizeof(DNT_COUNT_STRUCT));
                }
                Size++;
                pData[middle] = pList->pData[i];
            }
            else {
                // Update the count.
                pData[middle].count += pList->pData[i].count;
            }
        }
        free(pList->pData);
        free(pList);
        pList = pTemp;
    }

    // OK, we now have aggregated the data.  Next, trim the data down to only
    // the N hottest.
    if(Size > maxOutSize) {
        // Too much data, trim out the maxOutSize - Size coldest objects.
        DWORD *Counts=NULL;
        DWORD  countSize = 0;
        DWORD  spillCount = 0;
        DWORD  leastCountVal = 0;
        DWORD  i,j;

        // allocate 1 greater than the max out size because after we have filled
        // up maxCountSize elements, the insertion algorithm just shifts
        // everything down by one from the insertion point, so let's make sure
        // we have some "scratch" space after the end of the array.
        //
        Counts = THAlloc((1 + maxOutSize) * sizeof(DWORD));
        if(Counts) {
            // preload the array.
            Counts[0] = pData[0].count;
            countSize = 1;
            leastCountVal = Counts[0];

            for(i=1;i<Size;i++) {
                j=0;
                // Insert pData[i].count into the list.
                while(j < countSize && Counts[j] >= pData[i].count)
                    j++;

                if(j == countSize) {
                    // insert at end
                    if(countSize != maxOutSize) {
                        leastCountVal = pData[i].count;
                        Counts[countSize] = pData[i].count;
                        countSize++;
                    }
                    else {
                        // OK, we don't actually have room for this one, but, if
                        // it equal to leastcountval, we have to inc the
                        // spillcount, since we are spilling it.
                        if(leastCountVal == pData[i].count) {
                            spillCount++;
                        }
                    }
                }
                else if(j < countSize) {
                    // Yep, the current count is greater than some count in the
                    // count list.  Keep it.
                    if(countSize == maxOutSize) {
                        // We're spilling.
                        // NOTE: this algorithm only works for maxOutSize > 1
                        if(Counts[maxOutSize - 2 ] == leastCountVal) {
                            spillCount++;
                        }
                        else {
                            leastCountVal = Counts[maxOutSize - 2];
                            spillCount = 0;
                        }

                        // This is the place where we just move everything down
                        // one element.  Note that if we hadn't allocated an
                        // extra space for scratch, this memmove would shift the
                        // last element in the Counts array to one past the last
                        // element.
                        //
                        // Yes, there are other ways to do this, but
                        // this is tested.  If you really want to change this,
                        // feel free.  The change would be to not overallocate,
                        // and to memmove only countSize - j - 1 elements here.
                        // If you do that, rearrange the code in the else block
                        // to do the countSize++ first, then you can change that
                        // memmove to be countSize - j - 1 also, and so you can
                        // put the memmove and the assign onto a common code
                        // path, out of the if and the else.
                        memmove(&Counts[j+1], &Counts[j],
                                (countSize - j) * sizeof(DWORD));
                        Counts[j] = pData[i].count;
                    }
                    else {
                        // We're not spilling.
                        memmove(&Counts[j+1], &Counts[j],
                                (countSize - j) * sizeof(DWORD));
                        Counts[j] = pData[i].count;

                        countSize++;
                    }
                }
            }

            // OK, now tighten up the pData, keeping anything with a count
            // greater than leastCountVal, and throw away spillCount objects
            // with value leastCountVal

            for(i=0,j=0;i<Size;i++) {
                if(pData[i].count > leastCountVal) {
                    // Keep this value.
                    pData[j] = pData[i];
                    j++;
                }
                else if(pData[i].count == leastCountVal) {
                    if(spillCount) {
                        spillCount--;
                    }
                    else {
                        // Keep this value.
                        pData[j] = pData[i];
                        j++;
                    }
                }
            }

            Size = j;
            THFreeEx(pTHS,Counts);

        }
        else {
            // We couldn't allocate the structure we need to find the maxOutSize
            // hottest objects, so we are arbitrarily keeping the first portion
            // of the data, not the hottest.
            Size = maxOutSize;
        }

    }

    (*ppResult)->pNext = NULL;
    (*ppResult)->cData = Size;
    (*ppResult)->pData  = realloc(pData, Size * sizeof(DNT_COUNT_STRUCT));

    if(!((*ppResult)->pData)) {
        free(pData);
        free(*ppResult);
        *ppResult = NULL;
        return FALSE;
    }


    return TRUE;
}


VOID
dnRegisterHotList (
        DWORD localCount,
        DNT_COUNT_STRUCT *DNTs
        )
/*++

  This routine is called by dnReadProcessTransactionalData, below.

  It is passed in an array of DNTs + counts, and a size specify the number of
  objects in the array.

  This routine takes the data and copies it into malloced memory.  This data is
  hung on a DNT_HOT_LIST structure (a linked list node, basically), and the data
  is added to the level 1 hot list.

  If the level 1 hot list is not yet full, the call returns.

  If the level 1 hot list is full, the routine takes the hot list from it's
  global pointer and calls dnAggregateInfo to condense all the DNT-counts in the
  level 1 hot list.  The resulting coallesced/condensed data is added to the
  level 2 hot list, which uses the same format as the level 1 hot list.

  If the level 2 hot list is not yet full, the call returns.

  If the level 2 hot list is full, the routine aggregates the info in that list
  and then puts the resulting list of DNTs in place as the global list of DNTs
  that should be in the global portion of the dnread cache.  If aggregating the
  info from the level 2 list results in fewer DNTs than we are willing to cache,
  DNTs from the global DNT cache list are added to the newly created one.  Since
  the lists are kept ordered by DNTs, lower DNTs are more likely to be
  transferred from the old list to the new than higher DNTs are.

  After the new list is put in place (a global pointer), a task queue event is
  placed to ask for a recalculation of the global portion of the dnread cache.

  Note also, that the lists are aggregated if this is the first time through
  this routine, or if it has been more than  DNREADREBUILDDELAY ticks since the
  lists have been aggregated.

  In general, if anything goes wrong during this routine (primarily memory
  allocation), then data is simply dropped, no errors are returned.  This could
  lead to empty global dnread caches, or lists of DNTs that are cold.  Neither
  condition is fatal, and should be cleaned up by simply waiting (unless
  something is seriously wrong with the machine, in which case other threads
  will be reporting errors.)


--*/
{
    DWORD *pNewDNReadCacheDNTs=NULL;
    DWORD i, Size, StaleCount=0;
    DNT_HOT_LIST *pThisElement, *pTemp;

    Assert(DsaIsRunning());

    if(!localCount || eServiceShutdown) {
        // Caller didn't really have a hot list, or we're about to exit
        return;
    }

    // Build a malloced element for the level 1 hot list.
    pThisElement = malloc(sizeof(DNT_HOT_LIST));
    if(!pThisElement) {
        return;
    }

    pThisElement->pNext = NULL;
    pThisElement->pData = malloc(localCount * sizeof(DNT_COUNT_STRUCT));
    if(!pThisElement->pData) {
        free(pThisElement);
        return;
    }

    memcpy(pThisElement->pData, DNTs, localCount * sizeof(DNT_COUNT_STRUCT));
    pThisElement->cData = localCount;

    // Now, add it to the level 1 list.
    EnterCriticalSection(&csDNReadLevel1List);
    __try {
        pThisElement->pNext = Level1HotList;

#if DBG
        {
            // Someone is mangling the pointer in the hotlist by incing or
            // decing it.  Let's try to catch them early.
            DNT_HOT_LIST *pTemp = Level1HotList;

            while(pTemp) {
                Assert(!(((DWORD_PTR)pTemp) & 3));
                pTemp = pTemp->pNext;
            }
        }
#endif

        // See how long it's been since we have signalled for a rebuild.  If
        // it's been long enough, set the flags. To force aggregation of both
        // lists now.
        if((GetTickCount() - gLastDNReadDNTUpdate) > DNREADREBUILDDELAY) {
            // reset the global tick count here, so that anyone coming through
            // here between now and when we actually get to signal doesn't also
            // aggregate the lists (which, if this thread is succesful, should
            // be empty).
            gLastDNReadDNTUpdate = GetTickCount();

            // Setting these flags to FALSE forces aggregation of the lists and
            // recalculation of the dnread dnt list.
            bImmediatelyAggregateLevel1List = TRUE;
            bImmediatelyAggregateLevel2List = TRUE;
        }

        // bImmediatelyAggregateLevel1List starts out globally TRUE so that the
        // first time someone comes through here, it lets the first
        // hot list blow right through here to get made into a global list of
        // DNTs to cache, since we don't have one already.
        if(bImmediatelyAggregateLevel1List ||
           (Level1HotListCount == MAX_LEVEL_1_HOT_LIST_LENGTH)) {

            bImmediatelyAggregateLevel1List = FALSE;
            Level1HotListCount = 0;
            Level1HotList = NULL;
        }
        else {
            Level1HotList = pThisElement;
            pThisElement = NULL;
            Level1HotListCount++;
        }
    }
    __finally {
        LeaveCriticalSection(&csDNReadLevel1List);
    }

    if(!pThisElement) {
        return;
    }


    DPRINT2(4,"Level 1 aggregate, 1- %d, 2- %d\n", Level1HotListCount,
            Level2HotListCount);

    // If pThisElement is non-null, we have been elected to aggregate the info
    // in a level 1 hot list and put it into a level 2 hot list.

    if(!dnAggregateInfo( pThisElement, MAX_LEVEL_2_HOT_DNTS, &pTemp)) {
        // Something failed in the aggregation.  Bail.  dnAggregate freed the
        // list we passed in.
        return;
    }

    pThisElement = pTemp;
    // Finally, add to the level 2 hot list.
    EnterCriticalSection(&csDNReadLevel2List);
    __try {
        pThisElement->pNext = Level2HotList;
#if DBG
        {
            // Someone is mangling the pointer in the hotlist by incing or
            // decing it.  Let's try to catch them early.
            DNT_HOT_LIST *pTemp = Level2HotList;

            while(pTemp) {
                Assert(!(((DWORD_PTR)pTemp) & 3));
                pTemp = pTemp->pNext;
            }
        }
#endif

        // bImmediatelyAggregateLevel2List starts out globally TRUE so that the
        // first time someone comes through here, it lets the first
        // hot list blow right through here to get made into a global list of
        // DNTs to cache, since we don't have one already.
        if(bImmediatelyAggregateLevel2List ||
           (Level2HotListCount == MAX_LEVEL_2_HOT_LIST_LENGTH)) {

            bImmediatelyAggregateLevel2List = FALSE;
            Level2HotListCount = 0;
            Level2HotList = NULL;
        }
        else {
            Level2HotList = pThisElement;
            pThisElement = NULL;
            Level2HotListCount++;
        }
    }
    __finally {
        LeaveCriticalSection(&csDNReadLevel2List);
    }


    if(!pThisElement) {
        return;
    }

    // Boy, are we lucky.  Aggregate the level 2 hot list and replace the global
    // dnt list.
    // First, find the max size we'll need.

    DPRINT2(4,"Level 2 aggregate, 1- %d, 2- %d\n", Level1HotListCount,
            Level2HotListCount);

    // If pThisElement is non-null, we have been elected to aggregate the info
    // in a level 1 hot list and put it into a level 2 hot list.
    pTemp = NULL;
#if DBG
    {
        // Someone is mangling the pointer in the hotlist by incing or
        // decing it.  Let's try to catch them early.
        DNT_HOT_LIST *pTemp = pThisElement;

        while(pTemp) {
            Assert(!(((DWORD_PTR)pTemp) & 3));
            pTemp = pTemp->pNext;
        }
    }
#endif
    if(!dnAggregateInfo( pThisElement, MAX_GLOBAL_DNTS, &pTemp)) {
        // Something failed in the aggregation.  Bail.  dnAggregate freed the
        // list we passed in.
        return;
    }

    pThisElement = pTemp;
    Size = pThisElement->cData;

    // OK, we now have aggregated the data.  It's sorted by DNT.
    // Prepare a new global DNT list.
    // NOTE!!! the global DNT list MUST remain sorted by DNT.
    pNewDNReadCacheDNTs = malloc(MAX_GLOBAL_DNTS * sizeof(DWORD));
    if(!pNewDNReadCacheDNTs) {
        free(pTemp->pData);
        pTemp->pData = NULL;
        free(pTemp);
        pTemp = NULL;
        //
        return;
    }

    for(i=0;i<Size;i++) {
        pNewDNReadCacheDNTs[i] = pThisElement->pData[i].DNT;
    }

    free(pThisElement->pData);
    free(pThisElement);

    // Next, if we don't have enought DNTs in the list, get enough from the
    // current list to get to MAX_GLOBAL_DNTS.
    if(Size < MAX_GLOBAL_DNTS) {
        // Yep, we don't have enough.  Steal some from the current global DNT
        // list.  Remember that that list is protected by a critical section.
        EnterCriticalSection(&csDNReadGlobalCache);
        __try {
            DWORD begin, end, middle;
            BOOL bFound;

            i=0;
            while((i<cGlobalDNTReadCacheDNTs) && (Size < MAX_GLOBAL_DNTS)) {
                begin = 0;
                end = Size;
                middle = (begin + end) / 2;
                bFound = TRUE;
                while(bFound && (pNewDNReadCacheDNTs[middle] !=
                                 pGlobalDNReadCacheDNTs[i])) {
                    if(pNewDNReadCacheDNTs[middle] >
                       pGlobalDNReadCacheDNTs[i]) {
                        end = middle;
                    }
                    else {
                        begin = middle;
                    }
                    if(middle == (begin + end) / 2) {
                        bFound = FALSE;
                        if(pNewDNReadCacheDNTs[middle] <
                           pGlobalDNReadCacheDNTs[i]) {
                            middle++;
                        }
                    }
                    else {
                        middle = (begin + end)/2;
                    }
                }
                if(!bFound) {
                    // Insert this.
                    if(middle < Size) {
                        memmove(&pNewDNReadCacheDNTs[middle + 1],
                                &pNewDNReadCacheDNTs[middle],
                                (Size - middle) * sizeof(DWORD));
                    }
                    StaleCount++;
                    Size++;
                    pNewDNReadCacheDNTs[middle] = pGlobalDNReadCacheDNTs[i];
                }
                i++;
            }
        }
        __finally {
            LeaveCriticalSection(&csDNReadGlobalCache);
        }

        pNewDNReadCacheDNTs = realloc(pNewDNReadCacheDNTs,
                                      Size * sizeof(DWORD));
    }

    DPRINT2(4,"New cache list has %d hot items, %d stale items.\n",
            Size - StaleCount, StaleCount);


    EnterCriticalSection(&csDNReadGlobalCache);
    __try {

        cGlobalDNTReadCacheDNTs = Size;
        if(pGlobalDNReadCacheDNTs) {
            free(pGlobalDNReadCacheDNTs);
        }

        pGlobalDNReadCacheDNTs = pNewDNReadCacheDNTs;
    }
    __finally {
        LeaveCriticalSection(&csDNReadGlobalCache);
    }

    gLastDNReadDNTUpdate = GetTickCount();

    // Mark to reload the dnread cache.
    InsertInTaskQueue(TQ_ReloadDNReadCache, NULL, 0);
}

VOID
dbResetLocalDNReadCache (
        THSTATE *pTHS,
        BOOL fForceClear
        )
/*++
  This routine clears the local dnread cache if it is suspect.  Also, if told to
  do so, it clears it no matter what.
--*/
{
    DWORD i, j;
    DWORD SequenceNumber;

    if(fForceClear) {
        // They want the cache cleared no matter what.  Use the invalid sequence
        // number.
        SequenceNumber = 0;
    }
    else {
        EnterCriticalSection(&csDNReadInvalidateData);
        __try {
            if(gDNReadNumCurrentInvalidators) {
                // Some one is currently trying to commit an invalidating
                // transaction.
                SequenceNumber = 0;
            }
            else {
                // OK, noone is trying to commit a transaction, so find out what
                // the current sequence is.
                SequenceNumber = gDNReadLastInvalidateSequence;
            }
        }
        __finally {
            LeaveCriticalSection(&csDNReadInvalidateData);
        }
    }
    // We now have the sequence number that should be on the local dnread
    // cache.  If the sequence number already on it equals the one we just
    // calculated, then no one has made any attempt to commit a transaction that
    // invalidated the dnread cache since this local dnread cache was created.
    // The one exception to that is if we calculated that this dnread cache
    // should have a sequence number of 0 (indicating we don't really know it's
    // relation to transactions in other threads), then we're going to clear out
    // the cache.

    if(SequenceNumber &&
       pTHS->LocalDNReadOriginSequence == SequenceNumber) {
        // Yep, the local cache is still good.
        return;
    }

    // Nope, we don't trust the contents of the local dnread cache.  Clear it
    // out.

    // Free all the name structures pointed to in the local dnread cache.
    for(i=0;i<LOCAL_DNREAD_CACHE_SIZE;i++) {
        for(j=0;j<DN_READ_CACHE_SLOT_NUM;j++) {
            if(SLOT(i,j).pName) {
                THFreeOrg(pTHS, SLOT(i,j).pName->pAncestors);
                Assert((WCHAR *)&(SLOT(i,j).pName[1]) ==
                       (SLOT(i,j).pName->tag.pRdn));
                THFreeOrg(pTHS, SLOT(i,j).pName);
            }
        }
        if(HOLD(i).pName) {
            THFreeOrg(pTHS, HOLD(i).pName->pAncestors);
            Assert((WCHAR *)&(HOLD(i).pName[1])==(HOLD(i).pName->tag.pRdn));
            THFreeOrg(pTHS, HOLD(i).pName);
        }
    }

    // Now, memset the whole thing to 0;
    memset(&pTHS->LocalDNReadCache, 0,
           sizeof(DNREADCACHEBUCKET) * LOCAL_DNREAD_CACHE_SIZE);

    pTHS->LocalDNReadOriginSequence = SequenceNumber;
}


VOID
dbReleaseDNReadCache(
        GLOBALDNREADCACHE *pCache
        )
/*++
  Description:
      Given a globaldnread cache structure, drop the refcount by one.  If the
      refcount drops to 0, free the structure.
--*/
{
    DWORD i, retval;
    GLOBALDNREADCACHESLOT *pData;

    if(!pCache) {
        return;
    }

    // Trying to track someone who is mangling a refcount.  Assume
    // no more than 1000 concurrent users of a DNReadCache.
    // This will trigger if we are inc'ing a value that is really a
    // pointer, which is the bug we're looking for.
    // Also, we shouldn't be releasing when the count is already at 0
    Assert(pCache->refCount);
    Assert(pCache->refCount < 1000);
    retval = InterlockedDecrement(&pCache->refCount);

    // If the interlocked decrement dropped this to 0, we must be the last ones
    // holding this globaldnread cache.  Free it.
    if(!retval) {
        Assert(!(pCache->refCount));
        // Since this is the last step to freeing this, it had better not be the
        // one still on the anchor.
        Assert(pCache != gAnchor.MainGlobal_DNReadCache);
        DPRINT1(3, "Freeing dnread cache 0x%X\n",pCache);
        if(pCache->pData) {
            pData = pCache->pData;
            for(i=0;i<pCache->count;i++) {
                free(pData[i].name.pAncestors);
                free(pData[i].name.tag.pRdn);
            }
            free(pData);
        }
        free(pCache);
    }

    return;
}

void
dbResetGlobalDNReadCache (
        THSTATE *pTHS
        )
/*++
  Description:
      Called from DBTransIn, and DBTransIn ONLY!!!
      Callers should already have taken the resource resGlobalDNReadCache.  See
      the description in DBTransIn and dbReplaceCacheInAnchor for why this is
      the case.


      Get a new dnread cache (or validate that the one we have is still the most
      current).

--*/
{
    GLOBALDNREADCACHE *pCache = NULL;
    Assert(OWN_RESOURCE_SHARED(&resGlobalDNReadCache));
    EnterCriticalSection(&gAnchor.CSUpdate);
    __try {
        // Get the new global dnread cache.  We do this inside this critical
        // section to avoid doing the compare in the if statement, then having
        // someone change gAnchor.MainGlobal_DNReadCache in another thread.  It
        // is insufficient to just make a local copy of the pointer, since the
        // MainGlobal_DNReadCache is refcounted, and is only guaranteed to be
        // valid while it's associated with the anchor.  That is, if we copied
        // the pointer out of the anchor, and then someone decoupled it from the
        // anchor, they would also drop it's refcount (since it's not being used
        // by the anchor anymore) which could result in the datastructure being
        // freed before we get to our interlocked increment below.

        if(pTHS->Global_DNReadCache !=  gAnchor.MainGlobal_DNReadCache) {
            // We need to get this new cache.  Remember the cache we already
            // have so we can release it (i.e. drop the refcount, maybe free it,
            // etc.)
            pCache = pTHS->Global_DNReadCache;

            // Grab the new cache.
            pTHS->Global_DNReadCache = gAnchor.MainGlobal_DNReadCache;

            if(pTHS->Global_DNReadCache) {
                // OK, we have a new global dnread cache.  Increment the
                // refcount before we leave the critical section to avoid having
                // it disappear beneath us.


                // DEBUG: Trying to track someone who is mangling a refcount.
                // Assume no more than 1000 concurrent users of a
                // Global_DNReadCache.
                // This will trigger if we are inc'ing a value that is
                // really a  pointer, which is the bug we're looking for.
                Assert(pTHS->Global_DNReadCache->refCount);
                Assert(pTHS->Global_DNReadCache->refCount < 1000);

                // Interlock the increment since the interlocked decrement is
                // not done inside the gAnchor.CSUpdate critical section.
                InterlockedIncrement(&pTHS->Global_DNReadCache->refCount);
            }
        }
    }
    __finally {
        LeaveCriticalSection(&gAnchor.CSUpdate);
    }

    // Now, free the old cache.
    if(pCache) {
        dbReleaseDNReadCache(pCache);
    }

    // Free any old cache support structures.
    if(pTHS->pGlobalCacheHits) {
        THFreeOrg(pTHS, pTHS->pGlobalCacheHits);
        pTHS->cGlobalCacheHits = 0;
        pTHS->pGlobalCacheHits = NULL;
    }

    if(!pTHS->Global_DNReadCache) {
        return;
    }

    // Build new cache support structures.
    if(pTHS->Global_DNReadCache->count) {
        // Create the parallel count structure.
        pTHS->cGlobalCacheHits = pTHS->Global_DNReadCache->count;
        pTHS->pGlobalCacheHits =
            THAllocOrg(pTHS, pTHS->cGlobalCacheHits * sizeof(DWORD));
        if ( pTHS->pGlobalCacheHits == NULL ) {
            pTHS->cGlobalCacheHits = 0;
        }
    }

    return;
}


VOID
dbReplaceCacheInAnchor(
        GLOBALDNREADCACHE *pCache
        )
/*
   Description:
       Replace the dnread cache in the anchor.  To do this, we must take the
       critical section guarding updating the anchor.

       Also, if we are putting a new cache (i.e. pCache != NULL) into the
       anchor, we must grab the GlobalDNReadCache resource in an exclusive
       fashion.  This avoids a problem where someone can begin a transaction and
       then have the global dnread cache in the anchor change.  If they then
       grab the new dnread cache, they could run into cache coherency problems
       where the new cache has data that doesn't agree with the jet transacted
       view. (see DBTransIn for more discussion of this, and the other use of
       the global dnread cache resource).

       This routine should be called with a non-NULL pCache only from the task
       queue thread that has built a new global dnread cache.  It can also be
       called from a normal worker thread that is committing a change that has
       caused a cache invalidation when it notices that the global dnread cache
       it is using is not the one currently on the anchor.

  Parameters:
      pCache - pointer to the new cache to put into the anchor.  If non-NULL,
          should already have a refcount of 1, representing the anchors use of
          the cache.

  Return values:
      None.
--*/
{
    GLOBALDNREADCACHE *pOldCache;

    if(pCache) {
        RtlAcquireResourceExclusive(&resGlobalDNReadCache, TRUE);
        Assert(OWN_RESOURCE_EXCLUSIVE(&resGlobalDNReadCache));
        __try { // finally to release resource.
            EnterCriticalSection(&gAnchor.CSUpdate);
            __try {// finally to leave critical section
                pOldCache = gAnchor.MainGlobal_DNReadCache;
                gAnchor.MainGlobal_DNReadCache = pCache;
                Assert(pCache->refCount == 1);
            }
            __finally {
                LeaveCriticalSection(&gAnchor.CSUpdate);
            }
        }
        __finally {
            RtlReleaseResource(&resGlobalDNReadCache);
        }

    }
    else {
        // In this case we're just trying to remove any global dnread cache.  It
        // is not important to grab the resource, since if someone grabs this
        // NULL pointer, they simply won't have a dnread cache, but will behave
        // correctly (i.e. since this cache is empty, it has no invalid data
        // with respect to transacted jet views).
        EnterCriticalSection(&gAnchor.CSUpdate);
        __try {
            pOldCache = gAnchor.MainGlobal_DNReadCache;
            gAnchor.MainGlobal_DNReadCache = pCache;
        }
        __finally {
            LeaveCriticalSection(&gAnchor.CSUpdate);
        }
    }
    // NOTE: it is important to remove the cache from the anchor
    // before releasing it.  Once a cache has been removed from the
    // anchor, it's ref count will never increase.  Therefore,
    // whenever the count reaches 0, it will be safe to delete the
    // cache.
    if(pOldCache) {
        Assert(pOldCache->refCount);
        dbReleaseDNReadCache(pOldCache);
    }

}

void
dbReleaseGlobalDNReadCache (
        THSTATE *pTHS
        )
{
    GLOBALDNREADCACHE *pOldCache;

    pOldCache = pTHS->Global_DNReadCache;
    if(pTHS->pGlobalCacheHits) {
        THFreeOrg(pTHS, pTHS->pGlobalCacheHits);
    }
    pTHS->cGlobalCacheHits = 0;
    pTHS->pGlobalCacheHits = NULL;
    pTHS->Global_DNReadCache = NULL;

    if(pOldCache) {
        dbReleaseDNReadCache(pOldCache);
    }

    return;
}
void
dnReadLeaveInvalidators (
        )
/*++
  Description:
     Bookkeeping for a thread leaving the list of active invalidators.  The only
     reason it's in its own routine is because the try/except can mess up code
     optimizations in other routines.
--*/
{
    EnterCriticalSection(&csDNReadInvalidateData);
    __try {
        // Keep invalidate sequence and the count of current
        // invalidators in sync, use a critsec
        gDNReadLastInvalidateSequence++;
        Assert(gDNReadNumCurrentInvalidators);
        gDNReadNumCurrentInvalidators--;
    }
    __finally {
        LeaveCriticalSection(&csDNReadInvalidateData);
    }
}
void
dnReadEnterInvalidators (
        )
/*++
  Description:
     Bookkeeping for a thread entering the list of active invalidators.  The
     only reason it's in its own routine is because the try/except can mess up
     code optimizations in other routines.
     --*/
{
    EnterCriticalSection(&csDNReadInvalidateData);
    __try {
        // Keep invalidate sequence and the count of current
        // invalidators in sync, use a critsec
        gDNReadLastInvalidateSequence++;
        gDNReadNumCurrentInvalidators++;
    }
    __finally {
        LeaveCriticalSection(&csDNReadInvalidateData);
    }
}

void
dnReadPostProcessTransactionalData (
        THSTATE *pTHS,
        BOOL fCommit,
        BOOL fCommitted
        )
/*++

  This routine is called by dbtransout.

  If we drop to transaction level 0, this routine sweeps through the local and
  global dn read cache and produces a list of the hottest DNTs (i.e. the highest
  hit count associated with them in the dnread cache).  No more than
  MAX_LEVEL_1_HOT_DNTS are kept.  This list is then passed off to
  dnRegisterHotDNTs.

--*/
{
    DWORD          i,j,k;
    DNT_COUNT_STRUCT       DNTs[MAX_LEVEL_1_HOT_DNTS];
    DWORD          localCount = 0;

    memset(DNTs, 0, sizeof(DNTs));

    Assert(VALID_THSTATE(pTHS));

    if(!fCommitted) {
        // We're aborting.  The local cache is suspect, so clear it out.
        dbResetLocalDNReadCache(pTHS, TRUE);

        // NOTE: we're keeping our global dnread cache, not picking up a new
        // copy.
        if(pTHS->cGlobalCacheHits) {
            memset(pTHS->pGlobalCacheHits, 0,
                   pTHS->cGlobalCacheHits * sizeof(DWORD));
        }
    }
    else if (pTHS->transactionlevel == 0 ) {
        Assert(fCommitted);
        if(DsaIsRunning()) {
            // OK, we're committing to transaction level 0.  Go through the
            // local dnread cache and add them to the list of objects we would
            // like added to the global dn read cache.

            // NOTE: the global dnread cache is built using the task queue.  If
            // we are not DSAIsRunning(), then the task queue isn't even here,
            // so don't bother doing any of this.
            for(i=0; i<LOCAL_DNREAD_CACHE_SIZE;i++) {
                if(SLOT(i,0).DNT) {
                    // The first DNT was not 0.  That implies there might
                    // actually be some full entries in this cache bucket, and
                    // the HOLD also might have some data.
                    for(j=0;SLOT(i,j).DNT && j<DN_READ_CACHE_SLOT_NUM;j++) {

                        if(SLOT(i,j).pName) {
                            k=0;
                            while(k < MAX_LEVEL_1_HOT_DNTS &&
                                  DNTs[k].count > SLOT(i,j).hitCount) {
                                k++;
                            }
                            if(k<MAX_LEVEL_1_HOT_DNTS) {
                                if(!DNTs[MAX_LEVEL_1_HOT_DNTS - 1].DNT) {
                                    // We are not going to be dropping a DNT off
                                    // the end of the list, so up the count by
                                    // 1. I.E. we are adding a DNT to the list,
                                    // not replacing one.
                                    localCount++;
                                }
                                memmove(&DNTs[k + 1], &DNTs[k],
                                        ((MAX_LEVEL_1_HOT_DNTS - k - 1 ) *
                                         sizeof(DNT_COUNT_STRUCT)));
                                DNTs[k].DNT = SLOT(i,j).DNT;
                                DNTs[k].count = SLOT(i,j).hitCount;
                                SLOT(i,j).hitCount = 1;
                            }
                        }
                    }

                    // try the second chance slot
                    if(HOLD(i).pName) {
                        k=0;
                        while(k < MAX_LEVEL_1_HOT_DNTS &&
                              DNTs[k].count > HOLD(i).hitCount) {
                            k++;
                        }
                        if(k<MAX_LEVEL_1_HOT_DNTS) {
                            if(!DNTs[MAX_LEVEL_1_HOT_DNTS - 1].DNT) {
                                // We are not going to be dropping a DNT off the
                                // end of the list, so up the count by 1.
                                // I.E. we are adding a DNT to the list, not
                                // replacing  one.
                                localCount++;
                            }
                            memmove(&DNTs[k + 1], &DNTs[k],
                                    ((MAX_LEVEL_1_HOT_DNTS - k - 1 ) *
                                     sizeof(DNT_COUNT_STRUCT)));
                            DNTs[k].DNT = HOLD(i).DNT;
                            DNTs[k].count = HOLD(i).hitCount;
                            HOLD(i).hitCount = 1;
                        }
                    }
                }
            }

            // finally, scan through the hit count of the global structure to
            // see how hot they were.
            for(i=0;i<pTHS->cGlobalCacheHits;i++) {
                if(pTHS->pGlobalCacheHits[i] >
                   DNTs[MAX_LEVEL_1_HOT_DNTS - 1].count) {

                    // Yep, this is a hot one.
                    k = MAX_LEVEL_1_HOT_DNTS - 1;

                    while(k &&
                          DNTs[k].count <
                          pTHS->pGlobalCacheHits[i])
                        k--;

                    if(!DNTs[MAX_LEVEL_1_HOT_DNTS - 1].DNT) {
                        // We are not going to be dropping a DNT off the end
                        // of the list, so up the count by 1.  I.E. we are
                        // adding a DNT to the list, not replacing one.
                        localCount++;
                    }
                    memmove(&DNTs[k + 1], &DNTs[k],
                            ((MAX_LEVEL_1_HOT_DNTS - k - 1 ) *
                             sizeof(DNT_COUNT_STRUCT)));

                    DNTs[k].count = pTHS->pGlobalCacheHits[i];
                    DNTs[k].DNT = pTHS->Global_DNReadCache->pData[i].name.DNT;
                }
            }

            dnRegisterHotList(localCount,DNTs);
        }

        // NOTE: we're keeping our global dnread cache, not picking up a new
        // copy. We are also keeping our local dnread cache.
        if(pTHS->cGlobalCacheHits) {
            memset(pTHS->pGlobalCacheHits, 0,
                   pTHS->cGlobalCacheHits * sizeof(DWORD));
        }

        if(pTHS->fDidInvalidate) {
            // In preprocessing, we should have verified that the global dnread
            // cache this thread is using is the same as the one on the anchor,
            // or we should have nulled the one on the anchor.  Further, if we
            // nulled it, then the gDNReadLastInvalidateSequence and
            // gDNReadNumCurrentInvalidators should have kept us from getting a
            // new global dnread cache in the anchor.  Assert this.
            // Note, we are looking at gAnchor.MainGlobal_DNReadCache outside
            // the csUpdate critsec.  Thus, it is conceivable that inbetween the
            // two clauses of the OR in the assert, it's value could change,
            // doing weird things to the assert. Not bloody likely, it it?
            Assert(!gAnchor.MainGlobal_DNReadCache ||
                   (pTHS->Global_DNReadCache==gAnchor.MainGlobal_DNReadCache));


            // Write to the global variables that holds the sequence info of the
            // last commit that was on a thread that invalidated the cache. The
            // global dnread cache manager uses this information to help
            // consistency. The critical section is used to keep the
            // last invalidate time in sync with the last invalidate sequence.
            dnReadLeaveInvalidators();

            // Reset the flag
            pTHS->fDidInvalidate = FALSE;
        }
    }

    return;
}
BOOL
dnReadPreProcessTransactionalData (
        BOOL fCommit
        )
/*++

  This routine is called by dbtransout.

  If we drop to transaction level 0, and we are going to commit, check to see if
  we made a change that invalidates the dnread cache.  If so, mark that so the
  world knows about it.
--*/
{
    THSTATE       *pTHS = pTHStls;

    Assert(VALID_THSTATE(pTHS));
    Assert(pTHS->transactionlevel);

    if(fCommit && pTHS->transactionlevel <= 1 ) {
        Assert(pTHS->transactionlevel == 1);
        // OK, we're committing to transaction level 0.

#if DBG
        if(gfExhaustivelyValidateDNReadCache) {
            dbExhaustivelyValidateDNReadCache(pTHS);
        }
#endif

        if(pTHS->fDidInvalidate) {
            // Write to the global variable that holds the time of the
            // last commit that was on a thread that invalidated the cache. The
            // global dnread cache manager uses this information to help
            // consistency.
            dnReadEnterInvalidators();

            // Since we just inc'ed the invalidate sequence and the
            // currentinvalidators count, we can be assured that no new global
            // dnread cache will be created until after we have post processed
            // the dnread cache stuff and dropped the invalidator count back to
            // 0. However, someone may have already built a new global dnread
            // cache while we had our transaction open.  Therefore, the thing we
            // invalidated in this threads global dnread cache isn't invalidated
            // in that other global dnread cache.  So, we're going to throw away
            // any new global dnread cache.  Any thread that already has a
            // handle to this new dnread cache is OK since it's transaction is
            // already open.  What we need to do is prevent transactions that
            // open after the one we are in picking up that potentially invalid
            // dnread cache.  Note that that other cache may have invalidations
            // that we don't have, so the only safe thing to do is to throw away
            // both (i.e. decouple both from the gAnchor and let the refounts
            // clear them up).

            if(pTHS->Global_DNReadCache != gAnchor.MainGlobal_DNReadCache) {
                DPRINT(3, "Hey, we invalidated and got a new dnread cache\n");

                // Switch the universe to use the NO global cache
                dbReplaceCacheInAnchor(NULL);
            }
        }
    }

    return TRUE;
}

/* dbFlushDNReadCache
 *
 * Purges a specific item from the DNRead cache, and from the global cache,
 * if necessary.
 *
 * INPUT:
 *   DNT - the DNT of the item to be flushed from the cache
 */
void
dbFlushDNReadCache (
        IN DBPOS *pDB,
        IN ULONG tag
        )
{
    THSTATE *pTHS = pTHStls;
    GLOBALDNREADCACHESLOT *pData;
    DWORD index;
    DWORD i;
    DWORD PDNTMask=0;
    DWORD ulRDNLenMask=0;
    BOOL fFound = FALSE;

    // Remember that we attempted to invalidate something.
    //
    // Except when a new object is created. From 383459...
    // Entries in the DNread cache are invalidated whenever certain
    // attributes on the objects are modified.  It looks like what's
    // happening is that setting those attributes on an object
    // currently being adding causes the object  to be marked as
    // invalidated.  When invalidations occur while the global cache
    // is being rebuilt, the newly built cache is suspect and has to
    // be abandoned.  We need to avoid triggering the invalidation logic
    // for objects being added.  This is safe because those objects are
    // not yet globally visible and hence could not have appeared in any
    // cache other than the current thread's, and hence do not need to be
    // invalidated.
    //
    // The fix is to remember the last, newly created row's DNT and
    // avoid triggering the invalidation logic by not setting
    // fDidInvalidate.
    if (pDB->NewlyCreatedDNT != tag) {
        pTHS->fDidInvalidate = TRUE;
    }

    // Look for the object in the local cache
    index = tag & LOCAL_DNREAD_CACHE_MASK;
    for(i=0;i<DN_READ_CACHE_SLOT_NUM;i++) {
        if(!fFound && SLOT(index,i).DNT == tag) {
            fFound = TRUE;
            // Found it.
            THFreeOrg(pTHS, SLOT(index,i).pName->pAncestors);
            Assert((WCHAR *)&(SLOT(index,i).pName[1])==
                   (SLOT(index,i).pName->tag.pRdn));
            THFreeOrg(pTHS, SLOT(index,i).pName);
            // Copy the HOLD slot
            if(HOLD(index).pName) {
                INC_CACHE_KEEP_HOLD;
                SLOT(index,i) = HOLD(index);
                memset(&(HOLD(index)), 0, sizeof(DNREADCACHESLOT));
            }
            else {
                memset(&(SLOT(index,i)), 0, sizeof(DNREADCACHESLOT));
                // Set the DNT to a bad but non-zero DNT.  We use this info to
                // help short circuit scans through the slots (i.e. if we hit a
                // slot with DNT==0, then there are no more full slots after
                // it). Since there might be a full slot after this, we can't
                // leave it marked as 0.
                SLOT(index,i).DNT = INVALIDDNT;
            }

            // keep going to recalculate the masks in the index
        }


        PDNTMask |= SLOT(index,i).PDNT;
        ulRDNLenMask |= SLOT(index,i).ulRDNLen;

    }

    // try the second chance slot
    if(!fFound && HOLD(index).DNT == tag) {
        fFound = TRUE;
        THFreeOrg(pTHS, HOLD(index).pName->pAncestors);
        Assert((WCHAR *)&(HOLD(index).pName[1])==(HOLD(index).pName->tag.pRdn));
        THFreeOrg(pTHS, HOLD(index).pName);
        memset(&(HOLD(index)), 0, sizeof(DNREADCACHESLOT));
    }
    else {
        PDNTMask |= HOLD(index).PDNT;
        ulRDNLenMask |= HOLD(index).ulRDNLen;
    }

    if(fFound) {
        // We now have a new value for the mask.
        INDEX(index).PDNT = PDNTMask;
        INDEX(index).ulRDNLen = ulRDNLenMask;
    }

    Assert(PDNTMask == INDEX(index).PDNT);
    Assert(ulRDNLenMask == INDEX(index).ulRDNLen);

    // Even if it was in the local cache, we need to look in the Global (there
    // are a few weird cases where we can end up with an object in both the
    // local and global dnread caches).
    // PERFORMANCE: Could do a binary search here.
    if(pTHS->Global_DNReadCache && pTHS->Global_DNReadCache->pData) {
        pData = pTHS->Global_DNReadCache->pData;
        for(i=0;i<pTHS->Global_DNReadCache->count;i++) {
            if(pData[i].name.DNT == tag) {
                // found it
                pData[i].valid = FALSE;

                // Newly created row should not be in the global dnread cache
                Assert(pDB->NewlyCreatedDNT != tag
                       && "Newly created row should not be in the global dnread cache");

                return;
            }
        }
    }

    return;
}

BOOL
dnGetCacheByDNT(
        DBPOS *pDB,
        DWORD tag,
        d_memname **ppname
        )
/*++

  Look in the dnread cache for the specified tag (DNT).  Both the global and
  local dnread cachre are searched.  If the DNT is found, a pointer to the
  memname structure for that DNT is returned, along with a return value of TRUE.
  If it is not found, FALSE is returned.
  If it is found, a count associated with the DNT is incremented.

--*/
{
    GLOBALDNREADCACHESLOT *pData;
    DWORD index;
    BOOL  bFound;
    DWORD begin, end, middle, i;
    THSTATE *pTHS = pDB->pTHS;

    Assert(pTHS->transactionlevel);
    INC_FIND_BY_DNT;

    Assert(ppname);
    (*ppname)=NULL;

    if(!tag) {
        return FALSE;
    }

    PERFINC(pcNameCacheTry);
    // First, look in the global cache.

    if(pTHS->Global_DNReadCache && pTHS->Global_DNReadCache->pData) {
        pData = pTHS->Global_DNReadCache->pData;

        // Look up the correct node in the pData array. Since pData is
        // sorted by DNT, use a binary search.
        begin = 0;
        end = pTHS->Global_DNReadCache->count;
        middle = (begin + end) / 2;
        bFound = TRUE;
        while(bFound && (pData[middle].name.DNT != tag)) {
            if(pData[middle].name.DNT > tag) {
                end = middle;
            }
            else {
                begin = middle;
            }
            if(middle == (begin + end) / 2) {
                bFound = FALSE;
            }
            else  {
                middle = (begin + end) / 2;
            }

        }
        if(bFound) {
            // found it
            if(pData[middle].valid) {
                *ppname = &pData[middle].name;
                PERFINC(pcNameCacheHit);
                if(pTHS->cGlobalCacheHits > middle) {
                    pTHS->pGlobalCacheHits[middle] += 1;
                }
                return TRUE;
            }
        }
    }

    // Didn't find it in the global cache (or it was invalid).



    index = tag & LOCAL_DNREAD_CACHE_MASK;

    if(!INDEX(index).ulRDNLen) {
        // Nothing in this bucket has any length for an RDN, so the bucket must
        // be empty.
        return FALSE;
    }

    // This loop stops after either looking at all the slots or finding a slot
    // with no DNT.  We prefill all slots with a 0 DNT, and if we invalidate a
    // slot, we fill the DNT with INVALIDDNT, so if we hit a slot with DNT ==
    // 0, then we know there are no more values after it.
    for(i=0;SLOT(index,i).DNT && i<DN_READ_CACHE_SLOT_NUM;i++) {
        if(SLOT(index,i).DNT == tag) {
            PERFINC(pcNameCacheHit);
            *ppname = SLOT(index, i).pName;
            SLOT(index,i).hitCount++;
            return TRUE;
        }
    }

    // try the second chance slot
    if(HOLD(index).DNT == tag) {
        DNREADCACHESLOT tempSlot;
        PERFINC(pcNameCacheHit);
        INC_CACHE_KEEP_HOLD;

        *ppname = HOLD(index).pName;

        // Swap the next slot and the hold.
        tempSlot = HOLD(index);
        HOLD(index) = NEXTSLOT(index);
        NEXTSLOT(index) = tempSlot;
        NEXTSLOT(index).hitCount++;

        INCREMENTINDEX(index);
        return TRUE;
    }

    return FALSE;

}

BOOL
dnGetCacheByPDNTRdn (
        DBPOS *pDB,
        DWORD parenttag,
        DWORD cbRDN,
        WCHAR *pRDN,
        ATTRTYP rdnType,
        d_memname **ppname)
/*++

  Look in the dnread cache for the specified combination of parenttag, RDN, and
  rdn length.  Both the global and local dnread cachre are searched.  If the
  object is found, a pointer to the memname structure for that object is
  returned, along with a return value of TRUE.  If it is not found, FALSE is
  returned.  If it is found, a count associated with the object is incremented.

  NOTE:
  The local and global dn read caches are optimized for looking up DNTs.  This
  routine does a linear scan through the caches to find the objects.

--*/
{
    DWORD i, j;
    GLOBALDNREADCACHESLOT *pData;
    THSTATE *pTHS = pDB->pTHS;
    DWORD dwHashRDN;

    INC_FIND_BY_PDNT_RDN;

    Assert(pTHS->transactionlevel);

    PERFINC(pcNameCacheTry);
    Assert(ppname);
    (*ppname)=NULL;

    if(!parenttag) {
        return FALSE;
    }

    dwHashRDN = DSStrToHashKey (pDB->pTHS, pRDN, cbRDN / sizeof (WCHAR));

    // First, look in the global cache.
    if(pTHS->Global_DNReadCache && pTHS->Global_DNReadCache->pData) {
        pData = pTHS->Global_DNReadCache->pData;
        for(i=0;i<pTHS->Global_DNReadCache->count;i++) {
            if((pData[i].name.tag.PDNT == parenttag) &&
               (pData[i].name.tag.rdnType == rdnType) &&
               (pData[i].dwHashKey == dwHashRDN) &&
               (gDBSyntax[SYNTAX_UNICODE_TYPE].Eval(
                       pDB,
                       FI_CHOICE_EQUALITY,
                       cbRDN,
                       (PUCHAR)pRDN,
                       pData[i].name.tag.cbRdn,
                       (PUCHAR)pData[i].name.tag.pRdn))) {

                // found it
                if(pData[i].valid) {
                    PERFINC(pcNameCacheHit);
                    *ppname = &pData[i].name;
                    if(pTHS->cGlobalCacheHits > i) {
                        pTHS->pGlobalCacheHits[i] += 1;
                    }
                    return TRUE;
                }
                // It's invalid.  Break out of the while loop, since it still
                // might in the local.
                break;
            }
        }
    }
    // Didn't find it in the global cache.

    for(i=0; i<LOCAL_DNREAD_CACHE_SIZE;i++) {

        if( (INDEX(i).PDNT & parenttag) == parenttag) {
            // This bucket might hold a match.

            // This loop stops after either looking at all the slots or finding
            // a slot a with no DNT.  We prefill all slots with a 0 DNT, and if
            // we invalidate a slot, we fill the DNT with INVALIDDNT, so if we
            // hit a slot with DNT == 0, then we know there are no more values
            // after it.
            for(j=0;SLOT(i,j).DNT && j<DN_READ_CACHE_SLOT_NUM;j++) {
                if((SLOT(i,j).PDNT == parenttag) &&
                   (SLOT(i,j).pName->tag.rdnType == rdnType) &&
                   (SLOT(i,j).dwHashKey == dwHashRDN) &&
                   (gDBSyntax[SYNTAX_UNICODE_TYPE].Eval(
                           pDB, FI_CHOICE_EQUALITY,
                           cbRDN,
                           (PUCHAR)pRDN,
                           SLOT(i,j).ulRDNLen,
                           (PUCHAR)SLOT(i,j).pName->tag.pRdn))) {

                    PERFINC(pcNameCacheHit);
                    *ppname = SLOT(i,j).pName;
                    SLOT(i,j).hitCount++;
                    return TRUE;
                }
            }

            // try the second chance slot
            if((HOLD(i).PDNT == parenttag) &&
               (HOLD(i).pName->tag.rdnType == rdnType) &&
               (HOLD(i).dwHashKey == dwHashRDN) &&
               (gDBSyntax[SYNTAX_UNICODE_TYPE].Eval(
                       pDB, FI_CHOICE_EQUALITY,
                       cbRDN,
                       (PUCHAR)pRDN,
                       HOLD(i).ulRDNLen,
                       (PUCHAR)HOLD(i).pName->tag.pRdn))) {
                DNREADCACHESLOT tempSlot;

                PERFINC(pcNameCacheHit);
                INC_CACHE_KEEP_HOLD;

                *ppname = HOLD(i).pName;

                // Swap the next slot and the hold.
                tempSlot = HOLD(i);
                HOLD(i) = NEXTSLOT(i);
                NEXTSLOT(i) = tempSlot;
                NEXTSLOT(i).hitCount++;

                INCREMENTINDEX(i);

                return TRUE;
            }
        }
    }

    return FALSE;
}


BOOL
dnGetCacheByGuid (
        DBPOS *pDB,
        GUID *pGuid,
        d_memname **ppname)
/*++

  Look in the dnread cache for an object with the specified guid.  Both the
  global and local dnread cachre are searched.  If the
  object is found, a pointer to the memname structure for that object is
  returned, along with a return value of TRUE.  If it is not found, FALSE is
  returned.  If it is found, a count associated with the object is incremented.


  NOTE:
  The local and global dn read caches are optimized for looking up DNTs.  This
  routine does a linear scan through the caches to find the objects.

--*/
{
    DWORD i, j;
    GLOBALDNREADCACHESLOT *pData;
    THSTATE *pTHS = pDB->pTHS;
    INC_FIND_BY_GUID;

    Assert(pTHS->transactionlevel);

    PERFINC(pcNameCacheTry);
    Assert(ppname);
    (*ppname)=NULL;

    if(!pGuid) {
        return FALSE;
    }

    // First, look in the global cache.
    if(pTHS->Global_DNReadCache && pTHS->Global_DNReadCache->pData) {
        pData = pTHS->Global_DNReadCache->pData;
        for(i=0;i<pTHS->Global_DNReadCache->count;i++) {
            if(!(memcmp(pGuid, &pData[i].name.Guid, sizeof(GUID)))) {

                // found it
                if(pData[i].valid) {
                    *ppname = &pData[i].name;
                    PERFINC(pcNameCacheHit);
                    if(pTHS->cGlobalCacheHits > i) {
                        pTHS->pGlobalCacheHits[i] += 1;
                    }
                    return TRUE;
                }
                // It's invalid.  Break out of the while loop, since it still
                // might in the local.
                break;
            }
        }
    }

    for(i=0; i<LOCAL_DNREAD_CACHE_SIZE;i++) {
        if(INDEX(i).ulRDNLen) {
            // Something in this bucket has an RDN, so the bucket must not
            // be empty.  Scan it.

            // This loop stops after either looking at all the slots or finding
            // a slot a with no DNT.  We prefill all slots with a 0 DNT, and if
            // we invalidate a slot, we fill the DNT with INVALIDDNT, so if we
            // hit a slot with DNT == 0, then we know there are no more values
            // after it.
            for(j=0;SLOT(i,j).DNT && j<DN_READ_CACHE_SLOT_NUM;j++) {
                if(SLOT(i,j).pName &&
                   !memcmp(&(SLOT(i,j).pName->Guid), pGuid,sizeof(GUID))) {

                    PERFINC(pcNameCacheHit);
                    *ppname = SLOT(i,j).pName;
                    SLOT(i,j).hitCount++;
                    return TRUE;
                }
            }

            // try the second chance slot
            if(HOLD(i).pName &&
               !memcmp(&(HOLD(i).pName->Guid), pGuid, sizeof(GUID))) {

                DNREADCACHESLOT tempSlot;

                PERFINC(pcNameCacheHit);
                INC_CACHE_KEEP_HOLD;

                *ppname = HOLD(i).pName;

                // Swap the next slot and the hold.
                tempSlot = HOLD(i);
                HOLD(i) = NEXTSLOT(i);
                NEXTSLOT(i) = tempSlot;
                NEXTSLOT(i).hitCount++;

                INCREMENTINDEX(i);

                return TRUE;
            }
        }
    }

    return FALSE;
}

JET_RETRIEVECOLUMN dnreadColumnInfoTemplate[] = {
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0},
    { 0, 0, 0, 0, 0, 0, 1, 0, 0}
    };

d_memname *
dnCreateMemname(
        IN DBPOS * pDB,
        IN JET_TABLEID tblid
        )
/*++

Routine Description:

    Create a memname for the record with currency in the given
    tableid.


Arguments:

    pDB (IN)
    tblid (IN) - cursor for the record to be added to the cache.

Return Values:

   NULL if something went wrong, a pointer to the full memname otherwise.  The
       memory is allocated using THAllocOrg, so remember that when you free it.

--*/
{
    THSTATE *          pTHS = pDB->pTHS;
    JET_RETRIEVECOLUMN columnInfo[11];
    JET_ERR            err;
    d_memname         *pname;
    ATTCACHE          *pAC;

    Assert(VALID_DBPOS(pDB));

    // build a memname from the thread heap.  Alloc a single buffer big
    // enough to hold the memname
    // AND the RDN.
    pname = THAllocOrgEx(pTHS,sizeof(d_memname) + MAX_RDN_SIZE * sizeof(WCHAR));
    // Set the pointer to the start of the RDN buffer.
    pname->tag.pRdn = (WCHAR *)&pname[1];

    // Guess at a number of ancestors.  Why 25? Why not?
    pname->pAncestors = THAllocOrgEx(pTHS, 25 * sizeof(DWORD));

    // Populate the new read cache entry.
    memcpy(columnInfo,dnreadColumnInfoTemplate,
           sizeof(dnreadColumnInfoTemplate));

    columnInfo[0].pvData = &pname->DNT;
    columnInfo[1].pvData = &pname->tag.PDNT;
    columnInfo[2].pvData = &pname->objflag;
    columnInfo[3].pvData = &pname->tag.rdnType;
    columnInfo[4].pvData = &pname->NCDNT;
    columnInfo[5].pvData = &pname->Guid;
    columnInfo[6].pvData = &pname->Sid;
    columnInfo[7].pvData = pname->tag.pRdn;
    columnInfo[8].pvData = &pname->dwObjectClass;
    columnInfo[9].pvData = &pname->sdId;
    columnInfo[10].pvData = pname->pAncestors;
    columnInfo[10].cbData = 25*sizeof(DWORD);

    err = JetRetrieveColumnsWarnings(pDB->JetSessID, tblid, columnInfo, 11);

    if ((err != JET_errSuccess) && (err != JET_wrnColumnNull) && (err != JET_wrnBufferTruncated)) {
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
    }

    pname->tag.cbRdn = columnInfo[7].cbActual;
    // No 0 byte RDNs, please.
    Assert(pname->tag.cbRdn);
    pname->SidLen       = columnInfo[6].cbActual;

    pname = THReAllocOrgEx(pTHS, pname, sizeof(d_memname) + pname->tag.cbRdn);
    pname->tag.pRdn = (WCHAR *)&pname[1];

    if (0 == columnInfo[5].cbActual) {
        // No GUID on this record.
        memset(&pname->Guid, 0, sizeof(pname->Guid));
    }

    if (pname->SidLen) {
        // Convert the SID from internal to external format.
        InPlaceSwapSid(&(pname->Sid));
    }

    // figure out what we got for the SD id
    switch (columnInfo[9].err) {
    case JET_errSuccess:
        // normal case;
        break;

    case JET_wrnColumnNull:
        pname->sdId = (SDID)0;
        break;

    case JET_wrnBufferTruncated:
        // must be an old-style SD (longer than 8 bytes)
        // we don't really want to read it into the cache...
        pname->sdId = (SDID)-1;
        break;

    default:
        // some other error... we should not be here
        Assert(!"error reading SD id");
        DsaExcept(DSA_DB_EXCEPTION, columnInfo[9].err, 0);
    }

    // process Ancestors
    switch (columnInfo[10].err) {
    case JET_errSuccess:
        // OK, we got the ancestors.  Realloc down
        pname->pAncestors = THReAllocOrgEx(pTHS, pname->pAncestors, columnInfo[10].cbActual);
        break;

    case JET_wrnBufferTruncated:
        // Failed to read, not enough memory.  Realloc it larger.
        pname->pAncestors = THReAllocOrgEx(pTHS, pname->pAncestors, columnInfo[10].cbActual);

        if(err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                           tblid,
                                           ancestorsid,
                                           pname->pAncestors,
                                           columnInfo[10].cbActual,
                                           &columnInfo[10].cbActual, 0, NULL)) {
            // Failed again.
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
        }
        break;

    default:
        // Failed badly.
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
        break;
    }
    pname->cAncestors = columnInfo[10].cbActual / sizeof(DWORD);

    return pname;
}


d_memname *
DNcache(
        IN  DBPOS *     pDB,
        IN  JET_TABLEID tblid,
        IN  BOOL        bCheckForExisting
        )
/*++

  This routine adds an entry for the current object in the table specified to
  the local dn read cache.

--*/
{
    THSTATE    *pTHS = pDB->pTHS;
    DWORD       index, i;
    d_memname  *pname;
    d_memname  *pTemp;

    Assert(pDB == pDBhidden || pTHS->transactionlevel);

    // First, create a memname to be cached.
    pname = dnCreateMemname(pDB, tblid);
    if(pDB == pDBhidden || !pname->tag.PDNT || !pname->DNT) {
        // Hey, don't bother putting this in the cache, we're in a dangerous
        // place.
        return pname;
    }

    if(bCheckForExisting &&
       // The caller didn't already check the cache for this entry.  We need to
       // see if it is already there, and only add this to the cache if it isn't
       dnGetCacheByDNT(pDB, pname->DNT, &pTemp)
       // This is  already in the cache, don't add it.
                                             ) {
        return pname;
    }

#if DBG
    // Make sure no pre-existing cache entry has the same tag, GUID, or
    // PDNT & RDN type & RDN.
    {

        INC_CACHE_CHECK;

        Assert(!dnGetCacheByDNT(pDB,pname->DNT,&pTemp));
        DEC(pcNameCacheTry);

        Assert(!dnGetCacheByPDNTRdn(pDB,
                                    pname->tag.PDNT,
                                    pname->tag.cbRdn,
                                    pname->tag.pRdn,
                                    pname->tag.rdnType,
                                    &pTemp));
        DEC(pcNameCacheTry);

        Assert(fNullUuid(&pname->Guid) ||
               !dnGetCacheByGuid(pDB,
                                 &pname->Guid,
                                 &pTemp));

        DEC(pcNameCacheTry);

    }
#endif



    // Now, add it to the cache.

    // First, find the correct spot.
    index = pname->DNT & LOCAL_DNREAD_CACHE_MASK;
    // Now, see if we need to copy the thing in the slot to the hold.
    if(NEXTSLOT(index).pName) {
        // Yep, that slot is in use.
        if(HOLD(index).pName) {
            INC_CACHE_THROW_HOLD;

            THFreeOrg(pTHS, HOLD(index).pName->pAncestors);
            Assert((WCHAR *)&(HOLD(index).pName[1]) ==
                   (HOLD(index).pName->tag.pRdn));
            THFreeOrg(pTHS, HOLD(index).pName);
            memset(&(HOLD(index)), 0, sizeof(DNREADCACHESLOT));
        }
        HOLD(index) = NEXTSLOT(index);
    }

    // OK, we've copied away the contents of the slot if we needed to.
    // Now, fill in the slot with the new info.
    NEXTSLOT(index).DNT = pname->DNT;
    NEXTSLOT(index).PDNT = pname->tag.PDNT;
    NEXTSLOT(index).ulRDNLen = pname->tag.cbRdn;
    NEXTSLOT(index).pName = pname;
    NEXTSLOT(index).hitCount = 1;
    NEXTSLOT(index).dwHashKey = DSStrToHashKey (pTHS,
                                                pname->tag.pRdn,
                                                pname->tag.cbRdn / sizeof (WCHAR));

    // recalculate the masks
    INDEX(index).PDNT = HOLD(index).PDNT;
    INDEX(index).ulRDNLen = HOLD(index).ulRDNLen;
    for(i=0;i<DN_READ_CACHE_SLOT_NUM;i++) {
        INDEX(index).PDNT |= SLOT(index,i).PDNT;
        INDEX(index).ulRDNLen |= SLOT(index,i).ulRDNLen;
    }
    INCREMENTINDEX(index);

    DPRINT5(3, "Cached tag = 0x%x, ptag = 0x%x, RDN = '%*.*ls'\n",
            pname->DNT, pname->tag.PDNT,
            pname->tag.cbRdn/2, pname->tag.cbRdn/2,
            pname->tag.pRdn);

    return pname;
}




/* ReloadDNReadCache
 *
 * This routine (invoked off of the task queue) resets the global DNread
 * cache to something sensible.  We do this by clearing our thread's cache,
 * seeking some interesting DNTS, and directly creating cache items for
 * them.
 *
 * INPUT:
 *   A bunch of junk that we don't use, to match the task queue prototype
 */
void
ReloadDNReadCache(
    IN  void *  buffer,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    )
{
    THSTATE * pTHS = pTHStls;
    DWORD i,j;
    GLOBALDNREADCACHE *pNewCache=NULL;
    DWORD index;
    GLOBALDNREADCACHESLOT *pData;
    void * * pFreeBuf;
    DWORD localCount;
    DWORD *localDNTList;
    BOOL  fDoingRebuild = TRUE;
    DWORD LastInvalidateSequenceOrig;
    BOOL bDefunct;

    // This is inside the critical section to keep the sequence and count of
    // current invalidators in sync.
    EnterCriticalSection(&csDNReadInvalidateData);
    __try {
        if(gDNReadNumCurrentInvalidators) {
            // Someone is actively, right now, working on committing a
            // transaction that caused a cache invalidation.  We won't rebuild
            // the global cache right now.
            fDoingRebuild = FALSE;
        }
        else {
            // OK, no one is currently closing a transaction that puts the
            // DNRead cache in jeopardy. However, we need to know what the
            // current sequence number for invalidations is.  After we build a
            // new global cache, we're going to recheck this, and if it's
            // different, throw away the cache we build here because we can't
            // vouch for its correctness.
            LastInvalidateSequenceOrig = gDNReadLastInvalidateSequence;
        }
    }
    __finally {
        LeaveCriticalSection(&csDNReadInvalidateData);
    }

    if(!fDoingRebuild) {
        return;
    }

    Assert(!pTHS->pDB);

    DBOpen(&pTHS->pDB);
    __try {
    /* Discard my existing cache */
        dbReleaseGlobalDNReadCache(pTHS);

    /* make the cache permanent */
        DPRINT(3,"Processing Cache Rebuild request\n");

        // Grab the list
        EnterCriticalSection(&csDNReadGlobalCache);
        __try {
            if(localDNTList = pGlobalDNReadCacheDNTs) {
                // Take complete possesion of the list so no one else frees it
                // out from under us.
                pGlobalDNReadCacheDNTs = NULL;
                localCount = cGlobalDNTReadCacheDNTs;
                cGlobalDNTReadCacheDNTs = 0;
            }
            else {
                fDoingRebuild = FALSE;
            }
        }
        __finally {
            LeaveCriticalSection(&csDNReadGlobalCache);
        }

        if(!fDoingRebuild) {
            // Someone else is rebuilding, bail.
            __leave;
        }

        __try { // Make sure we have a finally to reset the global dnt list


            // Allocate a new global cache structure
            pNewCache = malloc(sizeof(GLOBALDNREADCACHE));
            if(!pNewCache) {
                fDoingRebuild = FALSE;
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_MINIMAL,
                         DIRLOG_READ_CACHE_SKIPPED, NULL,NULL,NULL);
                __leave;
            }
            memset(pNewCache, 0, sizeof(GLOBALDNREADCACHE));

            index = 0;
            pData = malloc(localCount * sizeof(GLOBALDNREADCACHESLOT));
            if(!pData) {
                free(pNewCache);
                pNewCache = NULL;
                fDoingRebuild = FALSE;
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_MINIMAL,
                         DIRLOG_READ_CACHE_SKIPPED, NULL,NULL,NULL);
                __leave;
            }
            memset(pData, 0, localCount * sizeof(GLOBALDNREADCACHESLOT));



            // Now, cache the DNTs in the global list
            for(i=0;i<localCount;i++) {
                if(localDNTList[i]) {
                    if(!DBTryToFindDNT(pTHS->pDB, localDNTList[i])) {
                        d_memname  *pname=NULL;
                        // First, create a memname to be cached.
                        pname =dnCreateMemname(pTHS->pDB,
                                               pTHS->pDB->JetObjTbl);
                        if(pname) {
                            memcpy(&pData[index].name,
                                   pname,
                                   sizeof(d_memname));

                            pData[index].dwHashKey = DSStrToHashKey (pTHS,
                                                                     pname->tag.pRdn,
                                                                     pname->tag.cbRdn / sizeof (WCHAR));

                            pData[index].name.tag.pRdn =
                                malloc(pData[index].name.tag.cbRdn);
                            if(pData[index].name.tag.pRdn) {
                                pData[index].name.pAncestors =
                                    malloc(pData[index].name.cAncestors *
                                           sizeof(DWORD));
                                if(pData[index].name.pAncestors) {
                                    memcpy(pData[index].name.tag.pRdn,
                                           pname->tag.pRdn,
                                           pname->tag.cbRdn);
                                    memcpy(pData[index].name.pAncestors,
                                           pname->pAncestors,
                                           pname->cAncestors * sizeof(DWORD));
                                    pData[index].valid = TRUE;
                                    index++;
                                }
                                else {
                                    free(pData[index].name.tag.pRdn);
                                }
                            }
                        }
                        if (pname) {
                            THFreeOrg(pTHS, pname->pAncestors);
                            Assert((WCHAR *)&(pname[1]) == pname->tag.pRdn);
                            THFreeOrg(pTHS, pname);
                        }
                    }
                    else {
                        DPRINT1(4,"Failed to cache DNT %d\n",localDNTList[i]);
                    }
                }
                else {
                    DPRINT(4,"Caching Skipping 0\n");
                }

            }
            pNewCache->pData = pData;
            pNewCache->count = index;
            DPRINT1(3,"New cache, %d elements\n", index);

        }
        __finally {
            EnterCriticalSection(&csDNReadGlobalCache);
            __try {
                if(!pGlobalDNReadCacheDNTs) {
                    pGlobalDNReadCacheDNTs = localDNTList;
                    localDNTList = NULL;
                    cGlobalDNTReadCacheDNTs = localCount;
                }
                //ELSE  Someone replaced the global list while we were using
                //      this one.  Free the one we have.
            }
            __finally {
                LeaveCriticalSection(&csDNReadGlobalCache);
            }
        }
    }
    __finally {
    DBClose(pTHS->pDB, TRUE);
    }

    if(localDNTList) {
        free(localDNTList);
    }

    if(!fDoingRebuild) {
        return;
    }

    Assert(pNewCache);

    EnterCriticalSection(&csDNReadInvalidateData);
    __try {

        if(LastInvalidateSequenceOrig != gDNReadLastInvalidateSequence) {
            // Someone committed a change that invalidated the dnread cache
            // since we started rebuilding the cache (or is in the process of
            // doing so).  Therefore, don't use the cache we just built.
            fDoingRebuild = FALSE;
        }
        else {
            // Switch the universe to use the new cache.  Note we do this inside
            // the csDNReadInalidateData crit sec to avoid someone deciding to
            // invalidate in between our last check of the sequence and actually
            // replacing the global pointer.  This way, if we check the sequence
            // and it's OK, we are guaranteed of making the pointer change.
            // Then, someone else who enters a new sequence and then checks the
            // pointer is guaranteed to find the new pointer, and take
            // appropriate action.

            // The new cache starts with a refcount of 1 for being in the
            // anchor. Everytime someone grabs a use of it from the anchor, the
            // refcount increases.  Everytime they release the use of it, the
            // refcount decreases.  The refcount drops by one when it is removed
            // from the anchor.
            pNewCache->refCount = 1;
            DPRINT1(3,"Using dnreadcache 0x%X\n",pNewCache);
            dbReplaceCacheInAnchor(pNewCache);
            Assert(fDoingRebuild);
            pNewCache = NULL;
        }
    }
    __finally {
        LeaveCriticalSection(&csDNReadInvalidateData);
    }

    if(!fDoingRebuild) {
        // We have built a cache, but decided not to use it.  Throw it away.
        if(pNewCache->pData) {
            for(i=0;i<pNewCache->count;i++) {
                free(pNewCache->pData[i].name.pAncestors);
                free(pNewCache->pData[i].name.tag.pRdn);
            }
            free(pNewCache->pData);
        }
        free(pNewCache);
        return;
    }
}


#if DBG
VOID
DbgCompareMemnames (
        d_memname *p1,
        d_memname *p2,
        DWORD      DNT
        )
/* This is just a separate routine to get the pointers on the stack. */
{
    Assert(p2);
    Assert(p2->DNT == DNT);
    Assert(p1->DNT == p2->DNT);
    Assert(p1->NCDNT == p2->NCDNT);
    Assert(!memcmp(&p1->Guid,
                   &p2->Guid,
                   sizeof(GUID)));
    Assert(p1->SidLen == p2->SidLen);
    Assert(!p1->SidLen || !memcmp(&p1->Sid,
                                     &p2->Sid,
                                     p1->SidLen));
    Assert(p1->objflag == p2->objflag);
    Assert(p1->cAncestors == p2->cAncestors);
    Assert(!memcmp(p1->pAncestors,
                   p2->pAncestors,
                   p1->cAncestors * sizeof(DWORD)));

    Assert(p1->tag.PDNT == p2->tag.PDNT);
    Assert(p1->tag.rdnType == p2->tag.rdnType);
    Assert(p1->tag.cbRdn == p2->tag.cbRdn);
    Assert(!memcmp(p1->tag.pRdn,
                   p2->tag.pRdn,
                   p2->tag.cbRdn));
    return;
}

VOID
dbExhaustivelyValidateDNReadCache (
        THSTATE *pTHS
        )
/*++
  Description:
      A debug only routine used to validate that the dnread cache is coherent.
      Walk the local DNRead cache and validate all objects in it.

--*/
{
    DWORD i,j;
    d_memname *pname=NULL;
    DBPOS *pDBTemp=NULL;
    GLOBALDNREADCACHESLOT *pData;

    DBOpen2(TRUE, &pDBTemp);
    __try {

        for(i=0; i<LOCAL_DNREAD_CACHE_SIZE;i++) {
            for(j=0;j<DN_READ_CACHE_SLOT_NUM;j++) {
                if((SLOT(i,j).DNT != 0) &&
                   (SLOT(i,j).DNT != INVALIDDNT)) {
                    // This slot has something in it.  Verify that the contents
                    // are still valid (i.e. that we didn't forget to
                    // dbFlushDNReadCache when we needed to.)
                    //
                    DBFindDNT(pDBTemp, SLOT(i,j).DNT);
                    // Now, create a memname by reading the object.
                    pname = dnCreateMemname(pDBTemp, pDBTemp->JetObjTbl);

                    // Finally, check the value in the memname.
                    DbgCompareMemnames(pname, SLOT(i,j).pName,SLOT(i,j).DNT);
                    THFreeOrg(pTHS, pname);
                    pname = NULL;
                }
                else {
                    Assert(!SLOT(i,j).pName);
                }
            }

            // try the second chance slot
            if((HOLD(i).DNT != 0) &&
               (HOLD(i).DNT != INVALIDDNT)) {
                // This slot has something in it.  Verify that the contents are
                // still valid (i.e. that we didn't forget to dbFlushDNReadCache
                // when we needed to.)
                //
                DBFindDNT(pDBTemp, HOLD(i).DNT);
                // Now, create a memname by reading the object.
                pname = dnCreateMemname(pDBTemp, pDBTemp->JetObjTbl);
                // Finally, check the value in the memname.

                DbgCompareMemnames (pname, HOLD(i).pName, HOLD(i).DNT);
                THFreeOrg(pTHS, pname);
                pname = NULL;
            }
            else {
                Assert(!HOLD(i).pName);
            }

        }

        // Now, validate the global DN cache.
        if(pTHS->Global_DNReadCache && pTHS->Global_DNReadCache->pData) {
            pData = pTHS->Global_DNReadCache->pData;
            for(i=0;i<pTHS->Global_DNReadCache->count;i++) {
                if(pData[i].valid) {
                    // Only validate things that are marked as valid.
                    DBFindDNT(pDBTemp, pData[i].name.DNT);
                    // Now, create a memname by reading the object.
                    pname = dnCreateMemname(pDBTemp, pDBTemp->JetObjTbl);
                    // Finally, check the value in the memname.

                    DbgCompareMemnames(pname,
                                       &pData[i].name,
                                       pData[i].name.DNT);
                    THFreeOrg(pTHS, pname);
                    pname = NULL;
                }
            }
        }
    }
    __finally {
        DBClose(pDBTemp, TRUE);
    }


}
#endif

#undef SLOT
#undef HOLD
#undef INCREMENTINDEX
#undef NEXTSLOT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dbintrnl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbintrnl.h
//
//--------------------------------------------------------------------------

/*
==========================================================================
**
**  DB layer definitions required only within the DB layer, not to be
**  exported to outside of the DB Layer.
**
==========================================================================
*/

#ifndef _dbintrnl_h_
#define _dbintrnl_h_

/* external variables */
extern  DBPOS *pDBhidden;

extern  char        szUser[];
extern  char        szPassword[];
extern  char        szJetFilePath[];
extern  char        szJetDirectoryPath[];
extern  int     lastattr;
extern  JET_COLUMNID    insttypeid;
extern  JET_COLUMNID    objclassid;
extern  JET_COLUMNID    ntdefsecdescid;
extern  JET_COLUMNID    ntsecdescid;
extern  JET_COLUMNID    dntid;
extern  JET_COLUMNID    pdntid;
extern  JET_COLUMNID    ancestorsid;
extern  JET_COLUMNID    ncdntid;
extern  JET_COLUMNID    objid;
extern  JET_COLUMNID    rdnid;
extern  JET_COLUMNID    rdntypid;
extern  JET_COLUMNID    dscorepropinfoid;
extern  JET_COLUMNID    abcntid;
extern  JET_COLUMNID    cntid;
extern  JET_COLUMNID    deltimeid;
extern  JET_COLUMNID    usnid;
extern  JET_COLUMNID    usnchangedid;
extern  JET_COLUMNID    dsaid;
extern  JET_COLUMNID    isdeletedid;
extern  JET_COLUMNID    IsVisibleInABid;
extern  JET_COLUMNID    iscriticalid;
extern  JET_COLUMNID    cleanid;
// Link table
extern  JET_COLUMNID    linkdntid;
extern  JET_COLUMNID    backlinkdntid;
extern  JET_COLUMNID    linkbaseid;
extern  JET_COLUMNID    linkdataid;
extern  JET_COLUMNID    linkndescid;
// Link value replication
extern  JET_COLUMNID    linkdeltimeid;
extern  JET_COLUMNID    linkusnchangedid;
extern  JET_COLUMNID    linkncdntid;
extern  JET_COLUMNID    linkmetadataid;
// SD propagator
extern  JET_COLUMNID    orderid;
extern  JET_COLUMNID    begindntid;
extern  JET_COLUMNID    trimmableid;
extern  JET_COLUMNID    clientidid;
extern  JET_COLUMNID    sdpropflagsid;

extern  JET_INSTANCE    jetInstance;
extern  JET_COLUMNID    guidid;
extern  JET_COLUMNID    distnameid;
extern  JET_COLUMNID    sidid;
extern  JET_COLUMNID    ShowInid;
extern  JET_COLUMNID    mapidnid;

// SD table
extern  JET_COLUMNID    sdidid;
extern  JET_COLUMNID    sdhashid;
extern  JET_COLUMNID    sdvalueid;
extern  JET_COLUMNID    sdrefcountid;

extern  JET_INDEXID     idxPdnt;
extern  JET_INDEXID     idxRdn;
extern  JET_INDEXID     idxNcAccTypeName;
extern  JET_INDEXID     idxNcAccTypeSid;
extern  JET_INDEXID     idxAncestors;
extern  JET_INDEXID     idxDnt;
extern  JET_INDEXID     idxDel;
extern  JET_INDEXID     idxGuid;
extern  JET_INDEXID     idxSid;
extern  JET_INDEXID     idxProxy;
extern  JET_INDEXID     idxMapiDN;
extern  JET_INDEXID     idxDraUsn;
extern  JET_INDEXID     idxDraUsnCritical;
extern  JET_INDEXID     idxDsaUsn;
extern  JET_INDEXID     idxPhantom;
extern  JET_INDEXID     idxDntDel;
extern  JET_INDEXID     idxDntClean;
extern  JET_INDEXID     idxInvocationId;

// Link value replication
extern  JET_INDEXID     idxLink;
extern  JET_INDEXID     idxBackLink;
extern  JET_INDEXID     idxBackLinkAll;
extern  JET_INDEXID     idxLinkDel;
extern  JET_INDEXID     idxLinkDraUsn;
extern  JET_INDEXID     idxLinkLegacy;
extern  JET_INDEXID     idxLinkAttrUsn;
// Link value replication

// SD table
extern  JET_INDEXID     idxSDId;
extern  JET_INDEXID     idxSDHash;

// Lingering Object Removal
extern  JET_INDEXID     idxNcGuid; 

extern RTL_RESOURCE     resGlobalDNReadCache;


// bit to use for JetPrepareUpdate(replace)
#define DS_JET_PREPARE_FOR_REPLACE  JET_prepReplaceNoLock

/* string constants for JET */

// Link table
#define SZLINKTABLE "link_table"     /* table for links and backlinks */
#define SZLINKDNT   "link_DNT"   /* DNT of link */
#define SZBACKLINKDNT   "backlink_DNT"   /* DNT of backlink */
#define SZLINKBASE      "link_base"  /* unique ID  of link/backlink pair */
#define SZLINKDATA  "link_data"  /* more data for link/backlink */
#define SZLINKNDESC "link_ndesc"     /* # of descriptors in more data */
// Link Value Replication
#define SZLINKDELTIME "link_deltime"     // Deletion time
#define SZLINKUSNCHANGED "link_usnchanged" // Link USN changed
#define SZLINKNCDNT "link_ncdnt" // Link NC DNT
#define SZLINKMETADATA "link_metadata"     // Link metadata
// Link Value Replication

// Lingering Object Removall
#define SZNCGUIDINDEX "nc_guid_Index" /* nc + guid index */

// SD table
#define SZSDTABLE       "sd_table"      /* table for SDs */
#define SZSDID          "sd_id"         /* SD hash value */
#define SZSDHASH        "sd_hash"       /* SD hash value */
#define SZSDREFCOUNT    "sd_refcount"   /* SD refcount */
#define SZSDVALUE       "sd_value"      /* actual SD data */

#define SZDATATABLE "datatable"  /* name of JET data table */
#define SZPROPTABLE     "sdproptable"    /* Security Descriptor propagations */
#define SZANCESTORS     "Ancestors_col"  /* name of ancestors blob column */
#define SZDNT       "DNT_col"    /* name of DNT column */
#define SZPDNT      "PDNT_col"   /* name of PDNT column */
#define SZDISPTYPE  "DispTYpeT_col"  /* name of DispType column */
#define SZOBJ       "OBJ_col"    /* name of OBJ column */
#define SZRDNTYP    "RDNtyp_col"     /* name of RDN type column */
#define SZCACHE     "cache_col"  /* name of cache header column */
#define SZCNT       "cnt_col"    /* name of cache header column */
#define SZABCNT     "ab_cnt_col"     /* name of cache header column */
#define SZDELTIME   "time_col"   /* name of delete time column */
#define SZNCDNT     "NCDNT_col"  /* name of NCDNT column */
#define SZCLEAN    "clean_col" /*name of clean column */
#define SZMAPIDN        "ATTe590479"     /* name of legacy mapi dn att */
#define SZ_NC_ACCTYPE_NAME_INDEX "NC_Acc_Type_Name"
#define SZ_NC_ACCTYPE_SID_INDEX "NC_Acc_Type_Sid"
#define SZANCESTORSINDEX "Ancestors_index"
#define SZDNTINDEX  "DNT_index"  /* name of DNT index */
#define SZPDNTINDEX "PDNT_index"     /* name of PDNT index */
#define SZRDNINDEX  "INDEX_00090001" /* name of RDN index */
#define SZDELINDEX  "del_index"  /* name of time index */
#define SZOBJCLASS      "ATTc0"          /* name of Object Class col */
#define SZCOMMONNAME    "ATTm3"          /* name of ATT_COMMON_NAME col */
#define SZDISPNAME      "ATTm131085"     /* name of Display Name col */
#define SZDRAUSNNAME    "ATTq131192"     /* name of DRAUSN att */
#define SZDRATIMENAME   "ATTl131075"     /* name of when changed att */
#define SZMETADATA      "ATTk589827"     /* name of meta data att */
#define SZOBJECTVERSION "ATTj131148"     /* name of object version att */
#define SZDSASIGNAME    "ATTk131146"     /* name of DSA signature att */
#define SZSRCUSNNAME    "ATTq131446"     /* name of source usn att */
#define SZINVOCIDNAME   "ATTk131187"     /* name of invocation id att */
#define SZINVOCIDINDEX  "INDEX_00020073" /* name of invocation id index */
#define SZPROXY     "ATTe131282"     /* name of Proxy-Address att */
#define SZPROXYINDEX    "INDEX_000200D2" /* name of Proxy-Address index */
#define SZINSTTYPE  "ATTj131073"     /* name of Instance-Type att */
#define SZNTSECDESC     "ATTp131353"     /* name  NT-Security-Descriptor att */
#define SZDEFNTSECDESC  "ATTk590048"     /* name  NT-Security-Descriptor att */
#define SZSHOWINCONT    "ATTb590468"     /* name of the SHOW-IN att */
#define SZISDELETED "ATTi131120"     /* name of Is-Deleted att */
#define SZLINKID        "ATTj131122"     /* name of ATT_LINK_ID column */
#define SZDMDLOCATION "ATTb131108"       /* name of DMD-Location att */
#define SZHIDDENTABLE   "hiddentable"    /* name of JET hidden table */
#define SZDSA       "dsa_col"    /* name of DSA name column */
#define SZUSN       "usn_col"    /* name of USN column */
#define SZDSSTATE   "state_col"  /* Contains the state of the DS = UnInstalled Installed Running Backedup*/
#define SZDSFLAGS   "flags_col"  /* Contains additional Flags used for keeping track of state */

#define SZDRAUSNINDEX   "DRA_USN_index"  /* index for DRA USN */
#define SZDSAUSNINDEX   "INDEX_0002004A" /* index for DSA USN */
#define SZISVISIBLEINAB "IsVisibleInAB"  /* For restricting via index */
// Link indexes
// New programmatic names with ALL are given to the old non-conditional
// indexes. They have must retain their old Jet names.  link_index is the
// primary index and cannot be changed.
// The default indexes, with program names SZLINKINDEX and SZBACKLINKINDEX,
// are redefined to point to the new conditional indexes.
#define SZLINKALLINDEX "link_index"     /* name of link index */
#define SZLINKINDEX "link_present_index"     /* name of link present index */
#define SZBACKLINKALLINDEX "backlink_index" /* name of backlink index */
#define SZBACKLINKINDEX "backlink_present_index" /* name of backlink index */
// Link Value Replication
#define SZLINKDELINDEX "link_del_index"     /* name of link del time index */
#define SZLINKDRAUSNINDEX   "link_DRA_USN_index"  /* index for DRA USN */
#define SZLINKLEGACYINDEX "link_legacy_index"     /* name of link legacy index */
#define SZLINKATTRUSNINDEX   "link_attr_USN_index"  /* index for attr USN */

// SD table indexes
#define SZSDIDINDEX     "sd_id_index"    /* index on SD id values */
#define SZSDHASHINDEX   "sd_hash_index"  /* index on SD hash values */

#define SZGUID          "ATTk589826"     /* name of GUID att */
#define SZGUIDINDEX     "INDEX_00090002" /* name of GUID index */
#define SZRDNATT        "ATTm589825"     /* name of RDN att */
#define SZSID           "ATTr589970"     /* name of SID att */
#define SZSIDINDEX      "INDEX_00090092" /* name of SID index */
#define SZACCTYPE       "ATTj590126"     /* name of account type att */
#define SZACCNAME       "ATTm590045"     /* name of account name att */
#define SZDISTNAME      "ATTb49"

#define SZORDER         "order_col"      /* Order column in SD prop table */
#define SZBEGINDNT      "begindnt_col"   /* Begin DNT column in SD prop table */
#define SZTRIMMABLE     "trimmable_col"  /* Trimmable column in SD prop table */
#define SZCLIENTID      "clientid_col"   /* Client id column in SD prop table */
#define SZSDPROPFLAGS   "flags_col"      /* flags column in SD prop table */

#define SZORDERINDEX    "order_index"    /* Order index in SD prop table */
#define SZTRIMINDEX     "trim_index"     /* Trimmable index, SD prop table */
#define SZCLIENTIDINDEX "clientid_index" /* Client ID index, SD prop table */
#define SZPROXIEDINDEX  "INDEX_000904E1" /* ATT_PROXIED_OBJECT_NAME index */
#define SZSAMACCTINDEX  "INDEX_000900DD" /* ATT_SAM_ACCOUNT_NAME index */
#define SZDISPLAYINDEX  "INDEX_0002000D" /* ATT_DISPLAY_NAME index */
#define SZALTSECIDINDEX "INDEX_00090363" /* ATT_ALT_SECURITY_IDENTITIES index */
#define SZUPNINDEX      "INDEX_00090290" /* ATT_USER_PRINCIPAL_NAME index */
#define SZSPNINDEX      "INDEX_00090303" /* ATT_SERVICE_PRINCIPAL_NAME index */
#define SZMAPIDNINDEX   "INDEX_0009028F" // ATT_LEGACY_EXCHANGE_DN
#define SZSIDHISTINDEX  "INDEX_00090261" /* ATT_SID_HISTORY index */
#define SZPRIMARYGROUPIDINDEX "INDEX_00090062"  /* ATT_PRIMARY_GROUP_ID index */
#define SZDSCOREPROPINFO "ATTl591181"    /* ATT_DS_CORE_PROPAGATION_INFO */
#define SZPHANTOMINDEX      "PhantomIndex"        // Index to find ref phantoms
#define SZDNTDELINDEX   "DNT_IsDeleted_Index" /* DNT + isDeleted index */
#define SZDNTCLEANINDEX   "DNT_clean_Index" /* DNT + clean index */

#define SZTUPLEINDEXPREFIX "INDEX_T_"

#define SZLCLINDEXPREFIX "LCL_"
/* These indices are localized in dbinit.c.  They MUST begin with
 * the prefix defined in SZLCLINDEXPREFIX, so that we can reclaim
 * unnecessary localized indices.
 */

/* name of ABView index */
#define SZABVIEWINDEX                 "LCL_ABVIEW_index"

// SZDRAUSNINDEX above
#define SZDRAUSNCRITICALINDEX  "DRA_USN_CRITICAL_index"
// SZNCDNT above
#define SZUSNCHANGED           "ATTq131192"
#define SZUSNCREATED           "ATTq131091"
#define SZISCRITICAL           "ATTi590692"


/* configuration parameters */
#define DISPNAMEINDXDENSITY     80  /* density of Display Name index */
#define GENERIC_INDEX_DENSITY   90

#define DB_INITIAL_BUF_SIZE 4096

// Attribute search state
#define ATTRSEARCHSTATEUNDEFINED        0
#define ATTRSEARCHSTATELINKS            1
#define ATTRSEARCHSTATEBACKLINKS        2


// values for ulIndexType
#define IndexTypeNone         0 /* index can not be defined on this field   */
#define IndexTypeSingleColumn 1 /* index to be defined on this column alone */
#define IndexTypeAppendDNT    2 /* index to be defined on this value + DNT  */



/* structure to map DSA syntax types to JET column types and sizes.
   A colsize of zero indicates a fixed length column (size is inherent).
*/
typedef struct
{
    UCHAR       syntax;
    JET_COLTYP  coltype;
    USHORT      colsize;
    USHORT      cp;
    ULONG       ulIndexType;
} SYNTAX_JET;


extern SYNTAX_JET syntax_jet[];

#define ENDSYNTAX   0xff    /* end of table indicactor */


extern NT4SID *pgdbBuiltinDomain;

// Maximum number of Jet sessions
extern ULONG gcMaxJetSessions;

// Array of uncommitted usns
extern USN * UncUsn;

// Critical section to guard uncommitted usn array
extern CRITICAL_SECTION csUncUsn;

// The following is used by DNRead to do a JetRetrieveColumns call. However,
// dbinit.c needs to touch this object to stuff in column IDs.
extern JET_RETRIEVECOLUMN dnreadColumnInfoTemplate[];

// The following are used by dbAddSDPropTime, but dbinit.c needs to touch them
// to stuff in column IDs.
extern JET_RETRIEVECOLUMN dbAddSDPropTimeReadTemplate[];
extern JET_SETCOLUMN dbAddSDPropTimeWriteTemplate[];

// This is a macro to encapsulate when we should track value metadata
// fLinkedValueReplication is a thread-wide (machine-wide) state that controls
// whether we are recording link metadata.  fScopeLegacyLinks is only
// significant when fLVR is true. It is needed when we have promoted to fLVR
// mode, but are applying a legacy value change that was originated in the old
// mode.  fScopeLegacyLinks is only DBPOS-wide because on a replicated
// write, it is necessary for the incoming values to be applied with legacy
// semantics, but "cascaded originating writes" (ie those triggered locally
// during the application of the replicated write) in separate DBPOS must be
// applied with LVR semantics. Whew!
#define TRACKING_VALUE_METADATA( pDB ) \
( (pDB->pTHS->fLinkedValueReplication) && (!(pDB->fScopeLegacyLinks)) )


// Typedef for struct for an array of functions to translate to and from
// internal format and to do comparisons
typedef struct {
    // Internal-to-External format translation function
    // Internal is the DB format (i.e. DNs are represented as DNTs)
    // External is the code/user format (i.e. DNs are represented as DSNAME structs)
    //
    // extTableOp can be either DBSYN_INQ (inquire) or DBSYN_REM (remove value):
    // DBSYN_INQ does the actual translation.
    //
    // DBSYN_REM is called so that extra work can be done for attributes that
    //           reference other data (such as DNs and SDs) and you need to
    //           decrement the refcount.
    //
    // NOTE: DBSYN_REM is not used anywhere (except for one place in dbsetup.c)
    //       A similar functionality is usually achieved by invoking
    //       dbAdjustRefCountByAttVal. So, if you implement a refcounted value
    //       (such as SD or DN), you have to provide the functionality in both
    //       places. One exception with dbAdjustRefCountByAttVal is that it is
    //       not expected to create new rows. This is always achieved by
    //       a ExtIntXXXX(DBSYN_ADD) call.
    //
    // ulUpdateDnt is a hack for backlinks.  The replicator needs to be able to
    // remove backlinks from objects directly, but the ref count for link pairs
    // goes from teh link to the backlink, not the other way around.  This means
    // that the ref count needs to be adjusted on an object other than the object
    // being referenced (specifically, the object which the value is being removed
    // from).  It only has meaning on DSNAME syntaxes, and then is only used for
    // backlinks.
    //
    // jTbl parameter seems to be unused...
    //
    // flags might have some meaning only for certain syntaxes.
    int (*IntExt) (DBPOS FAR *pDB,
                   USHORT extTableOp,
                   ULONG intLen,
                   UCHAR *pIntVal,
                   ULONG *pExtLen,
                   UCHAR **pExtVal,
                   ULONG ulUpdateDnt,
                   JET_TABLEID jTbl,
                   ULONG flags);

    // External-to-Internal format translation function
    //
    // extTableOp can be either DBSYN_INQ (inquire) or DBSYN_ADD (add value):
    // DBSYN_INQ does the actual translation. If the value is refcounted, then
    //           it is also expected to check if the internal value exists in
    //           the table. If not, the function should return DIRERR_OBJ_NOT_FOUND
    //           (this is used in DBReplaceAtt_AC).
    //
    // DBSYN_ADD is called so that extra work can be done for attributes that
    //           reference other data (such as DNs and SDs) and you need to
    //           increment the refcount or create a new row.
    int (*ExtInt) (DBPOS FAR *pDB,
                   USHORT extTableOp,
                   ULONG extLen,
                   UCHAR *pExtVal,
                   ULONG *pIntLen,
                   UCHAR **pIntVal,
                   ULONG ulUpdateDnt,
                   JET_TABLEID jTbl,
                   ULONG flags);

    // value comparison function
    // the comparison is always done on values in internal format
    // Oper can be one of FI_CHOICE_* (see filtypes.h)
    int  (*Eval)  (DBPOS FAR *pDB,
                   UCHAR Oper,
                   ULONG IntLen1,
                   UCHAR *pIntVal1,
                   ULONG IntLen2,
                   UCHAR *pIntVal2);
} DBSyntaxStruct;

// TableOps for gDBSyntax[] conversions.
#define DBSYN_INQ       0
#define DBSYN_ADD       1
#define DBSYN_REM       2

// flags for ExtInt calls
#define EXTINT_NEW_OBJ_NAME 0x1
#define EXTINT_SECRETDATA   0x2
#define EXTINT_UPDATE_PHANTOM 0x4
#define EXTINT_REJECT_TOMBSTONES 0x8

// flags for IntExt calls
// The first 4 bits are reserved for security descriptor flags.
#define INTEXT_BACKLINK     0x10
#define INTEXT_SHORTNAME    0x20
#define INTEXT_MAPINAME     0x40
#define INTEXT_SECRETDATA   0x80
#define INTEXT_WELLKNOWNOBJ 0x100

#define INTEXT_VALID_FLAGS  0x1FF

extern const DBSyntaxStruct gDBSyntax[];


VOID
dbTrackModifiedDNTsForTransaction (
        PDBPOS pDB,
        DWORD NCDNT,
        ULONG cAncestors,
        DWORD *pdwAncestors,
        BOOL  fNotifyWaiters,
        DWORD fChangeType
        );

extern TRIBOOL
dbEvalInt (
        DBPOS FAR *pDB,
        BOOL  fUseObjTbl,
        UCHAR Operation,
        ATTRTYP type,
        ULONG valLenFilter,
        UCHAR *pValFilter,
        BOOL  *pbSkip
        );


extern DWORD
dbInitRec(
    DBPOS FAR *pDB
    );

extern VOID
dbInitIndicesToKeep(void);

extern DWORD
dbInitpDB (
        DBPOS FAR *pDB
        );

ULONG dbGetHiddenFlags(CHAR *pFlags, DWORD flagslen);

ULONG dbSetHiddenFlags(CHAR *pFlags, DWORD flagslen);


DWORD
dbUnMarshallRestart (
        DBPOS FAR *pDB,
        PRESTART pArgRestart,
        BYTE *pDBKeyCurrent,
        DWORD SearchFlags,
        DWORD *cbDBKeyCurrent,
        DWORD *StartDNT
        );

extern void
dbCheckJet (
        JET_SESID sesid
        );

DWORD
dbGetNthNextLinkVal(
        DBPOS * pDB,
        ULONG sequence,
        ATTCACHE **ppAC,
        DWORD Flags,
        ULONG InBuffSize,
        PUCHAR *ppVal,
        ULONG *pul
        );

extern DB_ERR
dbCloseTempTables (DBPOS *pDB);

extern void
dbFreeKeyIndex(
        THSTATE *pTHS,
        KEY_INDEX *pIndex
        );


extern DB_ERR
dbGetSingleValueInternal (
        DBPOS *pDB,
        JET_COLUMNID colId,
        void * pvData,
        DWORD cbData,
        DWORD *pSizeRead,
        DWORD grbit
        );

extern DWORD
dbGetMultipleColumns (
        DBPOS *pDB,
        JET_RETRIEVECOLUMN **ppOutputCols,
        ULONG *pcOutputCols,
        JET_RETRIEVECOLUMN *pInputCols,
        ULONG cInputCols,
        BOOL fGetValues,
        BOOL fOriginal
        );

extern BOOL
dbGetFilePath (
        UCHAR *pFilePath,
        DWORD dwSize
        );


extern BOOL
dbEvalFilterSecurity (
        DBPOS FAR *pDB,
        CLASSCACHE *pCC,
        PSECURITY_DESCRIPTOR pSD,
        PDSNAME pDN
        );

extern void
dbFlushUncUsns (
        void
        );

extern void
dbUnlockDNs (
        DBPOS *pDB
        );

void
dbReleaseGlobalDNReadCache (
        THSTATE *pTHS
        );

void
dbFlushDNReadCache (
        IN DBPOS *pDB,
        IN DWORD DNT
        );

void
dbResetGlobalDNReadCache (
        THSTATE *pTHS
        );

VOID
dbResetLocalDNReadCache (
        THSTATE *pTHS,
        BOOL fForceClear
        );

VOID
dbAdjustRefCountByAttVal(
        DBPOS    *pDB,
        ATTCACHE *pAC,
        PUCHAR   pVal,
        ULONG    valLen,
        int      adjust);

void
dbRemoveAllLinks(
        DBPOS *pDB,
        DWORD DNT,
        BOOL fIsBacklink
        );

DWORD
dbGetNextAtt (
        DBPOS *pDB,
        ATTCACHE **ppAC,
        ULONG *pSearchState
        );

BOOL
dbFindIntLinkVal(
    DBPOS FAR *pDB,
    ATTCACHE *pAC,
    ULONG intLen,
    void *pIntVal,
    OUT BOOL *pfPresent
    );

void
dbGetLinkTableData (
        PDBPOS           pDB,
        BOOL             bIsBackLink,
        BOOL             bWarnings,
        DWORD           *pulObjectDnt,
        DWORD           *pulValueDnt,
        DWORD           *pulRecLinkBase
        );

DWORD APIENTRY
dbGetLinkVal(
        DBPOS * pDB,
        ULONG sequence,
        ATTCACHE **ppAC,
        DWORD Flags,
        ULONG InBuffSize,
        PUCHAR *ppVal,
        ULONG *pul);

DWORD
dbAddIntLinkVal (
        DBPOS FAR *pDB,
        ATTCACHE *pAC,
        ULONG intLen,
        void *pIntVal,
        IN VALUE_META_DATA *pMetaDataRemote OPTIONAL
        );

void
dbSetLinkValuePresent(
    IN DBPOS *pDB,
    IN DWORD dwEventCode,
    IN ATTCACHE *pAC,
    IN BOOL fResetDelTime,
    IN VALUE_META_DATA *pMetaDataRemote OPTIONAL
    );

void
dbSetLinkValueAbsent(
    IN DBPOS *pDB,
    IN DWORD dwEventCode,
    IN ATTCACHE *pAC,
    IN PUCHAR pVal,
    IN VALUE_META_DATA *pMetaDataRemote OPTIONAL
    );

DWORD
dbRemIntLinkVal (
        DBPOS FAR *pDB,
        ATTCACHE *pAC,
        ULONG intLen,
        void *pIntVal,
        IN VALUE_META_DATA *pMetaDataRemote OPTIONAL
        );

VOID
dbDecodeInternalDistnameSyntax(
    IN ATTCACHE *pAC,
    IN VOID *pIntVal,
    IN DWORD intLen,
    OUT DWORD *pulBacklinkDnt,
    OUT DWORD *pulLinkBase,
    OUT PVOID *ppvData,
    OUT DWORD *pcbData
    );

UCHAR *
dbGetExtDnForLinkVal(
    IN DBPOS * pDB
    );

#define dbAlloc(size)           THAllocOrgEx(pTHS, size)
#define dbReAlloc(ptr, size)    THReAllocOrgEx(pTHS, ptr, size)
#define dbFree(ptr)             THFreeOrg(pTHS, ptr)

// Subject Table routines.
extern BOOL
dbFIsAnAncestor (
        DBPOS FAR *pDB,
        ULONG ulAncestor
        );

#define SBTGETTAG_fMakeCurrent      (1)
#define SBTGETTAG_fUseObjTbl        (2)
#define SBTGETTAG_fSearchByGuidOnly (4)
#define SBTGETTAG_fAnyRDNType       (8)
extern DWORD
sbTableGetTagFromDSName(
        DBPOS FAR *pDB,
        DSNAME *pName,
        ULONG ulFlags,
        ULONG *pTag,
        struct _d_memname **ppname
        );

extern DWORD
sbTableGetDSName(
        DBPOS FAR *pDB,
        ULONG tag,
        DSNAME **ppName,
        DWORD fFlag
        );

extern DWORD
sbTableAddRef (
        DBPOS FAR *pDB,
        DWORD dwFlags,
        DSNAME *pName,
        ULONG *pTag
        );

void
InPlaceSwapSid(PSID pSid);

// Debug only routines
#if DBG
extern void
dbAddDBPOS (
        DBPOS *pDB,
        JET_SESID sesid
        );

extern void
dbEndDBPOS (
        DBPOS *pDB
        );
#endif

// Replication meta data routines.
void
dbCacheMetaDataVector(
    IN  DBPOS * pDB
    );

void
dbFlushMetaDataVector(
    IN  DBPOS *                     pDB,
    IN  USN                         usn,
    IN  PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote OPTIONAL,
    IN  DWORD                       dwMetaDataFlags
    );

void
dbFreeMetaDataVector(
    IN  DBPOS * pDB
    );


void
dbSetLinkValueMetaData(
    IN  DBPOS *pDB,
    IN  DWORD dwEventCode,
    IN  ATTCACHE *pAC,
    IN  VALUE_META_DATA *pMetaDataLocal,
    IN  VALUE_META_DATA *pMetaDataRemote OPTIONAL,
    IN  DSTIME *ptimeCurrent OPTIONAL
    );

void
dbTouchLinkMetaData(
    IN DBPOS *pDB,
    IN VALUE_META_DATA * pMetaData
    );

BOOL
dbHasAttributeMetaData(
    IN  DBPOS *     pDB,
    IN  ATTCACHE *  pAC
    );

//
// Wrapper routines that call Jet APIs and raise exceptions on all unexpected
// errors

//
// function prototypes
//

JET_ERR
JetInitException (
        JET_INSTANCE *pinstance,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetTermException (
        JET_INSTANCE instance,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetSetSystemParameterException (
        JET_INSTANCE  *pinstance,
        JET_SESID sesid,
        unsigned long paramid,
        unsigned long lParam,
        const char  *sz,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetBeginSessionException (
        JET_INSTANCE instance,
        JET_SESID  *psesid,
        const char  *szUserName,
        const char  *szPassword,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetDupSessionException (
        JET_SESID sesid,
        JET_SESID  *psesid,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetEndSessionException (
        JET_SESID sesid,
        JET_GRBIT grbit,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetCreateDatabaseException (
        JET_SESID sesid,
        const char  *szFilename,
        const char  *szConnect,
    JET_DBID  *pdbid,
        JET_GRBIT grbit,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetAttachDatabaseException (
        JET_SESID sesid,
        const char  *szFilename,
        JET_GRBIT grbit ,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetDetachDatabaseException (
        JET_SESID sesid,
        const char  *szFilename,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetCreateTableException (
        JET_SESID sesid,
        JET_DBID dbid,
        const char  *szTableName,
    unsigned long lPages,
        unsigned long lDensity,
        JET_TABLEID  *ptableid,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetCreateTableException (
        JET_SESID sesid,
        JET_DBID dbid,
    const char  *szTableName,
        unsigned long lPages,
        unsigned long lDensity,
    JET_TABLEID  *ptableid,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetGetTableColumnInfoException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    const char  *szColumnName,
        void  *pvResult,
        unsigned long cbMax,
    unsigned long InfoLevel,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetGetColumnInfoException (
        JET_SESID sesid,
        JET_DBID dbid,
    const char  *szTableName,
        const char  *szColumnName,
    void  *pvResult,
        unsigned long cbMax,
        unsigned long InfoLevel,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetAddColumnException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    const char  *szColumn,
        const JET_COLUMNDEF  *pcolumndef,
    const void  *pvDefault,
        unsigned long cbDefault,
    JET_COLUMNID  *pcolumnid,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetDeleteColumnException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    const char  *szColumn,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetGetTableIndexInfoException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    const char  *szIndexName,
        void  *pvResult,
        unsigned long cbResult,
    unsigned long InfoLevel,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetCreateIndexException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    const char  *szIndexName,
        JET_GRBIT grbit,
    const char  *szKey,
        unsigned long cbKey,
        unsigned long lDensity,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetDeleteIndexException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    const char  *szIndexName,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetBeginTransactionException (
        JET_SESID sesid,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetCommitTransactionException (
        JET_SESID sesid,
        JET_GRBIT grbit,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetRollbackException (
        JET_SESID sesid,
        JET_GRBIT grbit,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetCloseDatabaseException (
        JET_SESID sesid,
        JET_DBID dbid,
        JET_GRBIT grbit,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetCloseTableException (
        JET_SESID sesid,
        JET_TABLEID tableid,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetOpenDatabaseException (
        JET_SESID sesid,
        const char  *szFilename,
    const char  *szConnect,
        JET_DBID  *pdbid,
        JET_GRBIT grbit,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetOpenTableException (
        JET_SESID sesid,
        JET_DBID dbid,
    const char  *szTableName,
        const void  *pvParameters,
    unsigned long cbParameters,
        JET_GRBIT grbit,
        JET_TABLEID  *ptableid,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetDeleteException (
        JET_SESID sesid,
        JET_TABLEID tableid,
        USHORT usFileNo,
        int nLine
        );

JET_ERR
JetUpdateException (
        JET_SESID sesid,
        JET_TABLEID tableid,
        void  *pvBookmark,
    unsigned long cbBookmark,
        unsigned long  *pcbActual,
        DWORD dsid
        );

JET_ERR
JetEscrowUpdateException (
        JET_SESID sesid,
        JET_TABLEID tableid,
        JET_COLUMNID columnid,
        void *pvDelta,
        unsigned long cbDeltaMax,
        void *pvOld,
        unsigned long cbOldMax,
        unsigned long *pcbOldActual,
        JET_GRBIT grbit,
        DWORD dsid
        );

JET_ERR
JetRetrieveColumnException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    JET_COLUMNID columnid,
        void  *pvData,
        unsigned long cbData,
    unsigned long  *pcbActual,
        JET_GRBIT grbit,
        JET_RETINFO  *pretinfo,
    BOOL fExceptOnWarning,
        DWORD dsid
        );

JET_ERR
JetRetrieveColumnsException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    JET_RETRIEVECOLUMN *pretrievecolumn,
        unsigned long cretrievecolumn,
    BOOL fExceptOnWarning ,
        DWORD dsid
        );

JET_ERR
JetEnumerateColumnsException(
    JET_SESID           sesid,
    JET_TABLEID         tableid,
    ULONG               cEnumColumnId,
    JET_ENUMCOLUMNID*   rgEnumColumnId,
    ULONG*              pcEnumColumn,
    JET_ENUMCOLUMN**    prgEnumColumn,
    JET_PFNREALLOC      pfnRealloc,
    void*               pvReallocContext,
    ULONG               cbDataMost,
    JET_GRBIT           grbit,
    DWORD               dsid );

JET_ERR
JetSetColumnException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    JET_COLUMNID columnid,
        const void  *pvData,
        unsigned long cbData,
    JET_GRBIT grbit,
        JET_SETINFO  *psetinfo,
        BOOL fExceptOnWarning,
        DWORD dsid
        );

JET_ERR
JetSetColumnsException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    JET_SETCOLUMN *psetcolumn,
        unsigned long csetcolumn ,
        DWORD dsid
        );

JET_ERR
JetPrepareUpdateException (
        JET_SESID sesid,
        JET_TABLEID tableid,
        unsigned long prep,
        DWORD dsid
        );

JET_ERR
JetGetRecordPositionException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    JET_RECPOS  *precpos,
        unsigned long cbRecpos,
        DWORD dsid
        );

JET_ERR
JetGotoPositionException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    JET_RECPOS *precpos ,
        DWORD dsid
        );

JET_ERR
JetDupCursorException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    JET_TABLEID  *ptableid,
        JET_GRBIT grbit,
        DWORD dsid
        );

JET_ERR
JetGetCurrentIndexException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    char  *szIndexName,
        unsigned long cchIndexName,
        DWORD dsid
        );

JET_ERR
JetSetCurrentIndex2Exception (
        JET_SESID sesid,
        JET_TABLEID tableid,
    const char  *szIndexName,
        JET_GRBIT grbit,
        BOOL fReturnErrors,
        DWORD dsid
        );

JET_ERR
JetSetCurrentIndex4Exception (
        JET_SESID sesid,
        JET_TABLEID tableid,
        const char  *szIndexName,
        struct tagJET_INDEXID *pidx,
        JET_GRBIT grbit,
        BOOL fReturnErrors,
        DWORD dsid
        );

JET_ERR
JetMoveException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    long cRow,
        JET_GRBIT grbit,
        DWORD dsid
        );

JET_ERR
JetMakeKeyException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    const void  *pvData,
        unsigned long cbData,
        JET_GRBIT grbit,
        DWORD dsid
        );

JET_ERR
JetSeekException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    JET_GRBIT grbit,
        DWORD dsid
        );

JET_ERR
JetGetBookmarkException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    void  *pvBookmark,
    unsigned long cbMax,
        unsigned long  *pcbActual,
        DWORD dsid
        );

JET_ERR
JetGotoBookmarkException (
        JET_SESID sesid,
        JET_TABLEID tableid,
    void  *pvBookmark,
        unsigned long cbBookmark,
        DWORD dsid
        );

JET_ERR
JetComputeStatsException (
        JET_SESID sesid,
        JET_TABLEID tableid,
        DWORD dsid
        );

JET_ERR
JetOpenTempTableException (
        JET_SESID sesid,
        const JET_COLUMNDEF  *prgcolumndef,
    unsigned long ccolumn,
    JET_GRBIT grbit,
        JET_TABLEID  *ptableid,
    JET_COLUMNID  *prgcolumnid,
        DWORD dsid
        );

JET_ERR
JetIntersectIndexesException(
    JET_SESID sesid,
        JET_INDEXRANGE * rgindexrange,
    unsigned long cindexrange,
        JET_RECORDLIST * precordlist,
    JET_GRBIT grbit,
    DWORD dsid
    );


JET_ERR
JetSetIndexRangeException (
        JET_SESID sesid,
        JET_TABLEID tableidSrc,
        JET_GRBIT grbit,
        DWORD dsid
        );

JET_ERR
JetIndexRecordCountException (
        JET_SESID sesid,
    JET_TABLEID tableid,
        unsigned long  *pcrec,
        unsigned long crecMax ,
        DWORD dsid
        );

JET_ERR
JetRetrieveKeyException (
        JET_SESID sesid,
        JET_TABLEID tableid,
        void  *pvData,
    unsigned long cbMax,
        unsigned long  *pcbActual,
        JET_GRBIT grbit ,
    BOOL fExceptOnWarning,
        DWORD dsid
        );

//
// Macros to drop the line number into the Jet wrappers above.
//

#define JetInitEx(pinstance) JetInitException(pinstance, FILENO, __LINE__)
#define JetTermEx(instance) JetTermException(instance, FILENO, __LINE__)
#define JetSetSystemParameterEx(pinstance, sesid, paramid, lParam, sz)         \
        JetSetSystemParameterException(pinstance, sesid, paramid, lParam, sz,  \
                                       FILENO, __LINE__)
#define JetBeginSessionEx(instance, psesid, szUserName, szPassword)            \
        JetBeginSessionException(instance, psesid, szUserName, szPassword,     \
                                 FILENO, __LINE__)
#define JetDupSessionEx(sesid, psesid)                                         \
        JetDupSessionException(sesid, psesid, FILENO, __LINE__)
#define        JetEndSessionEx(sesid, grbit)                                   \
        JetEndSessionException(sesid, grbit, FILENO, __LINE__)
#define JetGetVersionEx(sesid, pwVersion)                                      \
        JetGetVersionException(sesid, pwVersion, FILENO, __LINE__)
#define JetCreateDatabaseEx(sesid, szFilename, szConnect, pdbid, grbit)        \
        JetCreateDatabaseException(sesid, szFilename, szConnect, pdbid, grbit, \
                                   FILENO, __LINE__)
#define JetAttachDatabaseEx(sesid, szFilename, grbit )                         \
        JetAttachDatabaseException(sesid, szFilename, grbit , FILENO, __LINE__)
#define JetDetachDatabaseEx(sesid, szFilename)                                 \
        JetDetachDatabaseException(sesid, szFilename, FILENO, __LINE__)
#define JetCreateTableEx(sesid, dbid, szTableName, lPages, lDensity, ptableid) \
        JetCreateTableException(sesid, dbid, szTableName, lPages, lDensity,    \
                                ptableid, FILENO, __LINE__)
#define JetCreateTableEx(sesid, dbid, szTableName, lPages, lDensity,ptableid)  \
        JetCreateTableException(sesid, dbid, szTableName, lPages, lDensity,    \
                                ptableid, FILENO, __LINE__)
#define JetGetTableColumnInfoEx(sesid, tableid, szColumnName, pvResult, cbMax, \
                                InfoLevel)                                     \
        JetGetTableColumnInfoException(sesid, tableid, szColumnName, pvResult, \
                                       cbMax, InfoLevel, FILENO, __LINE__)
#define JetGetColumnInfoEx(sesid, dbid, szTableName, szColumnName, pvResult,   \
                           cbMax, InfoLevel)                                   \
        JetGetColumnInfoException(sesid, dbid, szTableName, szColumnName,      \
                                  pvResult, cbMax, InfoLevel, FILENO, __LINE__)
#define JetAddColumnEx(sesid, tableid, szColumn, pcolumndef, pvDefault,        \
                       cbDefault, pcolumnid)                                   \
        JetAddColumnException(sesid, tableid, szColumn, pcolumndef, pvDefault, \
                              cbDefault, pcolumnid, FILENO, __LINE__)
#define JetDeleteColumnEx(sesid, tableid, szColumn)                            \
        JetDeleteColumnException(sesid, tableid, szColumn, FILENO, __LINE__)
#define JetGetTableIndexInfoEx(sesid, tableid,         szIndexName, pvResult,  \
                               cbResult, InfoLevel)                            \
        JetGetTableIndexInfoException(sesid, tableid, szIndexName, pvResult,   \
                                      cbResult, InfoLevel, FILENO, __LINE__)
#define JetCreateIndexEx(sesid, tableid, szIndexName, grbit, szKey, cbKey,     \
                         lDensity)                                             \
        JetCreateIndexException(sesid, tableid, szIndexName, grbit, szKey,     \
                                cbKey, lDensity, FILENO, __LINE__)
#define JetDeleteIndexEx(sesid, tableid, szIndexName)                          \
        JetDeleteIndexException(sesid, tableid, szIndexName, FILENO, __LINE__)
#define JetBeginTransactionEx(sesid)                                           \
        JetBeginTransactionException(sesid, FILENO, __LINE__)
#define JetCommitTransactionEx(sesid, grbit)                                   \
        JetCommitTransactionException(sesid, grbit, FILENO, __LINE__)
#define JetRollbackEx(sesid, grbit)                                            \
        JetRollbackException(sesid, grbit, FILENO, __LINE__)
#define JetCloseDatabaseEx(sesid, dbid, grbit)                                 \
        JetCloseDatabaseException(sesid, dbid, grbit, FILENO, __LINE__)
#define JetCloseTableEx(sesid, tableid)                                        \
        JetCloseTableException(sesid, tableid, FILENO, __LINE__)
#define JetOpenDatabaseEx(sesid, szFilename, szConnect, pdbid, grbit)          \
        JetOpenDatabaseException(sesid, szFilename, szConnect, pdbid, grbit,   \
                                 FILENO, __LINE__)
#define JetOpenTableEx(sesid, dbid, szTableName, pvParameters, cbParameters,   \
                       grbit, ptableid)                                        \
        JetOpenTableException(sesid, dbid, szTableName, pvParameters,          \
                              cbParameters, grbit, ptableid, FILENO, __LINE__)
#define        JetDeleteEx(sesid, tableid)                                     \
        JetDeleteException(sesid, tableid, FILENO, __LINE__)
#define JetUpdateEx(sesid, tableid, pvBookmark, cbBookmark, pcbActual)        \
        JetUpdateException(sesid, tableid, pvBookmark, cbBookmark, pcbActual, \
                           DSID(FILENO, __LINE__))
#define JetEscrowUpdateEx(sesid, tableid, columnid, pvDelta, cbDeltaMax,      \
                          pvOld, cbOldMax, pcbOldActual, grbit)               \
        JetEscrowUpdateException(sesid, tableid, columnid, pvDelta,cbDeltaMax,\
                                 pvOld, cbOldMax, pcbOldActual, grbit,        \
                                 DSID(FILENO, __LINE__))
#define JetSetColumnEx(sesid,tableid,columnid,pvData, cbData, grbit, psetinfo)\
        JetSetColumnException(sesid, tableid, columnid, pvData, cbData, grbit,\
                              psetinfo, FALSE, DSID(FILENO, __LINE__))
#define JetSetColumnsEx(sesid, tableid, psetcolumn, csetcolumn )              \
        JetSetColumnsException(sesid, tableid, psetcolumn, csetcolumn,        \
                               DSID(FILENO,__LINE__))
#define JetPrepareUpdateEx(sesid, tableid, prep)                              \
        JetPrepareUpdateException(sesid, tableid, prep, DSID(FILENO, __LINE__))
#define JetGetRecordPositionEx(sesid, tableid, precpos, cbRecpos)             \
        JetGetRecordPositionException(sesid, tableid, precpos, cbRecpos,      \
                                      DSID(FILENO, __LINE__))
#define        JetGotoPositionEx(sesid, tableid, precpos )                    \
        JetGotoPositionException(sesid, tableid, precpos,                     \
                                 DSID(FILENO, __LINE__))
#define JetDupCursorEx(sesid, tableid, ptableid, grbit)                       \
        JetDupCursorException(sesid, tableid, ptableid, grbit,                \
                              DSID(FILENO, __LINE__))
#define JetGetCurrentIndexEx(sesid, tableid, szIndexName, cchIndexName)       \
        JetGetCurrentIndexException(sesid, tableid, szIndexName, cchIndexName,\
                                    DSID(FILENO, __LINE__))
#define JetMoveEx(sesid, tableid, cRow, grbit)                                \
        JetMoveException(sesid, tableid, cRow, grbit, DSID(FILENO, __LINE__))
#define JetMakeKeyEx(sesid, tableid, pvData, cbData, grbit)                   \
        JetMakeKeyException(sesid, tableid, pvData, cbData, grbit,            \
                            DSID(FILENO,__LINE__))
#define JetSeekEx(sesid, tableid, grbit)                                      \
        JetSeekException(sesid, tableid, grbit, DSID(FILENO, __LINE__))
#define JetGetBookmarkEx(sesid, tableid, pvBookmark, cbMax, pcbActual)        \
        JetGetBookmarkException(sesid, tableid, pvBookmark, cbMax, pcbActual, \
                                DSID(FILENO, __LINE__))
#define JetGotoBookmarkEx(sesid, tableid, pvBookmark, cbBookmark)             \
        JetGotoBookmarkException(sesid, tableid, pvBookmark, cbBookmark,      \
                                 DSID(FILENO, __LINE__))
#define JetComputeStatsEx(sesid, tableid)                                     \
        JetComputeStatsException(sesid, tableid, DSID(FILENO, __LINE__))
#define JetOpenTempTableEx(sesid, prgcolumndef, ccolumn, grbit, ptableid,     \
                           prgcolumnid)                                       \
        JetOpenTempTableException(sesid, prgcolumndef, ccolumn, grbit,        \
                                  ptableid, prgcolumnid, DSID(FILENO,__LINE__))
#define JetSetIndexRangeEx(sesid, tableidSrc, grbit)                          \
        JetSetIndexRangeException(sesid, tableidSrc, grbit,                   \
                                  DSID(FILENO, __LINE__))
#define JetIntersectIndexesEx(sesid, rgindexrange, cindexrange, precordlist, grbit)\
        JetIntersectIndexesException(sesid, rgindexrange, cindexrange, precordlist, grbit, \
                                  DSID(FILENO, __LINE__))
#define JetIndexRecordCountEx(sesid, tableid, pcrec, crecMax )                \
        JetIndexRecordCountException(sesid, tableid, pcrec, crecMax ,         \
                                     DSID(FILENO, __LINE__))

#define JetRetrieveKeyEx(sesid, tableid, pvData, cbMax, pcbActual, grbit )    \
        JetRetrieveKeyException(sesid, tableid, pvData, cbMax, pcbActual,     \
                        grbit, TRUE, DSID(FILENO, __LINE__))

// Some wrappers to only allow succes or certain warnings.

#define JetRetrieveKeyWarnings(sesid, tableid, pvData, cbMax,                 \
                               pcbActual, grbit )                             \
        JetRetrieveKeyException(sesid, tableid, pvData, cbMax, pcbActual,     \
                                grbit, FALSE, DSID(FILENO, __LINE__))

#define JetRetrieveKeySuccess(sesid, tableid, pvData, cbMax,                  \
                               pcbActual, grbit )                             \
        JetRetrieveKeyException(sesid, tableid, pvData, cbMax, pcbActual,     \
                                grbit, TRUE, DSID(FILENO, __LINE__))

#define JetSetColumnWarnings(sesid,tableid,columnid,pvData, cbData,       \
              grbit, psetinfo)                                                \
        JetSetColumnException(sesid, tableid, columnid, pvData, cbData, grbit,\
                              psetinfo, FALSE, DSID(FILENO, __LINE__))

// A JetRetrieveColumn call that returns only success
#define JetRetrieveColumnSuccess(sesid, tableid, columnid, pvData, cbData,    \
                pcbActual, grbit, pretinfo)                                   \
                JetRetrieveColumnException(sesid, tableid, columnid, pvData,  \
                                           cbData, pcbActual, grbit, pretinfo,\
                                           TRUE, DSID(FILENO, __LINE__))

// A JetRetrieveColumn call that returns success, or NULL, or buffer truncated
#define JetRetrieveColumnWarnings(sesid, tableid, columnid, pvData, cbData,   \
                                  pcbActual, grbit, pretinfo)                 \
        JetRetrieveColumnException(sesid, tableid, columnid, pvData, cbData,  \
                                   pcbActual, grbit, pretinfo, FALSE,         \
                                   DSID(FILENO,__LINE__))


// A JetRetrieveColumns call that returns only success
#define JetRetrieveColumnsSuccess(sesid, tableid, pretrievecolumn,            \
                cretrievecolumn)                                              \
        JetRetrieveColumnsException(sesid, tableid, pretrievecolumn,          \
                                    cretrievecolumn, TRUE,                    \
                                    DSID(FILENO, __LINE__))

// A JetRetrieveColumns call that returns success, or NULL, or buffer truncated
#define JetRetrieveColumnsWarnings(sesid, tableid, pretrievecolumn,           \
                cretrievecolumn)                                              \
        JetRetrieveColumnsException(sesid, tableid, pretrievecolumn,          \
                       cretrievecolumn, FALSE, DSID(FILENO, __LINE__))

#define JetEnumerateColumnsEx(sesid, tableid, cEnumColumnId, rgEnumColumnId,  \
                            pcEnumColumn, prgEnumColumn, pfnRealloc,          \
                            pvReallocContext, cbDataMost, grbit)              \
        JetEnumerateColumnsException(sesid, tableid, cEnumColumnId,           \
                            rgEnumColumnId, pcEnumColumn, prgEnumColumn,      \
                            pfnRealloc, pvReallocContext, cbDataMost, grbit,   \
                            DSID(FILENO, __LINE__))

// A JetSetCurrentIndex call that either succeeds or excepts
#define JetSetCurrentIndexSuccess(sesid, tableid, szIndexName)                \
        JetSetCurrentIndex2Exception(sesid, tableid, szIndexName,             \
                   JET_bitMoveFirst, FALSE, DSID(FILENO, __LINE__))

// A JetSetCurrentIndex call that also returns expected errors (index doesn't
// exist)
#define JetSetCurrentIndexWarnings(sesid, tableid, szIndexName)               \
        JetSetCurrentIndex2Exception(sesid, tableid, szIndexName,             \
                    JET_bitMoveFirst, TRUE, DSID(FILENO, __LINE__))

// A JetSetCurrentIndex call that either succeeds or excepts
#define JetSetCurrentIndex2Success(sesid, tableid, szIndexName, grbit)        \
        JetSetCurrentIndex2Exception(sesid, tableid, szIndexName, grbit,      \
                                     FALSE, DSID(FILENO, __LINE__))

// A JetSetCurrentIndex call that also returns expected errors (index doesn't
// exist)
#define JetSetCurrentIndex2Warnings(sesid, tableid, szIndexName,grbit)        \
    JetSetCurrentIndex2Exception(sesid, tableid, szIndexName, grbit,      \
                                     TRUE, DSID(FILENO, __LINE__))

// A JetSetCurrentIndex call that either succeeds or excepts
#define JetSetCurrentIndex4Success(sesid, tableid, szIndexName, pidx, grbit)  \
        JetSetCurrentIndex4Exception(sesid, tableid, szIndexName, pidx, grbit,\
                                     FALSE, DSID(FILENO, __LINE__))

// A JetSetCurrentIndex call that also returns expected errors (index doesn't
// exist)
#define JetSetCurrentIndex4Warnings(sesid, tableid, szIndexName, pidx,grbit)  \
        JetSetCurrentIndex4Exception(sesid, tableid, szIndexName, pidx, grbit,\
                                     TRUE, DSID(FILENO, __LINE__))

extern
BOOL
dnReadPreProcessTransactionalData (
        BOOL fCommit
        );
extern
VOID
dnReadPostProcessTransactionalData (
        THSTATE *pTHS,
        BOOL fCommit,
        BOOL fCommitted
        );

extern
VOID
dbEscrowPromote(
    DWORD   phantomDNT,
    DWORD   objectDNT);

extern
BOOL
dbEscrowPreProcessTransactionalData(
    DBPOS   *pDB,
    BOOL    fCommit);

extern
VOID
dbEscrowPostProcessTransactionalData(
    DBPOS   *pDB,
    BOOL    fCommit,
    BOOL    fCommitted);

DWORD
dbMakeCurrent(
    DBPOS *pDB,
    struct _d_memname *pname);

BOOL
dnGetCacheByDNT(
        DBPOS *pDB,
        DWORD tag,
        d_memname **ppname
        );

BOOL
dnGetCacheByPDNTRdn (
        DBPOS *pDB,
        DWORD parenttag,
        DWORD cbRDN,
        WCHAR *pRDN,
        ATTRTYP rdnType,
        d_memname **ppname);

BOOL
dnGetCacheByGuid (
        DBPOS *pDB,
        GUID *pGuid,
        d_memname **ppname);

d_memname *
DNcache(
        IN  DBPOS *     pDB,
        IN  JET_TABLEID tblid,
        IN  BOOL        bCheckForExisting
        );

BOOL
dbIsModifiedInMetaData (
        DBPOS *pDB,
        ATTRTYP att
        );

DWORD
dbMapiTypeFromObjClass (
        ATTRTYP objClass,
        wchar_t *pTemp
        );



// These data structures are used to marshall and unmarshal restart args.  They
// are used in dbtools.  If these structures change, then the code in
// DBCreateRestart, DBCreateRestartForSAM, and DBUnmarshallRestart must all
// change in sync.
// A packed restart arg has a single PACKED_KEY_HEADER, followed by N
// PACKED_KEY_INDEXes (where N is NumIndices in the PACKED_KEY_HEADER), followed
// by M DNTs (where M is NumDNTs in the PACKED_KEY_HEADER).  Note then, that the
// whole restart arg has 2 variable sized arrays in it, which is why we use this
// weird hand marshalling.

typedef struct _PACKED_KEY_HEADER {
    DWORD NumIndices;
    DWORD NumDNTs;
    DWORD StartDNT;
    DWORD cbCurrentKey;
    DWORD ulSearchType;
    RESOBJ BaseResObj;
    GUID  BaseGuid;
    DWORD ulSorted;
    DWORD indexType;
    DWORD bOnCandidate;
    DWORD dupDetectionType;
    BOOL  bOneNC;
    DWORD SearchEntriesVisited;
    DWORD SearchEntriesReturned;
    BOOL  fVLVSearch:1;
    BOOL  bUsingMAPIContainer:1;
    ULONG ulVLVContentCount;
    ULONG ulVLVTargetPosition;
    DWORD cbVLVCurrPositionKey;
    DWORD MAPIContainerDNT;
    DWORD asqMode;
    ULONG ulASQLastUpperBound;
} PACKED_KEY_HEADER;

typedef struct _PACKED_KEY_INDEX {
    DWORD bPDNT;
    DWORD bIsSingleValued;
    DWORD bIsEqualityBased;
    DWORD bIsForSort;
    DWORD cbIndexName;
    DWORD cbDBKeyLower;
    DWORD cbDBKeyUpper;
} PACKED_KEY_INDEX;

typedef struct _INDEX_RANGE     {
    DWORD   cbValLower;
    PVOID   pvValLower;
    DWORD   cbValUpper;
    PVOID   pvValUpper;
} INDEX_RANGE;


#define dbmkfir_PDNT  1
#define dbmkfir_NCDNT 2
KEY_INDEX *
dbMakeKeyIndex(
        DBPOS *pDB,
        DWORD dwSearchType,
        BOOL  bIsSingleValued,
        DWORD Option,
        char * szIndex,
        BOOL fGetNumRecs,
        DWORD cIndexRanges,
        INDEX_RANGE * rgIndexRange
        );

void
dbFreeKeyIndex(
        THSTATE *pTHS,
        KEY_INDEX *pIndex
        );

DWORD dbFreeFilter(
        DBPOS *pDB,
        FILTER *pFil);

BOOL
dbFObjectInCorrectDITLocation (
        DBPOS *pDB,
        JET_TABLEID tblId
        );


BOOL
dbFObjectInCorrectNC (
        DBPOS *pDB,
        ULONG DNT,
        JET_TABLEID tblId
        );

BOOL
dbMatchSearchCriteriaForSortedTable (
        DBPOS *pDB,
        BOOL  *pCanRead
        );

VOID
dbSearchDuplicateCreateHashTable(
    IN      struct _LHT**   pplht
    );

BOOL __inline
dbNeedToFlushDNCacheOnUpdate(ATTRTYP at)
/*++
    do we need to flush the dn read cache when this attribute is updated?
--*/
{
    switch(at) {
    case ATT_OBJECT_GUID:
    case ATT_OBJECT_SID:
    case ATT_RDN:
    case ATT_OBJECT_CLASS:
    case ATT_NT_SECURITY_DESCRIPTOR:
        // Changing these attributes changes the record's identity, so we'll
        // need to flush this DNT from the read cache after we've updated the
        // record.
        return TRUE;
    default:
        return FALSE;
    }
}


#define SORTED_INDEX(x) ( ((x)==TEMP_TABLE_INDEX_TYPE) || ((x)==TEMP_TABLE_MEMORY_ARRAY_TYPE) )

// allocate that much memory for SD by default (will increase if needed)
#define DEFAULT_SD_SIZE 4096

ULONG
CountAncestorsIndexSizeHelper (
    DBPOS *pDB,
    DWORD  cAncestors,
    DWORD *pAncestors
    );



#endif  /* _dbintrnl_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dbinit.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbinit.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <errno.h>
#include <dsjet.h>
#include <dsconfig.h>

#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <dbopen.h>
#include <mdglobal.h>
#include <mdlocal.h>
#include <dsatools.h>

#include <mdcodes.h>
#include <dsevent.h>

#include <dsexcept.h>
#include "anchor.h"
#include "objids.h"     /* Contains hard-coded Att-ids and Class-ids */
#include "usn.h"

#include "debug.h"      /* standard debugging header */
#define DEBSUB     "DBINIT:"   /* define the subsystem for debugging */

#include <ntdsctr.h>
#include <dstaskq.h>
#include <crypto\md5.h>
#include "dbintrnl.h"

#include <fileno.h>
#define  FILENO FILENO_DBINIT


/* Prototypes for internal functions. */

int APIENTRY DBAddSess(JET_SESID sess, JET_DBID dbid);
int APIENTRY DBEndSess(JET_SESID sess);
void DBEnd(void);
VOID PASCAL FAR DBEndSig(USHORT sig, USHORT signo);
DBPOS * dbGrabHiddenDBPOS(THSTATE *pTHS);
void dbReleaseHiddenDBPOS(DBPOS *pDB);
CRITICAL_SECTION csHiddenDBPOS;
DWORD dbCreateLocalizedIndices (JET_SESID sesid,JET_TABLEID tblid);
JET_ERR dbCreateHiddenDBPOS (void);
USHORT dbCloseHiddenDBPOS (void);



/*
 * External variables from dbopen.c
 */
extern DWORD gcOpenDatabases;
extern BOOL  gFirstTimeThrough;
extern BOOL  gfNeedJetShutdown;

/*
 * External variables from dbtools.c
 */
extern BOOL gfEnableReadOnlyCopy;

/*
 * External variables from dbobj.c
 */
extern DWORD gMaxTransactionTime;

/*
 * Global variables
 */
CRITICAL_SECTION csSessions;
CRITICAL_SECTION csAddList;
DSA_ANCHOR gAnchor;
NT4SID *pgdbBuiltinDomain=NULL;
HANDLE hevDBLayerClear;

JET_INSTANCE    jetInstance = 0;

JET_COLUMNID dsstateid;
JET_COLUMNID dsflagsid;

//
// Setting Flags stored in the database
//
CHAR gdbFlags[200];

/* Data used for Jet session & table cache */
#define SESSION_CACHE_SIZE 16
SESSIONCACHE gaSessionCache[SESSION_CACHE_SIZE];
unsigned gSessionCacheIndex = SESSION_CACHE_SIZE;
CRITICAL_SECTION csSessionCache;

// These used to be declared static.  Consider this if there is a problem with these.
JET_TABLEID     HiddenTblid;
DBPOS   FAR     *pDBhidden=NULL;



// This array keeps track of opened JET sessions.

typedef struct {
        JET_SESID       sesid;
        JET_DBID        dbid;
} OPENSESS;

extern OPENSESS *opensess;

typedef struct {
        JET_SESID sesid;
        DBPOS *pDB;
        DWORD tid;
        DSTIME atime;
}JET_SES_DATA;


#if DBG
// This array is used by the debug version to keep track of allocated
// DBPOS structures.
#define MAXDBPOS 1000
extern JET_SES_DATA    opendbpos[];
extern int DBPOScount;
extern CRITICAL_SECTION csDBPOS;
#endif // DBG





OPENSESS *opensess;

#if DBG

// This array is used by the debug version to keep track of allocated
// DBPOS structures.

JET_SES_DATA    opendbpos[MAXDBPOS];
int DBPOScount = 0;
CRITICAL_SECTION csDBPOS;


// These 3 routines are used to consistency check our transactions and
// DBPOS handling.

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
// This function checks that jet session has no pdbs

void APIENTRY dbCheckJet (JET_SESID sesid){
    int i;
    EnterCriticalSection(&csDBPOS);
    __try
    {
        for (i=0;i < MAXDBPOS; i++){
            if (opendbpos[i].sesid == sesid){
                DPRINT(0,"Warning, closed session with open transactions\n");

                // Clean up so we don't get repeat warning of the same problem.

                opendbpos[i].pDB = 0;
                opendbpos[i].sesid = 0;
                opendbpos[i].tid = 0;
            }
        }
    }
    __finally
    {
        LeaveCriticalSection(&csDBPOS);
    }
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function registers pDBs
*/

extern void APIENTRY dbAddDBPOS(DBPOS *pDB, JET_SESID sesid){

    int i;
    BOOL fFound = FALSE;

    EnterCriticalSection(&csDBPOS);
    __try
    {
        for (i=0; i < MAXDBPOS; i++)
        {
            if (opendbpos[i].pDB == 0)
            {
                opendbpos[i].pDB = pDB;
                opendbpos[i].sesid = sesid;
                opendbpos[i].tid = GetCurrentThreadId();
                opendbpos[i].atime = DBTime();
                DBPOScount++;
                if (pTHStls) {
                    DPRINT3(3,"DBAddpos dbpos count is %x, sess %lx, pDB %x\n",pTHStls->opendbcount, sesid, pDB);
                }

                fFound = TRUE;
                break;
            }
        }

        // if we have run out of slots, it is probably a bug.
        Assert(fFound);
    }
    __finally
    {
        LeaveCriticalSection(&csDBPOS);
    }

    return;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function deletes freed pDBs
*/

extern void APIENTRY dbEndDBPOS(DBPOS *pDB){

    int i;
    BOOL fFound = FALSE;

    EnterCriticalSection(&csDBPOS);
    __try
    {
        for (i=0; i < MAXDBPOS; i++)
        {
            if (opendbpos[i].pDB == pDB)
            {
                DBPOScount--;
                if (pTHStls) {
                    DPRINT3(3,"DBEndpos dbpos count is %x, sess %lx, pDB %x\n",pTHStls->opendbcount, opendbpos[i].sesid, pDB);
                }
                opendbpos[i].pDB = 0;
                opendbpos[i].sesid = 0;
                opendbpos[i].tid = 0;

                fFound = TRUE;
                break;
            }
        }

        // At this point if we couldn't find the DBPOS to remove it, assert.
        Assert(fFound);
    }
    __finally
    {
        LeaveCriticalSection(&csDBPOS);
    }
    return;
}

#endif  // DEBUG

// Define the parameters for new database columns

/*
Design note on the implementation of the present indicator for link rows.
Jliem writes:
First thing to note is that it sounds like you don't even need the column
in the index.  Create the index with your indicator column specified as a
conditional column.  We will automatically filter out records from the index
when the column is NULL.
The JET_INDEXCREATE structure you pass to JetCreateIndex() has a
JET_CONDITIONALCOLUMN member.  Fill that out.  Unfortunately, ESENT only supports
one conditional column per index, so set the cConditionalColumns member to 1
(ESE98 supports up to 12).  Also, you need to set the grbit member of in the
JET_CONDITIONALCOLUMN structure to JET_bitIndexColumnMustBeNonNull
(or JET_bitIndexColumnMustBeNull if you want the record in the index only if
the column is NULL).
*/

// This is the structure that defines a new column in an existing table
typedef struct {
    char *pszColumnName;
    JET_COLUMNID *pColumnId;
    JET_COLTYP ColumnType;
    JET_GRBIT  grbit;
    unsigned long cbMax;
    PVOID pvDefault;
    unsigned long cbDefault;
} CREATE_COLUMN_PARAMS, *PCREATE_COLUMN_PARAMS;

// New columns in the link table
CREATE_COLUMN_PARAMS rgCreateLinkColumns[] = {
    // create link deletion time id
    { SZLINKDELTIME, &linkdeltimeid, JET_coltypCurrency, JET_bitColumnFixed, 0, NULL, 0 },
    // create link usn changed id
    { SZLINKUSNCHANGED, &linkusnchangedid, JET_coltypCurrency, JET_bitColumnFixed, 0, NULL, 0 },
    // create link nc dnt id
    { SZLINKNCDNT, &linkncdntid, JET_coltypLong, JET_bitColumnFixed, 0, NULL, 0 },
    // create link metadata id
    { SZLINKMETADATA, &linkmetadataid, JET_coltypBinary, 0, 255, NULL, 0 },
    0
};

// new columns in the SD table
DWORD dwSDRefCountDefValue = 1;
CREATE_COLUMN_PARAMS rgCreateSDColumns[] = {
    // id
    { SZSDID, &sdidid, JET_coltypCurrency, JET_bitColumnFixed | JET_bitColumnAutoincrement, 0, NULL, 0 },
    // hash value
    { SZSDHASH, &sdhashid, JET_coltypBinary, JET_bitColumnFixed, MD5DIGESTLEN, NULL, 0 },
    // refcount
    { SZSDREFCOUNT, &sdrefcountid, JET_coltypLong,
      JET_bitColumnFixed | JET_bitColumnEscrowUpdate | JET_bitColumnFinalize,
      0, &dwSDRefCountDefValue, sizeof(dwSDRefCountDefValue)
    },
    // actual SD value (create as tagged since can not estimate upper bound for a variable length column)
    { SZSDVALUE, &sdvalueid, JET_coltypLongBinary, JET_bitColumnTagged, 0, NULL, 0 },
    0
};

// new columns in the SD prop table
CREATE_COLUMN_PARAMS rgCreateSDPropColumns[] = {
    // SD prop flags
    { SZSDPROPFLAGS, &sdpropflagsid, JET_coltypLong, JET_bitColumnFixed, 0, NULL, 0 },
    0
};

// This structure is shared by the RecreateFixedIndices routine.
// This is the structure that defines a new index
typedef struct
{
    char        *szIndexName;
    char        *szIndexKeys;
    ULONG       cbIndexKeys;
    ULONG       ulFlags;
    ULONG       ulDensity;
    JET_INDEXID *pidx;
    JET_CONDITIONALCOLUMN *pConditionalColumn;
}   CreateIndexParams;

// Index keys for the link table
char rgchLinkDelIndexKeys[] = "+" SZLINKDELTIME "\0+" SZLINKDNT "\0+" SZBACKLINKDNT "\0";
char rgchLinkDraUsnIndexKeys[] = "+" SZLINKNCDNT "\0+" SZLINKUSNCHANGED "\0+" SZLINKDNT "\0";
char rgchLinkIndexKeys[] = "+" SZLINKDNT "\0+" SZLINKBASE "\0+" SZBACKLINKDNT "\0+" SZLINKDATA "\0";
char rgchBackLinkIndexKeys[] = "+" SZBACKLINKDNT "\0+" SZLINKBASE "\0+" SZLINKDNT "\0";
// Note the third segment of this key is descending. This is intended.
char rgchLinkAttrUsnIndexKeys[] = "+" SZLINKDNT "\0+" SZLINKBASE "\0-" SZLINKUSNCHANGED "\0";

// Conditional column definition
// When LINKDELTIME is non-NULL (row absent), filter the row out of the index.
JET_CONDITIONALCOLUMN CondColumnLinkDelTimeNull = {
    sizeof( JET_CONDITIONALCOLUMN ),
    SZLINKDELTIME,
    JET_bitIndexColumnMustBeNull
};
// When LINKUSNCHANGED is non-NULL (row has metadata), filter the row out of the index.
JET_CONDITIONALCOLUMN CondColumnLinkUsnChangedNull = {
    sizeof( JET_CONDITIONALCOLUMN ),
    SZLINKUSNCHANGED,
    JET_bitIndexColumnMustBeNull
};

// Indexes to be created
// This is for indexes that did not exist in the Product 1 DIT
// Note that it is NOT necessary to also put these definitions in mkdit.ini.
// The reason is that when mkdit.exe is run, dbinit will be run, and this
// very code will upgrade the dit before it is saved to disk.

// The old SZLINKINDEX is now known by SZLINKALLINDEX
// The old SZBACKLINKINDEX is now know by SZBACKLINKALLINDEX

CreateIndexParams rgCreateLinkIndexes[] = {
    // Create new link present index
    { SZLINKINDEX,
      rgchLinkIndexKeys, sizeof( rgchLinkIndexKeys ),
      JET_bitIndexUnique, 90, &idxLink, &CondColumnLinkDelTimeNull },

    // Create new backlink present index
    { SZBACKLINKINDEX,
      rgchBackLinkIndexKeys, sizeof( rgchBackLinkIndexKeys ),
      0, 90, &idxBackLink, &CondColumnLinkDelTimeNull },

    // Create link del time index
    { SZLINKDELINDEX,
      rgchLinkDelIndexKeys, sizeof( rgchLinkDelIndexKeys ),
      JET_bitIndexIgnoreNull | JET_bitIndexIgnoreAnyNull,
      98, &idxLinkDel, NULL },

    // Create link dra usn index (has metadata)
    { SZLINKDRAUSNINDEX,
      rgchLinkDraUsnIndexKeys, sizeof( rgchLinkDraUsnIndexKeys ),
      JET_bitIndexUnique | JET_bitIndexIgnoreNull | JET_bitIndexIgnoreAnyNull,
      100, &idxLinkDraUsn, NULL },

    // Create new link legacy index (does not have metadata)
    { SZLINKLEGACYINDEX,
      rgchLinkIndexKeys, sizeof( rgchLinkIndexKeys ),
      JET_bitIndexUnique, 90, &idxLinkLegacy, &CondColumnLinkUsnChangedNull },

    // Create link attr usn index (has metadata)
    { SZLINKATTRUSNINDEX,
      rgchLinkAttrUsnIndexKeys, sizeof( rgchLinkAttrUsnIndexKeys ),
      JET_bitIndexUnique | JET_bitIndexIgnoreNull | JET_bitIndexIgnoreAnyNull,
      100, &idxLinkAttrUsn, NULL },

    0
};
DWORD cNewLinkIndexes = ((sizeof(rgCreateLinkIndexes) / sizeof(CreateIndexParams)) - 1);

// Index keys for the SD table
char rgchSDIdIndexKeys[] = "+" SZSDID "\0";
char rgchSDHashIndexKeys[] = "+" SZSDHASH "\0";

// SD Indexes to be created
CreateIndexParams rgCreateSDIndexes[] = {
    // SD id index
    { SZSDIDINDEX,
      rgchSDIdIndexKeys, sizeof( rgchSDIdIndexKeys ),
      JET_bitIndexUnique | JET_bitIndexPrimary,
      100, &idxSDId, NULL },

    // SD hash index
    { SZSDHASHINDEX,
      rgchSDHashIndexKeys, sizeof( rgchSDHashIndexKeys ),
      0,
      90, &idxSDHash, NULL },

    0
};
DWORD cNewSDIndexes = ((sizeof(rgCreateSDIndexes) / sizeof(CreateIndexParams)) - 1);

// Indexes to be modified
// This is for (non-primary) indexes that have changed since the Product 1 DIT
//
// If indexes in the dit are different from what is listed here, they will
// be recreated with the new attributes.
// Note that the index differencing code is pretty simple. Make sure
// the code can distinguish your type of change!

//
// Modified Data Table Indexes
//

char rgchDraUsnIndexKeys[] = "+" SZNCDNT "\0+" SZUSNCHANGED "\0";
char rgchDelKey[] = "+" SZDELTIME "\0+" SZDNT "\0";

CreateIndexParams rgModifyDataIndexes[] = {

    // Modify SZDRAUSNINDEX to remove SZISCRITICAL
    // Key segment change from 3 to 2
    { SZDRAUSNINDEX,
      rgchDraUsnIndexKeys, sizeof( rgchDraUsnIndexKeys ),
      JET_bitIndexIgnoreNull,
      100, &idxDraUsn, NULL },

    // Modify SZDELINDEX to change flags
    // Add flag IgnoreAnyNull
    {SZDELINDEX, rgchDelKey, sizeof(rgchDelKey),
     JET_bitIndexIgnoreAnyNull,
     98, &idxDel, NULL },

    // Put your index descriptions here
    0
};

//
// Modified Link Table Indexes
//

CreateIndexParams rgModifyLinkIndexes[] = {

    // Put your index descriptions here
    0
};


JET_ERR
dbCreateSingleIndex(
    JET_SESID initsesid,
    JET_TABLEID tblid,
    CreateIndexParams *pIndex,
    BOOL fRecreate
    )

/*++

Routine Description:

Helper routine to (re) create indexes.  Check if the index is present.
If we are recreating the index, then delete the existing one.
Create the new index.

Arguments:

    initsesid -
    tblid -
    pCreateIndexes -
    fRecreate -

Return Value:

    JET_ERR -

--*/

{
    JET_ERR err;
    JET_INDEXCREATE indexCreate;

    err = JetGetTableIndexInfo(initsesid,
                               tblid,
                               pIndex->szIndexName,
                               pIndex->pidx,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err == JET_errSuccess) {
        if (!fRecreate) {
            // It exists and we're not recreating => we're done
            return JET_errSuccess;
        }

        DPRINT1(0, "Deleted old index %s.\n", pIndex->szIndexName );

        err = JetDeleteIndex( initsesid, tblid, pIndex->szIndexName );
        if (err) {
            DPRINT2(0, "JetDeleteIndex (%s) error: %d\n",
                    pIndex->szIndexName, err);
            LogUnhandledError(err);
            return err;
        }
        // Fall through to recreate
    } else if (err != JET_errIndexNotFound) {
        DPRINT2(0, "JetGetTableIndexInfo (%s) error: %d\n",
                pIndex->szIndexName, err);
        LogUnhandledError(err);
        return err;
    }

    memset( &indexCreate, 0, sizeof( indexCreate ) );
    indexCreate.cbStruct = sizeof( indexCreate );
    indexCreate.szIndexName = pIndex->szIndexName;
    indexCreate.szKey = pIndex->szIndexKeys;
    indexCreate.cbKey = pIndex->cbIndexKeys;
    indexCreate.grbit = pIndex->ulFlags;
    indexCreate.ulDensity = pIndex->ulDensity;
    if (pIndex->pConditionalColumn) {
        indexCreate.rgconditionalcolumn = pIndex->pConditionalColumn;
        indexCreate.cConditionalColumn = 1;
    }
    err = JetCreateIndex2( initsesid,
                           tblid,
                           &indexCreate,
                           1 );
    if (err) {
        DPRINT2(0, "JetCreateIndex (%s) error: %d\n",
                pIndex->szIndexName, err);
        LogUnhandledError(err);
        return err;
    }

    DPRINT1(0, "Added new index %s.\n", pIndex->szIndexName );

    err = JetGetTableIndexInfo(initsesid,
                               tblid,
                               pIndex->szIndexName,
                               pIndex->pidx,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        DPRINT2(0, "JetGetTableIndexInfo (%s) error: %d\n",
                pIndex->szIndexName, err);
        LogUnhandledError(err);
        return err;
    }

    return JET_errSuccess;
} /* dbCreateSingleIndex */


JET_ERR
dbCreateNewColumns(
    JET_SESID initsesid,
    JET_TABLEID tblid,
    PCREATE_COLUMN_PARAMS pCreateColumns
    )

/*++

Routine Description:

    Query Jet for the Column and Index ID's of the named items. If the item
    does not exist, create it.

Arguments:

    initsesid - Jet session
    tblid - Jet table
    pCreateColumns - array of column defintions to query/create

Return Value:

    JET_ERR - Jet error code

--*/

{
    JET_ERR err = 0;
    JET_COLUMNDEF coldef;
    PCREATE_COLUMN_PARAMS pColumn;

    //
    // Lookup or Create new columns
    //

    for( pColumn = pCreateColumns;
         pColumn->pszColumnName != NULL;
         pColumn++ ) {

        err = JetGetTableColumnInfo(
            initsesid,
            tblid,
            pColumn->pszColumnName,
            &coldef,
            sizeof(coldef),
            0 );
        if (err == JET_errColumnNotFound) {
            // If column not present, add it

            ZeroMemory( &coldef, sizeof(coldef) );
            coldef.cbStruct = sizeof( JET_COLUMNDEF );
            coldef.coltyp = pColumn->ColumnType;
            coldef.grbit = pColumn->grbit;
            coldef.cbMax = pColumn->cbMax;

            err = JetAddColumn(
                initsesid,
                tblid,
                pColumn->pszColumnName,
                &coldef,
                pColumn->pvDefault,
                pColumn->cbDefault,
                &(coldef.columnid) );

            if (err != JET_errSuccess) {
                DPRINT2(0, "JetAddColumn (%s) error: %d\n",
                        pColumn->pszColumnName, err);
                LogUnhandledError(err);
                return err;
            }
            DPRINT1(0, "Added new column %s.\n", pColumn->pszColumnName );
        } else if (err != JET_errSuccess) {
            DPRINT2(0, "JetGetTableColumnInfo (%s) error: %d\n",
                    pColumn->pszColumnName, err);
            LogUnhandledError(err);
            return err;
        }
        *(pColumn->pColumnId) = coldef.columnid;
    }

    return 0;
} /* createNewColumns */

// Max no of retries for creating an index
#define MAX_INDEX_CREATE_RETRY_COUNT 2


JET_ERR
dbCreateIndexBatch(
    JET_SESID sesid,
    JET_TABLEID tblid,
    DWORD cIndexCreate,
    JET_INDEXCREATE *pIndexCreate
    )

/*++

Routine Description:

Create multiple indexes together in a batch. Retries with smaller
batch sizes if necessary.

The caller has already determined that the indexes do not exist.

This helper routine is used by createNewIndexes and dbRecreateFixedIndexes

Arguments:

    initsesid - database session
    tblid - table cursor
    cIndexCreate - Number of indexes to actually create
    pIndexCreate - Array of jet index create structures

Return Value:

    JET_ERR -

--*/

{
    JET_ERR err = 0;
    ULONG last, remaining, noToCreate;
    ULONG maxNoOfIndicesInBatch = MAX_NO_OF_INDICES_IN_BATCH;
    ULONG retryCount = 0;

    last = 0;
    remaining = cIndexCreate;

    while (remaining > 0) {
        if (remaining > maxNoOfIndicesInBatch) {
            noToCreate = maxNoOfIndicesInBatch;
        }
        else {
            noToCreate = remaining;
        }

        err = JetCreateIndex2(sesid,
                              tblid,
                              &(pIndexCreate[last]),
                              noToCreate);

        switch(err) {
            case 0:
                DPRINT1(0, "%d index batch successfully created\n", noToCreate );
                // reset retryCount
                retryCount = 0;
                break;

            case JET_errDiskFull:
            case JET_errLogDiskFull:
                DPRINT1(1, "Ran out of version store, trying again with batch size of 1 (retryCount is %d)\n", retryCount);
                maxNoOfIndicesInBatch = 1;
                retryCount++;
                break;

            default:
                // Huh?
                DPRINT1(0, "JetCreateIndex failed. Error = %d\n", err);
                // reset retryCount, we do not retry on these errors
                retryCount = 0;

                // Log the error
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_FIXED_INDEX_CREATION_FAILED,
                         szInsertInt(err), 0, 0);
                break;
        }

        if (retryCount && (retryCount <= MAX_INDEX_CREATE_RETRY_COUNT)) {
            // continue with smaller batch size set
            err = 0;
            continue;
        }

        if (err) {
            goto abort;
        }

        // success, so adjust for next batch
        last += noToCreate;
        remaining -= noToCreate;
    }

abort:
    return err;

} /* createIndexBatch */


JET_ERR
dbCreateNewIndexesBatch(
    JET_SESID initsesid,
    JET_TABLEID tblid,
    DWORD cIndexCreate,
    CreateIndexParams *pCreateIndexes
    )

/*++

Routine Description:

    Create missing indexes
    BUGBUG WLEES 03/02/00
    This function dbCreateNewIndexesBatch, doesn't seem to work
    reliably with conditional columns. This is with ESE97/NT. Try again with ESE98.


Arguments:

    initsesid - database session
    tblid - table cursor
    cIndexCreate - Number of indexes to check
    pCreateIndexes - index attributes

Return Value:

    JET_ERR -

--*/

{
    THSTATE *pTHS = pTHStls;
    JET_ERR err = 0;
    CreateIndexParams *pIndex;
    JET_INDEXCREATE *pIndexCreate, *pNewIndex;
    DWORD cIndexNeeded = 0;

    // Allocate maximal size
    pIndexCreate = THAllocEx( pTHS, cIndexCreate * sizeof( JET_INDEXCREATE ) );

    //
    // Initialize the list of indexes to be created
    //

    pNewIndex = pIndexCreate;
    for( pIndex = pCreateIndexes;
         pIndex->szIndexName != NULL;
         pIndex++ ) {

        if (err = JetSetCurrentIndex(initsesid,
                                     tblid,
                                     pIndex->szIndexName)) {
            DPRINT2(0,"Need an index %s (%d)\n", pIndex->szIndexName, err);

            pNewIndex->cbStruct = sizeof( JET_INDEXCREATE );
            pNewIndex->szIndexName = pIndex->szIndexName;
            pNewIndex->szKey = pIndex->szIndexKeys;
            pNewIndex->cbKey = pIndex->cbIndexKeys;
            pNewIndex->grbit = pIndex->ulFlags;
            pNewIndex->ulDensity = pIndex->ulDensity;
            if (pIndex->pConditionalColumn) {
                pNewIndex->rgconditionalcolumn = pIndex->pConditionalColumn;
                pNewIndex->cConditionalColumn = 1;
            }
            pNewIndex++;
            cIndexNeeded++;
        }
    }

    //
    // Create the batch
    //

    if (cIndexNeeded) {
        err = dbCreateIndexBatch( initsesid, tblid, cIndexNeeded, pIndexCreate );
        if (err) {
            goto abort;
        }
    }

    // Gather index hint for fixed indices
    for( pIndex = pCreateIndexes;
         pIndex->szIndexName != NULL;
         pIndex++ ) {
        err = JetGetTableIndexInfo(initsesid,
                                   tblid,
                                   pIndex->szIndexName,
                                   pIndex->pidx,
                                   sizeof(JET_INDEXID),
                                   JET_IdxInfoIndexId);
        if (err) {
            DPRINT2(0, "JetGetTableIndexInfo (%s) error: %d\n",
                    pIndex->szIndexName, err);
            LogUnhandledError(err);
            goto abort;
        }
    }

abort:
    THFreeEx(pTHS, pIndexCreate);

    return err;

} /* createNewIndexes */


JET_ERR
dbCreateNewIndexes(
    JET_SESID initsesid,
    JET_TABLEID tblid,
    DWORD cIndexCreate,
    CreateIndexParams *pCreateIndexes
    )

/*++

Routine Description:

    Create missing indexes.

    This is the serial version of this function.
    The batch version of this function is dbCreateNewIndexesBatch.

Arguments:

    initsesid - database session
    tblid - table cursor
    cIndexCreate - Number of indexes to check
    pCreateIndexes - index attributes

Return Value:

    JET_ERR -

--*/

{
    THSTATE *pTHS = pTHStls;
    JET_ERR err = 0;
    CreateIndexParams *pIndex;

    for( pIndex = pCreateIndexes;
         pIndex->szIndexName != NULL;
         pIndex++ ) {

        err = dbCreateSingleIndex( initsesid, tblid, pIndex, FALSE /* don't recreate */ );
        if (err) {
            break;
        }
    }

    return err;

} /* createNewIndexes */


JET_ERR
dbModifyExistingIndexes(
    JET_SESID initsesid,
    JET_TABLEID tblid,
    CreateIndexParams *pModifyIndexes
    )

/*++

Routine Description:

Jliem writes:
The difference between JetGetIndexInfo() and JetGetTableIndexInfo() is that the
former takes a table name while the latter takes a table cursor.  If you already
have a cursor opened on the table, use the latter.  If not, use the former.
Note that Internally, the former is just a wrapper for the latter and simply opens
the table for you before calling the latter.

The difference between JET_IdxInfo and JET_IdxInfoList is that the former returns
a temp. table with info on only one index while the latter returns a temp. table
with info. on all the indexes of the table.  For a given index, the temp. table will
contain a number of records equal to the number of columns in the index.  So for
instance, if an index "Foo" was over three columns, "+ColA+ColB+ColC", there would be
3 records in the temp. table for that index.  When you're navigating the temp. table,
you can use the "cColumns" column of the record to tell how many total columns
(and thus records) are in the current index and the "iColumns" column of the record to
tell which column of the index the current record pertains to.

Arguments:

    initsesid -
    tblid -
    pModifyIndexes -

Return Value:

    JET_ERR -

--*/

{
    JET_ERR err;
    CreateIndexParams *pIndex;
    JET_INDEXLIST indexList;
    JET_TABLEID indexTable;
    JET_RETRIEVECOLUMN attList[4];
    CHAR szIndexName[50], szOldIndexName[50];
    DWORD grbitIndex, cColumn, iColumn;

    szOldIndexName[0] = '\0';

    // Account for the fact that if you specify IgnoreAnyNull,
    // Jet forces IgnoreFirstNull|IgnoreNull
    for( pIndex = pModifyIndexes;
         pIndex->szIndexName != NULL;
         pIndex++ ) {
        if (pIndex->ulFlags & JET_bitIndexIgnoreAnyNull) {
            pIndex->ulFlags |=
                (JET_bitIndexIgnoreNull | JET_bitIndexIgnoreFirstNull );
        }
    }

    err = JetGetTableIndexInfo(initsesid,
                               tblid,
                               NULL, // All indexes
                               &indexList,
                               sizeof(indexList),
                               JET_IdxInfoList);
    if (err) {
        DPRINT2(0, "JetGetTableIndexInfo (%s) error: %d\n",
                pIndex->szIndexName, err);
        LogUnhandledError(err);
        return err;
    }

    indexTable = indexList.tableid;

    err = JetMove(initsesid, indexTable, JET_MoveFirst, 0);
    if (err) {
        DPRINT1(0, "JetMove error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }

    do {
        memset( attList, 0, sizeof(attList) );

        attList[0].columnid = indexList.columnidindexname;
        attList[0].pvData = szIndexName;
        attList[0].cbData = sizeof(szIndexName);
        attList[0].itagSequence = 1;
        attList[1].columnid = indexList.columnidgrbitIndex;
        attList[1].pvData = &grbitIndex;
        attList[1].cbData = sizeof(grbitIndex);
        attList[1].itagSequence = 1;
        attList[2].columnid = indexList.columnidcColumn;
        attList[2].pvData = &cColumn;
        attList[2].cbData = sizeof(cColumn);
        attList[2].itagSequence = 1;

        // Null terminate index name buffer
        memset( szIndexName, 0, sizeof(szIndexName));

        err = JetRetrieveColumns( initsesid, indexTable, attList, 3);
        if (err) {
            DPRINT1(0, "JetRetrieveColumns error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
        DPRINT3( 4, "Name = %s, grbit = 0x%x, cCol = %d\n",
                 szIndexName, grbitIndex, cColumn );

        // The entries in this table metadata table are one record per column in the index

        if (strcmp( szIndexName, szOldIndexName ) != 0) {
            // First occurance of a unique index

            for( pIndex = pModifyIndexes;
                 pIndex->szIndexName != NULL;
                 pIndex++ ) {

                if (strcmp( szIndexName, pIndex->szIndexName ) == 0) {
                    DWORD newColCount;
                    LPSTR p;

                    // Count number of new columns
                    for( p = pIndex->szIndexKeys, newColCount = 0;
                         *p != '\0';
                         p += strlen( p ) + 1, newColCount++ ) ;

                    // TODO: implement more sophisticated column difference
                    if ( (grbitIndex != pIndex->ulFlags) ||
                         (cColumn != newColCount) ) {
                        DPRINT1( 0, "Index %s has changed.\n", pIndex->szIndexName );
                        DPRINT4( 4, "grbit = 0x%x, cCol = %d, grbit = 0x%x, cCol = %d\n",
                                 grbitIndex, cColumn, pIndex->ulFlags, newColCount );

                        err = dbCreateSingleIndex( initsesid, tblid, pIndex, TRUE /*recreate*/ );
                        if (err) {
                            return err;
                        }
                    }
                }
            }
            strcpy( szOldIndexName, szIndexName );
        }

        err = JetMove( initsesid, indexTable, JET_MoveNext, JET_bitMoveKeyNE );
    } while (!err);

    if (err != JET_errNoCurrentRecord) {
        DPRINT1(0, "JetMove error: %d\n", err);
        LogUnhandledError(err);
        // Keep going
    }

    err = JetCloseTable( initsesid, indexTable );
    if (err) {
        DPRINT1(0, "JetCloseTable error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }

    return err;
} /* modifyExistingIndexes */


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function initializes JET, creates the base SESID, and finds
   all the attribute columns in the JET data table. Each DBOpen must
   create a unique JET sesid, dbid and tableid for each DBPOS structure.
*/

int APIENTRY DBInit(void){

    unsigned i;
    JET_ERR     err;
    JET_DBID    dbid;
    JET_TABLEID dattblid;
    JET_TABLEID linktblid;
    JET_TABLEID proptblid;
    JET_TABLEID sdtblid;
    JET_COLUMNDEF coldef;
    ULONG ulErrorCode, dwException, dsid;
    PVOID dwEA;
    JET_SESID     initsesid;
    SID_IDENTIFIER_AUTHORITY NtAuthority =  SECURITY_NT_AUTHORITY;
    BOOL        fSDConversionRequired = FALSE;
    BOOL        fWriteHiddenFlags = FALSE;

#if DBG

    // Initialize the DBPOS array

    for (i=0; i < MAXDBPOS; i++){
        opendbpos[i].pDB = 0;
        opendbpos[i].sesid = 0;
    }
#endif


    if (!gFirstTimeThrough)
        return 0;

    gFirstTimeThrough = FALSE;


    // control use of JET_prepReadOnlyCopy for testing

    if (!GetConfigParam(DB_CACHE_RECORDS, &gfEnableReadOnlyCopy, sizeof(gfEnableReadOnlyCopy))) {
        gfEnableReadOnlyCopy = !!gfEnableReadOnlyCopy;
    } else {
        gfEnableReadOnlyCopy = TRUE;  // default
    }


    // if a transaction lasts longer than gMaxTransactionTime,
    // an event will be logged when DBClose.

    if (!GetConfigParam(DB_MAX_TRANSACTION_TIME, &gMaxTransactionTime, sizeof(gMaxTransactionTime))) {
        gMaxTransactionTime *= 1000;                               //second to tick
    }
    else {
        gMaxTransactionTime = MAX_TRANSACTION_TIME;                //default
    }

    dbInitIndicesToKeep();

    // Create a copy of the builtin domain sid.  The dnread cache needs this.
    RtlAllocateAndInitializeSid(
            &NtAuthority,
            1,
            SECURITY_BUILTIN_DOMAIN_RID,
            0,0, 0, 0, 0, 0, 0,
            &pgdbBuiltinDomain
            );


    opensess = calloc(gcMaxJetSessions, sizeof(OPENSESS));
    UncUsn = malloc(gcMaxJetSessions * sizeof(UncUsn[0]));
    if (!opensess || !UncUsn) {
        MemoryPanic(gcMaxJetSessions * (sizeof(OPENSESS) + sizeof(UncUsn[0])));
        return ENOMEM;
    }

    // Initialize uncommitted usns array

    for (i=0;i < gcMaxJetSessions;i++) {
        UncUsn[i] = USN_MAX;
    }

    __try {
        InitializeCriticalSection(&csAddList);

#if DBG
        InitializeCriticalSection(&csDBPOS);
#endif
        err = 0;
    }
    __except (GetExceptionData(GetExceptionInformation(), &dwException,
                               &dwEA, &ulErrorCode, &dsid)) {
        err = dwException;
    }

    if (err) {
        DsaExcept(DSA_MEM_EXCEPTION, 0, 0);
    }

    //
    // Do JetInit, BeginSession, Attach/OpenDatabase
    //

    err = DBInitializeJetDatabase( &jetInstance, &initsesid, &dbid, NULL, TRUE );
    if (err != JET_errSuccess) {
        return err;
    }

    /* Most indices are created by the schema cache, but certain
     * ones must be present in order for us to even read the schema.
     * Create those now.
     */
    err = DBRecreateFixedIndices(initsesid, dbid);
    if (err) {
        DPRINT1(0, "Error %d recreating fixed indices\n", err);
        LogUnhandledError(err);
        return err;
    }

    /* Open data table */

    if ((err = JetOpenTable(initsesid, dbid, SZDATATABLE, NULL, 0, 0,
                            &dattblid)) != JET_errSuccess) {
        DPRINT1(1, "JetOpenTable error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetOpenTable complete\n");

    // create localized indices

    if (err = dbCreateLocalizedIndices(initsesid, dattblid))
        {
            DPRINT(0,"Localized index creation failed\n");
            LogUnhandledError(err);
            return err;
        }

    // Modify existing data table indexes at runtime if necessary
    if (err = dbModifyExistingIndexes( initsesid,
                                       dattblid,
                                       rgModifyDataIndexes)) {
        // Error already logged
        return err;
    }

    /* Get DNT column ID */
    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZDNT, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (DNT) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (DNT) complete\n");
    dntid = coldef.columnid;
    // fill in the template used in the DNRead function.
    dnreadColumnInfoTemplate[0].columnid = dntid;
    dnreadColumnInfoTemplate[0].cbData = sizeof(ULONG);

    /* Get PDNT column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZPDNT, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (PDNT) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (PDNT) complete\n");
    pdntid = coldef.columnid;
    // fill in the template used in the DNRead function.
    dnreadColumnInfoTemplate[1].columnid = pdntid;
    dnreadColumnInfoTemplate[1].cbData = sizeof(ULONG);

    /* Get Ancestors column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZANCESTORS, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (ANCESTORS) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (ANCESTORS) complete\n");
    ancestorsid = coldef.columnid;
    dnreadColumnInfoTemplate[10].columnid = ancestorsid;

    /* Get object flag */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZOBJ, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (OBJ) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (OBJ) complete\n");
    objid = coldef.columnid;
    // fill in the template used in the DNRead function.
    dnreadColumnInfoTemplate[2].columnid = objid;
    dnreadColumnInfoTemplate[2].cbData = sizeof(char);

    /* Get RDN column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZRDNATT, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (RDN) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (RDN) complete\n");
    rdnid = coldef.columnid;
    // fill in the template used by the DNRead function
    dnreadColumnInfoTemplate[7].columnid = rdnid;
    dnreadColumnInfoTemplate[7].cbData=MAX_RDN_SIZE * sizeof(WCHAR);

    /* Get RDN Type column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZRDNTYP, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (RDNTYP) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (RDNTYP) complete\n");
    rdntypid = coldef.columnid;
    // fill in the template used in the DNRead function.
    dnreadColumnInfoTemplate[3].columnid = rdntypid;
    dnreadColumnInfoTemplate[3].cbData = sizeof(ATTRTYP);

    /* Get count column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZCNT, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (Cnt) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (Cnt) complete\n");
    cntid = coldef.columnid;

    /* Get abref count column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZABCNT, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (ABCnt) error: %d\n", err);
        // On upgrade paths, this is not necessarily here in all DBs.  Ignore
        // this failure.
        abcntid = 0;
        gfDoingABRef = FALSE;
    }
    else {
        DPRINT(5,"JetGetTableColumnInfo (ABCnt) complete\n");
        abcntid = coldef.columnid;
        gfDoingABRef = (coldef.grbit & JET_bitColumnEscrowUpdate);
        // IF the column exists and is marked as escrowable, then we are
        // keeping track of show ins for MAPI support.
    }

    /* Get delete time column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZDELTIME,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (Time) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (Time) complete\n");
    deltimeid = coldef.columnid;

    /* Get NCDNT column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZNCDNT, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (NCDNT) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (NCDNT) complete\n");
    ncdntid = coldef.columnid;
    dnreadColumnInfoTemplate[4].columnid = ncdntid;
    dnreadColumnInfoTemplate[4].cbData = sizeof(ULONG);

    /* Get IsVisibleInAB column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZISVISIBLEINAB,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (IsVisibleInABT) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (IsVisibleInAB) complete\n");
    IsVisibleInABid = coldef.columnid;

    /* Get ShowIn column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZSHOWINCONT,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (ShowIn) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (ShowIn) complete\n");
    ShowInid = coldef.columnid;

    /* Get MAPIDN column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZMAPIDN,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (MAPIDN) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (MAPIDN) complete\n");
    mapidnid = coldef.columnid;

    /* Get IsDeleted column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZISDELETED,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (isdeleted) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (isdeleted) complete\n");
    isdeletedid = coldef.columnid;

    /* Get dscorepropagationdata column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZDSCOREPROPINFO,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (DSCorePropInfo) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (dscorepropinfoid) complete\n");
    dscorepropinfoid = coldef.columnid;
    dbAddSDPropTimeReadTemplate[0].columnid = coldef.columnid;
    dbAddSDPropTimeReadTemplate[1].columnid = coldef.columnid;
    dbAddSDPropTimeReadTemplate[2].columnid = coldef.columnid;
    dbAddSDPropTimeWriteTemplate[0].columnid= coldef.columnid;
    dbAddSDPropTimeWriteTemplate[1].columnid= coldef.columnid;
    dbAddSDPropTimeWriteTemplate[2].columnid= coldef.columnid;

    /* Get Object Class column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZOBJCLASS,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (DNT) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (objectClass) complete\n");
    objclassid = coldef.columnid;
    dnreadColumnInfoTemplate[8].columnid = objclassid;
    dnreadColumnInfoTemplate[8].cbData = sizeof(DWORD);

    /* Get SecurityDescriptor column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZNTSECDESC,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (DNT) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (NT-Sec-Disc) complete\n");
    ntsecdescid = coldef.columnid;
    dnreadColumnInfoTemplate[9].columnid = ntsecdescid;
    dnreadColumnInfoTemplate[9].cbData = sizeof(SDID);

    /* Get instancetype column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZINSTTYPE,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (DNT) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (instance type) complete\n");
    insttypeid = coldef.columnid;

    /* Get USNChanged column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZUSNCHANGED,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (USNCHANGED) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (USNCHANGED) complete\n");
    usnchangedid = coldef.columnid;

    /* Get GUID column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZGUID,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (GUID) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (GUID) complete\n");
    guidid = coldef.columnid;
    // fill in the template used in the DNRead function.
    dnreadColumnInfoTemplate[5].columnid = guidid;
    dnreadColumnInfoTemplate[5].cbData = sizeof(GUID);

    /* Get OBJDISTNAME column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZDISTNAME,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (DISTNAME) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (DISTNAME) complete\n");
    distnameid = coldef.columnid;

    /* Get SID column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZSID,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (SID) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (SID) complete\n");
    sidid = coldef.columnid;
    // fill in the template used in the DNRead function.
    dnreadColumnInfoTemplate[6].columnid = sidid;
    dnreadColumnInfoTemplate[6].cbData = sizeof(NT4SID);

    /* Get IsCritical column ID */

    if ((err = JetGetTableColumnInfo(initsesid, dattblid, SZISCRITICAL,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess) {
        DPRINT1(1, "JetGetTableColumnInfo (iscritical) error: %d\n", err);
        LogUnhandledError(err);
        return err;
    }
    DPRINT(5,"JetGetTableColumnInfo (iscritical) complete\n");
    iscriticalid = coldef.columnid;

    // cleanid is populated through the dbCreateNewColumns call


    /* Open link table */
    // Open table exclusively in case indexes need to be updated
    if ((err = JetOpenTable(initsesid, dbid, SZLINKTABLE,
                            NULL, 0,
                            JET_bitTableDenyRead, &linktblid)) != JET_errSuccess)
        {
            DPRINT1(0, "JetOpenTable (link table) error: %d.\n", err);
            LogUnhandledError(err);
            return err;
        }

    /* get linkDNT column id */

    if ((err = JetGetTableColumnInfo(initsesid, linktblid, SZLINKDNT, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess)
        {
            DPRINT1(1, "JetGetTableColumnInfo (link DNT) error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    linkdntid = coldef.columnid;

    /* get linkDNT column id */

    if ((err = JetGetTableColumnInfo(initsesid, linktblid, SZBACKLINKDNT,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess)
        {
            DPRINT1(1, "JetGetTableColumnInfo (backlink DNT) error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    backlinkdntid = coldef.columnid;

    /* get link base column id */

    if ((err = JetGetTableColumnInfo(initsesid, linktblid, SZLINKBASE, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess)
        {
            DPRINT1(1, "JetGetTableColumnInfo (link base) error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    linkbaseid = coldef.columnid;

    /* get link data column id */

    if ((err = JetGetTableColumnInfo(initsesid, linktblid, SZLINKDATA, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess)
        {
            DPRINT1(1, "JetGetTableColumnInfo (link data) error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    linkdataid = coldef.columnid;

    /* get link ndesc column id */

    if ((err = JetGetTableColumnInfo(initsesid, linktblid, SZLINKNDESC, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess)
        {
            DPRINT1(1, "JetGetTableColumnInfo (link ndesc) error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    linkndescid = coldef.columnid;

    // Expand link table at runtime if necessary

    if (err = dbCreateNewColumns( initsesid,
                                linktblid,
                                rgCreateLinkColumns )) {
        // Error already logged
        return err;
    }

    // Modify existing link table indexes at runtime if necessary
    if (err = dbModifyExistingIndexes( initsesid,
                                       linktblid,
                                       rgModifyLinkIndexes)) {
        // Error already logged
        return err;
    }

    // BUGBUG - Call dbCreateNewIndexesBatch when Jet is fixed
    if (err = dbCreateNewIndexes( initsesid,
                                  linktblid,
                                  cNewLinkIndexes,
                                  rgCreateLinkIndexes)) {
        // Error already logged
        return err;
    }

    /* Open SD prop table */
    if ((err = JetOpenTable(initsesid, dbid, SZPROPTABLE,
                            NULL, 0, 0, &proptblid)) != JET_errSuccess)
        {
            DPRINT1(0, "JetOpenTable (link table) error: %d.\n", err);
            LogUnhandledError(err);
            return err;
        }

    /* get order column id */

    if ((err = JetGetTableColumnInfo(initsesid, proptblid, SZORDER,
                                     &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess)
        {
            DPRINT1(1, "JetGetTableColumnInfo (backlink DNT) error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    orderid = coldef.columnid;

    /* get begindnt column id */

    if ((err = JetGetTableColumnInfo(initsesid, proptblid, SZBEGINDNT, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess)
        {
            DPRINT1(1, "JetGetTableColumnInfo (link base) error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    begindntid = coldef.columnid;

    /* get trimmable column id */

    if ((err = JetGetTableColumnInfo(initsesid, proptblid, SZTRIMMABLE, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess)
        {
            DPRINT1(1, "JetGetTableColumnInfo (link data) error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    trimmableid = coldef.columnid;

    /* get clientid column id */

    if ((err = JetGetTableColumnInfo(initsesid, proptblid, SZCLIENTID, &coldef,
                                     sizeof(coldef), 0)) != JET_errSuccess)
        {
            DPRINT1(1, "JetGetTableColumnInfo (link data) error: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
    clientidid = coldef.columnid;

    // grab new columns (or create if needed)
    if (err = dbCreateNewColumns(initsesid, proptblid, rgCreateSDPropColumns)) {
        // error already logged
        return err;
    }

    /* Open SD table */
    // Open table exclusively in case columns/indexes need to be updated
    err = JetOpenTable(initsesid, dbid, SZSDTABLE, NULL, 0, JET_bitTableDenyRead, &sdtblid);
    if (err == JET_errObjectNotFound) {
        DPRINT(0, "SD table not found. Must be an old DIT. Creating SD table\n");
        // old-style DIT. Need to create SD table
        if ((err = JetCreateTable(initsesid, dbid, SZSDTABLE, 2, 90, &sdtblid)) != JET_errSuccess ) {
            DPRINT1(0, "JetCreateTable (SD table) error: %d.\n", err);
            LogUnhandledError(err);
            return err;
        }
        // SD table was not present -- must be upgrading an existing old-style DIT
        // set the global flag so that DsaDelayedStartupHandler can schedule the global SD rewrite
        fSDConversionRequired = TRUE;
    }
    else if (err != JET_errSuccess) {
        DPRINT1(0, "JetOpenTable (SD table) error: %d.\n", err);
        LogUnhandledError(err);
        return err;
    }
    // grab columns (or create if needed)
    if (err = dbCreateNewColumns(initsesid, sdtblid, rgCreateSDColumns)) {
        // error already logged
        return err;
    }
    // grab index (or create if needed)
    if (err = dbCreateNewIndexes( initsesid,
                                  sdtblid,
                                  cNewSDIndexes,
                                  rgCreateSDIndexes)) {
        // Error already logged
        return err;
    }

    /* Get Index ids */
    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZDELINDEX,
                               &idxDel,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        LogUnhandledError(err);
        return err;
    }
    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZDNTINDEX,
                               &idxDnt,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        LogUnhandledError(err);
        return err;
    }
    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZDRAUSNINDEX,
                               &idxDraUsn,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        LogUnhandledError(err);
        return err;
    }

    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZGUIDINDEX,
                               &idxGuid,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        LogUnhandledError(err);
        return err;
    }
    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZMAPIDNINDEX,
                               &idxMapiDN,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        memset(&idxMapiDN, 0, sizeof(JET_INDEXID));
    }
    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZ_NC_ACCTYPE_SID_INDEX,
                               &idxNcAccTypeSid,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        LogUnhandledError(err);
        return err;
    }
    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZPHANTOMINDEX,
                               &idxPhantom,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        memset(&idxPhantom, 0, sizeof(JET_INDEXID));
    }
    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZPROXYINDEX,
                               &idxProxy,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        memset(&idxProxy, 0, sizeof(JET_INDEXID));
    }
    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZSIDINDEX,
                               &idxSid,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        LogUnhandledError(err);
        return err;
    }

    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZANCESTORSINDEX,
                               &idxAncestors,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        LogUnhandledError(err);
        return err;
    }

    err = JetGetTableIndexInfo(initsesid,
                               dattblid,
                               SZINVOCIDINDEX,
                               &idxInvocationId,
                               sizeof(JET_INDEXID),
                               JET_IdxInfoIndexId);
    if (err) {
        LogUnhandledError(err);
        return err;
    }

    /* We're done.  Close JET session */

    if ((err = JetCloseDatabase(initsesid, dbid, 0))  != JET_errSuccess)
        {
            DPRINT1(1, "JetCloseDatabase error: %d\n", err);
            LogUnhandledError(err);
        }

    InterlockedDecrement(&gcOpenDatabases);
    DPRINT3(2,"DBInit - JetCloseDatabase. Session = %d. Dbid = %d.\n"
            "Open database count: %d\n",
            initsesid, dbid,  gcOpenDatabases);

    if ((err = JetEndSession(initsesid, JET_bitForceSessionClosed))
        != JET_errSuccess)

        DPRINT1(1, "JetEndSession error: %d\n", err);

    DBEndSess(initsesid);

    /* Initialize a DBPOS for hidden record accesses */

    if (err = dbCreateHiddenDBPOS())
        return err;

    // read the setting flags
    ZeroMemory (&gdbFlags, sizeof (gdbFlags));
    err = dbGetHiddenFlags ((CHAR *)&gdbFlags, sizeof (gdbFlags));

    if (err) {
        DPRINT1 (0, "Error Retrieving FLags: %d\n", err);

        // for > whistler beta2, start with 1
        gdbFlags[DBFLAGS_AUXCLASS] = '1';
        gdbFlags[DBFLAGS_SD_CONVERSION_REQUIRED] = '0';
        fWriteHiddenFlags = TRUE;
    }
    if (fSDConversionRequired) {
        gdbFlags[DBFLAGS_SD_CONVERSION_REQUIRED] = '1';
        fWriteHiddenFlags = TRUE;
    }

    if (fWriteHiddenFlags) {
        err = DBUpdateHiddenFlags();
        if (err) {
            DPRINT1 (0, "Error Setting Flags: %d\n", err);
        }
    }

    return 0;

}  /*DBInit*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function registers open JET sessions.
 * We do this because JET insists that all sessions be closed before we
 * can call JetTerm so we keep track of open sessions so that we can
 * close them in DBEnd.
*/

extern int APIENTRY DBAddSess(JET_SESID sess, JET_DBID dbid){

    unsigned i;
    int ret = 1;

    DPRINT(2,"DBAddSess\n");
    EnterCriticalSection(&csSessions);
    __try {
        for (i=0; ret && (i < gcMaxJetSessions); i++)
        {
            if (opensess[i].sesid == 0)
            {
                opensess[i].sesid = sess;
                opensess[i].dbid = dbid;
                ret = 0;
            }
        }
    }
    __finally {
        LeaveCriticalSection(&csSessions);
    }

    return ret;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function deletes closed JET sessions
*/

extern int APIENTRY DBEndSess(JET_SESID sess){

    unsigned i;
    int ret = 1;

    DPRINT(2,"DBEndSess\n");

    EnterCriticalSection(&csSessions);
    __try {
        for (i=0; ret && (i < gcMaxJetSessions); i++)
        {
            if (opensess[i].sesid == sess)
            {
                opensess[i].sesid = 0;
                opensess[i].dbid = 0;
                ret = 0;
            }
        }
    }
    __finally {
        LeaveCriticalSection(&csSessions);
    }

    return ret;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function closes all open JET sessions and calls JetTerm
*/

void DBEnd(void){

    JET_ERR     err;
    unsigned    i;

    if (!gfNeedJetShutdown) {
        return;
    }

    __try {
        DPRINT(0, "DBEnd\n");

        // Close the hidden DB session.
        // We'll change this if time permits to only open the hidden
        // session as needed and the close it.

        dbCloseHiddenDBPOS();

        // Close all remaining in-use sessions, including those in the cache.
        // That is, the opensess table includes all sessions in the cache plus
        // those in actual use, so closing all the opensess sessions will
        // automatically close all session in the cache.  Thus we can just
        // discard all the cache items, safe in the knowledge that they'll
        // be cleaned up.

        // Discard the cache
        for ( ; gSessionCacheIndex<SESSION_CACHE_SIZE; gSessionCacheIndex++) {
            memset(&gaSessionCache[gSessionCacheIndex],0,sizeof(SESSIONCACHE));
        }
        // Close all sessions
        EnterCriticalSection(&csSessions);
        __try {
            for (i=0; i < gcMaxJetSessions; i++) {
                if (opensess[i].sesid != 0) {
#if DBG
                    dbCheckJet(opensess[i].sesid);
#endif
                    if(opensess[i].dbid)
                      // JET_bitDbForceClose not supported in Jet600.
                      if ((err = JetCloseDatabase(opensess[i].sesid,
                                                  opensess[i].dbid,
                                                  0)) !=
                          JET_errSuccess) {
                          DPRINT1(1,"JetCloseDatabase error: %d\n", err);
                      }

                    InterlockedDecrement(&gcOpenDatabases);
                    DPRINT3(2,
                            "DBEnd - JetCloseDatabase. Session = %d. "
                            "Dbid = %d.\nOpen database count: %d\n",
                            opensess[i].sesid,
                            opensess[i].dbid,
                            gcOpenDatabases);

                    if ((err = JetEndSession(opensess[i].sesid,
                                             JET_bitForceSessionClosed))
                        != JET_errSuccess)

                      DPRINT1(1, "JetEndSession error: %d\n", err);
                    opensess[i].sesid = 0;
                    opensess[i].dbid = 0;
                }
            }
        }
        __finally {
            LeaveCriticalSection(&csSessions);
        }
        JetTerm(jetInstance);
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        // do nothing
    }
    gfNeedJetShutdown = FALSE;
}






ULONG cSessionCacheTry;
ULONG cSessionCacheHit;
ULONG *pcSessionCacheTry = &cSessionCacheTry;
ULONG *pcSessionCacheHit = &cSessionCacheHit;


/*++ dbCloseJetSessionCacheEntry
 *
 * This routine closes everything associated with a session cache, and
 * zeros out the cache object.  It is to be called only by the session
 * cache code itself, and is in a separate routine only so that common
 * code can be used for the cache-overflow and shutdown/rundown cases.
 */
void dbCloseJetSessionCacheEntry(SESSIONCACHE *pJetCache)
{
    JetCloseTable(pJetCache->sesid, pJetCache->objtbl);
    JetCloseTable(pJetCache->sesid, pJetCache->searchtbl);
    JetCloseTable(pJetCache->sesid, pJetCache->linktbl);
    JetCloseTable(pJetCache->sesid, pJetCache->sdproptbl);
    JetCloseTable(pJetCache->sesid, pJetCache->sdtbl);

    JetCloseDatabaseEx(pJetCache->sesid, pJetCache->dbid, 0);
#if DBG
    dbCheckJet(pJetCache->sesid);
#endif
    JetEndSessionEx(pJetCache->sesid, JET_bitForceSessionClosed);
    DBEndSess(pJetCache->sesid);

    if ((0 == InterlockedDecrement(&gcOpenDatabases)) && eServiceShutdown) {
        SetEvent(hevDBLayerClear);
    }

    memset(pJetCache, 0, sizeof(SESSIONCACHE));
}

/*++ RecycleSession
 *
 * This routine cleans out a session (if convenient) and places it into a
 * session cache.  If the cache is full or we're shutting down, the session
 * is closed.
 *
 * INPUT:
 *   pTHS  - pointer to current thread state
 * OUTPUT:
 *   none
 * RETURN VALUE:
 *   none
 */
void RecycleSession(THSTATE *pTHS)
{
    DBPOS *pDB = pTHS->pDB;
    if (!pTHS->JetCache.sesid) {
        /* nothing to do */
        return;
    }

    Assert(pTHS->JetCache.sesid);

    Assert(!pTHS->JetCache.dataPtr);

    // Should never retire a session which is not at transaction
    // level 0.  Else next thread to get this session will not
    // have clean view of the database.
    Assert(0 == pTHS->transactionlevel);


    // For free builds, handle the case where the above Assert is false
    if(pDB && (pDB->transincount>0)) {

#ifdef DBG
        if (IsDebuggerPresent()) {
            OutputDebugString("DS: Thread freed with open transaction,"
                              " please contact anyone on dsteam\n");
            OutputDebugString("DS: Or at least mail a stack trace to dsteam"
                              " and then hit <g> to continue\n");
            DebugBreak();
        }
#endif

        // If we still have a transaction open, abort it, because it's
        // too late to do anything useful

        while (pDB->transincount) {
            // DBTransOut will decrement pDB->cTransactions.
            DBTransOut(pDB, FALSE, FALSE);
        }
    }

    // Jet seems to think that we've been re-using sessions with
    // open transactions.  Verify that Jet thinks this session is
    // safe as well.
    #if DBG
    {
        DWORD err = JetRollback(pTHS->JetCache.sesid, 0);
        Assert( (err == JET_errNotInTransaction) || (err == JET_errTermInProgress) );
    }
    #endif

    if (!eServiceShutdown) {
        EnterCriticalSection(&csSessionCache);
        if (gSessionCacheIndex != 0) {
            --gSessionCacheIndex;
            gaSessionCache[gSessionCacheIndex] = pTHS->JetCache;
            pTHS->JetCache.sesid = 0;
        }
        LeaveCriticalSection(&csSessionCache);
    }

    if (pTHS->JetCache.sesid) {
        // If we still have a session id it could be because the cache
        // was full or because we're shutting down.  In any case,
        // since we're not going to cache this one, destroy it.

        dbCloseJetSessionCacheEntry(&(pTHS->JetCache));
    }

}

/*++ GrabSession
 *
 * This routine grabs a session from the session cache, if one exists.  If no
 * cached session is available then a new one is created.
 *
 * INPUT:
 *   none
 * OUTPUT:
 *   none
 * RETURN VALUE:
 *   error code
 */
DWORD GrabSession(void)
{
    SESSIONCACHE scLocal;
    DWORD err = 0;

    ULONG ulErrorCode, dwException, dsid;
    PVOID dwEA;


    INC(pcSessionCacheTry);
    memset(&scLocal, 0, sizeof(scLocal));
    EnterCriticalSection(&csSessionCache);
    if (gSessionCacheIndex != SESSION_CACHE_SIZE) {
        scLocal = gaSessionCache[gSessionCacheIndex];
        memset(&gaSessionCache[gSessionCacheIndex], 0, sizeof(SESSIONCACHE));
        ++gSessionCacheIndex;
        Assert(!scLocal.dataPtr);

    }
    LeaveCriticalSection(&csSessionCache);

    // Session should be at transaction level 0 either because of the
    // memset earlier, or because all transactions should be at level
    // 0 when returned to the cache.  See assert in RecycleSession.
    Assert(0 == scLocal.transLevel);

    if (!scLocal.sesid) {
        // Cache was empty, so let's create a new one.

        __try {
            scLocal.sesid = scLocal.dbid = 0;

            JetBeginSessionEx(jetInstance,
                              &scLocal.sesid,
                              szUser,
                              szPassword);

            JetOpenDatabaseEx(scLocal.sesid,
                              szJetFilePath,
                              "",
                              &scLocal.dbid,
                              0);

            // Open data table
            JetOpenTableEx(scLocal.sesid,
                           scLocal.dbid,
                           SZDATATABLE,
                           NULL,
                           0,
                           0,
                           &scLocal.objtbl);

            /* Create subject search cursor */
            JetDupCursorEx(scLocal.sesid,
                           scLocal.objtbl,
                           &scLocal.searchtbl,
                           0);

            /* Open the Link Table */
            JetOpenTableEx(scLocal.sesid,
                           scLocal.dbid,
                           SZLINKTABLE,
                           NULL,
                           0,
                           0,
                           &scLocal.linktbl);

            JetOpenTableEx(scLocal.sesid,
                           scLocal.dbid,
                           SZPROPTABLE,
                           NULL,
                           0,
                           0,
                           &scLocal.sdproptbl);

            JetOpenTableEx(scLocal.sesid,
                           scLocal.dbid,
                           SZSDTABLE,
                           NULL,
                           0,
                           0,
                           &scLocal.sdtbl);
            // we mostly need ID index for SDID lookups it's primary, so pass NULL for perf
            JetSetCurrentIndex4Success(scLocal.sesid,
                                       scLocal.sdtbl,
                                       NULL,
                                       &idxSDId,
                                       0);

            scLocal.tablesInUse = FALSE;

            InterlockedIncrement(&gcOpenDatabases);
            DBAddSess(scLocal.sesid, scLocal.dbid);

        }
        __except (GetExceptionData(GetExceptionInformation(), &dwException,
                               &dwEA, &ulErrorCode, &dsid)) {

            if (scLocal.dbid) {
                JetCloseDatabase (scLocal.sesid, scLocal.dbid, 0);
                scLocal.dbid = 0;
            }

            if (scLocal.sesid) {
                JetEndSession (scLocal.sesid, JET_bitForceSessionClosed);
                scLocal.sesid = 0;
            }

            err = DB_ERR_UNKNOWN_ERROR;
        }
    }
    else {
        INC(pcSessionCacheHit);
    }

    Assert(!scLocal.dataPtr);
    pTHStls->JetCache = scLocal;

    return err;
}

/*++ DBFlushSessionCache
 *
 * This routine empties out the DBLayer's cache of JET sessions.  It is
 * intended for use only at shutdown time.
 */
void DBFlushSessionCache( void )
{
    SESSIONCACHE scLocal;
    BOOL bEmpty = FALSE;
    memset(&scLocal, 0, sizeof(scLocal));

    // Set a very small checkpoint depth to cause the database cache to start
    // flushing all important dirty pages to the database.  note that we do not
    // set the depth to zero because that would make any remaining updates
    // that need to be done very slow
    JetSetSystemParameter(
        NULL,
        0,
        JET_paramCheckpointDepthMax,
        16384,
        NULL );

    do {

        EnterCriticalSection(&csSessionCache);
        if (gSessionCacheIndex != SESSION_CACHE_SIZE) {
            scLocal = gaSessionCache[gSessionCacheIndex];
            memset(&gaSessionCache[gSessionCacheIndex],
                   0,
                   sizeof(SESSIONCACHE));
            ++gSessionCacheIndex;
            Assert(!scLocal.dataPtr);
        }
        LeaveCriticalSection(&csSessionCache);

        if (scLocal.sesid) {
            dbCloseJetSessionCacheEntry(&scLocal);
        }
        else {
            bEmpty = TRUE;
        }

    } while (!bEmpty);
}



/*
DBInitThread

Make sure this thread has initialized the DB layer.
The DB layer must be initialized once for each thread id.

Also open a DBPOS for this thread.

Returns zero for success, non zero for failure.

*/

DWORD DBInitThread( THSTATE *pTHS )
{
    DWORD err = 0;

    if (!pTHS->JetCache.sesid) {
        if (eServiceShutdown) {
            err = DB_ERR_SHUTTING_DOWN;
        }
        else {
            __try {
                err = GrabSession();
            }
            __except (HandleMostExceptions(GetExceptionCode())) {
                err = DB_ERR_UNKNOWN_ERROR;
            }
        }
    }
    return err;
}

DWORD APIENTRY DBCloseThread( THSTATE *pTHS)
{
    // Thread should always be at transaction level 0 when exiting.
    Assert(0 == pTHS->transactionlevel);

    dbReleaseGlobalDNReadCache(pTHS);

    RecycleSession(pTHS);

    // Ensure that this session holds no uncommitted usns. Normally they
    // should be cleared at this point, but if they're not the system
    // will eventually assert.

    dbFlushUncUsns();


    dbResetLocalDNReadCache (pTHS, TRUE);

    return 0;
}


char rgchABViewIndex[] = "+" SZSHOWINCONT "\0+" SZDISPNAME "\0+" SZISVISIBLEINAB "\0+" SZDNT "\0";

/*++ dbCreateLocalizedIndices
 *
 * This is one of the three routines in the DS that can create indices.
 * General purpose indices over single columns in the datatable are created
 * and destroyed by the schema cache by means of DB{Add|Del}ColIndex.
 * A localized index over a small fixed set of columns and a variable set
 * of languages, for use in tabling support for NSPI clients, is handled
 * in dbCreateLocalizedIndices.  Lastly, a small fixed set of indices that
 * should always be present are guaranteed by DBRecreateFixedIndices.
 */
DWORD
dbCreateLocalizedIndices (
        JET_SESID sesid,
        JET_TABLEID tblid
        )
/*++
  Description:
      Create the localized indices used for the MAPI NSPI support.  We create
      one index per language in a registry key.

  Return Values:
      We only return an error on such conditions as memory allocation failures.
      If we can't create any localized indices, we log, but we just go on,
      since we don't want this to cause a boot failure.
--*/
{
    DWORD dwType;
    HKEY  hk;
    ULONG i;
    JET_ERR err;
    BOOL fStop = FALSE;
    BOOL fIndexExists;
    BOOL fHaveDefaultLanguage = FALSE;
    char szSuffix[9] = "";
    char szIndexName[256];
    char szValueName[256];
    DWORD dwValueNameSize;
    DWORD dwLanguage = 0;
    DWORD dwLanguageSize;
    JET_INDEXCREATE       indexCreate;
    JET_UNICODEINDEX      unicodeIndexData;

    // Start by assuming we have no default language, and we don't support any
    // langauges.
    gAnchor.ulDefaultLanguage = 0;

    gAnchor.ulNumLangs = 0;
    gAnchor.pulLangs = malloc(20 * sizeof(DWORD));
    if (!gAnchor.pulLangs) {
        MemoryPanic(20 * sizeof(DWORD));
        return ENOMEM;
    }

    gAnchor.pulLangs[0] = 20;



    // open the language regkey
    if (err = RegOpenKey(HKEY_LOCAL_MACHINE, DSA_LOCALE_SECTION, &hk)) {
        DPRINT1(0, "%s section not found in registry. Localized MAPI indices"
                " will not be created ", DSA_LOCALE_SECTION);
        // Return no error, we still want to boot.
        return 0;
    }

    for (i = 0; !fStop; i++) {
        dwValueNameSize = sizeof(szValueName);
        dwLanguageSize = sizeof(dwLanguage);

        if (RegEnumValue(hk,
                         i,
                         szValueName,
                         &dwValueNameSize,
                         NULL,
                         &dwType,
                         (LPBYTE) &dwLanguage,
                         &dwLanguageSize)) {
            fStop = TRUE;
            continue;
        }
        else {
            sprintf(szSuffix,"%08X", dwLanguage);
        }

        if (!IsValidLocale(MAKELCID(dwLanguage, SORT_DEFAULT),LCID_INSTALLED)) {
            LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_BAD_LANGUAGE,
                     szInsertHex(dwLanguage),
                     NULL,
                     NULL);
        }
        else {
            // Valid locale.  See if the index is there.
            fIndexExists = FALSE;

            strcpy(szIndexName, SZABVIEWINDEX);
            strcat(szIndexName, szSuffix);

            if (JetSetCurrentIndex(sesid,
                                   tblid,
                                   szIndexName)) {
                // Didn't already find the index.  Try to create it.
                // Emit debugger message so people know why startup is slow.
                DPRINT1(0, "Creating localized index '%s' ...\n",
                        szIndexName);


                memset(&indexCreate, 0, sizeof(indexCreate));
                indexCreate.cbStruct = sizeof(indexCreate);
                indexCreate.szIndexName = szIndexName;
                indexCreate.szKey = rgchABViewIndex;
                indexCreate.cbKey = sizeof(rgchABViewIndex);
                indexCreate.grbit = (JET_bitIndexIgnoreAnyNull |
                                     JET_bitIndexUnicode           );
                indexCreate.ulDensity = DISPNAMEINDXDENSITY;
                indexCreate.pidxunicode = &unicodeIndexData;

                memset(&unicodeIndexData, 0, sizeof(unicodeIndexData));
                unicodeIndexData.lcid = dwLanguage;
                unicodeIndexData.dwMapFlags =
                    (DS_DEFAULT_LOCALE_COMPARE_FLAGS |
                     LCMAP_SORTKEY);



                err = JetCreateIndex2(sesid,
                                      tblid,
                                      &indexCreate,
                                      1);

                switch(err) {
                case JET_errIndexDuplicate:
                case 0:
                    DPRINT(0, "Index successfully created\n");
                    fIndexExists = TRUE;
                    break;

                default:
                    LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_LOCALIZED_CREATE_INDEX_FAILED,
                             szInsertUL(ATT_DISPLAY_NAME),
                             szInsertSz("ABVIEW"),
                             szInsertInt(dwLanguage),
                             szInsertInt(err),
                             NULL, NULL, NULL, NULL);
                    // Don't fail the call, that would fail booting.  Keep
                    // going, trying other locales.
                    break;
                }
            }
            else {
                DPRINT1(2, "Index '%s' verified\n", szIndexName);
                fIndexExists = TRUE;
            }

            if(fIndexExists) {
                // OK, we support this locale.  Add the local to the sized
                // buffer of locales we support
                gAnchor.ulNumLangs++;
                if(gAnchor.ulNumLangs == gAnchor.pulLangs[0]) {
                    DWORD cDwords = gAnchor.pulLangs[0] * 2;

                    /* oops, need a bigger buffer */
                    gAnchor.pulLangs =
                        realloc(gAnchor.pulLangs, cDwords * sizeof(DWORD));

                    if (!gAnchor.pulLangs) {
                        MemoryPanic(cDwords * sizeof(DWORD));
                        return ENOMEM;
                    }

                    gAnchor.pulLangs[0] = cDwords;
                }
                gAnchor.pulLangs[gAnchor.ulNumLangs] = dwLanguage;

                if(!fHaveDefaultLanguage) {
                    fHaveDefaultLanguage = TRUE;
                    gAnchor.ulDefaultLanguage = dwLanguage;
                }
            }
            else {
                LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_NO_LOCALIZED_INDEX_CREATED_FOR_LANGUAGE,
                         szInsertHex(dwLanguage),
                         NULL,
                         NULL);
            }
        }

    }

    if (hk)
        RegCloseKey(hk);

    if(!fHaveDefaultLanguage) {
        // No localized indices were created. This is bad, but only for the MAPI
        // interface, so complain, but don't fail.
        DPRINT(0, "Unable to create any indices to support MAPI interface.\n");
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                 DS_EVENT_SEV_VERBOSE,
                 DIRLOG_NO_LOCALIZED_INDICES_CREATED,
                 NULL,
                 NULL,
                 NULL);
    }
    else {
        DPRINT1 (1, "Default Language: 0x%x\n", gAnchor.ulDefaultLanguage);
    }

    return 0;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Obtain a DBPOS for use by the Get and Replace.  The DBPOS is used to
*  serialize access to the hidden record.
*/
extern JET_ERR APIENTRY
dbCreateHiddenDBPOS(void)
{
    JET_COLUMNDEF  coldef;
    JET_ERR        err;

    /* Create hidden DBPOS */

    DPRINT(2,"dbCreateHiddenDBPOS\n");

    pDBhidden = malloc(sizeof(DBPOS));
    if(!pDBhidden) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    memset(pDBhidden, 0, sizeof(DBPOS));   /*zero out the structure*/

    /* Initialize value work buffer */

    DPRINT(5, "ALLOC inBuf and valBuf\n");
    pDBhidden->pValBuf = malloc(VALBUF_INITIAL);
    pDBhidden->valBufSize = VALBUF_INITIAL;
    pDBhidden->Key.pFilter = NULL;
    pDBhidden->fHidden = TRUE;

    /* Open JET session. */

    JetBeginSessionEx(jetInstance, &pDBhidden->JetSessID, szUser, szPassword);

    JetOpenDatabaseEx(pDBhidden->JetSessID, szJetFilePath, "",
                      &pDBhidden->JetDBID, 0);

    DBAddSess(pDBhidden->JetSessID, pDBhidden->JetDBID);

#if DBG
    dbAddDBPOS (pDBhidden, pDBhidden->JetSessID);
#endif

    /* Open hidden table */

    JetOpenTableEx(pDBhidden->JetSessID, pDBhidden->JetDBID,
        SZHIDDENTABLE, NULL, 0, 0, &HiddenTblid);

    /* Create subject search cursor */

    JetOpenTableEx(pDBhidden->JetSessID, pDBhidden->JetDBID,
                   SZDATATABLE, NULL, 0, 0, &pDBhidden->JetSearchTbl);

    /* Initialize new object */

    DBSetFilter(pDBhidden, NULL, NULL, NULL, 0, NULL);
    DBInitObj(pDBhidden);

    /* Get USN column ID */

    JetGetTableColumnInfoEx(pDBhidden->JetSessID,
                            HiddenTblid,
                            SZUSN,
                            &coldef,
                            sizeof(coldef),
                            0);
    usnid = coldef.columnid;

    /* Get DSA name column ID */

    JetGetTableColumnInfoEx(pDBhidden->JetSessID,
                            HiddenTblid,
                            SZDSA,
                            &coldef,
                            sizeof(coldef),
                            0);
    dsaid = coldef.columnid;

    /* Get DSA installation state column ID */

    JetGetTableColumnInfoEx(pDBhidden->JetSessID,
                            HiddenTblid,
                            SZDSSTATE,
                            &coldef,
                            sizeof(coldef),
                            0);
    dsstateid = coldef.columnid;

    /* Get DSA additional state info column ID */

    err = JetGetTableColumnInfo(pDBhidden->JetSessID,
                            HiddenTblid,
                            SZDSFLAGS,
                            &coldef,
                            sizeof(coldef),
                            0);

    if (err == JET_errColumnNotFound) {

        JET_COLUMNDEF  newcoldef;
        PCREATE_COLUMN_PARAMS pColumn;

        ZeroMemory( &newcoldef, sizeof(newcoldef) );
        newcoldef.cbStruct = sizeof( JET_COLUMNDEF );
        newcoldef.coltyp = JET_coltypBinary;
        newcoldef.grbit = JET_bitColumnFixed;
        newcoldef.cbMax = 200;

        err = JetAddColumn(
            pDBhidden->JetSessID,
            HiddenTblid,
            SZDSFLAGS,
            &newcoldef,
            NULL,
            0,
            &(coldef.columnid) );

        if (err) {
            DPRINT1 (0, "Error adding column to hidden table: %d\n", err);
            LogUnhandledError(err);
            return err;
        }
        else {
            DPRINT (0, "Succesfully created new column\n");
        }
    }
    else if (err) {
        DPRINT1 (0, "Error %d reading column\n", err);
        LogUnhandledError(err);
        return err;
    }

    dsflagsid = coldef.columnid;

    DPRINT(2,"dbCreateHiddenDBPOS done\n");
    return 0;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Close the hidden record's DBPOS
*/
extern USHORT APIENTRY
dbCloseHiddenDBPOS(void)
{
    JET_SESID sesid;
    JET_DBID  dbid;

    if(!pDBhidden)
        return 0;

    dbGrabHiddenDBPOS(pTHStls);

    DPRINT(2,"dbCloseHiddenDBPOS\n");
    DPRINT1(4,"Exit count closehidden %x\n",pDBhidden->transincount);
    sesid = pDBhidden->JetSessID;
    dbid = pDBhidden->JetDBID;

    /* normally, we do a DBFree(pDBhidden) to kill a pDB, but since
     * the hidden pDB is NOT allocated on the pTHStls heap, and is instead
     * allocated using malloc, we simply do a free(pDBhidden);
     */
    free(pDBhidden);

#if DBG
    dbEndDBPOS (pDBhidden);
    dbCheckJet(sesid);
#endif

    pDBhidden = NULL;
    dbReleaseHiddenDBPOS(NULL);

    // JET_bitDbForceClose not supported in Jet600.
    JetCloseDatabaseEx(sesid, dbid, 0);
    DPRINT2(2, "dbCloseHiddenDBPOS - JetCloseDatabase. Session = %d. Dbid = %d.\n",
            sesid, dbid);

    JetEndSessionEx(sesid, JET_bitForceSessionClosed);
    DBEndSess(sesid);

    return 0;
}

/*
 * Every other DBPOS in the system is managed by DBOpen, which sets and
 * clears the thread id appropriately.  For the hidden DBPOS, we must do
 * this manually at each use, hence these routines.
 */

DBPOS *
dbGrabHiddenDBPOS(THSTATE *pTHS)
{
    EnterCriticalSection(&csHiddenDBPOS);
    Assert(pDBhidden->pTHS == NULL);
    pDBhidden->pTHS = pTHS;
    return pDBhidden;
}

void
dbReleaseHiddenDBPOS(DBPOS *pDB)
{
    Assert(pDB == pDBhidden);
    Assert(!pDB || (pDB->pTHS == pTHStls));
    if(pDB) {
        pDB->pTHS = NULL;
    }
    LeaveCriticalSection(&csHiddenDBPOS);
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Replace the hidden record.  Use the pDBhidden handle
   read the record and update it.
*/
ULONG
DBReplaceHiddenDSA(DSNAME *pDSA)
{
    JET_ERR err;
    long update;
    BOOL fCommit = FALSE;
    ULONG tag = 0;
    DBPOS *pDB = dbGrabHiddenDBPOS(pTHStls);

    __try {
        DBTransIn(pDB);
        __try
        {
            if (pDSA) {
                err = sbTableGetTagFromDSName(pDB, pDSA, 0, &tag, NULL);
                if (err) {
                    LogUnhandledError(err);
                    return err;
                }
            }

            /* Move to first (only) record in table */
            update = DS_JET_PREPARE_FOR_REPLACE;

            if (err = JetMoveEx(pDB->JetSessID,
                                HiddenTblid,
                                JET_MoveFirst,
                                0)) {
                update = JET_prepInsert;
            }

            JetPrepareUpdateEx(pDB->JetSessID, HiddenTblid, update);

            JetSetColumnEx(pDB->JetSessID, HiddenTblid, dsaid, &tag,
                           sizeof(tag), 0, NULL);

            JetUpdateEx(pDB->JetSessID, HiddenTblid, NULL, 0, NULL);
            fCommit = TRUE;
        }
        _finally
        {
            DBTransOut(pDB, fCommit, FALSE);
        }
    }
    _finally
    {
        dbReleaseHiddenDBPOS(pDB);
    }

    return 0;

}  /*DBReplaceHiddenDSA*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Replace the hidden record.  Use the pDBhidden handle
   read the record and update it.
*/
ULONG
DBReplaceHiddenUSN(USN usnInit)
{
    JET_ERR err;
    long update;
    BOOL fCommit = FALSE;
    DBPOS *pDB = dbGrabHiddenDBPOS(pTHStls);

    __try
    {
        DBTransIn(pDB);
        __try
        {
            /* Move to first (only) record in table */
            update = DS_JET_PREPARE_FOR_REPLACE;

            if (err = JetMoveEx(pDB->JetSessID, HiddenTblid, JET_MoveFirst, 0))
            {
                update = JET_prepInsert;
            }

            JetPrepareUpdateEx(pDB->JetSessID, HiddenTblid, update);

            JetSetColumnEx(pDB->JetSessID, HiddenTblid, usnid,
                           &usnInit, sizeof(usnInit), 0, NULL);

            JetUpdateEx(pDB->JetSessID, HiddenTblid, NULL, 0, NULL);
            fCommit = TRUE;
        }
        _finally
        {
            DBTransOut(pDB, fCommit, FALSE);
        }
    }
    _finally
    {
        dbReleaseHiddenDBPOS(pDB);
    }


    return 0;

}  /*DBReplaceHiddenUSN*/


/*-------------------------------------------------------------------------*/
/* Set State Info  */

ULONG DBSetHiddenState(DITSTATE State)
{
    JET_ERR err;
    long update;
    BOOL fCommit = FALSE;
    DBPOS *pDB = dbGrabHiddenDBPOS(pTHStls);

    __try {
        __try {
            DBTransIn(pDB);
            __try {
                /* Move to first (only) record in table */
                update = DS_JET_PREPARE_FOR_REPLACE;

                if (err = JetMoveEx(pDB->JetSessID,
                                    HiddenTblid,
                                    JET_MoveFirst,
                                    0)) {
                    update = JET_prepInsert;
                }

                JetPrepareUpdateEx(pDB->JetSessID, HiddenTblid, update);

                JetSetColumnEx(pDB->JetSessID, HiddenTblid, dsstateid,
                               &State, sizeof(State), 0, NULL);

                JetUpdateEx(pDB->JetSessID, HiddenTblid, NULL, 0, NULL);
                fCommit = TRUE;
                err = 0;
            }
            _finally {
                DBTransOut(pDB, fCommit, FALSE);
            }
        } __except (HandleMostExceptions(GetExceptionCode())) {
            /* Do nothing, but at least don't die */
            err = DB_ERR_EXCEPTION;
        }
    }
    _finally {
        dbReleaseHiddenDBPOS(pDB);
    }

    return err;

}

ULONG dbGetHiddenFlags(CHAR *pFlags, DWORD flagslen)
{
    JET_ERR             err = 0;
    ULONG               actuallen;
    BOOL                fCommit = FALSE;
    DBPOS *pDB = dbGrabHiddenDBPOS(pTHStls);

    __try {
        __try {
            DBTransIn(pDB);
            __try {
                *pFlags = '\0';          /* In case of error */

                /* Move to first (only) record in table */

                if ((err = JetMoveEx(pDB->JetSessID,
                                     HiddenTblid,
                                     JET_MoveFirst,
                                     0)) != JET_errSuccess) {
                    DsaExcept(DSA_DB_EXCEPTION, err, 0);
                }

                /* Retrieve state */

                JetRetrieveColumnSuccess(pDB->JetSessID,
                                         HiddenTblid,
                                         dsflagsid,
                                         pFlags,
                                         flagslen,
                                         &actuallen,
                                         0,
                                         NULL);

                fCommit = TRUE;
            }
            __finally {
                Assert(0 == err);
                DBTransOut(pDB, fCommit, FALSE);
            }
        }
        __except (HandleMostExceptions(GetExceptionCode())) {
            if (0 == err)
              err = DB_ERR_EXCEPTION;
        }
    }
    __finally {
        dbReleaseHiddenDBPOS(pDB);
    }

    return err;
}

ULONG DBUpdateHiddenFlags() {
    return dbSetHiddenFlags((CHAR*)&gdbFlags, sizeof(gdbFlags));
}

ULONG dbSetHiddenFlags(CHAR *pFlags, DWORD flagslen)
{
    JET_ERR err;
    long update;
    BOOL fCommit = FALSE;
    DBPOS *pDB = dbGrabHiddenDBPOS(pTHStls);

    __try {
        __try {
            DBTransIn(pDB);
            __try {
                /* Move to first (only) record in table */
                update = DS_JET_PREPARE_FOR_REPLACE;

                if (err = JetMoveEx(pDB->JetSessID,
                                    HiddenTblid,
                                    JET_MoveFirst,
                                    0)) {
                    update = JET_prepInsert;
                }

                JetPrepareUpdateEx(pDB->JetSessID, HiddenTblid, update);

                JetSetColumnEx(pDB->JetSessID, HiddenTblid, dsflagsid,
                               pFlags, flagslen, 0, NULL);

                JetUpdateEx(pDB->JetSessID, HiddenTblid, NULL, 0, NULL);
                fCommit = TRUE;
                err = 0;
            }
            _finally {
                DBTransOut(pDB, fCommit, FALSE);
            }
        } __except (HandleMostExceptions(GetExceptionCode())) {
            /* Do nothing, but at least don't die */
            err = DB_ERR_EXCEPTION;
        }
    }
    _finally {
        dbReleaseHiddenDBPOS(pDB);
    }

    return err;
}

ULONG DBGetHiddenState(DITSTATE* pState)
{

    JET_ERR             err = 0;
    ULONG               actuallen;
    BOOL                fCommit = FALSE;
    DBPOS *pDB = dbGrabHiddenDBPOS(pTHStls);

    __try {
        __try {
            DBTransIn(pDB);
            __try {
                *pState = eErrorDit;    /* In case of error */

                /* Move to first (only) record in table */

                if ((err = JetMoveEx(pDB->JetSessID,
                                     HiddenTblid,
                                     JET_MoveFirst,
                                     0)) != JET_errSuccess) {
                    DsaExcept(DSA_DB_EXCEPTION, err, 0);
                }

                /* Retrieve state */

                JetRetrieveColumnSuccess(pDB->JetSessID,
                                         HiddenTblid,
                                         dsstateid,
                                         pState,
                                         sizeof(*pState),
                                         &actuallen,
                                         0,
                                         NULL);

                fCommit = TRUE;
            }
            __finally {
                Assert(0 == err);
                DBTransOut(pDB, fCommit, FALSE);
            }
        }
        __except (HandleMostExceptions(GetExceptionCode())) {
            if (0 == err)
              err = DB_ERR_EXCEPTION;
        }
    }
    __finally {
        dbReleaseHiddenDBPOS(pDB);
    }

    return err;
}




/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Retrieves the hidden DSA name.  Allocates memory for DSA name and
   sets user's pointer to it.
*/
extern USHORT APIENTRY DBGetHiddenRec(DSNAME **ppDSA, USN *pusnInit){

    JET_ERR             err;
    ULONG               actuallen;
    DSNAME              *pHR;
    BOOL                fCommit = FALSE;
    ULONG               tag;
    DBPOS *pDB = dbGrabHiddenDBPOS(pTHStls);

    __try {
        DBTransIn(pDB);
        __try {
            *pusnInit = 0L;    /* incase of error or no XTRA return 0 usnInit */

            /* Move to first (only) record in table */

            if ((err = JetMoveEx(pDB->JetSessID,
                                 HiddenTblid,
                                 JET_MoveFirst,
                                 0)) != JET_errSuccess) {
                DsaExcept(DSA_DB_EXCEPTION, err, 0);
            }

            /* Retrieve DSA name */

            JetRetrieveColumnSuccess(pDB->JetSessID, HiddenTblid, dsaid,
                                     &tag, sizeof(tag), &actuallen, 0, NULL);
            Assert(actuallen == sizeof(tag));

            err = sbTableGetDSName(pDB, tag, &pHR,0);
            if (err) {
                // uh, oh
                LogUnhandledError(err);
            }

            /* Allocate space to hold the name-address on the permanent heap*/

            if (!(*ppDSA = malloc(pHR->structLen)))
            {
                DsaExcept(DSA_MEM_EXCEPTION, 0, 0);
            }
            memcpy(*ppDSA, pHR, pHR->structLen);
            THFree(pHR);

            /* Retrieve USN */

            JetRetrieveColumnSuccess(pDB->JetSessID, HiddenTblid, usnid,
                pusnInit, sizeof(*pusnInit), &actuallen, 0, NULL);

            fCommit = TRUE;
        }
        __finally
        {
            DBTransOut(pDB, fCommit, FALSE);
        }
    }
    __finally
    {
        dbReleaseHiddenDBPOS(pDB);
    }

    return 0;
}/*GetHiddenRec*/


/*++ DBRecreateFixedIndices
 *
 * This is one of the three routines in the DS that can create indices.
 * Most general purpose indices over single columns in the datatable are created
 * and destroyed by the schema cache by means of DB{Add|Del}ColIndex.
 * Localized indices over a small fixed set of columns and a variable set
 * of languages, for use in tabling support for NSPI clients, are handled
 * in dbCreateLocalizedIndices.  Lastly, a small fixed set of indices that
 * should always be present are guaranteed by DBRecreateFixedIndices.
 *
 * Why do we need code to maintain a fixed set of indices?
 * Since NT upgrades can change the definition of sort orders, they can
 * also invalidate existing JET indices, which are built on the premise
 * that the results of a comparison of two constant values will not change
 * over time.  Therefore JET responds to NT upgrades by deleting indices
 * at attach time that could have been corrupted by an NT upgrade since
 * the previous attach.  The schema cache will automatically recreate any
 * indices indicated in the schema, and other code will handle creating
 * localized indices, because we expect these sets of indices to change
 * over time.  However, we have some basic indices that the DSA uses to
 * hold the world together that we don't ever expect to go away.  This
 * routine is used to recreate all those indices, based from a hard-coded
 * list.
 *
 * So what indices should be listed here and what can be listed in
 * schema.ini?  The short answer is that the DNT index should stay in
 * schema.ini, and that any index involving any Unicode column *must*
 * be listed here.  Anything else is left to user discretion.
 */

// New columns in the data table
CREATE_COLUMN_PARAMS rgCreateDataColumns[] = {
    // Create object cleanup indicator column
    { SZCLEAN, &cleanid, JET_coltypUnsignedByte, JET_bitColumnTagged, 0, NULL, 0 },
    0
};

// A note on index design. There are two ways to accomplish conditional
// membership in an index.
// One is used when the trigger for filtering is an optional attribute
// being null. In that case, include the attribute in the index, and use
// the flag IgnoreAnyNull.  For example, see isABVisible and isCritical
// in below indexes for examples of indicator columns.
// The other is used when the trigger for filtering is an attribute being
// non-null. In that case, use a conditional column.  See the example of
// deltime as a indicator for the link indexes.  An additional note, I haven't
// had any luck using conditional columns for a tagged attribute, but
// maybe I was missing something.

char rgchRdnKey[] = "+" SZRDNATT "\0";
char rgchPdntKey[] = "+" SZPDNT "\0+" SZRDNATT "\0";
char rgchAccNameKey[] = "+" SZNCDNT "\0+" SZACCTYPE "\0+" SZACCNAME "\0";
char rgchDntDelKey[] = "+" SZDNT "\0+" SZISDELETED "\0";
char rgchDntCleanKey[] = "+" SZDNT "\0+" SZCLEAN "\0";
char rgchDraUsnCriticalKey[] = "+" SZNCDNT "\0+" SZUSNCHANGED "\0+" SZISCRITICAL "\0+" SZDNT "\0";
char rgchDraNcGuidKey[] = "+" SZNCDNT "\0+" SZGUID "\0";

CreateIndexParams FixedIndices[] = {

    // Create SZRDNINDEX
    {SZRDNINDEX, rgchRdnKey, sizeof(rgchRdnKey), 0, 90, &idxRdn, NULL},

    // Create SZPDNTINDEX
    {SZPDNTINDEX, rgchPdntKey, sizeof(rgchPdntKey),
       JET_bitIndexIgnoreNull | JET_bitIndexUnique, 90, &idxPdnt, NULL},

    // Create SZ_NC_ACCTYPE_NAME_INDEX
    {SZ_NC_ACCTYPE_NAME_INDEX, rgchAccNameKey, sizeof(rgchAccNameKey),
     JET_bitIndexIgnoreNull | JET_bitIndexIgnoreAnyNull,
     90, &idxNcAccTypeName, NULL},

    // Create SZDNTDELINDEX
    // Note that this is different from SZDELINDEX!
    // Also note that it is by design that IgnoreNull is not set on this
    // index. The fast path lookup code in dbsyntax.c uses this index
    // to look up DNTs for both deleted and non-deleted objects.
    {SZDNTDELINDEX, rgchDntDelKey, sizeof(rgchDntDelKey),
     0, 90, &idxDntDel, NULL},

    // Create new DRA USN CRITICAL index
    { SZDRAUSNCRITICALINDEX,
      rgchDraUsnCriticalKey, sizeof( rgchDraUsnCriticalKey ),
      JET_bitIndexIgnoreNull | JET_bitIndexIgnoreAnyNull,
      98, &idxDraUsnCritical, NULL },

    // Create new SZDNTCLEANINDEX
    {SZDNTCLEANINDEX, rgchDntCleanKey, sizeof(rgchDntCleanKey),
     JET_bitIndexIgnoreAnyNull,
     90, &idxDntClean, NULL},

    // Create new SZNCGUIDINDEX
     {SZNCGUIDINDEX, rgchDraNcGuidKey, sizeof(rgchDraNcGuidKey),
	 JET_bitIndexIgnoreAnyNull,
	 90, &idxNcGuid, NULL},

    0
};
DWORD cFixedIndices = sizeof(FixedIndices) / sizeof(FixedIndices[0]);


int DBRecreateFixedIndices(JET_SESID sesid, JET_DBID dbid)
{
    THSTATE          *pTHS = pTHStls;
    ULONG            i = 0, cb;
    ULONG            cIndexCreate = 0, cUnicodeIndexData = 0;
    JET_TABLEID      tblid;
    JET_INDEXCREATE  *pIndexCreate, *pTempIC;
    JET_UNICODEINDEX *pUnicodeIndexData, *pTempUID;
    JET_ERR          err = 0;

    char             szColname[16];
    char             szIndexName[MAX_INDEX_NAME];
    BYTE             rgbIndexDef[128];
    char             szPDNTIndexName[MAX_INDEX_NAME];
    BYTE             rgbPDNTIndexDef[128];
    ULONG            cbPDNT;
    BYTE             *pb;
    ATTRTYP          aid;
    unsigned         syntax;
    HANDLE           hevUI;


    err = JetOpenTable(sesid, dbid, SZDATATABLE, NULL, 0, JET_bitTableDenyRead, &tblid);
    if (err) {
        LogUnhandledError(err);
        return err;
    }

    // Expand data table at runtime if necessary
    if (err = dbCreateNewColumns( sesid,
                                tblid,
                                rgCreateDataColumns )) {
        // Error already logged
        return err;
    }

    // Allocate space for JET_INDEXCREATE/JET_UNICODEINDEX structures
    // There can be at most two indices created per attribute in
    // IndicesToKeep Table, plus the fixed indices

    pIndexCreate = THAllocEx(pTHS, (2*cIndicesToKeep + cFixedIndices)*sizeof(JET_INDEXCREATE));
    pUnicodeIndexData = THAllocEx(pTHS, (2*cIndicesToKeep + cFixedIndices)*sizeof(JET_UNICODEINDEX));


    // first fill up the structures for the FixedIndices

    while (FixedIndices[i].szIndexName) {
        if (err = JetSetCurrentIndex(sesid,
                                     tblid,
                                     FixedIndices[i].szIndexName)) {
           DPRINT2(0,"Need an index %s (%d)\n", FixedIndices[i].szIndexName, err);

            pTempIC = &(pIndexCreate[cIndexCreate++]);
            memset(pTempIC, 0, sizeof(JET_INDEXCREATE));
            pTempIC->cbStruct = sizeof(JET_INDEXCREATE);
            pTempIC->szIndexName = FixedIndices[i].szIndexName;
            pTempIC->szKey = FixedIndices[i].szIndexKeys;
            pTempIC->cbKey = FixedIndices[i].cbIndexKeys;
            pTempIC->grbit = (FixedIndices[i].ulFlags |
                                 JET_bitIndexUnicode           );
            pTempIC->ulDensity = FixedIndices[i].ulDensity;
            if (FixedIndices[i].pConditionalColumn) {
                pTempIC->rgconditionalcolumn = FixedIndices[i].pConditionalColumn;
                pTempIC->cConditionalColumn = 1;
            }
            pTempUID = &(pUnicodeIndexData[cUnicodeIndexData++]);
            pTempIC->pidxunicode = pTempUID;

            memset(pTempUID, 0, sizeof(JET_UNICODEINDEX));
            pTempUID->lcid = DS_DEFAULT_LOCALE;
            pTempUID->dwMapFlags = (DS_DEFAULT_LOCALE_COMPARE_FLAGS |
                                           LCMAP_SORTKEY);

        }
        i++;
    }


    // ok, now check for the indices in IndicesToKeep Table, and
    // create them if necessary. Do not check the last entry in the table,
    // it is just a sentinel for searches

    for (i=0; i<cIndicesToKeep - 1; i++) {
        aid = IndicesToKeep[i].attrType;
        syntax = IndicesToKeep[i].syntax;
        sprintf(szColname, "ATTa%d", aid);
        szColname[3] += (CHAR)syntax;
        if (IndicesToKeep[i].indexType & fATTINDEX) {
             sprintf(szIndexName, SZATTINDEXPREFIX"%08X", aid);
             if (err = JetSetCurrentIndex(sesid,
                                          tblid,
                                          szIndexName)) {
                   DPRINT2(0,"Need an index %s (%d)\n", szIndexName, err);
                   memset(rgbIndexDef, 0, sizeof(rgbIndexDef));
                   strcpy(rgbIndexDef, "+");
                   strcat(rgbIndexDef, szColname);
                   cb = strlen(rgbIndexDef) + 1;
                   if (syntax_jet[syntax].ulIndexType == IndexTypeAppendDNT) {
                       pb = rgbIndexDef + cb;
                       strcpy(pb, "+");
                       strcat(pb, SZDNT);
                       cb += strlen(pb) + 1;
                   }
                   cb +=1;
                   pTempIC = &(pIndexCreate[cIndexCreate++]);
                   memset(pTempIC, 0, sizeof(JET_INDEXCREATE));
                   pTempIC->cbStruct = sizeof(JET_INDEXCREATE);
                   pTempIC->szIndexName = THAllocEx(pTHS, strlen(szIndexName)+1);
                   memcpy(pTempIC->szIndexName, szIndexName, strlen(szIndexName)+1);
                   pTempIC->szKey = THAllocEx(pTHS, cb);
                   memcpy(pTempIC->szKey, rgbIndexDef, cb);
                   pTempIC->cbKey = cb;
                   pTempIC->grbit = JET_bitIndexIgnoreAnyNull;
                   pTempIC->ulDensity = GENERIC_INDEX_DENSITY;
                   if(syntax != SYNTAX_UNICODE_TYPE) {
                        pTempIC->lcid = DS_DEFAULT_LOCALE;
                   }
                   else {
                        pTempUID =  &(pUnicodeIndexData[cUnicodeIndexData++]);
                        pTempIC->pidxunicode = pTempUID;
                        pTempIC->grbit |= JET_bitIndexUnicode;

                        memset(pTempUID, 0,
                               sizeof(JET_UNICODEINDEX));
                        pTempUID->lcid = DS_DEFAULT_LOCALE;
                        pTempUID->dwMapFlags =
                            (DS_DEFAULT_LOCALE_COMPARE_FLAGS | LCMAP_SORTKEY);
                   }
            }
       }

       // Now the PDNT indexes, now a dummy since no att in IndicesToKeep
       // needs a PDNT index, but just in case someone adds some

       if (IndicesToKeep[i].indexType & fPDNTATTINDEX) {
            PCHAR pTemp = rgbPDNTIndexDef;

            sprintf(szPDNTIndexName, SZATTINDEXPREFIX"P_%08X", aid);
            if (err = JetSetCurrentIndex(sesid,
                                         tblid,
                                         szPDNTIndexName)) {
                   DPRINT2(0,"Need an index %s (%d)\n", szPDNTIndexName, err);
                   memset(rgbPDNTIndexDef, 0, sizeof(rgbPDNTIndexDef));
                   strcpy(pTemp, "+");
                   strcat(pTemp, SZPDNT);
                   cbPDNT = strlen(pTemp) + 1;
                   pTemp = &rgbPDNTIndexDef[cbPDNT];
                   strcpy(pTemp, "+");
                   strcat(pTemp, szColname);
                   cbPDNT += strlen(pTemp) + 1;
                   pTemp = &rgbPDNTIndexDef[cbPDNT];
                   if (syntax_jet[syntax].ulIndexType == IndexTypeAppendDNT) {
                       strcpy(pTemp, "+");
                       strcat(pTemp, SZDNT);
                       cbPDNT += strlen(pTemp) + 1;
                   }
                   cbPDNT++;
                   pTempIC = &(pIndexCreate[cIndexCreate++]);
                   memset(pTempIC, 0, sizeof(JET_INDEXCREATE));
                   pTempIC->cbStruct = sizeof(JET_INDEXCREATE);
                   pTempIC->szIndexName = THAllocEx(pTHS, strlen(szPDNTIndexName)+1);
                   memcpy(pTempIC->szIndexName, szPDNTIndexName, strlen(szPDNTIndexName)+1);
                   pTempIC->szKey = THAllocEx(pTHS, cbPDNT);
                   memcpy(pTempIC->szKey, rgbPDNTIndexDef, cbPDNT);
                   pTempIC->cbKey = cbPDNT;
                   pTempIC->grbit = JET_bitIndexIgnoreAnyNull;
                   pTempIC->ulDensity = GENERIC_INDEX_DENSITY;
                   if(syntax != SYNTAX_UNICODE_TYPE) {
                       pTempIC->lcid = DS_DEFAULT_LOCALE;
                   }
                   else {
                       pTempUID =  &(pUnicodeIndexData[cUnicodeIndexData++]);
                       pTempIC->grbit |= JET_bitIndexUnicode;
                       pTempIC->pidxunicode = pTempUID;

                       memset(pTempUID, 0,
                              sizeof(JET_UNICODEINDEX));
                       pTempUID->lcid = DS_DEFAULT_LOCALE;
                       pTempUID->dwMapFlags =
                              (DS_DEFAULT_LOCALE_COMPARE_FLAGS | LCMAP_SORTKEY);
                   }
           }
       }
    } /* for */

    // Now actually create the indices.
    // Indices need to be created in batches of MAX_NO_OF_INDICES_IN_BATCH,
    // the max that JetCreateIndex2 can handle now

    // Emit debugger message so people know why startup is slow.
    DPRINT(0, "Recreating Necessary Indices...\n");

    // This event is used to let Winlogon put up UI, so that the screen
    // isn't just blank during the potentially hours long index rebuild.
    hevUI = CreateEvent(NULL,
                        TRUE,
                        FALSE,
                        "NTDS.IndexRecreateEvent");

    err = dbCreateIndexBatch( sesid, tblid, cIndexCreate, pIndexCreate );
    if (err) {
        goto abort;
    }

    // Gather index hint for fixed indices
    i = 0;
    while (FixedIndices[i].szIndexName) {
        JetGetTableIndexInfo(sesid,
                             tblid,
                             FixedIndices[i].szIndexName,
                             FixedIndices[i].pidx,
                             sizeof(JET_INDEXID),
                             JET_IdxInfoIndexId);
        ++i;
    }

abort:
    JetCloseTable(sesid, tblid);

    if (hevUI) {
        SetEvent(hevUI);
        CloseHandle(hevUI);
    }

    // free whatever we can without going into too much trouble

    THFreeEx(pTHS, pIndexCreate);
    THFreeEx(pTHS, pUnicodeIndexData);

    return err;
}



void
DBSetDatabaseSystemParameters(JET_INSTANCE *jInstance, unsigned fInitAdvice)
{
    ULONG cSystemThreads = 4;   // permanent server threads. Task queue etc.
    ULONG cServerThreads = 50;
    ULONG ulMaxSessionPerThread = 3;
    ULONG ulMinBuffers;
    ULONG ulMaxBuffers;
    ULONG ulMaxLogBuffers;
    ULONG ulLogFlushThreshold;
    ULONG ulMaxTables;
    ULONG ulSpareBuckets = 100; // bucket in addition to 2 per thread
    ULONG ulStartBufferThreshold;
    ULONG ulStopBufferThreshold;
    ULONG ulLogFlushPeriod;
    ULONG ulPageSize = JET_PAGE_SIZE;               // jet page size

    JET_SESID sessid = (JET_SESID) 0;
    MEMORYSTATUSEX mstat;
    const DWORDLONG ull16Meg = 16*1024*1024;
    const DWORDLONG ull100Meg = 100*1024*1024;
    const DWORDLONG ull500Meg = 512*1024*1024;
    const DWORDLONG ull2Gig = 2i64 * 1024i64 * 1024i64 * 1024i64;
    DWORDLONG ullTmp, ullTmp2;
    SYSTEM_INFO sysinfo;
    DWORD i;

    const ULONG ulLogFileSize = JET_LOG_FILE_SIZE;  // Never, ever, change this.
    // As of now (1/18/99), Jet cannot handle a change in log file size
    // on an installed system.  That is, you could create an entirely new
    // database with any log file size you want, but if you ever change
    // it later then Jet will AV during initialization.  We used to let
    // people set the log file size via a registry key, but apparently no one
    // ever did, as when we finally tried it it blew up.  We've now chosen
    // a good default file size (10M), and we're stuck with it forever,
    // as no installed server can ever choose a different value, unless
    // JET changes logging mechanisms.

    /*
     * By default, tell Jet to use up to all but 16M of RAM in the machine
     * for buffers, and to not let its buffer usage fall below 2% of that
     * (a separate check below tests for an undersized min buffer).
     * Given that we're inside of an overpopulated process in a single
     * 2GB address space, don't allow Jet to consume more than 1G (2G
     * on EE, where total VA is 3G) lest we run out of VA again.
     * dwTotalPhys is in bytes, ulMaxBuffers is a count of page-sized
     * buffers, hence the division by ulPageSize.
     */

    GetSystemInfo(&sysinfo);

    ulMaxBuffers = 0;
    mstat.dwLength = sizeof(mstat);
    GlobalMemoryStatusEx(&mstat);
    ullTmp = mstat.ullTotalPhys;
    if ( ullTmp > ull16Meg ) {
        ullTmp -= ull16Meg;         // get memory over 16M
        if ( ullTmp > ull500Meg ) {
            // Uh-oh.  We're on a really big memory machine, where allocating
            // all of RAM could exhaust virtual address space.  If this is
            // a standard VM system (user VM <= 2G) then we'll cap our usage
            // at 500M.  If VM is greater, then we'll additionally allow half
            // of the extra VM, up to the RAM of the machine.
            // Note that we don't look at ullTotalVirtual, but rather at
            // ullAvailVirtual.  It turns out that on systems running with
            // 3G user address spaces all processes are proclaimed to have
            // 3G TotalVirtual, but the loader may silently render 1G of that
            // unavailable to the application if your exe header is not
            // satisfactory.
            if (mstat.ullTotalVirtual <= ull2Gig) {
                // Limit buffers to 500M since process address space is only 2G
                ullTmp = ull500Meg;
            }
            else {
                ullTmp2 = ull500Meg + ((mstat.ullTotalVirtual - ull2Gig) / 2);
                if (ullTmp2 < ullTmp) {
                    ullTmp = ullTmp2;
                }
            }
        }
        ullTmp /= ulPageSize;       // convert to page count

        // We know this fits in a DWORD now - so assign.
        Assert(ullTmp <= 0xffffffff);
        ulMaxBuffers = (ULONG) ullTmp;
    }
    Assert(ulMaxBuffers > 500);
    ulMinBuffers = ulMaxBuffers / 50;

    // Set required common database system parameters first
    //
    DBSetRequiredDatabaseSystemParameters (jInstance);

    // Have Jet log to the Directory Service log using a source value
    // defined by the DS.

    for ( i = 0; i < cEventSourceMappings; i++ )
    {
        if ( DIRNO_ISAM == rEventSourceMappings[i].dirNo )
        {
            JetSetSystemParameter(
                            &jetInstance,
                            sessid,
                            JET_paramEventSourceKey,
                            0,
                            rEventSourceMappings[i].pszEventSource);
            break;
        }
    }

    // Assert we found DIRNO_ISAM and registered it.
    Assert(i < cEventSourceMappings);



    // the setting of the following Jet Parameters is
    // done in DBSetRequiredDatabaseSystemParameters

    // 1. Set the default info for unicode indices
    // 2. Ask for 8K pages.
    // 3. Indicate that Jet may nuke old, incompatible log files
    //   if and only if there was a clean shut down.
    // 4. Tell Jet that it's ok for it to check for (and later delete) indices
    //   that have been corrupted by NT upgrades.
    // 5. Get relevant DSA registry parameters
    // 6. how to die
    // 7. event logging parameters
    // 8. log file size
    // 9. circular logging


    // maximum RPC threads for client calls
    if (GetConfigParam(
            SERVER_THREADS_KEY,
            &cServerThreads,
            sizeof(cServerThreads)))
    {
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_BASIC,
            DIRLOG_CANT_FIND_REG_PARM,
            szInsertSz(SERVER_THREADS_KEY),
            NULL,
            NULL);
    }

    /* Set up global session limit, based on the number of threads */
    gcMaxJetSessions = ulMaxSessionPerThread *
      (
       cServerThreads                     // max RPC threads
       + cSystemThreads                   // internal worker threads
       + 4 * sysinfo.dwNumberOfProcessors // max LDAP threads
       );


    // Max Sessions (i.e., DBPOSes)
    JetSetSystemParameter(&jetInstance,
        sessid,
        JET_paramMaxSessions,
        gcMaxJetSessions,
        NULL);


    //  max buffers
    if (GetConfigParam(
            MAX_BUFFERS,
            &ulMaxBuffers,
            sizeof(ulMaxBuffers)))
    {
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_BASIC,
            DIRLOG_CANT_FIND_REG_PARM_DEFAULT,
            szInsertSz(MAX_BUFFERS),
            szInsertUL(ulMaxBuffers),
            NULL);
    }
    else {
        // If the user specifies a max buffer size, make sure that it's
        // at least as large as the minBuffers setting.
        ulMaxBuffers = max(ulMinBuffers, ulMaxBuffers);
    }

    // 10-9-98 From AndyGo: The minimum acceptable number of buffers is
    // four times the number of sessions
    ulMinBuffers = max(ulMinBuffers, 4*gcMaxJetSessions);
    ulMaxBuffers = max(ulMaxBuffers, 4*gcMaxJetSessions);

    JetSetSystemParameter(&jetInstance,
                          sessid,
                          JET_paramCacheSizeMax,
                          ulMaxBuffers,
                          NULL);

    JetSetSystemParameter(&jetInstance,
                          sessid,
                          JET_paramCacheSizeMin,
                          ulMinBuffers,
                          NULL);

    //  max log buffers
    if (GetConfigParam(
            MAX_LOG_BUFFERS,
            &ulMaxLogBuffers,
            sizeof(ulMaxLogBuffers)))
    {
        // From AndyGo, 7/14/98: "Set to maximum desired log cache memory/512b
        // This number should be at least 256 on a large system.  This should
        // be set high engouh so that the performance counter .Database /
        // Log Record Stalls / sec. is almost always 0."
        // DS: we use the larger of 256 (== 128kb) or (0.1% of RAM * # procs),
        // on the theory that the more processors, the faster we can make
        // updates and hence burn through log files.
        ulMaxLogBuffers = max(256,
                              (sysinfo.dwNumberOfProcessors *
                               (ULONG)(mstat.ullTotalPhys / (512*1024))));
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_VERBOSE,
            DIRLOG_CANT_FIND_REG_PARM_DEFAULT,
            szInsertSz(MAX_LOG_BUFFERS),
            szInsertUL(ulMaxLogBuffers),
            NULL);
    }
    // Note that the log buffer size must be ten sectors less than the log
    // file size, with the added wart that size is in kb, and buffers is
    // in 512b sectors.
    ulMaxLogBuffers = min(ulMaxLogBuffers, ulLogFileSize*2 - 10);
    JetSetSystemParameter(&jetInstance,
                          sessid,
                          JET_paramLogBuffers,
                          ulMaxLogBuffers,
                          NULL);


    // Andygo 7/14/98: Set to max( min(256, ulMaxBuffers * 1%), 16), use
    // 10% for very high update rates such as defrag
    // DS: we use 10% for our initial install (dcpromo)
    if (GetConfigParam(
            BUFFER_FLUSH_START,
            &ulStartBufferThreshold,
            sizeof(ulStartBufferThreshold)))
    {
        ulStartBufferThreshold = max(
                                    min(256,
                                        ((fInitAdvice ? 10 : 1) * ulMaxBuffers) / 100
                                        ),
                                    16);
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_VERBOSE,
            DIRLOG_CANT_FIND_REG_PARM_DEFAULT,
            szInsertSz(BUFFER_FLUSH_START),
            szInsertUL(ulStartBufferThreshold),
            NULL);
    }
    JetSetSystemParameter(&jetInstance,
                          sessid,
                          JET_paramStartFlushThreshold,
                          ulStartBufferThreshold,
                          NULL);



    // AndyGo 7/14/98: Set to max( min(512, ulMaxBuffers * 2%), 32), use
    // 20% for very high update rates such as defrag
    // DS: we use 20% for our initial install (dcpromo)
    if (GetConfigParam(
            BUFFER_FLUSH_STOP,
            &ulStopBufferThreshold,
            sizeof(ulStopBufferThreshold)))
    {
        ulStopBufferThreshold = max(
                                    min(512,
                                        ((fInitAdvice ? 20 : 2) * ulMaxBuffers) / 100
                                        ),
                                    32);
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_VERBOSE,
            DIRLOG_CANT_FIND_REG_PARM_DEFAULT,
            szInsertSz(BUFFER_FLUSH_STOP),
            szInsertUL(ulStopBufferThreshold),
            NULL);
    }
    JetSetSystemParameter(&jetInstance,
                          sessid,
                          JET_paramStopFlushThreshold,
                          ulStopBufferThreshold,
                          NULL);


    // max tables - Currently no reason to expose this
    // In Jet600, JET_paramMaxOpenTableIndexes is removed. It is merged with
    // JET_paramMaxOpenTables. So if you used to set JET_paramMaxOpenIndexes
    // to be 2000 and and JET_paramMaxOpenTables to be 1000, then for new Jet,
    // you need to set JET_paramMaxOpenTables to 3000.

    // AndyGo 7/14/98: You need one for each open table index, plus one for
    // each open table with no indexes, plus one for each table with long
    // column data, plus a few more.

    // NOTE: the number of maxTables is calculated in scache.c
    // and stored in the registry setting, only if it exceeds the default
    // number of 500

    if (GetConfigParam(
            DB_MAX_OPEN_TABLES,
            &ulMaxTables,
            sizeof(ulMaxTables)))
    {
        ulMaxTables = 500;

        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
            DS_EVENT_SEV_VERBOSE,
            DIRLOG_CANT_FIND_REG_PARM_DEFAULT,
            szInsertSz(DB_MAX_OPEN_TABLES),
            szInsertUL(ulMaxTables),
            NULL);
    }

    if (ulMaxTables < 500) {
        DPRINT1 (1, "Found MaxTables: %d. Too low. Using Default of 500.\n", ulMaxTables);
        ulMaxTables = 500;
    }

    JetSetSystemParameter(&jetInstance,
        sessid,
        JET_paramMaxOpenTables,
        ulMaxTables * 2,
        NULL);

    // open tables indexes - Currently no reason to expose this
    // See comment on JET_paramMaxOpenTables.

    // Max temporary tables - same as sessions (one per DBPOS)
    JetSetSystemParameter(&jetInstance,
        sessid,
        JET_paramMaxTemporaryTables,
        gcMaxJetSessions,
        NULL);


    // Version buckets.  The units are 16k "buckets", and we get to set
    // two separate values.  The first is our preferred value, and is read
    // from the registry.  JET will try to maintain the pool of buckets at
    // around this level.  The second parameter is the absolute maximum
    // number of buckets which JET will never exceed.  We set that based on
    // the amount of physical memory in the machine (unless the preferred
    // setting was already higher than that!).  This very large value should
    // ensure that no transaction will ever fail because of version store
    // exhaustion.
    //
    // N.B. Jet will try to reserve jet_paramMaxVerPages in contiguous memory
    // causing out of memory problems.  We should only need a maximum of a
    // quarter of the available physical memory.
    //
    // N.B. Version pages are 16K each.

    if (GetConfigParam(SPARE_BUCKETS,
                       &ulSpareBuckets,
                       sizeof(ulSpareBuckets))) {
        LogEvent(DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                 DS_EVENT_SEV_VERBOSE,
                 DIRLOG_CANT_FIND_REG_PARM_DEFAULT,
                 szInsertSz(SPARE_BUCKETS),
                 szInsertUL((2 * gcMaxJetSessions) + ulSpareBuckets),
                 NULL);
    }
    JetSetSystemParameter(&jetInstance,
                          sessid,
                          JET_paramPreferredVerPages,
                          (2 * gcMaxJetSessions) + ulSpareBuckets,
                          NULL);

    ullTmp = mstat.ullTotalPhys;    // total memory in system
    ullTmp /= 4;                    // limit to 1/4 of total memory in system
    if ( ullTmp > ull100Meg ) {
        // Limit version store to 100M since process address space is only 2G.
        ullTmp = ull100Meg;
    }
    // Convert to version store page count.
    ullTmp /= (16*1024);            // N.B. - ullTmp fits in a DWORD now.
    Assert(ullTmp <= 0xffffffff);

    if (ulSpareBuckets < (ULONG) ullTmp) {
        ulSpareBuckets = (ULONG) ullTmp;
    }

    JetSetSystemParameter(&jetInstance,
                          sessid,
                          JET_paramMaxVerPages,
                          (2 * gcMaxJetSessions) + ulSpareBuckets,
                          NULL);

    // From AndyGo 7/14/98: You need one cursor per concurrent B-Tree
    // navigation in the JET API.  Guessing high will only waste address space.
    // DS: Allow 10 per session, which is two per table, one for the
    // table itself and one for any secondary indices used on that table.
    JetSetSystemParameter(&jetInstance,
        sessid,
        JET_paramMaxCursors,
        (gcMaxJetSessions * 10),
        NULL);

    // Set the tuple index parameters.  Have to do this since once an index is
    // created these parameters can't be changed for that index.  Thus changing
    // the minimum tuple length has the potential to cause failures in the future.
    JetSetSystemParameter(&jetInstance,
        sessid,
        JET_paramIndexTuplesLengthMin,
        DB_TUPLES_LEN_MIN,
        NULL);
    JetSetSystemParameter(&jetInstance,
        sessid,
        JET_paramIndexTuplesLengthMax,
        DB_TUPLES_LEN_MAX,
        NULL);
    JetSetSystemParameter(&jetInstance,
        sessid,
        JET_paramIndexTuplesToIndexMax,
        DB_TUPLES_TO_INDEX_MAX,
        NULL);

    //
    // Do event log caching if the event log is not turned on
    // This enables the system to start if the event log has been
    // disabled. The value of the parameter is the size of the cache in bytes.
    #define JET_EVENTLOG_CACHE_SIZE  100000

    JetSetSystemParameter(&jetInstance,
                          sessid,
                          JET_paramEventLogCache,
                          JET_EVENTLOG_CACHE_SIZE,
                          NULL);

    // Disable versioned temp tables.  this makes TTs faster but disables the
    // ability to rollback an insert into a materialized TT
    JetSetSystemParameter(&jetInstance,
        sessid,
        JET_paramEnableTempTableVersioning,
        0,
        NULL );
}/* DBSetDatabaseSystemParameters */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dbindex.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dbindex.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module DBLayer functions to deal with indices.  Functions include thos
    to set indices, seek in indeices, create index ranges, compare position of
    two object in an index, etc.

Author:

    Tim Williams (timwi) 25-Apr-1996

Revision History:
    
--*/
#include <NTDSpch.h>
#pragma  hdrstop

#include <limits.h>

#include <dsjet.h>

#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <dsatools.h>

#include <mdcodes.h>
#include <dsevent.h>

#include <dsexcept.h>
#include "objids.h"	/* Contains hard-coded Att-ids and Class-ids */
#include "debug.h"	/* standard debugging header */
#define DEBSUB     "DBINDEX:"   /* define the subsystem for debugging */

#include "dbintrnl.h"

#include <fileno.h>
#define  FILENO FILENO_DBINDEX


DB_ERR
DBMove (
       DBPOS * pDB,
       BOOL UseSortTable,
       LONG Distance
       )
/*++
  
Routine Description:

    Wrapper around DBMoveEx
    
Arguments:

Return Value:
    
--*/       
{
    return
        DBMoveEx(
            pDB,
            (UseSortTable?pDB->JetSortTbl:pDB->JetObjTbl),
            Distance ); 
}


DB_ERR
DBMoveEx (
       DBPOS * pDB,
       JET_TABLEID Cursor,
       LONG Distance
       )
/*++
  
Routine Description:

    Moves in a data base table.  Currently, this is a very thin wrapper around
    JetMove.
    
Arguments:

    pDB - the DBLayer Postion block to move in.

    Cursor - which table to use
    
    Distance - the distance to move.  Special cases of 0x7fffffff (DB_MoveLast)
    and 0x00000000 (DB_MoveFirst) are used.

Return Value:
    
    0 if no error, an error code otherwise (currently the bare Jet error).
    
--*/       
{
    DWORD cbActual;
    DB_ERR err;
    
    Assert(VALID_DBPOS(pDB));

    if(!Cursor) {
        return DB_ERR_NO_SORT_TABLE;
    }
    
    err = JetMove(pDB->JetSessID,
                  Cursor,
                  Distance,
                  0);
    
    if ( (Cursor == pDB->JetObjTbl) && (err == JET_errSuccess) ) {
        // Get the DNT and PDNT.  
        dbMakeCurrent(pDB, NULL);
    }
    
    return err;
}

DB_ERR
DBMovePartial (
       DBPOS * pDB,
       LONG Distance
       )
/*++
  
Routine Description:

    Moves in a data base table.  Currently, this is a very thin wrapper around
    JetMove. This version does not call dbMakeCurrent. Is mainly used from MAPI.
    
Arguments:

    pDB - the DBLayer Postion block to move in.

    Distance - the distance to move.  Special cases of 0x7fffffff (DB_MoveLast)
    and 0x00000000 (DB_MoveFirst) are used.

Return Value:
    
    0 if no error, an error code otherwise (currently the bare Jet error).
    
--*/       
{
    DB_ERR err;
    
    Assert(VALID_DBPOS(pDB));

    err = JetMove(pDB->JetSessID,
                         pDB->JetObjTbl,
                         Distance,
                         0);
    
    return err;
}

DB_ERR
DBOpenSortTable (
        DBPOS *pDB,
        ULONG SortLocale,
        DWORD flags,
        ATTCACHE *pAC
        )
/*++
  
Routine Description:

    Opens a temporary table to be used for sorting.  The sort order and
    data type to be sorted are specified in flags.
    
Arguments:

    pDB - The DBLayer Postion block to attach this sort table to.

    SortLocale - the Locale that the data is to be sorted in.

    flags - flags describing sort orders.  Legal flags are:
     DB_SORT_DESCENDING -> sort the data in descending order.
     DB_SORT_ASCENDING -> (DEFAULT) sort the data in ascending order.
     DB_SORT_FORWARDONLY -> request a forward only sort (faster)

    pAC - attcache of attribute to sort on. NULL if no sort is necessary

Return Value:
    
    FALSE if table creation failed, the table handle otherwise.
    
--*/       
{
    JET_COLUMNDEF tempTableColumns[2];
    DB_ERR        err;
    JET_GRBIT     grbit;
    DWORD         index;
    
    Assert(VALID_DBPOS(pDB));

    if(pDB->JetSortTbl) {
        // We already have a sort table.  Bail.
        return !0;
    }

    if(pAC) {
        // This is a sort table, not just a list of DNTs
        tempTableColumns[0].cbStruct = sizeof(tempTableColumns[0]);
        tempTableColumns[0].columnid = 0;
        tempTableColumns[0].langid = LANGIDFROMLCID(SortLocale);
        tempTableColumns[0].cp = CP_WINUNICODE;
        tempTableColumns[0].cbMax = 0;
        tempTableColumns[0].grbit = JET_bitColumnFixed | JET_bitColumnTTKey;
        
        // OK, get the coltyp from the attcache
        switch(pAC->syntax) {
        case SYNTAX_CASE_STRING_TYPE:
        case SYNTAX_NOCASE_STRING_TYPE:
        case SYNTAX_PRINT_CASE_STRING_TYPE:
        case SYNTAX_NUMERIC_STRING_TYPE:
        case SYNTAX_BOOLEAN_TYPE:
        case SYNTAX_INTEGER_TYPE:
        case SYNTAX_OCTET_STRING_TYPE:
        case SYNTAX_TIME_TYPE:
        case SYNTAX_UNICODE_TYPE:
        case SYNTAX_ADDRESS_TYPE:
        case SYNTAX_I8_TYPE:
            // We support sorting over these types
            tempTableColumns[0].coltyp = syntax_jet[pAC->syntax].coltype;

            // Because DBInsertSortTable always truncates to 240 bytes and
            // because LV types force materialization and we may not want to
            // use a materialized sort, transform LV types into their non-LV
            // equivalents
            if (tempTableColumns[0].coltyp == JET_coltypLongBinary) {
                tempTableColumns[0].coltyp = JET_coltypBinary;
            }
            else if (tempTableColumns[0].coltyp == JET_coltypLongText) {
                tempTableColumns[0].coltyp = JET_coltypText;
            }
            // If we are using a variable length type then set its max size at
            // 240 bytes and set it to variable length so we don't overflow key
            // space and cause duplicate removal AND so that we don't eat gobs
            // of space unnecessarily
            if (    tempTableColumns[0].coltyp == JET_coltypBinary ||
                    tempTableColumns[0].coltyp == JET_coltypText ) {
                tempTableColumns[0].cbMax = 240;
                tempTableColumns[0].grbit = JET_bitColumnTTKey;
            }
            break;
        default:
            return !0;
        }
    
        if(flags & DB_SORT_DESCENDING) {
            tempTableColumns[0].grbit |= JET_bitColumnTTDescending;
        }
        
        index = 1;
    }
    else {
        index = 0;
    }
        
    tempTableColumns[index].cbStruct = sizeof(tempTableColumns[index]);
    tempTableColumns[index].columnid = 0;
    tempTableColumns[index].coltyp = JET_coltypLong;
    tempTableColumns[index].langid = LANGIDFROMLCID(SortLocale);
    tempTableColumns[index].cp = CP_WINUNICODE;
    tempTableColumns[index].cbMax = 0;
    tempTableColumns[index].grbit = JET_bitColumnFixed | JET_bitColumnTTKey;

    index++;

    grbit = JET_bitTTSortNullsHigh | JET_bitTTUnique;
    if (!(flags & DB_SORT_FORWARDONLY)) {
        grbit = grbit | JET_bitTTForceMaterialization | JET_bitTTIndexed;
    }

    if(err = JetOpenTempTable2(pDB->JetSessID,
                               tempTableColumns,
                               index,
                               LANGIDFROMLCID(SortLocale),
                               grbit,
                               &pDB->JetSortTbl,
                               pDB->SortColumns)) {

        // something went wrong.
        pDB->JetSortTbl = 0;
        pDB->SortColumns[0] = 0;
        pDB->SortColumns[1] = 0;
        pDB->SortColumns[2] = 0;
    }

    pDB->SortColumns[2] = 0;
    if(pAC) {
        // There is a sort column other than DNT.  Switch the values in
        // SortColumns so that pDB->SortColumns[0] is ALWAYS the columnid of the
        // DNT column and pDB->SortColumns[1] is ALWAYS 0 OR the columnid of the
        // data column, and pDB->SortColumns[2] is ALWAYS 0;
        index = pDB->SortColumns[0];
        pDB->SortColumns[0] = pDB->SortColumns[1];
        pDB->SortColumns[1] = index;
    }
    else {
        pDB->SortColumns[1] = 0;
    }
    
    #if DBG
        if (err == 0) {
            pDB->numTempTablesOpened++;
        }
    #endif

    return err;
}

DB_ERR
dbCloseTempTables (
        DBPOS *pDB
        )
{
    KEY_INDEX *pTemp, *pIndex;


    pIndex = pDB->Key.pIndex;

    while(pIndex) {
        pTemp = pIndex->pNext;
        
        if (pIndex->bIsIntersection) {
            Assert (pIndex->tblIntersection);
            JetCloseTable (pDB->JetSessID, pIndex->tblIntersection );

            pIndex->bIsIntersection = 0;
            pIndex->tblIntersection = 0;
            #if DBG
            pDB->numTempTablesOpened--;
            #endif
        }

        Assert (pIndex->tblIntersection == 0);
        
        pIndex = pTemp;
    }
    
    return 0;
}


DB_ERR
DBCloseSortTable (
        DBPOS *pDB
        )
/*++

Routine Description:

    Close a temporary table.  Tolerates a null table handle and returns success
    
Arguments:

    pDB - the DBLayer Position block which holds the sort table to close.

Return Values:
    0 if the table closed ok, an error otherwise (currently returns the bare
    Jet error code).

--*/
{
    DB_ERR err;
    
    Assert(VALID_DBPOS(pDB));

    if(pDB->JetSortTbl) {
        err = JetCloseTable(pDB->JetSessID, pDB->JetSortTbl);
        #if DBG
        Assert (err == 0);
        pDB->numTempTablesOpened--;
        #endif
    }
    else {
        err = 0;
    }
    
    pDB->JetSortTbl =  pDB->SortColumns[0] = pDB->SortColumns[1] =
        pDB->SortColumns[2] = 0;
    
    return err;
}

DB_ERR
DBInsertSortTable (
        DBPOS *pDB,
        CHAR * TextBuff,
        DWORD cb,
        DWORD DNT
        )
/*++

Routine Description:

    Insert a value into a temporary table.  
    
Arguments:

    pDB - the DBLayer Postion block from which to get the sort table to insert
        into. 

    TextBuff - the data to be inserted.

    cb - the count of bytes of data to be inserted.

    DNT - The DNT associated with this data.

Return Values:

    0 if the new new row is added to the table, an error otherwise (currently
    returns the bare Jet error code).

--*/
{
    DB_ERR      err;
    JET_SETINFO setinfo;
    
    Assert(VALID_DBPOS(pDB));

    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = 0;
    setinfo.itagSequence = 0;

    if(!pDB->JetSortTbl) {
        // No one has opened a sort table.  Bail.
        return DB_ERR_NO_SORT_TABLE;
    }
    if(TextBuff && (pDB->SortColumns[1]==0)) {
        // They gave us some bytes to put in the sort column, but we don't
        // apparantly have a sort column.
        return DB_ERR_UNKNOWN_ERROR;
    }
    
    // Shove the DNT and display name into the sort table;
    err = JetPrepareUpdate(pDB->JetSessID,pDB->JetSortTbl,JET_prepInsert);
    if(err != DB_success) {
        return DBErrFromJetErr(err);
    }

    if(TextBuff) {
        // Use no more than 240 bytes of the first column.  This is so that
        // the DNT is used in the key to kill duplicates.  This is safe to
        // do since the first column is only used for sorting, never for
        // reading back, and jet already refuses to sort correctly when the key
        // (which is truncated to CB_MAK_KEY bytes) is too long (a limitation of
        // JET). We're just shortening the number of characters we correctly
        // sort by a little. 
        
        err = JetSetColumn(pDB->JetSessID,
                           pDB->JetSortTbl,
                           pDB->SortColumns[1],
                           TextBuff,
                           min(cb,240),
                           0,
                           &setinfo);
        if(err != DB_success)   {
            JetPrepareUpdate(pDB->JetSessID,pDB->JetSortTbl,JET_prepCancel);
            return DBErrFromJetErr(err);
        }
    }
    
    err = JetSetColumn(pDB->JetSessID,
                       pDB->JetSortTbl,
                       pDB->SortColumns[0],
                       &DNT,
                       sizeof(DWORD),
                       0,
                       &setinfo);
    if(err != DB_success) {
        JetPrepareUpdate(pDB->JetSessID,pDB->JetSortTbl,JET_prepCancel);
        return DBErrFromJetErr(err);
    }
    
    err = JetUpdate(pDB->JetSessID,
                    pDB->JetSortTbl,
                    NULL,
                    0,
                    NULL);
    if(err != DB_success)  {
        JetPrepareUpdate(pDB->JetSessID,pDB->JetSortTbl,JET_prepCancel);
        return DBErrFromJetErr(err);
    }
    
    return DB_success;
}

DB_ERR
DBDeleteFromSortTable (
        DBPOS *pDB
        )
/*++

Routine Description:

    Deletes the current row from a temporary table.  
    
Arguments:

    pDB - the DBLayer Postion block from which to get the sort table to delete
        from.

Return Values:

    0 if the row is deleted from the table, an error otherwise (currently
    returns the bare Jet error code).

--*/
{
    DB_ERR      err;
    Assert(VALID_DBPOS(pDB));

    if(!pDB->JetSortTbl) {
        // No one has opened a sort table.  Bail.
        return DB_ERR_NO_SORT_TABLE;
    }
    err = JetDelete(pDB->JetSessID, pDB->JetSortTbl);
    return err;
}

DB_ERR
DBSetFractionalPosition (
        DBPOS *pDB,
        DWORD Numerator,
        DWORD Denominator
        )
/*++

Routine Description:

    Sets the fractional position in a certain table in whatever the current
    index is.
    
Arguments:

    pDB - the DBLayer position block to move around in.

    Numerator - the Numerator of the fractional position.

    Denominator - the Denominator of the fractional position.

Return Values:
    0 if all went well, an error otherwise (currently returns the bare
    Jet error code).

--*/
{
    JET_RECPOS  RecPos;
    DWORD       err;
    
    Assert(VALID_DBPOS(pDB));

    RecPos.cbStruct = sizeof(JET_RECPOS );
    RecPos.centriesLT = Numerator;
    RecPos.centriesTotal = Denominator;
    RecPos.centriesInRange = 1;
    
    err = JetGotoPosition(pDB->JetSessID, pDB->JetObjTbl, &RecPos);
    
    // Reset DNT and PDNT.
    if(err == JET_errSuccess) {
        // Get the DNT and PDNT.  Get them from disk, since they are not likely
        // to be in the index.
        dbMakeCurrent(pDB, NULL);
    }

    return err;
}

void
DBGetFractionalPosition (
        DBPOS * pDB,
        DWORD * Numerator,
        DWORD * Denominator
        )
/*++

Routine Description:

    Gets the fractional position in a certain table in whatever the current
    index is.
    
Arguments:

    pDB - The DBLayer positon block to use.

    Numerator - the Numerator of the fractional position.

    Denominator - the Denominator of the fractional position.

Return Values:
    None.

--*/
{
    DB_ERR     err;
    JET_RECPOS RecPos;
    
    Assert(VALID_DBPOS(pDB));

    err = JetGetRecordPosition(pDB->JetSessID, pDB->JetObjTbl, &RecPos,
                               sizeof(JET_RECPOS));
    switch(err) {
    case DB_success:
        *Numerator = RecPos.centriesLT;
        *Denominator = RecPos.centriesTotal;
        break;
    default:
        // Just ignore errors.
        *Numerator = 0;
        *Denominator = 1;
        break;
    }
    return;
}

DB_ERR
DBSetCurrentIndex (
        DBPOS *pDB,
        eIndexId indexid,
        ATTCACHE * pAC,
        BOOL MaintainCurrency
        )
/*++

Routine Description:

    Sets the Object Table to the appropriate index.  The index is either
    specified as a string name, or an AttCache * pointing to the attribute we
    want indexed, but not both (which is an error condition).
    
Arguments:

    pDB - The DBLayer positon block to use.

    indexid - an enumerated constant for the index to set to.

    pAC - pointer to an attcache for the attribute we want and index on.

    MaintainCurrency - Do we want to maintain the current object as the current
        object after the index change?

Return Values:

    0 if all went well, an error code otherwise (currently returns the bare jet
    error code).

--*/
{
    DB_ERR err;
    char * pszIndexName = NULL;
    char szIndexName[MAX_INDEX_NAME];
    JET_INDEXID *pidx;
    JET_TABLEID cursor;

    Assert(VALID_DBPOS(pDB));

    Assert((!indexid && pAC) || (indexid && !pAC));

    cursor = pDB->JetObjTbl;

    if (pAC) {
        pszIndexName = pAC->pszIndex;
        pidx = pAC->pidxIndex;
    }
    else {
        switch (indexid) {
          case Idx_Proxy:
            pszIndexName = SZPROXYINDEX;
            pidx = &idxProxy;
            break;

          case Idx_MapiDN:
            pszIndexName = SZMAPIDNINDEX;
            pidx = &idxMapiDN;
            break;

          case Idx_Dnt:
            pszIndexName = SZDNTINDEX;
            pidx = &idxDnt;
            break;

          case Idx_Pdnt:
            pszIndexName = SZPDNTINDEX;
            pidx = &idxPdnt;
            break;

          case Idx_Rdn:
            pszIndexName = SZRDNINDEX;
            pidx = &idxRdn;
            break;

          case Idx_DraUsn:
            pszIndexName = SZDRAUSNINDEX;
            pidx = &idxDraUsn;
            break;

          case Idx_DsaUsn:
            pszIndexName = SZDSAUSNINDEX;
            pidx = &idxDsaUsn;
            break;

          case Idx_ABView:
            // in case of the ABView index, index hints 
            // don't work since there might be several
            // active locales. we use the locale from the
            // thread state to construct the indexName
            sprintf(szIndexName,"%s%08X",SZABVIEWINDEX,
                      LANGIDFROMLCID(pDB->pTHS->dwLcid));
            pidx = NULL;
            pszIndexName = szIndexName;
            break;

          case Idx_Phantom:
            pszIndexName = SZPHANTOMINDEX;
            pidx = &idxPhantom;
            break;

          case Idx_Sid:
            pszIndexName = SZSIDINDEX;
            pidx = &idxSid;
            break;

          case Idx_Del:
            pszIndexName = SZDELINDEX;
            pidx = &idxDel;
            break;

          case Idx_NcAccTypeName:
            pszIndexName = SZ_NC_ACCTYPE_NAME_INDEX;
            pidx = &idxNcAccTypeName;
            break;

          case Idx_NcAccTypeSid:
            pszIndexName = SZ_NC_ACCTYPE_SID_INDEX;
            pidx = &idxNcAccTypeSid;
            break;

          case Idx_LinkDraUsn:
              pszIndexName = SZLINKDRAUSNINDEX;
              pidx = &idxLinkDraUsn;
              cursor = pDB->JetLinkTbl;
              break;

          case Idx_LinkDel:
              pszIndexName = SZLINKDELINDEX;
              pidx = &idxLinkDel;
              cursor = pDB->JetLinkTbl;
              break;

          case Idx_DraUsnCritical:
            pszIndexName = SZDRAUSNCRITICALINDEX;
            pidx = &idxDraUsnCritical;
            break;

          case Idx_Clean:
            pszIndexName = SZDNTCLEANINDEX;
            pidx = &idxDntClean;
            break;

          case Idx_InvocationId:
            pszIndexName = SZINVOCIDINDEX;
            pidx = &idxInvocationId;
            break;

          case Idx_ObjectGuid:
            pszIndexName = SZGUIDINDEX;
            pidx = &idxGuid;
            break;

	  case Idx_NcGuid:
	    pszIndexName = SZNCGUIDINDEX;
	    pidx = &idxNcGuid;
	    break;

          default:
            Assert(FALSE);
            pidx = NULL;    //to avoid C4701
        }
    }

    if (!pszIndexName) {
        return DB_ERR_BAD_INDEX;
    }


    err = JetSetCurrentIndex4Warnings(pDB->JetSessID,
                                      cursor,
                                      pszIndexName,
                                      pidx,
                                      (MaintainCurrency?JET_bitNoMove:0));
    if ( (cursor == pDB->JetObjTbl) &&
         (!MaintainCurrency) &&
         (err == JET_errSuccess) ) {
        pDB->PDNT = pDB->DNT = 0;
    }
        
    return err;
}


DB_ERR
DBSetLocalizedIndex(
        DBPOS *pDB,
        eIndexId IndexId,
        unsigned long ulLangId,
        BOOL MaintainCurrency)
/*++

Routine Description:

    Sets the Object Table to the appropriate index.  The index is either
    specified as a string name, or an AttCache * pointing to the attribute we
    want indexed, but not both (which is an error condition).
    
Arguments:

    pDB - The DBLayer positon block to use.

    indexid - an enumerated constant for the index to set to.
    
    ulLangId -  the locale of the language that we need to set the index to

    MaintainCurrency - Do we want to maintain the current object as the current
        object after the index change?

Return Values:

    0 if all went well,
    DB_ERR_BAD_INDEX - if passed in a bad index, or index does not exist
    JET error code - otherwise

--*/
{
    char pszLocalizedIndex[128];
    DWORD err;

    if (IndexId != Idx_ABView) {
        return DB_ERR_BAD_INDEX;
    }

    sprintf(pszLocalizedIndex,
            "%s%08X",
            SZABVIEWINDEX,
            ulLangId);

    err = JetSetCurrentIndex2Warnings(pDB->JetSessID,
                                       pDB->JetObjTbl,
                                       pszLocalizedIndex,
                                       (MaintainCurrency?JET_bitNoMove:0));

    if (err == JET_errIndexNotFound) {
        return DB_ERR_BAD_INDEX;
    }

    return err;
}

DB_ERR
DBSeek ( 
       DBPOS *pDB,
       INDEX_VALUE *pIV,
       DWORD nVals,
       DWORD SeekType
      )
/*++

Routine Description:

    Wrapper around DBSeekEx
    
Arguments:

Return Values:

--*/
{
    return DBSeekEx( pDB, pDB->JetObjTbl, pIV, nVals, SeekType );
}


DB_ERR
DBSeekEx ( 
       DBPOS *pDB,
       JET_TABLEID Cursor,
       INDEX_VALUE *pIV,
       DWORD nVals,
       DWORD SeekType
      )
/*++

  !!!!!!!!! WARNING !!!!!!!!! WARNING !!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!

    This routine is unreliable for keys that exceed Jets maximum key length.
    If you are using a key that might be too long, remember that Jet truncates
    keys (currently to 255 bytes), and therefore two unicodes strings that
    differ after the 128th Character are considered to be equal!  Multipart
    keys are even worse, since it's the total of the normalized key that is
    limited,not each individual part.  YOU HAVE BEEN WARNED
  
  !!!!!!!!! WARNING !!!!!!!!! WARNING !!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!
    
Routine Description:

    Seeks in the object table to the data described in the key.  Accepts a
    flag, SeekType, which specifies the kind of seek to do.
    
Arguments:

    pDB - The DBLayer positon block to use.

    pIV - the values to search for.

    nVals - the number of values that we are to use.

    SeekType - >=, >, ==, <=, or <

Return Values:

    0 if all went well, an error code otherwise (currently returns the bare jet
    error code).

--*/
{
    DB_ERR      err;
    DWORD       i;
    ULONG       grbit = JET_bitNewKey;
    
    Assert(VALID_DBPOS(pDB));

    for (i=0; i<nVals; i++) {
        err = JetMakeKey(pDB->JetSessID,
                         Cursor,
                         pIV[i].pvData,
                         pIV[i].cbData,
                         grbit);;
        
        if(err != DB_success)
            DsaExcept(DSA_EXCEPTION, err,0);
        
        grbit &= ~JET_bitNewKey;
    }

    switch(SeekType) {
    case DB_SeekGT:
        grbit = JET_bitSeekGT;
        break;
        
    case DB_SeekGE:
        grbit = JET_bitSeekGE;
        break;
        
    case DB_SeekEQ:
        grbit = JET_bitSeekEQ;
        break;
        
    case DB_SeekLE:
        grbit = JET_bitSeekLE;
        break;
        
    case DB_SeekLT:
        grbit = JET_bitSeekLT;
        break;

    default:
        return !0;
    }
    
        
    err = JetSeekEx(pDB->JetSessID, Cursor, grbit);
    
    if(err == JET_wrnSeekNotEqual) {
        // exact search should never find a seeknotequal
        Assert((SeekType != DB_SeekEQ));
        err = DB_success;
    }
    
    if ( (Cursor == pDB->JetObjTbl) && (err == JET_errSuccess) ) {
        dbMakeCurrent(pDB, NULL);
    }
    return err;
}


DB_ERR
dbGetSingleValueInternal (
        DBPOS *pDB,
        JET_COLUMNID colID,
        void * pvData,
        DWORD cbData,
        DWORD *pSizeRead,
        DWORD  grbit
        )
/*++

Routine Description:

    Gets the first value of the given column from the current object in the
    database. 
    
Arguments:

    pDB - The DBLayer positon block to use.

    colId - the Jet database column.

    pvData - buffer to place the data in.

    cbData - size of the buffer.

    pSizeRead - a pointer to a DWORD to return the size of the data actually
    read, or NULL if the caller doesn't care how much was read.

Return Values:

    0 if all went well, an error code otherwise

--*/
{
    DWORD        cbActual;
    JET_ERR      err;

    Assert(VALID_DBPOS(pDB));

    err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                    pDB->JetObjTbl,
                                    colID,
                                    pvData,
                                    cbData,
                                    &cbActual,
                                    grbit,
                                    NULL);
    
    if(pSizeRead)
        *pSizeRead = cbActual;

    switch(err) {
    case JET_errColumnNotFound:
    case JET_wrnColumnNull:
        return DB_ERR_NO_VALUE;
        break;
        
    case JET_wrnBufferTruncated:
        return DB_ERR_VALUE_TRUNCATED;
        break;

    case JET_errSuccess:
        return 0;

    default:
        return err;
    }
    

}
DB_ERR
DBGetSingleValue (
        DBPOS *pDB,
        ATTRTYP Att,
        void * pvData,
        DWORD cbData,
        DWORD *pSizeRead
        )
/*++

Routine Description:

    Gets the first value of the given column from the current object in the
    database.  Does this by looking up the appropriate column id and then
    calling dbGetSingleValueInternal
    
Arguments:

    pDB - The DBLayer positon block to use.

    Att - the attribute to look up.

    pvData - buffer to place the data in.

    cbData - size of the buffer.

    pSizeRead - a pointer to a DWORD to return the size of the data actually
    read, or NULL if the caller doesn't care how much was read.

Return Values:

    0 if all went well, an error code otherwise

--*/
{
    DWORD        cbActual;
    JET_ERR      err;
    ATTCACHE     *pAC;
    JET_COLUMNID colID;
    

    Assert(VALID_DBPOS(pDB));

    switch(Att) {
    case FIXED_ATT_ANCESTORS:
        colID = ancestorsid;
        break;
    case FIXED_ATT_DNT:
        colID = dntid;
        break;
    case FIXED_ATT_NCDNT:
        colID = ncdntid;
        break;
    case FIXED_ATT_OBJ:
        colID = objid;
        break;
    case FIXED_ATT_PDNT:
        colID = pdntid;
        break;
    case FIXED_ATT_REFCOUNT:
        colID = cntid;
        break;
    case FIXED_ATT_AB_REFCOUNT:
        colID = abcntid;
        break;
    case FIXED_ATT_RDN_TYPE:
        colID = rdntypid;
        break;
    case FIXED_ATT_NEEDS_CLEANING:
        colID = cleanid;
        break;
    default:
        if(!(pAC = SCGetAttById(pDB->pTHS, Att))) {
            if (pSizeRead) {
                *pSizeRead = 0;
            }
            return (DB_ERR_NO_VALUE);
        }
        colID = pAC->jColid;
        break;
    }

    return dbGetSingleValueInternal(pDB, colID, pvData, cbData, pSizeRead,
                                    pDB->JetRetrieveBits);
}

DB_ERR
DBGetSingleValueFromIndex (
        DBPOS *pDB,
        ATTRTYP Att,
        void * pvData,
        DWORD cbData,
        DWORD *pSizeRead
        )
/*++

Routine Description:

    Gets the first value of the given column from the current object in the
    database.  Does this by looking up the appropriate column id and then
    calling dbGetSingleValueInternal with the grbit JET_bitRetrieveFromIndex,
    
Arguments:

    pDB - The DBLayer positon block to use.

    Att - the attribute to look up.

    pvData - buffer to place the data in.

    cbData - size of the buffer.

    pSizeRead - a pointer to a DWORD to return the size of the data actually
    read, or NULL if the caller doesn't care how much was read.

Return Values:

    0 if all went well, an error code otherwise

--*/
{
    DWORD        cbActual;
    JET_ERR      err;
    ATTCACHE     *pAC;
    JET_COLUMNID colID;
    

    Assert(VALID_DBPOS(pDB));

    switch(Att) {
    case FIXED_ATT_ANCESTORS:
        colID = ancestorsid;
        break;
    case FIXED_ATT_DNT:
        colID = dntid;
        break;
    case FIXED_ATT_NCDNT:
        colID = ncdntid;
        break;
    case FIXED_ATT_OBJ:
        colID = objid;
        break;
    case FIXED_ATT_PDNT:
        colID = pdntid;
        break;
    case FIXED_ATT_REFCOUNT:
        colID = cntid;
        break;
    case FIXED_ATT_AB_REFCOUNT:
        colID = abcntid;
        break;
    case FIXED_ATT_RDN_TYPE:
        colID = rdntypid;
        break;
    case FIXED_ATT_NEEDS_CLEANING:
        colID = cleanid;
        break;
    default:
        if(!(pAC = SCGetAttById(pDB->pTHS, Att))) {
            return (DB_ERR_NO_VALUE);
        }
        colID = pAC->jColid;
        break;
    }

    return dbGetSingleValueInternal(pDB, colID, pvData, cbData, pSizeRead,
                                    JET_bitRetrieveFromIndex);
}
BOOL
DBHasValues_AC (
        DBPOS *pDB,
        ATTCACHE *pAC
        )
{
    DWORD        cbActual;
    DWORD        temp;
    JET_ERR      err;
    
    
    Assert(VALID_DBPOS(pDB));

    if(pAC->ulLinkID) {
        ULONG ulLinkBase= MakeLinkBase(pAC->ulLinkID);
        PUCHAR szIndex;
        ULONG ulObjectDnt, ulRecLinkBase, cb;
        JET_COLUMNID objectdntid;
        
        // First, are we looking at a link or backlink attribute?
        if (FIsBacklink(pAC->ulLinkID)) {
            szIndex = SZBACKLINKINDEX;
            objectdntid = backlinkdntid;
        }
        else {
            szIndex = (pDB->fScopeLegacyLinks ? SZLINKLEGACYINDEX : SZLINKINDEX);
            objectdntid = linkdntid;
        }

        // Set up the index and search for a match.
        JetSetCurrentIndexSuccess(pDB->JetSessID,
                                  pDB->JetLinkTbl,
                                  szIndex);
        
        JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                     &(pDB->DNT), sizeof(pDB->DNT), JET_bitNewKey);
        JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl, 
                     &ulLinkBase, sizeof(ulLinkBase), 0);
        
        // seek
        if (((err = JetSeekEx(pDB->JetSessID, pDB->JetLinkTbl, JET_bitSeekGE)) 
             !=  JET_errSuccess) &&
            (err != JET_wrnRecordFoundGreater)) {
            return FALSE;
        }
        
        // test to verify that we found a qualifying record
        JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl, objectdntid, 
                                 &ulObjectDnt, sizeof(ulObjectDnt), &cb, 0,
                                  NULL); 

        JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl, linkbaseid, 
                                 &ulRecLinkBase, sizeof(ulRecLinkBase), &cb, 0,
                                  NULL); 
 
        if ((ulObjectDnt != pDB->DNT) || (ulLinkBase != ulRecLinkBase)) {
            return FALSE;
        }

        // found a valid record
        return TRUE;

    }
    else {
        switch(JetRetrieveColumnWarnings(pDB->JetSessID,
                                         pDB->JetObjTbl,
                                         pAC->jColid,
                                         &temp,
                                         0,
                                         &cbActual,
                                         pDB->JetRetrieveBits,
                                         NULL)) {
            
        case JET_errColumnNotFound:
        case JET_wrnColumnNull:
            return FALSE;
            break;
            
        case JET_wrnBufferTruncated:
        case JET_errSuccess:
            return TRUE;
            break;
        default:
            return FALSE;
        }
    }
    
}
BOOL
DBHasValues (
        DBPOS *pDB,
        ATTRTYP Att
        )
{
    DWORD        cbActual;
    DWORD        temp;
    JET_ERR      err;
    ATTCACHE     *pAC;
    JET_COLUMNID colID;

    Assert(VALID_DBPOS(pDB));

    if(Att < FIRST_FIXED_ATT) {
        // Not a fixed column, so it better have an attcache.
        if(!(pAC = SCGetAttById(pDB->pTHS, Att))) {
            return FALSE;
        }
        return DBHasValues_AC(pDB, pAC);
    }
    
    switch (Att) {
    case FIXED_ATT_ANCESTORS:
        colID = ancestorsid;
        break;
    case FIXED_ATT_DNT:
        colID = dntid;
        break;
    case FIXED_ATT_NCDNT:
        colID = ncdntid;
        break;
    case FIXED_ATT_OBJ:
        colID = objid;
        break;
    case FIXED_ATT_PDNT:
        colID = pdntid;
        break;
    case FIXED_ATT_REFCOUNT:
        colID = cntid;
        break;
    case FIXED_ATT_AB_REFCOUNT:
        colID = abcntid;
        break;
    case FIXED_ATT_RDN_TYPE:
        colID = rdntypid;
        break;
    case FIXED_ATT_NEEDS_CLEANING:
        colID = cleanid;
        break;
    default:
        return FALSE;
    }

    
    switch(JetRetrieveColumnWarnings(pDB->JetSessID,
                                     pDB->JetObjTbl,
                                     colID,
                                     &temp,
                                     0,
                                     &cbActual,
                                     pDB->JetRetrieveBits,
                                     NULL)) {
            
    case JET_errColumnNotFound:
    case JET_wrnColumnNull:
        return FALSE;
        break;
        
    case JET_wrnBufferTruncated:
    case JET_errSuccess:
        return TRUE;
        break;
    default:
        return FALSE;
    }
    
}

DB_ERR
DBGetDNTSortTable (
        DBPOS *pDB,
        DWORD *pvData
        )
/*++

Routine Description:

    Gets the first value of the given column from the current object in the
    database.  If UseSortTable, then use the sort table, otherwise use the
    object table.
    
Arguments:

    pDB - The DBLayer positon block to use.

    pvData - buffer to place the data in.

Return Values:

    0 if all went well, an error code otherwise

--*/
{
    DWORD       cbActual, colID;
    JET_ERR     err;

    Assert(VALID_DBPOS(pDB));

    if(!pDB->JetSortTbl) {
        return DB_ERR_NO_SORT_TABLE;
    }
    
    err = JetRetrieveColumnWarnings(
            pDB->JetSessID,
            pDB->JetSortTbl,
            pDB->SortColumns[0],
            pvData,
            sizeof(DWORD),
            &cbActual,
            0,
            NULL);

    switch(err) {
    case JET_errColumnNotFound:
    case JET_wrnColumnNull:
        return DB_ERR_NO_VALUE;
        break;
        
    case JET_wrnBufferTruncated:
        return DB_ERR_VALUE_TRUNCATED;
        break;

    case JET_errSuccess:
        return 0;

    default:
        return err;
    }
    

}

DWORD
DBCompareDNTs (
        DBPOS *pDB,
        eIndexId idIndex,
        ATTCACHE *pAC,
        DWORD DNT1,
        DWORD DNT2,
        DWORD *pResult
        )
/*++

Routine Description:

    Compares the relative position of the two DNTs is the given index. Returns <
    0 if DNT1 < DNT2, 0 if DNT1==DNT2, and >0 if DNT1 > DNT2.  Specifies the
    index either by name of by an attcache pointer to the attribute to be
    indexed. 
    
Arguments:

    pDB - The DBLayer positon block to use.

    idIndex - the identifier of the index.

    pAC - Attcache pointer to an attribute to be indexed.

    DNT1 - the first DNT.

    DNT2 - the second DNT.
    
    pResult - the result of the comparison

Return Values:

    0 if the comparison was done, an error code otherwise.

--*/
{
    ULONG   cb1, cb2;
    BYTE    acKey2[DB_CB_MAX_KEY], acKey1[DB_CB_MAX_KEY];
    JET_ERR err;
    
    Assert(VALID_DBPOS(pDB));

    // DB_CB_MAX_KEY is the maximum jet key size.
    cb1=cb2=DB_CB_MAX_KEY;
    
    
    // First, get the keys of the two objects.
    if(err = DBSetCurrentIndex(pDB, Idx_Dnt, NULL, 0))
        return err;
    
    if(err = DBFindDNT(pDB, DNT1))
        return err;

    // Jump to the named index, retaining place.
    if(err =DBSetCurrentIndex(pDB, idIndex, pAC, TRUE))
        return err;
    

    // Get the key.
    JetRetrieveKeyEx(pDB->JetSessID,
                     pDB->JetObjTbl,
                     acKey1, cb1,
                     &cb1, 0);


    // Do it again for the second DNT
    if(err = DBSetCurrentIndex(pDB, Idx_Dnt, NULL, 0))
        return err;
    
    if(err = DBFindDNT(pDB, DNT2))
        return err;

    if(err = DBSetCurrentIndex(pDB, idIndex, NULL, TRUE))
        return err;

    JetRetrieveKeyEx(pDB->JetSessID,
                     pDB->JetObjTbl,
                     acKey2, cb2,
                     &cb2, 0);


    // memcmp the keys.  This finds the relative position of the two DNTs
    if(!(*pResult = memcmp(acKey1, acKey2, min(cb1,cb2)))) {
        // tie-breaker; longer key is later 
        *pResult = cb2 - cb1;
    }
    
    return 0;
}

DWORD
DBSetIndexRangeEx (
        DBPOS *pDB,
        JET_TABLEID Cursor,
        INDEX_VALUE *pIV,
        DWORD nVals,
        BOOL fSubstring
        )
/*++

Routine Description:

    Sets an index range on the current index using the target bytes given.  An
    index range sets an artificial end of index after any value which fails to
    satisfy the key used to create the range.  A DBMove which would land on the
    artificial end of index acts the same as if it had walked of the real end of
    the index.
    
Arguments:

    pDB - The DBLayer positon block to use.

    Cursor - Which table to use

    pTarget - the data to use for the index range key.

    cbTarget - the size of the data.

    fSubstring - Substring match. If true, this index range is intended to be
         over a string data column and does an initial substring match key.

Return Values:

    0 if the comparison was done, an error code otherwise.

--*/
{
    JET_ERR err;
    DWORD   i;
    DWORD grbits = fSubstring ? JET_bitStrLimit : 0;

    Assert(VALID_DBPOS(pDB));

    for (i=0; i<nVals; i++) {
        err = JetMakeKey(pDB->JetSessID,
                         Cursor,
                         pIV[i].pvData,
                         pIV[i].cbData,
                         i ? 0 : (grbits | JET_bitNewKey));
        
        if(err != DB_success)
            return err;
    }
    
    return JetSetIndexRangeEx(pDB->JetSessID,
                              Cursor,
                              (JET_bitRangeUpperLimit |
                               JET_bitRangeInclusive ));
    
}

DWORD
DBSetIndexRange (
        DBPOS *pDB,
        INDEX_VALUE *pIV,
        DWORD nVals
        )
/*++

Routine Description:

    Sets an index range on the current index using the target bytes given.  An
    index range sets an artificial end of index after any value which fails to
    satisfy the key used to create the range.  A DBMove which would land on the
    artificial end of index acts the same as if it had walked of the real end of
    the index.  Note that this index range is intended to be over a string data
    column and does an initial substring match key.
    
Arguments:

    pDB - The DBLayer positon block to use.

    pTarget - the data to use for the index range key.

    cbTarget - the size of the data.

Return Values:

    0 if the comparison was done, an error code otherwise.

--*/
{
    return DBSetIndexRangeEx( pDB, pDB->JetObjTbl, pIV, nVals, TRUE /*substring*/ );
}

void
DBGetIndexSize(
        DBPOS *pDB,
        ULONG *pSize
        )
/*++

Routine Description:

    Returns the number of objects in the current index.

Arguments:

    pDB - The DBLayer positon block to use.

    pSize - the place to return the size of the index.

Return Values:

    None.

--*/
{
    JET_ERR err;

    Assert(VALID_DBPOS(pDB));

    *pSize = 0;

    err = JetIndexRecordCountEx(pDB->JetSessID, pDB->JetObjTbl,pSize, ULONG_MAX);
    if ( (err != JET_errSuccess) &&
         (err != JET_errNoCurrentRecord) ) {
        DPRINT1( 0, "JetIndexRecountCountEx failed, err = %d\n", err );
    }
}


void
DBGetIndexSizeEx(
        DBPOS *pDB,
        JET_TABLEID Cursor,
        ULONG *pSize
        )
/*++

Routine Description:

    Returns the number of objects in the current index.

Arguments:

    pDB - The DBLayer positon block to use.

    Cursor - Which table to search

    pSize - the place to return the size of the index.

Return Values:

    None.

--*/
{
    JET_ERR err;

    Assert(VALID_DBPOS(pDB));

    *pSize = 0;

    err = JetIndexRecordCountEx(pDB->JetSessID, Cursor, pSize, ULONG_MAX);
    if ( (err != JET_errSuccess) &&
         (err != JET_errNoCurrentRecord) ) {
        DPRINT1( 0, "JetIndexRecountCountEx failed, err = %d\n", err );
    }
       
}


void
DBGetBookMark (
        DBPOS *pDB,
        DBBOOKMARK *pBookMark
    )

/*++

Routine Description:

Record the position in the object table.

Arguments:

    pDB - 
    pBookMark - pointer to updated bookmark structure

Return Value:

    None

--*/

{
    DBGetBookMarkEx( pDB, pDB->JetObjTbl, pBookMark );
} /* DBGetBookMark  */


void
DBGotoBookMark (
        DBPOS *pDB,
        DBBOOKMARK BookMark
        )

/*++

Routine Description:

Goto bookmark position in object table

Arguments:

    pDB - 
    BookMark - passed by value for historical reasons

Return Value:

    None

--*/

{
    DBGotoBookMarkEx( pDB, pDB->JetObjTbl, &BookMark );

} /* DBGotoBookMark  */

void
DBGetBookMarkEx (
        DBPOS *pDB,
        JET_TABLEID Cursor,
        DBBOOKMARK *pBookMark)
/* 
   Description:
      A very thin wrapper around JetGetBookMark.  Allocates the memory for the
      bookmark and drops it into a structure passed in.

   Free using DbFreeBookMark() when done

   Parameters      
      pDB - DBPOS to use
      Cursor - which table to use
      pBookMark - pointer to already existing structure to fill in the bookmark
      data. 

   Returns:
      No return code, but the bookmark structure is filled in when we return.

*/      
{
    DWORD cb = 0;
    DWORD err;
    void *pv;

    pBookMark->pv = NULL;
    pBookMark->cb = 0;
    
    err = JetGetBookmark(pDB->JetSessID,
                         Cursor,
                         NULL,
                         0,
                         &cb);
    if (err != JET_errBufferTooSmall) {
        // This shouldn't happen.  
        DsaExcept(DSA_EXCEPTION, err,0);
    }
    
    pv = THAllocEx(pDB->pTHS, cb);
    pBookMark->pv = pv;
    pBookMark->cb = cb;
    JetGetBookmarkEx(pDB->JetSessID,
                     Cursor,
                     pv,
                     cb,
                     &cb);

    Assert(cb == pBookMark->cb);
    return;
}

void
DBGotoBookMarkEx (
        DBPOS *pDB,
        JET_TABLEID Cursor,
        DBBOOKMARK *pBookMark
        )
/* 
   Description:
      A very thin wrapper around JetGotoBookMark.  After going to the bookmark,
      reset position data in the dbpos.

   Parameters      
      pDB - DBPOS to use
      Cursor - which table to use
      pBookMark - bookmark to goto.

   Returns:
      No return code.

*/
{
    Assert(pBookMark->pv);
    Assert(pBookMark->cb);
    JetGotoBookmarkEx(pDB->JetSessID,
                      Cursor,
                      pBookMark->pv,
                      pBookMark->cb);

    // Guarantee that DBPOS is updated with new position
    if (Cursor == pDB->JetObjTbl) {
        dbMakeCurrent(pDB, NULL);
    }

    return;
}


DWORD
DBGetEstimatedNCSizeEx(
    IN DBPOS *pDB,
    IN ULONG dntNC
    )
/*++

Routine Description:

This was written to replace DBGetNCSizeEx() in cases where an estimated
size would suffice.  This routines uses the CountAncestorsIndexSizeHelper()
function to get the number of objects in the index with a common chain
of ancestors.

Used as a base:
  src\mddit.c:MakeNCEntry()
  dblayer\dbtools.c:CountAncestorsIndexSizeHelper/CountAncestorsIndexSize


Arguments:

    pDB - Which session to use.
    dntNC - DNT of NC you want to count.

Return Value:

    (DWORD) - Estimated size of NC.  Raises exceptions on errors.  Finally,
    note currency will be lost, caller must restore.

--*/
{
    DWORD       cbAncestors = 0;
    DWORD *     pAncestors = NULL;
    DWORD       numAncestors = 0;
    ULONG       ulEstimatedSize = 0;

    DBFindDNT(pDB, dntNC);

    DBGetAncestors (pDB, &cbAncestors, &pAncestors, &numAncestors);

    ulEstimatedSize = CountAncestorsIndexSizeHelper (pDB,
                                                     cbAncestors,
                                                     pAncestors);

    THFreeEx (pTHStls, pAncestors);
    return(ulEstimatedSize);
}


DWORD
DBGetNCSizeEx(
    IN DBPOS *pDB,
    IN JET_TABLEID Cursor,
    IN eIndexId indexid,
    IN ULONG dntNC
    )

/*++

Routine Description:

Return the number of objects in a given NC.  This relies on the fact we have
an index with ncdnt as the primary segment.

Currency is left at the first record of the next nc, or the last record of the
desired nc.

Counting the number of objects in an index can take a long time when there are
100K or 1M objects.  We do the following to reduce the impact:
1. Using seek and index ranges, we only count the index once
2. We only call this one per full-sync-cycle on the source.  The dest uses
a counter.

Note that another option is to use the get/set record position capability.
These functions return position hints and can be up to 20% off.
    // Record position
    numerator = 0;
    denominator = 0;
    DBGetFractionalPosition( pDB, &numerator, &denominator );
    lowerPosition = (DWORD)
        ( ( (double) numerator / (double) denominator ) * (double) indexSize );

Arguments:

    pDB - Which session to use
    Cursor - Which table to search
    dntNC - nc

Return Value:

    DWORD - 

--*/

{
    DB_ERR dberr;
    INDEX_VALUE indexValue;
    DWORD count = 0;
    DWORD dntSearchNC = dntNC;

    // We want one that is indexed by NCDNT
    dberr = DBSetCurrentIndex(pDB, indexid, NULL, FALSE);
    if (dberr == JET_errNoCurrentRecord) {
        // No range exists
        return 0;
    } else if (dberr) {
        DsaExcept(DSA_EXCEPTION, dberr,0);
    }

    // Start at the beginning of the index
    dberr = DBMoveEx(pDB, Cursor, DB_MoveFirst);
    if (dberr == JET_errNoCurrentRecord) {
        // No range exists
        return 0;
    } else if (dberr) {
        DsaExcept(DSA_EXCEPTION, dberr,0);
    }

    // Seek to first record with that ncdnt
    indexValue.pvData = &dntSearchNC;
    indexValue.cbData = sizeof( ULONG );

    dberr = DBSeekEx( pDB, Cursor, &indexValue, 1, DB_SeekGE );
    if (dberr == JET_errRecordNotFound) {
        // No changes on this index
        return 0;
    } else if (dberr) {
        DsaExcept(DSA_EXCEPTION, dberr,0);
    }

    // Point the index value at the next higher NC
    dntSearchNC++;

    // Set the counting limit to be the top of the NC
    dberr = DBSetIndexRangeEx( pDB, Cursor, &indexValue, 1, FALSE /*notsubstring*/ );
    if (dberr == JET_errNoCurrentRecord) {
        // No range exists
        return 0;
    } else if (dberr) {
        DsaExcept(DSA_EXCEPTION, dberr,0);
    }

    // Check if we're shutting down before doing this expensive call.
    if(eServiceShutdown){
        DsaExcept(DSA_EXCEPTION, ERROR_DS_SHUTTING_DOWN, 0);
    }

    // Get index size from position to end
    // SCALING: This call counts every record
    // PERFORMANCE: Call JetIndexRecordCount directly and set the upper bound
    // option on the number of records counted.  This will bound the amount
    // of index processing time we put into this.
    DBGetIndexSizeEx( pDB, Cursor, &count );

    // Check if we're shutting down right after this expensive call.
    if(eServiceShutdown){
        DsaExcept(DSA_EXCEPTION, ERROR_DS_SHUTTING_DOWN, 0);
    }

#if DBG
    DPRINT2( 1, "Size of NC %s is %d record(s).\n",
             DBGetExtDnFromDnt( pDB, dntNC ), count );
#endif

    return count;
} /* DBGetNCSizeEx */


VOID
DBSearchCriticalByDnt(
    DBPOS *pDB,
    DWORD dntObject,
    BOOL *pCritical
    )

/*++

Routine Description:

    Check if the given dnt refers to a critical object
    Use the search table so not to disturb ObjectTable Concurrency

    This is a performance optimization helper for
    GetNextObjOrValByUsn. In the case where we are searching for critical
    objects and have found a value, we have the dnt of an object. We want
    to know quickly and with minimal disturbance of the object referenced
    by the dnt is critical.

    In the future, we might consider caching the results of this lookup
    somehow.

Arguments:

    pDB - 
    dntObject - 
    pCritical - 

Return Value:

    DWORD - 

--*/

{
    JET_ERR err;
    DWORD cbActual;

    Assert(VALID_DBPOS(pDB));

    // Switch to dnt index
    JetSetCurrentIndex4Success(pDB->JetSessID,
                               pDB->JetSearchTbl,
                               SZDNTINDEX,
                               &idxDnt,
                               0 // no currency to keep
        );
            
    // Seek to this item
    JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl,
                 &dntObject, sizeof(dntObject),
                 JET_bitNewKey);

    err = JetSeekEx(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekEQ);
    if (err) {
        DPRINT1( 0, "dnt %d not found on dnt index\n", dntObject );
        DsaExcept(DSA_EXCEPTION, err,0);
    }

    // At this point, we have seeked to the dnt on a separate Jet cursor.
    // We have a choice: we can read ATT_IS_CRITICAL_SYSTEM_OBJECT from the
    // data page, or we can switch to USN-CRITICAL index and read the att
    // out of the index. I chose the latter.

    // Switch to Usn Critical index, preserving currency
    err = JetSetCurrentIndex2Warnings(pDB->JetSessID,
                                      pDB->JetSearchTbl,
                                      SZDRAUSNCRITICALINDEX,
                                      JET_bitNoMove);
    if (err) {
        // Record not on this index, not critical
        DPRINT1( 3, "dnt %d not found on usn critical index\n", dntObject );
        *pCritical = FALSE;
        return;
    }

    // Should succeed if on the index
    JetRetrieveColumnSuccess(pDB->JetSessID,
                             pDB->JetSearchTbl,
                             iscriticalid,
                             pCritical,
                             sizeof(BOOL),
                             &cbActual,
                             JET_bitRetrieveFromIndex,
                             NULL );

    DPRINT2( 3, "critical value of dnt %d is %d\n", dntObject, *pCritical );

} /* DBSearchCriticalByDnt */


BOOL
DBSearchHasValuesByDnt(
    IN DBPOS        *pDB,
    IN DWORD        DNT,
    IN JET_COLUMNID jColid
    )

/*++

Routine Description:

    Does object at DNT have values for jColid?

    pDB->JetSearchTbl is used. Currency in pDB->JetObjTbl is not disturbed.

    This is a performance optimization helper for SetSpecialAttsForAuxClasses
    when creating a dynamic object.

Arguments:

    pDB - database currency
    DNT - for the object in question
    jColid - retrieve value for this column

Return Value:
    An exception is raised if there is an unexpected jet error.
    TRUE - value exists and has been returned.
    FALSE - value doesn't exist.

--*/

{
    JET_ERR err;
    DWORD   Data;
    DWORD   cbActual;

    Assert(VALID_DBPOS(pDB));

    // Switch to dnt index using the search table
    if (JET_errSuccess != JetSetCurrentIndex4Warnings(pDB->JetSessID,
                                                      pDB->JetSearchTbl,
                                                      SZDNTINDEX,
                                                      &idxDnt,
                                                      0)) {
        return FALSE;
    }
            
    // Seek to the object by dnt
    JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl,
                 &DNT, sizeof(DNT), JET_bitNewKey);
    if (JET_errSuccess != JetSeekEx(pDB->JetSessID, 
                                    pDB->JetSearchTbl, 
                                    JET_bitSeekEQ)) {
        return FALSE;
    }

    // Has values?
    switch(JetRetrieveColumnWarnings(pDB->JetSessID,
                                     pDB->JetSearchTbl,
                                     jColid,
                                     &Data,
                                     0,
                                     &cbActual,
                                     0,
                                     NULL)) {
        
    case JET_errColumnNotFound:
    case JET_wrnColumnNull:
        return FALSE;
        break;
        
    case JET_wrnBufferTruncated:
    case JET_errSuccess:
        return TRUE;
        break;
    default:
        return FALSE;
    }

} // DBSearchHasValuesByDnt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dbfilter.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       dbfilter.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <mdlocal.h>
#include <dsatools.h>                   // For pTHS
#include <limits.h>


// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>
#include "ntdsctr.h"

// Assorted DSA headers
#include <anchor.h>
#include <mappings.h>
#include <dsevent.h>
#include <filtypes.h>                   // Def of FI_CHOICE_???     
#include "objids.h"                     // Hard-coded Att-ids and Class-ids 
#include "dsconfig.h"
#include "debug.h"                      // standard debugging header 
#define DEBSUB "DBFILTER:"              // define the subsystem for debugging

// DBLayer includes
#include "dbintrnl.h"

#include <fileno.h>
#define  FILENO FILENO_DBFILTER


/* Internal functions */
DWORD
dbFlattenFilter (
        DBPOS *pDB,
        FILTER *pFil,
        FILTER **ppOutFil);

DWORD 
dbCloneFilter (
    DBPOS *pDB,
    FILTER *pFil, 
    FILTER **ppOutFil);


DWORD 
dbOptFilter (
        DBPOS     *pDB,
        DWORD     Flags,
        KEY_INDEX **ppBestIndex,
        FILTER    *pFil
        );

DWORD 
dbOptAndFilter (
    DBPOS     *pDB,
    DWORD     Flags,
    KEY_INDEX **ppBestIndex,
    FILTER    *pFil
    );

DWORD 
dbOptItemFilter (
    DBPOS    *pDB,
    DWORD     fParentFilterType,
    DWORD     Flags,
    KEY_INDEX **ppBestIndex,
    FILTER    *pFil,
    FILTER    *pFil2
    );

DWORD
dbOptSubstringFilter (
        DBPOS *pDB,
        DWORD  fParentFilterType,
        DWORD     Flags,
        KEY_INDEX **ppBestIndex,
        DWORD     *pIndexCount,
        FILTER    *pFil
        );

//
// Index optimization flags.
//
#define DBOPTINDEX_fUSE_SHOW_IN_AB             0x1
#define DBOPTINDEX_fDONT_INTERSECT             0x2
#define DBOPTINDEX_fDONT_OPT_MEDIAL_SUBTSTRING 0x4


// this is the maximum number of the indexes that can be intersected.
// this is related to the filters that are under the AND filter.
// for each one, we have to create a new jet cursor, which limits the number
// of active open cursors we can have at any time.
// the Jet limit for this is 64, but we think 16 will be enough for our case.
#define MAX_NUMBER_INTERSECTABLE_INDEXES 16

// this is the number of entries that if found on the default index, 
// we do not optimize the filter
#define MIN_NUM_ENTRIES_ON_OPT_INDEX 2

BOOL gfUseIndexOptimizations = TRUE;

BOOL gfUseRangeOptimizations = TRUE;
BOOL gfUseANDORFilterOptimizations = TRUE;

ULONG gulInteserctExpenseRatio = DEFAULT_DB_INTERSECT_RATIO;
ULONG gulMaxRecordsWithoutIntersection = DEFAULT_DB_INTERSECT_THRESHOLD;
ULONG gulEstimatedAncestorsIndexSize = 100000000;

BOOL gfSupressFirstLastANR=FALSE;
BOOL gfSupressLastFirstANR=FALSE;

const char c_szIntersectIndex[] = "INTERSECT_INDEX";
const DWORD cIntersectIndex = sizeof (c_szIntersectIndex);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Set a new filter.
*/

void
DBSetFilter (
        DBPOS FAR *pDB,
        FILTER *pFil,
        POBJECT_TYPE_LIST pSec,
        DWORD *pSecResults,
        ULONG SecSize,
        BOOL *pbSortSkip
        )
{
    BOOL fDontFreeFilter = pDB->Key.fDontFreeFilter;

    if (pDB->Key.pIndex) {
        dbFreeKeyIndex (pDB->pTHS, pDB->Key.pIndex);
    }
    if (pDB->Key.pFilter) {
        dbFreeFilter (pDB, pDB->Key.pFilter);
    }
    memset(&pDB->Key, 0, sizeof(KEY));
    pDB->Key.fDontFreeFilter = fDontFreeFilter;
    
    pDB->Key.pFilter = pFil;   /*Set filter pointer*/
    pDB->Key.pFilterSecurity = pSec;
    pDB->Key.pFilterResults = pSecResults;
    pDB->Key.FilterSecuritySize = SecSize;
    pDB->Key.pbSortSkip = pbSortSkip;
    
    return;

}/*DBSetFilter*/

/*++

Routine Description:

    Generates the correct index name to be used for an attribute.
    Takes in consideration the type of index required (SUBTREE/ONELEVEL),
    and whether there exists a pre-existing index for this attribute.
    Also considers the required language this index has to be for 
    the ONELEVEL case.

Arguments:    

    pAC - the attribute to use
    flags - fATTINDEX OR fPDNTATTINDEX  (what index to generate)
    dwLcid - the required locale (DS_DEFAULT_LOCALE is default)
    szIndexName - where to store the generated index name
    cchIndexName - the size of the passed in szIndexName

Return Value:
    
    TRUE on success

--*/     
BOOL DBGetIndexName (ATTCACHE *pAC, DWORD flags, DWORD dwLcid, CHAR *szIndexName, DWORD cchIndexName)
{
    int ret;
    if (flags == fATTINDEX) {
        ret = _snprintf(szIndexName, cchIndexName, SZATTINDEXPREFIX"%08X", pAC->id);
        Assert (ret>=0);
    }
    else if (flags == fTUPLEINDEX) {
        ret = _snprintf(szIndexName, cchIndexName, SZATTINDEXPREFIX"T_%08X", pAC->id);
        Assert (ret>=0);
    }
    else if (flags == fPDNTATTINDEX ) {

        if (dwLcid == DS_DEFAULT_LOCALE) {
            if (pAC->id == ATT_RDN) {
                strncpy(szIndexName, SZPDNTINDEX, cchIndexName);
            }
            else {
                ret = _snprintf(szIndexName, cchIndexName, SZATTINDEXPREFIX"P_%08X", pAC->id);
                Assert (ret>=0);
            }
        }
        else {
            ret = _snprintf(szIndexName, cchIndexName, SZATTINDEXPREFIX"LP_%08X_%04X", pAC->id, dwLcid);
            Assert (ret>=0);
        }
    }
    else {
        Assert (!"DBGetIndexName: Bad parameter passed");
        return FALSE;
    }

    return TRUE;
}

BOOL
dbSetToTupleIndex(
        DBPOS    *pDB,
        ATTCACHE *pAC,
        CHAR     *szIndexName
        )
{
    THSTATE *pTHS=pDB->pTHS;

    sprintf(szIndexName, SZATTINDEXPREFIX"T_%08X", pAC->id);
    if(!JetSetCurrentIndexWarnings(pDB->JetSessID,
                                   pDB->JetSearchTbl,
                                   szIndexName)) {
        return TRUE;
    }
    DPRINT1(2, "dbSetToTupleIndex: Unable to set to index %s\n", szIndexName);
    return FALSE;
}

BOOL
dbSetToIndex(
        DBPOS    *pDB,
        BOOL      fCanUseShowInAB,
        BOOL     *pfPDNT,
        CHAR     *szIndexName,
        ATTCACHE *pAC
        )
{
    THSTATE *pTHS=pDB->pTHS;
    *pfPDNT = FALSE;
    
    Assert(VALID_DBPOS(pDB));

    if(!pTHS->fDefaultLcid && !pDB->Key.pVLV) {
        // We have a non-default locale.  That implies that this is a mapi
        // request.  So, try to use the index we build mapi tables out of.
        switch(pAC->id) {
        case ATT_SHOW_IN_ADDRESS_BOOK:
            sprintf(szIndexName,"%s%08X",SZABVIEWINDEX,
                    LANGIDFROMLCID(pTHS->dwLcid));
            
            if(!JetSetCurrentIndexWarnings(pDB->JetSessID,
                                           pDB->JetSearchTbl,
                                           szIndexName)) {
                return TRUE;
            }
            break;
        case ATT_DISPLAY_NAME:
            // It would be cool if we could use the ABVIEW index to
            // support this.  The ABVIEW index is over ATT_SHOW_IN_ADDRESS_BOOK
            // followed by ATT_DISPLAY_NAME.  To support the ATT_DISPLAY_NAME
            // case, we would need a way to figure out what the value of
            // ATT_SHOW_IN_ADDRESS_BOOK needs to be.  Maybe I'll figure out how
            // to do this later.  Until then, do nothing special.
            break;

        default:
            // No special index use available.
            break;
        }
    }
    else if(fCanUseShowInAB && pAC->id == ATT_SHOW_IN_ADDRESS_BOOK) {
        // We can use the index we build mapi tables out of anyway, because we
        // have previously checked the filter and the caller is also doing
        // something that implies presence of display name (the AB index is
        // compound over SHOW_IN.. and DISPLAY_NAME

        if (!pDB->Key.pVLV) {
            sprintf(szIndexName,"%s%08X",SZABVIEWINDEX,
                    LANGIDFROMLCID(gAnchor.ulDefaultLanguage));
        }
        else {
            sprintf(szIndexName,"%s%08X",SZABVIEWINDEX,
                    LANGIDFROMLCID(pTHS->dwLcid));
        }
        
        if(!JetSetCurrentIndexWarnings(pDB->JetSessID,
                                       pDB->JetSearchTbl,
                                       szIndexName)) {
            return TRUE;
        }
    }
    
    // First, see if we should try a PDNT version
    if(pDB->Key.ulSearchType ==  SE_CHOICE_IMMED_CHLDRN) {

        if (pAC->fSearchFlags & fPDNTATTINDEX) {
            // We are looking only for children of a certain parent and the schema
            // cache says that such an index should exist.
            // Try for a PDNT based index.

            // if we are doing VLV on a language other than the default
            // we will try to use the language specific PDNT index
            if (pDB->Key.pVLV && pTHS->dwLcid != DS_DEFAULT_LOCALE) {
                DPRINT1 (0, "Using Language 0x%x\n", pTHS->dwLcid);

                sprintf(szIndexName, SZATTINDEXPREFIX"LP_%08X_%04X", 
                                    pAC->id, pTHS->dwLcid);

                if (!JetSetCurrentIndex4Warnings(pDB->JetSessID,
                                                 pDB->JetSearchTbl,
                                                 szIndexName,
                                                 0,
                                                 0)) {
                    *pfPDNT = TRUE;
                    return TRUE;
                }
            }

            //copy cached index to return variable, since it used afterwards
            Assert (pAC->pszPdntIndex);
            strcpy (szIndexName, pAC->pszPdntIndex);

            if (!JetSetCurrentIndex4Warnings(pDB->JetSessID,
                                             pDB->JetSearchTbl,
                                             szIndexName,
                                             pAC->pidxPdntIndex,
                                             0)) {
                *pfPDNT = TRUE;
                return TRUE;
            }
        }
        
        else if (pAC->id == ATT_RDN) {
            // this is a special case
            // we can use the pDNTRDN index directly when we ask for the default lang

            if (pTHS->dwLcid == DS_DEFAULT_LOCALE) {

                strcpy (szIndexName, SZPDNTINDEX);

                if (!JetSetCurrentIndex4Warnings(pDB->JetSessID,
                                                 pDB->JetSearchTbl,
                                                 szIndexName,
                                                 &idxPdnt,
                                                 0)) {
                    *pfPDNT = TRUE;
                    return TRUE;
                }
            }
        }
    }
    
    // Don't have an index yet.
    if(pAC->fSearchFlags & fATTINDEX) {
        // But the schema cache says one should exist.
        
        //copy cached index to return variable, since it used afterwards
        Assert (pAC->pszIndex);
        strcpy (szIndexName, pAC->pszIndex); 

        if (!JetSetCurrentIndex4Warnings(pDB->JetSessID,
                                         pDB->JetSearchTbl,
                                         szIndexName,
                                         pAC->pidxIndex,
                                         0))  {
            // index defined for this column 
            return TRUE;
        }
    }

    //
    // Special case: If distinguishedName (OBJ-DIST-NAME) requested,
    // use the DNT index
    //

    if ( pAC->id == ATT_OBJ_DIST_NAME ) {

        strcpy(szIndexName, SZDNTINDEX);
        if ( !JetSetCurrentIndexWarnings(pDB->JetSessID,
                                        pDB->JetSearchTbl,
                                        szIndexName) ) {
            // index defined for this column 
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
dbFIsAlwaysPresent (
        ATTRTYP type
        )
/*++

Routine Description:

    Worker routine that tells callers whether an attrtyp is always present on an
    instantiated object (i.e. not a phantom).  Usually called from
    dbFlattenItemFilter to turn FI_CHOICE_PRESENT filter items into
    FI_CHOICE_TRUE filter items. 

Arguments:    

    type - attribute in question.

Return Value:
    
    TRUE if we think the attribute ALWAYS exists on objects.

--*/     
{
    switch(type) {
    case ATT_OBJECT_CLASS:
    case ATT_OBJECT_CATEGORY:
    case ATT_OBJ_DIST_NAME:
    case ATT_RDN:
    case ATT_OBJECT_GUID:
        return TRUE;
        break;
        
    default:
        return FALSE;
        break;
    }
}

BOOL
dbIsPresenceOnDisplayName (
        FILTER *pFil
        )
/*++
Description:
          Returns True if the itemfilter passed in implies a presence test of
          the DISPLAY_NAME attribute (i.e. Presence filter, Equality Filter,
          Greater Than/Less Than filter, etc.).

--*/     
{
    ATTRTYP type;
    
    if(pFil->choice != FILTER_CHOICE_ITEM) {
        return FALSE;
    }
    
    // Just a normal item filter.
    switch(pFil->FilterTypes.Item.choice) {
    case FI_CHOICE_TRUE:
    case FI_CHOICE_FALSE:
    case FI_CHOICE_UNDEFINED:
        return FALSE;
        break;
        
    case FI_CHOICE_SUBSTRING:
        type = pFil->FilterTypes.Item.FilTypes.pSubstring->type;
        break;
        
    case FI_CHOICE_GREATER_OR_EQ:
    case FI_CHOICE_GREATER:
    case FI_CHOICE_LESS_OR_EQ:
    case FI_CHOICE_LESS:
    case FI_CHOICE_EQUALITY:
    case FI_CHOICE_BIT_AND:
    case FI_CHOICE_BIT_OR:
        type = pFil->FilterTypes.Item.FilTypes.ava.type;
        break;

    case FI_CHOICE_PRESENT:
        type = pFil->FilterTypes.Item.FilTypes.present;
        break;
        
    default:
        // Huh?
        return FALSE;
    }
    
    return (type == ATT_DISPLAY_NAME);
}


#define OPT_FILTER_VALUE_OK      0
#define OPT_FILTER_VALUE_IGNORE  1
#define OPT_FILTER_VALUE_ERROR   2

DWORD
dbMakeValuesForOptimizedFilter (
        IN  THSTATE *pTHS,
        IN  DWORD   fParentFilterType,
        IN  BOOL    fFullValues,
        IN  FILTER  *pFil,
        IN  FILTER  *pFil2,
        OUT ATTRTYP *ptype,
        OUT UCHAR   **ppVal1,
        OUT UCHAR   **ppVal2,
        OUT ULONG   *pcbVal1,
        OUT ULONG   *pcbVal2
        )
/*++     
    Given a filter item, fill in the type and the appropriate values used to set
    a subrange.
    
    fParentFilterType -  the type of the parent filter:
                  FILTER_CHOICE_AND, FILTER_CHOICE_OR, FILTER_CHOICE_NOT, 
                  or
                  FILTER_CHOICE_ITEM
    
    fFullValues - if TRUE return full information regarding the filter,
                  otherwise (FALSE) return information only regarding the 
                  ATTR type of the filter (ptype variable).

    pFil1, pFil2 - Use these filters to extract the value contained in the filter
                   and put it in the ppVal?, pcbVal? variables
                   the pFil2 is used only when the pFil1 type is on of (<, <=, >, >=)
                   inorder to construct a range
                   If pFil1 is of type (<, <=) it is assumed the pFil2 will be 
                   of type (>, >=) and both will construct a range, with pFil2 
                   having the lower bound.
                   
                   Similarly, if pFil1 if of type (>, >=) it is assumed 
                   that pFil2 is (<, <=) and that pFil2 has the upper bound.

    ppVal1, ppVal2 - pointers to memory containing the data for this filter
    pcbVal1, pcBVal2 - size of the data               

    returns OPT_FILTER_VALUE_OK (which == 0) if all went well, an error
    otherwise.
--*/    
{
    DWORD i=0;
    DWORD dwTemp;
    DWORD cbTemp;
    PUCHAR pTemp=NULL;
    ULONGLONG ullTemp=0;
    LONGLONG llTemp=0;
    LONG     lTemp = 0;
    BOOL     bNeg;
    
    if(pFil->choice != FILTER_CHOICE_ITEM) {
        return OPT_FILTER_VALUE_OK;
    }
    
    // Just a normal item filter.
    switch(pFil->FilterTypes.Item.choice) {
    case FI_CHOICE_TRUE:
        // if we're doing an OR filter, then this means the whole OR is
        // non-optimizable.  If we're not doing an OR filter, we just skip it.
        if(fParentFilterType == FILTER_CHOICE_OR) {
            return OPT_FILTER_VALUE_ERROR;
        }
        else {
            return OPT_FILTER_VALUE_IGNORE;
        }
        break;
        
    case FI_CHOICE_FALSE:
        // If we're doing an OR filter, we can just skip this.  If we're not
        // doing an OR filter, make up some values that will get us an index
        // that hit's a single object.
        if(fParentFilterType == FILTER_CHOICE_OR) {
            return OPT_FILTER_VALUE_IGNORE;
        }
        else {
            // Pick an index, any index, which is simple to walk, and that
            // we can restrict to a single entry.  Here, we use the DNT
            // index and restrict to the base object.  That way, we don't
            // upset the rest of the code that walks indices during
            // searches, but we only look at one object ever.

            *ptype = ATT_OBJ_DIST_NAME;
            if (fFullValues) {
                *ppVal2 = *ppVal1 = (BYTE *)&pTHStls->pDB->Key.ulSearchRootDnt;
                *pcbVal2 = *pcbVal1 = sizeof(DWORD);
            }
        }
        break;
        
    case FI_CHOICE_SUBSTRING:
        if(!pFil->FilterTypes.Item.FilTypes.pSubstring->initialProvided) {
            return OPT_FILTER_VALUE_ERROR;
        }
        
        if (fFullValues) {
                *ppVal1 = pFil->FilterTypes.Item.FilTypes.pSubstring->InitialVal.pVal;
                *pcbVal1= pFil->FilterTypes.Item.FilTypes.pSubstring->InitialVal.valLen;
                *ppVal2 = pFil->FilterTypes.Item.FilTypes.pSubstring->InitialVal.pVal;
                *pcbVal2= pFil->FilterTypes.Item.FilTypes.pSubstring->InitialVal.valLen;
        }
        *ptype = pFil->FilterTypes.Item.FilTypes.pSubstring->type;
        break;
        
    case FI_CHOICE_GREATER_OR_EQ:
    case FI_CHOICE_GREATER:
        if (fFullValues) {
                *ppVal1 = pFil->FilterTypes.Item.FilTypes.ava.Value.pVal;
                *pcbVal1 = pFil->FilterTypes.Item.FilTypes.ava.Value.valLen;

                if (pFil2) {
                    *ppVal2 = pFil2->FilterTypes.Item.FilTypes.ava.Value.pVal;
                    *pcbVal2 = pFil2->FilterTypes.Item.FilTypes.ava.Value.valLen;
                }
                else {
                    *ppVal2 = NULL;
                    *pcbVal2 = 0;
                }
        }
        *ptype = pFil->FilterTypes.Item.FilTypes.ava.type;
        break;
        
    case FI_CHOICE_LESS_OR_EQ:
    case FI_CHOICE_LESS:
        if (fFullValues) {
                if (pFil2) {
                    *ppVal1 = pFil2->FilterTypes.Item.FilTypes.ava.Value.pVal;
                    *pcbVal1 = pFil2->FilterTypes.Item.FilTypes.ava.Value.valLen;
                }
                else {
                    *ppVal1 = NULL;
                    *pcbVal1 = 0;
                }
                *ppVal2 = pFil->FilterTypes.Item.FilTypes.ava.Value.pVal;
                *pcbVal2 = pFil->FilterTypes.Item.FilTypes.ava.Value.valLen;
        }
        *ptype = pFil->FilterTypes.Item.FilTypes.ava.type;
        break;
        
    case FI_CHOICE_EQUALITY:
        if (fFullValues) {
                *ppVal1 = pFil->FilterTypes.Item.FilTypes.ava.Value.pVal;
                *pcbVal1 = pFil->FilterTypes.Item.FilTypes.ava.Value.valLen;
                *ppVal2 = pFil->FilterTypes.Item.FilTypes.ava.Value.pVal;
                *pcbVal2 = pFil->FilterTypes.Item.FilTypes.ava.Value.valLen;
        }
        *ptype = pFil->FilterTypes.Item.FilTypes.ava.type;
        break;
        
    case FI_CHOICE_PRESENT:
        if (fFullValues) {
                *ppVal1 = NULL;
                *pcbVal1 = 0;
                *ppVal2 = NULL;
                *pcbVal2 = 0;
        }
        *ptype = pFil->FilterTypes.Item.FilTypes.present;
        break;
        
    case FI_CHOICE_BIT_AND:
        // Remember, Jet Indices over out int values are SIGNED,  So, if someone
        // is looking for BIT_AND 0000100000000000, that implies two ranges 
        // (16 bit numbers used for discussion only)
        // 0000100000000000 through 0111111111111111 and
        // 1000100000000000 through 1111111111111111
        // Anyway, we don't support mulitple ranges.  So, in this case, we can
        // only use the range 1000100000000000 through 0111111111111111, but
        // remember that 0111111111111111 is the end of the index.  So, if the
        // number passed in is positive, then the range is from the number
        // created by ORing in the highbit through the end of the index.
        //
        // If, on the other hand, the number passed already had the high bit set
        // (i.e is negative), then only the second range is valid.  So, in that
        // case, the optimized subrange is from the number passed in through -1.

        if (fFullValues) {
                switch(pFil->FilterTypes.Item.FilTypes.ava.Value.valLen) {
                case sizeof(LONG):
                    lTemp = *((LONG *)pFil->FilterTypes.Item.FilTypes.ava.Value.pVal);
                    bNeg = (lTemp < 0);
                    pTemp = THAllocEx(pTHS, sizeof(LONG));
                    cbTemp = sizeof(LONG);
                    if(bNeg) {
                        *((LONG *)pTemp) = -1;
                    }
                    else {
                        *((LONG *)pTemp) = 0x80000000 | lTemp;
                    }
                    break;

                case sizeof(ULONGLONG):
                    llTemp =
                        *((LONGLONG *) pFil->FilterTypes.Item.FilTypes.ava.Value.pVal);

                    bNeg = (llTemp < 0);
                    pTemp = THAllocEx(pTHS, sizeof(LONGLONG));
                    cbTemp = sizeof(LONGLONG);
                    if(bNeg) {
                        *((ULONGLONG *)pTemp) = ((LONGLONG)-1);
                    }
                    else {
                        *((ULONGLONG *)pTemp) = 0x8000000000000000 | llTemp;
                    }
                    break;

                default:
                    // Uh, this shouldn't really happen.  Don't bother optimizing
                    // anything, but then again, don't complain.
                    bNeg = FALSE;
                    cbTemp = 0;
                    pTemp = NULL;
                    break;
                }

                if(bNeg) {
                    // Range is from value passed in to -1.  -1 was already constructed
                    *ppVal1 = pFil->FilterTypes.Item.FilTypes.ava.Value.pVal;
                    *pcbVal1 = pFil->FilterTypes.Item.FilTypes.ava.Value.valLen;
                    *ppVal2 = pTemp;
                    *pcbVal2 = cbTemp;

                }
                else {
                    // Range is from (highbit | value passed in) to end of index.
                    // (highbit | value passed in) was already constructed.
                    *ppVal1 = pTemp;
                    *pcbVal1 = cbTemp;
                    *ppVal2 = NULL;
                    *pcbVal2 = 0;
                }
        }
        *ptype = pFil->FilterTypes.Item.FilTypes.ava.type;
        break;
        
    case FI_CHOICE_BIT_OR:
        // Remember, Jet Indices over out int values are SIGNED,  So, if someone
        // is looking for BIT_OR 0010100000000000, that implies two ranges
        // (16 bit numbers used for discussion only)
        // 0000100000000000 through 0111111111111111 and
        // 1000100000000000 through 1111111111111111
        // Anyway, we don't support mulitple ranges.  So, we can only optimize
        // this to one range.  The smallest single range is from
        // 1000100000000000 through 0111111111111111
        // Remember that 0111111111111111 is the end of the index.
        // So, the optimization is to find the lowest order bit, and create a
        // number that has ONLY that bit sit and the high order bit.  Then
        // search from there to the end of the index.

        if (fFullValues) {
                switch(pFil->FilterTypes.Item.FilTypes.ava.Value.valLen) {
                case sizeof(DWORD):
                    dwTemp = *((DWORD *)pFil->FilterTypes.Item.FilTypes.ava.Value.pVal);

                    pTemp = THAllocEx(pTHS, sizeof(DWORD));
                    if (dwTemp) {
                        while(!(dwTemp & 1)) {
                            dwTemp = dwTemp >> 1;
                            i++;
                        }
                        *((DWORD *)pTemp) = (1 << i);
                    } else {
                        *((DWORD *)pTemp) = 0;
                    }

                    cbTemp = sizeof(DWORD);
                    *((DWORD *)pTemp) |= 0x80000000;
                    break;

                case sizeof(ULONGLONG):
                    ullTemp =
                        *((ULONGLONG *) pFil->FilterTypes.Item.FilTypes.ava.Value.pVal);

                    pTemp = THAllocEx(pTHS, sizeof(LONGLONG));
                    
                    if (ullTemp) {
                        while(!(ullTemp & 1)) {
                            ullTemp = ullTemp >> 1;
                            i++;
                        }
                        *((ULONGLONG *)pTemp) = ((ULONGLONG)1 << i);
                    } else {
                        *((ULONGLONG *)pTemp) = 0;
                    }

                    cbTemp = sizeof(LONGLONG);
                    *((ULONGLONG *)pTemp) |= 0x8000000000000000;
                    break;

                default:
                    // Uh, this should really happen.  Don't bother optimizing anything,
                    // but then again, don't complain.
                    cbTemp = 0;
                    pTemp = NULL;
                }
                *ppVal1 = pTemp;
                *pcbVal1 = cbTemp;
                *ppVal2 = NULL;
                *pcbVal2 = 0;
        }

        *ptype = pFil->FilterTypes.Item.FilTypes.ava.type;
        break;
    
    case FI_CHOICE_UNDEFINED:
        
        // if we are doing an OR filter, we can ingore this.
        // if we are doing an AND or a nOT, it is an error
        // otherwise, devise a simple index and use it
        //

        if(fParentFilterType == FILTER_CHOICE_OR) {
            return OPT_FILTER_VALUE_IGNORE;
        }
        else if (fParentFilterType == FILTER_CHOICE_AND ||
                 fParentFilterType == FILTER_CHOICE_NOT) {
                    return OPT_FILTER_VALUE_ERROR;
        }
        else {
            // Pick an index, any index, which is simple to walk, and that
            // we can restrict to a single entry.  Here, we use the DNT
            // index and restrict to the base object.  That way, we don't
            // upset the rest of the code that walks indices during
            // searches, but we only look at one object ever.

            *ptype = ATT_OBJ_DIST_NAME;
            if (fFullValues) {
                *ppVal2 = *ppVal1 = (BYTE *)&pTHStls->pDB->Key.ulSearchRootDnt;
                *pcbVal2 = *pcbVal1 = sizeof(DWORD);
            }
        }
        break;
        
    default:
        // Hey, this isn't really optimizable
        return OPT_FILTER_VALUE_ERROR;
    }

    return OPT_FILTER_VALUE_OK;
}

BOOL 
IsFilterOptimizable (
    THSTATE *pTHS,
    FILTER  *pFil)
{
    ATTCACHE   *pAC = NULL;
    ATTRTYP     type = -1;  // init to non-existent attid
    UCHAR      *pVal1;
    UCHAR      *pVal2;
    ULONG       cbVal1;
    ULONG       cbVal2;
    DWORD       filterSubType;
    
    // when the filter is of type ITEM, we can only optimize it if it
    // is of one of the following subtypes.
    if ( pFil->choice == FILTER_CHOICE_ITEM ) {

        if(  ( (filterSubType = pFil->FilterTypes.Item.choice) == FI_CHOICE_EQUALITY) ||
             (filterSubType == FI_CHOICE_SUBSTRING)     ||
             (filterSubType == FI_CHOICE_GREATER)       ||
             (filterSubType == FI_CHOICE_GREATER_OR_EQ) ||
             (filterSubType == FI_CHOICE_LESS)          ||
             (filterSubType == FI_CHOICE_LESS_OR_EQ)    ||
             (filterSubType == FI_CHOICE_PRESENT)       ||
             (filterSubType == FI_CHOICE_BIT_OR)        ||
             (filterSubType == FI_CHOICE_BIT_AND)     ) {

            // See if this item is indexed.
            if (dbMakeValuesForOptimizedFilter (pTHS, 
                                                FILTER_CHOICE_ITEM, 
                                                FALSE,
                                                pFil,
                                                NULL,
                                                &type, 
                                                &pVal1,
                                                &pVal2,
                                                &cbVal1,
                                                &cbVal2) == OPT_FILTER_VALUE_OK) {

                // find the att in schema cache
                if (!(pAC = SCGetAttById(pTHS, type))) {
                    DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, type);
                }
                // check if we have an index on this property so we can optimize it
                //
                else if (   (pAC->fSearchFlags & fATTINDEX) ||
                            (pAC->fSearchFlags & fPDNTATTINDEX && 
                             pTHS->pDB->Key.ulSearchType == SE_CHOICE_IMMED_CHLDRN) ){

                    return TRUE;
                }


                // we already have an index for this which is used in dbSetToIndex
                if (pAC->id == ATT_OBJ_DIST_NAME) {
                    return TRUE;
                }
            }

            //
            // If it's a SUBSTRING filter there may be a tuple index.
            //
            if (filterSubType == FI_CHOICE_SUBSTRING) {
                // find the att in schema cache
                if (!pAC && !(pAC = SCGetAttById(pTHS, pFil->FilterTypes.Item.FilTypes.pSubstring->type))) {
                    DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, type);
                }
                // check if we have an index on this property so we can optimize it
                //
                else if (pAC->fSearchFlags & fTUPLEINDEX) {

                    return TRUE;
                }
            }
        }
    }
    // this filter has something other than an ITEM, or it is not optimizable
    
    return FALSE;
}


DWORD
dbOptOrFilter (
        DBPOS *pDB,
        DWORD Flags,
        KEY_INDEX **ppBestIndex,
        FILTER *pFil
        )
/*++
    The filter is an OR of at least one index property.  Create the list of
    index ranges for this filter.
    
--*/
{
    DWORD      count1, count2;
    ATTCACHE  *pAC;
    ATTRTYP    type;
    UCHAR     *pVal1;
    UCHAR     *pVal2;
    ULONG      cbVal1;
    ULONG      cbVal2;
    BOOL       fPDNT;
    char       szIndexName[MAX_INDEX_NAME];
    FILTER    *pFilTemp, *pFilTemp2;
    BOOL       fNotIndexable = TRUE;
    KEY_INDEX *pAndIndex=NULL;
    KEY_INDEX *pNewIndex=NULL;
    KEY_INDEX *pIndices=NULL;
    THSTATE    *pTHS=pDB->pTHS;
    INDEX_RANGE IndexRange;       
    BOOL        needRecordCount;
    KEY_INDEX *pTemp1, *pTemp2;
    DWORD      err;
    
    Assert(VALID_DBPOS(pDB));
    Assert(ppBestIndex);

    DPRINT(2, "dbOptORFilter: entering OR\n");

    // Preliminary check, that the or is over only ITEM filters or
    // AND filters which contain at least one indexable item.
    // If the OR filter is over AND filters that cannot be indexed,
    // there is no meaning in continuing with the optimization 
    // and we can fallback to the default index (Ancestors)
    count1 = pFil->FilterTypes.Or.count;
    for (pFilTemp = pFil->FilterTypes.Or.pFirstFilter; count1;
         count1--, pFilTemp = pFilTemp->pNextFilter) {
        
        switch(pFilTemp->choice) {
        case FILTER_CHOICE_ITEM:
            break;

        case FILTER_CHOICE_AND:
            // This is optimizable if there is at least one indexed
            // attribute in the AND.
            fNotIndexable = TRUE;
            count2 = pFilTemp->FilterTypes.And.count;
            for (pFilTemp2 = pFilTemp->FilterTypes.And.pFirstFilter;
                 (fNotIndexable && count2);
                 count2--, pFilTemp2 = pFilTemp2->pNextFilter) {
                
                if(pFilTemp2->choice == FILTER_CHOICE_ITEM) {
                    
                    // See if this item is indexed.

                    if (dbMakeValuesForOptimizedFilter (pTHS, 
                                                        FILTER_CHOICE_AND, 
                                                        FALSE,
                                                        pFilTemp2,
                                                        NULL,
                                                        &type, 
                                                        &pVal1,
                                                        &pVal2,
                                                        &cbVal1,
                                                        &cbVal2) == OPT_FILTER_VALUE_OK) {

                        // find the att in schema cache
                        if (!(pAC = SCGetAttById(pTHS, type))) {
                            DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, type);
                        }
                        // well, this is an indication that there is some kind of index 
                        // on this attribute. if not, we will error later
                        else if ((pAC->fSearchFlags & fATTINDEX) ||
                                 (pAC->fSearchFlags & fPDNTATTINDEX && 
                                  pDB->Key.ulSearchType == SE_CHOICE_IMMED_CHLDRN)) {
                            fNotIndexable = FALSE;
                        }
                    }
                    else if (pFilTemp2->FilterTypes.Item.choice == FI_CHOICE_UNDEFINED) {
                        // this is an AND with an Undefined term. continue as usual
                        fNotIndexable = FALSE;
                        break;
                    }
                }
            }
            if(fNotIndexable) {
                DPRINT1 (2, "dbOptOrFilter: OR Branch not optimizable (no index for attribute: 0x%x)\n", type);
                return 0;
            }
            break;
        default:
            // Not optimizable
            DPRINT(2, "dbOptOrFilter: OR Branch not optimizable \n");
            return 0;
            break;
        }
    }
    
    // Now, loop over each index and get the key_index structure.
    count1 = pFil->FilterTypes.Or.count;
    for (pFil = pFil->FilterTypes.Or.pFirstFilter;
         count1;
         count1--, pFil = pFil->pNextFilter) {

        switch(pFil->choice) {
        case FILTER_CHOICE_ITEM:
            DPRINT(2, "dbOptOrFilter: ITEM \n");
            break;
        case FILTER_CHOICE_AND:
            
            // We already know that at least one of the things in this index
            // should be indexable. call dbOptFilter to do the hard work.
            // if it return an error, then we forget all the indexes,
            // otherwise we continue with the next filter.

            err = dbOptAndFilter(pDB,
                                 Flags,
                                 &pAndIndex,
                                 pFil);

            if (err) {
                    DPRINT (2, "dbOptOrFilter: Error Optimizing AND branch\n");

                    // we had an error optimizing this branch, exit optimization
                    dbFreeKeyIndex(pTHS, pIndices);
                    return 0;
            }
            else if(!pAndIndex) {
                // we didn't had an error optimizing this branch, but we got no 
                // result to work with. try next one, since we are in an OR
                
                DPRINT (2, "dbOptOrFilter: AND branch not optimizable\n");
                
                continue;
            }

            break;
        default:
            // Huh? how did this get here?
            DPRINT(2, "dbOptOrFilter: OTHER->ERROR \n");
            dbFreeKeyIndex(pTHS, pIndices);
            return DB_ERR_NOT_OPTIMIZABLE;
        }

        if(pAndIndex) {
            // we did an and optimization

            #if DBG

            {
            KEY_INDEX *pIndex = pAndIndex;

                while(pIndex) {
                    if(pIndex->szIndexName) {
                        DPRINT1 (2, "dbOptOrFilter: AND queue index %s\n", pIndex->szIndexName);
                    }
                    pIndex = pIndex->pNext;
                }
            }
            #endif
        
            pNewIndex = pAndIndex;
            pAndIndex = NULL;
        }
        else {
            // A normal Item optimization

            pNewIndex = NULL;

            // this is an undefined in the OR. skip it
            if ((pFil->FilterTypes.Item.choice == FI_CHOICE_UNDEFINED)) {
                continue;
            }

            if (pFil->FilterTypes.Item.choice == FI_CHOICE_SUBSTRING) {
                err = dbOptSubstringFilter(pDB,
                                           FILTER_CHOICE_OR,
                                           Flags,
                                           &pNewIndex,
                                           NULL,
                                           pFil);
            } else {
                err = dbOptItemFilter(pDB,
                                      FILTER_CHOICE_OR, 
                                      Flags,
                                      &pNewIndex,
                                      pFil,
                                      NULL);
            }

            // we didn't manage to find an index for this item
            //
            if (err || !pNewIndex) {
                DPRINT(2, "dbOptOrFilter: Couldn't optimize ITEM filter.\n");
                dbFreeKeyIndex(pTHS, pIndices);
                return DB_ERR_NOT_OPTIMIZABLE;
            }
        }
        
        if(pIndices) {
            // Note that ulEstimatedRecsInRange is the estimate of ALL the
            // records in range in the rest of the indices in the chain.  
            pNewIndex->ulEstimatedRecsInRange +=
                pIndices->ulEstimatedRecsInRange;

            DPRINT1(2, "dbOptOrFilter: TOTAL in OR: %d \n", pNewIndex->ulEstimatedRecsInRange);
        }

        // we have a queue of indexes, so add the indexes in the correct place

        pTemp1 = pNewIndex;
        pTemp2 = NULL;

        while(pTemp1) {
            pTemp2 = pTemp1;
            pTemp1 = pTemp1->pNext;
        }

        Assert (pTemp2);
        
        pTemp2->pNext = pIndices;
        pIndices = pNewIndex;

        if(*ppBestIndex &&
           (pNewIndex->ulEstimatedRecsInRange >
            (*ppBestIndex)->ulEstimatedRecsInRange)) {
            // Darn, this OR is bigger than the best we had so far.

            DPRINT(2, "dbOptOrFilter: BIGGER than best so far\n");
            dbFreeKeyIndex(pTHS, pIndices);
            return 0;
        }
    }

    if(*ppBestIndex) {
        DPRINT2(2, "dbOptOrFilter: freeing previous filter %s %d\n",(*ppBestIndex)->szIndexName, (*ppBestIndex)->ulEstimatedRecsInRange);
        dbFreeKeyIndex(pTHS, *ppBestIndex);
    }

    *ppBestIndex = pIndices;

#if DBG

    {
        KEY_INDEX *pIndex = pIndices;

        while(pIndex) {
            if(pIndex->szIndexName) {
                DPRINT1 (2, "dbOptOrFilter: queue index %s\n", pIndex->szIndexName);
            }
            pIndex = pIndex->pNext;
        }
    }

#endif

    return 0;
}

DWORD
dbOptDoIntersection (
        DBPOS     *pDB,
        DWORD     Flags,
        KEY_INDEX **ppBestIndex,
        KEY_INDEX **ppIntersectIndexes,
        int       cntIntersect
        )
/*++
    The filter is an AND of indexed properties.  
    Try evaluating this filter using JetIntersectIndexes.
--*/
{
    THSTATE     *pTHS=pDB->pTHS;
    USHORT       count;
    JET_ERR      err;
    BOOL         fReturnSuccess = FALSE;

    KEY_INDEX    *pIndex = NULL;
    
    JET_RECORDLIST  recordlist;
    JET_INDEXRANGE      *rgindexrange;
    JET_TABLEID     tmpSrchTable = -1;

    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;


    Assert (cntIntersect >= 2);

    DPRINT1 (2, "dbOptDoIntersection: Attempting intersection of %d indexes\n", cntIntersect);

#ifdef DBG
    DPRINT(2, "Intersecting the following indexes: \n");
    for (count=0; count<cntIntersect; count++) {
        DPRINT2(2, "  %s %d\n", ppIntersectIndexes[count]->szIndexName, ppIntersectIndexes[count]->ulEstimatedRecsInRange); 
    }
#endif

    rgindexrange = dbAlloc (sizeof (JET_INDEXRANGE) * cntIntersect);
    if (!rgindexrange) {
        return 1;
    }
    memset (rgindexrange, 0, sizeof (JET_INDEXRANGE) * cntIntersect);

    __try {
        for (count=0; count < cntIntersect; count++ ){

            pIndex = ppIntersectIndexes[count];

            // we duplicate the current cursor so as to leave pDB with one valid searchTable,
            // since we close all cursors at the end

            // keep current searchTable somewhere for later
            tmpSrchTable = pDB->JetSearchTbl;

            // duplicate it
            if (err = JetDupCursor(pDB->JetSessID, 
                                   pDB->JetSearchTbl, 
                                   &rgindexrange[count].tableid, 
                                   0)) {

                rgindexrange[count].tableid = 0;
                break;
            }

            // put it on pDB so as everything will function using this duplicated cursor
            pDB->JetSearchTbl = rgindexrange[count].tableid;

            rgindexrange[count].cbStruct = sizeof( JET_INDEXRANGE );
            rgindexrange[count].grbit = JET_bitRecordInIndex;


            // set to appropriate index 
            //

            JetSetCurrentIndexSuccess(pDB->JetSessID, pDB->JetSearchTbl,
                                      pIndex->szIndexName);

                
            // Move to the start of this index
            //
            if (pIndex->cbDBKeyLower) {
                JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl,
                                 pIndex->rgbDBKeyLower,
                                 pIndex->cbDBKeyLower,
                                 JET_bitNormalizedKey);
                    
                // this call might fail, if we can't find any records
                err = JetSeekEx(pDB->JetSessID, pDB->JetSearchTbl,
                                    JET_bitSeekGE); 
            }
            else {
                // this call might fail, if we can't find any records
                err = JetMoveEx(pDB->JetSessID, pDB->JetSearchTbl,
                                    JET_MoveFirst, 0);
            }
                
            if ((err == JET_errSuccess) || 
                (err == JET_wrnRecordFoundGreater)) {

                // move to the upper bound
                if (pIndex->cbDBKeyUpper) {

                    JetMakeKeyEx( pDB->JetSessID, 
                            pDB->JetSearchTbl,
                            pIndex->rgbDBKeyUpper,
                            pIndex->cbDBKeyUpper,                 
                            JET_bitNormalizedKey );

                    err = JetSetIndexRange( pDB->JetSessID, 
                                            pDB->JetSearchTbl, 
                                            JET_bitRangeUpperLimit  //| JET_bitRangeInclusive 
                                            );

                    if ( (err != JET_errSuccess) && (err != JET_errNoCurrentRecord)) {
                        // return pDB->searchtable to original value
                        pDB->JetSearchTbl = tmpSrchTable;
                        break;
                    }
                    err = JET_errSuccess;
                }
            }

            else {
                // no records. so there is no point in intersecting
                // return pDB->searchtable to original value
                pDB->JetSearchTbl = tmpSrchTable;

                // we should flag this function as succesfull, since the fact that
                // we found no records in the AND filter is not bad. 
                // as a result the passed in BestIndex remains the same
                fReturnSuccess = TRUE;

                break;
            }

            // return pDB->searchtable to original value
            pDB->JetSearchTbl = tmpSrchTable;
            tmpSrchTable = -1;
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);

        DPRINT1 (2, "Failed while preparing AND intersection at %d index\n", count);

        err = 1;

        // return pDB->searchtable to original value
        if (tmpSrchTable != -1) {
            pDB->JetSearchTbl = tmpSrchTable;
        }
    }

    
    __try {
        if (!err) {
            // They should be the same. otherwise we shouldn't be here
            Assert ( count == cntIntersect );

            DPRINT1 (2, "Intersecting %d indexes\n", cntIntersect);

            // do the intersection of these indexes
            memset (&recordlist, 0, sizeof (recordlist));
            recordlist.cbStruct = sizeof( recordlist );
            if (!(err = JetIntersectIndexes( pDB->JetSessID, 
                                             rgindexrange, 
                                             cntIntersect, 
                                             &recordlist, 0) ) )
            {
                LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_QUERY_INDEX_CONSIDERED,
                         szInsertSz(c_szIntersectIndex),   // maybe construct full string
                         szInsertUL(recordlist.cRecord),
                         NULL);

                DPRINT1 (2, "Estimated intersect index size: %d\n", recordlist.cRecord);

                // see if it has better results than what we have so far
                //
                if(!(*ppBestIndex) ||
                   (recordlist.cRecord < (*ppBestIndex)->ulEstimatedRecsInRange)) {
                    // yes - it sure looks that way...

                    if(*ppBestIndex) {
                        dbFreeKeyIndex(pDB->pTHS, *ppBestIndex);
                    }
                    pIndex = *ppBestIndex = dbAlloc(sizeof(KEY_INDEX));
                    pIndex->pNext = NULL;
                    pIndex->ulEstimatedRecsInRange = recordlist.cRecord;
                    pIndex->szIndexName = dbAlloc(cIntersectIndex + 1);
                    strcpy(pIndex->szIndexName, c_szIntersectIndex);
                    
                    pIndex->bIsIntersection = TRUE;
                    pIndex->tblIntersection = recordlist.tableid;
                    Assert (pIndex->tblIntersection);
                    pIndex->columnidBookmark = recordlist.columnidBookmark;

                    #if DBG
                    pDB->numTempTablesOpened++;
                    #endif
                }
                else {
                    // nop. it is not good, so close temp table
                    JetCloseTable (pDB->JetSessID, recordlist.tableid );
                    recordlist.tableid = 0;
                }
            }
            else if (err == JET_errNoCurrentRecord) {
                // this means that the Intersect found no common record on both indexes. cool.
                err = JET_errSuccess;
            }
            else {
                DPRINT1 (2, "JetIntersectIndexes: returned %d\n", err);
            }
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);

        DPRINT1 (0, "Failed while doing AND intersection for %d indexes\n", cntIntersect);
    }

    // free stuff. close tables
    for (count=0; count<cntIntersect; count++) {
        if (rgindexrange[count].tableid) {
            JetCloseTable (pDB->JetSessID, rgindexrange[count].tableid);
        }
    }
    dbFree (rgindexrange);

    if (fReturnSuccess) {
        err = JET_errSuccess;
    }

    // done
    return err;
}

DWORD
dbOptAndIntersectFilter (
        DBPOS     *pDB,
        DWORD     Flags,
        KEY_INDEX **ppBestIndex,
        KEY_INDEX **ppIntersectIndexes,
        DWORD     cntPossIntersect
        )
/*++
    Takes a set of indexes that can potentially be intersected, puts the indexes
    in order, determines whether intersection is warranted, and if so performs
    the intersection.  This function has the side affect of sorting the list of 
    indexes passed in.
--*/
{
    THSTATE     *pTHS=pDB->pTHS;
    
    DWORD       count, count2;
    DWORD       err = 0;
    BOOL        fNotAbleToIntersect = FALSE;

    if (cntPossIntersect < 2) {
        if (cntPossIntersect == 0) {
            return err;
        }
        fNotAbleToIntersect = TRUE;
    }

    // sort the array of candidate indexes on EstimatedRecsInRange
    //

    DPRINT(2, "dbOptAndIntersectFilter: Sorting Array\n");

    for (count=0; count<(cntPossIntersect-1); count++) {
        ULONG numRecs;
        KEY_INDEX  *tmpIndex;

        if (!ppIntersectIndexes[count]) {
            continue;
        }

        numRecs = ppIntersectIndexes[count]->ulEstimatedRecsInRange;

        for (count2=count+1; count2<cntPossIntersect; count2++) {

            if (ppIntersectIndexes[count2] && 
                ppIntersectIndexes[count2]->ulEstimatedRecsInRange < numRecs) {

                tmpIndex = ppIntersectIndexes[count];
                ppIntersectIndexes[count] = ppIntersectIndexes[count2];
                ppIntersectIndexes[count2] = tmpIndex;

                numRecs = ppIntersectIndexes[count]->ulEstimatedRecsInRange;
            }
        }
    }

#if DBG
    // the best index should be in pos 0
    // the worst index should be in pos cntPossIntersect-1
    for (count=1; count<cntPossIntersect-1; count++) {
        if (  (ppIntersectIndexes[count]->ulEstimatedRecsInRange < 
               ppIntersectIndexes[0]->ulEstimatedRecsInRange)             ||
              (ppIntersectIndexes[cntPossIntersect-1]->ulEstimatedRecsInRange < 
               ppIntersectIndexes[count]->ulEstimatedRecsInRange)           ) {

            Assert (!"Sort Order Bad\n");
        }
    }
#endif


    // we cannot use index intersection when:
    // a) the number of optimizable indexes is less that two
    // b) global flags say so
    // c) we already have an index that is small enough without intersection.
    // this is a double negation, but it is better than an AND with 4 components
    
    fNotAbleToIntersect =  fNotAbleToIntersect ||
                           (Flags & DBOPTINDEX_fDONT_INTERSECT) ||
                           cntPossIntersect<2 ||
                           !gfUseIndexOptimizations ||
                           ppIntersectIndexes[0]->ulEstimatedRecsInRange < gulMaxRecordsWithoutIntersection; 




    // check the result of all indexes and try to find the ratio between 
    // the best and the worst one, and decide whether it is worth it to
    // go for the brute force way (visiting each entry), or is better for
    // Jet to cut some entries (using Intersections)
    //
    if (!fNotAbleToIntersect) {

        // the best index should be in pos 0 due to sorting
        // the worst index should be in pos cntIntersect-1
        //
        unsigned cntIntersect = cntPossIntersect;
        Assert (cntIntersect>=2);

        DPRINT(2, "dbOptAndIntersectFilter: Investigating use of Intersections\n");

        if (cntIntersect>2) {

            ULONG  bestSoFar = ppIntersectIndexes[0]->ulEstimatedRecsInRange;

            for (count=cntIntersect-1; count>0; count--) {

                // this is not a very good index, so we have better stop
                //
                if (bestSoFar * gulInteserctExpenseRatio > ppIntersectIndexes[count]->ulEstimatedRecsInRange) {
                    cntIntersect = count + 1;
                    break;
                }
            }
            if (count==0) {
                cntIntersect = 0;
                fNotAbleToIntersect = TRUE;
                DPRINT(2, "dbOptAndIntersectFilter: Intersection not advisable.\n");
            }
        }

        if (cntIntersect > 0) {
            cntIntersect = min(cntIntersect, MAX_NUMBER_INTERSECTABLE_INDEXES);
            // there is no need for using ShowInAddressBook index, 
            // since we have other indexes to use

            DPRINT1(2, "dbOptAndIntersectFilter: Attempting to intersect %d indexes\n", cntIntersect);
            err = dbOptDoIntersection(pDB,
                          FALSE,
                          ppBestIndex,
                          ppIntersectIndexes,
                          cntIntersect);
        }
    }

    // If we managed to do an intersection then that is the best index to return.
    // Other wise compare the first index in the list to ppBestIndex and return 
    // the best one.
    if (fNotAbleToIntersect) {
        if(!(*ppBestIndex)
           || (*ppBestIndex)->ulEstimatedRecsInRange < ppIntersectIndexes[0]->ulEstimatedRecsInRange) {
            dbFreeKeyIndex(pTHS, *ppBestIndex);
            *ppBestIndex = ppIntersectIndexes[0];
            ppIntersectIndexes[0] = NULL;
        }
    }

    return err;
}

// This is the the min tuple length in bytes for unicode strings, the only syntax
// currently supported.
#define DB_UNICODE_TUPLES_LEN_MIN  (sizeof(WCHAR) * DB_TUPLES_LEN_MIN)


DWORD
dbOptSubstringFilter (
        DBPOS *pDB,
        DWORD  fParentFilterType,
        DWORD Flags,
        KEY_INDEX **ppBestIndex,
        DWORD  *pIndexCount,
        FILTER *pFil
        )
/*++
    This filter is a SUBSTRING filter which can be made up of several parts.
    Create the list of index ranges for this filter.
    
    If the caller passed a value for pIndexCount, return the list of indexes
    so that the caller can decide whether to intersect the substring indexes
    with any other indexes available from an AND clause.
    
    Otherwise if pIndexCount is NULL, decide whether to intersect just these
    indexes and return either the intersected index, or the best index out of
    the list of indexes.
    
    For the time being this function only picks the best of the tuple index
    ranges.  It might make sense to revisit this if support is ever added in
    Jet for intersecting an index range with another index range on the same
    index.
        
--*/
{
    THSTATE         *pTHS=pDB->pTHS;    

    DWORD           err;
    DWORD           countIndexes = 0;
    DWORD           count;
    BOOL            fTupleIndex = FALSE;
    KEY_INDEX       *pLocalBestIndex = NULL;
    KEY_INDEX       *pIndexList, *pTempIndex, *pCurIndex;
    KEY_INDEX       *pBestTupleIndex = NULL;
    KEY_INDEX       **ppIntersectIndexes;
    SUBSTRING       *pSubstring;
    INDEX_RANGE     IndexRange;
    ATTCACHE        *pAC;
    char            szTupleIndexName[MAX_INDEX_NAME];
    BOOL            fError = FALSE;

    pSubstring = pFil->FilterTypes.Item.FilTypes.pSubstring;

    // find the att in schema cache
    if (!(pAC = SCGetAttById(pTHS, pSubstring->type))) {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, pSubstring->type);
    }

    // Get any initial string index if one exists.
    err = dbOptItemFilter(pDB, fParentFilterType, Flags, &pLocalBestIndex, pFil, NULL);

    if (Flags & DBOPTINDEX_fDONT_OPT_MEDIAL_SUBTSTRING) {
        goto LeaveOnNoTupleIndex;
    }
    
    if (pSubstring->AnyVal.count || pSubstring->finalProvided || !pLocalBestIndex) {
        // Find out if there is a tuple index for this attribute.
        fTupleIndex = dbSetToTupleIndex(pDB, pAC, szTupleIndexName);
    }

    if ( !fTupleIndex 
         || (pLocalBestIndex
             && !pSubstring->finalProvided
             && !pSubstring->AnyVal.count)) {
        //
        // One of two cases:
        // 1. There's only an initial substring filter and we have an index for
        // it from dbOptItemFilter.
        // 2. There's no tuple index so there's no point in continuing.
        // See if we've managed to get a better index and then return.
        //
        goto LeaveOnNoTupleIndex;
    }

    // At this point we know that we have a Tuple index.

    if (!pLocalBestIndex 
        && pSubstring->initialProvided
        && pSubstring->InitialVal.valLen >= DB_UNICODE_TUPLES_LEN_MIN) {
        // There's an initial substring, but we don't have a regular index
        // over this attribute.  If the initial substring is long enough
        // we'll use the tuple index instead.

        IndexRange.cbValLower = pSubstring->InitialVal.valLen;
        IndexRange.pvValLower = pSubstring->InitialVal.pVal;
        IndexRange.cbValUpper = pSubstring->InitialVal.valLen;
        IndexRange.pvValUpper = pSubstring->InitialVal.pVal;
        
        pTempIndex =
            dbMakeKeyIndex(pDB,
                           pFil->FilterTypes.Item.choice,
                           pAC->isSingleValued,
                           0,
                           szTupleIndexName,
                           TRUE,
                           1,  // only one component in the index range
                           &IndexRange
                           );
        if (!pTempIndex) {
            DPRINT1(0, "dbOptSubstringFilter: Failed to create KEY_INDEX for tuple index on att %s\n",
                    pAC->name);
            goto LeaveOnNoTupleIndex;
        } else {
            pTempIndex->pAC = pAC;
            pTempIndex->bIsTupleIndex = TRUE;

            if (!pBestTupleIndex
                || pBestTupleIndex->ulEstimatedRecsInRange > pTempIndex->ulEstimatedRecsInRange) {
                dbFreeKeyIndex(pTHS, pBestTupleIndex);
                pBestTupleIndex = pTempIndex;
            }
        }

    }

    //
    // Build KEY_INDEXES for medial substring filters.
    //
    if (pSubstring->AnyVal.count) {
        ANYSTRINGLIST   *pAnyString;

        if (pSubstring->AnyVal.FirstAnyVal.AnyVal.valLen >= DB_UNICODE_TUPLES_LEN_MIN) {
            // Get the first medial substring.
            IndexRange.cbValLower = pSubstring->AnyVal.FirstAnyVal.AnyVal.valLen;
            IndexRange.pvValLower = pSubstring->AnyVal.FirstAnyVal.AnyVal.pVal;
            IndexRange.cbValUpper = pSubstring->AnyVal.FirstAnyVal.AnyVal.valLen;
            IndexRange.pvValUpper = pSubstring->AnyVal.FirstAnyVal.AnyVal.pVal;

            pTempIndex =
                dbMakeKeyIndex(pDB,
                               pFil->FilterTypes.Item.choice,
                               pAC->isSingleValued,
                               0,
                               szTupleIndexName,
                               TRUE,
                               1,  // only one component in the index range
                               &IndexRange
                               );

            if (!pTempIndex) {
                DPRINT1(0, "dbOptSubstringFilter: Failed to create KEY_INDEX for tuple index on att %s\n",
                        pAC->name);
                fError = TRUE;
            } else {
                pTempIndex->pAC = pAC;
                pTempIndex->bIsTupleIndex = TRUE;

                if (!pBestTupleIndex
                    || pBestTupleIndex->ulEstimatedRecsInRange > pTempIndex->ulEstimatedRecsInRange) {
                    dbFreeKeyIndex(pTHS, pBestTupleIndex);
                    pBestTupleIndex = pTempIndex;
                }
            }
        }


        if (!fError) {
            pAnyString = pSubstring->AnyVal.FirstAnyVal.pNextAnyVal;

            // Get the rest of the medial substrings.
            while (pAnyString) {
                
                // If the substring is too small don't bother
                // making a KEY_INDEX
                if (pAnyString->AnyVal.valLen >= DB_UNICODE_TUPLES_LEN_MIN) {
                    
                    IndexRange.cbValLower = pAnyString->AnyVal.valLen;
                    IndexRange.pvValLower = pAnyString->AnyVal.pVal;
                    IndexRange.cbValUpper = pAnyString->AnyVal.valLen;
                    IndexRange.pvValUpper = pAnyString->AnyVal.pVal;

                    pTempIndex =
                        dbMakeKeyIndex(pDB,
                                       pFil->FilterTypes.Item.choice,
                                       pAC->isSingleValued,
                                       0,
                                       szTupleIndexName,
                                       TRUE,
                                       1,  // only one component in the index range
                                       &IndexRange
                                       );

                    if (pTempIndex) {
                        pTempIndex->pAC = pAC;
                        pTempIndex->bIsTupleIndex = TRUE;
                        if (!pBestTupleIndex
                            || pBestTupleIndex->ulEstimatedRecsInRange > pTempIndex->ulEstimatedRecsInRange) {
                            dbFreeKeyIndex(pTHS, pBestTupleIndex);
                            pBestTupleIndex = pTempIndex;
                        }
                    } else {
                        //
                        // There's no reason to continue.
                        //
                        DPRINT1(0, "dbOptSubstringFilter: Failed to create KEY_INDEX for tuple index on att %s\n",
                                pAC->name);
                        pAnyString = NULL;
                        fError = TRUE;
                    }
                }
                // move to the next medial substring
                pAnyString = pAnyString->pNextAnyVal;
            }
        }

    }

    // If there is a final substring set that up.
    if (!fError
        && pSubstring->finalProvided
        && pSubstring->FinalVal.valLen >= DB_UNICODE_TUPLES_LEN_MIN) {

        IndexRange.cbValLower = pSubstring->FinalVal.valLen;
        IndexRange.pvValLower = pSubstring->FinalVal.pVal;
        IndexRange.cbValUpper = pSubstring->FinalVal.valLen;
        IndexRange.pvValUpper = pSubstring->FinalVal.pVal;

        pTempIndex =
        dbMakeKeyIndex(pDB,
                       pFil->FilterTypes.Item.choice,
                       pAC->isSingleValued,
                       0,
                       szTupleIndexName,
                       TRUE,
                       1,  // only one component in the index range
                       &IndexRange
                      );

        if (!pTempIndex) {
            DPRINT1(0, "dbOptSubstringFilter: Failed to create KEY_INDEX for tuple index on att %s\n",
                    pAC->name);
        } else {
            pTempIndex->pAC = pAC;
            pTempIndex->bIsTupleIndex = TRUE;
            if (!pBestTupleIndex
                || pBestTupleIndex->ulEstimatedRecsInRange > pTempIndex->ulEstimatedRecsInRange) {
                dbFreeKeyIndex(pTHS, pBestTupleIndex);
                pBestTupleIndex = pTempIndex;
            }
        }
    }

    if (pBestTupleIndex) {
        countIndexes = 1;
    }
    if (pLocalBestIndex) {
        pIndexList = pLocalBestIndex;
        pIndexList->pNext = pBestTupleIndex;
        countIndexes++;
    } else {
        pIndexList = pBestTupleIndex;
    }

    if (fError || !pIndexList) {
        // For some reason we couldn't make use of the tuple index.
        goto LeaveOnNoTupleIndex;
    }

    //
    // We now have a list of KEY_INDEXES we can use for this filter.
    // Now decide whether to intersect them or not.
    // 
    if (pIndexCount) {
        // The caller is willing to accept a list of indexes which means that
        // they are willing to attempt the intersection themselves.  Time to go
        // home.
        *pIndexCount = countIndexes;
        *ppBestIndex = pIndexList;
        DPRINT1(2, "dbOptSubstringFilter: returning a linked list of %d filters\n", countIndexes);
        return 0;
    }

    //
    // If we made it to here, then we are considering intersecting indexes.
    //

    if (countIndexes == 1) {
        DPRINT(2, "dbOptSubstringFilter: returning a single filter\n");
        //
        // There's only one index, so go ahead and return it.
        //
        pLocalBestIndex = pIndexList;
        goto LeaveOnNoTupleIndex;
    }


    // Put all the potential KEY_INDEXES pointers into an array so that they
    // can be passed to the intersection routine.
    ppIntersectIndexes = THAllocEx(pTHS, sizeof(KEY_INDEX *) * countIndexes);
    pCurIndex = pIndexList;
    for (count=0; count < countIndexes; count++) {
        ppIntersectIndexes[count] = pCurIndex;
        pCurIndex = pCurIndex->pNext;
        ppIntersectIndexes[count]->pNext = NULL;
    }

    // Intersect if possible.
    DPRINT1(2, "dbOptSubstringFilter: calling dbOptAndIntersectFilter with %d KEY_INDEX's\n", countIndexes);
    err = dbOptAndIntersectFilter (pDB,
                                   Flags,
                                   ppBestIndex,
                                   ppIntersectIndexes,
                                   countIndexes
                                   );

    // Free the rest of the indexes
    for (count=1; count<countIndexes; count++) {
        if (ppIntersectIndexes[count]) {
            dbFreeKeyIndex(pTHS, ppIntersectIndexes[count]);
        }
    }

    return err;

LeaveOnNoTupleIndex:

// Check to see if we found a better index or not.
    if (pLocalBestIndex) {
        if (!(*ppBestIndex) ||
            (*ppBestIndex)->ulEstimatedRecsInRange > pLocalBestIndex->ulEstimatedRecsInRange) {

            if (*ppBestIndex) {
                DPRINT2(2, "dbOptSubstringFilter: freeing previous filter %s %d\n",(*ppBestIndex)->szIndexName, (*ppBestIndex)->ulEstimatedRecsInRange);
                dbFreeKeyIndex(pDB->pTHS, (*ppBestIndex));
            }
            (*ppBestIndex) = pLocalBestIndex;
        } else {
            DPRINT2 (2, "dbOptSubstringFilter: Initial Index %s is NOT best so far %d\n", pLocalBestIndex->szIndexName, pLocalBestIndex->ulEstimatedRecsInRange);
            dbFreeKeyIndex(pDB->pTHS, pLocalBestIndex);
        }
        if (pIndexCount) {
            *pIndexCount = (*ppBestIndex) ? 1 : 0;
        }
    }
    return err;

}



DWORD 
dbOptItemFilter (
    DBPOS    *pDB,
    DWORD     fParentFilterType,
    DWORD     Flags,
    KEY_INDEX **ppBestIndex,
    FILTER    *pFil,
    FILTER    *pFil2
    )
{
    THSTATE    *pTHS=pDB->pTHS;
    
    ATTCACHE   *pAC;
    ATTRTYP     type = -1;  // init to non-existent attid
    UCHAR      *pVal1;
    UCHAR      *pVal2;
    ULONG       cbVal1;
    ULONG       cbVal2;
    char        szIndexName[MAX_INDEX_NAME];
    INDEX_RANGE IndexRange;
    
    BOOL        fPDNT = FALSE;
    BOOL        needRecordCount;
    KEY_INDEX  *pNewIndex = NULL;

    DPRINT(2, "dbOptItemFilter: entering ITEM\n");

    switch(dbMakeValuesForOptimizedFilter(pTHS,
                                          fParentFilterType,
                                          TRUE, 
                                          pFil,
                                          pFil2,
                                          &type,
                                          &pVal1,
                                          &pVal2,
                                          &cbVal1,
                                          &cbVal2)) {
    case OPT_FILTER_VALUE_OK:
        // Normal Success path
        break;
    case OPT_FILTER_VALUE_IGNORE:
        // No optimization possible
        return DB_ERR_NOT_OPTIMIZABLE;
        break;

    default:
        // Huh?
        return DB_ERR_NOT_OPTIMIZABLE;
    }

    // find the att in schema cache
    if (!(pAC = SCGetAttById(pTHS, type))) {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, type);
    }

    if(!dbSetToIndex(pDB, (Flags & DBOPTINDEX_fUSE_SHOW_IN_AB), &fPDNT, szIndexName, pAC)) {
        // Couldn't set to the required index

        DPRINT1(2, "dbOptItemFilter: Error setting to index %s\n", szIndexName);

        return DB_ERR_NOT_OPTIMIZABLE;
    }

     // set up the index range structure

    IndexRange.cbValLower = cbVal1;
    IndexRange.pvValLower = pVal1;
    IndexRange.cbValUpper = cbVal2;
    IndexRange.pvValUpper = pVal2;

    // Now we evaluate the associated index

    // if we "know" the expected number of items for this filter
    // there is no need to try to find them, unless we supress optimizations

    needRecordCount = (pFil->FilterTypes.Item.expectedSize == 0) || !gfUseIndexOptimizations;

    pNewIndex =
        dbMakeKeyIndex(
                pDB,
                pFil->FilterTypes.Item.choice,
                pAC->isSingleValued,
                (fPDNT?dbmkfir_PDNT:0),
                szIndexName,
                needRecordCount,
                1,  // only one component in the index range
                &IndexRange
                );

    if(!pNewIndex) {
        DPRINT1 (2, "dbOptItemFilter: Not optimizable ITEM: 0x%x\n", pAC->id);

        return DB_ERR_NOT_OPTIMIZABLE;
    }

    pNewIndex->pAC = pAC;

    if (!needRecordCount) {
        pNewIndex->ulEstimatedRecsInRange = pFil->FilterTypes.Item.expectedSize;
    }

    DPRINT2 (2, "dbOptItemFilter: Index %s estimated size %d\n", szIndexName, pNewIndex->ulEstimatedRecsInRange);        

    pNewIndex->bIsPDNTBased = fPDNT;

    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
             DS_EVENT_SEV_VERBOSE,
             DIRLOG_QUERY_INDEX_CONSIDERED,
             szInsertSz(szIndexName),
             szInsertUL(pNewIndex->ulEstimatedRecsInRange),
             NULL);

    // is this index best so far?

    if(!(*ppBestIndex) ||
       (pNewIndex->ulEstimatedRecsInRange <
        (*ppBestIndex)->ulEstimatedRecsInRange)) {
        // yes - it sure looks that way...

        DPRINT2 (2, "dbOptItemFilter: Index %s estimated is best so far %d\n", szIndexName, pNewIndex->ulEstimatedRecsInRange);

        if(*ppBestIndex) {
            DPRINT2(2, "dbOptItemFilter: freeing previous filter %s %d\n",(*ppBestIndex)->szIndexName, (*ppBestIndex)->ulEstimatedRecsInRange);
            dbFreeKeyIndex(pDB->pTHS, *ppBestIndex);
        }
        *ppBestIndex = pNewIndex;
    }
    else {
        // Nope, free it.
        DPRINT2 (2, "dbOptItemFilter: Index %s is NOT best so far %d\n", szIndexName, pNewIndex->ulEstimatedRecsInRange);
        dbFreeKeyIndex(pDB->pTHS, pNewIndex);
    }

    return 0;
}

DWORD 
dbOptAndFilter (
    DBPOS     *pDB,
    DWORD     Flags,
    KEY_INDEX **ppBestIndex,
    FILTER    *pFil
    )
{
    THSTATE    *pTHS=pDB->pTHS;
    unsigned    count, count2;
    JET_ERR     err = 0;
    
    ATTCACHE   *pAC;
    ATTRTYP     type = -1;  // init to non-existent attid
    UCHAR      *pVal1;
    UCHAR      *pVal2;
    ULONG       cbVal1;
    ULONG       cbVal2;
    char        szIndexName[MAX_INDEX_NAME];
    INDEX_RANGE IndexRange;
    
    FILTER      *pFilTemp;
    KEY_INDEX   *pNewIndex = NULL;
    KEY_INDEX    HeadSubstrIndexList, *pCurSubstrIndex;
    DWORD        dwSubstrIndexCount=0, dwTempIndexCount;

    BOOL         fOptimizationFinished = FALSE;
    BOOL         fNonIndexableComponentsPresent = FALSE;
    
    unsigned     cntFilters = 0;
    FILTER     **pFilArray = NULL;
    DWORD        cntPossOpt = 0;
    FILTER     **pFilPossOpt = NULL;
    
    KEY_INDEX  **ppIndex = NULL;

    DPRINT(2, "dbOptAndFilter: entering AND\n");

    // Do this in three passes.
    // 1) Look for an Item filter that implies a PRESENCE test for
    //    DISPLAY_NAME.  If we find one, we can optimize filters over the
    //    SHOW_IN_ADDRESSBOOK attribute.  SHOW_IN_ADDRESSBOOK is indexed,
    //    but it is a compound index over SHOW_IN_ADDRESSBOOK and
    //    DISPLAY_NAME with Jet set to ignore any nulls.  The index is
    //    defined this way so the MAPI head can use it to create tables.
    //    So, before we can use it, we have to make sure that the filter
    //    will drop out items that have NULLs for DISPLAY_NAME.
    //
    // 2) Optimize the ITEMS.
    //
    // 3) Finally, go back and try for any ORs.  We do all the items first
    //    since we have to check them anyway, and once we have our best ITEM
    //    filter, we can use it's count to short circuit looking for an OR
    //    optimization.  As an example, if the last Item filter implies an
    //    index range with 3 entries, and we have an OR with 7 parts that
    //    comes before that in the filter, if we do the items first, we can
    //    stop checking the OR after the first part of the OR if it is
    //    already bigger than 3 entries.  If we did things in linear order,
    //    we would set to the indices described by all 7 parts of the OR and
    //    later find out that we didn't need to.
    //


    // put all the filters in an array
    // check to see which filters have a possibility 
    // of being optimizable and put them on a separate array
    //
    cntFilters = count = pFil->FilterTypes.And.count;
    pFilArray = (FILTER **) THAllocEx (pTHS, sizeof (FILTER *) * cntFilters);
    pFilPossOpt = (FILTER **) THAllocEx (pTHS, sizeof (FILTER *) * cntFilters);

    for (count2=0, pFilTemp = pFil->FilterTypes.And.pFirstFilter; count;
         count--, count2++, pFilTemp = pFilTemp->pNextFilter) {

        pFilArray[count2] = pFilTemp;

        if (IsFilterOptimizable (pTHS, pFilTemp)) {
            pFilPossOpt[cntPossOpt++] = pFilTemp;
        }
    }

    // we might have a non indexable component
    //
    if (cntFilters != cntPossOpt) {
        fNonIndexableComponentsPresent = TRUE;
    }

    DPRINT2(2, "dbOptAndFilter: initially found %d out of %d optimizable filters\n", 
                    cntPossOpt, cntFilters );

    // New level of filter, so we can't use the ShowInAB unless this level
    // says we can.
    Flags &= ~DBOPTINDEX_fUSE_SHOW_IN_AB;

    for (count=0; count<cntFilters; count++) {
        pFilTemp = pFilArray[count];
        if (pFilTemp && pFilTemp->choice == FILTER_CHOICE_ITEM) {
            if (dbIsPresenceOnDisplayName(pFilTemp)) {
                Flags |= DBOPTINDEX_fUSE_SHOW_IN_AB;
                break;
            }
        }
    }

    // we create a KEY INDEX for every filter that is optimizable
    // using two parallel arrays: ppIndex and pFilPossOpt
    // This way, once we have the KEY_INDEX we can decide how to use it.
    // In addition, we take care of ranges
    //
    if (cntPossOpt) {
        
        FILTER *pFilTemp2 = NULL;
        UCHAR relop1, relop2;
        AVA *pAVA1, *pAVA2;
        
        ppIndex = (KEY_INDEX **) 
                        THAllocEx (pTHS, sizeof (KEY_INDEX *) * cntPossOpt);
        memset (ppIndex, 0, sizeof (KEY_INDEX *) * cntPossOpt);
        
        
        for (count=0; 
                count<cntPossOpt && 
                err == JET_errSuccess &&
                gfUseRangeOptimizations; count++) {
            

            pFilTemp = pFilPossOpt[count];

            // filter might have been deleted in the mean time
            if (!pFilTemp) {
                continue;
            }

            // we shouldn't be here if this is FALSE
            Assert (pFilTemp->choice == FILTER_CHOICE_ITEM);
            
            // get the first relop
            // and for simplicity, treat equalities as inequalities
            //
            relop1 = pFilTemp->FilterTypes.Item.choice;
            if (relop1 == FI_CHOICE_GREATER_OR_EQ) {
                relop1 = FI_CHOICE_GREATER;
            }
            else if (relop1 == FI_CHOICE_LESS_OR_EQ) {
                relop1 = FI_CHOICE_LESS;
            }

            if (relop1 == FI_CHOICE_GREATER || relop1 == FI_CHOICE_LESS) {

                pAVA1 = &pFilTemp->FilterTypes.Item.FilTypes.ava;


                // start with the case case of x<A and x<B when A<B
                // where we can have x<A (same for >)
                //
                for (count2=count+1; count2<cntPossOpt; count2++) {

                    pFilTemp2 = pFilPossOpt[count2];

                    // filter might have been deleted in the mean time
                    if (!pFilTemp2) {
                        continue;
                    }

                    Assert (pFilTemp2->choice == FILTER_CHOICE_ITEM);

                    pAVA2 = &pFilTemp2->FilterTypes.Item.FilTypes.ava;

                    // check to see if we are comparing on the same type
                    //
                    if (pAVA2->type == pAVA1->type) {
                        relop2 = pFilTemp2->FilterTypes.Item.choice;

                        if (relop2 == FI_CHOICE_GREATER_OR_EQ) {
                            relop2 = FI_CHOICE_GREATER;
                        }
                        else if (relop2 == FI_CHOICE_LESS_OR_EQ) {
                            relop2 = FI_CHOICE_LESS;
                        }


                        if ( relop1 == relop2)  {

                            // find the att in schema cache
                            if (!(pAC = SCGetAttById(pTHS, pAVA1->type))) {
                                DsaExcept(DSA_EXCEPTION, 
                                          DIRERR_ATT_NOT_DEF_IN_SCHEMA, 
                                          pAVA1->type);
                            }

                            // case A<B
                            if (gDBSyntax[pAC->syntax].Eval(pDB,
                                                            FI_CHOICE_LESS,
                                                            pAVA1->Value.valLen,
                                                            pAVA1->Value.pVal,
                                                            pAVA2->Value.valLen,
                                                            pAVA2->Value.pVal)) {

                                // X<A and X<B when A < B => X<A
                                if (relop1 == FI_CHOICE_LESS) {
                                    pFilPossOpt[count2] = NULL;

                                    DPRINT(2, "dbOptAndFilter: found case X<A & X<B when A<B\n");
                                }
                                // X>A and X>B when A < B => X>B
                                else {
                                    pFilPossOpt[count] = pFilPossOpt[count2];
                                    pFilPossOpt[count2] = NULL;
                                    pFilTemp = pFilTemp2;
                                    pAVA1 = pAVA2;
                                    DPRINT(2, "dbOptAndFilter: found case X>A & X>B when A<B\n");
                                }
                            }
                            // case A>B
                            else if (gDBSyntax[pAC->syntax].Eval(pDB,
                                                            FI_CHOICE_GREATER,
                                                            pAVA1->Value.valLen,
                                                            pAVA1->Value.pVal,
                                                            pAVA2->Value.valLen,
                                                            pAVA2->Value.pVal)) {


                                // X<A and X<B when A > B => X<B
                                if (relop1 == FI_CHOICE_LESS) {
                                    pFilPossOpt[count] = pFilPossOpt[count2];
                                    pFilPossOpt[count2] = NULL;
                                    pFilTemp = pFilTemp2;
                                    pAVA1 = pAVA2;
                                    DPRINT(2, "dbOptAndFilter: found case X<A & X<B when A>B\n");
                                }
                                // X>A and X>B when A > B => X>A
                                else {
                                    pFilPossOpt[count2] = NULL;
                                    DPRINT(2, "dbOptAndFilter: found case X>A & X>B when A>B\n");
                                }
                            }
                            // case A==B 
                            else {
                                pFilPossOpt[count2] = NULL;
                                DPRINT(2, "dbOptAndFilter: found case X>A & X>B when A==B\n");
                            }
                        }
                    }
                } // count2 loop
            }
        } // count loop
        
        
        // RANGE optimizations
        // check to see if we have a case of:   val<=HighVal AND val>=LowVal
        // that we can convert to a LowVal<=val<=HighVal range
        //
        DPRINT(2, "dbOptAndFilter: looking for RANGE optimizations\n");

        for (count=0; 
                count<cntPossOpt && 
                err == JET_errSuccess &&
                gfUseRangeOptimizations; count++) {
            

            pFilTemp = pFilPossOpt[count];

            // filter might have been deleted in the mean time
            if (!pFilTemp) {
                continue;
            }

            // we shouldn't be here if this is FALSE
            Assert (pFilTemp->choice == FILTER_CHOICE_ITEM);
            
            // get the first relop
            // and for simplicity, treat equalities as inequalities
            //
            relop1 = pFilTemp->FilterTypes.Item.choice;
            if (relop1 == FI_CHOICE_GREATER_OR_EQ) {
                relop1 = FI_CHOICE_GREATER;
            }
            else if (relop1 == FI_CHOICE_LESS_OR_EQ) {
                relop1 = FI_CHOICE_LESS;
            }

            if (relop1 == FI_CHOICE_GREATER || relop1 == FI_CHOICE_LESS) {

                pAVA1 = &pFilTemp->FilterTypes.Item.FilTypes.ava;

                // we found one potential part of the range (low or high end)
                // look for the oposite side
                //
                for (count2=count+1; count2<cntPossOpt; count2++) {

                    pFilTemp2 = pFilPossOpt[count2];

                    // filter might have been deleted in the mean time
                    if (!pFilTemp2) {
                        continue;
                    }

                    Assert (pFilTemp2->choice == FILTER_CHOICE_ITEM);

                    pAVA2 = &pFilTemp2->FilterTypes.Item.FilTypes.ava;

                    // check to see if we are comparing on the same type
                    //
                    if (pAVA2->type == pAVA1->type) {
                        relop2 = pFilTemp2->FilterTypes.Item.choice;

                        if (relop2 == FI_CHOICE_GREATER_OR_EQ) {
                            relop2 = FI_CHOICE_GREATER;
                        }
                        else if (relop2 == FI_CHOICE_LESS_OR_EQ) {
                            relop2 = FI_CHOICE_LESS;
                        }

                        // check to see if this relop is a compatible 
                        // one for use in a range
                        //
                        if (  ( relop1 == FI_CHOICE_GREATER  && 
                                relop2 == FI_CHOICE_LESS     )  ||
                              ( relop2 == FI_CHOICE_GREATER && 
                                 relop1 == FI_CHOICE_LESS    )  )  {

                            DPRINT1 (2, "dbOptAndFilter: found RANGE on 0x%x \n", 
                                                pAVA1->type );

                            if (err = dbOptItemFilter(pDB, 
                                                      FILTER_CHOICE_AND,
                                                      Flags, 
                                                      &ppIndex[count], 
                                                      pFilTemp, 
                                                      pFilTemp2) ) {
                                break;
                            }

                            if (ppIndex[count]) {
                                DPRINT2 (2, "dbOptAndFilter: RANGE on %s = %d\n", 
                                         ppIndex[count]->szIndexName, 
                                         ppIndex[count]->ulEstimatedRecsInRange );
                            }

                            // we managed to concatanate these two filters
                            // remove the second one from the array

                            pFilPossOpt[count2] = NULL;

                        }
                    }
                } // count2 loop
            }
        } // count loop

        // if something failed, then we cannot optimize this, so exit
        if (err) {
            DPRINT1(2, "dbOptAndFilter: AND Optimization Failed1:  %d\n", err);

            goto exitAndOptimizer;
        }
    }


    pCurSubstrIndex = &HeadSubstrIndexList;
    pCurSubstrIndex->pNext = NULL;

    // First try the brute force way, by visiting all indexes 
    // and counting possible entries in each index. 
    // Keep all the results for later evaluation
    //
    for (count = 0; count < cntPossOpt; count++) {

        pFilTemp = pFilPossOpt[count];

        if (!pFilTemp) {
            continue;
        }

        if (ppIndex[count] == NULL) {
            if (pFilTemp->choice == FILTER_CHOICE_ITEM
                && pFilTemp->FilterTypes.Item.choice == FI_CHOICE_SUBSTRING) {

                // Find the current end of the substring filter list.
                while (pCurSubstrIndex->pNext) {
                    pCurSubstrIndex = pCurSubstrIndex->pNext;
                }
                err = dbOptSubstringFilter(pDB,
                                           FILTER_CHOICE_AND,
                                           Flags,
                                           &pCurSubstrIndex->pNext,
                                           &dwTempIndexCount,
                                           pFilTemp
                                           );
                if (err) {
                    break;
                }
                dwSubstrIndexCount += dwTempIndexCount;

            } else {
                // Recursively call opt filter to get the item case
                if (err = dbOptFilter(pDB, Flags, &ppIndex[count], pFilTemp)) {
                    break;
                }
            }
        }

        // we don't need to continue. we have a complete match
        if (ppIndex[count] && 
            ppIndex[count]->ulEstimatedRecsInRange < gulMaxRecordsWithoutIntersection) {

                DPRINT1 (2, "dbOptAndFilter: Found Index with %d entries. Registry says we should use it.\n", 
                            ppIndex[count]->ulEstimatedRecsInRange);

                fOptimizationFinished = TRUE;
                break;
        }
    }

    // if something failed, then we cannot optimize this, so exit
    if (err) {
        DPRINT1(2, "dbOptAndFilter: AND Optimization Failed2: %d\n", err);
        goto exitAndOptimizer;
    }

    DPRINT(2, "dbOptAndFilter: Putting substring indexes at the end of the Array\n");
    //
    // Make room for any substring indexes we may have receieved and put them
    // at the end of the list of possible index optimizations.
    //
    if (dwSubstrIndexCount) {
        ppIndex = THReAllocEx(pTHS, ppIndex, (cntPossOpt + dwSubstrIndexCount) * sizeof(KEY_INDEX *));
        
        pCurSubstrIndex = HeadSubstrIndexList.pNext;

        count = cntPossOpt;
        cntPossOpt += dwSubstrIndexCount;
        while (pCurSubstrIndex) {
            ppIndex[count] = pCurSubstrIndex;
            pCurSubstrIndex = pCurSubstrIndex->pNext;
            ppIndex[count]->pNext = NULL;
            count++;
        }
    }

    DPRINT(2, "dbOptAndFilter: Removing duplicates.\n");

    // Since jet won't currently intersect to KEY_INDEXES over the same index,
    // we need to make sure that we only have the best KEY_INDEX for any
    // particular index.
    for (count=0; count<cntPossOpt; count++) {
        if (ppIndex[count]) {
            for (count2=count + 1; count2<cntPossOpt; count2++) {
                if (ppIndex[count2] 
                    && !strcmp(ppIndex[count]->szIndexName, ppIndex[count2]->szIndexName)) {
                    
                    DWORD  dwIndexToFree;
                    if (ppIndex[count]->ulEstimatedRecsInRange <= ppIndex[count2]->ulEstimatedRecsInRange) {
                        dwIndexToFree = count2;
                    } else {
                        dwIndexToFree = count;
                    }
                    DPRINT1(2, "dbOptAndFilter: removing KEY_INDEX over duplicate index '%s'\n",
                           ppIndex[dwIndexToFree]->szIndexName);
                    dbFreeKeyIndex(pTHS, ppIndex[dwIndexToFree]);
                    ppIndex[dwIndexToFree] = NULL;
                    if (dwIndexToFree == count) {
                        break;
                    }
                }
            }
        }
    }

    DPRINT(2, "dbOptAndFilter: Compacting Array\n");
    // move all valid entries in the start of the array
    //
    for (count=0; count<cntPossOpt; count++) {
        if (ppIndex[count]==NULL) {
            for (count2=count+1 ; count2<cntPossOpt; count2++) {
                if (ppIndex[count2]) {
                    break;
                }
            }
            if (count2 < cntPossOpt) {
                ppIndex[count] = ppIndex[count2];
                ppIndex[count2] = NULL;
            }
            else {
                break;
            }
        }
    }
    cntPossOpt = count;

    #if 0
    for (count=0; count<cntPossOpt; count++) {
        if (pFilPossOpt[count] == NULL || ppIndex[count]==NULL) {
            DPRINT4 (0, "pFilPossOpt[%d]=0x%x, ooPindex[%d]=0x%x\n",
                    count, pFilPossOpt[count], 
                    count, ppIndex[count]);
        }
        Assert (ppIndex[count] && pFilPossOpt[count]);
    }
    #endif

    // 
    // Intersect if it makes sense to do so.
    if (!fOptimizationFinished) {
        err = dbOptAndIntersectFilter(pDB, Flags, ppBestIndex, ppIndex, cntPossOpt);
    }

    // consolidate best indexes found until now
    // and free the remaining
    //
    DPRINT(2, "dbOptAndFilter: Consolidating best indexes for far\n");

    for (count=0; count<cntPossOpt; count++) {

        // is it better than the one we already have ?
        if(!(*ppBestIndex) ||
           (ppIndex[count] && 
            (ppIndex[count]->ulEstimatedRecsInRange < (*ppBestIndex)->ulEstimatedRecsInRange)) ) {
                // yes - it sure looks that way...

                if(*ppBestIndex) {
                    dbFreeKeyIndex(pTHS, *ppBestIndex);
                }
                *ppBestIndex = ppIndex[count];
                ppIndex[count] = NULL;
        }
        else {
            dbFreeKeyIndex(pTHS, ppIndex[count]);
            ppIndex[count] = NULL;
        }
    }

    // if we can't use the special AND optimize, 
    // or we used it and somehow it failed
    // we try with a simpler brute force optimizer
    //
    if (!fOptimizationFinished && (fNonIndexableComponentsPresent || err != JET_errSuccess) ) {
        
        // Now that we've picked the best ITEM, go back and try for ORs.
        //
        count = cntFilters;
        for (count = 0; count < cntFilters; count++) {
            pFilTemp = pFilArray[count];
            if (pFilTemp && pFilTemp->choice == FILTER_CHOICE_OR) {
                
                err = dbOptOrFilter(pDB, Flags, ppBestIndex, pFilTemp);
                if(err) {

                    DPRINT1(2, "dbOptAndFilter: Error optimizing OR filter %d\n", err);

                    goto exitAndOptimizer;
                }
            }
        }

        // if we didn't manage to optimize this branch, return an indication.
        if (*ppBestIndex == NULL) {
            
            DPRINT(2, "dbOptAndFilter: AND branch not optimizable\n");
            
            err = 1;
        }
    }

exitAndOptimizer:

    // first free all potential KEY_INDEXES so far
    for (count=0; count<cntPossOpt; count++) {
        if (ppIndex[count]) {
            dbFreeKeyIndex(pTHS, ppIndex[count]);
            ppIndex[count] = NULL;
        }
    }

    THFreeEx (pTHS, ppIndex);
    THFreeEx (pTHS, pFilArray);
    THFreeEx (pTHS, pFilPossOpt);

    return err;
}


DWORD 
dbOptFilter (
        DBPOS     *pDB,
        DWORD     Flags,
        KEY_INDEX **ppBestIndex,
        FILTER    *pFil
         )
{
    DWORD       err = 0;
    
    Assert(VALID_DBPOS(pDB));

    DPRINT(2, "dbOptFilter: entering\n");

    if (pFil == NULL)
        return 0;

    if (  eServiceShutdown
        && !(   (eServiceShutdown == eRemovingClients)
             && (pDB->pTHS->fDSA)
             && !(pDB->pTHS->fSAM))) {
        // Shutting down, bail.
        return DB_ERR_SHUTTING_DOWN;
    }

    switch (pFil->choice) {
    case FILTER_CHOICE_AND:
        err = dbOptAndFilter (pDB,
                              Flags,
                              ppBestIndex,
                              pFil);
        return err;
        break;
        
    case FILTER_CHOICE_OR:
        dbOptOrFilter(pDB,
                      Flags,
                      ppBestIndex,
                      pFil);
        return 0;
        break;
        
    case FILTER_CHOICE_NOT:
        DPRINT(2, "dbOptFilter: NOT\n");
        // No optimization possible.
        return 0;
        
    case FILTER_CHOICE_ITEM:
        if (pFil->FilterTypes.Item.choice == FI_CHOICE_SUBSTRING) {
            err = dbOptSubstringFilter(pDB,
                                       FILTER_CHOICE_ITEM,
                                       Flags,
                                       ppBestIndex,
                                       NULL,
                                       pFil);
        } else {
            err = dbOptItemFilter (pDB,
                                   FILTER_CHOICE_ITEM,
                                   Flags,
                                   ppBestIndex,
                                   pFil,
                                   NULL);
        }
        return err;
        
    default:
        DPRINT1(2, "DBOptFilter got unknown filter element, %X\n", pFil->choice);
        Assert(!"DBOptFilter got unknown fitler element\n");
        return DB_ERR_UNKNOWN_ERROR;
        
    }  /*switch FILTER*/
    
    return 0;
}
DWORD
dbCreateSortedTable (
        IN DBPOS *pDB,
        IN DWORD StartTick,
        IN DWORD DeltaTick,
        IN DWORD SortAttr,
        IN DWORD SortFlags,
        IN DWORD MaxSortTableSize
        )
{
    THSTATE   *pTHS=pDB->pTHS;
    ATTCACHE  *pACSort = NULL;
    KEY_INDEX *pIndex;
    DWORD     Count=0;
    DWORD     err;
    DWORD     cbActual;
    PUCHAR    pData;
    BOOL      bCanRead;
    UCHAR     data[240];            // Note that we only read the first
                                    // part of the sort value.
                                    // DBInsertSortTable truncates at 240,
                                    // so no reason to do more.
    unsigned char rgbBookmark[JET_cbBookmarkMost];
    unsigned long cbBookmark;


    //
    // ok, these callers are exempted from the table size check
    //

    if ( pTHS->fDRA ||
         pTHS->fDSA ||
         pTHS->fSAM ) {

        MaxSortTableSize = UINT_MAX;
    }

    Assert(VALID_DBPOS(pDB));

    if (!(pACSort = SCGetAttById(pTHS, SortAttr))) {
        // What?  The sort attribute is invalid?
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, SortAttr);
    }

    if(DBOpenSortTable(
            pDB,
            pTHS->dwLcid,
            pDB->Key.pVLV ? ( SortFlags & ~DB_SORT_DESCENDING ) : SortFlags,
            pACSort)) {
        // Can't open a sort table on this attribute, bail
        return DB_ERR_NO_SORT_TABLE;
    }

    pIndex = pDB->Key.pIndex;
    while (pIndex) {

        // handle intersections differently
        if (pIndex->bIsIntersection) {
            err = JetMoveEx( pDB->JetSessID, 
                             pIndex->tblIntersection, 
                             JET_MoveFirst, 
                             0 );

            if (err == JET_errSuccess) {
                if (! (err = JetRetrieveColumn(
                                    pDB->JetSessID,
                                    pIndex->tblIntersection,
                                    pIndex->columnidBookmark,
                                    rgbBookmark,
                                    sizeof( rgbBookmark ),
                                    &cbBookmark,
                                    0,
                                    NULL )) ) {
    
                    err = JetGotoBookmark( 
                                   pDB->JetSessID,
                                   pDB->JetObjTbl,
                                   rgbBookmark, 
                                   cbBookmark );
                }
            }

            if(err) {
                // What kind of error is this?  dunno, fail
                DPRINT1(2, "DBCreateSortedTable failed to use Intersect Table, err %d\n",err);
                Assert(!"DBCreateSortedTable failed to use Intersect Table\n");
                return DB_ERR_UNKNOWN_ERROR;
            }
        }
        else {
            // Set to the index.
            JetSetCurrentIndex2Success(pDB->JetSessID,
                                       pDB->JetObjTbl,
                                       pIndex->szIndexName,
                                       0);

            if (pIndex->cbDBKeyLower) {
                // Seek to the first element.
                JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetObjTbl,
                         pIndex->rgbDBKeyLower,
                         pIndex->cbDBKeyLower,
                         JET_bitNormalizedKey);


                err = JetSeekEx(pDB->JetSessID,
                            pDB->JetObjTbl,
                            JET_bitSeekGE);
            } else {
                err = JetMoveEx(pDB->JetSessID, 
                                pDB->JetObjTbl,
                                JET_MoveFirst, 0);
            }

            switch(err) {
            case JET_errSuccess:
            case JET_wrnSeekNotEqual:
                // Normal case
                break;

            case JET_errRecordNotFound:
            case JET_errNoCurrentRecord:
                // Already outside the bounds of the range we wanted.  This means
                // that there are no objects from this keyindex that we care about.
                // Go on to the next one.
                pIndex = pIndex->pNext;
                continue;
                break;

            default:
                // The seek failed in some way.
                DPRINT1(2, "DBCreateSortedTable failed to seek, err %d\n",err);
                Assert(!"DBCreateSortedTable failed to seek\n");
                return DB_ERR_UNKNOWN_ERROR;
            }

            // OK, we seeked to something.  Set the index range.
            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetObjTbl,
                         pIndex->rgbDBKeyUpper,
                         pIndex->cbDBKeyUpper,
                         JET_bitNormalizedKey);

            err = JetSetIndexRange(pDB->JetSessID,
                                   pDB->JetObjTbl,
                                   (JET_bitRangeUpperLimit |
                                    JET_bitRangeInclusive ));

            if(err == JET_errNoCurrentRecord) {
                // The object we were on is already outside the bounds of the range.
                pIndex = pIndex->pNext;
                continue;
            }

            if(err) {
                // What kind of error is this?  dunno, fail
                DPRINT1(2, "DBCreateSortedTable failed to set range, err %d\n",err);
                Assert(!"DBCreateSortedTable failed to set range\n");
                return DB_ERR_UNKNOWN_ERROR;
            }
        }
        
        while(!err) {
            if(StartTick) {       // There is a time limit
                if((GetTickCount() - StartTick) > DeltaTick) {
                    DBCloseSortTable(pDB);
                    return DB_ERR_TIMELIMIT;
                }
            }

            // read currency
            dbMakeCurrent(pDB, NULL);

            if(dbFObjectInCorrectDITLocation(pDB, pDB->JetObjTbl) &&
               dbFObjectInCorrectNC(pDB, pDB->DNT, pDB->JetObjTbl)     &&
               dbMatchSearchCriteriaForSortedTable(pDB, &bCanRead)) {
                // In the correct place and NC, and the filter matches.
                pData = data;
                
                if(bCanRead) {
                    // Get the value we are sorting on.
                    err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                                    pDB->JetObjTbl,
                                                    pACSort->jColid,
                                                    (void *)data,
                                                    240,
                                                    &cbActual,
                                                    0,
                                                    NULL);
                }
                else {
                    // We can't read the value due to security.  Make it be
                    // a null value.
                    pData = NULL;
                    cbActual = 0;
                    err = JET_errSuccess;
                }
                
                
                switch (err) {
                case JET_wrnColumnNull:
                    // Set up the null value.
                    pData = NULL;
                    cbActual = 0;
                    
                    // fall through.
                case JET_errSuccess:
                case JET_wrnBufferTruncated:
                    err = DBInsertSortTable(pDB,
                                            pData,
                                            cbActual,
                                            pDB->DNT);
                    
                    switch (err) {
                    case DB_success:
                        if( Count++ >= MaxSortTableSize ) {
                            
                            // This table is too big.  Bail.
                            DBCloseSortTable(pDB);
                            return DB_ERR_TOO_MANY;
                        }
                        break;
                    case DB_ERR_ALREADY_INSERTED:
                        // This is ok, it just means that we've already
                        // added this object to the sort table. Don't inc
                        // the count; 
                        break;
                    default:
                        // Something went wrong.
                        DBCloseSortTable(pDB);
                        DPRINT1(2,
                                "DBCreateSortedTable failed to insert, %d\n",
                                err);
                        Assert(!"DBCreateSortedTable failed to insert\n");
                        return DB_ERR_UNKNOWN_ERROR;
                        break;
                    }
                    break;
                    
                default:
                    // Something went wrong.
                    DBCloseSortTable(pDB);
                    DPRINT1(0,
                            "DBCreateSortedTable failed to read, %d\n",
                            err);
                    Assert(!"DBCreateSortedTable failed to read\n");
                    return DB_ERR_UNKNOWN_ERROR;
                    break;
                }
            }
            
            
            //  Move to next, retrieve it's key.
            if (pIndex->bIsIntersection) {
                err = JetMoveEx(pDB->JetSessID, 
                                pIndex->tblIntersection,
                                JET_MoveNext, 
                                0);

                if (err == JET_errSuccess) {
                    if (! (err = JetRetrieveColumn(
                                        pDB->JetSessID,
                                        pIndex->tblIntersection,
                                        pIndex->columnidBookmark,
                                        rgbBookmark,
                                        sizeof( rgbBookmark ),
                                        &cbBookmark,
                                        0,
                                        NULL )) ) {

                        err = JetGotoBookmark( 
                                       pDB->JetSessID,
                                       pDB->JetObjTbl,
                                       rgbBookmark, 
                                       cbBookmark );
                    }
                }
            }
            else {
                err = JetMoveEx(pDB->JetSessID,
                                pDB->JetObjTbl,
                                JET_MoveNext,
                                0);
            }
        }
        pIndex = pIndex->pNext;
    }

    dbFreeKeyIndex(pTHS, pDB->Key.pIndex);
    pDB->Key.fSearchInProgress = FALSE;
    pDB->Key.indexType = TEMP_TABLE_INDEX_TYPE;
    pDB->Key.ulEntriesInTempTable = Count;
    pDB->Key.bOnCandidate = FALSE;
    pDB->Key.pIndex = NULL;
    
    if (pDB->Key.pVLV) {
        DWORD *pDNTs;
        #if DBG
        DWORD DntIndex = 0;
        #endif

        DPRINT1 (1, "Doing VLV using INMEMORY Sorted Table. Num Entries: %d\n", Count);

        pDB->Key.cdwCountDNTs = pDB->Key.pVLV->contentCount = Count;

        if (Count) {
            pDB->Key.pVLV->currPosition = 1;
            pDB->Key.currRecPos = 1;

            pDNTs = pDB->Key.pDNTs = THAllocEx(pTHS, (Count+1) * sizeof (DWORD));

            err = JetMove(pDB->JetSessID,
                  pDB->JetSortTbl,
                  JET_MoveFirst,
                  0);

            if(!err) {
                do {
                    // OK, pull the DNT out of the sort table
                    DBGetDNTSortTable (
                            pDB,
                            pDNTs);

                    pDNTs++;

                    #ifdef DBG
                        DntIndex++;
                    #endif

                    err = JetMove(pDB->JetSessID,
                                  pDB->JetSortTbl,
                                  JET_MoveNext,
                                  0);

                    if(StartTick) {       // There is a time limit
                        if((GetTickCount() - StartTick) > DeltaTick) {
                            DBCloseSortTable(pDB);
                            return DB_ERR_TIMELIMIT;
                        }
                    }

                } while (!err);
            }

            #if DBG
                Assert (DntIndex == Count);
            #endif
        }

        DBCloseSortTable(pDB);
        pDB->Key.indexType = TEMP_TABLE_MEMORY_ARRAY_TYPE;
    }

    return 0;
}

DWORD
dbCreateASQTable (
        IN DBPOS *pDB,
        IN DWORD StartTick,
        IN DWORD DeltaTick,
        IN DWORD MaxTableSize,
        IN BOOL  fSort,
        IN DWORD SortAttr
        )
{
    THSTATE   *pTHS=pDB->pTHS;
    ATTCACHE  *pACSort = NULL;
    ATTCACHE  *pACASQ = NULL;

    ATTCACHE  *rgpAC[1];
    ATTRBLOCK  AttrBlock;

    RANGEINFSEL   SelectionRange;
    RANGEINFOITEM RangeInfoItem;
    RANGEINF      RangeInf;

    DWORD     upperLimit;
    DWORD    *pDNTs = NULL;

    DWORD     err = 0;
    DWORD     Count=0, j, loopCount=0;
    BOOL      fDone = FALSE;

    DWORD     cbActual;
    DWORD     DNT;
    PUCHAR    pData;
    BOOL      bCanRead;
    UCHAR     data[240];            // Note that we only read the first
                                    // part of the sort value.
                                    // DBInsertSortTable truncates at 240,
                                    // so no reason to do more.
    DWORD     SortFlags=0;

    Assert(VALID_DBPOS(pDB));

    if (fSort) {
        if (!(pACSort = SCGetAttById(pTHS, SortAttr))) {
            // What?  The sort attribute is invalid?
            DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, SortAttr);
        }
    }
    
    if (!(pACASQ = SCGetAttById(pTHS, pDB->Key.asqRequest.attrType))) {
        // What?  The sort attribute is invalid?
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, 
                  pDB->Key.asqRequest.attrType);
    }

    rgpAC[0] = pACASQ;

    SelectionRange.valueLimit = 1000;
    SelectionRange.count = 1;
    SelectionRange.pRanges = &RangeInfoItem;

    RangeInfoItem.AttId = pDB->Key.asqRequest.attrType;

    upperLimit = pDB->Key.ulASQLastUpperBound + MaxTableSize;

    while (!err && !fDone) {

        RangeInfoItem.lower = loopCount * 1000 + pDB->Key.ulASQLastUpperBound;
        RangeInfoItem.upper = RangeInfoItem.lower + 1000;

        if (RangeInfoItem.upper >= upperLimit) {
            RangeInfoItem.upper = upperLimit;
            fDone = TRUE;
        }

        err = DBFindDNT(pDB, pDB->Key.ulSearchRootDnt);

        err = DBGetMultipleAtts(pDB,
                                1,
                                rgpAC,
                                &SelectionRange,
                                &RangeInf,
                                &AttrBlock.attrCount,
                                &AttrBlock.pAttr,
                                DBGETMULTIPLEATTS_fGETVALS,
                                0);

        if (err) {
            return err;
        }

        if (!AttrBlock.attrCount) {
            break;
        }

        if (loopCount == 0) {
            if(fSort) {
                if (AttrBlock.pAttr[0].AttrVal.valCount >= MIN_NUM_ENTRIES_FOR_FORWARDONLY_SORT) {
                    SortFlags = SortFlags | DB_SORT_FORWARDONLY;
                }
                if (DBOpenSortTable(
                        pDB,
                        pTHS->dwLcid,
                        SortFlags,
                        pACSort)) {
                    // Can't open a sort table on this attribute, bail
                    return DB_ERR_NO_SORT_TABLE;
                }
            }
            else {
                if (pDB->Key.pDNTs) {
                    pDB->Key.pDNTs = THReAllocEx(pTHS, pDB->Key.pDNTs, (MaxTableSize+1) * sizeof (DWORD));
                }
                else {
                    pDB->Key.pDNTs = THAllocEx(pTHS, (MaxTableSize+1) * sizeof (DWORD));
                }
                pDNTs = pDB->Key.pDNTs;
            }
        }

        if (fSort) {
            err = JetSetCurrentIndex4Warnings(pDB->JetSessID,
                                              pDB->JetObjTbl,
                                              SZDNTINDEX,
                                              &idxDnt,
                                              0);
        }

        j = 0; 
        while(!err && j < AttrBlock.pAttr[0].AttrVal.valCount) {

            DNT = *(DWORD *)AttrBlock.pAttr[0].AttrVal.pAVal[j].pVal;

            if (fSort) {
                
                if(StartTick) {       // There is a time limit
                    if((GetTickCount() - StartTick) > DeltaTick) {
                        DBCloseSortTable(pDB);
                        return DB_ERR_TIMELIMIT;
                    }
                }

                JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl, &DNT, 
                             sizeof(DNT), JET_bitNewKey);

                if (err = JetSeekEx(pDB->JetSessID, pDB->JetObjTbl, JET_bitSeekEQ))
                {
                    DsaExcept(DSA_DB_EXCEPTION, err, 0);
                }

                dbMakeCurrent(pDB, NULL);

                // if we are doing a sorted search, we will get back only the
                // objects that are not phantoms
                if(dbFObjectInCorrectDITLocation(pDB, pDB->JetObjTbl) &&
                   dbFObjectInCorrectNC(pDB, DNT, pDB->JetObjTbl)     &&
                   dbMatchSearchCriteriaForSortedTable(pDB, &bCanRead)) {
                    // In the correct place and NC, and the filter matches.
                    pData = data;

                    if(bCanRead) {
                        // Get the value we are sorting on.
                        err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                                        pDB->JetObjTbl,
                                                        pACSort->jColid,
                                                        (void *)data,
                                                        240,
                                                        &cbActual,
                                                        0,
                                                        NULL);
                    }
                    else {
                        // We can't read the value due to security.  Make it be
                        // a null value.
                        pData = NULL;
                        cbActual = 0;
                        err = JET_errSuccess;
                    }


                    switch (err) {
                    case JET_wrnColumnNull:
                        // Set up the null value.
                        pData = NULL;
                        cbActual = 0;

                        // fall through.
                    case JET_errSuccess:
                        err = DBInsertSortTable(pDB,
                                                pData,
                                                cbActual,
                                                DNT);

                        switch (err) {
                        case DB_success:
                            if( Count++ >= MaxTableSize ) {

                                // This table is too big.  Bail.
                                DBCloseSortTable(pDB);
                                return DB_ERR_TOO_MANY;
                            }
                            break;
                        case DB_ERR_ALREADY_INSERTED:
                            // This is ok, it just means that we've already
                            // added this object to the sort table. Don't inc
                            // the count; 
                            err=0;
                            break;
                        default:
                            // Something went wrong.
                            DBCloseSortTable(pDB);
                            DPRINT1(2,
                                    "dbCreateASQTable failed to insert, %d\n", err);
                            Assert(!"dbCreateASQTable failed to insert\n");
                            return DB_ERR_UNKNOWN_ERROR;
                            break;
                        }
                        break;

                    default:
                        // Something went wrong.
                        if (fSort) {
                            DBCloseSortTable(pDB);
                        }
                        DPRINT1(0, "dbCreateASQTable failed to read, %d\n", err);
                        Assert(!"dbCreateASQTable failed to read\n");
                        return DB_ERR_UNKNOWN_ERROR;
                        break;
                    }
                }
            }
            else {
                if( Count++ >= MaxTableSize ) {
                    // we don't need any more entries
                    Count--;
                    fDone = TRUE;
                    break;
                }
                *pDNTs = DNT;

                pDNTs++;
            }

            //  Move to next, retrieve it's key.
            j++;
        }

        loopCount++;
    
        if (!RangeInf.pRanges || RangeInf.pRanges->upper == -1) {
            break;
        }

        if(StartTick) {       // There is a time limit
            if((GetTickCount() - StartTick) > DeltaTick) {
                if (fSort) {
                    DBCloseSortTable(pDB);
                }
                return DB_ERR_TIMELIMIT;
            }
        }
    }

    Assert (!pDB->Key.pIndex);

    pDB->Key.fSearchInProgress = FALSE;
    pDB->Key.ulEntriesInTempTable = Count;
    pDB->Key.bOnCandidate = FALSE;
    pDB->Key.pIndex = NULL;
    
    
    if (pDB->Key.pVLV || fSort) {
        #if DBG
        DWORD DntIndex = 0;
        #endif

        DPRINT1 (1, "Doing VLV/ASQ using INMEMORY Sorted Table. Num Entries: %d\n", Count);

        pDB->Key.cdwCountDNTs = Count;

        if (Count) {
            if (pDB->Key.pVLV) {
                pDB->Key.pVLV->contentCount = Count;
                pDB->Key.pVLV->currPosition = 1;
            }
            pDB->Key.currRecPos = 1;

            pDNTs = pDB->Key.pDNTs = THAllocEx(pTHS, (Count+1) * sizeof (DWORD));

            err = JetMove(pDB->JetSessID,
                  pDB->JetSortTbl,
                  JET_MoveFirst,
                  0);

            if(!err) {
                do {
                    // OK, pull the DNT out of the sort table
                    DBGetDNTSortTable (
                            pDB,
                            pDNTs);

                    pDNTs++;

                    #ifdef DBG
                        DntIndex++;
                    #endif

                    err = JetMove(pDB->JetSessID,
                                  pDB->JetSortTbl,
                                  JET_MoveNext,
                                  0);

                    if(StartTick) {       // There is a time limit
                        if((GetTickCount() - StartTick) > DeltaTick) {
                            DBCloseSortTable(pDB);
                            return DB_ERR_TIMELIMIT;
                        }
                    }

                } while (!err);
            }

            #if DBG
                Assert (DntIndex == Count);
            #endif
        }

        DBCloseSortTable(pDB);
        pDB->Key.indexType = TEMP_TABLE_MEMORY_ARRAY_TYPE;
    }
    else {
        pDB->Key.cdwCountDNTs = Count;
        pDB->Key.indexType = TEMP_TABLE_MEMORY_ARRAY_TYPE;

        if (Count) {
            pDB->Key.currRecPos = 1;
            pDB->Key.pDNTs = THReAllocEx(pTHS, pDB->Key.pDNTs, (Count+1) * sizeof (DWORD));
        }
        else {
            pDB->Key.currRecPos = 0;
        }
    }

    return 0;
}

/*++

Routine Description:

    Attempt to find an index to use for walking the database for a search.  Sets
    up the index information in the pDB->Key.  If a SortAttribute is given, use
    the index on that attribute if it exists, fail the call if it doesn't.  If
    instructed to fUseFilter, try to pick a better index based on the filter
    supplied on the pDB.

    Note we must use the sort index if a size limit is specified and the
    resultant output is likely to be larger than the size limit.  We do this for
    two reasons.
    1) if they want paged results, we need to be able to come back and continue
    the search.  This is exceedingly tricky to do unless we are walking the sort
    index in the first place (paged results are done via passing back to the
    client the index and associated keys we are using)
    2) Even if they don't want paged results, walking another index requires
    sorting after we evaluate the filter.  It seems to be less than advantageous
    to completely evaluate a filter, getting perhaps many more times the amount
    of data we want, just to sort and then throw most of it away. 


Arguments:

    pDB - The DBPos to use.  Specifies the filter to use.
    
    StartTick - if !0, specifies a time limit is in effect, and this is the tick
            count when the call was started.
            
    DeltaTick - if a time limit is in effect, this is the maximum number of
            ticks past StartTick to allow.

    SortAttr - an optional attribute to sort on.  If 0, no sort specified.
    
    SortType - the type of the sort (SORT_NEVER, SORT_OPTIONAL, SORT_MANTADORY)
    
    Flags - DBCHOOSEINDEX_fUSEFILTER - use filter for choosing better index.
            DBCHOOSEINDEX_fREVERSE_SORT - this is a reverse sort
            DBCHOOSEINDEX_fPAGED_SEARCH - this is a paged search
            DBCHOOSEINDEX_fVLV_SEARCH - this is a VLV search

    MaxTempTableSize - the maximum Temporary size that we are allowed to use
                       for the sorted results.

Return Values:
 
    0 if all went well, 
    DB_ERR_CANT_SORT - no sort exists on specified SortAttr.
    DB_ERR_SHUTTING_DOWN - if we are

--*/    
DWORD
DBChooseIndex (
        IN DBPOS  *pDB,
        IN DWORD   StartTick,
        IN DWORD   DeltaTick,
        IN ATTRTYP SortAttr,
        IN ULONG   SortType,
        IN DWORD   Flags,
        IN DWORD   MaxTempTableSize
        )
{
    THSTATE     *pTHS=pDB->pTHS;
    ULONG       actuallen = 0;
    char        szBuff[MAX_INDEX_NAME];
    char        *pszTempIndex = NULL;
    char        *pszDefaultIndex = NULL;
    ULONG       cbSortKey1, cbSortKey2;
    ULONG       SortedIndexSize = (ULONG)-1;
    BOOL        fPDNT=FALSE;            // Is the sort index over a PDNT index?
    BOOL        fNormalSearch = TRUE;
    BOOL        fVLVSearch = FALSE;
    BOOL        fASQSearch = FALSE;
    BOOL        fUseTempSortedTable = FALSE;
    DWORD       fType = 0;
    DWORD       cAncestors=0;
    DWORD       dwOptFlags=0;
    KEY_INDEX  *pSortIndex = NULL;
    KEY_INDEX  *pTempIndex = NULL;
    KEY_INDEX  *pOptimizedIndex = NULL;
    KEY_INDEX  *pDefaultIndex = NULL;
    DWORD       SortFlags = 0;
    KEY_INDEX  *pIndex = NULL;
    DWORD       ulEstimatedRecsTotal = 0;

    INDEX_RANGE rgIndexRange[2]; // we support indices upto 2 components
                                  // excluding PDNT, DNT etc.
    DWORD       cIndexRanges=0;
    NAMING_CONTEXT_LIST *pNCL;
    ULONG       ulEstimatedSubTreeSize = 0;
    ULONG       ulEstimatedDefaultIndex = 0;
    BOOL        fGetNumRecs;
    ATTCACHE    *pAC;
    BOOL        fIndexIsSingleValued = TRUE;
    DWORD       dwErr;
    BOOL        bAppropriateVLVIndexFound = FALSE;
    BOOL        bSkipCreateSortTable = FALSE;
    BOOL        bSkipUseDefaultIndex = FALSE;
    NCL_ENUMERATOR nclEnum;

    Assert(VALID_DBPOS(pDB));
    if (  eServiceShutdown
        && !(   (eServiceShutdown == eRemovingClients)
             && (pTHS->fDSA)
             && !(pTHS->fSAM))) {
        // Shutting down, bail.
        return DB_ERR_SHUTTING_DOWN;
    }

    pDB->Key.ulSorted = SORT_NEVER;
    pDB->Key.fSearchInProgress = FALSE;
    pDB->Key.bOnCandidate = FALSE;
    pDB->Key.dupDetectionType = DUP_NEVER;
    pDB->Key.cDupBlock = 0;
    pDB->Key.pDupBlock = NULL;
    pDB->Key.indexType = UNSET_INDEX_TYPE;
    
    // init special search flags
    fVLVSearch = Flags & DBCHOOSEINDEX_fVLV_SEARCH;
    fASQSearch = pDB->Key.asqRequest.fPresent;
    // are we instructed to create a temp sort table no matter what the 
    // sort index might be ?
    fUseTempSortedTable = Flags & DBCHOOSEINDEX_fUSETEMPSORTEDTABLE;

    // See if the search is tagged with a hint from SAM
    if(pTHS->pSamSearchInformation) {
        SAMP_SEARCH_INFORMATION *pSearchInfo;
        BOOL fUseFilter;

        // Just a typing shortcut.
        pSearchInfo = pTHS->pSamSearchInformation;
        
        // Save the fUsefilter flag, we might need to restore it.
        fUseFilter = (Flags & DBCHOOSEINDEX_fUSEFILTER);
        
        // We will not use the filter in this case.
        Flags &= ~DBCHOOSEINDEX_fUSEFILTER;

        // And, we aren't going to go through the normal index choice code.
        fNormalSearch = FALSE;

        //
        // Set up the index ranges structure
        //

        rgIndexRange[0].cbValUpper = pSearchInfo->HighLimitLength1;
        rgIndexRange[0].pvValUpper = (BYTE *)pSearchInfo->HighLimit1;
        rgIndexRange[1].cbValUpper = pSearchInfo->HighLimitLength2;
        rgIndexRange[1].pvValUpper = (BYTE *)pSearchInfo->HighLimit2;

        rgIndexRange[0].cbValLower = pSearchInfo->LowLimitLength1;
        rgIndexRange[0].pvValLower = (BYTE *)pSearchInfo->LowLimit1;
        rgIndexRange[1].cbValLower = pSearchInfo->LowLimitLength2;
        rgIndexRange[1].pvValLower = (BYTE *)pSearchInfo->LowLimit2;
        
        switch(pSearchInfo->IndexType) {
        case SAM_SEARCH_SID:
            pszDefaultIndex = SZSIDINDEX;
            fType = 0;
            cIndexRanges = 1;
            break;

        case SAM_SEARCH_NC_ACCTYPE_NAME:
            pszDefaultIndex = SZ_NC_ACCTYPE_NAME_INDEX;
            // This is so dbmakekeyindex knows we are ncdnt based.
            fType = dbmkfir_NCDNT;
            cIndexRanges = 2;
            break;

        case SAM_SEARCH_NC_ACCTYPE_SID:
            pszDefaultIndex = SZ_NC_ACCTYPE_SID_INDEX;
            // This is so dbmakekeyindex knows we are ncdnt based.
            fType = dbmkfir_NCDNT;
            cIndexRanges = 2;
            break;

        case SAM_SEARCH_PRIMARY_GROUP_ID:
            pszDefaultIndex = SZPRIMARYGROUPIDINDEX;
            fType = 0;
            cIndexRanges = 1;
            pAC = SCGetAttById(pTHS, ATT_PRIMARY_GROUP_ID);
            Assert(pAC != NULL);
            fIndexIsSingleValued = pAC->isSingleValued;
            break;

        default:
            //Huh?  Oh, well, skip the search hints.  Undo the setup we did
            // above.
            Assert(FALSE);
            fNormalSearch = TRUE;
            fType = 0;
            Flags |= fUseFilter;
            break;
        }
    }

    // First, set up the default indices so that we can see how big they are.
    if(fNormalSearch) {

        // this is a NormalSearch (not SAM related)
        switch (pDB->Key.ulSearchType) {
        case SE_CHOICE_BASE_ONLY:
            if (!fASQSearch) {
                pDB->Key.pIndex = dbAlloc(sizeof(KEY_INDEX));
                pDB->Key.pIndex->pNext = NULL;
                pDB->Key.pIndex->bIsPDNTBased = FALSE;
                pDB->Key.pIndex->bIsForSort = SortType;
                pDB->Key.ulSorted = SortType;
                pDB->Key.pIndex->bIsSingleValued = TRUE;
                pDB->Key.pIndex->szIndexName = NULL;
                pDB->Key.pIndex->cbDBKeyLower = 0;
                pDB->Key.pIndex->cbDBKeyUpper = 0;
                pDB->Key.pIndex->rgbDBKeyLower = NULL;
                pDB->Key.pIndex->rgbDBKeyUpper = NULL;
                pDB->Key.pIndex->ulEstimatedRecsInRange = 1;
                return 0;
            }
            break;
            
        case SE_CHOICE_IMMED_CHLDRN:
            pszDefaultIndex = SZPDNTINDEX;
            rgIndexRange[0].pvValUpper =  rgIndexRange[0].pvValLower 
                            = (BYTE *)&pDB->Key.ulSearchRootDnt;
            rgIndexRange[0].cbValUpper =  rgIndexRange[0].cbValLower 
                            = sizeof(pDB->Key.ulSearchRootDnt);
            cIndexRanges=1;
            break;
            
        case SE_CHOICE_WHOLE_SUBTREE:

            // subtree search walks the appropriate section of the ancestors
            // index. 
            pszDefaultIndex = SZANCESTORSINDEX;

            // first check whether this sub-tree search starts at root of the DIT
            if (pDB->DNT == ROOTTAG) {
                ulEstimatedSubTreeSize = gulEstimatedAncestorsIndexSize;

                rgIndexRange[0].cbValLower = sizeof (DWORD);
                rgIndexRange[0].pvValLower = THAllocEx (pTHS, sizeof (DWORD));

                *((DWORD *)rgIndexRange[0].pvValLower) = pDB->DNT;

                DPRINT (1, "Subtree Searching on root of GC\n");
            }
            else {
                // then check to see if it a subtree search starting at a known NC
                NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
                NCLEnumeratorSetFilter(&nclEnum, NCL_ENUMERATOR_FILTER_NCDNT, (PVOID)UlongToPtr(pDB->DNT));
                while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
                    if (pNCL->pAncestors) {
                        // cool. we are doing a subtree search on the start of an NC
                        break;
                    }
                }

                // this is the standard case, an arbitrary subtree search
                if (!pNCL) {
                    rgIndexRange[0].cbValLower = 0;
                    rgIndexRange[0].pvValLower = NULL;

                    DBGetAncestors(pDB,
                                   &rgIndexRange[0].cbValLower,
                                   (ULONG **)&rgIndexRange[0].pvValLower,
                                   &cAncestors);
                }
                else {
                    rgIndexRange[0].pvValLower = THAllocEx (pTHS, pNCL->cbAncestors);
                    rgIndexRange[0].cbValLower = pNCL->cbAncestors;
                    memcpy (rgIndexRange[0].pvValLower, pNCL->pAncestors, pNCL->cbAncestors);

                    ulEstimatedSubTreeSize = pNCL->ulEstimatedSize;
                    DPRINT (1, "Subtree Searching on an NC\n");
                }
            }

            rgIndexRange[0].pvValUpper =  rgIndexRange[0].pvValLower;
            rgIndexRange[0].cbValUpper =  rgIndexRange[0].cbValLower;
            cIndexRanges=1;

            ulEstimatedDefaultIndex = ulEstimatedSubTreeSize;

            break;
        }

        Assert (pDB->Key.pIndex == NULL);
    }
    else {
        // this is a special search (SAM), so we need to evaluate this index too
        pDefaultIndex =
            dbMakeKeyIndex(pDB,
                           FI_CHOICE_SUBSTRING,
                           fIndexIsSingleValued,
                           fType,
                           pszDefaultIndex,
                           TRUE,
                           cIndexRanges,
                           rgIndexRange
                           );

        if (Flags & DBCHOOSEINDEX_fUSEFILTER) {
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_QUERY_INDEX_CONSIDERED,
                     szInsertSz(pszDefaultIndex),
                     szInsertUL(pDefaultIndex->ulEstimatedRecsInRange),
                     NULL);
        }

        ulEstimatedDefaultIndex = pDefaultIndex->ulEstimatedRecsInRange;
    }

    
    // for asq mode we don't do any optimizations, since they are meaningless
    //
    if (fASQSearch) {
        goto skipOptimizations;
    }
    
    if(!fVLVSearch && SortType && !fUseTempSortedTable) {
        // An attribute to sort on has been specified.  Set up the name of the
        // index. this is for the simple sort case
        pAC = SCGetAttById(pTHS, SortAttr);
        Assert(pAC != NULL);
        
        if (!pAC) {
            return DB_ERR_CANT_SORT;
        }

        if(dbSetToIndex(pDB, FALSE, &fPDNT, &szBuff[0], pAC)) {
            // Found the required index.
            pszTempIndex = &szBuff[0];
            
            // We are on the sort index, set up the key.
            // See how many are in the sort index, and what the keys are.  Note
            // that the effective search type on this index is present
            // (i.e. we're looking for anything that has a value for the sort
            // index).

            pSortIndex = dbMakeKeyIndex(pDB,
                                        FI_CHOICE_PRESENT,
                                        pAC->isSingleValued,
                                        (fPDNT?dbmkfir_PDNT:0),
                                        pszTempIndex,
                                        TRUE,
                                        0,
                                        NULL
                                        );
            
            pSortIndex->bIsForSort = TRUE;

            pSortIndex->pAC = pAC;

            pSortIndex->bIsPDNTBased = fPDNT;
            // Keep the sort index around, but don't put it in place of the
            // default indices just yet.  
        }
    }
    else if (fVLVSearch) {

        FILTER *pFirstFilter, *pSecondFilter;
        
        // since we are doing vlv, we have an attribute to sort on.
        // set up the index and see if it is a good one.
        pAC = SCGetAttById(pTHS, SortAttr);
        Assert(pAC != NULL);

        if (!pAC) {
            return DB_ERR_CANT_SORT;
        }

        // check for MAPI like VLV search
        // check to see if this a ROOT search, asking for subtree,
        // that refers to a MAPI container. 
        // If so we have to transform this query.
        // what an if statement !!
        //
        if ( (pDB->Key.ulSearchRootDnt == ROOTTAG ) &&
             (pDB->Key.ulSearchType == SE_CHOICE_WHOLE_SUBTREE ) &&
             (pAC->id == ATT_DISPLAY_NAME) &&
             pDB->Key.pFilter &&
             (pDB->Key.pFilter->choice == FILTER_CHOICE_AND) &&
             (pFirstFilter = pDB->Key.pFilter->FilterTypes.And.pFirstFilter) &&
             (pFirstFilter->choice == FILTER_CHOICE_ITEM) &&
             (pFirstFilter->FilterTypes.Item.choice == FI_CHOICE_EQUALITY) &&
             (pFirstFilter->FilterTypes.Item.FilTypes.ava.type == ATT_SHOW_IN_ADDRESS_BOOK) && 
             (pSecondFilter = pFirstFilter->pNextFilter) && 
             (pSecondFilter->choice == FILTER_CHOICE_ITEM) &&
             (pSecondFilter->FilterTypes.Item.choice == FI_CHOICE_PRESENT) &&
             (pSecondFilter->FilterTypes.Item.FilTypes.present == ATT_DISPLAY_NAME)) {

            ATTCACHE    *pABAC;
            INDEX_RANGE IndexRange;       
            AVA         *pAVA;

            pABAC = SCGetAttById(pTHS, ATT_SHOW_IN_ADDRESS_BOOK);
            Assert(pABAC != NULL);
            
            if (dbSetToIndex(pDB, TRUE, &fPDNT, &szBuff[0], pABAC)) {
                
                pAVA = &pDB->Key.pFilter->FilterTypes.And.pFirstFilter->FilterTypes.Item.FilTypes.ava;
                pszTempIndex = &szBuff[0];

                // fake this as a one level search
                pDB->Key.ulSearchType = SE_CHOICE_IMMED_CHLDRN;
                pDB->Key.ulSearchRootDnt = *(DWORD *)pAVA->Value.pVal;

                pDB->Key.pVLV->bUsingMAPIContainer = TRUE;
                pDB->Key.pVLV->MAPIContainerDNT = *(DWORD *)pAVA->Value.pVal;
                DPRINT1 (0, "VLV/MAPI on container: %d\n", pDB->Key.ulSearchRootDnt);

                IndexRange.cbValLower = pAVA->Value.valLen;
                IndexRange.pvValLower = pAVA->Value.pVal;
                IndexRange.cbValUpper = pAVA->Value.valLen;
                IndexRange.pvValUpper = pAVA->Value.pVal;

                pSortIndex = dbMakeKeyIndex(pDB,
                                            FI_CHOICE_PRESENT,
                                            pAC->isSingleValued,
                                            0,
                                            pszTempIndex,
                                            TRUE,
                                            1,
                                            &IndexRange
                                            );
                
                bAppropriateVLVIndexFound = TRUE;

                pSortIndex->bIsForSort = TRUE;

                pSortIndex->pAC = pAC;

            }
            else {
                DPRINT (0, "Doing VLV(MAPI like) and no INDEX found\n");
            }
        }
        else if(dbSetToIndex(pDB, FALSE, &fPDNT, &szBuff[0], pAC)) {
            // Found the required index.
            pszTempIndex = &szBuff[0];
            
            // We are on the sort index, set up the key.
            // See how many are in the sort index, and what the keys are.  

            // Note that the effective search type on this index is present.
            // (i.e. we're looking for anything that has a value for the sort
            // index under the specified container).

            DPRINT1 (1, "Using Index for VLV %s\n", pszTempIndex);

            pSortIndex = dbMakeKeyIndex(pDB,
                                        FI_CHOICE_PRESENT,
                                        pAC->isSingleValued,
                                        (fPDNT?dbmkfir_PDNT:0),
                                        pszTempIndex,
                                        TRUE,
                                        0,
                                        NULL
                                        );

            pSortIndex->pAC = pAC;

            if (pDB->Key.ulSearchType == SE_CHOICE_IMMED_CHLDRN) {

                if (fPDNT == FALSE) {
                    // we found an index, but we would be better of if we had a 
                    // PDNT index on this sorted attribute, since we are doing
                    // VLV in one level

                    DPRINT (0, "Doing VLV on Immediate Children and no PDNT INDEX found\n");

                    // HINT: when WMI is available, use trace for this event
                    LogEvent8(DS_EVENT_CAT_FIELD_ENGINEERING,
                             DS_EVENT_SEV_EXTENSIVE,
                             DIRLOG_SEARCH_VLV_INDEX_NOT_FOUND,
                             szInsertSz(pAC->name), 
                             NULL, NULL, NULL, NULL, NULL, NULL, NULL);
                }
                else {
                    // we have a VLV sort index, and this is a good one

                    bAppropriateVLVIndexFound = TRUE;

                    pSortIndex->bIsPDNTBased = fPDNT;
                }
            }
            
            pSortIndex->bIsForSort = TRUE;
            // Keep the sort index around, but don't put it in place of the
            // default indices just yet.  
        }
        else {
            // we didn't find the required index for sorting
            // if we are doing VLV we want to keep track of the requested
            // index, cause we might rebuild this index later

            DPRINT (1, "Doing VLV and no appropriate INDEX found\n");

            if (pDB->Key.ulSearchType == SE_CHOICE_IMMED_CHLDRN) {

                // HINT: when WMI is available, use trace for this event
                LogEvent8(DS_EVENT_CAT_FIELD_ENGINEERING,
                         DS_EVENT_SEV_EXTENSIVE,
                         DIRLOG_SEARCH_VLV_INDEX_NOT_FOUND,
                         szInsertSz(pAC->name), 
                         NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            }
        }
    }
    

    // now optimize the filter if we are allowed to.
    // we optimize the filter if the flags say so and the estimated default index
    // is unknown or is more that a specified number of entries, cause we believe
    // we might do better, by taking the risk of the extra cycles

    // PERFHINT: we need to know later if we ever find a more restrictive index
    // range over the index we are sorting on (if we are sorting), and
    // dbOptFilter doesn't give back that info.  If we do, then in the case
    // later on where we have to fall back to walking the search index, we can
    // use the better limits.  We might even find that two subranges of the
    // index were found, which if disjoing implies a null result set, and if not
    // disjoint, implies a smaller range.
    
    if ((Flags & DBCHOOSEINDEX_fUSEFILTER) && 
         ( (ulEstimatedDefaultIndex == 0) || 
           (ulEstimatedDefaultIndex > MIN_NUM_ENTRIES_ON_OPT_INDEX)) ) {

        // if this is a paged search or 
        // a VLV search and a sort index was not found, 
        // we cannot use index intersections cause there is 
        // no efficient way  to restart intersect index operations

        if ((Flags & DBCHOOSEINDEX_fPAGED_SEARCH) || 
            (fVLVSearch && bAppropriateVLVIndexFound) ||
            ((SortType != SORT_NEVER) && !fVLVSearch)) {

            dwOptFlags |= DBOPTINDEX_fDONT_INTERSECT;
        }
        if (Flags & DBCHOOSEINDEX_fDELETIONS_VISIBLE) {
            //
            // Tuple indexes do not include deleted object, so we can't 
            // use them on a search that must return deleted objects.
            //
            dwOptFlags |= DBOPTINDEX_fDONT_OPT_MEDIAL_SUBTSTRING;
        }

        dbOptFilter(pDB,
                    dwOptFlags,
                    &pOptimizedIndex,
                    pDB->Key.pFilter);

        if(pOptimizedIndex) {
            // if we are sorting, and it happened that the filter
            // matched the sort order (same index), we are not going to 
            // drop this one, even if the index that we have now 
            // (propably ancestors index) might be a better choice
            if (pSortIndex &&
                pOptimizedIndex->pNext == NULL &&
                pOptimizedIndex->szIndexName &&
                !fVLVSearch &&
                strcmp (pOptimizedIndex->szIndexName, pSortIndex->szIndexName) == 0) {

                    bSkipCreateSortTable = TRUE;
                    bSkipUseDefaultIndex = TRUE;

                    DPRINT2 (1, "Using Sorted Index: %s %d\n", 
                            pOptimizedIndex->szIndexName, 
                            pOptimizedIndex->ulEstimatedRecsInRange);

                    if (pDefaultIndex) {
                        dbFreeKeyIndex(pTHS, pDefaultIndex);
                        pDefaultIndex = NULL;
                    }
                    pOptimizedIndex->bIsForSort = TRUE;
            }
        }
    }

    // now have a look at the default index, if needed
    //
    if (fNormalSearch && 
        (!bSkipUseDefaultIndex) &&
        ( (pOptimizedIndex== NULL) || 
          (pOptimizedIndex->ulEstimatedRecsInRange > MIN_NUM_ENTRIES_ON_OPT_INDEX) ) ) {

        Assert (pDefaultIndex == NULL);

        // if we know the size (ulEstimatedSubTreeSize != 0), 
        //    then there is no need calculating it again
        // if we don't know the size (ulEstimatedSubTreeSize == 0)
        //    then we have to calculate the size only if we had an index as a
        //    result of the filter optimization (pOptimizedIndex) or we 
        //    are considering of using a sortIndex (pSortIndex).
        fGetNumRecs = ulEstimatedSubTreeSize ? 
                          0 : ( (pOptimizedIndex!=NULL) || (pSortIndex!=NULL) );

        // now evaluate the index
        pDefaultIndex =
            dbMakeKeyIndex(pDB,
                           FI_CHOICE_SUBSTRING,
                           fIndexIsSingleValued,
                           fType,
                           pszDefaultIndex,
                           fGetNumRecs,
                           cIndexRanges,
                           rgIndexRange
                           );

        // when fGetNumRecs is FALSE, this means that ulEstimatedSubTreeSize !=0 or 
        // that we don't care, since we don't have an optimized index or sort index, 
        // so we don't bother finding the real value of the entries which is set 
        // to zero in dbMakeKeyIndex. 

        if (ulEstimatedSubTreeSize) {
            pDefaultIndex->ulEstimatedRecsInRange = ulEstimatedSubTreeSize;
            DPRINT1 (1, "Used estimated subtree size: %d\n", ulEstimatedSubTreeSize);
        }

        if (Flags & DBCHOOSEINDEX_fUSEFILTER) {
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_QUERY_INDEX_CONSIDERED,
                     szInsertSz(pszDefaultIndex),
                     szInsertUL(pDefaultIndex->ulEstimatedRecsInRange),
                     NULL);
        }
    }

    // decide which index is better, the default or the optimized one ?
    //
    if (pDefaultIndex) {
        if (pOptimizedIndex) {
            if (pOptimizedIndex->ulEstimatedRecsInRange <
                      pDefaultIndex->ulEstimatedRecsInRange) {
                // the optimized index was better than the default one
                dbFreeKeyIndex(pTHS, pDefaultIndex);
                pDB->Key.pIndex = pOptimizedIndex;
                pDefaultIndex = NULL;
            }
            else {
                dbFreeKeyIndex(pTHS, pOptimizedIndex);
                pOptimizedIndex = NULL;
                pDB->Key.pIndex = pDefaultIndex;
            }
        }
        else {
            pDB->Key.pIndex = pDefaultIndex;
        }
    }
    else {
        // use the optimized index, if existing
        pDB->Key.pIndex = pOptimizedIndex;
    }

    Assert (pDB->Key.pIndex);

skipOptimizations:

    if (  eServiceShutdown
        && !(   (eServiceShutdown == eRemovingClients)
             && (pTHS->fDSA)
             && !(pTHS->fSAM))) {
        // Shutting down, bail.
        return DB_ERR_SHUTTING_DOWN;
    }

    // Assume we have sorted if they asked us to.
    pDB->Key.ulSorted = SortType;
    
    if(SortType && !fASQSearch) {
        if(pSortIndex) {
            MaxTempTableSize = min(MaxTempTableSize,
                                   (pSortIndex->ulEstimatedRecsInRange +
                                    pDB->Key.pIndex->ulEstimatedRecsInRange));

            if (!bSkipCreateSortTable) {
                if (pDB->Key.pIndex &&
                    pDB->Key.pIndex->pNext == NULL &&
                    pDB->Key.pIndex->szIndexName &&
                    !fVLVSearch &&
                    strcmp (pDB->Key.pIndex->szIndexName, pSortIndex->szIndexName) == 0) {

                        bSkipCreateSortTable = TRUE;

                        DPRINT2 (1, "Using Sorted Index: %s %d\n", 
                                pDB->Key.pIndex->szIndexName, 
                                pDB->Key.pIndex->ulEstimatedRecsInRange);

                        pDB->Key.pIndex->bIsForSort = TRUE;
                }
                else if (bAppropriateVLVIndexFound) {

                    bSkipCreateSortTable = TRUE;

                    DPRINT2 (1, "Using Sorted Index: %s %d\n", 
                            pSortIndex->szIndexName, 
                            pSortIndex->ulEstimatedRecsInRange);
                }
            }
        }

        if (!bSkipCreateSortTable) {
            if (Flags & DBCHOOSEINDEX_fREVERSE_SORT) {
                SortFlags = SortFlags | DB_SORT_DESCENDING;
            }
            for (pIndex = pDB->Key.pIndex; pIndex != NULL; pIndex = pIndex->pNext) {
                ulEstimatedRecsTotal += pIndex->ulEstimatedRecsInRange;
            }
            if (ulEstimatedRecsTotal >= MIN_NUM_ENTRIES_FOR_FORWARDONLY_SORT) {
                SortFlags = SortFlags | DB_SORT_FORWARDONLY;
            }
        }

        // OK, we are to sort.  See if we should use a pre-sort.
        if( (bSkipCreateSortTable || dbCreateSortedTable(pDB, 
                                                  StartTick, 
                                                  DeltaTick, 
                                                  SortAttr,
                                                  SortFlags,
                                                  MaxTempTableSize) ) ) {
            
            // Either we couldn't create a pre-sort, or we thought it was too
            // big. Our only fall back now is to use a sort index.
            if(!pSortIndex) {
                // We can't sort.
                pDB->Key.ulSorted = SORT_NEVER;
                
                // See if we need to care.
                if (fVLVSearch == TRUE) {
                    return DB_ERR_CANT_SORT;
                }
                else if(SortType == SORT_MANDATORY || fUseTempSortedTable) {
                    // Yes, we need to care.
                    return DB_ERR_CANT_SORT;
                }
                // ELSE 
                //     No, the sort was optional.  Blow it off.
            }
            else {
                if (fVLVSearch && (bSkipCreateSortTable == FALSE)) {
                    // we are doing VLV and the sortindex that we had was not good
                    // we expected to be able to create a SORT table, but we failed
                    return DB_ERR_CANT_SORT;
                }
                // use the sort index we found for VLV
                else if (bAppropriateVLVIndexFound) {
                    
                    if (pDB->Key.pIndex) {
                        dbFreeKeyIndex (pTHS, pDB->Key.pIndex);
                    }
                    pDB->Key.pIndex = pSortIndex;
                    pSortIndex = NULL;
                }
                // We can sort
                else if(SortType == SORT_MANDATORY) {
                    // And, we have to sort.  Stitch the sort index in to the
                    // list of indices to walk.

                    // The index already in the key will find every object that
                    // matches the filter.  The pSortIndex will match every
                    // object in the filter (and lots more besides) EXCEPT those
                    // objects which have a NULL value.  Thus, to satisfy a
                    // forward sort, we will first walk the sort index then the
                    // rest of the indices.  This gets us all the objects with
                    // values for the sort attribute in the correct order, and
                    // then the objects with NULL values sorted to the end of
                    // the list. A mechanism in dbMatchSearchCriteria keeps us
                    // from return objects twice.  Also, it lets us ignore those
                    // objects on the sort index that effectively have no value
                    // for the sort attribute due to security (note we then pick
                    // them up in the other indices).  So, to make everything
                    // work out, we add the sort index to the head of the list
                    // of indices in the forward sort case, and the tail of the
                    // list in the reverse sort case.

                    // if it happened that the sort index and the filter index
                    // are the same (bSkipCreateSortTable==TRUE from above), 
                    // we should use only one of them. so we choose to use 
                    // the index from the filter optimization (since it is better)
                    // (we don't worry about skipping null entries which are included 
                    // in the sortIndex, since the filter would match them eitherway.)
                    if (!bSkipCreateSortTable) {
                        if(Flags & DBCHOOSEINDEX_fREVERSE_SORT) {

                            for(pTempIndex = pDB->Key.pIndex;
                                (pTempIndex != NULL) && (pTempIndex->pNext != NULL);
                                pTempIndex = pTempIndex->pNext)
                                    ;

                            if (pTempIndex != NULL) {
                                pTempIndex->pNext = pSortIndex;
                            }
                            else {
                                pDB->Key.pIndex = pSortIndex;
                            }
                            pSortIndex->pNext = NULL;
                            // we no longer need it. it will be freed when 
                            // pDB->key is freed
                            pSortIndex = NULL;
                        }
                        else {
                            pSortIndex->pNext = pDB->Key.pIndex;
                            pSortIndex->ulEstimatedRecsInRange +=
                                pDB->Key.pIndex->ulEstimatedRecsInRange;
                            pDB->Key.pIndex = pSortIndex;

                            // we no longer need it. it will be freed when 
                            // pDB->key is freed
                            pSortIndex = NULL;
                        }
                    }
                }
                else {
                    // OK, we don't actually have to sort.  However, we could if
                    // we wanted to.
                    // For now, we don't sort.  We could check to see if
                    // this makes the ulEstimatedRecsInRange not too much
                    // larger, and sort if it doesn't.  Later.
                    pDB->Key.ulSorted = SORT_NEVER;
                }
            }
        }
    }
    else if(SortType && fASQSearch) {
        DPRINT (1, "Doing Sorted ASQ\n");

        if (dbCreateASQTable(pDB, 
                             StartTick, 
                             DeltaTick, 
                             MaxTempTableSize,
                             TRUE,
                             SortAttr) ) {

            return DB_ERR_CANT_SORT;
        }
    }
    else if (fASQSearch) {
        DPRINT (1, "Doing Simple ASQ\n");

        if (dwErr = dbCreateASQTable(pDB, 
                                     StartTick, 
                                     DeltaTick, 
                                     pDB->Key.ulASQSizeLimit,
                                     FALSE,
                                     0) ) {
            return dwErr;
        }
    }
    
    if (pSortIndex) {
        dbFreeKeyIndex (pTHS, pSortIndex);
    }
    
    if (fVLVSearch && pDB->Key.pIndex) {
        pDB->Key.pVLV->contentCount = pDB->Key.pIndex->ulEstimatedRecsInRange;
        pDB->Key.pVLV->currPosition = 1;
    }

    if(SORTED_INDEX (pDB->Key.indexType)) {
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_VERBOSE,
                 DIRLOG_QUERY_INDEX_CHOSEN,
                 szInsertSz("Sorted Temporary Table"),
                 NULL,
                 NULL);
    }
    else if (fASQSearch) {
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_VERBOSE,
                 DIRLOG_QUERY_INDEX_CHOSEN,
                 szInsertSz("ASQ Table"),
                 NULL,
                 NULL);
    }
    else {
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_VERBOSE,
                 DIRLOG_QUERY_INDEX_CHOSEN,
                 szInsertSz(pDB->Key.pIndex->szIndexName),
                 NULL,
                 NULL);
    }
    
    // Set up the temp table to filter out duplicates.
    if((pDB->Key.indexType == TEMP_TABLE_INDEX_TYPE) || fVLVSearch || fASQSearch) {
        pDB->Key.dupDetectionType = DUP_NEVER;
    }
    else if(pDB->Key.pIndex->bIsSingleValued &&
            !pDB->Key.pIndex->pNext &&
            pDB->Key.indexType != TUPLE_INDEX_TYPE) {
        // We're walking one, single-valued, index.  We believe that we'll never
        // find duplicates.

        // we could also use this if we are walking multiple ranges of
        // one single-valued attribute.
        pDB->Key.dupDetectionType = DUP_NEVER;
    }
    else if(pDB->Key.pIndex->bIsEqualityBased &&
            !pDB->Key.pIndex->pNext) {
        // We're walking one index, doing an equality search.  Our range on the
        // index should include ONLY those values which are equal.  Since it is
        // impossible for an object to have multiple equal values for a single
        // attribute, we believe that this range of the index will never have a
        // duplicate in it.  So, set the duplicate detection algorithm to not
        // check for duplicates.
        pDB->Key.dupDetectionType = DUP_NEVER;
    }
    else {
        // OK, create the memory block to track duplicates
        pDB->Key.pDupBlock = THAllocEx(pTHS, DUP_BLOCK_SIZE * sizeof(DWORD));
        pDB->Key.cDupBlock = 0;
        pDB->Key.dupDetectionType = DUP_MEMORY;
    }

    return 0;
}

// translate a value from external to internal format, moving from one ATTRVAL
// to another

DWORD
MakeInternalValue (
        DBPOS *pDB,
        int syntax,
        ATTRVAL *pInAVal,
        ATTRVAL *pOutAVal)
{
    THSTATE *pTHS=pDB->pTHS;
    UCHAR *puc;
    ULONG intLen;

    
    int status =  gDBSyntax[syntax].ExtInt(pDB,
                                           DBSYN_INQ,
                                           pInAVal->valLen,
                                           pInAVal->pVal,
                                           &intLen,
                                           &puc,
                                           0,
                                           0,
                                           0);

    Assert(VALID_DBPOS(pDB));

    if (status)
        return status;

    pOutAVal->valLen = intLen;
    pOutAVal->pVal = THAllocEx(pTHS, intLen);
    memcpy(pOutAVal->pVal, puc, intLen);
    
    return 0;
}

DWORD dbFreeFilterItem (DBPOS *pDB, FILTER *pFil)
{
    THSTATE *pTHS = pDB->pTHS;
    SUBSTRING *pSub;
    ANYSTRINGLIST *pAny, *pAny2;

    if (!pFil) {
        return 0;
    }
    Assert (pFil->choice == FILTER_CHOICE_ITEM);

    switch(pFil->FilterTypes.Item.choice) {
    case FI_CHOICE_SUBSTRING:

        pSub = pFil->FilterTypes.Item.FilTypes.pSubstring;

        if (pSub->initialProvided && pSub->InitialVal.pVal) {
            THFreeEx (pTHS, pSub->InitialVal.pVal);
        }
        if (pSub->finalProvided && pSub->FinalVal.pVal) {
            THFreeEx (pTHS, pSub->FinalVal.pVal);
        }

        if (pSub->AnyVal.count) {

            pAny = pSub->AnyVal.FirstAnyVal.pNextAnyVal;

            if (pSub->AnyVal.FirstAnyVal.AnyVal.pVal) {
                THFreeEx (pTHS, pSub->AnyVal.FirstAnyVal.AnyVal.pVal);
            }

            while (pAny) {
                pAny2 = pAny->pNextAnyVal;

                THFreeEx (pTHS, pAny->AnyVal.pVal);

                pAny = pAny2;
            }

            if (pSub->AnyVal.FirstAnyVal.pNextAnyVal) {
                THFreeEx(pTHS, pSub->AnyVal.FirstAnyVal.pNextAnyVal);
            }
        }

        THFreeEx (pTHS, pSub);
        break;

    case FI_CHOICE_PRESENT:
    case FI_CHOICE_TRUE:
    case FI_CHOICE_FALSE:
    case FI_CHOICE_UNDEFINED:
        break;

    default:
        if (pFil->FilterTypes.Item.FilTypes.ava.Value.pVal) {
            THFreeEx (pTHS, pFil->FilterTypes.Item.FilTypes.ava.Value.pVal);
        }
        break;
    }

    return 0;
}

DWORD dbFreeFilter(DBPOS *pDB, FILTER *pFil)
{
    THSTATE *pTHS = pDB->pTHS;
    FILTER *pTemp, *pTemp2;
    DWORD err;

    if (!pFil || pDB->Key.fDontFreeFilter) {
        return 0;
    }

    pTemp = pFil;

    while (pTemp) {
        pTemp2 = pTemp->pNextFilter;

        switch (pTemp->choice) {
        case FILTER_CHOICE_AND:
            if (err = dbFreeFilter (pDB, pTemp->FilterTypes.And.pFirstFilter)) {
                return err;
            }
            break;

        case FILTER_CHOICE_OR:
            if (err = dbFreeFilter (pDB, pTemp->FilterTypes.Or.pFirstFilter)) {
                return err;
            }
            break;

        case FILTER_CHOICE_NOT:
            if (err = dbFreeFilter (pDB, pTemp->FilterTypes.pNot)) {
                return err;
            }
            break;

        case FILTER_CHOICE_ITEM:

            if (err = dbFreeFilterItem (pDB, pTemp)) {
                return err;
            }
            break;

        default:
            return DB_ERR_UNKNOWN_ERROR;

        }  /*switch FILTER*/

        THFreeEx (pTHS, pTemp);

        pTemp = pTemp2;
    }
    
    return 0;
}

DWORD
IsConstFilterType (
        FILTER * pFil
        )
{
    if(pFil->choice == FILTER_CHOICE_ITEM) {
        return pFil->FilterTypes.Item.choice;
    }
    else {
        return FI_CHOICE_PRESENT;
    }
}

DWORD
dbMakeANRItem (
        DBPOS   *pDB,
        FILITEM *pFilterItem,
        BOOL     fExact,
        ATTRTYP  aid,
        ATTRVAL *pVal
        )
/*++
Make an ANR filter item based on the incoming pVal.  pVal should be holding a
unicode valued, aid holds the attribute we're going to search for, pFilterItem
is the pointer to the item filter to instantiate.  If fExact, we're need to do
an equality filter, otherwise it's an initial substring filter.

--*/       
{
    THSTATE   *pTHS=pDB->pTHS;
    ATTCACHE  *pAC;
    SUBSTRING *pOut;
    ATTRVAL   *pOutVal;
    ATTRVAL   TempVal;

    if(!fExact) {
        pOut = THAllocEx(pTHS, sizeof(SUBSTRING));
        pFilterItem->FilTypes.pSubstring = pOut;
        pFilterItem->choice  = FI_CHOICE_SUBSTRING;
        
        pOut->type = aid;
        pOut->initialProvided = TRUE;
        pOut->finalProvided = FALSE;
        pOut->AnyVal.count = 0;
        pOut->AnyVal.FirstAnyVal.pNextAnyVal = NULL;
        pOutVal = &pOut->InitialVal;
        
    }
    else {
        // Do an exact equality match.
        pFilterItem->choice  = FI_CHOICE_EQUALITY;
        pFilterItem->FilTypes.ava.type = aid;
        pOutVal = &pFilterItem->FilTypes.ava.Value;
    }
    
    pAC = SCGetAttById(pTHS, aid);
    if(pAC) {
        switch(pAC->syntax) {
        case SYNTAX_UNICODE_TYPE:
            
            return MakeInternalValue(pDB,
                                     pAC->syntax,
                                     pVal,
                                     pOutVal);
            
            break;
            
        case SYNTAX_CASE_STRING_TYPE:
        case SYNTAX_NOCASE_STRING_TYPE:
        case SYNTAX_PRINT_CASE_STRING_TYPE:
            // These are all string 8 types.  Translate to string 8
            
            TempVal.pVal =
                String8FromUnicodeString(TRUE,
                                         CP_TELETEX,
                                         (wchar_t *)pVal->pVal,
                                         pVal->valLen/sizeof(wchar_t),
                                         &TempVal.valLen,
                                         NULL);
            
            return MakeInternalValue(pDB,
                                     pAC->syntax,
                                     &TempVal,
                                     pOutVal);
            break;
        default:
            DPRINT1(2, "DBMakeANRItem got bad syntax, %X\n", pAC->syntax);
            Assert(!"DBMakeANRItem got bad syntax, %X\n");
            return DB_ERR_UNKNOWN_ERROR;
            break;
        }
    }
     
    DPRINT1(2, "DBMakeANRItem got unknowtn attribute, %X\n", aid);
    Assert(!"DBMakeANRItem got unknowtn attribute, %X\n");
    return DB_ERR_UNKNOWN_ERROR;
}

VOID
dbMakeANRFilter (
        DBPOS *pDB,
        FILTER *pFil,
        FILTER **ppOutFil
        )
/*++
  Given an ANR item filter and a pointer to already allocated output filter,
  make the output filter into a valid ANR filter tree.
  Returns 0 for success.
  Returns non-zero for error, and frees all allocated memory INCLUDING the
  ppOutFil.
--*/  
{
    THSTATE    *pTHS=pDB->pTHS;
    USHORT     count=0, itemCount = 0;
    PFILTER    pOutFil;
    PFILTER    pTemp, pTemp2;
    DWORD      dwStatus;
    ATTRVAL   *pVal;
    DWORD     *pIDs = NULL;
    DWORD      i;
    wchar_t   *pStringTemp;
    wchar_t   *pFirst=NULL, *pLast=NULL;
    DWORD      cbFirst=0, cbLast = 0;
    BOOL       fExact=FALSE;
    ULONG      expectedIndexSize;
    

    pDB->Key.fDontFreeFilter = TRUE;

    // Make an 'OR' filter over the various ANR attributes
    pOutFil = *ppOutFil;
    
    pOutFil->choice = FILTER_CHOICE_OR;

    // Pluck out the string to ANR on.  If they gave us a substring filter, we
    // use the initial value and ignore the rest.  If they gave us a normal
    // filter, use the string from that.  Note that we don't pay any attention
    // to the type of filter they specified (i.e. ==, <= , etc.).
    if(pFil->FilterTypes.Item.choice == FI_CHOICE_SUBSTRING) {
        if(!pFil->FilterTypes.Item.FilTypes.pSubstring->initialProvided) {
            // No initial substring.  Turn this into an undefined.
            pOutFil->choice = FILTER_CHOICE_ITEM;
            pOutFil->FilterTypes.Item.choice = FI_CHOICE_UNDEFINED;
            return;
        }
        
        pVal = &pFil->FilterTypes.Item.FilTypes.pSubstring->InitialVal;
    }
    else {
        pVal = &pFil->FilterTypes.Item.FilTypes.ava.Value;
    }

    // Note from the above that we ignore non-initial provided substrings.
    // Now, massage the value.  First, we trim initial whitespace.
    pStringTemp = (wchar_t *)pVal->pVal;
    while(pVal->valLen && (*pStringTemp == L' ' || *pStringTemp == L'\t')) {
        pVal->valLen -= sizeof(wchar_t);
        pStringTemp++;
    }

    // Look for an '=' here, implying exact match, not initial substring
    // (initial substring is the default).
    if(pVal->valLen && *pStringTemp == L'=') {
        // Found one.
        fExact = TRUE;
        pStringTemp++;
        pVal->valLen -= sizeof(wchar_t);
        // And, skip any more leading whitespace
        while(pVal->valLen && (*pStringTemp == L' ' || *pStringTemp == L'\t')) {
            pVal->valLen -= sizeof(wchar_t);
            pStringTemp++;
        }
    }

    // Now, remove trailing whitespace.
    pVal->pVal = (PUCHAR)pStringTemp;
    
    if (pVal->valLen >= sizeof(wchar_t)) {
        pStringTemp = &pStringTemp[(pVal->valLen/sizeof(wchar_t)) - 1];
        while(pVal->valLen && (*pStringTemp == L' ' || *pStringTemp == L'\t')) {
            pVal->valLen -= sizeof(wchar_t);
            pStringTemp--;
        }
    }

    if(!pVal->valLen) {
        // ANRing on nothing.  Set filter to match nothing and return.
        pOutFil->choice = FILTER_CHOICE_ITEM;
        pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
        return;
    }

    
    if(!gfSupressFirstLastANR ||
       !gfSupressLastFirstANR    ) {
        // Not supressing both forms of first/last ANR
        
        // The final massage is to look for a medial whitespace and split the
        // string at that whitespace, copying the two fragments to scratch
        // space.  Then, make a ((firstname AND lastname) OR (lastname AND
        // firstname)) filter using the two fragments.
        pFirst = THAllocEx(pTHS, pVal->valLen);
        pStringTemp = (wchar_t *)pVal->pVal;
        i=0;
        while(i < pVal->valLen/sizeof(wchar_t) &&
              (*pStringTemp != L' ' && *pStringTemp != L'\t')) {
            pFirst[i] = *pStringTemp;
            i++;
            pStringTemp++;
        }
        if(i < pVal->valLen/sizeof(wchar_t)) {
            cbFirst = i * sizeof(wchar_t);
            
            // There was some medial whitespace
            while(*pStringTemp == L' ' || *pStringTemp == L'\t') {
                pStringTemp++;
                i++;
            }
            cbLast = (pVal->valLen - (i * sizeof(wchar_t)));
            pLast = THAllocEx(pTHS, cbLast);
            memcpy(pLast, pStringTemp, cbLast);
        }
        // At this point, cbLast != 0 implies we were able to split the string.
    }
    else {
        // No splitting necessary.
        cbLast = 0;
    }
    
    // Now, find the attributes we do ANR over.
    count = (USHORT)SCGetANRids(&pIDs);
    if(!count && !cbLast) {
        // Nothing to ANR on, no first/last filter necessary.  Set filter to
        // match nothing and return. 
        pOutFil->choice = FILTER_CHOICE_ITEM;
        pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
        return;
    }
    
    pOutFil->FilterTypes.Or.count = count;
    if(cbLast) {
        // And, we're doing a first/last last/first filter
        pOutFil->FilterTypes.Or.count+= 2;
        
        if(gfSupressFirstLastANR) {
            // Actually, we're not doing the first/last anr
            pOutFil->FilterTypes.Or.count-=1;
        }
        if(gfSupressLastFirstANR) {
            // Actually, we're not doing the last/first anr
            pOutFil->FilterTypes.Or.count-=1;
        }
        
    }

    // calculate the expected Index Size that the indexes used in ANR will have
    if ((pVal->valLen / 2) > 3) {
        expectedIndexSize = 1;
    }
    else {
        expectedIndexSize = 1;
        for (i = 4 - (pVal->valLen / 2 ); i; i--) {
            expectedIndexSize = expectedIndexSize * 10;
        }
    }

    pTemp = THAllocEx(pTHS, pOutFil->FilterTypes.Or.count * sizeof(FILTER));
    pOutFil->FilterTypes.Or.pFirstFilter = pTemp;

    
    itemCount=0;
    for(i=0;i<count;i++) {
        pTemp->choice = FILTER_CHOICE_ITEM;

        // this check is to ensure that on ATT_LEGACY_EXCHANGE_DN we do exact match.

        if(!dbMakeANRItem(pDB,
                          &pTemp->FilterTypes.Item,
                          (pIDs[i] == ATT_LEGACY_EXCHANGE_DN) ? TRUE : fExact,
                          pIDs[i],
                          pVal)) {
            // Succeeded in making an anr item.
            pTemp->FilterTypes.Item.expectedSize = expectedIndexSize;

            pTemp->pNextFilter = &pTemp[1];
            pTemp++;
            itemCount++;
        }
    }
    
    if(cbLast) {
        // We have a first/last or last/first ANR to do
        Assert(!gfSupressFirstLastANR || !gfSupressLastFirstANR);
        
        if(!gfSupressFirstLastANR) {
            // First, make the (firstname AND lastname) filter.
            pTemp->choice = FILTER_CHOICE_AND;
            pTemp->FilterTypes.And.count = 2;

            pTemp2 = THAllocEx(pTHS, 2 * sizeof(FILTER));
            pTemp->FilterTypes.And.pFirstFilter = pTemp2;
            // Make the "firstname" portion.
            pTemp2->choice = FILTER_CHOICE_ITEM;

            pVal->valLen = cbFirst;
            pVal->pVal = (PUCHAR)pFirst;
            
            if(!dbMakeANRItem(pDB,
                              &pTemp2->FilterTypes.Item,
                              fExact,
                              ATT_GIVEN_NAME,
                              pVal)) {
                
                // Set estimated hint to zero so as to calculate 
                pTemp2->FilterTypes.Item.expectedSize = 0;

                // Succeeded in translating given name, continue.
                pTemp2->pNextFilter = &pTemp2[1];
                pTemp2++;
                
                
                // Now, make the "lastname" portion.
                pTemp2->choice = FILTER_CHOICE_ITEM;
                
                pVal->valLen = cbLast;
                pVal->pVal = (PUCHAR)pLast;
                if(!dbMakeANRItem(pDB,
                                  &pTemp2->FilterTypes.Item,
                                  fExact,
                                  ATT_SURNAME,
                                  pVal)) {
                    // Set estimated hint to zero so as to calculate 
                    pTemp2->FilterTypes.Item.expectedSize = 0;
                    pTemp2->pNextFilter = NULL;
                    
                    pTemp->pNextFilter = &pTemp[1];
                    // We made a (firstname AND lastname) filter.  Now, make the
                    // (lastname AND firstname) filter, if we need to.
                    itemCount++;
                    pTemp++;
                }
            }
        }
        
        if(!gfSupressLastFirstANR) {
            // Now, the (lastname AND firstname) filter.
            pTemp->choice = FILTER_CHOICE_AND;
            pTemp->FilterTypes.And.count = 2;
            pTemp2 = THAllocEx(pTHS, 2 * sizeof(FILTER));
            pTemp->FilterTypes.And.pFirstFilter = pTemp2;
            // Make the "lastname" portion.
            pTemp2->choice = FILTER_CHOICE_ITEM;
            
            pVal->valLen = cbLast;
            pVal->pVal = (PUCHAR)pLast;
            if(!dbMakeANRItem(pDB,
                              &pTemp2->FilterTypes.Item,
                              fExact,
                              ATT_GIVEN_NAME,
                              pVal)) {
                
                // Set estimated hint to zero so as to calculate 
                pTemp2->FilterTypes.Item.expectedSize = 0;

                // Succeeded in translating surname, continue.
                pTemp2->pNextFilter = &pTemp2[1];
                pTemp2++;
                // Finally, make the "lastname" portion.
                pTemp2->choice = FILTER_CHOICE_ITEM;
                
                pVal->valLen = cbFirst;
                pVal->pVal = (PUCHAR)pFirst;
                if(!dbMakeANRItem(pDB,
                                  &pTemp2->FilterTypes.Item,
                                  fExact,
                                  ATT_SURNAME,
                                  pVal)) {
                    // Set estimated hint to zero so as to calculate 
                    pTemp2->FilterTypes.Item.expectedSize = 0;

                    pTemp2->pNextFilter = NULL;
                    // Succeeded in making the (lastname AND firstname) filter.
                    itemCount++;
                }
            }
        }
    }

    if(!itemCount) {
        // We ended up with nothing to ANR on.  Set filter to match nothing and
        // return.  
        pOutFil->choice = FILTER_CHOICE_ITEM;
        pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
        THFreeEx(pTHS, pOutFil->FilterTypes.Or.pFirstFilter);
    }
    else {
        pOutFil->FilterTypes.Or.count = itemCount;
        pOutFil->FilterTypes.Or.pFirstFilter[itemCount - 1].pNextFilter = NULL;
    }
    return;
}
     
DWORD dbConcatenateFilters (
    DBPOS *pDB,
    FILTER *pFirstFilter, 
    FILTER *pSecondFilter, 
    FILTER **pOutFil)
/*
    This function takes two filters (pFirstFilter, pSecondFilter)
    and creates a new filter (pOutFil) by concatenating these two filters.
    The original memory of the input filters remains unchanged and the
    whole filter is copied in new memory.
*/
{

    DWORD err;
    FILTER *pFil1 = NULL, 
           *pFil2 = NULL, 
           *pTemp;

    DPRINT (2, "dbConcatenateFilters \n");

    if (err = dbCloneFilter (pDB, pFirstFilter, &pFil1)) {
        return err;
    }
    
    if (err = dbCloneFilter (pDB, pSecondFilter, &pFil2)) {
        return err;
    }

    pTemp = pFil1;
    while (pTemp) {
        if (pTemp->pNextFilter == NULL) {
            pTemp->pNextFilter = pFil2;
            break;
        }
        pTemp = pTemp->pNextFilter;
    }

    if (pFil1) {
        *pOutFil = pFil1;
    }
    else {
        *pOutFil = pFil2;
    }

    return ERROR_SUCCESS;
}


BOOL dbCheckOptimizableAllItems(
        DBPOS *pDB,
        FILTER *pFil
        ) 
/*
    returns TRUE is ALL filters under pFil are ITEM_FILTERS 
    and they are optimizable.
*/
{
    FILTER *pTemp = pFil;


    while (pTemp) {
        if (pTemp->choice != FILTER_CHOICE_ITEM) {
            return FALSE;
        }

        if (!IsFilterOptimizable(pDB->pTHS, pTemp)) {
            return FALSE;
        }

        pTemp = pTemp->pNextFilter;
    }

    return TRUE;
}


BOOL dbCheckOptimizableOneItem(
    DBPOS *pDB,
    FILTER *pFil
    ) 
/*
    returns TRUE is at least ONE of filters under pFil is ITEM_FILTERS 
    and they is optimizable.
*/
{
    FILTER *pTemp = pFil;

    while (pTemp) {
        if (pTemp->choice == FILTER_CHOICE_ITEM) {
            if (IsFilterOptimizable(pDB->pTHS, pTemp)) {
                return TRUE;
            }
        }

        pTemp = pTemp->pNextFilter;
    }

    return FALSE;
}


DWORD
dbFlattenOrFilter (
        DBPOS *pDB,
        FILTER *pFil,
        FILTER **ppOutFil
        )
{
    THSTATE  *pTHS=pDB->pTHS;
    USHORT   count=0, undefined=0;
    PFILTER  pOutFil;
    PFILTER  pTemp;
    PFILTER  *ppTemp2;
    DWORD    err;
    
    Assert(VALID_DBPOS(pDB));

    // Presume failure.
    *ppOutFil = NULL;
        
    pOutFil = THAllocEx(pTHS, sizeof(FILTER));
    
    pOutFil->choice = pFil->choice;
    
    // First, recursively flatten the elements of the OR

    // pTemp walks along the elements of the filter passed in.
    pTemp = pFil->FilterTypes.Or.pFirstFilter;

    // ppTemp2 walks along the OutFil we are creating.  It is doubly indirect
    // because we are creating the out filter as we go.
    ppTemp2 = &pOutFil->FilterTypes.Or.pFirstFilter;
    
    while(pTemp) {
        if ((err = dbFlattenFilter(pDB, pTemp, ppTemp2)) != ERROR_SUCCESS) {
            return err;
        }
        
        if((*ppTemp2)->choice == FILTER_CHOICE_OR) {
            // This element of the OR is itself an OR.  We can merge this with
            // the current OR filter.
            FILTER *pTemp2; // Very local use, so declare var in here.
            
            pTemp2 = (*ppTemp2)->FilterTypes.Or.pFirstFilter;

            // Free this node of the top level OR.
            THFreeEx(pTHS, *ppTemp2);

            // Link in the lower level OR.
            *ppTemp2 = pTemp2;

            // Now, walk through the lower level OR to get ppTemp2 pointing to
            // the correct spot and to set the count correctly.
            count++;
            while(pTemp2->pNextFilter) {
                count++;
                pTemp2 = pTemp2->pNextFilter;
            }
            ppTemp2 = &pTemp2->pNextFilter;
        }
        else {
            switch (IsConstFilterType(*ppTemp2)) {
            // Check for a true or false filter, which can be optimized
            case FI_CHOICE_FALSE:
                // A false element can simply be ignored.  Free the filter we got
                // back from the recursive call.  Note we don't increment the count.
                THFreeEx(pTHS, *ppTemp2);
                *ppTemp2 = NULL;
                break;

            case FI_CHOICE_TRUE:
                // A true element can be returned in place of the OR

                // First, free the linked list of filter elements already hanging
                // off the OR filter (if there is such a list).
                dbFreeFilter(pDB, pOutFil->FilterTypes.Or.pFirstFilter);

                // Now, turn the OR filter into a TRUE item filter.
                pOutFil->choice = FILTER_CHOICE_ITEM;
                pOutFil->FilterTypes.Item.choice = FI_CHOICE_TRUE;

                *ppOutFil = pOutFil;
                // OK, return
                return ERROR_SUCCESS;
                break;

            case FI_CHOICE_UNDEFINED:
                // an undefined element, cannot be ignored, but we are interested 
                // in knowing how many undefines we have so as to take appropriate action
                undefined++;
                // fall through
            default:
                // Normal case.  Inc the count, advance the pointer in the output
                // filter we are constructing.
                ppTemp2 = &(*ppTemp2)->pNextFilter;
                count++;
                break;
            }
        }
        pTemp = pTemp->pNextFilter;
    }
    
    if(count == 0) {
        // We must have trimmed away a bunch of FALSEs. Return a FALSE.
        pOutFil->choice = FILTER_CHOICE_ITEM;
        pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
        *ppOutFil = pOutFil;
        return ERROR_SUCCESS;
    }

    if(count == 1) {
        // Only one object.  Cut the OR out completely
        *ppOutFil = pOutFil->FilterTypes.Or.pFirstFilter;
        THFreeEx(pTHS, pOutFil);
        return ERROR_SUCCESS;
    }

    if (undefined == count) {
        // all the filter is undefined. remove the OR
        pOutFil->choice = FILTER_CHOICE_ITEM;
        pOutFil->FilterTypes.Item.choice = FI_CHOICE_UNDEFINED;
        *ppOutFil = pOutFil;
        return ERROR_SUCCESS;
    }
    
    // Returning a normal OR filter
    pOutFil->FilterTypes.Or.count = count;
    *ppOutFil = pOutFil;
    
    return ERROR_SUCCESS;
}

DWORD
dbFlattenAndFilter (
        DBPOS *pDB,
        FILTER *pFil,
        FILTER **ppOutFil
        )
{
    THSTATE  *pTHS=pDB->pTHS;
    USHORT   count=0;
    PFILTER  pOutFil;
    PFILTER  pTemp;
    PFILTER  *ppTemp2;
    DWORD    err;

    Assert(VALID_DBPOS(pDB));

    // Presume failure.
    *ppOutFil = NULL;
        
    pOutFil = THAllocEx(pTHS, sizeof(FILTER));
    
    pOutFil->choice = pFil->choice;
    
    // First, recursively flatten the elements of the AND

    // pTemp walks along the elements of the filter passed in.
    pTemp = pFil->FilterTypes.And.pFirstFilter;

    // ppTemp2 walks along the OutFil we are creating.  It is doubly indirect
    // because we are creating the out filter as we go.
    ppTemp2 = &pOutFil->FilterTypes.And.pFirstFilter;
    
    while(pTemp) {

        if ((err = dbFlattenFilter(pDB, pTemp, ppTemp2)) != ERROR_SUCCESS) {
            return err;
        }
        
        if((*ppTemp2)->choice == FILTER_CHOICE_AND) {
            // This element of the AND is itself an AND.  We can merge this with
            // the current AND filter.
            FILTER *pTemp2; // Very local use, so declare var in here.
            
            pTemp2 = (*ppTemp2)->FilterTypes.And.pFirstFilter;

            // Free this node of the top level AND.
            THFreeEx(pTHS, *ppTemp2);

            // Link in the lower level AND.
            *ppTemp2 = pTemp2;

            // Now, walk through the lower level AND to get ppTemp2 pointing to
            // the correct spot and to set the count correctly.
            count++;
            while(pTemp2->pNextFilter) {
                count++;
                pTemp2 = pTemp2->pNextFilter;
            }
            ppTemp2 = &pTemp2->pNextFilter;
        }
        else {
            switch (IsConstFilterType(*ppTemp2)) {
            // Check for a true or false filter, which can be optimized
            case FI_CHOICE_TRUE:
                // A true element can simply be ignored.  Free the filter we got
                // back from the recursive call.  Note we don't increment the count.
                THFreeEx(pTHS, *ppTemp2);
                *ppTemp2 = NULL;
                break;

            case FI_CHOICE_FALSE:
                // A false element can be returned in place of the AND

                // First, free the linked list of filter elements already hanging
                // off the AND filter (if there is such a list).
                dbFreeFilter(pDB, pOutFil->FilterTypes.And.pFirstFilter);

                // Now, turn the AND filter into a FALSE item filter.
                pOutFil->choice = FILTER_CHOICE_ITEM;
                pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;

                *ppOutFil = pOutFil;
                // OK, return
                return ERROR_SUCCESS;
                break;

            case FI_CHOICE_UNDEFINED:
            default:
                // Normal case.  Inc the count, advance the pointer in the output
                // filter we are constructing.
                ppTemp2 = &(*ppTemp2)->pNextFilter;
                count++;
                break;
            }
        }
        pTemp = pTemp->pNextFilter;
    }
    
    if(count == 0) {
        // We must have trimmed away a bunch of TRUEs. Return a TRUE.
        pOutFil->choice = FILTER_CHOICE_ITEM;
        pOutFil->FilterTypes.Item.choice = FI_CHOICE_TRUE;
        *ppOutFil = pOutFil;
        return ERROR_SUCCESS;
    }
    
    if(count == 1) {
        // Only one object.  Cut the AND out completely
        *ppOutFil = pOutFil->FilterTypes.And.pFirstFilter;
        THFreeEx(pTHS, pOutFil);
        return ERROR_SUCCESS;
    }

    // Returning a normal AND filter
    pOutFil->FilterTypes.And.count = count;
    *ppOutFil = pOutFil;

    
    // We check to see if we have an AND - OR case.
    // If so, we convert the AND - OR to an OR with multiple ANDs
    // 
    //
    //          AND                                OR
    //         /  \                               /  \
    //        /    \         ======>             /    \
    //       A     OR                         AND      AND
    //             /\                        / \       / \
    //            /  \                      /   \     /   \
    //           B    C                    A     B   A     C
    //
    //
    //  The above transformation is done only if:
    //  a) A is optimizable, or 
    //  b) B AND C are optimizable.
    //
    if (gfUseANDORFilterOptimizations) {
        FILTER **ppTemp;             // last memory location of pTemp
        FILTER *pTempFirstFilter;    // first Filter under AND
        FILTER *pTempOr;             // the first OR filter under AND
        FILTER *pTempNextFilter;     // the next filter from found OR
        FILTER *pTempOr1, *pTempOr2; // break OR apart so as to clone
        FILTER *pTempNewAnd;         // the newly created AND filter
        FILTER *pTempCount;          // used to count filters
        USHORT  count2;

        BOOL    bANDpartOptimizable = FALSE;
    
        // pTemp walks along the elements of the filter passed out.
        pTempFirstFilter = pTemp = pOutFil->FilterTypes.And.pFirstFilter;
        
        // ppTemp keeps the last memory pos of pTemp
        ppTemp = &pOutFil->FilterTypes.And.pFirstFilter;

        bANDpartOptimizable = dbCheckOptimizableOneItem(pDB, pTempFirstFilter);

        while (pTemp) {

            if (pTemp->choice == FILTER_CHOICE_OR) {

                DPRINT1 (1, "Found AND-OR case. Breaking filter apart: 0x%x\n", pOutFil);
                pTempOr = pTemp;
                
                // check to see if all parts of the OR filter are optimizable, 
                // or at least one of the rest of the AND parts of the AND filter 
                // since we don't want to end up with a worst filter

                if (!bANDpartOptimizable ||
                    !dbCheckOptimizableAllItems (pDB, pTempOr->FilterTypes.Or.pFirstFilter) ) {

                    DPRINT1 (1, "found AND-OR case, but one part is not optimizable (AND=%d). skipping.\n", bANDpartOptimizable);

                    break;
                }
                
                // make previous filter point to next filter
                pTempNextFilter = pTempOr->pNextFilter;
                *ppTemp = pTempNextFilter;

                // make Or filter standalone
                pTempOr->pNextFilter = NULL;

                // get the start of the AND filter, since it might have been rearranged
                pTempFirstFilter = pOutFil->FilterTypes.And.pFirstFilter;

                // now we have two filters that we want to rearrange
                // the OR filter: pTempOr
                // the rest of the filter: pTempFirstFilter

                // we convert the starting AND filter to an OR
                pOutFil->choice = FILTER_CHOICE_OR;
                pOutFil->FilterTypes.And.pFirstFilter = NULL;
                pOutFil->FilterTypes.Or.pFirstFilter = NULL;

                // for each filter in the OR, we concatenate one of the 
                // items in OR with all the items in pTempFirstFilter under 
                // a new AND filter and we add this AND filter 
                // under the OR filter
                //
                pTempOr1 = pTempOr->FilterTypes.Or.pFirstFilter;
                for (count =0; count < pTempOr->FilterTypes.Or.count; count++) {
                    pTempNewAnd = THAllocEx(pTHS, sizeof(FILTER));
                    pTempNewAnd->choice = FILTER_CHOICE_AND;

                    // break link list
                    pTempOr2 = pTempOr1->pNextFilter;
                    pTempOr1->pNextFilter = NULL;

                    if (err = dbConcatenateFilters (
                                     pDB,
                                     pTempFirstFilter, 
                                     pTempOr1, 
                                     &pTempNewAnd->FilterTypes.And.pFirstFilter)) {
                        return err;
                    }

                    // add AND filter to OR
                    pTempNewAnd->pNextFilter = pOutFil->FilterTypes.Or.pFirstFilter;
                    pOutFil->FilterTypes.Or.pFirstFilter = pTempNewAnd;

                    // count filters under newly created AND
                    count2 = 0;
                    pTempCount = pTempNewAnd->FilterTypes.And.pFirstFilter;
                    while (pTempCount) {
                        count2++;
                        pTempCount = pTempCount->pNextFilter;
                    }
                    pTempNewAnd->FilterTypes.And.count = count2;

                    DPRINT1 (1, "AND sub-part: 0x%x\n", pTempNewAnd);

                    // restore link list
                    pTempOr1->pNextFilter = pTempOr2;
                    pTempOr1 = pTempOr2;
                }
                pOutFil->FilterTypes.Or.count = count;

                DPRINT1 (1, "Final part: 0x%x\n", pOutFil);

                dbFreeFilter (pDB, pTempOr->pNextFilter);
                dbFreeFilter (pDB, pTempFirstFilter);

                // we can't do the same optimization again. so we exit.
                // we let the caller detect that the filter type changed, 
                // so as to call again
                break;
            }

            ppTemp = &pTemp->pNextFilter;
            pTemp = pTemp->pNextFilter;
        }
    }

    return ERROR_SUCCESS;
}

DWORD
dbFlattenItemFilter (
        DBPOS *pDB,
        FILTER *pFil,
        FILTER **ppOutFil
        )
{
    THSTATE       *pTHS=pDB->pTHS;
    ATTCACHE      *pAC;
    USHORT        count;
    ANYSTRINGLIST *pAS, *pNewAS;
    PFILTER       pOutFil;
    SUBSTRING     *pIn;
    SUBSTRING     *pOut;

    ULONG         objCls;
    CLASSCACHE    *pCC;
    ATTRVAL       attrVal;
    
    Assert(VALID_DBPOS(pDB));

    // Assume failure.
    *ppOutFil = NULL;
    
    // These are already flat.  copy to THAlloced Memory
    pOutFil = THAllocEx(pTHS, sizeof(FILTER));
    pOutFil->choice = pFil->choice;
    pOutFil->FilterTypes.Item.choice = pFil->FilterTypes.Item.choice;
    
    switch(pFil->FilterTypes.Item.choice) {
    case FI_CHOICE_SUBSTRING:
        // Readability hack.
        pIn = pFil->FilterTypes.Item.FilTypes.pSubstring;
        
        if(pIn->type == ATT_ANR) {
            *ppOutFil = pOutFil;
            dbMakeANRFilter(pDB, pFil, ppOutFil);
            return ERROR_SUCCESS;
        }

        if(pIn->type == ATT_CREATE_TIME_STAMP) {
            pIn->type = ATT_WHEN_CREATED;
        }
        else if (pIn->type == ATT_MODIFY_TIME_STAMP) {
            pIn->type = ATT_WHEN_CHANGED;
        }
        
        if (!(pAC = SCGetAttById(pTHS, pIn->type))) {
            DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, pIn->type);
        }

        // we don't support constructed attributes in filters.
        if (pAC->bIsConstructed) {
            return ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS;
        }

        // Make sure this is a valid operation on this syntax.
        if(!FLegalOperator(pAC->syntax, pFil->FilterTypes.Item.choice)) {
            // Nope, not legal.  Make a FALSE filter.
            pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
            *ppOutFil = pOutFil;
            return ERROR_SUCCESS;
        }
        
        pOut = THAllocEx(pTHS, sizeof(SUBSTRING));
        pOutFil->FilterTypes.Item.FilTypes.pSubstring = pOut;
        
        pOut->type = pIn->type;
        pOut->initialProvided = pIn->initialProvided;
        pOut->finalProvided = pIn->finalProvided;
        
        // convert initial and final substrings
        if ((pIn->initialProvided &&
             MakeInternalValue(pDB, pAC->syntax,
                               &pIn->InitialVal,
                               &pOut->InitialVal))  ||
            (pIn->finalProvided &&
             MakeInternalValue(pDB, pAC->syntax,
                               &pIn->FinalVal,
                               &pOut->FinalVal))) {
            // Failed to translate to internal.  Turn this into a FALSE, since
            // that means that we will never be able to find something with the
            // specified values.
            THFreeEx(pTHS, pOut);
            pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
            *ppOutFil = pOutFil;
            return ERROR_SUCCESS;
        }
        
        if(count = pIn->AnyVal.count) {
            // There are medial values.
            pOut->AnyVal.count = count;
            
            // Do the first value, since it's special.
            if (MakeInternalValue(pDB, pAC->syntax,
                                  &pIn->AnyVal.FirstAnyVal.AnyVal,
                                  &pOut->AnyVal.FirstAnyVal.AnyVal)) {
                // Failed to translate to internal.  Turn this into a FALSE
                THFreeEx(pTHS, pOut);
                pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
                *ppOutFil = pOutFil;
                return ERROR_SUCCESS;
            }
            // Dealt with the first one.
            count--;
            pOut->AnyVal.FirstAnyVal.pNextAnyVal = NULL;

            // Any more?
            if(count) {
                // Allocate some medial value holders.  Note that we only do
                // this if there are more than one medial values, since a
                // SUBSTRING has room in it for the first medial value.
                pOut->AnyVal.FirstAnyVal.pNextAnyVal =
                    THAllocEx(pTHS, count * sizeof(ANYSTRINGLIST));
                // Note we depend on zero filled memory allocatedy by THAlloc.
                
                pAS = pIn->AnyVal.FirstAnyVal.pNextAnyVal;
                pNewAS = pOut->AnyVal.FirstAnyVal.pNextAnyVal;
                for(;count;count--) {
                    
                    if (MakeInternalValue(pDB, pAC->syntax,
                                          &pAS->AnyVal,
                                          &pNewAS->AnyVal)) {
                        // Free up any values.
                        for(pAS =  &pOut->AnyVal.FirstAnyVal;
                            pAS;
                            pAS = pAS->pNextAnyVal) {
                            THFreeEx(pTHS, pAS->AnyVal.pVal);
                        }
                        // Now, free the ANYSTRINGs we allocated
                        THFreeEx(pTHS, pOut->AnyVal.FirstAnyVal.pNextAnyVal);
                        
                        // Now, free the substring filter structure
                        THFreeEx(pTHS, pOut);
                        
                        // Finally, turn the filter into a FALSE;
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;

                        *ppOutFil = pOutFil;
                        return ERROR_SUCCESS;
                    }
                    
                    pAS = pAS->pNextAnyVal;
                    if(count > 1) {
                        pNewAS->pNextAnyVal = &pNewAS[1];
                        pNewAS = pNewAS->pNextAnyVal;
                    }
                    else {
                        // NULL terminate the linked list
                        pNewAS->pNextAnyVal = NULL;
                    }
                }
            } 
        }
        else {
            pOut->AnyVal.count = 0;
            pOut->AnyVal.FirstAnyVal.pNextAnyVal = NULL;
        }
        
        break;
        
    case FI_CHOICE_PRESENT:

        if(pFil->FilterTypes.Item.FilTypes.present == ATT_CREATE_TIME_STAMP) {
            pFil->FilterTypes.Item.FilTypes.present = ATT_WHEN_CREATED;
        }
        else if (pFil->FilterTypes.Item.FilTypes.present == ATT_MODIFY_TIME_STAMP) {
            pFil->FilterTypes.Item.FilTypes.present = ATT_WHEN_CHANGED;
        }
        
        if(dbFIsAlwaysPresent(pFil->FilterTypes.Item.FilTypes.present)) {
            // We believe that this attribute is always present.  So, turn this
            // into a TRUE filter
            pOutFil->FilterTypes.Item.choice = FI_CHOICE_TRUE;
        }
        else {
            if(pFil->FilterTypes.Item.FilTypes.present == ATT_ANR) {
                // Present on ANR?  Huh?  That's always false.
                pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
            }
            else {
                pOutFil->FilterTypes.Item.FilTypes.present =
                    pFil->FilterTypes.Item.FilTypes.present;
            }
        }

        // the only constructed attr we we accept presence on is ANR
        if (pFil->FilterTypes.Item.FilTypes.present != ATT_ANR) {
            if (!(pAC = SCGetAttById(pTHS, pFil->FilterTypes.Item.FilTypes.present))) {
                DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, pFil->FilterTypes.Item.FilTypes.present);
            }

            // we don't support constructed attributes in filters.
            if (pAC->bIsConstructed) {
                return ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS;
            }
        }
        break;
        
    case FI_CHOICE_TRUE:
    case FI_CHOICE_FALSE:
    case FI_CHOICE_UNDEFINED:
        // These don't require conversion
        break;
        
    default:
        // all others are AVAs
        
        if(pFil->FilterTypes.Item.FilTypes.ava.type == ATT_ANR) {
            *ppOutFil = pOutFil;
            dbMakeANRFilter(pDB, pFil, ppOutFil);
            return ERROR_SUCCESS;
        }
        
        if(pFil->FilterTypes.Item.FilTypes.ava.type == ATT_CREATE_TIME_STAMP) {
            pFil->FilterTypes.Item.FilTypes.ava.type = ATT_WHEN_CREATED;
        }
        else if (pFil->FilterTypes.Item.FilTypes.ava.type == ATT_MODIFY_TIME_STAMP) {
            pFil->FilterTypes.Item.FilTypes.ava.type = ATT_WHEN_CHANGED;
        }

        // Once upon  time, we turned all filters of (objectClass=FOO) into
        // (objectCategory = BAR).  For a variety of reasons (i.e. incorrect
        // search results, weird results when you have different READ privileges
        // on objectClass and objectCategory, cases where exact objectClass is
        // necessary, so is done on the client, and deleted objects where
        // objectCategory is removed)  we are no longer doing this.  The code
        // that did this was right here.

        if (!(pAC = SCGetAttById(pTHS, 
                                 pFil->FilterTypes.Item.FilTypes.ava.type))) {
            DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA,
                      pFil->FilterTypes.Item.FilTypes.ava.type);
        }

        // we don't support constructed attributes in filters.
        if (pAC->bIsConstructed) {
            
#if 0 // do not allow filters containing EntryTTL

// Originally added for TAPI, this partial filter capability is no longer
// needed. The test group is concerned that the partial filter capability
// on this one constructed attribute, EntryTTL, will cause more problems
// than it solves for users. I have commented it out instead of removing
// the code because it is a useful starting point if this type of 
// functionality is needed again.

            // unless it is an EntryTTL, so we convert it
            if (pAC->id == ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->EntryTTLId) {

                ATTRVAL newValue;
                LONG ttl=0;
                DSTIME newTime=0, *pNewTime;

                newValue.pVal=NULL;
                newValue.valLen=0;

                // Make sure this is a valid operation on this syntax.
                if(!FLegalOperator(pAC->syntax, pFil->FilterTypes.Item.choice)) {
                    // Nope, not legal.  Turn this into a FALSE.
                    pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
                    *ppOutFil = pOutFil;
                    return ERROR_SUCCESS;
                }

                pOutFil->FilterTypes.Item.FilTypes.ava.type = ATT_MS_DS_ENTRY_TIME_TO_DIE;

                if(MakeInternalValue(
                         pDB,
                         pAC->syntax,
                         &pFil->FilterTypes.Item.FilTypes.ava.Value,
                         &newValue)) {

                    // Failed to convert the right hand side.  Turn this into an
                    // appropriate filter.
                    switch(pFil->FilterTypes.Item.choice) {
                    case FI_CHOICE_EQUALITY:
                        // They wanted equal, but we sure don't have this in the
                        // DS. Turn it into a false filter 
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
                        break;
                    case FI_CHOICE_NOT_EQUAL:
                        // They wanted not equal, and we sure don't have this in the
                        // DS. Turn it into a TRUE filter 
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_PRESENT;
                        pOutFil->FilterTypes.Item.FilTypes.present = ATT_MS_DS_ENTRY_TIME_TO_DIE;
                        break;
                    default:
                        // Don't know what they want.  Well, we have to do
                        // something, so set it to FALSE.
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
                        break;
                    }

                    *ppOutFil = pOutFil;
                    return ERROR_SUCCESS;
                }

                ttl = *(LONG *)(newValue.pVal);

                // entryTTL is a constructed attribute. It is constructed
                // by subtracting NOW from msDS-Entry-Time-To-Die and mapping
                // the answer to 0 if it is <0. Adjust Item.choice to
                // compensate for this construction.
                if (ttl==0) {
                    switch(pFil->FilterTypes.Item.choice) {
                    case FI_CHOICE_NOT_EQUAL:
                        // search for objects that haven't expired (>= 1)
                        ttl = 1;
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_GREATER_OR_EQ;
                        break;
                    case FI_CHOICE_GREATER_OR_EQ:
                        // Find all objects
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_PRESENT;
                        pOutFil->FilterTypes.Item.FilTypes.present = ATT_MS_DS_ENTRY_TIME_TO_DIE;
                        break;
                    case FI_CHOICE_LESS_OR_EQ:
                        // This is okay as is
                        break;
                    case FI_CHOICE_EQUALITY:
                        // search for expired objects (<= 0)
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_LESS_OR_EQ;
                        break;
                    default:
                        // Don't know what they want.  Well, we have to do
                        // something, so set it to FALSE.
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
                        *ppOutFil = pOutFil;
                        return ERROR_SUCCESS;
                    }
                } else if (ttl<0) {
                    // entryttl cannot be negative (see rangeLower)
                    switch(pFil->FilterTypes.Item.choice) {
                    case FI_CHOICE_NOT_EQUAL:
                    case FI_CHOICE_GREATER_OR_EQ:
                        // Find all objects
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_PRESENT;
                        pOutFil->FilterTypes.Item.FilTypes.present = ATT_MS_DS_ENTRY_TIME_TO_DIE;
                        break;
                    default:
                        // Find no objects
                        pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
                        *ppOutFil = pOutFil;
                        return ERROR_SUCCESS;
                    }
                }

                newTime = DBTime() + ttl;
                THFreeEx (pTHS, newValue.pVal);

                pOutFil->FilterTypes.Item.FilTypes.ava.Value.pVal = 
                            THAllocEx (pTHS, sizeof (DSTIME));
                pOutFil->FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof (DSTIME);

                pNewTime = (DSTIME *)pOutFil->FilterTypes.Item.FilTypes.ava.Value.pVal;
                *pNewTime = newTime;

                *ppOutFil = pOutFil;
                return ERROR_SUCCESS;
            }
            else {
                return ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS;
            }
#else 0 // do not allow filters containing EntryTTL
            return ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS;
#endif 0 // do not allow filters containing EntryTTL
        }
        
        // Make sure this is a valid operation on this syntax.
        if(!FLegalOperator(pAC->syntax, pFil->FilterTypes.Item.choice)) {
            // Nope, not legal.  Turn this into a FALSE.
            pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
            *ppOutFil = pOutFil;
            return ERROR_SUCCESS;
        }
        
        pOutFil->FilterTypes.Item.FilTypes.ava.type =
            pFil->FilterTypes.Item.FilTypes.ava.type;
        if(MakeInternalValue(
                pDB,
                pAC->syntax,
                &pFil->FilterTypes.Item.FilTypes.ava.Value,
                &(pOutFil->FilterTypes.Item.FilTypes.ava.Value))) {
            
            // Failed to convert the right hand side.  Turn this into an
            // appropriate filter.
            switch(pFil->FilterTypes.Item.choice) {
            case FI_CHOICE_EQUALITY:
                // They wanted equal, but we sure don't have this in the
                // DS. Turn it into a false filter 
                pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
                break;
            case FI_CHOICE_NOT_EQUAL:
                // They wanted not equal, and we sure don't have this in the
                // DS. Turn it into a TRUE filter 
                pOutFil->FilterTypes.Item.choice = FI_CHOICE_TRUE;
                break;
            default:
                // Don't know what they want.  Well, we have to do
                // something, so set it to FALSE.
                pOutFil->FilterTypes.Item.choice = FI_CHOICE_FALSE;
                break;
            }
            break;
        }  
    }
    
    *ppOutFil = pOutFil;

    return ERROR_SUCCESS;
}
 
DWORD
dbFlattenNotFilter (
        DBPOS *pDB,
        FILTER *pFil,
        FILTER **ppOutFil
        )
{
    THSTATE *pTHS=pDB->pTHS;
    FILTER *pFilTemp = NULL;
    DWORD err;
    
    Assert(VALID_DBPOS(pDB));

    *ppOutFil = THAllocEx(pTHS, sizeof(FILTER));
    
    (*ppOutFil)->choice = pFil->choice;
    
    // First, recursively flatten the element of the NOT
    if ((err = dbFlattenFilter(pDB,
                    pFil->FilterTypes.pNot,
                    &(*ppOutFil)->FilterTypes.pNot)) != ERROR_SUCCESS) {

        return err;
    }
    
    // Now, if it ended up being NOT of a TRUE or FALSE, flatten again
    // Note that we can't flatten things like !(name>"foo") to be (name<="foo").
    // That really flattens to (|(name<="foo")(name ! Exists.)),
    // i.e. !(name>"foo") also needs to get things that have no value for name
    // at all. 

    pFilTemp = (*ppOutFil)->FilterTypes.pNot;
    switch(IsConstFilterType(pFilTemp)) {
    case FI_CHOICE_TRUE:
        // Yep, we should flatten
        THFreeEx(pTHS, *ppOutFil);
        *ppOutFil = pFilTemp;
        pFilTemp->FilterTypes.Item.choice = FI_CHOICE_FALSE;
        break;
    case FI_CHOICE_FALSE:
        THFreeEx(pTHS, *ppOutFil);
        *ppOutFil = pFilTemp;
        pFilTemp->FilterTypes.Item.choice = FI_CHOICE_TRUE;
        break;
    case FI_CHOICE_UNDEFINED:
        THFreeEx(pTHS, *ppOutFil);
        *ppOutFil = pFilTemp;
        pFilTemp->FilterTypes.Item.choice = FI_CHOICE_UNDEFINED;
        break;
    default:
        // No, nothing more to do.
        break;
    }
    return ERROR_SUCCESS;
}


DWORD
dbFlattenFilter (
        DBPOS *pDB,
        FILTER *pFil,
        FILTER **ppOutFil)
{
    DWORD err;
    Assert(VALID_DBPOS(pDB));

    if(!pFil) {
        // This is as flat as possible
        return ERROR_SUCCESS;
    }

    switch(pFil->choice) {
    case FILTER_CHOICE_OR:
        return dbFlattenOrFilter(pDB, pFil, ppOutFil);
        break;

    case FILTER_CHOICE_AND:
        err = dbFlattenAndFilter(pDB, pFil, ppOutFil);
        // PERFHINT: IF this Filter was converted to an OR
        // it might be a good idea flatten the filter again
        // since it might help lowering the number of nesting
        return err;
        break;
        
    case FILTER_CHOICE_NOT:
        return dbFlattenNotFilter(pDB, pFil, ppOutFil);
        break;

    case FILTER_CHOICE_ITEM:
        return dbFlattenItemFilter(pDB, pFil, ppOutFil);
        break;
    default:
        // what is this?  return an error.
        *ppOutFil = pFil;
        return ERROR_INVALID_DATA;
        break;
    }

    return ERROR_SUCCESS;
}


DWORD
DBMakeFilterInternal (
        DBPOS FAR *pDB,
        FILTER *pFil,
        PFILTER *pOutFil
        )
/*++
Routine Description:

    Calls routines to create an internal version of the passed in filter.
    Passes the internal version back to the caller.

Arguments:    

    pDB - DBPOS to use.

    pFil - Filter to internalize

    pOutFil - Place to holde Filter to return.

Return Value:
    
    ERROR_SUCCESS - if the filter is valid
    errorCode - otherwise
              - ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS: Filter uses constructed attribute
    
    We always turn the filter into the best internal version we can, or
    we throw an exception during memory allocation.

--*/
{
    DPRINT(2, "DBMakeFilterInternal entered\n");

    Assert(VALID_DBPOS(pDB));

    if(pFil == NULL){
        DPRINT(2,"No filter..return\n");
        return ERROR_SUCCESS;
    }

    return dbFlattenFilter(pDB, pFil, pOutFil);
}/* DBMakeFilterInternal*/



DWORD dbCloneItemFilter(
    DBPOS *pDB,
    FILTER *pFil, 
    FILTER **ppOutFil)
{
    THSTATE       *pTHS=pDB->pTHS;
    ATTCACHE      *pAC;
    USHORT        count;
    ANYSTRINGLIST *pAS, *pNewAS;
    PFILTER       pOutFil;
    SUBSTRING     *pIn;
    SUBSTRING     *pOut;

    ULONG         objCls;
    CLASSCACHE    *pCC;
    ATTRVAL       attrVal, *pAttrValIn;
    AVA           *pAVA, *pAVAdst;
    
    DPRINT (2, "dbCloneItemFilter \n");

    Assert(VALID_DBPOS(pDB));

    // Assume failure.
    *ppOutFil = NULL;
    
    // These are already flat.  copy to THAlloced Memory
    pOutFil = THAllocEx(pTHS, sizeof(FILTER));
    pOutFil->choice = pFil->choice;
    pOutFil->FilterTypes.Item.choice = pFil->FilterTypes.Item.choice;
    
    switch(pFil->FilterTypes.Item.choice) {
    case FI_CHOICE_SUBSTRING:
        // Readability hack.
        pIn = pFil->FilterTypes.Item.FilTypes.pSubstring;
        
        pOut = THAllocEx(pTHS, sizeof(SUBSTRING));
        pOutFil->FilterTypes.Item.FilTypes.pSubstring = pOut;
        
        pOut->type = pIn->type;
        pOut->initialProvided = pIn->initialProvided;
        pOut->finalProvided = pIn->finalProvided;
        
        // convert initial and final substrings
        if (pIn->initialProvided && pIn->InitialVal.valLen) {
            pOut->InitialVal.valLen = pIn->InitialVal.valLen;
            pOut->InitialVal.pVal = THAllocEx(pTHS, pOut->InitialVal.valLen);
            memcpy(pOut->InitialVal.pVal, pIn->InitialVal.pVal, pOut->InitialVal.valLen);
        }
        if (pIn->finalProvided && pIn->FinalVal.valLen) {
            pOut->FinalVal.valLen = pIn->FinalVal.valLen;
            pOut->FinalVal.pVal = THAllocEx(pTHS, pOut->FinalVal.valLen);
            memcpy(pOut->FinalVal.pVal, pIn->FinalVal.pVal, pOut->FinalVal.valLen);
        }
        
        if(count = pIn->AnyVal.count) {
            // There are medial values.
            pOut->AnyVal.count = count;
            
            // Do the first value, since it's special.
            pAttrValIn = &pIn->AnyVal.FirstAnyVal.AnyVal;
            if (pAttrValIn->valLen) {
                ATTRVAL *pAttrValOut = &pOut->AnyVal.FirstAnyVal.AnyVal;
                pAttrValOut->valLen = pAttrValIn->valLen;
                pAttrValOut->pVal = THAllocEx(pTHS, pAttrValOut->valLen);
                memcpy(pAttrValOut->pVal, pAttrValIn->pVal, pAttrValOut->valLen);
            }
            // Dealt with the first one.
            count--;
            pOut->AnyVal.FirstAnyVal.pNextAnyVal = NULL;

            // Any more?
            if(count) {
                // Allocate some medial value holders.  Note that we only do
                // this if there are more than one medial values, since a
                // SUBSTRING has room in it for the first medial value.
                pOut->AnyVal.FirstAnyVal.pNextAnyVal =
                    THAllocEx(pTHS, count * sizeof(ANYSTRINGLIST));
                // Note we depend on zero filled memory allocatedy by THAlloc.
                
                pAS = pIn->AnyVal.FirstAnyVal.pNextAnyVal;
                pNewAS = pOut->AnyVal.FirstAnyVal.pNextAnyVal;
                for(;count;count--) {
                    
                    if (pAS->AnyVal.valLen) {
                        pNewAS->AnyVal.valLen = pAS->AnyVal.valLen;
                        pNewAS->AnyVal.pVal = THAllocEx(pTHS, pAS->AnyVal.valLen);
                        memcpy(pNewAS->AnyVal.pVal, pAS->AnyVal.pVal, pAS->AnyVal.valLen);
                    }
                    pAS = pAS->pNextAnyVal;
                    if(count > 1) {
                        pNewAS->pNextAnyVal = &pNewAS[1];
                        pNewAS = pNewAS->pNextAnyVal;
                    }
                    else {
                        // NULL terminate the linked list
                        pNewAS->pNextAnyVal = NULL;
                    }
                }
            } 
        }
        else {
            pOut->AnyVal.count = 0;
            pOut->AnyVal.FirstAnyVal.pNextAnyVal = NULL;
        }
        break;
        
    case FI_CHOICE_PRESENT:
        pOutFil->FilterTypes.Item.FilTypes.present =
                    pFil->FilterTypes.Item.FilTypes.present;
        break;
        
    case FI_CHOICE_TRUE:
    case FI_CHOICE_FALSE:
        // These don't require conversion
        break;
        
    default:
        // all others are AVAs
        pAVA = &pFil->FilterTypes.Item.FilTypes.ava;
        pAVAdst = &pOutFil->FilterTypes.Item.FilTypes.ava;
        
        pAVAdst->type = pAVA->type;

        if (pAVA->Value.valLen) {
            pAVAdst->Value.valLen = pAVA->Value.valLen;
            pAVAdst->Value.pVal = THAllocEx(pTHS, pAVAdst->Value.valLen);
            memcpy(pAVAdst->Value.pVal, pAVA->Value.pVal, pAVAdst->Value.valLen);
        }
    }
    *ppOutFil = pOutFil;

    return ERROR_SUCCESS;
}

DWORD dbCloneAndOrFilter (
    DBPOS *pDB,
    FILTER *pFil, 
    FILTER **ppOutFil)
{
    THSTATE *pTHS=pDB->pTHS;
    FILTER  *pOutFil;
    FILTER  *pTemp;
    FILTER  **ppTemp;
    DWORD    err;

    pOutFil = THAllocEx(pTHS, sizeof(FILTER));
    memcpy (pOutFil, pFil, sizeof (FILTER));

    switch(pFil->choice) {
    case FILTER_CHOICE_OR:
        DPRINT (2, "dbCloneORFilter \n");

        pTemp = pFil->FilterTypes.Or.pFirstFilter;
        ppTemp = &pOutFil->FilterTypes.Or.pFirstFilter;
        break;

    case FILTER_CHOICE_AND:
        DPRINT (2, "dbCloneAndFilter \n");

        pTemp = pFil->FilterTypes.And.pFirstFilter;
        ppTemp = &pOutFil->FilterTypes.And.pFirstFilter;
        break;

    default:
        Assert (!"dbCloneAndOrFilter: Not an AND or OR filter");
        return ERROR_INVALID_DATA;
    }
    
    while (pTemp) {
        if (err = dbCloneFilter (pDB, pTemp, ppTemp)) {
            return err;
        }

        pTemp = pTemp->pNextFilter;
        ppTemp = &(*ppTemp)->pNextFilter;
    }

    *ppOutFil = pOutFil;

    return ERROR_SUCCESS;
}

DWORD dbCloneNotFilter (
    DBPOS *pDB,
    FILTER *pFil, 
    FILTER **ppOutFil)
{
    THSTATE *pTHS=pDB->pTHS;
    FILTER  *pOutFil;
    FILTER  *pTemp;
    FILTER  **ppTemp;
    DWORD    err;

    pOutFil = THAllocEx(pTHS, sizeof(FILTER));
    memcpy (pOutFil, pFil, sizeof (FILTER));

    pTemp = pFil->FilterTypes.pNot;
    ppTemp = &pOutFil->FilterTypes.pNot;
    
    if (err = dbCloneFilter (pDB, pTemp, ppTemp)) {
        return err;
    }

    *ppOutFil = pOutFil;

    return ERROR_SUCCESS;
}


DWORD dbCloneFilter (
    DBPOS *pDB,
    FILTER *pFil, 
    FILTER **ppOutFil)
{
    DWORD err;
    *ppOutFil = NULL;

    if(!pFil) {
        // This is as flat as possible. can't clone
        return ERROR_SUCCESS;
    }
    
    DPRINT (2, "dbCloneFilter \n");

    switch(pFil->choice) {
    case FILTER_CHOICE_OR:
    case FILTER_CHOICE_AND:
        err = dbCloneAndOrFilter(pDB, pFil, ppOutFil);
        break;
    
    case FILTER_CHOICE_NOT:
        err = dbCloneNotFilter(pDB, pFil, ppOutFil);
        break;

    case FILTER_CHOICE_ITEM:
        err = dbCloneItemFilter(pDB, pFil, ppOutFil);
        break;
    default:
        // what is this?  return an error.
        *ppOutFil = pFil;
        err = ERROR_INVALID_DATA;
        break;
    }

    if (!err && pFil->pNextFilter) {
        err = dbCloneFilter (pDB, pFil->pNextFilter, & (*ppOutFil)->pNextFilter);
    }

    return err;
}



char *szFilterItemDescFormat[][2] = {
    { " (%s = <val>) ",    " (attr(0x%x) = <val>) " },      // FI_CHOICE_EQUALITY
    { " (%s = "       ,    " (attr(0x%x) = " },             // FI_CHOICE_SUBSTRING
    { " (%s > <val>) ",    " (attr(0x%x) > <val>) " },      // FI_CHOICE_GREATER
    { " (%s >= <val>) ",   " (attr(0x%x) >= <val>) " },     // FI_CHOICE_GREATER_OR_EQ
    { " (%s < <val>) ",    " (attr(0x%x) < <val>) " },      // FI_CHOICE_LESS
    { " (%s <= <val>) ",   " (attr(0x%x) <= <val>) " },     // FI_CHOICE_LESS_OR_EQ
    { " (%s != <val>) ",   " (attr(0x%x) != <val>) " },     // FI_CHOICE_NOT_EQUAL
    { " (%s = *) ",        " (attr(0x%x)=*) "} ,            // FI_CHOICE_PRESENT
    { " (TRUE) ",          "" },                            // FI_CHOICE_TRUE
    { " (FALSE) ",         "" },                            // FI_CHOICE_FALSE
    { " (%s & <bit_val>) ", " (attr(0x%x) & <bit_val>) " }, // FI_CHOICE_BIT_AND
    { " (%s | <bit_val>) ", " (attr(0x%x) | <bit_val>) " }  // FI_CHOICE_BIT_OR
};

BOOL StrCatBuffer (LPSTR buff, LPCSTR str, DWORD buffSize)
{
    LPSTR p = buff;

    buffSize--;

    while (buffSize && *p) {
        p++;
        buffSize--;
    }

    while (buffSize && *str) {
        *p++=*str++;
        buffSize--;
    }

    *p = '\0';

    return TRUE;
}

//
// Given a filter (pFilter) and a buffer (buff) of known size (buffSize),
// creates a printable form of the filter to be used for performance 
// logging
//
void DBCreateSearchPerfLogFilter (DBPOS *pDB, FILTER *pFilter, LPSTR buff, DWORD buffSize)
{
    THSTATE *pTHS = pDB->pTHS;
    BOOL bogus = FALSE;
    ATTCACHE *pAC = NULL;
    unsigned choice;
    char *pTmpStr;

    if (!pFilter) {
        return;
    }

    switch ( pFilter->choice )
    {
    case FILTER_CHOICE_ITEM:

        choice = pFilter->FilterTypes.Item.choice;
        pTmpStr = NULL;

        switch ( choice )
        {
        case FI_CHOICE_EQUALITY:
        case FI_CHOICE_GREATER:
        case FI_CHOICE_GREATER_OR_EQ:
        case FI_CHOICE_LESS:
        case FI_CHOICE_LESS_OR_EQ:
        case FI_CHOICE_NOT_EQUAL:
        case FI_CHOICE_BIT_AND:
        case FI_CHOICE_BIT_OR:

            pAC = SCGetAttById(pTHS, pFilter->FilterTypes.Item.FilTypes.ava.type);
            if (pAC && pAC->name) {
                pTmpStr = THAllocEx (pTHS, strlen (pAC->name) + 80);
                sprintf (pTmpStr, szFilterItemDescFormat[choice][0], pAC->name);
            }
            else {
                pTmpStr = THAllocEx (pTHS, 80);
                sprintf (pTmpStr, szFilterItemDescFormat[choice][1], 
                         pFilter->FilterTypes.Item.FilTypes.ava.type);
            }
            StrCatBuffer (buff, pTmpStr, buffSize);
            break;
        
        case FI_CHOICE_PRESENT:
            pAC = SCGetAttById(pTHS, pFilter->FilterTypes.Item.FilTypes.present);
            if (pAC && pAC->name) {
                pTmpStr = THAllocEx (pTHS, strlen (pAC->name) + 80);
                sprintf (pTmpStr, szFilterItemDescFormat[choice][0], pAC->name);
            }
            else {
                pTmpStr = THAllocEx (pTHS, 80);
                sprintf (pTmpStr, szFilterItemDescFormat[choice][1], 
                         pFilter->FilterTypes.Item.FilTypes.present);
            }
            StrCatBuffer (buff, pTmpStr, buffSize);
            break;

        case FI_CHOICE_SUBSTRING:
            
            pAC = SCGetAttById(pTHS, pFilter->FilterTypes.Item.FilTypes.pSubstring->type);
            if (pAC && pAC->name) {
                pTmpStr = THAllocEx (pTHS, strlen (pAC->name) + 80);
                sprintf (pTmpStr, szFilterItemDescFormat[choice][0], pAC->name);
            }
            else {
                pTmpStr = THAllocEx (pTHS, 90);
                sprintf (pTmpStr, szFilterItemDescFormat[choice][1], 
                         pFilter->FilterTypes.Item.FilTypes.pSubstring->type);
            }

            if (pFilter->FilterTypes.Item.FilTypes.pSubstring->initialProvided) {
                strcat (pTmpStr, " <startSubstr>*");
            }
            
            if (pFilter->FilterTypes.Item.FilTypes.pSubstring->AnyVal.count) {
                strcat (pTmpStr, " *<middleSubstr>*");
            }

            if (pFilter->FilterTypes.Item.FilTypes.pSubstring->finalProvided) {
                strcat (pTmpStr, " *<endSubstr>");
            }
            strcat (pTmpStr, ") ");

            StrCatBuffer (buff, pTmpStr, buffSize);
            break;

        case FI_CHOICE_TRUE:
        case FI_CHOICE_FALSE:
            StrCatBuffer (buff, szFilterItemDescFormat[choice][0], buffSize);
            break;

        default:
            StrCatBuffer (buff, " (<UNKNOWN>) ", buffSize);
            break;
        }
        
        if (pTmpStr) {
            THFreeEx (pTHS, pTmpStr);
        }

        break;

    case FILTER_CHOICE_AND:

        StrCatBuffer (buff, " ( & ", buffSize);

        DBCreateSearchPerfLogFilter (pDB, pFilter->FilterTypes.And.pFirstFilter, buff, buffSize);
        
        StrCatBuffer (buff, ") ", buffSize);

        break;

    case FILTER_CHOICE_OR:

        StrCatBuffer (buff, " ( | ", buffSize);

        DBCreateSearchPerfLogFilter (pDB, pFilter->FilterTypes.Or.pFirstFilter, buff, buffSize);
        
        StrCatBuffer (buff, ") ", buffSize);

        break;

    case FILTER_CHOICE_NOT:

        StrCatBuffer (buff, " ( ! ", buffSize);

        DBCreateSearchPerfLogFilter (pDB, pFilter->FilterTypes.pNot, buff, buffSize);
        
        StrCatBuffer (buff, ") ", buffSize);
        
        break;

    default:

        StrCatBuffer (buff, " <UNKNOWN> ", buffSize);
        bogus = TRUE;
        break;
    }

    if ( NULL != pFilter->pNextFilter && !bogus) {
        DBCreateSearchPerfLogFilter (pDB, pFilter->pNextFilter, buff, buffSize);
    }
}

//
// creates the logging info for the particular filter used / indexes
// and stores that info on the pTHS->searchLogging datastructure
//
void DBGenerateLogOfSearchOperation (DBPOS *pDB)
{
    KEY_INDEX *tmp_index;
    DWORD count, size, buffSize;
    LPSTR buff;
    char szIndexName [MAX_RDN_SIZE+32];
    
    buff = THAllocEx(pDB->pTHS, DBFILTER_DUMP_SIZE*2);
    buff[0] = '\0';
    DBCreateSearchPerfLogFilter (pDB, 
                                 pDB->Key.pFilter, 
                                 buff, 
                                 DBFILTER_DUMP_SIZE * 2);

    pDB->pTHS->searchLogging.pszFilter = buff;

    size = sizeof (szIndexName);
    count = 0;
    for (tmp_index = pDB->Key.pIndex; tmp_index; tmp_index = tmp_index->pNext) {
        count++;
        if (tmp_index->pAC && tmp_index->pAC->name) {
            size+=strlen (tmp_index->pAC->name);
        }
        else if (tmp_index->szIndexName) {
            size+=strlen (tmp_index->szIndexName);
        }
    }

    buffSize = size + count * 32;
    buff = THAllocEx(pDB->pTHS, buffSize);
    buff[0] = '\0';

    if (count) {
        for (tmp_index = pDB->Key.pIndex; tmp_index; tmp_index = tmp_index->pNext) {
            if (tmp_index->pAC && tmp_index->pAC->name) {

                sprintf (szIndexName, "idx_%s:%d:%c;", 
                     tmp_index->pAC->name, 
                     tmp_index->ulEstimatedRecsInRange,
                     tmp_index->tblIntersection ? 'I' :
                        tmp_index->bIsTupleIndex ? 'T' : 
                            tmp_index->bIsPDNTBased ? 'P' : 'N');

                StrCatBuffer (buff, szIndexName, buffSize);

            } else if (tmp_index->szIndexName) {

                sprintf (szIndexName, "%s:%d:%c;", 
                     tmp_index->szIndexName, 
                     tmp_index->ulEstimatedRecsInRange,
                     tmp_index->tblIntersection ? 'I' :
                        tmp_index->bIsTupleIndex ? 'T' : 
                            tmp_index->bIsPDNTBased ? 'P' : 'N');

                StrCatBuffer (buff, szIndexName, buffSize);
            }
        }
    }
    else {
        if (pDB->Key.indexType == TEMP_TABLE_INDEX_TYPE) {
            StrCatBuffer (buff, "TEMPORARY_SORT_INDEX", buffSize);
        }
        else if (pDB->Key.indexType == TEMP_TABLE_MEMORY_ARRAY_TYPE) {
            StrCatBuffer (buff, "INMEMORY_INDEX", buffSize);
        }
    }
    pDB->pTHS->searchLogging.pszIndexes = buff;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dbjetex.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbjetex.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <dsatools.h>                   // For pTHStls
#include <attids.h>

// Logging headers.
#include <dsexcept.h>

// Assorted DSA headers
#include <dsevent.h>
#include   "debug.h"         /* standard debugging header */
#define DEBSUB "DBJETEX:" /* define the subsystem for debugging        */

// DBLayer includes
#include "dbintrnl.h"


#include <fileno.h>
#define  FILENO FILENO_DBJETEX


JET_ERR
JetBeginSessionException(JET_INSTANCE instance, JET_SESID  *psesid,
    const char  *szUserName, const char  *szPassword, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    err = JetBeginSession(instance, psesid, szUserName, szPassword);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetDupSessionException(JET_SESID sesid, JET_SESID  *psesid, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    err = JetDupSession(sesid, psesid);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetEndSessionException(JET_SESID sesid, JET_GRBIT grbit, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    err = JetEndSession(sesid, grbit);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetGetTableColumnInfoException(JET_SESID sesid, JET_TABLEID tableid,
    const char  *szColumnName, void  *pvResult, unsigned long cbMax,
    unsigned long InfoLevel, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    err = JetGetTableColumnInfo(sesid, tableid, szColumnName, pvResult, cbMax, InfoLevel);

    switch (err)
    {
    case JET_errSuccess:
    case JET_errColumnNotFound:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetBeginTransactionException(JET_SESID sesid, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    err = JetBeginTransaction(sesid);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetCommitTransactionException(JET_SESID sesid, JET_GRBIT grbit, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    err = JetCommitTransaction(sesid, grbit);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetRollbackException(JET_SESID sesid, JET_GRBIT grbit, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    err = JetRollback(sesid, grbit);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetCloseDatabaseException(JET_SESID sesid, JET_DBID dbid,
    JET_GRBIT grbit, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    err = JetCloseDatabase(sesid, dbid, grbit);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetCloseTableException(JET_SESID sesid, JET_TABLEID tableid, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    err = JetCloseTable(sesid, tableid);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetOpenDatabaseException(JET_SESID sesid, const char  *szFilename,
    const char  *szConnect, JET_DBID  *pdbid, JET_GRBIT grbit, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    err = JetOpenDatabase(sesid, szFilename, szConnect, pdbid, grbit);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetOpenTableException(JET_SESID sesid, JET_DBID dbid,
              const char  *szTableName, const void  *pvParameters,
              unsigned long cbParameters, JET_GRBIT grbit,
              JET_TABLEID  *ptableid, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    err = JetOpenTable(sesid, dbid, szTableName, pvParameters,
               cbParameters, grbit, ptableid);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        *ptableid = 0;
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0,
                  usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetDeleteException(JET_SESID sesid, JET_TABLEID tableid, USHORT usFileNo, int nLine)
{
    JET_ERR err;

    err = JetDelete(sesid, tableid);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    case JET_errWriteConflict:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_EXTENSIVE);

    default:
        RaiseDsaException(DSA_DB_EXCEPTION, (ULONG) err, 0, usFileNo, nLine, DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetUpdateException(JET_SESID sesid, JET_TABLEID tableid,
    void  *pvBookmark, unsigned long cbBookmark,
    unsigned long  *pcbActual, DWORD dsid)
{
    JET_ERR err;

    err = JetUpdate(sesid, tableid, pvBookmark, cbBookmark, pcbActual);

    switch (err) {
      case JET_errSuccess:
        return err;

      case JET_errKeyDuplicate:
      case JET_errWriteConflict:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                       DS_EVENT_SEV_EXTENSIVE);

      default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                       DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetEscrowUpdateException(JET_SESID sesid,
                         JET_TABLEID tableid,
                         JET_COLUMNID columnid,
                         void *pvDelta,
                         unsigned long cbDeltaMax,
                         void *pvOld,
                         unsigned long cbOldMax,
                         unsigned long *pcbOldActual,
                         JET_GRBIT grbit,
                         DWORD dsid)
{
    JET_ERR err;

    err = JetEscrowUpdate(sesid, tableid, columnid, pvDelta, cbDeltaMax,
                          pvOld, cbOldMax, pcbOldActual, grbit);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    case JET_errWriteConflict:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_EXTENSIVE);

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetRetrieveColumnException(JET_SESID sesid, JET_TABLEID tableid,
    JET_COLUMNID columnid, void  *pvData, unsigned long cbData,
    unsigned long  *pcbActual, JET_GRBIT grbit, JET_RETINFO  *pretinfo,
    BOOL fExceptOnWarning, DWORD dsid)
{
    JET_ERR err;

    err = JetRetrieveColumn(sesid, tableid, columnid, pvData, cbData,
    pcbActual, grbit, pretinfo);

    switch (err)
    {
    case JET_errSuccess:
        return err;

        case JET_errColumnNotFound:
            // The column wasn't found.  If we weren't trying to read this
            // column from the index, return this as an error.  If we were
            // reading from the index, treat this as a warning.
            if(!(grbit & JET_bitRetrieveFromIndex)) {
                RaiseDsaExcept(DSA_DB_EXCEPTION,
                               (ULONG) err, 0, dsid,
                               DS_EVENT_SEV_MINIMAL);
            }
            // fall through

    case JET_wrnColumnNull:
    case JET_wrnBufferTruncated:
        if (!fExceptOnWarning)
        return err;

        // fall through
    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetRetrieveColumnsException( JET_SESID sesid, JET_TABLEID tableid,
    JET_RETRIEVECOLUMN *pretrievecolumn, unsigned long cretrievecolumn,
    BOOL fExceptOnWarning, DWORD dsid)
{
    JET_ERR err;

    err = JetRetrieveColumns(sesid, tableid, pretrievecolumn, cretrievecolumn);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    case JET_wrnColumnNull:
    case JET_wrnBufferTruncated:
        if (!fExceptOnWarning)
        return err;

        // fall through
    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;

}

JET_ERR
JetEnumerateColumnsException(
    JET_SESID           sesid,
    JET_TABLEID         tableid,
    ULONG               cEnumColumnId,
    JET_ENUMCOLUMNID*   rgEnumColumnId,
    ULONG*              pcEnumColumn,
    JET_ENUMCOLUMN**    prgEnumColumn,
    JET_PFNREALLOC      pfnRealloc,
    void*               pvReallocContext,
    ULONG               cbDataMost,
    JET_GRBIT           grbit,
    DWORD               dsid )
{
    JET_ERR err;

    err = JetEnumerateColumns(
        sesid,
        tableid,
        cEnumColumnId,
        rgEnumColumnId,
        pcEnumColumn,
        prgEnumColumn,
        pfnRealloc,
        pvReallocContext,
        cbDataMost,
        grbit );

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;

}

JET_ERR
JetSetColumnException(
        JET_SESID sesid, JET_TABLEID tableid,
        JET_COLUMNID columnid, const void  *pvData, unsigned long cbData,
        JET_GRBIT grbit, JET_SETINFO  *psetinfo,
        BOOL fExceptOnWarning, DWORD dsid)
{
    JET_ERR err;

    err = JetSetColumn(sesid, tableid, columnid, pvData, cbData, grbit,
                       psetinfo);

    switch (err)
    {
    case JET_errSuccess:
        return err;

        case JET_errMultiValuedDuplicate:
        case JET_errMultiValuedDuplicateAfterTruncation:
            if(!fExceptOnWarning)
                return err;

            // fall through

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetSetColumnsException(JET_SESID sesid, JET_TABLEID tableid,
    JET_SETCOLUMN *psetcolumn, unsigned long csetcolumn , DWORD dsid)
{
    JET_ERR err;

    err = JetSetColumns(sesid, tableid, psetcolumn, csetcolumn );

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetPrepareUpdateException(JET_SESID sesid, JET_TABLEID tableid,
    unsigned long prep, DWORD dsid)
{
    JET_ERR err;

    err = JetPrepareUpdate(sesid, tableid, prep);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    case JET_errWriteConflict:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_EXTENSIVE);

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetGetRecordPositionException(JET_SESID sesid, JET_TABLEID tableid,
    JET_RECPOS  *precpos, unsigned long cbRecpos, DWORD dsid)
{
    JET_ERR err;

    err = JetGetRecordPosition(sesid, tableid, precpos, cbRecpos);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetGotoPositionException(JET_SESID sesid, JET_TABLEID tableid,
    JET_RECPOS *precpos, DWORD dsid)
{
    JET_ERR err;

    err = JetGotoPosition(sesid, tableid, precpos );

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetDupCursorException(JET_SESID sesid, JET_TABLEID tableid,
    JET_TABLEID  *ptableid, JET_GRBIT grbit, DWORD dsid)
{
    JET_ERR err;

    err = JetDupCursor(sesid, tableid, ptableid, grbit);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetGetCurrentIndexException(JET_SESID sesid, JET_TABLEID tableid,
    char  *szIndexName, unsigned long cchIndexName, DWORD dsid)
{
    JET_ERR err;

    err = JetGetCurrentIndex(sesid, tableid, szIndexName, cchIndexName);

    switch (err)
    {
    case JET_errSuccess:
    case JET_wrnBufferTruncated:
    case JET_errNoCurrentIndex:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR JetSetCurrentIndex2Exception( JET_SESID sesid, JET_TABLEID tableid,
    const char *szIndexName, JET_GRBIT grbit, BOOL fReturnErrors,
        DWORD dsid)
{
    JET_ERR err;

    err = JetSetCurrentIndex2(sesid, tableid, szIndexName,grbit);

    switch( err) {
    case JET_errSuccess:
        return err;

    case JET_errIndexNotFound:
    case JET_errNoCurrentRecord:
        if( fReturnErrors)
        return err;

        /* else fall through */
    default:
    RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                       DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetSetCurrentIndex4Exception(JET_SESID sesid,
                             JET_TABLEID tableid,
                             const char *szIndexName,
                             struct tagJET_INDEXID *pidx,
                             JET_GRBIT grbit,
                             BOOL fReturnErrors,
                             DWORD dsid)
{
    JET_ERR err;

    err = JetSetCurrentIndex4(sesid, tableid, szIndexName, pidx, grbit, 0);

    switch( err) {
    case JET_errSuccess:
        return err;

    case JET_errInvalidIndexId:
    case JET_errInvalidParameter:
        // Refresh the hint
        if (NULL != pidx) {
            // Ignore errors. Retry at a later failure
            err = JetGetTableIndexInfo(sesid,
                                       tableid,
                                       szIndexName,
                                       pidx,
                                       sizeof(*pidx),
                                       JET_IdxInfoIndexId);
        }
        // And set the index w/o the hint
        err = JetSetCurrentIndex2(sesid, tableid, szIndexName, grbit);
        if (JET_errSuccess == err) {
            return err;
        }

        /* else fall through */

    case JET_errIndexNotFound:
    case JET_errNoCurrentRecord:
        if( fReturnErrors)
        return err;

        /* else fall through */
    default:
    RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                       DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetMoveException(JET_SESID sesid, JET_TABLEID tableid,
    long cRow, JET_GRBIT grbit, DWORD dsid)
{
    JET_ERR err;

    err = JetMove(sesid, tableid, cRow, grbit);

    switch (err)
    {
    case JET_errSuccess:
    case JET_errNoCurrentRecord:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetMakeKeyException(JET_SESID sesid, JET_TABLEID tableid,
    const void  *pvData, unsigned long cbData, JET_GRBIT grbit,
                    DWORD dsid)
{
    JET_ERR err;

    err = JetMakeKey(sesid, tableid, pvData, cbData, grbit);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetSeekException(JET_SESID sesid, JET_TABLEID tableid,
    JET_GRBIT grbit, DWORD dsid)
{
    JET_ERR err;

    err = JetSeek(sesid, tableid, grbit);

    switch (err)
    {
    case JET_errSuccess:
    case JET_errRecordNotFound:
    case JET_wrnSeekNotEqual:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetGetBookmarkException(JET_SESID sesid, JET_TABLEID tableid,
    void  *pvBookmark, unsigned long cbMax,
    unsigned long  *pcbActual, DWORD dsid)
{
    JET_ERR err;

    err = JetGetBookmark(sesid, tableid, pvBookmark, cbMax, pcbActual);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetGotoBookmarkException(JET_SESID sesid, JET_TABLEID tableid,
    void  *pvBookmark, unsigned long cbBookmark, DWORD dsid)
{
    JET_ERR err;

    err = JetGotoBookmark(sesid, tableid, pvBookmark, cbBookmark);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetComputeStatsException(JET_SESID sesid, JET_TABLEID tableid, DWORD dsid)
{
    JET_ERR err;

    err = JetComputeStats(sesid, tableid);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetOpenTempTableException(JET_SESID sesid,
    const JET_COLUMNDEF  *prgcolumndef, unsigned long ccolumn,
    JET_GRBIT grbit, JET_TABLEID  *ptableid,
    JET_COLUMNID  *prgcolumnid, DWORD dsid)
{
    JET_ERR err;

    err = JetOpenTempTable(sesid, prgcolumndef, ccolumn, grbit, ptableid, prgcolumnid);

    switch (err)
    {
    case JET_errSuccess:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetIntersectIndexesException(JET_SESID sesid,
    JET_INDEXRANGE * rgindexrange, unsigned long cindexrange,
    JET_RECORDLIST * precordlist, JET_GRBIT grbit, DWORD dsid)
{
    JET_ERR err;

    err = JetIntersectIndexes(sesid, rgindexrange, cindexrange, precordlist, grbit);

    switch (err)
    {
    case JET_errSuccess:
        return JET_errSuccess;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetSetIndexRangeException(JET_SESID sesid,
    JET_TABLEID tableidSrc, JET_GRBIT grbit, DWORD dsid)
{
    JET_ERR err;

    err = JetSetIndexRange(sesid, tableidSrc, grbit);

    switch (err)
    {
        case JET_errNoCurrentRecord:
        // The end of the index is the end of the range.
    case JET_errSuccess:
        return JET_errSuccess;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetIndexRecordCountException(JET_SESID sesid,
    JET_TABLEID tableid, unsigned long  *pcrec, unsigned long crecMax ,
        DWORD dsid)
{
    JET_ERR err;

    err = JetIndexRecordCount(sesid, tableid, pcrec, crecMax );

    switch (err)
    {
    case JET_errSuccess:
    case JET_errNoCurrentRecord:
        return err;

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}

JET_ERR
JetRetrieveKeyException(JET_SESID sesid,
                        JET_TABLEID tableid, void  *pvData, unsigned long cbMax,
                        unsigned long  *pcbActual, JET_GRBIT grbit ,
                        BOOL fExceptOnWarning, DWORD dsid)
{
    JET_ERR err;

    err = JetRetrieveKey(sesid, tableid, pvData, cbMax, pcbActual, grbit );

    switch (err)
    {
    case JET_errSuccess:
        return err;

        case JET_wrnBufferTruncated:
            if(!fExceptOnWarning) {
                return err;
            }
            // fall through.

    default:
        RaiseDsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0, dsid,
                           DS_EVENT_SEV_MINIMAL);
    }
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dbisam.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbisam.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <mdlocal.h>
#include <dsatools.h>                   // For pTHS

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>

// Assorted DSA headers
#include <hiertab.h>
#include "anchor.h"
#include <dsevent.h>
#include <filtypes.h>                   // Def of FI_CHOICE_???
#include "objids.h"                     // Hard-coded Att-ids and Class-ids
#include "usn.h"
#include "drameta.h"
#include "debug.h"                      // standard debugging header
#include "dstaskq.h"                    /* task queue stuff */
#define DEBSUB "DBISAM:"                // define the subsystem for debugging

// DBLayer includes
#include "dbintrnl.h"

// perfmon header
#include "ntdsctr.h"

#include <fileno.h>
#define  FILENO FILENO_DBISAM

typedef enum _DB_CHECK_ACTION {
    DB_CHECK_ERROR = 0,
    DB_CHECK_DELETE_OBJECT,
    DB_CHECK_HAS_DELETED_CHILDREN,
    DB_CHECK_LIVE_CHILD
} DB_CHECK_ACTION;

BOOL gfDoingABRef = FALSE;

/* Column IDs for static (key) columns */

JET_COLUMNID insttypeid;
JET_COLUMNID objclassid;
JET_COLUMNID ntsecdescid;
JET_COLUMNID dscorepropinfoid;
JET_COLUMNID dntid;
JET_COLUMNID pdntid;
JET_COLUMNID ancestorsid;
JET_COLUMNID objid;
JET_COLUMNID rdnid;
JET_COLUMNID rdntypid;
JET_COLUMNID cntid;
JET_COLUMNID abcntid;
JET_COLUMNID deltimeid;
JET_COLUMNID usnid;
JET_COLUMNID usnchangedid;
JET_COLUMNID dsaid;
JET_COLUMNID ncdntid;
JET_COLUMNID isdeletedid;
JET_COLUMNID IsVisibleInABid;
JET_COLUMNID iscriticalid;
JET_COLUMNID cleanid;
// Link table
JET_COLUMNID linkdntid;
JET_COLUMNID backlinkdntid;
JET_COLUMNID linkbaseid;
JET_COLUMNID linkdataid;
JET_COLUMNID linkndescid;
// Link Value Replication
JET_COLUMNID linkdeltimeid;
JET_COLUMNID linkusnchangedid;
JET_COLUMNID linkncdntid;
JET_COLUMNID linkmetadataid;
// Link Value Replication

JET_COLUMNID guidid;
JET_COLUMNID distnameid;
JET_COLUMNID sidid;
JET_COLUMNID orderid;
JET_COLUMNID begindntid;
JET_COLUMNID trimmableid;
JET_COLUMNID clientidid;
JET_COLUMNID sdpropflagsid;

JET_COLUMNID ShowInid;
JET_COLUMNID mapidnid;

// SD table
JET_COLUMNID sdidid;
JET_COLUMNID sdhashid;
JET_COLUMNID sdvalueid;
JET_COLUMNID sdrefcountid;

JET_INDEXID idxDnt;
JET_INDEXID idxDraUsn;
JET_INDEXID idxDraUsnCritical;
JET_INDEXID idxDsaUsn;
JET_INDEXID idxMapiDN;
JET_INDEXID idxNcAccTypeName;
JET_INDEXID idxNcAccTypeSid;
JET_INDEXID idxPdnt;
JET_INDEXID idxPhantom;
JET_INDEXID idxProxy;
JET_INDEXID idxRdn;
JET_INDEXID idxSid;
JET_INDEXID idxDel;
JET_INDEXID idxGuid;
JET_INDEXID idxDntDel;
JET_INDEXID idxDntClean;
JET_INDEXID idxAncestors;
JET_INDEXID idxInvocationId;

// Link Value Replication
JET_INDEXID idxLink;
JET_INDEXID idxBackLink;
JET_INDEXID idxLinkDel;
JET_INDEXID idxLinkDraUsn;
JET_INDEXID idxLinkLegacy;
JET_INDEXID idxLinkAttrUsn;
// Link Value Replication

// Lingering Object Removal
JET_INDEXID idxNcGuid;

// SD table indices
JET_INDEXID idxSDId;
JET_INDEXID idxSDHash;


// These are the usns used by the DSA and tloadobj. gusnec is the running
// usn which is incremented every time it's used and is the one used to
// stamp usns on updates. gusninit is a copy of the usn in the hidden
// record. We read gusnec from disk, and set gusninit as USN_DELTA more.
// We write gusninit back to the hidden record, and then when gusnec grows
// past gusninit, we increment gusninit again and update the disk copy.
// The update code is in dbrepl.

USN gusnEC = 1; // tloadobj needs a start point
USN gusnInit = 1; // make same as gusnEC, so that mkdit doesn't assert on first
                  // object add (since it doesn't call InitDsaInfo)

// We also keep track of the lowest usn that has not been committed. We do
// this because otherwise, when the DRA searches in another session in
// getncchanges it may find a higher usn that *has* been committed,
// and return that usn, in which case the DRA would start its next search
// past the uncommitted usn and never find it.

USN gusnLowestUncommitted = MAXLONGLONG;

// This is the array of all the lowest uncommitted usns allocated by the
// threads in  the system. there is one per session. The number of sessions
// is configurable from the registry, so the array is dynamically allocated
// at initialization.

USN *UncUsn;

// This is the critical section that guards access to the uncommitted
// usn array and the global uncommitted usn value.

CRITICAL_SECTION csUncUsn;

SYNTAX_JET syntax_jet[] = {
    {SYNTAX_UNDEFINED_TYPE,     JET_coltypUnsignedByte,0,CP_NON_UNICODE_FOR_JET,
     IndexTypeNone},
    {SYNTAX_DISTNAME_TYPE,      JET_coltypLong,        0,CP_NON_UNICODE_FOR_JET,
     IndexTypeAppendDNT},
    {SYNTAX_OBJECT_ID_TYPE,     JET_coltypLong,        0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_CASE_STRING_TYPE,   JET_coltypLongBinary,    0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_NOCASE_STRING_TYPE, JET_coltypLongText,    0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_PRINT_CASE_STRING_TYPE, JET_coltypLongBinary,0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_NUMERIC_STRING_TYPE, JET_coltypBinary,      0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_DISTNAME_BINARY_TYPE, JET_coltypLongBinary,  0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_BOOLEAN_TYPE,       JET_coltypLong,        0,CP_NON_UNICODE_FOR_JET,
     IndexTypeAppendDNT},
    {SYNTAX_INTEGER_TYPE,       JET_coltypLong,        0,CP_NON_UNICODE_FOR_JET,
     IndexTypeAppendDNT},
    {SYNTAX_OCTET_STRING_TYPE,  JET_coltypLongBinary,  0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_TIME_TYPE,          JET_coltypCurrency,        0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_UNICODE_TYPE ,      JET_coltypLongText,    0,CP_WINUNICODE,
     IndexTypeSingleColumn},
    {SYNTAX_ADDRESS_TYPE,       JET_coltypText,      255,CP_NON_UNICODE_FOR_JET,
     IndexTypeNone},
    {SYNTAX_DISTNAME_STRING_TYPE, JET_coltypLongBinary, 0,CP_NON_UNICODE_FOR_JET,
     IndexTypeNone},
    {SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE,  JET_coltypLongBinary,  0,
     CP_NON_UNICODE_FOR_JET,  IndexTypeSingleColumn},
    {SYNTAX_I8_TYPE,            JET_coltypCurrency,    0,CP_NON_UNICODE_FOR_JET,
     IndexTypeSingleColumn},
    {SYNTAX_SID_TYPE,           JET_coltypLongBinary,  0,CP_NON_UNICODE_FOR_JET,     IndexTypeSingleColumn},
    {ENDSYNTAX,                 0,                     0,CP_NON_UNICODE_FOR_JET,
     IndexTypeNone }
};



// This is a list of attribute IDs that have indices based on them
// that must not ever be removed.  You get into this list by having a hardcoded
// index named "INDEX_%08X" or "INDEX_P_%08X", where %08X is the attribute id
// the index indexes on. The list is terminated with a 0x7FFFFFFF.  If you ever
// create an index like this, or remove one that is named like this, you must
// change this  list.  The actual #defines which make these index names are in
// dbintrnl.h, so if you ever think something funny having to do with this list
// is going on, or you are just bored, you my cross reference this list with
// that file.
//
// NOTE: We used to keep this list ordered which required entry of numeric
//       attids which then would not track changes to schema.ini.  So we
//       now use ATT_* manifest constants and sort the list at init time.
//
// The indexType value shows the index type (fATTINdex or fPDNTATTINDEX or
// both, the values are 0x1, 0x2, or bitwise OR, defined in scache.h) that
// these attributes should have. They are taken from their defined values
// in schema.ini. If you change the index type for these in schema.ini
// you should change the value here too.
//
// We also define an end marker which ComparAttrtypInIndexInfo will
// not interpret as a negative number.

#define ATT_END_MARKER 0x7fffffff


INDEX_INFO IndicesToKeep[] = {
   { ATT_ALT_SECURITY_IDENTITIES,  SYNTAX_UNICODE_TYPE,         fATTINDEX },  // lookup by alternate credentials
   { ATT_DISPLAY_NAME,             SYNTAX_UNICODE_TYPE,         fATTINDEX | fANR },   // name cracking
   { ATT_DNS_ROOT,                 SYNTAX_UNICODE_TYPE,         fATTINDEX },   // name cracking
   { ATT_FLAT_NAME,                SYNTAX_UNICODE_TYPE,         fATTINDEX },   // used by LSA for
                                                  // trust lookups
   { ATT_FSMO_ROLE_OWNER,          SYNTAX_DISTNAME_TYPE,        fATTINDEX },   // so UI can find
                                                  // owners quickly
   { ATT_GIVEN_NAME,               SYNTAX_UNICODE_TYPE,         fATTINDEX | fANR },  // MAPI
   { ATT_GROUP_TYPE,               SYNTAX_INTEGER_TYPE,         fATTINDEX },   // needed by object picker
                                                  // and other UI
   { ATT_INVOCATION_ID,            SYNTAX_OCTET_STRING_TYPE,    fATTINDEX },   // find NTDS-DSA efficiently
   { ATT_LDAP_DISPLAY_NAME,        SYNTAX_UNICODE_TYPE,         fATTINDEX },   // efficient schema lookup
   { ATT_LEGACY_EXCHANGE_DN,       SYNTAX_NOCASE_STRING_TYPE,   fATTINDEX | fANR },   // MAPI support?
   { ATT_NETBIOS_NAME,             SYNTAX_UNICODE_TYPE,         fATTINDEX },   // name cracking
   { ATT_OBJECT_CATEGORY,          SYNTAX_DISTNAME_TYPE,        fATTINDEX },   // efficient "object class" search
   { ATT_OBJECT_GUID,              SYNTAX_OCTET_STRING_TYPE,    fATTINDEX },   // efficient SAM, other lookups
   { ATT_OBJECT_SID,               SYNTAX_SID_TYPE,             fATTINDEX },   // efficient SAM lookups
   { ATT_PRIMARY_GROUP_ID,         SYNTAX_INTEGER_TYPE,         fATTINDEX },   // SAM primary group optimization
   { ATT_PROXIED_OBJECT_NAME,      SYNTAX_DISTNAME_BINARY_TYPE, fATTINDEX },   // cross domain move & replay
   { ATT_PROXY_ADDRESSES,          SYNTAX_UNICODE_TYPE,         fATTINDEX | fANR },   // MAPI support?
   { ATT_SAM_ACCOUNT_NAME,         SYNTAX_UNICODE_TYPE,         fATTINDEX | fANR },   // name cracking
   { ATT_SAM_ACCOUNT_TYPE,         SYNTAX_INTEGER_TYPE,         fATTINDEX },   // needed by object picker
                                                  // and other UI
   { ATT_SERVICE_PRINCIPAL_NAME,   SYNTAX_UNICODE_TYPE,         fATTINDEX },   // name cracking
   { ATT_SID_HISTORY,              SYNTAX_SID_TYPE, fATTINDEX },   // name cracking
   { ATT_SURNAME,                  SYNTAX_UNICODE_TYPE, fATTINDEX | fANR }, // MAPI
   { ATT_TRUST_PARTNER,            SYNTAX_UNICODE_TYPE, fATTINDEX },   // used by LSA for trust lookups
   { ATT_USER_ACCOUNT_CONTROL,     SYNTAX_INTEGER_TYPE, fATTINDEX },   // for efficient SAM searches
   { ATT_USER_PRINCIPAL_NAME,      SYNTAX_UNICODE_TYPE, fATTINDEX },   // name cracking
   { ATT_USN_CHANGED,              SYNTAX_I8_TYPE, fATTINDEX },   // efficient find of changed objects
   { ATT_END_MARKER,               0,  0  },         // must be last in list
};

DWORD cIndicesToKeep = sizeof(IndicesToKeep) / sizeof(IndicesToKeep[0]);

int __cdecl
CompareAttrtypInIndexInfo(
        const void * pv1,
        const void * pv2
        )
/*
 * Cheap function needed by qsort for sorting IndexInfo structures by attrType
 */
{
    return ( CompareAttrtyp(&((INDEX_INFO *)pv1)->attrType,
                            &((INDEX_INFO *)pv2)->attrType) );
}

/*
 * Small helper routine to find if an attribute is in the
 * indices-to-keep table
*/

BOOL
AttInIndicesToKeep(ULONG id)
{
    INDEX_INFO * pIndexToKeep = IndicesToKeep;

    while( pIndexToKeep->attrType < id) {
       pIndexToKeep++;
    }

    if( pIndexToKeep->attrType == id) {
       // found it
       return TRUE;
    }

    return FALSE;
}


VOID
dbInitIndicesToKeep()
{

    // sort by attrType field

    qsort((void *) IndicesToKeep,
          (size_t) cIndicesToKeep,
          (size_t) sizeof(IndicesToKeep[0]),
          CompareAttrtypInIndexInfo);
    // Verify ascending order.
    Assert(IndicesToKeep[1].attrType > IndicesToKeep[0].attrType);
    // Verify end marker.
    Assert(ATT_END_MARKER == IndicesToKeep[cIndicesToKeep-1].attrType);
}

/* Internal functions */

DWORD WriteRoot(DBPOS FAR *pDB);
BOOL  FObjHasDisplayName(DBPOS *pDB);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* AddUncUsn - Record this usn as uncommitted

   Called when a thread takes a usn.

   If we have no uncommitted usn in this thread, then this is the
   lowest uncommitted usn and we save it in the thread state.
   If we have no system-wide uncommitted usn, then this is the
   lowest system-wide uncommitted usn and we save it in the global variable.
*/
void AddUncUsn (USN usn)
{
    THSTATE *pTHS = pTHStls;
   unsigned i;

   // If there is no existing lowest usn for this thread, use new one.

   if (pTHS->UnCommUsn == 0) {
        pTHS->UnCommUsn  = usn ;

        // If there's no existing lowest system wide, use this one.

        if (gusnLowestUncommitted  == USN_MAX ) {
            gusnLowestUncommitted  = usn ;
        } else {

            // Ok there is already a lowest (which must be lower),
            // so just add this thread's lowest usn to array

            for (i=0;i< gcMaxJetSessions;i++) {
                if (UncUsn[i]  == USN_MAX ) {
                    UncUsn[i]  = usn ;
                    break;
                }
            }
            if (i == gcMaxJetSessions) {
                // Not enough space
                Assert(FALSE);
                LogUnhandledError ((LONG)usn);
            }
        }
    }
}
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* dbFlushUncUsns - Remove this thread's usns from uncommitted.

   Called when a thread has committed (or rolled back) all its usns, which
   will include its lowest uncommitted usn. Find new lowest and clear this
   thread's lowest from thread storage and array.

*/
#if defined(_M_IA64)
#if _MSC_FULL_VER== 13008973
#pragma optimize("", off)
#endif
#endif
void dbFlushUncUsns (void)
{
    THSTATE *pTHS=pTHStls;
    USN usnThread;
    unsigned i;
    USN usnHighestCommitted;

    usnThread  = pTHS->UnCommUsn ;

    // If this thread had a lowest usn ...

    if (usnThread !=0) {

        EnterCriticalSection (&csUncUsn);
        __try {

            // If it's the system-wide lowest replace it with next lowest

            if (usnThread  == gusnLowestUncommitted ) {

                USN usnTemp  = USN_MAX ;
                unsigned IndexLowest = gcMaxJetSessions;

                // Find lowest usn in array.

                for (i=0;i < gcMaxJetSessions;i++) {
                    if (UncUsn[i]  < usnTemp ) {
                        usnTemp  = UncUsn[i] ;
                        IndexLowest = i;
                    }
                }
                // If we found a lowest, put that in global and clear that entry.
                // Else set global usn to max.

                if (IndexLowest != gcMaxJetSessions) {
                    gusnLowestUncommitted  = UncUsn[IndexLowest] ;
                    UncUsn[IndexLowest]  = USN_MAX ;
                } else {
                    gusnLowestUncommitted  = USN_MAX ;
                }

            } else {

                // Or just remove it from the array.

                for (i=0;i < gcMaxJetSessions;i++) {
                    if (UncUsn[i]  == usnThread ) {
                        UncUsn[i]  = USN_MAX ;
                        break;
                    }
                }
                if (i == gcMaxJetSessions) {

                    // Usn not found.

                    Assert(!usnThread );
                    LogUnhandledError ((LONG)usnThread);
                }
            }
            // Finally indicate no lowest usn in this thread.

            pTHS->UnCommUsn  = 0;

            // update perfmon counters
            usnHighestCommitted = ((USN_MAX == gusnLowestUncommitted) ?
                                    (gusnEC - 1) : (gusnLowestUncommitted -1));

            ISET(pcHighestUsnCommittedLo, LODWORD(usnHighestCommitted));
            ISET(pcHighestUsnCommittedHi, HIDWORD(usnHighestCommitted));

        }
        __finally {
            LeaveCriticalSection (&csUncUsn);
        }
    }
}
#if defined( _M_IA64)
#if _MSC_FULL_VER== 13008973
#pragma optimize("", on)
#endif
#endif


/*++
  DBFindBestMatch

Routine Description:

    Find the closest real object match of the object specified by DSNAME.  This
    match can be either an object by the same name but a different GUID, or the
    nearest real object parent.  If no real object parent is available, returns
    the dsname of the ROOT.

    1 - Re-initialize the DB object
    2 - Look the DN up in the subject table and get the tag of the best match.
    3 - use the DNT DN index to find the object index record.
    4 - look at the object found and its parents until we find the root or a
        real object.

Returns:

      0

--*/

DWORD APIENTRY
DBFindBestMatch(DBPOS *pDB, DSNAME *pDN, DSNAME **pParent)
{
    THSTATE         *pTHS=pDB->pTHS;
    DWORD            dwError;
    ULONG            ulDNT;
    ULONG            cbActual;
    JET_ERR          err;

    // NOTE This routine may reposition currency in the object table.

    Assert(VALID_DBPOS(pDB));

    // Since we are moving currency, we need to assure that we are not
    // in the middle of an init rec.  If we were, then whatever update
    // we were doing would be lost, because you can't change currency
    // inside of an update.


    Assert(pDB->JetRetrieveBits == 0);

    // There's been some confusion about the meaning of NameLen and whether
    // or not the trailing null is included.  The answer is: there should
    // be NameLen non-null characters in the name, but enough space should
    // be allocated in the structure to hold one extra null.  The following
    // asserts make sure that misallocated names are caught.
    Assert(pDN->StringName[pDN->NameLen] == L'\0');
    Assert(pDN->NameLen == 0 || pDN->StringName[pDN->NameLen-1] != L'\0');
    Assert(pDN->structLen >= DSNameSizeFromLen(pDN->NameLen));

    dbInitpDB(pDB);

    // Find the object by name.
    dwError = sbTableGetTagFromDSName(pDB, pDN, 0, &ulDNT, NULL);

    if ( 0 == dwError ) {
        // It's a real object.  Just copy the name to an output buffer.
        *pParent = THAllocEx(pTHS, pDN->structLen);
        memcpy(*pParent, pDN, pDN->structLen);
        return 0;
    }

    // We bailed, but ulDNT was the last good tag.  Go there.
    DBFindDNT(pDB, ulDNT);

    // We've placed currency.  Now, while currency is NOT on a real object, set
    // currency to the parent.
    while (pDB->DNT != ROOTTAG && !DBCheckObj(pDB)) {
        DBFindDNT(pDB, pDB->PDNT);
    }
    // Now find the object nearest this one, that is visible
    // to the client
    FindFirstObjVisibleBySecurity(pTHS, pDB->DNT, pParent);

    return 0;
}

/*++DBFindDSName
 *
 * Find the object specified by DSNAME.
 *
 * 1 - Re-initialize the DB object
 * 2 - Look the DN up in the subject table and get its tag.
 * 3 - use the DNT DN index to find the object index record.
 * 4 - initialize some object flags.
 *
 * Returns:
 *
 *      DIRERR_NOT_AN_OBJECT if the object is found but a phantom.
 *      DIRERR_OBJ_NOT_FOUND if the object is not found.
 *      Miscellaneous sbTableGetTagFromDSName errors.
 *
 */

DWORD APIENTRY
DBFindDSName(DBPOS FAR *pDB, const DSNAME *pDN)
{
    DWORD   dwError;
    ULONG   ulSaveDnt;
    JET_ERR err;

    Assert(VALID_DBPOS(pDB));

    // There's been some confusion about the meaning of NameLen and whether
    // or not the trailing null is included.  The answer is: there should
    // be NameLen non-null characters in the name, but enough space should
    // be allocated in the structure to hold one extra null.  The following
    // asserts make sure that misallocated names are caught.
    Assert(pDN->NameLen == 0 || pDN->StringName[pDN->NameLen] == L'\0');
    Assert(pDN->structLen >= DSNameSizeFromLen(pDN->NameLen));

    // Since we are moving currency, we need to assure that we are not
    // in the middle of an init rec.  If we were, then whatever update
    // we were doing would be lost, because you can't change currency
    // inside of an update.
    Assert(pDB->JetRetrieveBits == 0);

    // Initialize a new object

    dbInitpDB(pDB);

    dwError = sbTableGetTagFromDSName(pDB, (DSNAME*)pDN,
                  SBTGETTAG_fUseObjTbl | SBTGETTAG_fMakeCurrent, NULL, NULL);

    return dwError;
}
DWORD APIENTRY
DBFindDSNameAnyRDNType(DBPOS FAR *pDB, const DSNAME *pDN)
// This routine is the same as DBFindDSName except it doesn't check the type of
// the RDN of the object (although it does enforce type equality for all other
// components of the DN)
{
    DWORD   dwError;
    ULONG   ulSaveDnt;
    JET_ERR err;

    Assert(VALID_DBPOS(pDB));

    // There's been some confusion about the meaning of NameLen and whether
    // or not the trailing null is included.  The answer is: there should
    // be NameLen non-null characters in the name, but enough space should
    // be allocated in the structure to hold one extra null.  The following
    // asserts make sure that misallocated names are caught.
    Assert(pDN->NameLen == 0 || pDN->StringName[pDN->NameLen] == L'\0');
    Assert(pDN->NameLen == 0 || pDN->StringName[pDN->NameLen-1] != L'\0');
    Assert(pDN->structLen >= DSNameSizeFromLen(pDN->NameLen));

    // Since we are moving currency, we need to assure that we are not
    // in the middle of an init rec.  If we were, then whatever update
    // we were doing would be lost, because you can't change currency
    // inside of an update.
    Assert(pDB->JetRetrieveBits == 0);

    // Initialize a new object

    dbInitpDB(pDB);

    dwError = sbTableGetTagFromDSName(pDB,
                                      (DSNAME*)pDN,
                                      (SBTGETTAG_fAnyRDNType  |
                                       SBTGETTAG_fUseObjTbl   |
                                       SBTGETTAG_fMakeCurrent   ),
                                      NULL,
                                      NULL);

    return dwError;
}

/*++DBFindObjectWithSid
 *
 *     Given a DS Name Specifying  a SID and an DWORD specifying the
 *     ith object, this routine finds that object.
 *
 *
 *     Returns
 *          0                       - Found the Object Successfully
 *          DIRERR_OBJECT_NOT_FOUND - If the Object Was not found
 *          DIRERR_NOT_AN_OBJECT    - If the Object is a Phantom
 *
 --*/
DWORD APIENTRY
DBFindObjectWithSid(DBPOS FAR *pDB, DSNAME * pDN, DWORD iObject)
{

    NT4SID InternalFormatSid;
    DWORD err;
    ULONG cbActual;

    Assert(VALID_DBPOS(pDB));
    Assert(pDN->SidLen>0);
    Assert(RtlValidSid(&pDN->Sid));


    err = DBSetCurrentIndex(pDB, Idx_Sid, NULL, FALSE);
    Assert(err == 0);       // the index must always be there

    // Convert the Sid to Internal Representation
    memcpy(&InternalFormatSid,&(pDN->Sid),RtlLengthSid(&(pDN->Sid)));
    InPlaceSwapSid(&InternalFormatSid);

    // Make a Jet Key
    JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl, &InternalFormatSid,
                 RtlLengthSid(&InternalFormatSid), JET_bitNewKey);

    err = JetSeek(pDB->JetSessID, pDB->JetObjTbl,
                  JET_bitSeekEQ|JET_bitSetIndexRange);
    if ( 0 == err )  {
#ifndef JET_BIT_SET_INDEX_RANGE_SUPPORT_FIXED
        JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl,
                     &InternalFormatSid,RtlLengthSid(&InternalFormatSid),
                     JET_bitNewKey);

        JetSetIndexRangeEx(pDB->JetSessID, pDB->JetObjTbl,
                           (JET_bitRangeUpperLimit | JET_bitRangeInclusive ));
#endif
        //
        // Ok We found the object. Keep Moving Forward Until either the SID does
        // not Match or we reached the given object
        //

        if((0==err) && (iObject>0)) {
            err = JetMove(
                    pDB->JetSessID,
                    pDB->JetObjTbl,
                    iObject,
                    0);
        }

        if (0==err) {
            // Establish currency on the object found, which also checks
            // the object flag.
            err = dbMakeCurrent(pDB, NULL);

            if (err) {
                DPRINT1(1,
                        "DBFindObjectWithSid: success, DNT=%ld of non object\n",
                        (pDB)->DNT);
            }
        }
        else {
            err = DIRERR_OBJ_NOT_FOUND;
        }
    }
    else {
        err = DIRERR_OBJ_NOT_FOUND;
    }

    return err;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Check that the object portion of the record exists.
     return: !0  present.
             0   not present or failure.
*/
char APIENTRY
DBCheckObj(DBPOS FAR *pDB)
{
    JET_ERR  dwError;
    char     objval;
    long     actuallen;

    Assert(VALID_DBPOS(pDB));

    switch (dwError = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetObjTbl,
                                                objid,
                                                &objval, sizeof(objval),
                                                &actuallen,
                                                pDB->JetRetrieveBits, NULL)) {
    case JET_errSuccess:
        return objval;
    case JET_wrnColumnNull:
        return 0;
    default:
        DsaExcept(DSA_DB_EXCEPTION, dwError, 0);
    }
    return 0;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add a new object to the database.
     1 - Set the create date to the current time.
     2 - Add the attribute fields to the record.
     3 - Get the RDN of the object if it isn't a root object.

   NOTE:
     This function assumes that the object class, DN and RDN attributes
     have already been set.
*/

DWORD APIENTRY
dbReplAdd(DBPOS FAR *pDB, USN usn, DWORD fFlags)
{
    THSTATE    *pTHS=pDB->pTHS;
    SYNTAX_TIME  time;
    char         objval = 1;
    SYNTAX_TIME  timeDeleted = 0;
    ULONG       actuallen;
    UCHAR       syntax;
    ULONG       len;
    UCHAR       *pVal;

    Assert(VALID_DBPOS(pDB));

    if (fFlags & DBREPL_fRESET_DEL_TIME)
    {
        // all we need to do is reset the deletion time

        JetSetColumnEx(pDB->JetSessID,
                       pDB->JetObjTbl,
                       deltimeid,
                       &timeDeleted,
                       0,
                       0,
                       NULL);

        return 0;
    }


    /* Add the when created attribute, unless it already exists */

    if (DBGetSingleValue(pDB, ATT_WHEN_CREATED, &time, sizeof(time),NULL)) {

        time = DBTime();
        DBResetAtt(pDB, ATT_WHEN_CREATED, sizeof(time),
                   &time, SYNTAX_TIME_TYPE);
    }

    /* Add the usn created attribute */

    DBResetAtt(pDB, ATT_USN_CREATED, sizeof(usn), &usn, SYNTAX_I8_TYPE);

    if (fFlags & DBREPL_fROOT)
        return(WriteRoot(pDB));

    /* Update OBJ flag to indicate that object portion exists */

    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, objid, &objval,
                   sizeof(objval), 0, NULL);

    // Update del time field to be missing. It could have been set
    // by promoting a non-object to an object

    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, deltimeid, &timeDeleted, 0,
                   0, NULL);
    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, dntid,
                             &(pDB->DNT), sizeof(pDB->DNT), &actuallen,
                             pDB->JetRetrieveBits, NULL);

    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, ncdntid, &pDB->NCDNT,
                   sizeof(pDB->NCDNT), 0, NULL);

    pDB->JetNewRec = FALSE;
    return 0;
}

void
dbSetIsVisibleInAB(
        DBPOS *pDB,
        BOOL bCurrentVisibility
        )
/*++

  Description:
    Helper routine to DBRepl.  Sets ATT_SHOW_IN_ADDRESS_BOOK appropriately and
    tracks the abcnt refcount.

  Parameters:
    bCurrentVisibility: current value of ATT_SHOW_IN_ADDRESS_BOOK on object.

  Return Values:
    None.
    Raises exception on error

--*/
{
    THSTATE            *pTHS = pDB->pTHS;
    DWORD               index, cOrigShowIn;
    BYTE                bVisible = 1;
    JET_RETRIEVECOLUMN  InputCol;
    JET_RETRIEVECOLUMN *pOutCols = NULL;
    DWORD               cNewShowIn;

    if(DBIsObjDeleted(pDB) || !FObjHasDisplayName(pDB)) {
        if(bCurrentVisibility) {
            // Object was visible, but it is now invisible. Set the value of
            // IsVisibleInAB to NULL
            JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl,
                           IsVisibleInABid, NULL, 0,
                           0, NULL);

            if(gfDoingABRef) {
                // We are tracking the show-in values as refcounts.  Decrement
                // the count of objects in the AB containers that it was
                // originally in.

                // Read the values of ATT_SHOW_IN_ADDRESS_BOOK from the original
                memset(&InputCol, 0, sizeof(InputCol));
                cOrigShowIn = 0;
                InputCol.columnid = ShowInid;
                dbGetMultipleColumns(pDB,
                                     &pOutCols,
                                     &cOrigShowIn,
                                     &InputCol,
                                     1,
                                     TRUE,
                                     TRUE);
                for(index=0;index<cOrigShowIn;index++) {
                    // Raises exception on error
                    DBAdjustABRefCount(pDB,
                                       *((DWORD *)(pOutCols[index].pvData)),
                                       -1);

                    THFreeEx(pTHS, pOutCols[index].pvData);
                }
                THFreeEx(pTHS, pOutCols);
            }
        }
    }
    else {
        // Object is now visible.
        if(!bCurrentVisibility) {
            // This object went from invisible to visible.  Set the new
            // value of the IsVisible column

            JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, IsVisibleInABid,
                           &bVisible, sizeof(bVisible), 0, NULL);

            if(gfDoingABRef) {
                // We are tracking the show-in values as refcounts.  Increment
                // the count of objects in the AB containers that it is now in.


                // Read the values of ATT_SHOW_IN_ADDRESS_BOOK from the copy
                memset(&InputCol, 0, sizeof(InputCol));
                cNewShowIn = 0;
                InputCol.columnid = ShowInid;
                dbGetMultipleColumns(pDB,
                                     &pOutCols,
                                     &cNewShowIn,
                                     &InputCol,
                                     1,
                                     TRUE,
                                     FALSE);
                for(index=0;index<cNewShowIn;index++) {
                    // Raises exception on error
                    DBAdjustABRefCount(pDB,
                                       *((DWORD *)(pOutCols[index].pvData)),
                                       1);
                    THFreeEx(pTHS, pOutCols[index].pvData);
                }
                THFreeEx(pTHS, pOutCols);
            }
        }
        else {
            // Was visible, is still visible.
            if(gfDoingABRef &&
               dbIsModifiedInMetaData(pDB, ATT_SHOW_IN_ADDRESS_BOOK)) {
                // However, the metadata shows that some changed happened to
                // the list of AB containers.  We need to decrement the count in
                // the containers it used to be in and increment in the
                // containers it now is in. We can achieve this by decrementing
                // the count of objects in the AB containers we used to be in
                // and incrementing the count in the containers we are now in.

                memset(&InputCol, 0, sizeof(InputCol));
                cNewShowIn = 0;
                InputCol.columnid = ShowInid;
                dbGetMultipleColumns(pDB,
                                     &pOutCols,
                                     &cNewShowIn,
                                     &InputCol,
                                     1,
                                     TRUE,
                                     FALSE);
                for(index=0;index<cNewShowIn;index++) {
                    // Raises exception on error
                    DBAdjustABRefCount(pDB,
                                       *((DWORD *)(pOutCols[index].pvData)),
                                       1);
                    THFreeEx(pTHS, pOutCols[index].pvData);
                }
                THFreeEx(pTHS, pOutCols);

                // Read the values of ATT_SHOW_IN_ADDRESS_BOOK from the original
                memset(&InputCol, 0, sizeof(InputCol));
                cOrigShowIn = 0;
                InputCol.columnid = ShowInid;
                dbGetMultipleColumns(pDB,
                                     &pOutCols,
                                     &cOrigShowIn,
                                     &InputCol,
                                     1,
                                     TRUE,
                                     TRUE);
                for(index=0;index<cOrigShowIn;index++) {
                    // Raises exception on error
                    DBAdjustABRefCount(pDB,
                                       *((DWORD *)(pOutCols[index].pvData)),
                                       -1);
                    THFreeEx(pTHS, pOutCols[index].pvData);
                }
                THFreeEx(pTHS, pOutCols);
            }
        }
    }

    return;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add or modify an object in the database.
*/
DWORD APIENTRY
DBRepl(DBPOS FAR *pDB, BOOL fDRA, DWORD fAddFlags,
       PROPERTY_META_DATA_VECTOR *pMetaDataVecRemote,
       DWORD dwMetaDataFlags)
{
    THSTATE  *pTHS=pDB->pTHS;
    USN    usn;
    ULONG len;
    JET_ERR err;
    DWORD pdnt, ncdnt, it;
    BYTE   bCurrentVisibility;
    JET_RETRIEVECOLUMN jCol[4];
    DWORD *pAncestors, cAncestors, cbAncestorsBuff;

    memset(jCol, 0, sizeof(jCol));
    DPRINT1(1, "DBRepl begin DNT:%ld\n", (pDB)->DNT);

    Assert(VALID_DBPOS(pDB));

    dbInitRec(pDB);

    // Retrieve the local USN to stamp on changed properties.
    usn = DBGetNewUsn();

    if ((fAddFlags & DBREPL_fADD) ||
        (fAddFlags & DBREPL_fROOT) ||
        (fAddFlags & DBREPL_fRESET_DEL_TIME))
    {
        err = dbReplAdd(pDB, usn, fAddFlags);
        if ((fAddFlags & DBREPL_fROOT) || err)
          return err;
    }

    memset(jCol, 0, sizeof(jCol));
    // get some info about this object - it'll be used in several places later
    jCol[0].columnid = pdntid;
    jCol[0].pvData = &pdnt;
    jCol[0].cbData = sizeof(pdnt);
    jCol[0].cbActual = sizeof(pdnt);
    jCol[0].grbit = pDB->JetRetrieveBits;
    jCol[0].itagSequence = 1;

    jCol[1].columnid = ncdntid;
    jCol[1].pvData = &ncdnt;
    jCol[1].cbData = sizeof(ncdnt);
    jCol[1].cbActual = sizeof(ncdnt);
    jCol[1].grbit = pDB->JetRetrieveBits;
    jCol[1].itagSequence = 1;

    jCol[2].columnid = insttypeid;
    jCol[2].pvData = &it;
    jCol[2].cbData = sizeof(it);
    jCol[2].cbActual = sizeof(it);
    jCol[2].grbit = pDB->JetRetrieveBits;
    jCol[2].itagSequence = 1;

    jCol[3].columnid = IsVisibleInABid;
    jCol[3].pvData = &bCurrentVisibility;
    jCol[3].cbData = sizeof(bCurrentVisibility);
    jCol[3].cbActual = sizeof(bCurrentVisibility);
    jCol[3].grbit = pDB->JetRetrieveBits;
    jCol[3].itagSequence = 1;

    JetRetrieveColumnsWarnings(pDB->JetSessID,
                               pDB->JetObjTbl,
                               jCol,
                               4);

    Assert(jCol[0].err == JET_errSuccess);

    // Determine the NCDNT of the object, remembering that NC_HEAD objects
    // are marked with their parent's NCDNT, which we don't want.
    if (jCol[2].err) {
        ncdnt = 0;
    }
    else if (it & IT_NC_HEAD) {
        ncdnt = pdnt;
    }

    // Use the current AB visibility status for computing the delta to
    // address book indices.

    switch (jCol[3].err)
    {
        case JET_errSuccess:
            break;

        case JET_wrnColumnNull:
            bCurrentVisibility = 0;
            break;

        default:
            DsaExcept(DSA_DB_EXCEPTION, jCol[3].err, 0);
    }

    // set the IsVisibleInAB field based if the object is not hidden and
    // not deleted

    dbSetIsVisibleInAB(pDB, bCurrentVisibility);

    // Update per-property meta data for all modified properties and merge
    // the replicated meta data (if any).  Writes updated meta data vector,
    // object changed time, and object changed USN to the record.
    dbFlushMetaDataVector(pDB, usn, pMetaDataVecRemote, dwMetaDataFlags);

    /* Update the permanent record from the copy buffer */

    DBUpdateRec(pDB);

    // Now that we're not insude the JetPrepareUpdate we can feel safe
    // to go and fetch the ancestors, confident that all our support
    // routines will work. (Prior to this point the record we're reading
    // is unseekable.)

    cbAncestorsBuff = sizeof(DWORD) * 12;
    pAncestors = THAllocEx(pDB->pTHS, cbAncestorsBuff);
    DBGetAncestors(pDB,
                   &cbAncestorsBuff,
                   &pAncestors,
                   &cAncestors);

    // Unless we have been told not to awaken waiters, update the list of
    // modified DNTs and their PDNTs on the DBPos structure

    dbTrackModifiedDNTsForTransaction(pDB,
                                      ncdnt,
                                      cAncestors,
                                      pAncestors,
                                      !(fAddFlags & DBREPL_fKEEP_WAIT),
                                      MODIFIED_OBJ_modified);

    // NOTE: We are no longer are in a JetPrepareUpdate
    // ...and therefore have lost currency if we just inserted a new record.

    DBFindDNT(pDB, (pDB)->DNT);

    return 0;
}                       /*DBRepl*/

//
// DBGetNewUsn
//
// Gets the next usn within a mutex. If we are up to the usn on disk
// in the hidden record, increment the disk usn and rewrite it.
#if defined(_M_IA64)
#if _MSC_FULL_VER== 13008973
#pragma optimize("", off)
#endif
#endif
USN DBGetNewUsn (void)

{
    USN usn;

    EnterCriticalSection (&csUncUsn);
    Assert(gusnEC <= gusnInit);
    __try  {

        // Increment the USN and if we're up to the usn on disk, increment
        // the master usn and update the disk copy.

        usn = gusnEC;

        // We have allocated a usn that has not yet been committed, keep
        // track of this.

        AddUncUsn (usn);
        if (usn+1 > gusnInit) {
            DBReplaceHiddenUSN(gusnInit + USN_DELTA_INIT);

            // Note that we increment the global here -- after the hidden table
            // has been updated, if need be -- such that DBGetNewUsn() will not
            // cause gusnInit to go out of its valid range if the hidden table
            // update fails.
            gusnInit += USN_DELTA_INIT;
        }

        // Note that we increment the global here -- after the hidden table has
        // been updated, if need be -- such that DBGetNewUsn() will not cause
        // gusnEC to go out of its valid range if the hidden table update fails.
        gusnEC++;

        // update perfmon counters
        ISET(pcHighestUsnIssuedLo, LODWORD(usn));
        ISET(pcHighestUsnIssuedHi, HIDWORD(usn));
    } __finally {
        LeaveCriticalSection (&csUncUsn);
    }
    return usn;
}
#if defined( _M_IA64)
#if _MSC_FULL_VER== 13008973
#pragma optimize("", on)
#endif
#endif

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* If the root already exists, return error.  Else copy the new record to
   the update buffer for the root record, and update it.
*/
DWORD
WriteRoot(DBPOS FAR *pDB)
{
    THSTATE     *pTHS=pDB->pTHS;
    JET_ERR      err;
    ULONG        tag = ROOTTAG;
    JET_RETINFO  retinfo;
    JET_SETINFO  setinfo;
    char         CurObjVal;
    char         *buf;
    ULONG        cbBuf;
    ULONG        actuallen;
    char         objval = 1;
    ULONG        CurrRecOccur;

    Assert(VALID_DBPOS(pDB));

    /* Position SearchTbl on the root record */

    DPRINT(2, "WriteRoot entered\n");
    JetSetCurrentIndexSuccess(pDB->JetSessID, pDB->JetSearchTbl, SZDNTINDEX);
    JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl, &tag, sizeof(tag), JET_bitNewKey);

    if (err = JetSeekEx(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekEQ))
    {
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
    }

    JetPrepareUpdateEx(pDB->JetSessID, pDB->JetSearchTbl, DS_JET_PREPARE_FOR_REPLACE);
    /* Get the OBJ flag. If its set, the root exists and the new record is bogus */

    if (JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetSearchTbl, objid, &CurObjVal,
        sizeof(CurObjVal), &actuallen, JET_bitRetrieveCopy,
        NULL) == JET_errSuccess)
    {
        if (CurObjVal)
        {
            DPRINT(1, "WriteRoot: Root exists\n");
            return DB_ERR_DATABASE_ERROR;
        }
    }

    /* Copy new rec attributes from ObjTbl to SearchTbl */

    CurrRecOccur = 1;
    retinfo.cbStruct = sizeof(retinfo);
    retinfo.ibLongValue = 0;
    retinfo.itagSequence = CurrRecOccur;
    retinfo.columnidNextTagged = 0;
    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = 0;
    setinfo.itagSequence = 0;    // New tag value

    cbBuf = DB_INITIAL_BUF_SIZE;
    buf = dbAlloc(cbBuf);

    while (((err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetObjTbl, 0, buf, cbBuf,
        &actuallen, pDB->JetRetrieveBits, &retinfo)) == JET_errSuccess) ||
                                        (err == JET_wrnBufferTruncated))
    {
        if (err == JET_errSuccess)
        {
            JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl,
                retinfo.columnidNextTagged, buf, actuallen, 0, &setinfo);

            retinfo.itagSequence = ++CurrRecOccur;
            retinfo.columnidNextTagged = 0;
        }
        else
        {
            cbBuf = actuallen;
            dbFree(buf);
            buf = dbAlloc(cbBuf);
        }
    }
    dbFree(buf);

    DBCancelRec(pDB);

    /* Update OBJ flag to indicate that root exists */

    JetSetColumn(pDB->JetSessID, pDB->JetSearchTbl, objid, &objval, sizeof(objval), 0, NULL);

    JetUpdateEx(pDB->JetSessID, pDB->JetSearchTbl, NULL, 0, 0);

    DBFindDNT(pDB, ROOTTAG);

    return 0;
}

VOID
DBResetAtt (
        DBPOS FAR *pDB,
        ATTRTYP type,
        ULONG len,
        void *pVal,
        UCHAR syntax
        )
/*++
Routine Description:
    Replace an existing attribute with a new value.

Arguments:
    pDB        - DBPOS to use.
    type       - Attribute to replace.
    len        - length of new value.
    pVal       - pointer to new value.
    syntax     - syntax of Attribute.

Return Values:
    None.  Suceeds or throws an exception.

--*/
{
    JET_SETINFO  setinfo;
    JET_COLUMNID colID;
    ATTCACHE * pAC = NULL;
    JET_GRBIT grbit = 0;

    Assert(VALID_DBPOS(pDB));

    dbInitRec(pDB);

    // Ensure that this is a valid attribute

    switch(type) {
    case FIXED_ATT_ANCESTORS:
        colID = ancestorsid;
        // This messes with cached info.  flush the dnread cache
        dbFlushDNReadCache(pDB, pDB->DNT);
        break;
    case FIXED_ATT_NCDNT:
        colID = ncdntid;
        // This messes with cached info.  flush the dnread cache
        dbFlushDNReadCache(pDB, pDB->DNT);
        break;
    default:
        if(!(pAC = SCGetAttById(pDB->pTHS, type))) {
            DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, 0);
        }
        if (dbNeedToFlushDNCacheOnUpdate(pAC->id)) {
            // This messes with cached info.  flush the dnread cache
            dbFlushDNReadCache(pDB, pDB->DNT);
        }
        colID = pAC->jColid;
        break;
    }

    if (SYNTAX_OCTET_STRING_TYPE == syntax)
    {
        // we are writing a binary blob;
        // set the appropriate grbits so that the blob is
        // overwritten on the current value instead of the
        // default behavior of jet (which is to delete, and insert
        // the new binary value). Overwriting would also cause jet
        // to write out only the diff into the log instead of writing
        // the entire binary values.
        grbit = JET_bitSetOverwriteLV | JET_bitSetSizeLV;
    }

    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = 0;
    setinfo.itagSequence = 1;

    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, colID,
                   pVal, len, grbit, &setinfo);

    if (NULL != pAC) {
        // Is not a fixed attribute; touch its replication meta data.
        // DBTouchMetaData succeeds or excepts.
        DBTouchMetaData(pDB, pAC);
    }

    // If code is added to call this function for any of the following
    // attributes, we'll need to conditionally force a flush of this DNT from
    // the read cache on update (i.e., set pDB->fFlushCacheOnUpdate = TRUE).
    Assert((rdnid != colID) && (sidid != colID) && (guidid != colID));

    return;

}/*DBResetAtt*/


// Overwrite only a portion of the given long valued attribute and thus
// optimize the Jet write
DWORD
DBResetAttLVOptimized (
    DBPOS FAR *pDB,
    ATTRTYP type,
    ULONG ulOffset,
    ULONG lenSegment,
    void *pValSegment,
    UCHAR syntax
    )
{
    JET_SETINFO  setinfo;
    JET_COLUMNID colID;
    ATTCACHE * pAC = NULL;

    Assert(VALID_DBPOS(pDB));
    Assert(SYNTAX_OCTET_STRING_TYPE == syntax);

    dbInitRec(pDB);

    // Ensure that this is a valid attribute
    if(!(pAC = SCGetAttById(pDB->pTHS, type))) {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, 0);
    }
    colID = pAC->jColid;

    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = ulOffset;
    setinfo.itagSequence = 1;

    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, colID,
                   pValSegment, lenSegment, JET_bitSetOverwriteLV, &setinfo);

    // touch its replication meta data (this is a no-op for
    // ATT_REPL_PROPERTY_META_DATA, but needed if others start using
    // DBResetAttLVOptimized()
    DBTouchMetaData(pDB, pAC);

    return 0;

}/*DBResetAttLVOptimized*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Determine if the object has a display name*/
BOOL
FObjHasDisplayName(DBPOS *pDB)
{
    Assert(VALID_DBPOS(pDB));

    if (!DBHasValues(pDB, ATT_DISPLAY_NAME))
      return FALSE;

   return TRUE;

}/*FObjHasDisplayName*/



DB_CHECK_ACTION
DBCheckToGarbageCollect(
    DBPOS *pDBold,
    ATTCACHE *pAC
    )

    /* we check to see if this object has any children that are real objects.
     * if it has children that are real objects (and they are in the same NC)
     *   we advance the deltime to that of the child + 1, so as to first
     *   delete the children and then the parent. The time is only adjusted
     *   if pAC is not set. If pAC is set, then we aren't sure if the
     *   time can be adjusted. Eg, if pAC is for EntryTTL then the time
     *   cannot be adjusted because that would break the RFC.
     *   In this case it returns FALSE
     *
     * if it doesn't have children or the children are from another NC,
     *   we can safely delete the object.
     *   in this case it returns TRUE
     *
     * The operations in this function are done in a separate transaction
     * as a result we don't move the cursor
     *
     */
{
    DB_CHECK_ACTION action = DB_CHECK_DELETE_OBJECT; // assume success
    BOOL updateObject = FALSE;

    INDEX_VALUE  IV[1];
    DWORD  ParentDNT;
    ULONG  actuallen;
    DSTIME child_deltime;
    DSTIME deltime;
    DWORD  it;
    DWORD  err;
    ULONG  dwException, ulErrorCode, dsid;
    PVOID  dwEA;
    DBPOS *pDB;
    DWORD  fCommit = FALSE;
    JET_COLUMNID jDelColid;

    #if DBG
    PDSNAME parentName, childName;
    #endif


     __try {
        // If no attribute is specified, use the fixed index deltimeid (whenDeleted)
        jDelColid = (pAC) ? pAC->jColid : deltimeid;
        DBOpen2 (FALSE, &pDB);
        __try {

            ParentDNT = pDBold->DNT;
            IV[0].pvData = &ParentDNT;
            IV[0].cbData = sizeof(ParentDNT);

            // position to node
            DBFindDNT(pDB, ParentDNT);


            /* Retrieve DEL time from parent record */
            err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetObjTbl,
                        jDelColid, &deltime, sizeof(deltime), &actuallen,
                        0, NULL);

            if (err) {
                // Do not delete
                action = DB_CHECK_ERROR;
                _leave;
            }

            #if DBG
            parentName = DBGetCurrentDSName(pDB);

            DPRINT3(3, "DBCheckToGarbageCollect: Parent: DNT(%x) %ws Deltime: %I64x\n",
                            ParentDNT, parentName->StringName, deltime);
            THFree (parentName);
            #endif


            // Set to the PDNT index
            JetSetCurrentIndexSuccess(pDB->JetSessID, pDB->JetObjTbl, SZPDNTINDEX);

            // Now, set an index range in the PDNT index to get all the children.
            // Use GE because this is a compound index.
            err = DBSeek(pDB, IV, 1, DB_SeekGE);


            if((!err || err == JET_wrnSeekNotEqual) && (pDB->PDNT == ParentDNT)) {
                // OK, we're GE. Set an indexRange.

                err = DBSetIndexRange(pDB, IV, 1);

                // Now, walk the index.
                while(!err) {
                    // First, see if this is a real object

                    if (DBCheckObj(pDB)) {
                        // Yep, it's a real object.

                        #if DBG
                        childName = DBGetCurrentDSName(pDB);
                        DPRINT2 (3, "DBCheckToGarbageCollect: Child DNT(%x) %ws\n",
                                            pDB->DNT, childName->StringName );
                        THFree (childName);
                        #endif

                        // Get the instance type
                        err = DBGetSingleValue(pDB,
                                           ATT_INSTANCE_TYPE,
                                           &it,
                                           sizeof(it),
                                           NULL);


                        // found child that is on the same NC, so we try to find the
                        // maximum deltime so as to change this object's deltime
                        // and then we skip deletion of this object
                        if (! (it & IT_NC_HEAD)) {

                            // parent has children, don't garbage collect
                            action = DB_CHECK_HAS_DELETED_CHILDREN;

                            /* Retrieve DEL time from child record */
                            err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                                           pDB->JetObjTbl,
                                                           jDelColid,
                                                           &child_deltime,
                                                           sizeof(child_deltime),
                                                           &actuallen,
                                                           0,
                                                           NULL);

                            // the child object does not have a deltime,
                            // so we should not garbagecollect the parent
                            if (err) {
                                action = DB_CHECK_LIVE_CHILD;
                                __leave;
                            }

                            // child's time is greater than parent's time; adjust
                            if (child_deltime >= deltime) {
                                updateObject = TRUE;
                                // set parent's time to > child's time
                                deltime = child_deltime + 1;
                                // we are ok if we find at least one
                                break;
                            }
                        }
                    }
                    err = DBMove(pDB, FALSE, DB_MoveNext);
                }
            }


            // reset delete time
            if (updateObject) {
                JET_SETINFO setinfo;

                // restore currency to parent object
                DBFindDNT(pDB, ParentDNT);

                DPRINT1(2, "DBCheckToGarbageCollect: skipping deletion of DNT: %x\n", ParentDNT);

                // Set Del time index field & update record
                setinfo.cbStruct = sizeof(setinfo);
                setinfo.ibLongValue = 0;
                setinfo.itagSequence = 1;

                JetPrepareUpdate(pDB->JetSessID, pDB->JetObjTbl, JET_prepReplace);
                JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, jDelColid,
                           &deltime, sizeof(deltime), 0, &setinfo);
                JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);

                fCommit = TRUE;
            }
        }
        __finally {
            DBClose(pDB, fCommit);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(),
                                        &dwException,
                                        &dwEA,
                                        &ulErrorCode,
                                        &dsid)) {

          DPRINT1 (0, "DBCheckToGarbageCollect: Exception: %d\n", ulErrorCode);

          // Do not delete
          action = DB_CHECK_ERROR;
    }

    return action;
}



/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Physically delete an object
 *
 * if fGarbCollectASAP is TRUE,
 *     the object is garbage collected ASAP.
 *     most of the other attributes, EXCLUDING backlinks are stripped.
 *
 * if fGarbCollectASAP is FALSE,
 *     the object is garbage collected if it has no children, or
 *     the children are not real objects
 *
 * pACDel is the index being scanned. Eg, msDS-Entry-Time-To-Die
 *
 *  Returns
 *        ERROR_SUCCESS            - Object was deleted, demoted or skipped
 *        ERROR_DS_CANT_DELETE     - Object could not be deleted
 *        ERROR_DS_CHILDREN_EXIST  - At least one live child exists
 *        <other non-zero error>   - Exception was raised
 *
*/
extern DWORD APIENTRY
DBPhysDel(
    DBPOS FAR   *pDB,
    BOOL        fGarbCollectASAP,
    ATTCACHE    *pACDel
    )
{
    long      actuallen;
    ULONG     cnt;
    char      objval = 0;
    BOOL      fObject;
    DWORD     dwStatus = ERROR_SUCCESS;
    DWORD     dwException;
    ULONG     ulErrorCode;
    ULONG     dsid;
    PVOID     dwEA;
    ATTR      *pAttr;
    ULONG     attrCount,i,j, err;
    JET_SETINFO setinfo;
    BYTE bClean;
    DB_CHECK_ACTION action;

    Assert(VALID_DBPOS(pDB));

    __try {
        /* Retrieve count from record */

        DPRINT1(4, "DBPhysDel entered DNT:%ld\n", (pDB)->DNT);

        fObject = DBCheckObj(pDB);

        DBCancelRec(pDB);


        /* we treat objects and non objects differently: If a record is an
         * object we remove all its attributes to free references to other
         * objects.  We then check the object's reference count and if it's
         * still greater than 1, we mark this as a non-object and return.
         * If the record was a non-object to begin with we just test the
         * reference count and if it's still greater than 1 we just return.
         * In both cases, if the reference count is zero we physically
         * delete the record.
         */

        if (fObject) {

            // if this object has children that are real objects and
            // their time of deletion is
            // in the future (regarding the parent), we are not going to
            // delete this object, but we are going to change the deletion time
            // of this object.

            if ( (fGarbCollectASAP == FALSE) &&
                 ((action = DBCheckToGarbageCollect (pDB, pACDel)) != DB_CHECK_DELETE_OBJECT) ) {

                PDSNAME pDelObj = DBGetCurrentDSName(pDB);

                LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                         DS_EVENT_SEV_BASIC,
                         DIRLOG_GC_FAILED_TO_REMOVE_OBJECT,
                         szInsertDN( pDelObj ),
                         szInsertInt(ERROR_DS_CHILDREN_EXIST),
                         szInsertHex(DSID(FILENO, __LINE__)));

                THFree (pDelObj);

                switch (action) {
                case DB_CHECK_LIVE_CHILD:
                    // Return a special indication to the caller
                    dwStatus = ERROR_DS_CHILDREN_EXIST;
                    break;
                default:
                    // An error occurred during the check, or deleted children
                    // were found, adjusting the object's deletion time.
                    // Skip this object and return success
                    Assert( dwStatus == ERROR_SUCCESS );
                    break;
                }

                // and bail out
                goto ExitTry;
            }

            /*
             * Loop through all attributes , releasing any references to other
             * objects.  This code parallels similar code in mddel.c:SetDelAtt
             * which treats linked attributes as special and removes them at the
             * end.
             */

            dbInitRec(pDB);

            DBGetMultipleAtts(pDB, 0,NULL, NULL, NULL, &attrCount, &pAttr, 0, 0);
            for(i=0;i<attrCount;i++) {
                ATTCACHE *pAC = NULL;

                pAC = SCGetAttById(pDB->pTHS, pAttr[i].attrTyp);

                // We leave the USN_CHANGED on the object because we use this
                // attribute later in the code that updates stale phantoms, and
                // this deletion may be making a phantom.

                switch(pAttr[i].attrTyp) {
                case ATT_RDN:
                case ATT_OBJECT_GUID:
                case ATT_USN_CHANGED:
                case ATT_OBJECT_SID:
                    // These have no extra work to do, we never remove them
                    // here.
                    break;
                // Now a few attrs which we want to be very explicit about
                // removing so no one is in doubt.
                case ATT_PROXIED_OBJECT_NAME:           // for cross dom move
                    DBRemAtt(pDB, pAttr[i].attrTyp);
                    break;
                default:
                    if (!pAC || (pAC->ulLinkID == 0)) {
                        // not a special attribute, not a link. kill it.
                        if (!pACDel || (pACDel != pAC)) {
                            // not the index being garbage collected. kill it.
                            DBRemAtt(pDB, pAttr[i].attrTyp);
                        }
                    }
                    break;
                }
                // Free at least some of what we allocated...
                for (j=0; j<pAttr[i].AttrVal.valCount; j++) {
                    THFreeEx(pDB->pTHS, pAttr[i].AttrVal.pAVal[j].pVal);
                }
                THFreeEx(pDB->pTHS, pAttr[i].AttrVal.pAVal);
            }
            THFreeEx(pDB->pTHS, pAttr);


            // Physically delete forward links. Not backlinks. See below.
            // Removing all forward links in one pass should make the loop below
            // faster.  Also, when operating in the new linked value mode, the
            // DBRemAtt call would not actually remove links, only marks them.

            // Don't remove backlinks; treat them just like non-link
            // references from other objects.  If this object was deleted
            // by a user, backlinks have already been removed by SetDelAtt()
            // in LocalRemove().  Otherwise, we're removing this object
            // as a part of tearing down a read-only NC, in which case we
            // don't want to delete forward links to this object from
            // objects in other NCs.

            // N.B. PhantomizeObject depends on the !FIsBacklink
            // behavior and the fact that reference count changes
            // aren't visible until the transaction goes back to level
            // zero.  I.e. We expect that no object on whom DBPhysDel
            // is called will immediately be nuked (even if it has
            // no references and ATT_OBJ_DIST_NAME is removed in
            // this loop) because the later "if (cnt)" test will always
            // evaluate to TRUE.

            dbRemoveAllLinks( pDB, (pDB->DNT), FALSE /* use forward link */ );

            // The backlinks have not been removed because the caller
            // is garbage collecting expired dynamic objects (entryTTL == 0).
            // Remove them now.
            if (pACDel && pACDel->id == ATT_MS_DS_ENTRY_TIME_TO_DIE) {
                dbRemoveAllLinks( pDB, (pDB->DNT), TRUE /* use back link */ );
            }

            /*
             * If this object still has references we're not going to
             * physically delete it but at least we stripped its attributes
             * and we're going to mark it as a non-object.
             */

            memset(&setinfo, 0, sizeof(setinfo));
            setinfo.cbStruct = sizeof(setinfo);
            setinfo.itagSequence = 1;

            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, cntid,
                                     &cnt, sizeof(cnt), &actuallen,
                                     pDB->JetRetrieveBits, NULL);

            if (cnt)  {
                JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, ncdntid,
                               NULL, 0, 0, &setinfo);

                JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, objid,
                               &objval, sizeof(objval), 0, NULL);

                // Flush entry out of the read cache, since we changed its
                // object flag.
                pDB->fFlushCacheOnUpdate = TRUE;

                DBUpdateRec(pDB);

                goto ExitTry;
            }
        }
        else {
            /* not an object */
            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, cntid,
                                     &cnt, sizeof(cnt), &actuallen,
                                     pDB->JetRetrieveBits, NULL);

            if (cnt) {
                // The caller is garbage collecting objects by scanning
                // an index that was created by adding an indexed attribute
                // to the schema. Unfortunately, an index created in this
                // way isn't guaranteed to have unique entries. Tell the
                // caller that this entry should be "skipped" because
                // repeated calls to DBPhysDel will not succeed in
                // removing the object at this time.
                if (pACDel) {
                    dwStatus = ERROR_DS_CANT_DELETE;
                }
                /* still has references */
                goto ExitTry;
            }
        }

#if DBG
        // Sanity check.
        err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetObjTbl,
                                        cleanid, &bClean, sizeof(bClean),
                                        &actuallen,pDB->JetRetrieveBits,NULL);
        // The cleaning column must be NULL or present == 0
        Assert( err || (!bClean) );
#endif
        /* Delete record. */

        DPRINT1(2, "DBPhysDel: removing DNT:%ld\n", (pDB)->DNT);

        // Clear pDB->JetRetrieveBits as a side effect of even a failed
        // JetDelete is to cancel a prepared update.

        pDB->JetRetrieveBits = 0;
        JetDeleteEx(pDB->JetSessID, pDB->JetObjTbl);

        // Flush entry out of the read cache.
        dbFlushDNReadCache( pDB, pDB->DNT );

        /* if parent is not root, decrement its reference count */

        if ((pDB)->PDNT != ROOTTAG) {
            DBAdjustRefCount(pDB, pDB->PDNT, -1);
        }
      ExitTry:
        ;
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        DBCancelRec(pDB);
        Assert(ulErrorCode);
        dwStatus = ERROR_DS_CANT_DELETE;
    }

    Assert(0 == pDB->JetRetrieveBits);
    return dwStatus;
}/*DBPhysDel*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Returns name of next entry in deletion index. Search status is kept in
   *pulLastTime and *pulTag. We use the DELINDEX to position and read the
   next record in sequence. The index is sorted by deletion time in ascending
   order and tag in descending order. This insures that when staring with
   a key of {0,0}, the first value retrieved will have at deletion time > 0,
   and also that children are generally returned before their parents.
*/

DWORD DBGetNextDelRecord(DBPOS FAR *pDB, DSTIME ageOutDate, DSNAME **ppRetBuf,
                         DSTIME *pulLastTime, ULONG *pulTag,
                         BOOL *pfObject)
{
    JET_ERR  err;
    ULONG    actuallen;
    DSTIME   time, newDeltime = DBTime();
    BOOL     HasDeleted;
    BOOL     Deleted;
    DWORD    RefCount;
    DSNAME  *pDNTmp = NULL;
    JET_SETINFO setinfo;

    DPRINT1( 2, "DBGetNextDelRec entered: ageOutDate [0x%I64x]\n", ageOutDate );
    Assert(VALID_DBPOS(pDB));
    Assert(0 == pDB->JetRetrieveBits);

    DBSetCurrentIndex(pDB, Idx_Del, NULL, FALSE);


    // Phantoms are created with a delete time set and they do not have
    // a ref-count for themselves - see comments in sbTableAddRefHelp().
    // So we need to iterate over the index and return only those items
    // which either have ATT_IS_DELETED set (real object case) or don't
    // have an ATT_IS_DELETED property and a ref count of 0 (phantom case).
    // We can't do this test in Garb_Collect() as it is above the dblayer
    // and the cnt_col is not visible.

    while ( TRUE )
    {
        JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl,
                    pulLastTime, sizeof(*pulLastTime),
                    JET_bitNewKey);
        JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl,
                    pulTag, sizeof(*pulTag),
                    0);

        if ((err = JetSeekEx(pDB->JetSessID, pDB->JetObjTbl,
                    JET_bitSeekGT))         != JET_errSuccess)
        {
            DPRINT(5, "GetNextDelRecord search complete");
            return DB_ERR_NO_MORE_DEL_RECORD;
        }

        /* Retrieve DEL time from record */

        JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl,
                    deltimeid, &time, sizeof(time), &actuallen,
                    0, NULL);

        /* if time greater than target, there are no more eligible records */

        if (time > ageOutDate)
        {
            DPRINT(5, "GetNextDelRecord search complete");
            return DB_ERR_NO_MORE_DEL_RECORD;
        }

        *pulLastTime = time;

        /* Get the name */

        JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, dntid,
                    &(pDB)->DNT, sizeof((pDB)->DNT),
                    &actuallen, 0, NULL);

        *pulTag = pDB->DNT;

        if (sbTableGetDSName(pDB, (pDB)->DNT, &pDNTmp,0)) {
            DPRINT( 1, "DBGetNextDelRecord: Failed looking up DN name.\n" );
            return  DB_ERR_DSNAME_LOOKUP_FAILED;
        }

        /* Get the parent since we will need to de-ref it later */

        JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, pdntid,
                    &(pDB)->PDNT, sizeof((pDB)->PDNT),
                    &actuallen, 0, NULL);

        // Check real object and phantom conditions.

        err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetObjTbl,
                   isdeletedid, &Deleted, sizeof(Deleted), &actuallen, 0, NULL);

        if (!err) {
            HasDeleted = TRUE;
        }
        else {
            // Record has deletion time but no "is deleted" attribute -- it must
            // be a phantom.
            Assert(JET_wrnColumnNull == err);
            HasDeleted = FALSE;
        }

        if ( HasDeleted )
        {
            if ( !Deleted )
            {
                DPRINT1(0,"Yikes! Tried to physically remove live object %ws\n",
                        pDNTmp->StringName);
                goto TryAgain;
            }
            else
            {
                DPRINT1(2,"Real object garbage candidate %ws\n",
                        pDNTmp->StringName);
            }
        }
        else
        {
            // Assume it's a phantom.
            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, cntid,
                        &RefCount, sizeof(RefCount),
                        &actuallen, 0, NULL);

            if ( 0 != RefCount )
            {
                // Skip phantoms which are still in use.
                DPRINT1(2,"Skipping in-use phantom %ws\n",
                        pDNTmp->StringName);

                // But first modify their delete times to current time so that
                // they would not be looked at again during this tombstone
                // lifetime by the garbage collector

                setinfo.cbStruct = sizeof(setinfo);
                setinfo.ibLongValue = 0;
                setinfo.itagSequence = 1;

                JetPrepareUpdate(pDB->JetSessID, pDB->JetObjTbl, JET_prepReplace);
                JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, deltimeid,
                               &newDeltime, sizeof(newDeltime), 0, &setinfo);
                JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);

                // We don't commit here, it will be committed by the
                // calling function (Garb_Collect)

                // go to the next entry
                goto TryAgain;
            }
            else
            {
                DPRINT1(2,"Phantom garbage candidate %ws\n",
                        pDNTmp->StringName);
            }
        }

        pDB->JetNewRec = FALSE;
        pDB->fFlushCacheOnUpdate = FALSE;

        *pfObject = DBCheckObj(pDB);

        DPRINT1(2, "DBGetNextDelRecord DNT to delete:%ld.\n", (pDB)->DNT);

        *ppRetBuf = pDNTmp;
        Assert(0 == pDB->JetRetrieveBits);
        return 0;

      TryAgain:
        Assert(0 == pDB->JetRetrieveBits);
        if (pDNTmp) {
            THFreeEx(pDB->pTHS, pDNTmp);
            pDNTmp = NULL;
        }
    }
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Returns next entry in ms-DS-Entry-Time-To-Die (EntryTTL) index.
   Search status is kept in *pulLastTime. The index is in ascending order.
*/

DWORD DBGetNextEntryTTLRecord(
    IN  DBPOS       *pDB,
    IN  DSTIME      ageOutDate,
    IN  ATTCACHE    *pAC,
    IN  ULONG       ulNoDelDnt,
    OUT DSNAME      **ppRetBuf,
    OUT DSTIME      *pulLastTime,
    OUT BOOL        *pfObject,
    OUT ULONG       *pulNextSecs
    )
{
    JET_ERR     err;
    ULONG       actuallen;
    DSTIME      time;
    DSNAME      *pDNTmp = NULL;
    BOOL        SkippedNoDelRecord;

    DPRINT1( 2, "DBGetNextEntryTTLRec entered: ageOutDate [0x%I64x]\n", ageOutDate );
    Assert(VALID_DBPOS(pDB));
    Assert(0 == pDB->JetRetrieveBits);

    // set index to ms-DS-Entry-Time-To-Die
    err = DBSetCurrentIndex(pDB, 0, pAC, FALSE);
    if (err) {
        DPRINT1(0, "DBSetCurrentIndex(msDS-Entry-Time-To-Die); %08x\n", err);
        return DB_ERR_NO_MORE_DEL_RECORD;
    }

    // Seek to the next (or first) record
    JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl,
                pulLastTime, sizeof(*pulLastTime), JET_bitNewKey);
    err = JetSeekEx(pDB->JetSessID, pDB->JetObjTbl, JET_bitSeekGE);
    if (err != JET_errSuccess && err != JET_wrnSeekNotEqual) {
        return DB_ERR_NO_MORE_DEL_RECORD;
    }

    //
    // If necessary, skip over an undeletable record.
    // Eg, a record may be undeletable if it has children.
    //

    SkippedNoDelRecord = (ulNoDelDnt == INVALIDDNT);
NextRecord:
    // Retrieve the time-to-die from the record
    if ((err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetObjTbl,
                                         pAC->jColid,
                                         &time, sizeof(time), &actuallen,
                                         0, NULL)) != JET_errSuccess) {
        return DB_ERR_NO_MORE_DEL_RECORD;
    }

    // Not expired; done
    if (time > ageOutDate) {
        *pulNextSecs = (ULONG)(time - ageOutDate);
        return DB_ERR_NO_MORE_DEL_RECORD;
    }

    // Get the dnt
    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, dntid,
                &(pDB)->DNT, sizeof((pDB)->DNT), &actuallen, 0, NULL);

    // If there is a record we can't delete, find it and skip it
    if (!SkippedNoDelRecord && time == *pulLastTime) {
        // Found it!
        if (ulNoDelDnt == pDB->DNT) {
            SkippedNoDelRecord = TRUE;
        }
        // Next record
        if ((err = JetMoveEx(pDB->JetSessID,
                             pDB->JetObjTbl,
                             JET_MoveNext, 0)) != JET_errSuccess) {
            return DB_ERR_NO_MORE_DEL_RECORD;
        }
        goto NextRecord;
    }

    //
    // Found a record to delete; gather more info about it
    //

    // Get the record's name
    if (sbTableGetDSName(pDB, (pDB)->DNT, &pDNTmp,0)) {
        DPRINT( 1, "DBGetNextEntryTTLRecord: Failed looking up DN name.\n" );
        return  DB_ERR_DSNAME_LOOKUP_FAILED;
    }

    // Get the parent since we will need to de-ref it later
    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, pdntid,
                &(pDB)->PDNT, sizeof((pDB)->PDNT),
                &actuallen, 0, NULL);


    pDB->JetNewRec = FALSE;
    pDB->fFlushCacheOnUpdate = FALSE;

    // is this an object?
    *pfObject = DBCheckObj(pDB);

    // return object's DSNAME and TimeToDie
    *ppRetBuf = pDNTmp;
    *pulLastTime = time;

    DPRINT2(2,"Garbage candidate (EntryTTL) %08x %ws\n",
            pDB->DNT, pDNTmp->StringName);

    Assert(0 == pDB->JetRetrieveBits);
    return 0;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Add an entry to the delete index.  The delete index is based on the
   delete time field which is created NULL in records.  This function
   moves the current ATT_WHEN_CHANGED value to the delete time field.
   It is the caller's responsibility to ensure that the last change was
   to add the ISDELETTED attribute.

   The exception to this rule is if fGarbCollectASAP is set, which implies
   that this object should be marked with a delete time such that garbage
   collection will process it as soon as possible.  This is typically used
   when removing a read-only NC, in which case we want to clean out the
   removed objects immediately.
*/
DWORD
DBAddDelIndex( DBPOS FAR *pDB, BOOL fGarbCollectASAP )
{
    DSTIME      time;
    JET_SETINFO setinfo;

    /* make sure record is in copy buffer */

    DPRINT1(2, "DBAddDelIndex entered DNT:%ld\n", (pDB)->DNT);
    Assert(VALID_DBPOS(pDB));

    DBFindDNT(pDB, (pDB)->DNT);

    if ( fGarbCollectASAP ) {
        // Choose a deletion time far in the past.

        time = 1;
    }
    else {
        // The deletion time is the time at which is-deleted was set.

        PROPERTY_META_DATA_VECTOR * pMetaDataVec;
        PROPERTY_META_DATA * pMetaData;
        ULONG cb;
        int i;

        if (   ( 0 != DBGetAttVal(pDB, 1, ATT_REPL_PROPERTY_META_DATA,
                                  0, 0, &cb, (LPBYTE *) &pMetaDataVec) )
            || ( NULL == ( pMetaData = ReplLookupMetaData(
                                            ATT_IS_DELETED,
                                            pMetaDataVec,
                                            NULL
                                            )
                         )
               )
           )
        {
            Assert( !"Cannot retrieve deletion time!" );
            return DB_ERR_CANT_ADD_DEL_KEY;
        }

        time = pMetaData->timeChanged;

        THFreeEx(pDB->pTHS,  pMetaDataVec );
    }

    DPRINT2(5, "DBAddDelIndex time:%lx DNT:%ld\n", time, (pDB)->DNT);

    /* Set Del time index field & update record */

    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = 0;
    setinfo.itagSequence = 1;

    JetPrepareUpdate(pDB->JetSessID, pDB->JetObjTbl, JET_prepReplace);
    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, deltimeid, (char*)&time,
                   sizeof(time), 0, &setinfo);
    JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);

    return 0;
}


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Find the first, next or specific object in the data table . Uses DNT index
   NOTE: THIS ROUTINE FOR DEBUG ONLY
*/
extern DWORD APIENTRY
DBDump(DBPOS FAR *pDB, long tag)
{
    JET_ERR  err=0;
    ULONG    actuallen;

    DPRINT(2, "DBDump start\n");
    Assert(VALID_DBPOS(pDB));

    switch (tag)
    {
        case 0:
            DPRINT(5, "DBDump: Initialize dump\n");
            DBCancelRec(pDB);
            DBSetCurrentIndex(pDB, Idx_Dnt, NULL, FALSE);

            if ((err = JetMoveEx(pDB->JetSessID, pDB->JetObjTbl, JET_MoveFirst, 0)) != JET_errSuccess)
            {
                DPRINT1(1, "JetMove (First) error: %d\n", err);
                return 1;
            }

            if ((err = JetMoveEx(pDB->JetSessID, pDB->JetObjTbl, JET_MoveNext, 0)) != JET_errSuccess)
            {
                DPRINT1(1, "JetMove (rec2) error: %d\n", err);
                return 1;
            }

        case 1:
            DPRINT(5, "DBDump: record\n");
            if ((err = JetMoveEx(pDB->JetSessID, pDB->JetObjTbl, JET_MoveNext, 0))
                                                           != JET_errSuccess)
            {
                DPRINT1(1, "JetMove (Next) error: %d\n", err);
                return 1;
            }

            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, dntid,
                                   &(pDB)->DNT, sizeof((pDB)->DNT), &actuallen,
                                   0, NULL);
            break;

        case -1:
            DPRINT(5, "DBDump: ROOT record\n");

            __try
            {
                DBFindDNT(pDB, ROOTTAG);
            }
            __except(HandleMostExceptions(GetExceptionCode()))
            {
                DPRINT1(1, "FindDNT error:%d ROOT\n", err);
                return 1;
            }
            break;

        default:
            DPRINT(5, "DBDump: Specific record\n");
            __try
            {
                DBFindDNT(pDB, tag);
            }
            __except(HandleMostExceptions(GetExceptionCode()))
            {
                DPRINT2(1, "FindDNT error:%d tag:ld\n", err, tag);
                return 1;
            }
            break;
   }

   DPRINT(2, "DBDump Sucessful\n");
   return 0;

}/*DBDump*/

/*++

Routine Description:

    Given an attribute type and a syntax, create an index over that type.  The
    name of the index encodes the type.  The syntax is used to decide whether to
    tack the DNT column onto the end of the index to avoid an index over values
    which take small ranges (e.g. booleans), which are very inneficient in Jet.
    Requires opening a complete new session to Jet to get to transaction level
    0.

    We can make indices where the first column is the attribute or the first
    column is the PDNT followed by the attribute.

    This is one of the three routines in the DS that can create indices.
    General purpose indices over single columns in the datatable are created
    and destroyed by the schema cache by means of DB{Add|Del}ColIndex.
    Localized indices over a small fixed set of columns and a variable set
    of languages, for use in tabling support for NSPI clients, are handled
    in dbCreateLocalizedIndices.  Lastly, a small fixed set of indices that
    should always be present are guaranteed by DBRecreateFixedIndices.

Arguments:

    aid - the attribute type of the column to index.

    syntax - the syntax of the column.

    eSearchFlags - flags describing what kind of index to create (just the
    attribute or PDNT then the attribute.)

    CommonGrbit - grbits that should be enabled when creating an
    index. Eg, there is no need to scan the rows looking for keys when
    when creating a new indexed attribute, so the grbits should be:
        (JET_bitIndexIgnoreAnyNull | JET_bitIndexEmpty)
    but when changing the searchflags on an existing attribute to be "indexed":
        (JET_bitIndexIgnoreAnyNull)

Return Values:

    Returns 0 if all went well, a Jet error code otherwise.

--*/
int
DBAddColIndex (
        ATTCACHE *pAC,
        DWORD eSearchFlags,
        JET_GRBIT CommonGrbit
        )
{
    char        szColname[16];

    char        szIndexName[MAX_INDEX_NAME];
    BYTE        rgbIndexDef[128];
    ULONG       cb = 0;      //initialized to avoid C4701

    char        szPDNTIndexName[MAX_INDEX_NAME];
    BYTE        rgbPDNTIndexDef[128];
    ULONG       cbPDNT = 0;  //initialized to avoid C4701

    char        szTupleIndexName[MAX_INDEX_NAME];
    BYTE        rgbTupleIndexDef[128];
    ULONG       cbTuple = 0;  //initialized to avoid C4701

    BYTE        *pb;
    JET_ERR     err, retCode = 0;
    JET_SESID   newSesid;
    JET_TABLEID newTblid;
    JET_DBID      newDbid;
    JET_INDEXCREATE  indexCreate;
    JET_UNICODEINDEX unicodeIndexData;
    JET_CONDITIONALCOLUMN condColumn;
    ATTRTYP     aid = pAC->id;
    unsigned    syntax = pAC->syntax;

    // Create an index, if the syntax will stand for it.

    if (syntax_jet[syntax].ulIndexType) {
        sprintf(szColname, "ATTa%d", aid);
        szColname[3] += (CHAR)syntax;

        if(eSearchFlags & fATTINDEX) {
            // An attribute index over the whole database has been requested.
            DBGetIndexName (pAC, fATTINDEX, DS_DEFAULT_LOCALE,
                            szIndexName, MAX_INDEX_NAME);

            memset(rgbIndexDef, 0, sizeof(rgbIndexDef));
            strcpy(rgbIndexDef, "+");
            strcat(rgbIndexDef, szColname);
            cb = strlen(rgbIndexDef) + 1;
            if (syntax_jet[syntax].ulIndexType == IndexTypeAppendDNT) {
                pb = rgbIndexDef + cb;
                strcpy(pb, "+");
                strcat(pb, SZDNT);
                cb += strlen(pb) + 1;
            }

            cb +=1;
        }
        if(eSearchFlags & fTUPLEINDEX) {
            // An attribute index over the whole database has been requested.
            Assert(syntax == SYNTAX_UNICODE_TYPE);
            DBGetIndexName (pAC, fTUPLEINDEX, DS_DEFAULT_LOCALE,
                            szTupleIndexName, MAX_INDEX_NAME);

            memset(rgbTupleIndexDef, 0, sizeof(rgbTupleIndexDef));
            strcpy(rgbTupleIndexDef, "+");
            strcat(rgbTupleIndexDef, szColname);
            cbTuple = strlen(rgbTupleIndexDef) + 1;
            if (syntax_jet[syntax].ulIndexType == IndexTypeAppendDNT) {
                pb = rgbTupleIndexDef + cb;
                strcpy(pb, "+");
                strcat(pb, SZDNT);
                cbTuple += strlen(pb) + 1;
            }

            cbTuple +=1;
        }
        if(eSearchFlags & fPDNTATTINDEX) {
            PCHAR pTemp = rgbPDNTIndexDef;

            // An attribute index over the PDNT field  has been requested.
            DBGetIndexName (pAC, fPDNTATTINDEX, DS_DEFAULT_LOCALE,
                            szPDNTIndexName, sizeof (szPDNTIndexName));

            memset(rgbPDNTIndexDef, 0, sizeof(rgbPDNTIndexDef));
            strcpy(pTemp, "+");
            strcat(pTemp, SZPDNT);
            cbPDNT = strlen(pTemp) + 1;
            pTemp = &rgbPDNTIndexDef[cbPDNT];
            strcpy(pTemp, "+");
            strcat(pTemp, szColname);
            cbPDNT += strlen(pTemp) + 1;
            pTemp = &rgbPDNTIndexDef[cbPDNT];
            if (syntax_jet[syntax].ulIndexType == IndexTypeAppendDNT) {
                strcpy(pTemp, "+");
                strcat(pTemp, SZDNT);
                cbPDNT += strlen(pTemp) + 1;
            }
            cbPDNT++;
        }

        // We need to open an entirely new session, etc.  in order to be at
        // transaction level 0 (it's a requirement of Jet.)
        err = JetBeginSession(jetInstance, &newSesid, szUser, szPassword);
        if(!err) {
            err = JetOpenDatabase(newSesid, szJetFilePath, "", &newDbid, 0);
            if(!err) {
                err = JetOpenTable(newSesid, newDbid, SZDATATABLE, NULL, 0, 0,
                                   &newTblid);
                if(!err) {
                    if(eSearchFlags & fPDNTATTINDEX) {

                        // we already have an index for RDN
                        // don't bother creating a new one.
                        // do this only for different langs
                        if (aid != ATT_RDN) {

                            // Emit message so people know why startup is slow.
                            DPRINT2(0, "Creating index '%s' with common grbits %08x ...\n",
                                    szPDNTIndexName, CommonGrbit);

                            memset(&indexCreate, 0, sizeof(indexCreate));
                            indexCreate.cbStruct = sizeof(indexCreate);
                            indexCreate.szIndexName = szPDNTIndexName;
                            indexCreate.szKey = rgbPDNTIndexDef;
                            indexCreate.cbKey = cbPDNT;
                            indexCreate.grbit = CommonGrbit;
                            indexCreate.ulDensity = GENERIC_INDEX_DENSITY;
                            if(syntax != SYNTAX_UNICODE_TYPE) {
                                indexCreate.lcid = DS_DEFAULT_LOCALE;
                            }
                            else {
                                indexCreate.grbit |= JET_bitIndexUnicode;
                                indexCreate.pidxunicode = &unicodeIndexData;

                                memset(&unicodeIndexData, 0,
                                       sizeof(unicodeIndexData));
                                unicodeIndexData.lcid = DS_DEFAULT_LOCALE;
                                unicodeIndexData.dwMapFlags =
                                    (DS_DEFAULT_LOCALE_COMPARE_FLAGS |
                                     LCMAP_SORTKEY);
                            }

                            err = JetCreateIndex2(newSesid,
                                                  newTblid,
                                                  &indexCreate,
                                                  1);

                            if ( err ) {
                                if (err != JET_errIndexDuplicate) {
                                    DPRINT1(0, "Error %d creating index\n", err);
                                }
                            }
                            else {
                                DBGetIndexHint(indexCreate.szIndexName,
                                               &pAC->pidxPdntIndex);
                                DPRINT(0, "Index successfully created\n");
                            }
                        }
                        else {
                            DPRINT (0, "Skipping creating of index for PDNTRDN\n");
                        }

                        // now do the language specific PDNT index creations
                        if (gAnchor.ulNumLangs) {
                            DWORD j;

                            for(j=1; j<=gAnchor.ulNumLangs; j++) {

                                // we don't want to create an index for a language same as our default
                                if (gAnchor.pulLangs[j] == DS_DEFAULT_LOCALE) {
                                    continue;
                                }

                                DBGetIndexName (pAC,
                                                fPDNTATTINDEX,
                                                gAnchor.pulLangs[j],
                                                szPDNTIndexName,
                                                sizeof (szPDNTIndexName));

                                if (JetSetCurrentIndex(newSesid,
                                                       newTblid,
                                                       szPDNTIndexName)) {

                                    // Didn't already find the index.  Try to create it.
                                    // Emit debugger message so people know why startup is slow.
                                    DPRINT2(0, "Creating localized index '%s' with common grbits %08x ...\n",
                                            szPDNTIndexName, CommonGrbit);

                                    memset(&indexCreate, 0, sizeof(indexCreate));
                                    indexCreate.cbStruct = sizeof(indexCreate);
                                    indexCreate.szIndexName = szPDNTIndexName;
                                    indexCreate.szKey = rgbPDNTIndexDef;
                                    indexCreate.cbKey = cbPDNT;
                                    indexCreate.grbit = (CommonGrbit | JET_bitIndexUnicode);
                                    indexCreate.ulDensity = GENERIC_INDEX_DENSITY;
                                    indexCreate.pidxunicode = &unicodeIndexData;

                                    memset(&unicodeIndexData, 0, sizeof(unicodeIndexData));
                                    unicodeIndexData.lcid = gAnchor.pulLangs[j];
                                    unicodeIndexData.dwMapFlags =
                                        (DS_DEFAULT_LOCALE_COMPARE_FLAGS |
                                         LCMAP_SORTKEY);

                                    retCode = JetCreateIndex2(newSesid,
                                                          newTblid,
                                                          &indexCreate,
                                                          1);

                                    switch(retCode) {
                                    case JET_errIndexDuplicate:
                                    case 0:
                                        break;

                                    default:
                                        LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                                                 DS_EVENT_SEV_ALWAYS,
                                                 DIRLOG_LOCALIZED_CREATE_INDEX_FAILED,
                                                 szInsertUL(pAC->id),
                                                 szInsertSz(pAC->name),
                                                 szInsertInt(gAnchor.pulLangs[j]),
                                                 szInsertInt(retCode),
                                                 NULL, NULL, NULL, NULL);

                                        if (!err) {
                                            err = retCode;
                                        }
                                        break;
                                    }
                                }
                                else {
                                    DPRINT1(1, "Index '%s' verified\n", szPDNTIndexName);
                                }
                            }
                        }
                    }


                    if(eSearchFlags & fATTINDEX) {
                        // Emit message so people know why startup is slow.
                        DPRINT2(0, "Creating index '%s' with common grbits %08x ...\n",
                                szIndexName, CommonGrbit);
                        memset(&indexCreate, 0, sizeof(indexCreate));
                        indexCreate.cbStruct = sizeof(indexCreate);
                        indexCreate.szIndexName = szIndexName;
                        indexCreate.szKey = rgbIndexDef;
                        indexCreate.cbKey = cb;
                        indexCreate.grbit = CommonGrbit;
                        indexCreate.ulDensity = GENERIC_INDEX_DENSITY;
                        if(syntax != SYNTAX_UNICODE_TYPE) {
                            indexCreate.lcid = DS_DEFAULT_LOCALE;
                        }
                        else {
                            indexCreate.pidxunicode = &unicodeIndexData;
                            indexCreate.grbit |= JET_bitIndexUnicode;

                            memset(&unicodeIndexData, 0,
                                   sizeof(unicodeIndexData));
                            unicodeIndexData.lcid = DS_DEFAULT_LOCALE;
                            unicodeIndexData.dwMapFlags =
                                (DS_DEFAULT_LOCALE_COMPARE_FLAGS |
                                 LCMAP_SORTKEY);
                        }

                        retCode = JetCreateIndex2(newSesid,
                                               newTblid,
                                               &indexCreate,
                                               1);
                        if ( retCode ) {
                            DPRINT1(0, "Error %d creating index\n", retCode);
                        }
                        else {
                            DBGetIndexHint(indexCreate.szIndexName,
                                           &pAC->pidxIndex);
                            DPRINT(0, "Index successfully created\n");
                        }
                    }
                    if(eSearchFlags & fTUPLEINDEX) {
                        // Emit message so people know why startup is slow.
                        DPRINT2(0, "Creating index '%s' with common grbits %08x ...\n",
                                szTupleIndexName, CommonGrbit);
                        memset(&indexCreate, 0, sizeof(indexCreate));
                        indexCreate.cbStruct = sizeof(indexCreate);
                        indexCreate.szIndexName = szTupleIndexName;
                        indexCreate.szKey = rgbTupleIndexDef;
                        indexCreate.cbKey = cbTuple;
                        indexCreate.grbit = CommonGrbit | JET_bitIndexTuples | JET_bitIndexUnicode;
                        indexCreate.ulDensity = GENERIC_INDEX_DENSITY;
                        indexCreate.pidxunicode = &unicodeIndexData;
                        indexCreate.rgconditionalcolumn = &condColumn;
                        indexCreate.cConditionalColumn = 1;

                        // Only index substrings if this object isn't deleted.
                        condColumn.cbStruct = sizeof(condColumn);
                        condColumn.szColumnName = SZISDELETED;
                        condColumn.grbit = JET_bitIndexColumnMustBeNull;

                        memset(&unicodeIndexData, 0,
                               sizeof(unicodeIndexData));
                        unicodeIndexData.lcid = DS_DEFAULT_LOCALE;
                        unicodeIndexData.dwMapFlags =
                            (DS_DEFAULT_LOCALE_COMPARE_FLAGS |
                             LCMAP_SORTKEY);

                        retCode = JetCreateIndex2(newSesid,
                                               newTblid,
                                               &indexCreate,
                                               1);
                        if ( retCode ) {
                            DPRINT1(0, "Error %d creating index\n", retCode);
                            DPRINT1(0, "indexCreate @ %p\n", &indexCreate);
                        }
                        else {
                            DBGetIndexHint(indexCreate.szIndexName,
                                           &pAC->pidxTupleIndex);
                            DPRINT(0, "Index successfully created\n");
                        }
                    }
                    if(!err)
                        err = retCode;
                }
            }
            // JET_bitDbForceClose not supported in Jet600.
            JetCloseDatabase(newSesid, newDbid, 0);
        }
        JetEndSession(newSesid, JET_bitForceSessionClosed);
    }
    else
        err = 1;

    return err;
}


/*++

Routine Description:

    Given an attribute type, delete an index over that attribute.  The name of
    the index encodes the type.  Requires opening a complete new session
    to Jet to get to transaction level 0.

Arguments:

    aid - the attribute type of the column to quit indexing.

    eSearchFlags - the search flags describing which kind of index to destroy

Return Values:

    Returns 0 if all went well, a Jet error code otherwise.

--*/
int
DBDeleteColIndex (
        ATTRTYP aid,
        DWORD eSearchFlags
        )
{
    char        szIndexName[MAX_INDEX_NAME];
    char        szPDNTIndexName[MAX_INDEX_NAME];
    char        szTupleIndexName[MAX_INDEX_NAME];
    JET_ERR     err, err2=0;
    JET_SESID     newSesid;
    JET_TABLEID   newTblid;
    JET_DBID      newDbid;

    // Delete an index.
    if(eSearchFlags & fPDNTATTINDEX)
        sprintf(szPDNTIndexName, SZATTINDEXPREFIX"P_%08X", aid);
    if(eSearchFlags & fATTINDEX)
        sprintf(szIndexName, SZATTINDEXPREFIX"%08X", aid);
    if(eSearchFlags & fTUPLEINDEX)
        sprintf(szTupleIndexName, SZATTINDEXPREFIX"T_%08X", aid);

    err = JetBeginSession(jetInstance, &newSesid, szUser, szPassword);
    if(!err) {
        err = JetOpenDatabase(newSesid, szJetFilePath, "", &newDbid, 0);
        if(!err) {
            err = JetOpenTable(newSesid, newDbid, SZDATATABLE, NULL, 0, 0,
                               &newTblid);
            if(!err) {
                if(eSearchFlags & fATTINDEX)
                    err = JetDeleteIndex(newSesid, newTblid, szIndexName);
                if(eSearchFlags & fPDNTATTINDEX)
                    err2 = JetDeleteIndex(newSesid, newTblid, szPDNTIndexName);
                if(!err)
                    err = err2;

                if(eSearchFlags & fTUPLEINDEX)
                    err2 = JetDeleteIndex(newSesid, newTblid, szTupleIndexName);
                if(!err)
                    err = err2;
            }

        }
        // JET_bitDbForceClose not supported in Jet600.
        JetCloseDatabase(newSesid, newDbid, 0);
    }
    JetEndSession(newSesid, JET_bitForceSessionClosed);


    return err;
}

/*++

Routine Description:

    Given an attribute type and a syntax, create a column in the database.  The
    name of the column encodes the type and syntax.  Requires opening a complete
    new session to Jet to get to transaction level 0.

    Returns the Jet column id of the newly created column.

    Also, if asked we will create an index over the newly formed column.

Arguments:

    aid - the attribute type of the column to create.

    syntax - the syntax of the column to create.

    pjCol - place to drop the Jet columnid of the newly created column.

    fCreateIndex - Should we also create an index for the column?

Return Values:

    Returns 0 if all went well, a Jet error code otherwise.

--*/
int
DBAddCol (
        ATTCACHE *pAC
        )
{
    char        szColname[16];
    JET_COLUMNDEF coldef;
    JET_SESID     newSesid;
    JET_TABLEID   newTblid;
    JET_DBID      newDbid;
    JET_ERR       err;

    sprintf(szColname, "ATTa%d", pAC->id);
    szColname[3] += (UCHAR)pAC->syntax;

    coldef.cbStruct = sizeof(coldef);
    coldef.columnid = 0;
    coldef.cp = syntax_jet[pAC->syntax].cp;
    coldef.coltyp = syntax_jet[pAC->syntax].coltype;
    coldef.wCountry = 0;
    coldef.wCollate = 0;
    coldef.langid = GetUserDefaultLangID();
    coldef.cbMax = syntax_jet[pAC->syntax].colsize;
    coldef.grbit = JET_bitColumnTagged | JET_bitColumnMultiValued;

    // We need to open an entirely new session, etc.  in order to be at
    // transaction level 0 (it's a requirement of Jet.)
    err = JetBeginSession(jetInstance, &newSesid, szUser, szPassword);
    if(!err) {
        err = JetOpenDatabase(newSesid, szJetFilePath, "", &newDbid, 0);
        if(!err) {
            err = JetOpenTable(newSesid, newDbid, SZDATATABLE, NULL, 0, 0,
                               &newTblid);
            if(!err)
                err = JetAddColumn(newSesid, newTblid, szColname, &coldef, NULL,
                                   0,&pAC->jColid);
            // JET_bitDbForceClose not supported in Jet600.
            JetCloseDatabase(newSesid, newDbid, 0);
        }
        JetEndSession(newSesid, JET_bitForceSessionClosed);
    }
    // Create an empty index for the new tagged column. An empty index is
    // created because there can't be rows with columns for this index.
    // It is, after all, a new column.
    if (!err && (pAC->fSearchFlags & (fATTINDEX | fPDNTATTINDEX))) {
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_SCHEMA_CREATING_INDEX,
                 szInsertUL(pAC->id), pAC->name, 0);
        err = DBAddColIndex(pAC,
                            pAC->fSearchFlags,
                            (JET_bitIndexIgnoreAnyNull | JET_bitIndexEmpty));
        if(err) {
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_SCHEMA_CREATE_INDEX_FAILED,
                     szInsertUL(pAC->id), szInsertSz(pAC->name), szInsertInt(err));
        } else {
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_SCHEMA_INDEX_CREATED,
                     szInsertUL(pAC->id), szInsertSz(pAC->name), 0);
        }
    }

    return err;
}

/*++

Routine Description:

    Given an attribute type and a syntax, destroy a column in the database.  The
    name of the column encodes the type and syntax.  Requires opening a complete
    new session to Jet to get to transaction level 0.

Arguments:

    aid - the attribute type of the column to create.

    syntax - the syntax of the column to create.

Return Values:

    Returns 0 if all went well, a Jet error code otherwise.

--*/
int
DBDeleteCol (
        ATTRTYP aid,
        unsigned syntax
        )
{
    JET_SESID     newSesid;
    JET_TABLEID   newTblid;
    JET_DBID      newDbid;
    JET_ERR       err;
    char        szColname[16];

    sprintf(szColname, "ATTa%d", aid);
    szColname[3] += (CHAR)syntax;

    // We need to open an entirely new session, etc.  in order to be at
    // transaction level 0 (it's a requirement of Jet.)
    if(!(err = JetBeginSession(jetInstance, &newSesid, szUser, szPassword))) {
        if(!(err = JetOpenDatabase(newSesid, szJetFilePath, "", &newDbid, 0))) {
            if(!(err = JetOpenTable(newSesid,
                                    newDbid,
                                    SZDATATABLE,
                                    NULL,
                                    0,
                                    0,
                                    &newTblid))) {
                err = JetDeleteColumn(newSesid, newTblid, szColname);
            }
            // JET_bitDbForceClose not supported in Jet600.
            JetCloseDatabase(newSesid, newDbid, 0);
        }
        JetEndSession(newSesid, JET_bitForceSessionClosed);
    }
    return err;
}



USN
DBGetLowestUncommittedUSN (
        )
/*++

Routine Description:

    Return the lowest uncommitted usn.
    NOTE: If there are no outstanding transactions, will return USN_MAX.

Arguments:

    None.

Return Values:

    The lowest uncommited USN.

--*/
{
    USN usnLowest = 0;
    EnterCriticalSection (&csUncUsn);
    __try {
        usnLowest = gusnLowestUncommitted;
    }
    __finally {
        LeaveCriticalSection (&csUncUsn);
    }

    return usnLowest;
}

USN
DBGetHighestCommittedUSN (
        )
/*++

Routine Description:

    Return the highest committed usn.

Arguments:

    None.

Return Values:

    The highest commited USN.

--*/
{
    USN usnHighestCommitted = 0;

    EnterCriticalSection( &csUncUsn );

    __try
    {
        if ( USN_MAX != gusnLowestUncommitted )
        {
            // there are threads with uncommitted transactions
            usnHighestCommitted = gusnLowestUncommitted - 1;
        }
        else
        {
            // no transactions outstanding; highest committed is
            // just what the next USN to be given out is, minus 1
            usnHighestCommitted = gusnEC - 1;
        }
    }
    __finally
    {
        LeaveCriticalSection( &csUncUsn );
    }

    return usnHighestCommitted;
}

DWORD
DBGetIndexHint(
               IN  char *pszIndexName,
               OUT struct tagJET_INDEXID **ppidxHint)
{
    JET_INDEXID indexInfo;
    DWORD err;
    DBPOS *pDBtmp;

    DBOpen2(FALSE, &pDBtmp);
    __try {
        *ppidxHint = NULL;
        err = JetGetTableIndexInfo(pDBtmp->JetSessID,
                                   pDBtmp->JetObjTbl,
                                   pszIndexName,
                                   &indexInfo,
                                   sizeof(indexInfo),
                                   JET_IdxInfo);
        if (err == 0) {
            *ppidxHint = malloc(sizeof(indexInfo));
            if (*ppidxHint) {
                **ppidxHint = indexInfo;
            }
            else {
                err = DB_ERR_BUFFER_INADEQUATE;
            }
        }
        else {
            err = DB_ERR_DATABASE_ERROR;
        }
    } __finally {
        DBClose(pDBtmp, TRUE);
    }

    return err;
}



DWORD
DBGetNextObjectNeedingCleaning(
    DBPOS FAR *pDB,
    ULONG *pulTag
    )

/*++

Routine Description:

    Find the next object on the SZDNTCLEANINDEX.
    An object needed cleaning will have the cleaning column set non-NULL.
    After cleaning, an object the caller should have the cleaning column
    set NULL.

    An object on this index may be deleted.
    An object on this index may also be a phantom.

Arguments:

    pDB - database position
    pulTag - IN - Last position on index. Set to zero initially.
             OUT - DNT of object found
    The purpose of pulTag is to act as an enumeration context. It holds the
    last position found after each iteration.  This style of routine is similar
    to GetNextDelRecord and GetNextDelLinkVal.  The reason we cannot use pDB->DNT
    as this context is that the caller may lose currency as part of a
    DBTransOut/DBTransIn sequence between calls to this routine.


Return Value:

    DWORD - 0 found
         On success, DBPOS is also made current for the found record.
         pDB->DNT == *pulTag

         DB_ERR_NO_DEL_RECORD - no more

--*/

{
    DWORD err, actuallen, dnt;
    BYTE bClean;

    Assert(VALID_DBPOS(pDB));
    Assert(0 == pDB->JetRetrieveBits);

    DBSetCurrentIndex(pDB, Idx_Clean, NULL, FALSE);

    // We should get 100% hits on this index

    JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl,
                 pulTag, sizeof(*pulTag),
                 JET_bitNewKey);

    if ((err = JetSeekEx(pDB->JetSessID, pDB->JetObjTbl,
                         JET_bitSeekGT))         != JET_errSuccess)
    {
        DPRINT(5, "GetNextCleanRecord search complete");
        return DB_ERR_NO_MORE_DEL_RECORD;
    }

#if DBG
    // Column must be present, by definition of index
    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl,
                             cleanid, &bClean, sizeof(bClean),
                             &actuallen,JET_bitRetrieveFromIndex,NULL);
    // Verify that clean_col has proper non-zero value
    Assert(bClean);
#endif

    // This routine will return DIRERR_NOT_AN_OBJECT for phantoms.
    // This is a possible outcome for this code.
    dbMakeCurrent( pDB, NULL );

    *pulTag = pDB->DNT;

    DPRINT1( 1, "Object %s needs cleaning.\n", DBGetExtDnFromDnt( pDB, pDB->DNT ) );

    return 0;
} /* DBGetNextObjectNeedingCleaning */


VOID
DBSetObjectNeedsCleaning(
    DBPOS *pDB,
    BOOL fNeedsCleaning
    )

/*++

Routine Description:

Set the special column for this record to indicate that the object cleaner
must work on it.

This routine may be called from within a prepared update or not.

Arguments:

    pDB - database position
    fNeedsCleaning - State to set

Return Value:

    None

--*/

{
// Delay cleaner by one minute to allow current transaction to finish
#define LINK_CLEANER_START_DELAY 60
    BYTE bClean = 1;
    BOOL fSuccess = FALSE;
    BOOL fInUpdate = (JET_bitRetrieveCopy == pDB->JetRetrieveBits);

    Assert(VALID_DBPOS(pDB));

    // Set clean index field & update record

    if (!fInUpdate) {
        dbInitRec(pDB);
    }

    // We are in a prepared update
    Assert(JET_bitRetrieveCopy == pDB->JetRetrieveBits);

    __try {
        if (fNeedsCleaning) {
            JET_SETINFO setinfo;

            setinfo.cbStruct = sizeof(setinfo);
            setinfo.ibLongValue = 0;
            setinfo.itagSequence = 1;

            JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, cleanid,
                           &bClean, sizeof(bClean), 0, &setinfo);

            // Add a reference to the object to indicate that the cleaner
            // still needs to run on it.  This is to account for the case of
            // an object in a read only nc with lots of forward links. When
            // the nc is torn down, only some of the forward links can be
            // removed immediately. If the object didn't have any backlinks
            // there would be nothing to keep the object from disappearing.

            DBAdjustRefCount(pDB, pDB->DNT, 1);
        } else {
            JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, cleanid,
                           NULL, 0, 0, NULL);

            // Remove the reference now that the cleaner is done.
            DBAdjustRefCount(pDB, pDB->DNT, -1);
        }

        fSuccess = TRUE;
    } __finally {

        if (!fInUpdate) {
            if (fSuccess) {
                DBUpdateRec(pDB);
            } else {
                DBCancelRec(pDB);
            }
            // No longer in a prepared update
            Assert(0 == pDB->JetRetrieveBits);
        }
    }

    if ( fNeedsCleaning && fSuccess) {
        // Reschedule Link cleanup to start ASAP
        InsertInTaskQueue(TQ_LinkCleanup, NULL, LINK_CLEANER_START_DELAY);
    }

    DPRINT2( 2, "Object %s set to cleaning state %d\n",
             GetExtDN( pDB->pTHS, pDB ), fNeedsCleaning );

} /* DBSetRecordNeedsCleaning */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dblink.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dblink.c

Abstract:

    Link table routines

    This module was split off from dbobj.c to contain all the functions relating
    to operations on values in the link table.

Author:

    Many authors contributed to this code.

Notes:

Revision History:

    Split off into separate file by Will Lees (wlees) 13-Jan-2000


--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <dsatools.h>                   // For pTHStls
#include <mdlocal.h>                    // IsRoot
#include <ntseapi.h>
#include <xdommove.h>
#include <drameta.h>                    // ReplInsertMetaData

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>
#include "ntdsctr.h"

// Assorted DSA headers
#include "dsevent.h"
#include "dstaskq.h"
#include "objids.h"        /* needed for ATT_MEMBER and ATT_IS_MEMBER_OFDL */
#include <dsexcept.h>
#include <filtypes.h>      /* Def of FI_CHOICE_???                  */
#include <anchor.h>
#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DBLINK:" /* define the subsystem for debugging */
#include <dsutil.h>

// DBLayer includes
#include "dbintrnl.h"

#include <fileno.h>
#define  FILENO FILENO_DBLINK

DWORD gcLinksProcessedImmediately = DB_COUNT_LINKS_PROCESSED_IMMEDIATELY;

void
dbGetLinkTableData (
        PDBPOS           pDB,
        BOOL             bIsBackLink,
        BOOL             bWarnings,
        DWORD           *pulObjectDnt,
        DWORD           *pulValueDnt,
        DWORD           *pulRecLinkBase
        )
{
    JET_RETRIEVECOLUMN attList[3];
    JET_COLUMNID       objectdntid;
    JET_COLUMNID       valuedntid;
    DWORD              cAtt = 0;
    DWORD              grbit;
    CHAR               szIndexName[JET_cbNameMost];

    if(bIsBackLink) {
        objectdntid = backlinkdntid;
        valuedntid = linkdntid;
    }
    else {
        valuedntid = backlinkdntid;
        objectdntid = linkdntid;
    }

    // Use RetrieveFromIndex only when we are using an index that
    // contains ALL the items desired.  There are other indexes,
    // notably LINKATTRUSNINDEX and LINKDELINDEX, which have some
    // link data components, but we currently optimize either all
    // or none.

    grbit = pDB->JetRetrieveBits;
    JetGetCurrentIndexEx( pDB->JetSessID, pDB->JetLinkTbl,
                          szIndexName, sizeof( szIndexName ) );
    if ( (!strcmp( szIndexName, SZLINKALLINDEX )) ||
         (!strcmp( szIndexName, SZLINKINDEX )) ||
         (!strcmp( szIndexName, SZLINKLEGACYINDEX )) ||
         (!strcmp( szIndexName, SZBACKLINKALLINDEX )) ||
         (!strcmp( szIndexName, SZBACKLINKINDEX )) ) {
        grbit |= JET_bitRetrieveFromIndex;
    }

    memset(attList,0,sizeof(attList));
    // First, try to retrieve everything from the index.
    if(pulObjectDnt) {
        attList[cAtt].pvData = pulObjectDnt;
        attList[cAtt].columnid = objectdntid;
        attList[cAtt].cbData = sizeof(DWORD);
        attList[cAtt].grbit = grbit;
        attList[cAtt].itagSequence = 1;
        cAtt++;
    }
    if(pulValueDnt) {
        attList[cAtt].pvData = pulValueDnt;
        attList[cAtt].columnid = valuedntid;
        attList[cAtt].cbData = sizeof(DWORD);
        attList[cAtt].grbit = grbit;
        attList[cAtt].itagSequence = 1;
        cAtt++;
    }
    if(pulRecLinkBase) {
        attList[cAtt].pvData = pulRecLinkBase;
        attList[cAtt].columnid = linkbaseid;
        attList[cAtt].cbData = sizeof(DWORD);
        attList[cAtt].grbit = grbit;
        attList[cAtt].itagSequence = 1;
        cAtt++;
    }

    if(!bWarnings) {
        JetRetrieveColumnsSuccess(pDB->JetSessID,
                                  pDB->JetLinkTbl,
                                  attList,
                                  cAtt);
    }
    else {
        DWORD err;
        err = JetRetrieveColumns(pDB->JetSessID,
                                 pDB->JetLinkTbl,
                                 attList,
                                 cAtt);
        switch(err) {
        case JET_errSuccess:
            break;

        case JET_errNoCurrentRecord:
            if(pulObjectDnt) {
                *pulObjectDnt = INVALIDDNT;
            }
            if(pulValueDnt) {
                *pulValueDnt = INVALIDDNT;
            }
            if(pulRecLinkBase) {
                *pulRecLinkBase = 0xFFFFFFFF;
            }
            break;

        default:
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
            break;
        }
    }


    return;
}


void
DBGetLinkTableData(
    PDBPOS           pDB,
    DWORD           *pulObjectDnt,
    DWORD           *pulValueDnt,
    DWORD           *pulRecLinkBase
    )

/*++

Routine Description:

This is a public wrapper function for dbGetLinkTableData.

It assumes we are positioned on a link table entry.

Arguments:

    pDB - 
    pulObjectDnt - 

Return Value:

    None

--*/

{
    dbGetLinkTableData( pDB, FALSE, FALSE,
                        pulObjectDnt, pulValueDnt, pulRecLinkBase );
} /* DBGetLinkTableData */

void
DBGetLinkTableDataDel (
        PDBPOS           pDB,
        DSTIME          *ptimeDeleted
        )

/*++

Routine Description:

This routine is a companion to DbGetLinkTableData. It returns secondary
info such as deletion time.

Metadata is obtained using DBGetLinkValueMetadata

Arguments:

    pDB - 
    ptimeDeleted - 

Return Value:

    None

--*/

{
    JET_RETRIEVECOLUMN attList[1];
    DWORD err;

// TODO: When we implement absent value garbage collection, expand this routine
// to retrieve by index when using the SZLINKDELINDEX. Also return LINKDNT from that
// index if useful.

    Assert( ptimeDeleted );

    // linkdeltimeid is not on LINKINDEX, but is on LINKDELINDEX
    memset(attList,0,sizeof(attList));
    attList[0].pvData = ptimeDeleted;
    attList[0].columnid = linkdeltimeid;
    attList[0].cbData = sizeof(DSTIME);
    attList[0].grbit = pDB->JetRetrieveBits;
    attList[0].itagSequence = 1;
    // Add additional columns here if needed

    // Some columns may legitimately not be present
    // Jliem writes: In general, if the error from the function return is 0, then
    // you're guaranteed the individual column errors are >= 0 (ie. no errors,
    // but possibly warnings).  FYI, the most common warning to get from individual
    // columns is JET_wrnColumnNull.

    err = JetRetrieveColumns(pDB->JetSessID,
                             pDB->JetLinkTbl,
                             attList,
                             1);
    if (err == JET_errColumnNotFound) {
        *ptimeDeleted = 0;
    } else if (err) {
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
    } else if (attList[0].err) {
        *ptimeDeleted = 0;
    }

#if DBG
    if (*ptimeDeleted == 0) {
        DPRINT( 4, "DbGetLinkTableDataDel, deltime = (not deleted)\n" );
    } else {
        CHAR szTime[SZDSTIME_LEN];
        DPRINT1( 4, "DbGetLinkTableDataDel, deltime = %s\n",
                 DSTimeToDisplayString(*ptimeDeleted, szTime) );
    }
#endif

    return;
} /* DBGetLinkTableDataDel  */

void
DBGetLinkTableDataUsn (
    PDBPOS           pDB,
    DWORD           *pulNcDnt,
    USN             *pusnChanged,
    DWORD           *pulDnt
    )

/*++

Routine Description:

    Return the fields from the link table dra usn index.

    You must be positioned on SZLINKDRAUSNINDEX in order for this to work.

Arguments:

    pDB - 
    pulNcDnt - 
    pusnChanged - 

Return Value:

    None

--*/

{
    JET_RETRIEVECOLUMN attList[3];
    DWORD              cAtt = 0;
    DWORD              grbit;

    // Always retrieve from index
    grbit = pDB->JetRetrieveBits | JET_bitRetrieveFromIndex;

    memset(attList,0,sizeof(attList));

    if(pulNcDnt) {
        attList[cAtt].pvData = pulNcDnt;
        attList[cAtt].columnid = linkncdntid;
        attList[cAtt].cbData = sizeof(DWORD);
        attList[cAtt].grbit = grbit;
        attList[cAtt].itagSequence = 1;
        cAtt++;
    }
    if(pusnChanged) {
        attList[cAtt].pvData = pusnChanged;
        attList[cAtt].columnid = linkusnchangedid;
        attList[cAtt].cbData = sizeof(USN);
        attList[cAtt].grbit = grbit;
        attList[cAtt].itagSequence = 1;
        cAtt++;
    }
    if(pulDnt) {
        attList[cAtt].pvData = pulDnt;
        attList[cAtt].columnid = linkdntid;
        attList[cAtt].cbData = sizeof(DWORD);
        attList[cAtt].grbit = grbit;
        attList[cAtt].itagSequence = 1;
        cAtt++;
    }
    JetRetrieveColumnsSuccess(pDB->JetSessID,
                              pDB->JetLinkTbl,
                              attList,
                              cAtt);
    return;
} /* DBGetLinkTableDataUsn  */


BOOL
dbPositionOnExactLinkValue(
    IN DBPOS *pDB,
    IN ULONG ulLinkDnt,
    IN ULONG ulLinkBase,
    IN ULONG ulBacklinkDnt,
    IN PVOID pvData,
    IN ULONG cbData,
    IN BOOL *pfPresent
    )

/*++

Routine Description:

This function will look up the value in the named index and position on it.

This routine should work regardless of tracking of metadata for values. What
it means to be present or absent may change, but we can still locate values
efficiently using the index this way.  This routine does not touch or depend
on value metadata.

This function you tell you if the value actually exists in the database. It is
more efficient than the DbGetNextLinkVal kinds of functions because it seeks
exactly to the row.

The index attributes enforce that (linkdnt,linkid,backlinkdnt,data) are unique.
(linkdnt,linkid,backlinkdnt) is itself unique, but since the index includes data,
there can be many records with the same first three segments, but different data.
Don wrote the following: The uniqifying entity is the combo of DN+data, and performance
will be shot if the data is not unique within the first ~240 bytes.  No work,
either in code or design, went in to supporting extremely large binary values.

I think we are ok. As long as Jet enforces the uniqueness of dn+data:1-240 in
the index, and also truncates seek keys in the same way, a record will either
be found or not. 

Arguments:

    pDB - DBPOS, to be positioned
    ulDnt - dnt of link row
    ulLinkBase - link base of link row
    ulBacklinkDnt - backlink of link row
    pvData - optional, pointer to data
    cbData - optional, data length
    fPresent - Returned present state

Return Value:

    BOOL - true if found, false if not found

--*/

{
    JET_ERR err;
    ULONG ulObjectDnt, ulValueDnt, ulNewLinkBase;
    DSTIME timeDeletion;
    DWORD count;

    Assert(VALID_DBPOS(pDB));

    // This index sees all links, present or absent
    JetSetCurrentIndexSuccess(pDB->JetSessID,
                              pDB->JetLinkTbl,
                              SZLINKALLINDEX);

    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl, &(ulLinkDnt),
                 sizeof(ulLinkDnt), JET_bitNewKey);
    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                 &ulLinkBase, sizeof(ulLinkBase), 0);
    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                 &ulBacklinkDnt, sizeof(ulBacklinkDnt), 0);
    err = JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                       pvData, cbData, 0 );
    Assert( !err );

    // Warnings are returned for this call
    err = JetSeekEx(pDB->JetSessID, pDB->JetLinkTbl, JET_bitSeekEQ);
    if (err) {
        DPRINT6( 2, "dbPosLinkValue, dnt = %d, base = %d, back = %d, cb = %d => %s err %d\n",
                 ulLinkDnt, ulLinkBase, ulBacklinkDnt, cbData,
                 "DOES NOT EXIST", err );
        return FALSE;  // Not found
    }

    if (pfPresent) {
        err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                        pDB->JetLinkTbl,
                                        linkdeltimeid,
                                        &timeDeletion, sizeof(timeDeletion),
                                        &count, 0, NULL);
        *pfPresent = (err != JET_errSuccess);

        DPRINT5( 2, "dbPosLinkValue, dnt = %d, base = %d, back = %d, cb = %d => %s\n",
                 ulLinkDnt, ulLinkBase, ulBacklinkDnt, cbData,
                 *pfPresent ? "PRESENT" : "ABSENT" );
    }

#if DBG
    // Verify that we found the right record
    {
        BYTE *rgb = NULL;
        ULONG cb;
        THSTATE *pTHS=pDB->pTHS;

        // test to verify that we found a qualifying record
        // Note, we don't retrieve from index because the index
        // truncates the data.
        dbGetLinkTableData( pDB,
                            FALSE, /*not backlink*/
                            FALSE, /*no warnings,must succeed*/
                            &ulObjectDnt,
                            &ulValueDnt,
                            &ulNewLinkBase );

        Assert( (ulObjectDnt == ulLinkDnt) &&
                (ulNewLinkBase == ulLinkBase) &&
                (ulValueDnt == ulBacklinkDnt) );

        if (JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                      linkdataid,
                                      NULL, 0, &cb, 0, NULL) ==
            JET_wrnBufferTruncated) {
            // data portion of the OR name exists -allocate space and read it

            rgb = THAllocEx( pTHS, cb);
            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                                     linkdataid, rgb, cb,
                                     &cb, 0, NULL);
        }
        else {
            cb = 0;
        }
        // compare pvdata with rgb
        Assert( (cb == cbData) &&
                ( (rgb != NULL) == (pvData != NULL) ) );
        Assert( (pvData == NULL) ||
                (memcmp( rgb, pvData, cb ) == 0) );
        if (rgb) {
            THFreeEx( pTHS, rgb );
        }
    }
#endif

    return TRUE;
} /* dbPositionOnExactLinkValue */


void
dbSetLinkValuePresent(
    IN DBPOS *pDB,
    IN DWORD dwEventCode,
    IN ATTCACHE *pAC,
    IN BOOL fResetDelTime,
    IN VALUE_META_DATA *pMetaDataRemote OPTIONAL
    )

/*++

Routine Description:

    Make the value present.
    This function may also be used to "touch" the metadata.

    This code assumes that the value exists, but may be absent.

    This function is a no-op when not tracking value metadata.  The reason
    for this is that value metadata always trumps attribute metadata. This
    means that if we are applying an attribute level update and the
    row already exists, nothing more can or should be done.  If the row
    exists in the absent state, a attribute level update cannot change it.

    If this routine is used by fDRA, we must not optimize out the updating
    of the metadata if the value is already present.

    From the LVR spec, section on "Originating Writes"

If the originating write is an add, and the corresponding row is absent,
that row becomes present: its deletion timestamp is set to NULL.

Arguments:

    pDB - dbpos with link cursor on value to be checked
    dwEventCode - Message describing operation, to be logged
    pAC - attcache of attribute to be checked
    fResetDelTime - true if deletion time should be reset
    pMetaDataRemote - remote metadata to be applied
Return Value:

    None

--*/

{
    VALUE_META_DATA metaDataLocal;
    BOOL fSuccess = FALSE;
    BOOL fTrackingValueMetadata;

    Assert(VALID_DBPOS(pDB));

    fTrackingValueMetadata = TRACKING_VALUE_METADATA( pDB );

    // See if we can skip this function
    if (!fTrackingValueMetadata) {
        return;
    }

    DPRINT1( 2, "dbSetLinkValuePresent, deltimereset = %d\n", fResetDelTime );

    JetPrepareUpdateEx(pDB->JetSessID,
                       pDB->JetLinkTbl, DS_JET_PREPARE_FOR_REPLACE );

    __try {
        // Set LINKDELTIMEID
        // By the magic of condition columns, the value will reappear in
        // the link and backlink indexes
        if (fResetDelTime) {
            JetSetColumnEx(pDB->JetSessID, pDB->JetLinkTbl,
                           linkdeltimeid, NULL, 0, 0, 0);
        }

        Assert(fTrackingValueMetadata);

        // PERF NOTE. The local metadata is not needed when the remote metadata
        // is present. The only thing DbSet needs to know in that case is whether
        // the record already exists. If we pass that in, we could eliminate this
        // read.
        DBGetLinkValueMetaData( pDB, pAC, &metaDataLocal );

        dbSetLinkValueMetaData( pDB, dwEventCode, pAC,
                                &metaDataLocal,
                                pMetaDataRemote, /* remotemetadata */
                                NULL /* time changed */ );

        JetUpdateEx( pDB->JetSessID, pDB->JetLinkTbl, NULL, 0, 0 );

        fSuccess = TRUE;

    } __finally {

        if (!fSuccess) {
            JetPrepareUpdate(pDB->JetSessID, pDB->JetLinkTbl, JET_prepCancel);
        }

    }

} /* dbSetLinkValuePresent */


void
dbSetLinkValueAbsent(
    IN DBPOS *pDB,
    IN DWORD dwEventCode,
    IN ATTCACHE *pAC,
    IN PUCHAR pVal,
    IN VALUE_META_DATA *pMetaDataRemote OPTIONAL
    )

/*++

Routine Description:

Mark an existing value as being absent.
The value must exist already, either present or absent.

    NOTE! NOTE! NOTE!
    If this routine is used by fDRA, we must not optimize out the updating
    of the metadata if the value is already absent.  This is true for the
    caller as well. The caller must look up the value in such a way that
    absent values are found.  Finding it absent, it must still touch the
    metadata.

    From the LVR Spec, section on "Originating Writes"

If the originating write is a deletion, the immediate effect is to change the
row into an absent value. (Later on the absent value may be garbage collected;
how that works is not part of this description.) An absent value has a non-NULL
deletion timestamp. During the originating write that performs the deletion,
the deletion timestamp is set to max(creation timestamp, current time). This
guarantees that the creation timestamp for a row is always <= the deletion
timestamp for that row.  This deletion timestamp is used as the update timestamp
for the originating write.

Arguments:

    pDB - database position
    dwEventCode - message id to log
    pAC - which attribute the linked value belongs
    pVal - The contents of the link
    pMetaDataRemote - Remote metadata to be applied

Return Value:

    None

--*/

{
    DSTIME timeCurrent, timeCreated, timeDeleted;
    VALUE_META_DATA metaDataLocal;
    BOOL fSuccess = FALSE, fTrackingValueMetadata;

    Assert(VALID_DBPOS(pDB));

    DPRINT( 2, "dbSetLinkValueAbsent\n" );

    fTrackingValueMetadata = TRACKING_VALUE_METADATA( pDB );

    // If not tracking value metadata, perform old behavior
    if (!fTrackingValueMetadata) {

#if DBG
        // I believe its the case that we should never attempt to remove a
        // row with metadata. This is because when we are not tracking metadata,
        // we use a special index which hides metadata-ful rows, and thus it
        // should never be a candidate for removal. Still, let's be paranoid.
        DBGetLinkValueMetaData( pDB, pAC, &metaDataLocal );
        Assert( IsLegacyValueMetaData( &metaDataLocal ) );
#endif

        dbAdjustRefCountByAttVal(pDB, pAC, pVal, sizeof(DWORD), -1);

        JetDeleteEx(pDB->JetSessID, pDB->JetLinkTbl);

        return;
    }

    JetPrepareUpdateEx(pDB->JetSessID,
                       pDB->JetLinkTbl, DS_JET_PREPARE_FOR_REPLACE );

    __try {
        DBGetLinkValueMetaData( pDB, pAC, &metaDataLocal );

        timeCurrent = DBTime();

        if (pMetaDataRemote) {
            // Use the incoming time of deletion
            timeDeleted = pMetaDataRemote->MetaData.timeChanged;
        } else {
            // Set to maximum of timeCurrent and creationTime

            timeCreated = metaDataLocal.timeCreated;
            if (timeCreated > timeCurrent) {
                timeDeleted = timeCreated;
            } else {
                timeDeleted = timeCurrent;
            }
        }

        // We unconditionally mark the value absent, even it it happens to have
        // been marked before.  This keeps the deletion time approximately in
        // sync with the meta data time changed.

        // Set LINKDELTIMEID
        // By the magic of condition columns, the value will cease to appear in
        // the link and backlink indexes
        JetSetColumnEx(pDB->JetSessID, pDB->JetLinkTbl,
                       linkdeltimeid, &timeDeleted, sizeof(timeDeleted), 0, 0);

#if DBG
        {
            CHAR szTime[SZDSTIME_LEN];
            DPRINT1( 4, "deltime = %s\n",
                     DSTimeToDisplayString(timeDeleted, szTime) );
        }
#endif

        dbSetLinkValueMetaData( pDB, dwEventCode, pAC,
                                &metaDataLocal,
                                pMetaDataRemote,
                                &timeCurrent /* time changed*/ );

        JetUpdateEx( pDB->JetSessID, pDB->JetLinkTbl, NULL, 0, 0 );

        fSuccess = TRUE;

    } __finally {

        if (!fSuccess) {
            JetPrepareUpdate(pDB->JetSessID, pDB->JetLinkTbl, JET_prepCancel);
        }

    }
} /* dbSetLinkValueAbsent */

/*++
    Description:
      Walks forward over N rows in the link table, then verifies that we are
      still on the attribute passed in.  If we are, we return the value.  Note
      that we DO NOT verify that we are on the correct attribute in the first
      place.

      The main difference between this routine and dbGetLinkVal is that the
      offset here is relative to current position, the offset in dbGetLinkVal is
      an absolute offset from the first value of the attribute.
--*/
DWORD
dbGetNthNextLinkVal(
        DBPOS * pDB,
        ULONG sequence,
        ATTCACHE **ppAC,
        DWORD Flags,
        ULONG InBuffSize,
        PUCHAR *ppVal,
        ULONG *pul
        )
{
    THSTATE     *pTHS=pDB->pTHS;
    BYTE        *rgb = NULL;
    INTERNAL_SYNTAX_DISTNAME_STRING *pBlob;
    JET_ERR     err;
    ULONG       ulValueDnt = 0;
    ULONG       ulRecLinkBase = 0;
    ULONG       cb;
    ULONG       ulObjectDnt = 0;
    ULONG       targetDNT;
    ATTCACHE    *pAC;
    BOOL        fIsBacklink;

    Assert( ppAC );
    pAC = *ppAC; // pAC may now be NULL

    if(Flags & DBGETATTVAL_fUSESEARCHTABLE) {
        targetDNT = pDB->SDNT;
    }
    else {
        targetDNT = pDB->DNT;
    }


    Assert(VALID_DBPOS(pDB));

    if(sequence) {
        // not the first value - move to the next value
        if (JetMoveEx(pDB->JetSessID, pDB->JetLinkTbl, sequence, 0)) {
            return DB_ERR_NO_VALUE;
        }
    }

    fIsBacklink = pAC ? FIsBacklink(pAC->ulLinkID) : FALSE;

    // test to verify that we found a qualifying record
    dbGetLinkTableData (pDB,
                        fIsBacklink,
                        FALSE,
                        &ulObjectDnt,
                        &ulValueDnt,
                        &ulRecLinkBase);

    if (ulObjectDnt != targetDNT) {
        DPRINT(2, "dbGetNthNextLinkVal: no values\n");
        return DB_ERR_NO_VALUE;
    }
    if (pAC) {
        ULONG ulLinkBase = MakeLinkBase(pAC->ulLinkID);
        if (ulLinkBase != ulRecLinkBase) {
            DPRINT(2, "dbGetNthNextLinkVal: no values\n");
            return DB_ERR_NO_VALUE;
        }
    } else {
        ULONG ulNewLinkID = MakeLinkId(ulRecLinkBase);

        pAC = SCGetAttByLinkId(pDB->pTHS, ulNewLinkID);
        if (!pAC) {
            DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, ulNewLinkID);
        }
        *ppAC = pAC;  // Return new pAC to caller
    }

    // found a valid record - return a value

    switch (pAC->syntax) {
    case SYNTAX_DISTNAME_TYPE:
        if(Flags & DBGETATTVAL_fCONSTANT) {
            // Existing buffer, better be room.  We'll check later.
        }
        else if(Flags & DBGETATTVAL_fREALLOC) {
            if(InBuffSize < sizeof(ulValueDnt)) {
                // Reallocable buffer,
                *ppVal = THReAllocEx(pTHS, *ppVal, sizeof(ulValueDnt));
                InBuffSize = sizeof(ulValueDnt);
            }
        }
        else {
            // No buffer.
            *ppVal = THAllocEx(pTHS, sizeof(ulValueDnt));
            InBuffSize = sizeof(ulValueDnt);
        }

        if(InBuffSize < sizeof(ulValueDnt))
            return DB_ERR_BUFFER_INADEQUATE;

        *pul = sizeof(ulValueDnt);
        *((ULONG *)(*ppVal)) = ulValueDnt;
        return 0;


    case SYNTAX_DISTNAME_BINARY_TYPE:
    case SYNTAX_DISTNAME_STRING_TYPE:
        // Build an internal version of this data type
        // Note, we don't retrieve from index because the index
        // truncates the data.
        if (JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                      linkdataid,
                                      NULL, 0, &cb, 0, NULL) ==
            JET_wrnBufferTruncated) {
            // data portion of the OR name exists -allocate space and read it

            rgb = THAllocEx(pTHS,cb);
            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                                     linkdataid, rgb, cb,
                                     &cb, 0, NULL);
        }
        else {
            cb = 0;
        }

        // How much buffer we gonna need?
        *pul = sizeof(ulValueDnt) + cb;

        if(Flags & DBGETATTVAL_fCONSTANT) {
            // Existing buffer, better be room.  We'll check later.
        }
        else if(Flags & DBGETATTVAL_fREALLOC) {
            if(InBuffSize < *pul) {
                // Reallocable buffer,
                *ppVal = THReAllocEx(pTHS, *ppVal, *pul);
                InBuffSize = *pul;
            }
        }
        else {
            // No buffer.
            *ppVal = THAllocEx(pTHS, *pul);
            InBuffSize = *pul;
        }

        if(InBuffSize < *pul)
        {
            if (rgb) { 
                THFreeEx(pTHS,rgb); 
            }
            return DB_ERR_BUFFER_INADEQUATE;
        }

        pBlob = (INTERNAL_SYNTAX_DISTNAME_STRING *) *ppVal;
        pBlob->tag = ulValueDnt;
        memcpy(&pBlob->data,rgb,cb);
        Assert(pBlob->data.structLen == cb);
        if (rgb) { 
            THFreeEx(pTHS,rgb); 
        }

        return 0;

    default:

        // all other syntaxes must have some value in the link data
        // Note, we don't retrieve from index because the index
        // truncates the data.

        if ((err=JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                           linkdataid,
                                           NULL, 0, pul, 0, NULL)) !=
            JET_wrnBufferTruncated) {
            DsaExcept(DSA_DB_EXCEPTION, err, linkdataid);
        }

        if(Flags & DBGETATTVAL_fCONSTANT) {
            // Existing buffer, better be room.  We'll check later.
        }
        else if(Flags & DBGETATTVAL_fREALLOC) {
            if(InBuffSize < *pul) {
                // Reallocable buffer,
                *ppVal = THReAllocEx(pTHS, *ppVal, *pul);
                InBuffSize = *pul;
            }
        }
        else {
            // No buffer.
            *ppVal = THAllocEx(pTHS, *pul);
            InBuffSize = *pul;
        }

        if(*pul > InBuffSize)
            return DB_ERR_BUFFER_INADEQUATE;

        JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl, linkdataid,
                                 *ppVal, *pul, pul, 0, NULL);

        return 0;
    }
}

/*++
    Description:
      Gets the Nth link attribute value for the attribute passed in.  The
      sequence number passed in is expected to be 1 indexed.  This routine seeks
      to the first value for the attribute, then calls dbGetNthNextLinkVal.
      This routine uses absolute positioning from the beginning of the values
      for the attribute, the other routine uses relative positioning.
--*/
DWORD APIENTRY
dbGetLinkVal(
        DBPOS * pDB,
        ULONG sequence,
        ATTCACHE **ppAC,
        DWORD Flags,
        ULONG InBuffSize,
        PUCHAR *ppVal,
        ULONG *pul)
{
    JET_ERR     err;
    DWORD       targetDNT;
    LPSTR       pszIndexName;
    ATTCACHE    *pAC;

    Assert( ppAC );
    pAC = *ppAC; // pAC may now be null

    if(Flags & DBGETATTVAL_fUSESEARCHTABLE) {
        targetDNT = pDB->SDNT;
    }
    else {
        targetDNT = pDB->DNT;
    }

    Assert(VALID_DBPOS(pDB));

    // Sequences in the link table are 0 based, 1 based in the data table
    Assert( sequence );
    sequence--;

    DPRINT(2, "dbGetLinkVal entered\n");


    if ( pAC && (FIsBacklink(pAC->ulLinkID)) ) {
        // backlink
        if (Flags & DBGETATTVAL_fINCLUDE_ABSENT_VALUES) {
            pszIndexName = SZBACKLINKALLINDEX;
        } else {
            pszIndexName = SZBACKLINKINDEX;
        }
    }
    else {
        //link
        if (Flags & DBGETATTVAL_fINCLUDE_ABSENT_VALUES) {
            pszIndexName = SZLINKALLINDEX;
        } else {
            pszIndexName =
                (pDB->fScopeLegacyLinks ? SZLINKLEGACYINDEX : SZLINKINDEX);
        }
    }
    JetSetCurrentIndexSuccess(pDB->JetSessID, pDB->JetLinkTbl, pszIndexName );


    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                 &(targetDNT), sizeof(targetDNT), JET_bitNewKey);

    if (pAC) {
        ULONG ulLinkBase = MakeLinkBase(pAC->ulLinkID);

        JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                     &ulLinkBase, sizeof(ulLinkBase), 0);
    }

    // seek
    if (((err = JetSeekEx(pDB->JetSessID, pDB->JetLinkTbl, JET_bitSeekGE))
         !=  JET_errSuccess) &&
        (err != JET_wrnRecordFoundGreater)) {
        return DB_ERR_NO_VALUE;
    }

    return dbGetNthNextLinkVal(pDB, sequence, ppAC, Flags, InBuffSize, ppVal,
                               pul);
}


DB_ERR
DBGetNextLinkValForLogon(
        DBPOS   FAR * pDB,
        BOOL    bFirst,
        ATTCACHE * pAC,
        PULONG  pulDNTNext
        )
/*-------------------------------------------------------------------------

  This routine provides a fast path in the system to build a transtitive
  reverse membership evaluation routine that recurses through the link
  table with a minimum of additional overhead

  If bFirst is TRUE, this routine positions on the first value of the requested
  attribute. If it is FALSE, then we move forward 1 in the link table and get
  that value

  This routine always gives out DNT's that

    return 0 - found value
    return DB_ERR_ONLY_ON_LINKED_ATTRIBUTE - called on a non linked attribute
                                        other than the one requested.
    return DB_ERR_NO_VALUE - didn't find value
-----------------------------------------------------------------------------*/
{
    THSTATE            *pTHS=pDB->pTHS;
    JET_ERR             err=0;
    ULONG               ulObjectDnt;
    ULONG               targetDNT  = pDB->DNT;
    ULONG               ulLinkBase = MakeLinkBase(pAC->ulLinkID);
    ULONG               ulRecLinkBase = 0;

     // First, verify that the att passed in is a link/backlink.
    if (!pAC->ulLinkID) {
        return DB_ERR_ONLY_ON_LINKED_ATTRIBUTE;
    }

    if (bFirst)
    {
        //
        // We need to seek to the record with the right DNT
        //



        if (FIsBacklink(pAC->ulLinkID))
        {
            // backlink
           JetSetCurrentIndexSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                                     SZBACKLINKINDEX);
        }
        else
        {
            //link
            JetSetCurrentIndexSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                   (pDB->fScopeLegacyLinks ? SZLINKLEGACYINDEX : SZLINKINDEX));
        }


        JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                     &(targetDNT), sizeof(targetDNT), JET_bitNewKey);

        JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                     &ulLinkBase, sizeof(ulLinkBase), 0);

        // seek
        if (((err = JetSeekEx(pDB->JetSessID, pDB->JetLinkTbl, JET_bitSeekGE))
             !=  JET_errSuccess) &&
            (err != JET_wrnRecordFoundGreater))
        {
            return DB_ERR_NO_VALUE;
        }
    }
    else
    {
        //
        // Move forward by 1
        //

        if (JetMoveEx(pDB->JetSessID, pDB->JetLinkTbl, 1, 0)) {
            return DB_ERR_NO_VALUE;
        }
    }

    //
    // Retrieve the link table data
    //

    dbGetLinkTableData (pDB,
                        FIsBacklink(pAC->ulLinkID),
                        FALSE,
                        &ulObjectDnt,
                        pulDNTNext,
                        &ulRecLinkBase);

    if ((ulObjectDnt != targetDNT) || (ulLinkBase != ulRecLinkBase))
    {
        return DB_ERR_NO_VALUE;
    }

    return(0);
}




/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Get the first or next value for a link attribute.
   A non-zero return indicates that the requested value doesn't exist.

   If bFirst is TRUE, this routine positions on the first value of the requested
   attribute.  If it is FALSE, then we move forward 1 in the link table and get
   that value.

   The caller can choose to have values returned in internal or external
   format.

   return 0 - found value
   return DB_ERR_ONLY_ON_LINKED_ATTRIBUTE - called on a non linked attribute
   return DB_ERR_NOT_ON_CORRECT_VALUE - called when positioned on some attribute
                                        other than the one requested.
   return DB_ERR_NO_VALUE - didn't find value
   return DB_ERR_BUFFER_INADEQUATE - buffer provided was not big enough
   return DB_ERR_UNKNOWN_ERROR - some other error

   NOTE!!!! This routine does not pass any SecurityDescriptorFlags to the
   internal to external data format conversions.  What this means is that you
   will always get back ALL parts of a Security Descriptor using this routine.
   DBGetMultipeAtts is wired to use SecurityDescriptorFlags, if it is important
   to you to trim parts from the SD, use that routine.

*/
DB_ERR
DBGetNextLinkVal_AC (
        DBPOS FAR *pDB,
        BOOL bFirst,
        ATTCACHE *pAC,
        DWORD Flags,
        ULONG InBuffSize,
        ULONG *pLen,
        UCHAR **ppVal
        )
{
    return
        DBGetNextLinkValEx_AC(
            pDB,
            bFirst,
            1,
            &pAC,
            Flags,
            InBuffSize,
            pLen,
            ppVal
            );
}



DB_ERR
DBGetNextLinkValEx_AC (
    DBPOS FAR *pDB,
    BOOL bFirst,
    DWORD Sequence,
    ATTCACHE **ppAC,
    DWORD Flags,
    ULONG InBuffSize,
    ULONG *pLen,
    UCHAR **ppVal
    )

/*++

Routine Description:

Position on the first or next link value.
Retrieve the internal value.
Convert to extern form if desired.

Arguments:

    pDB - DBPOS. Currency is on the object being searched.
    bFirst - If TRUE, position on the first value for the attribute. If
             FALSE, must already be on a value. Move forward by sequence.
    Sequence - if bFirst, Sequence > 0, seek to first, move forward sequence-1
               if !bFirst, Sequence >=0, no seek, move forward sequence
               bFirst = FALSE, Sequence == 0 may be used to re-read a value
    ppAC - Pointer to ATTCACHE. If ATTCACHE is non NULL, it is the 
          ATTCACHE of linked attribute on this object whose value is
          to be retrieved.  If ATTCACHE is NULL, it is filled with
          new ATTCACHE of record found.
    Flags - One or more of DBGETATTVAL_* from dbglobal.h
    InBuffSize - Size of previously allocated buffer pointed to by *ppVal.
                 Usually set when using DBGETATTVAL_REALLOC.
    pLen - Out. Length of data allocated or returned in *ppVal.
    ppVal - In/Out. Pointer to buffer. May be alloc'd or realloc'd

Return Value:

    DB_ERR - Errors from dbGetLinkVal or dbGetNthNextLinkVal

--*/

{
    THSTATE            *pTHS=pDB->pTHS;
    JET_ERR             err;
    ULONG               actuallen = 0;
    int                 rtn;
    BOOL                MakeExt=!(Flags & DBGETATTVAL_fINTERNAL);
    DWORD               dwSyntaxFlag = 0;
    ATTCACHE            *pAC;

    Assert(ppAC);
    pAC = *ppAC;
    // pAC may be null at this point

    // First, verify that the att passed in is a link/backlink.
    if (pAC) {
        if (!pAC->ulLinkID) {
            return DB_ERR_ONLY_ON_LINKED_ATTRIBUTE;
        }
        DPRINT2(2, "DBGetNextLinkVal_AC entered, fetching 0x%x (%s)\n",
                pAC->id, pAC->name);
    }

    if(Flags & DBGETATTVAL_fSHORTNAME) {
        dwSyntaxFlag = INTEXT_SHORTNAME;
    }
    else if(Flags &  DBGETATTVAL_fMAPINAME) {
        dwSyntaxFlag = INTEXT_MAPINAME;
    }

    Assert(VALID_DBPOS(pDB));
    Assert(!(Flags & DBGETATTVAL_fCONSTANT) || ((PUCHAR)pLen != *ppVal));

    if (!InBuffSize && (Flags & DBGETATTVAL_fREALLOC)) {
        // We have been given permission to realloc, but nothing has been
        // alloced.  This is the same case as if we were not given realloc
        // permission and so must just alloc.  Unset the realloc flag, leaving
        // us at the default behaviour, which is to alloc.
        Flags = Flags & ~DBGETATTVAL_fREALLOC;
    }

    if(!(Flags & DBGETATTVAL_fCONSTANT) && !(Flags & DBGETATTVAL_fREALLOC)) {
        // Since we don't have a currently existing buffer, make sure the
        // InBuffSize is 0
        InBuffSize = 0;
    }

    // Get the attribute value from the link table.
    if(bFirst) {
        // Position on the first element
        err = dbGetLinkVal(pDB,
                           Sequence,
                           ppAC,
                           Flags,
                           InBuffSize,
                           ppVal,
                           &actuallen);
    }
    else {
        ULONG            ulObjectDnt = 0, ulRecLinkBase = 0;
        ULONG            ulLinkBase;
        ULONG       targetDNT;
        BOOL        fIsBacklink;

        if(Flags & DBGETATTVAL_fUSESEARCHTABLE) {
            targetDNT = pDB->SDNT;
        }
        else {
            targetDNT = pDB->DNT;
        }

        fIsBacklink = pAC ? FIsBacklink(pAC->ulLinkID) : FALSE;

        dbGetLinkTableData (pDB,
                            fIsBacklink,
                            FALSE,
                            &ulObjectDnt,
                            NULL,
                            &ulRecLinkBase);
        if (pAC) {
            ulLinkBase = MakeLinkBase(pAC->ulLinkID);
        } else {
            // Disable the check on attribute id
            ulLinkBase = ulRecLinkBase;
        }

        if ((ulObjectDnt != targetDNT) || (ulLinkBase != ulRecLinkBase)) {
            DPRINT(2, "DBGetNextLinkVal_AC: not on a value!\n");
            return DB_ERR_NOT_ON_CORRECT_VALUE;
        }

        // move forward 1 and get the next value.
        err = dbGetNthNextLinkVal(pDB,
                                  Sequence,
                                  ppAC,
                                  Flags,
                                  InBuffSize,
                                  ppVal,
                                  &actuallen);
    }

    if(err) {
        return err;
    }

    // Read newly found attribute
    pAC = *ppAC;
    Assert(pAC);  // pAC no longer null

    // DBGetNextLinkVal makes sure that a big enough buffer already exists, so
    // set the InBuffSize to be big enough here so that we pass the checks
    // we make later during conversion to external format.
    InBuffSize = max(InBuffSize,actuallen);

    *pLen = actuallen;

    // Convert DB value to external format if so desired.

    if (MakeExt) {
        ULONG extLen;
        PUCHAR pExtVal=NULL;

        if (rtn = gDBSyntax[pAC->syntax].IntExt (
                pDB,
                DBSYN_INQ,
                *pLen,
                *ppVal,
                &extLen,
                &pExtVal,
                0, 0,
                dwSyntaxFlag)) {
            DsaExcept(DSA_EXCEPTION, DIRERR_BAD_ATT_SYNTAX, rtn);
        }

        if(Flags & DBGETATTVAL_fCONSTANT) {
            // Existing buffer, better be room.  We'll check later.
        }
        else {
            if(InBuffSize < extLen &&
               *pLen < extLen) {
                // Reallocable buffer,
                *ppVal = THReAllocEx(pTHS, *ppVal, extLen);
                InBuffSize = extLen;
            }
        }

        if(InBuffSize < extLen) {
            return DB_ERR_BUFFER_INADEQUATE;
        }

        *pLen = extLen;

        memcpy(*ppVal, pExtVal, extLen);
    }

    DPRINT1(2,"DBGetNextLinkVal_AC: complete  val:<%s>\n",
            asciiz(*ppVal,(USHORT)*pLen));
    return 0;

} /* DBGetNextLinkValEx_AC  */





VOID
dbInsertIntLinkVal(
    DBPOS FAR *pDB,
    ATTCACHE *pAC,
    ULONG ulDnt,
    ULONG ulLinkBase,
    ULONG ulBacklinkDnt,
    VOID *pvData,
    ULONG cbData,
    BOOL fPresent,
    IN VALUE_META_DATA *pMetaDataRemote OPTIONAL
    )

/*++

Routine Description:

    Common routine to insert a new link record.
    The initial state of present or absent may be set.
    It is assumed that we have already checked and the record not exist.

    It is assumed that a refcount has already been added by our caller.

Arguments:

    pDB - 
    ulDnt - 
    ulLinkBase - 
    ulBacklinkDnt - 
    cbData - 
    pvData - 
    fPresent - 

Return Value:

    NONE, exceptions raised for error conditions

--*/

{
    BOOL fSuccess = FALSE, fTrackingValueMetadata;
    DWORD dwEventCode;
    CHAR szTime[SZDSTIME_LEN];
    DSTIME timeCurrent, timeDeleted;

    fTrackingValueMetadata = TRACKING_VALUE_METADATA( pDB );

    DPRINT2( 2, "dbInsertIntLinkVal, obj=%s, value=%s\n",
             GetExtDN( pDB->pTHS, pDB ),
             DBGetExtDnFromDnt( pDB, ulBacklinkDnt ) );

    // prepare for inserting new record in link table
    JetPrepareUpdateEx(pDB->JetSessID,
                       pDB->JetLinkTbl, JET_prepInsert);

    __try {
        JetSetColumnEx(pDB->JetSessID, pDB->JetLinkTbl,
                       linkdntid, &(pDB->DNT), sizeof(pDB->DNT), 0, 0);
        JetSetColumnEx(pDB->JetSessID, pDB->JetLinkTbl,
                       linkbaseid, &ulLinkBase, sizeof(ulLinkBase), 0, 0);
        JetSetColumnEx(pDB->JetSessID, pDB->JetLinkTbl,
                       backlinkdntid, &ulBacklinkDnt, sizeof(ulBacklinkDnt), 0, 0);

        // set link data - only if it exists

        if (cbData) {
            // A length of zero indicates the data is null
            JetSetColumnEx(pDB->JetSessID, pDB->JetLinkTbl,
                           linkdataid, pvData, cbData, 0, 0 );
        }

        timeCurrent = DBTime();

        if (fPresent) {
            //
            // Create record in the present state
            //
            dwEventCode = DIRLOG_LVR_SET_META_INSERT_PRESENT;

        } else {
            //
            // Create record in absent state
            //

            if (!fTrackingValueMetadata) {
                Assert( !"Can't apply value metadata when not in proper mode!" );
                DsaExcept(DSA_DB_EXCEPTION, ERROR_DS_INTERNAL_FAILURE, 0);
            }

            if (pMetaDataRemote) {
                // Use the incoming time of deletion
                timeDeleted = pMetaDataRemote->MetaData.timeChanged;
            } else {
                // Set to maximum of timeCurrent and creationTime
                timeDeleted = timeCurrent;
            }

            JetSetColumnEx(pDB->JetSessID, pDB->JetLinkTbl,
                           linkdeltimeid, &timeDeleted, sizeof(timeDeleted), 0, 0);

            DPRINT1( 4, "deltime = %s\n",
                     DSTimeToDisplayString(timeDeleted, szTime) );

            dwEventCode = DIRLOG_LVR_SET_META_INSERT_ABSENT;
        }

        if (fTrackingValueMetadata) {
            dbSetLinkValueMetaData( pDB, dwEventCode, pAC,
                                    NULL, /*local metadata */
                                    pMetaDataRemote, /*remote metadata*/
                                    &timeCurrent /* time changed */ );
        }

        // update the database
        JetUpdateEx(pDB->JetSessID, pDB->JetLinkTbl, NULL, 0, 0);

        fSuccess = TRUE;

    } __finally {

        if (!fSuccess) {
            JetPrepareUpdate(pDB->JetSessID, pDB->JetLinkTbl, JET_prepCancel);
        }

    }
} /* dbInsertIntLinkVal */


VOID
dbDecodeInternalDistnameSyntax(
    IN ATTCACHE *pAC,
    IN VOID *pIntVal,
    IN DWORD intLen,
    OUT DWORD *pulBacklinkDnt,
    OUT DWORD *pulLinkBase,
    OUT PVOID *ppvData,
    OUT DWORD *pcbData
    )

/*++

Routine Description:

    Decode an internal form of a distname depending on the syntax

Arguments:

    pAC - 
    pIntVal - 
    pulBacklinkDnt - 
    pulLinkBase - 
    ppvData - 
    pcbData - 

Return Value:

    None

--*/

{
    *pulLinkBase = MakeLinkBase(pAC->ulLinkID);

    // The link attribute can be of syntax DN or the two DISTNAME + data
    // syntaxes.  We handle them a little differently

    switch (pAC->syntax) {
    case SYNTAX_DISTNAME_TYPE:
        *pulBacklinkDnt = *((ULONG *) pIntVal);
        *ppvData = NULL;
        *pcbData = 0;
        break;

    case SYNTAX_DISTNAME_STRING_TYPE:
    case SYNTAX_DISTNAME_BINARY_TYPE:
    {
        INTERNAL_SYNTAX_DISTNAME_STRING *pBlob =
            (INTERNAL_SYNTAX_DISTNAME_STRING *) pIntVal;
        *pulBacklinkDnt = pBlob->tag;
        *ppvData = &pBlob->data;
        *pcbData = pBlob->data.structLen;
        break;
    }
    default:    // all other syntaxes
        *ppvData = pIntVal;
        *pcbData = (ULONG) intLen;
        *pulBacklinkDnt = 0;
        break;
    }
} /* dbDecodeInternalDistnameSyntax */


BOOL
dbFindIntLinkVal(
    DBPOS FAR *pDB,
    ATTCACHE *pAC,
    ULONG intLen,
    void *pIntVal,
    OUT BOOL *pfPresent
    )

/*++

Routine Description:

Position on the given internal form of the link value

Arguments:

    pDB - 
    pAC - 
    intLen - 
    pIntVal - 
    pfPresent - Only valid on success

Return Value:

    BOOL - 

--*/

{
    void *pvData;
    ULONG cbData, ulBacklinkDnt, ulLinkBase;
    BOOL fFound;

    // Only for linked attributes right now
    Assert( pAC->ulLinkID );

    Assert(VALID_DBPOS(pDB));

    dbDecodeInternalDistnameSyntax( pAC, pIntVal, intLen,
                                    &ulBacklinkDnt,
                                    &ulLinkBase,
                                    &pvData,
                                    &cbData );

    // We've got to have either a valid DNT, data, or both
    Assert(ulBacklinkDnt || cbData);

    fFound = dbPositionOnExactLinkValue(
            pDB,
            pDB->DNT,
            ulLinkBase,
            ulBacklinkDnt,
            pvData,
            cbData,
            pfPresent );

    DPRINT3( 2, "dbFindIntLinkVal, obj=%s, value=%s, found=%d\n",
             GetExtDN( pDB->pTHS, pDB ),
             DBGetExtDnFromDnt( pDB, ulBacklinkDnt ),
             *pfPresent );

    return fFound;
} /* dbFindIntLinkVal */

DWORD
dbAddIntLinkVal (
        DBPOS FAR *pDB,
        ATTCACHE *pAC,
        ULONG intLen,
        void *pIntVal,
        IN VALUE_META_DATA *pMetaDataRemote OPTIONAL
        )
/*++

Routine Description:

    Add an internal link attribute value to the current object.

    It is assumed that a refcount has already been added by our caller.

--*/
{
    JET_ERR      err;
    void         *pvData;
    ULONG        cbData;
    ULONG        ulBacklinkDnt;
    ULONG        ulLinkBase;
    BOOL         fPresent;

    DPRINT1(2, "dbAddIntLinkVal entered, add value <%s>\n", asciiz(pIntVal, (USHORT)intLen));

    Assert(VALID_DBPOS(pDB));

    Assert(pAC->ulLinkID);

    // The link base is a number that should be the same for links and
    // backlinks. This is achieved by assuming that for LinkBase N, the
    // link ID of the link attribute is 2N , and the link ID of the backlink
    // is 2N+1. Furthermore, for security reasons and for avoiding weird
    // undesirable situations that might occur because of one-way interdomain
    // replication, we disallow setting backlink attributes.


    if (FIsBacklink(pAC->ulLinkID))
        return DB_ERR_NOT_ON_BACKLINK;

    dbDecodeInternalDistnameSyntax( pAC, pIntVal, intLen,
                                    &ulBacklinkDnt,
                                    &ulLinkBase,
                                    &pvData,
                                    &cbData );

    // We've got to have either a valid DNT, data, or both
    Assert(ulBacklinkDnt || cbData);

    // See if there is an absent value we can make present

    if (dbPositionOnExactLinkValue( pDB, pDB->DNT, ulLinkBase, ulBacklinkDnt,
                     pvData, cbData, &fPresent ) ) {

        // Record does exist

        // Do not optimize out for replicator
        if (pDB->pTHS->fDRA || (!fPresent)) {

            // The forward link already exists so no need to add another one.
            // Reverse the ref-count already added by our caller
            DBAdjustRefCount(pDB, ulBacklinkDnt, -1);

            dbSetLinkValuePresent( pDB,
                                   DIRLOG_LVR_SET_META_INSERT_MADE_PRESENT,
                                   pAC,
                                   (!fPresent), /*reset deltime*/
                                   pMetaDataRemote
                                   );
        } else {
            DPRINT(1, "dbAddIntLinkVal: Linked Value already exists\n");
            return DB_ERR_VALUE_EXISTS;
        }

    } else {

        // Record does not exist

        dbInsertIntLinkVal( pDB, pAC,
                            pDB->DNT, ulLinkBase, ulBacklinkDnt,
                            pvData, cbData, TRUE /*present*/,
                            pMetaDataRemote );
    }

    // Touch replication meta data for this attribute.
    // Never optimize this out for fDRA.
    DBTouchMetaData(pDB, pAC);

    // success

    return 0;
} // dbAddIntLinkVal

DWORD
dbRemIntLinkVal (
        DBPOS FAR *pDB,
        ATTCACHE *pAC,
        ULONG intLen,
        void *pIntVal,
        IN VALUE_META_DATA *pMetaDataRemote OPTIONAL
        )
/*++

Routine Description:

    Remove an internal link attribute value from the current object.

    Neither this routine nor its caller should decrement the ref count for the
    object that is the target of the link. That is because this routine does not
    remove the link, but actually marks it absent. The link is removed by the
    garbage collector at a later time.

    Two exceptions:
    1. If we are running not in LVR mode, then we will decrement the count and
    physically delete the link in dbSetLinkValueAbsent.
    2. The replicator can add a new link in the absent state. In this case it
    will use dbInsertIntLink, which will increment the ref count.
--*/
{
    JET_ERR      err;
    void         *pvData;
    ULONG        cbData;
    ULONG        ulBacklinkDnt;
    ULONG        ulLinkBase;
    BOOL         fPresent;

    DPRINT1(2, "dbRemIntLinkVal entered, add value <%s>\n", asciiz(pIntVal, (USHORT)intLen));

    Assert(VALID_DBPOS(pDB));

    Assert(pAC->ulLinkID);

    // The link base is a number that should be the same for links and
    // backlinks. This is achieved by assuming that for LinkBase N, the
    // link ID of the link attribute is 2N , and the link ID of the backlink
    // is 2N+1. Furthermore, for security reasons and for avoiding weird
    // undesirable situations that might occur because of one-way interdomain
    // replication, we disallow setting backlink attributes.


    if (FIsBacklink(pAC->ulLinkID))
        return DB_ERR_NOT_ON_BACKLINK;

    dbDecodeInternalDistnameSyntax( pAC, pIntVal, intLen,
                                    &ulBacklinkDnt,
                                    &ulLinkBase,
                                    &pvData,
                                    &cbData );

    // We've got to have either a valid DNT, data, or both
    Assert(ulBacklinkDnt || cbData);

    // See if there is a present value we can make absent

    if (dbPositionOnExactLinkValue( pDB, pDB->DNT, ulLinkBase, ulBacklinkDnt,
                     pvData, cbData, &fPresent ) ) {

        // Record does exist

        // Do not optimize out for replicator
        if (pDB->pTHS->fDRA || (fPresent)) {
            dbSetLinkValueAbsent( pDB,
                                  DIRLOG_LVR_SET_META_REMOVE_VALUE_MADE_ABSENT,
                                  pAC, pIntVal,
                                  pMetaDataRemote );
        } else {
            DPRINT(1, "dbRemIntLinkVal: Linked Value already absent\n");
            return DB_ERR_VALUE_DOESNT_EXIST;
        }

    } else {

        // Record does not exist

        // Only the replicator can create a value in the absent state
        if (pDB->pTHS->fDRA) {

            // We are creating a new link so we need a ref-count added
            // on the target.
            DBAdjustRefCount(pDB, ulBacklinkDnt, 1);

            dbInsertIntLinkVal( pDB, pAC,
                                pDB->DNT, ulLinkBase, ulBacklinkDnt,
                                pvData, cbData, FALSE /*present*/,
                                pMetaDataRemote );

        } else {

            DPRINT(1, "dbRemIntLinkVal: Linked Value doesn't exist\n");
            return DB_ERR_VALUE_DOESNT_EXIST;

        }
    }

    // Touch replication meta data for this attribute.
    // Never optimize this out for fDRA.
    DBTouchMetaData(pDB, pAC);

    // success

    return 0;
} // dbRemIntLinkVal

// This is a public routine for other dblayer callers
// It has a simplified api compatible with existing code.
// It removes links for all attributes, in one direction.
// It supports restartability via the link cleaner
void
dbRemoveAllLinks(
        DBPOS *pDB,
        DWORD DNT,
        BOOL fIsBacklink
        )
/*++
  Description:
      Remove all links with the given DNT
      Being present or absent is ignored.
      Which attribute is also ignored. All links associated with this object
      are affected.
      The link is physically removed in a non-replicable way
      This is done regardless of whether we are tracking value metadata.

  Parameters:
    pDB - DBPOS to use.
    DNT - DNT of the phantom whose backlinks are being removed.
    fIsBacklink - Which index to use

  Returns:
    No return values.  It succeeds or excepts.
--*/
{
    BOOL fMoreLinks;

    fMoreLinks = DBRemoveAllLinksHelp_AC( pDB, DNT, NULL, fIsBacklink,
                                          gcLinksProcessedImmediately, NULL );
    if (fMoreLinks) {
        // Didn't clean up all the links - object needs cleaning
        DBSetObjectNeedsCleaning( pDB, TRUE );
    }
}

// This is a helper routine for all callers
// It supports the full range of functionality
DWORD
DBRemoveAllLinksHelp_AC(
        DBPOS *pDB,
        DWORD DNT,
        ATTCACHE *pAC,
        BOOL fIsBacklink,
        DWORD cLinkLimit,
        DWORD *pcLinksProcessed
        )
/*++
  Description:
      Remove all links with the given DNT
      Being present or absent is ignored.
      Which attribute is also ignored. All links associated with this object
      are affected.
      The link is physically removed in a non-replicable way
      This is done regardless of whether we are tracking value metadata.

  Parameters:
    pDB - DBPOS to use.
    DNT - DNT of the phantom whose backlinks are being removed.
    pAC - If present, restrict links to only this attribute
    fIsBacklink - Which index to use
    cLinkLimit - Maximum number of links to process.
                 Use 0xffffffff for infinite.
    pcLinksProcessed - Incremented for each link processed.
       Not cleared at start.

  Returns:
    BOOL - More data flag. TRUE means more data available
    It succeeds or excepts.
--*/
{
    JET_ERR          err;
    ULONG            ulObjectDnt = INVALIDDNT, 
                     ulValueDnt = INVALIDDNT;
    ULONG            ulLinkBase, ulNewLinkBase;
    DWORD            count;
    BOOL             fMoreData = TRUE;

    Assert( !pAC || ((ULONG) fIsBacklink) == FIsBacklink( pAC->ulLinkID ) );
    Assert(DNT != INVALIDDNT);
    PREFIX_ASSUME((DNT != INVALIDDNT), "parameters should be valid");

    // set the index
    if (fIsBacklink) {
        // This index sees all backlinks, present or absent
        JetSetCurrentIndexSuccess(pDB->JetSessID,
                                  pDB->JetLinkTbl,
                                  SZBACKLINKALLINDEX);
    } else {
        // This index sees all links, present or absent
        JetSetCurrentIndexSuccess(pDB->JetSessID,
                                  pDB->JetLinkTbl,
                                  SZLINKALLINDEX);
    }

    // find first matching record
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetLinkTbl,
                 &DNT,
                 sizeof(DNT),
                 JET_bitNewKey);
    if (pAC) {
        ulLinkBase = MakeLinkBase(pAC->ulLinkID);
        JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                     &ulLinkBase, sizeof(ulLinkBase), 0);
    }
    err = JetSeekEx(pDB->JetSessID,
                    pDB->JetLinkTbl,
                    JET_bitSeekGE);

    if ((err != JET_errSuccess) && (err != JET_wrnSeekNotEqual)) {
        // no records
        return FALSE;
    }

    // A word of explanation on linked value ref-counting. See dbsubj.c header for more.
    // For every linked value row, a ref-count is added to the dnt in the backlinkdnt
    // column. This is to say, the target of the forward link is reference counted. As
    // it says in dbsubj.c, the hosting-dn, which is also the target of the backlink, is
    // not ref-counted.
    // That said, we can enumerate links in this routine either of two ways.
    // If we are enumerating forward links, then we want to deref the backlinkdnt each
    // time we find a row.
    // If we are enumerating backward links, we can perform an optimization. Since we
    // are positioned on the object which will be in the backlinkdnt column for all of
    // the found records, and since this will always be the same dnt, we can deref
    // it once at the end.

    count = 0;
    while ( count < cLinkLimit ) {
        // test to verify that we found a qualifying record
        dbGetLinkTableData (pDB,
                            fIsBacklink,           // fIsBacklink
                            FALSE,
                            &ulObjectDnt,
                            &ulValueDnt,
                            &ulNewLinkBase);

        if ( (ulObjectDnt != DNT) ||
             ( (pAC != NULL) && (ulLinkBase != ulNewLinkBase) ) ) {
            // No more records.
            fMoreData = FALSE;
            break;
        }

        // update reference count and remove the record
        count++;
        if (!fIsBacklink) {
            DBAdjustRefCount(pDB, ulValueDnt, -1);

            DPRINT2( 2, "Forward Link Owner %s Target %s removed.\n",
                     DBGetExtDnFromDnt( pDB, ulObjectDnt ),
                     DBGetExtDnFromDnt( pDB, ulValueDnt ) );
            LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_GC_REMOVED_OBJECT_VALUE,
                     szInsertSz( DBGetExtDnFromDnt( pDB, ulValueDnt ) ),
                     szInsertSz( DBGetExtDnFromDnt( pDB, ulObjectDnt ) ),
                     NULL);

        } else {

            DPRINT2( 2, "Backward Link Owner %s Target %s removed.\n",
                     DBGetExtDnFromDnt( pDB, ulValueDnt ),
                     DBGetExtDnFromDnt( pDB, ulObjectDnt ) );
            LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_GC_REMOVED_OBJECT_VALUE,
                     szInsertSz( DBGetExtDnFromDnt( pDB, ulObjectDnt ) ),
                     szInsertSz( DBGetExtDnFromDnt( pDB, ulValueDnt ) ),
                     NULL);
        }

        JetDeleteEx(pDB->JetSessID,
                    pDB->JetLinkTbl);

        if (JET_errNoCurrentRecord ==
            JetMoveEx(pDB->JetSessID, pDB->JetLinkTbl, 1, 0)) {
            // No more records.
            fMoreData = FALSE;
            break;
        }
    }

    // If an exception is raised in the previous while loop, it is the caller's
    // duty not to commit the transaction, thus reversing the deletes and not
    // running into the problem that the reference counts were not adjusted.

    if ( (fIsBacklink) && (count) ) {
        DBAdjustRefCount(pDB, DNT, -((int)count));
    }

    if (pcLinksProcessed) {
        (*pcLinksProcessed) += count;
    }

    return fMoreData;
}


DWORD
DBPhysDelLinkVal(
    IN DBPOS *pDB,
    IN ULONG ulObjectDnt,
    IN ULONG ulValueDnt
    )

/*++

Routine Description:

Physically delete the value we are currently positioned on.

You must pass in the backlinkdnt which must have already been read.
Arguments:

    pDB - 
    ulValueDnt - Dnt being referenced by the forward link. Also called
                 the "backlink dnt".

Return Value:

   DWORD - error flag, 1 for error, 0 for success

--*/

{
    ULONG ulLinkDnt, ulBackLinkDnt, actuallen;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    DWORD err = 0;

#if DBG
    // Verify positioning
    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                             linkdntid,
                             &ulLinkDnt, sizeof(ULONG),
                             &actuallen, 0, NULL);
    
    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                             backlinkdntid,
                             &ulBackLinkDnt, sizeof(ULONG),
                             &actuallen, 0, NULL);
    if ( (ulObjectDnt != ulLinkDnt) || (ulValueDnt != ulBackLinkDnt) ) {
        Assert( !"Not positioned on correct object for delete" );
        return DB_ERR_VALUE_DOESNT_EXIST;
    }
#endif

    __try {
        // update reference count and remove the record
        DBAdjustRefCount(pDB, ulValueDnt, -1);

        JetDeleteEx(pDB->JetSessID, pDB->JetLinkTbl);
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        err = ulErrorCode;
        Assert(err);
    }

    return err;
} /* DBPhysDelValue */

// remove all link attributes - this should be done when deleting an object so
// that the backlinks don't show up in the interval between deletion and garbage
// collection
// This is a wrapper for non-dblayer callers
DWORD APIENTRY
DBRemoveLinks(DBPOS *pDB)
{
    ATTCACHE *pAC = NULL;
    ULONG SearchState = ATTRSEARCHSTATELINKS;
    BOOL fOldLegacyLinkState;

    DPRINT1( 2, "DBRemoveLinks, dnt = %d\n", pDB->DNT );

    // First remove all legacy values of forward link attributes and update the
    // legacy meta data of those attributes to signal an originating write.
    //
    // This is particularly important for object deletions (the only client
    // of this function).  It's true that when the deletion replicates to
    // another DSA that DSA will remove all linked values associated with the
    // object anyway, regardless of whether the inbound data tells it to do
    // so explicitly.  However, object resuscitation (e.g., when a DSA overrides
    // the replicated deletion of its own DSA object that was originated on
    // another DSA) in Win2k requires that all attributes removed during
    // deletion -- linked or not -- have their meta data touched during the
    // originating deletion.  Any attribute that is silently removed during the
    // originating deletion will not be overridden as part of resuscitation (see
    // use of fBadDelete in ReplReconcileRemoteMetaDataVector), and thus the
    // values of the attribute will not be revived on DSAs where the object was
    // at one time deleted (resulting in an inconsistency).
    //
    // Note that we cannot skip this step when in LVR mode, as legacy values of
    // linked attributes may still exist in LVR mode (i.e., if the values were
    // created before the switch to LVR replication).  And rather than create a
    // new mechanism, DSAs that understand LVR still depend on attribute-level
    // meta data for legacy linked attributes being updated during object
    // deletion in order for resuscitation to work correctly.

    fOldLegacyLinkState = pDB->fScopeLegacyLinks;
    pDB->fScopeLegacyLinks = TRUE;

    __try {
        while (!dbGetNextAtt(pDB, &pAC, &SearchState)
               && (ATTRSEARCHSTATELINKS == SearchState)) {
            if (dbHasAttributeMetaData(pDB, pAC)) {
                DBRemAtt_AC(pDB, pAC);
            }
        }
    } __finally {
        pDB->fScopeLegacyLinks = fOldLegacyLinkState;
    }

    // Remove the first 1,000 LVR forward links.  If any remain, mark the object
    // such that the rest are removed later.
    dbRemoveAllLinks( pDB, (pDB->DNT), FALSE /* use forward link */ );

    // Remove the first 1,000 back links (legacy and LVR).  If any remain,
    // mark the object such that the rest are removed later.
    dbRemoveAllLinks( pDB, (pDB->DNT), TRUE /* use backward link */ );

    return 0;
}

// Remove the forward links from a particular attribute of an object
// It is used when vaporizing a single attribute.
// This is a wrapper for non-dblayer callers
DWORD APIENTRY
DBRemoveLinks_AC(
    DBPOS *pDB,
    ATTCACHE *pAC
    )
{
    BOOL fMoreLinks;

    Assert( pAC );
    Assert( pAC->ulLinkID );
    DPRINT2( 2, "DBRemoveLinks_AC, dnt = %d, attr = %s\n",
             pDB->DNT, pAC->name );

    // Remove all forward links. These are attributes on this object which contain
    // values which are dn's of other objects.

    fMoreLinks = DBRemoveAllLinksHelp_AC(
        pDB, // object has currency
        pDB->DNT, // dnt to remove
        pAC, // Attribute to remove
        FALSE /*forward links */,
        gcLinksProcessedImmediately,  // how many to remove
        NULL // no processed count
        );
    if (fMoreLinks) {
        // Didn't clean up all the links - object needs cleaning
        DBSetObjectNeedsCleaning( pDB, TRUE );
    }

    return 0;
}


UCHAR *
dbGetExtDnForLinkVal(
    IN DBPOS * pDB
    )

/*++

Routine Description:

   Assume we are positioned on a link value.
   Assume we are on an index that contains the backlink dnt.
   Read the backlink dnt, and convert to printable form.

Arguments:

    pDB - 

Return Value:

    None

--*/

{
    DWORD ulValueDnt = INVALIDDNT;

    dbGetLinkTableData( pDB,
                        FALSE /*backlink*/,
                        FALSE /*bWarnings*/,
                        NULL /*ulObjectDnt*/,
                        &ulValueDnt,
                        NULL /*ulLinkBase */ );

    return DBGetExtDnFromDnt( pDB, ulValueDnt );
} /* GetExtDnForLinkVal */


DWORD
DBGetNextDelLinkVal(
    IN DBPOS FAR *pDB,
    IN DSTIME ageOutDate,
    IN OUT DSTIME *ptLastTime,
    IN OUT ULONG *pulObjectDnt,
    IN OUT ULONG *pulValueDnt
    )

/*++

Routine Description:

    Returns the next absent link value

    The reason we re-seek each time is that our index and position
    may be lost as part of committing the transaction.
    We form a UNIQUE key so that we can position on the next
    record to consider.

    Note that we make a best-effort attempt to be unique. To be 100% unique
    we would have to move the deletion time to the nanosecond granularity, 
    or include the linkbase and linkdata in the index. As it
    it is, if two values which differ only in data are deleted in the same
    second, only one will be found on a given pass of this algorithm. The other
    will be found on the next pass.

Arguments:

    pDB - 
    ageOutDate - dstime after which value is expired
    ptLastTime - in, last time found, out new time found
    pulObjectDnt - in, last object found, out new object
    pulValueDnt - in:last backlink found, out:new backlink

Return Value:

    DWORD - DB_ERR_* error status, not win32 status
    success - candidate found for deletion
    NO_MORE_DEL_RECORD - no more items found, end search
    others - error occurred

--*/

{
    JET_ERR  err;
    ULONG    actuallen;

    DBSetCurrentIndex( pDB, Idx_LinkDel, NULL, FALSE );

    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                 ptLastTime, sizeof(*ptLastTime),
                 JET_bitNewKey);
    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                 pulObjectDnt, sizeof(*pulObjectDnt), 0);
    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                 pulValueDnt, sizeof(*pulValueDnt), 0);

    if ((err = JetSeekEx(pDB->JetSessID, pDB->JetLinkTbl,
                         JET_bitSeekGT))         != JET_errSuccess)
    {
        DPRINT(5, "GetNextDelRecord search complete");
        return DB_ERR_NO_MORE_DEL_RECORD;
    }

    /* Retrieve DEL time from record */
    
    JetRetrieveColumnSuccess( pDB->JetSessID,
                              pDB->JetLinkTbl,
                              linkdeltimeid,
                              ptLastTime, sizeof(*ptLastTime),
                              &actuallen,JET_bitRetrieveFromIndex, NULL);
    
    // Get the two link ends

    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                             linkdntid,
                             pulObjectDnt, sizeof(ULONG),
                             &actuallen, JET_bitRetrieveFromIndex, NULL);
    
    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                             backlinkdntid,
                             pulValueDnt, sizeof(ULONG),
                             &actuallen, JET_bitRetrieveFromIndex, NULL);
    
    // Note, the records referred to by these DNTs may no longer exist
#if DBG
    {
        CHAR szTime[SZDSTIME_LEN], szTime1[SZDSTIME_LEN];
        DPRINT4( 2, "[%d,%d,%s,%s,DELETED]\n",
                 *pulObjectDnt,
                 *pulValueDnt,
                 DSTimeToDisplayString(*ptLastTime, szTime),
                 DSTimeToDisplayString(ageOutDate, szTime1) );
    }
#endif

    /* if time greater than target, there are no more eligible records */
    
    if (*ptLastTime > ageOutDate)
    {
        DPRINT(5, "GetNextDelLinkVal search complete");
        return DB_ERR_NO_MORE_DEL_RECORD;
    }
    
    return 0;
} /* DBGetNextDelLinkVal */

DWORD
DBTouchAllLinksHelp_AC(
        DBPOS *pDB,
        ATTCACHE *pAC,
        USN usnEarliest,
        BOOL fIsBacklink,
        DWORD cLinkLimit,
        DWORD *pcLinksProcessed
        )
/*++
  Description:

    Update the metadata on all links (present or absent), in a single
    direction (foward or backward), for the particular attribute.

    We use this function to authoritatively restore the links by forcing
    all of them to appear to be updated.

    We use USNs as a positioning context. We only touch links with USNs < x
    so that we don't retouch the same links if multiple passes are required
    to touch all the links. Note that we don't use times because we want to
    be immune to local clock changes.

  Parameters:
    pDB - DBPOS to use.
          We are assumed to be positioned on the object whose
          links are to be operated on.
    pAC - Restrict links to only this attribute. May be NULL.
    usnEarliest - Smallest usn permissable
    fIsBacklink - Which index should be used
    cLinkLimit - Maximum number of links to process.
                 Use 0xffffffff for infinite.
    pcLinksProcessed - Incremented for each link processed.
       Not cleared at start.

  Returns:
    BOOL - More data flag. TRUE means more data available
    It succeeds or excepts.
--*/
{

    JET_ERR          err;
    ULONG            ulObjectDnt = INVALIDDNT, 
                     ulValueDnt = INVALIDDNT;
    ULONG            ulLinkBase = 0, ulNewLinkBase = 0;
    DWORD            count;
    BOOL             fMoreData = TRUE;
    VALUE_META_DATA  metaDataLocal;
    DBPOS            *pDBForward;
    ATTCACHE         *pACForward;

    Assert(VALID_DBPOS(pDB));
    Assert( pDB->pTHS->fLinkedValueReplication );
    Assert( !pAC || ((ULONG) fIsBacklink) == FIsBacklink( pAC->ulLinkID ) );

    // set the index
    // Note that these indexes contain absent values. In the case of a group type
    // change, replicating absent values is consistent with a newly promoted GC,
    // which will have absent members. Also, in the case of object revival, it
    // is important to revive all links, not just present ones.

    if (fIsBacklink) {
        // This index sees all backlinks, present or absent
        JetSetCurrentIndexSuccess(pDB->JetSessID,
                                  pDB->JetLinkTbl,
                                  SZBACKLINKALLINDEX);
    } else {
        // This index sees all links, present or absent
        JetSetCurrentIndexSuccess(pDB->JetSessID,
                                  pDB->JetLinkTbl,
                                  SZLINKALLINDEX);
    }


    // find first matching record
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetLinkTbl,
                 &(pDB->DNT),
                 sizeof(pDB->DNT),
                 JET_bitNewKey);

    if (pAC) {
        ulLinkBase = MakeLinkBase(pAC->ulLinkID);
        JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                     &ulLinkBase, sizeof(ulLinkBase), 0);
        pACForward = pAC;
    }

    err = JetSeekEx(pDB->JetSessID,
                    pDB->JetLinkTbl,
                    JET_bitSeekGE);

    if ((err != JET_errSuccess) && (err != JET_wrnSeekNotEqual)) {
        // no records
        return FALSE;
    }

    count = 0;
    while ( count < cLinkLimit ) {
        // test to verify that we found a qualifying record
        dbGetLinkTableData (pDB,
                            fIsBacklink,           // fIsBacklink
                            FALSE,           // Warnings
                            &ulObjectDnt,
                            &ulValueDnt,
                            &ulNewLinkBase);

        if (ulObjectDnt != (pDB->DNT)) {
            // No more records.
            fMoreData = FALSE;
            break;
        }
        if (pAC) {
            // Attribute was specified, check we are still on it
            if (ulLinkBase != ulNewLinkBase) {
                // No more records.
                fMoreData = FALSE;
                break;
            }
        } else {
            // Attribute not specified, derive it from current link
            // Note that this derives the name of the *forward* link attribute
            // which may not exist on pDB if this is a backlink to him
            ULONG ulNewLinkID = MakeLinkId(ulNewLinkBase);

            pACForward = SCGetAttByLinkId(pDB->pTHS, ulNewLinkID);
            if (!pACForward) {
                DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, ulNewLinkID);
            }
        }

        // Touching metadata must proceed from the currency perspective of the
        // forward link holder. The link metadata routines are coded this way
        // and it seems simpler to keep them that way. Position a new DBPOS on
        // the forward link holder if necessary.

        if (fIsBacklink) {
            DBOpen2( FALSE /* not new trans */, &pDBForward );
            // Link table in new db should have same currency as old db

            // Reset vars from the point of view of the forward link holder
            Assert( ulObjectDnt == pDB->DNT );
            ulObjectDnt = ulValueDnt;
            ulValueDnt = pDB->DNT;
        } else {
            pDBForward = pDB;
        }
        __try {
            if (fIsBacklink) {
                BOOL fFound, fPresent;
                BYTE *rgb = NULL;
                ULONG cb;

                // Position on object owning the *forward* link
                DBFindDNT(pDBForward, ulObjectDnt);

                // What we are doing here is positioning the link table on the same
                // row in the new pDB as we current are in the old pDB.  Is there a better
                // way to clone the position of a cursor onto another?

                // Read the data portion of the name, if any. Used for positioning
                if (JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                              linkdataid,
                                              NULL, 0, &cb, 0, NULL) ==
                    JET_wrnBufferTruncated) {
                    // data portion of the OR name exists -allocate space and read it

                    rgb = THAllocEx( pDB->pTHS, cb);
                    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                                             linkdataid, rgb, cb,
                                             &cb, 0, NULL);
                }
                else {
                    cb = 0;
                }

                // Position on link to be touched
                fFound = dbPositionOnExactLinkValue(
                    pDBForward,
                    ulObjectDnt,
                    ulNewLinkBase,
                    ulValueDnt,
                    rgb, cb,
                    NULL
                    );
                // Just found it a minute ago...
                Assert( fFound );
                if (!fFound) {
                    DsaExcept(DSA_DB_EXCEPTION, DB_ERR_VALUE_DOESNT_EXIST, linkdataid);
                }
                if (rgb) {
                    THFreeEx( pDB->pTHS, rgb );
                }
            }

            // Get the metadata
            DBGetLinkValueMetaData( pDBForward, pACForward, &metaDataLocal );

            // Has it already been updated? If not, do so
            // Note, this handles legacy values because their usnProperty == 0
            if (metaDataLocal.MetaData.usnProperty < usnEarliest) {

                // Touch the item
                // Note that this routine, by not setting the reset deltime argument,
                // will touch the metadata but not make an absent value present.
                // This is intended.
                dbSetLinkValuePresent( pDBForward,
                                       DIRLOG_LVR_SET_META_GROUP_TYPE_CHANGE,
                                       pACForward,
                                       FALSE /* don't reset deltime*/,
                                       NULL );
                count++;

                DPRINT3( 1, "Object %s attr %s Value %s touched.\n",
                         DBGetExtDnFromDnt( pDBForward, ulObjectDnt ),
                         pACForward->name,
                         DBGetExtDnFromDnt( pDBForward, ulValueDnt ) );
                LogEvent(DS_EVENT_CAT_GARBAGE_COLLECTION,
                         DS_EVENT_SEV_VERBOSE,
                         DIRLOG_GC_UPDATED_OBJECT_VALUE,
                         szInsertSz( DBGetExtDnFromDnt( pDBForward, ulValueDnt ) ),
                         szInsertSz( DBGetExtDnFromDnt( pDBForward, ulObjectDnt ) ),
                         NULL);
            }
        } __finally {
            if (fIsBacklink) {
                DBClose( pDBForward, !AbnormalTermination() );
            }
        }

        if (JET_errNoCurrentRecord ==
            JetMoveEx(pDB->JetSessID, pDB->JetLinkTbl, 1, 0)) {
            // No more records.
            fMoreData = FALSE;
            break;
        }
    }

    if (pcLinksProcessed) {
        (*pcLinksProcessed) += count;
    }

    return fMoreData;
}

DWORD APIENTRY
DBTouchLinks_AC(
    DBPOS *pDB,
    ATTCACHE *pAC,
    BOOL fIsBacklink
    )

/*++

Routine Description:

    Touch links, causing them to be replicated out.

    Update the metadata on all links (present or absent), in a single
    direction (forward or backward), for the particular attribute.

    We use this function to authoritatively restore the links by forcing
    all of them to appear to be updated.

    This routine does some number of links immediately. If there are more,
    the object is marked for the link cleaner to finish the job.

    If we don't touch all the links immediately, there may be some delay before
    the link cleaner runs to finish the job. Thus the first links will appear
    almost immediately, while others make take 6 hours or more to appear.

    When the links are marked immediately, they are marked with current USNs.
    Since this routine is called before the group_type usn is assigned, the USNs
    on the touched links are less than the group type usn. This means that the
    link cleaner will touch those links again.

Arguments:

    pDB - We are assumed to be positioned on the object whose links
          are to be operated on.
    pAC - Attribute to touch. May be null, meaning to touch all linked attributes
    fIsBacklink - if backlinks should be touched
Return Value:

    DWORD APIENTRY - 

--*/

{
    BOOL fMoreLinks;

    Assert(VALID_DBPOS(pDB));
    Assert( !pAC || ((ULONG) fIsBacklink) == FIsBacklink( pAC->ulLinkID ) );

    DPRINT2( 2, "DBTouchLinks_AC, dnt = %d, attr = %s\n",
             pDB->DNT, pAC ? pAC->name : "all" );

    // Touch all forward links

    fMoreLinks = DBTouchAllLinksHelp_AC(
        pDB, // object has currency
        pAC, // Attribute to remove
        DBGetHighestCommittedUSN(), // Default to current USN
        fIsBacklink, // Which links to touch
        gcLinksProcessedImmediately,  // how many to process
        NULL // no processed count
        );
    if (fMoreLinks) {
        // Didn't clean up all the links - object needs cleaning
        DBSetObjectNeedsCleaning( pDB, TRUE );
    }

    return 0;
} /* DBTouchLinks_AC */


VOID
DBImproveAttrMetaDataFromLinkMetaData(
    IN DBPOS *pDB,
    IN OUT PROPERTY_META_DATA_VECTOR ** ppMetaDataVec,
    IN OUT DWORD * pcbMetaDataVecAlloced
    )

/*++

Routine Description:

    Improve attribute metadata to account for metadata on its linked values.
    The resulting vector represents changes for all attributes. This modified
    vector is useful for clients that expect all attributes and metadaa to
    be included in the attribute metadata vector.

    For each linked attribute of the current object, find the row with the
    greatest usn-changed. Consider this row representative for the attribute
    and merge its metadata into the vector.

    This vector should not be written to disk or returned over the wire.

    Obviously, knowledge of incremental value changes is lost in the resulting
    vector. It can only express at a whole attribute level whether the attribute
    has changed or not.

    Direct usn-property filtering by comparing usn-changed should be accurate.
    Since the representative row is the last-written row, we can tell whether the
    client has seen the last row, and hence whether the client is current with
    the attribute as a whole, or not.

    Filtering using the up to date vector could be inaccurate. If the client has
    seen the representative row by virtue of transitive replication, that does
    not mean that the client has seen all other rows on the attribute. Each value
    on the attribute could have originated on a different dsa.

Arguments:

    pDB - 
    usnHighPropUpdateDest -
    pMetaDataVec - 

Return Value:

   Exceptions on error

--*/

{
    JET_ERR err;
    ULONG ulTargetDnt = pDB->DNT, ulLinkBase = 0, ulNewLinkID;
    ATTCACHE *pAC;
    VALUE_META_DATA metaDataValue;
    PROPERTY_META_DATA * pMetaData;
    BOOL fIsNewElement;

    JetSetCurrentIndexSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                              SZLINKATTRUSNINDEX);


    while (1) {
        JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                     &(ulTargetDnt), sizeof(ulTargetDnt), JET_bitNewKey);

        JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                     &ulLinkBase, sizeof(ulLinkBase), 0);

        // seek
        if (((err = JetSeekEx(pDB->JetSessID, pDB->JetLinkTbl, JET_bitSeekGE))
             !=  JET_errSuccess) &&
            (err != JET_wrnRecordFoundGreater))
        {
            // end of table, we're done
            break;
        }

        dbGetLinkTableData(pDB,
                           FALSE,
                           FALSE,
                           &ulTargetDnt,
                           NULL, // pulValueDnt
                           &ulLinkBase);
        if (ulTargetDnt != pDB->DNT) {
            // Have moved off current object, we're done
            break;
        }

        // Construct a pAC for the current attribute

        ulNewLinkID = MakeLinkId(ulLinkBase);

        pAC = SCGetAttByLinkId(pDB->pTHS, ulNewLinkID);
        if (!pAC) {
            DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, ulNewLinkID);
        }

        // By virtue of the way this index is organized, the first record
        // matching this key will be the highest usn for this attribute

        DBGetLinkValueMetaData( pDB, pAC, &metaDataValue );

        // Legacy rows will not have usn's, and will not be on this index
        Assert( !IsLegacyValueMetaData( &metaDataValue ) );

        DPRINT4( 4, "dnt=%d,attr=%s,ver=%d,usnprop=%I64d\n",
                 ulTargetDnt,
                 pAC->name,
                 metaDataValue.MetaData.dwVersion,
                 metaDataValue.MetaData.usnOriginating );

        // Merge it in.
        // Value metadata should always be more recent than legacy attr metadata

        // Find or add a meta data entry for this attribute.
        pMetaData = ReplInsertMetaData(
            pDB->pTHS,
            pAC->id,
            ppMetaDataVec,
            pcbMetaDataVecAlloced,
            &fIsNewElement );

        Assert( NULL != pMetaData );
        Assert( pAC->id == pMetaData->attrType );

        // We must be careful with any claims about the relationship between the
        // metadata of the most recently changed value and the attribute metadata
        // which may or may not exist.  On an intuitive level, the value metadata
        // should be "more recent" in the sense that it should have been changed
        // after the last attribute level update in the old mode.  However, we
        // cannot use ReplCompareMetaData to check this since the version numbers
        // of the two pieces of metadata are not directly comparable.  We also do
        // not wish to use timestamps, since we do not depend on them for
        // correctness. Since we are on the same machine, we can check the local
        // USNs assigned to both updates.

        // If metadata already exists in the vector, it should lose to
        // new metadata
        Assert( fIsNewElement ||
                pMetaData->usnProperty < metaDataValue.MetaData.usnProperty );

        // Improve
        memcpy( pMetaData, &(metaDataValue.MetaData), sizeof( PROPERTY_META_DATA ) );

        // Set the improved uuidDsaOriginating to null, so that checks based on
        // the up to date vector will always ship the attribute.

        memset( &(pMetaData->uuidDsaOriginating), 0, sizeof( UUID ) );
        // usnOriginating must be non-zero for later consistency checks

        // Next attribute
        ulLinkBase++;
    }

    VALIDATE_META_DATA_VECTOR_VERSION(*ppMetaDataVec);
} /* DBImproveLinkMetaDataToAttrMetaData */

/* end dblink.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dbmeta.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dbmeta.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Various functions to support handling of replication per-property meta data
    in the DBLayer.

DETAILS:

CREATED:

    97/05/07    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <mdlocal.h>
#include <dsatools.h>
#include <attids.h>
#include <drameta.h>
#include <anchor.h>
#include <dsutil.h>
#include <drserr.h>

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>

// Assorted DSA headers
#include <dsevent.h>
#include <debug.h>
#define DEBSUB "DBMETA:"

// DBLayer includes
#include "dbintrnl.h"

#include <fileno.h>
#define  FILENO FILENO_DBMETA

extern BOOL gfRestoring;
extern ULONG gulRestoreCount;
extern BOOL gfRunningAsExe;


// Factor used to bump up the version to make a write authoritative
// This value matches that used in util\ntdsutil\armain.c
#define VERSION_BUMP_FACTOR (100000)

// Version bump cannot exceed this any one time
#define VERSION_BUMP_LIMIT (10000000)

// Number of seconds in a day
#define SECONDS_PER_DAY (60*60*24)

////////////////////////////////////////////////////////////////////////////////
//
// Global implementations.
//


void
dbVerifyCachedObjectMetadata(
    IN DBPOS *pDB
    )

/*++

Routine Description:

    Verify that the metadata has enough attributes for a valid object

    Assumptions: these attributes are present on all objects: present, deleted,
    or pure subref's. We should not be called on a phantom.

Arguments:

    pDB - Database position

Return Value:

    None

--*/

{
    Assert( (pDB->DNT == ROOTTAG) || ReplLookupMetaData( ATT_INSTANCE_TYPE, pDB->pMetaDataVec, NULL ) );
    Assert( (pDB->DNT == ROOTTAG) || ReplLookupMetaData( ATT_OBJECT_CLASS, pDB->pMetaDataVec, NULL ) );
    Assert( (pDB->DNT == ROOTTAG) || ReplLookupMetaData( ATT_RDN, pDB->pMetaDataVec, NULL ) );
}

void
dbCacheMetaDataVector(
    IN  DBPOS * pDB
    )
/*++

Routine Description:

    Caches per-property meta data (if any) from the current object into the
    DBPOS.

Arguments:

    pDB

Return Values:

    None.

--*/
{
    DWORD dbErr;

    Assert(VALID_DBPOS(pDB));

    if ( !pDB->fIsMetaDataCached )
    {
        // Get the current meta data vector of the object.
        dbErr = DBGetAttVal(
                    pDB,
                    1,
                    ATT_REPL_PROPERTY_META_DATA,
                    0,
                    0,
                    &pDB->cbMetaDataVecAlloced,
                    (BYTE **) &pDB->pMetaDataVec
                    );

        switch ( dbErr )
        {
        case 0:
            // Meta data found and cached.
            VALIDATE_META_DATA_VECTOR_VERSION(pDB->pMetaDataVec);

            Assert(    pDB->cbMetaDataVecAlloced
                    == (DWORD) MetaDataVecV1Size( pDB->pMetaDataVec )
                  );
#if DBG
            dbVerifyCachedObjectMetadata( pDB );
#endif

            break;

        case DB_ERR_NO_VALUE:
            // No meta data found.  ('Salright.)
            pDB->pMetaDataVec = NULL;
            pDB->cbMetaDataVecAlloced = 0;
            break;

        case DB_ERR_BUFFER_INADEQUATE:
        case DB_ERR_UNKNOWN_ERROR:
        default:
            // This shouldn't happen....
            DPRINT1( 0, "Unexpected error %d reading meta data!\n", dbErr );
            LogUnhandledError( dbErr );
            Assert( !"Unexpected error reading meta data!" );
            DsaExcept( DSA_DB_EXCEPTION, dbErr, 0 );
            break;
        }

        // Meta data successfully cached.
        pDB->fIsMetaDataCached = TRUE;
        pDB->fMetaDataWriteOptimizable = TRUE; // meta data write is optimizable by default
                                               // we need to mark it as not optimizable only
                                               // if we insert or delete a meta data from the
                                               // cache at some point.
    }
}


void
dbTouchLinkMetaData(
    IN DBPOS *pDB,
    IN VALUE_META_DATA * pMetaData
    )

/*++

Routine Description:

    Indicate that value metadata on this object has been updated. We cache
    the greatest value metadata touched on this object.  This is used when
    calculating the when_changed on an object.

    Note that values are not necessarily touched in increasing usn order. For
    originating writes, they are. But for replicated writes, the values may have
    been sorted by object, and may not be applied in increasing usn order.

Arguments:

    pDB - 
    pMetaData - 

Return Value:

    None

--*/

{
    if (!pDB->fIsLinkMetaDataCached) {
        // No link metadata cached
        pDB->fIsLinkMetaDataCached = TRUE;
        pDB->pLinkMetaData = THAllocEx( pDB->pTHS, sizeof( VALUE_META_DATA ) );
        *(pDB->pLinkMetaData) = *pMetaData;
        return;
    }

    // Metadata already cached. Replace if greater.
    // What we want is a summary of highest value metadata based on time in
    // order to compute WHEN_CHANGED. Compare based on time only.
    if (pDB->pLinkMetaData->MetaData.timeChanged <
        pMetaData->MetaData.timeChanged) {
        *(pDB->pLinkMetaData) = *pMetaData;
    }

} /* dbTouchLinkMetaData */

void
DBTouchMetaData(
    IN  DBPOS *     pDB,
    IN  ATTCACHE *  pAC
    )
/*++

Routine Description:

    Touches cached meta data to signify a change in the given attribute.  The
    metadata properties as a whole are updated later; this routine simply flags
    the meta data for the given attribute as changed.

Arguments:

    pDB
    pAC - Attribute for which to update meta data.

Return Values:

    None.

--*/
{
    THSTATE *pTHS=pDB->pTHS;
    PROPERTY_META_DATA * pMetaData;

    Assert(VALID_DBPOS(pDB));

    if (pAC->bIsNotReplicated) {
        if (ATT_OBJ_DIST_NAME == pAC->id) {
            // A special case; map to ATT_RDN.
            pAC = SCGetAttById(pTHS, ATT_RDN);
            // prefix complains about pAC being NULL, 447335, bogus since we are using constant

            Assert(NULL != pAC);
            Assert(!pAC->bIsNotReplicated);
        }
        else {
            // Not replicated => no meta data => nothing to do.
            return;
        }
    }
    else if ((pAC->ulLinkID) && (TRACKING_VALUE_METADATA( pDB ))) {
        // This routine updates _attribute_ metadata. Linked attributes in
        // the new mode don't have attribute metadata, only value metadata.
        // Linked attributes are not replicated (their values are)
        // Note that we cannot assert that pDB->fIsLinkMetaDataCached. The object
        // operation routines always call DbTouchMetaData, even when no
        // linked values have been added. For example, see DbAttAtt_AC.
        // This is one difference between the old and new modes. In the old mode,
        // an add with no values resulted in atleast attr metadata, and
        // knowledge of any empty attr replicated around. In the new mode, an
        // add with no values leaves no trace, and there is nothing to replicate.
        return;
    }
    else if ((ATT_NT_SECURITY_DESCRIPTOR == pAC->id) && pTHS->fSDP) {
        // Don't update meta data for propagated security descriptor updates.
        return;
    }
    // we can skip updateing of metadata only in single user mode (domain rename).
    else  if (pDB->fSkipMetadataUpdate) {
        Assert (DsaIsSingleUserMode());
        return;
    }


    // Init rec.  If it's already inited, this is a no-op.
    dbInitRec( pDB );

    // Cache pre-existing meta data if we haven't done so already.
    if ( !pDB->fIsMetaDataCached )
    {
        dbCacheMetaDataVector( pDB );
    }

    if (pTHS->fGCLocalCleanup)
        {
 
	//locate the meta data, but don't actually delete it, instead
	//mark the pMetaData->usnProperty attribute as removed, later we'll make the real
	//delete (same form as update below).
	pMetaData = ReplLookupMetaData( pAC->id, pDB->pMetaDataVec, NULL );
	if (pMetaData!=NULL) {
	    //mark this attribute as removed.  We'll do the actual delete to the meta data later.
	    pMetaData->usnProperty = USN_PROPERTY_GCREMOVED;
	    pDB->fMetaDataWriteOptimizable = FALSE; // deleting something, meta data write
                                                // is no longer optimizable	
	}
    }
    else
    {
        BOOL fIsNewElement;

        // Find or add a meta data entry for this attribute.
        pMetaData = ReplInsertMetaData(
                        pTHS,
                        pAC->id,
                        &pDB->pMetaDataVec,
                        &pDB->cbMetaDataVecAlloced,
                        &fIsNewElement
                        );

        Assert( NULL != pMetaData );
        Assert( pAC->id == pMetaData->attrType );

        // Mark this attribute as touched.  We'll make the real update to its meta
        // data later.
        pMetaData->usnProperty = USN_PROPERTY_TOUCHED;

        if (fIsNewElement)
        {
            // new element has been added to meta data vector; meta data write is
            // no longer optimizable
            pDB->fMetaDataWriteOptimizable = FALSE;
        }
    }
}


DWORD
dbCalculateVersionBump(
    IN  DBPOS *pDB,
    DSTIME TimeCurrent
    )

/*++

Routine Description:

This routine calculates the amount to bump the version for an authoritative
write.  We want a value that is larger than any version that could be in
existence in the enterprise.

This code is similar to that used in util\ntdsutil\ar.c:GetVersionIncrease()

The algorithm is as follows:

bump = (age in days + restore count) * bump_factor

Arguments:

    pDB - 

Return Value:

    DWORD - 

--*/

{
    DWORD bump = 1, dbErr, idleDays, idleSeconds, restoreCount;
    DSTIME mostRecentChange;

    // Get the last time this object was changed
    if (dbErr = DBGetSingleValue(pDB,
                         ATT_WHEN_CHANGED,
                         &mostRecentChange,
                         sizeof(DSTIME), NULL)) {
        DsaExcept( DSA_DB_EXCEPTION, dbErr, 0 );
    }

    // How long ago was it, in days
    Assert(TimeCurrent > mostRecentChange);

    idleSeconds = (DWORD)(TimeCurrent - mostRecentChange);

    idleDays = idleSeconds / SECONDS_PER_DAY;
    if ( idleSeconds % SECONDS_PER_DAY > 0 ) {
        idleDays++;
    }

    // Get the number of times this system has been restored
    // This accounts for the number of bumps we have had in the past
    if (gulRestoreCount)
    {
        restoreCount = gulRestoreCount;
    }
    else
    {
        restoreCount = 1;
    }

    // Calculate the bump
    // The version factor represents the worst case maximal activity
    // on an object in a day

    bump = (restoreCount + idleDays) * VERSION_BUMP_FACTOR;

    // Not too big
    if (bump > VERSION_BUMP_LIMIT) {
        bump = VERSION_BUMP_LIMIT;
    }

#if 0
    {
        CHAR displayTime[SZDSTIME_LEN+1];
        DSTimeToDisplayString(mostRecentChange, displayTime);
        DPRINT1( 0, "most recent change at %s\n", displayTime );
        DPRINT3( 0, "idleSeconds = %d; idleDays = %d; restoreCount = %d\n",
                 idleSeconds, idleDays, restoreCount );
        DPRINT1( 0, "bump = %d\n", bump );
    }
#endif

    return bump;
} /* dbCalculateVersionBump */

void
dbFlushMetaDataVector(
    IN  DBPOS *                     pDB,
    IN  USN                         usn,
    IN  PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote OPTIONAL,
    IN  DWORD                       dwMetaDataFlags
    )
/*++

Routine Description:

    Update all touched attributes with the correct per-property meta data,
    merging replicated meta data (if any).  Write the updated meta data
    vector, highest USN changed, and highest changed time to the record.  
    
    Delete all attributes marked as removed.  Write the updated meta data vector
    but do not update the highest USN changed if 
    only deletes have occurred.  Still update the highest changed time on delete.

Arguments:

    pDB
    usn - The local USN to write in the meta data for changed attributes.
    pMetaDataExtVecRemote (OPTIONAL) - Replicated meta data vector to merge with
        the local vector.
    dwMetaDataFlags - bit flags specifying how to process meta data for 
                        Current values:
                        i) META_STANDARD_PROCESSING : 
                            - No special processing
                        ii) (dwMetaDataFlags & META_AUTHORITATIVE_MODIFY):
                            - Make the change authoritative by up'ing the
                              version to a much higher value than what 
                              could possibly exist in the enterprise

Return Values:

    None.

--*/
{
    THSTATE *               pTHS = pDB->pTHS;
    DWORD                   cNumPropsLocal;
    DWORD                   cNumPropsRemote;
    PROPERTY_META_DATA *    pMetaDataLocal;
    PROPERTY_META_DATA *    pMetaDataRemote;
    PROPERTY_META_DATA *    pNextMetaDataRemote;
    DSTIME                  timeCurrent;
    DSTIME                  timeMax;
    DSTIME                  timeMostRecentChange = 0;
    BOOL                    fReplicatedAttrChanged = FALSE;
    BOOL                    fReplicatedAttrDeleted = FALSE;
    BOOL                    fAuthoritative = (dwMetaDataFlags & META_AUTHORITATIVE_MODIFY);
    BOOL                    fWriteOptimizable = pDB->fMetaDataWriteOptimizable;
    PBYTE                   pbStart = NULL;
    DWORD                   cNumConsecutiveElemsChanged = 0;

    Assert(VALID_DBPOS(pDB));
    Assert(DsaIsInstalling() || !fNullUuid(&pTHS->InvocationID));

    // Only the replicator should pass remote meta data vectors to be merged.
    Assert( pTHS->fDRA || ( NULL == pMetaDataVecRemote ) );

    // Only HandleRestore() can currently issue an authoritative modify
    Assert( !fAuthoritative || gfRestoring);

    // Get the last changed time on this object. This may not exist for
    // a new object, which is why we don't check for errors here.
    DBGetSingleValue(pDB,
                     ATT_WHEN_CHANGED,
                     &timeMostRecentChange,
                     sizeof(DSTIME), NULL);

    // If we haven't yet cached the meta data for this object, then no
    // replicated attributes have been touched and our work is done.
    if (!pDB->fIsMetaDataCached) {

        // Special mode to update WHEN_CHANGED when object changes in a way
        // other than through its attribute metadata
        if (pDB->fIsLinkMetaDataCached) {
            // Update the object-level When-Changed attribute.
            if (pDB->pLinkMetaData->MetaData.timeChanged >
                timeMostRecentChange ) {
                DBResetAtt(pDB,
                           ATT_WHEN_CHANGED,
                           sizeof( DSTIME ),
                           &(pDB->pLinkMetaData->MetaData.timeChanged),
                           SYNTAX_TIME_TYPE
                    );
            }

            // This hack is for backward compatibility with those applications which search
            // for changes by USN. Even though only the linked values have changed, we
            // bump the object USN CHANGED so that external searches will find the object.
            // We introduce a minor inefficiency that outbound replication will now find
            // an object change on this object, but when searching the attribute level
            // metadata will not find anything to ship.
            DBResetAtt(pDB,
                       ATT_USN_CHANGED,
                       sizeof( usn ),
                       &usn,
                       SYNTAX_I8_TYPE
                );
        }

        return;
    }

    timeMax = 0;
    timeCurrent = DBTime();

    // Cue up the first remote meta data entry (if any).
    if ( NULL == pMetaDataVecRemote )
    {
        pNextMetaDataRemote = NULL;
        cNumPropsRemote = 0;
    }
    else
    {
        VALIDATE_META_DATA_VECTOR_VERSION(pMetaDataVecRemote);

        pNextMetaDataRemote = &pMetaDataVecRemote->V1.rgMetaData[ 0 ];
        cNumPropsRemote = pMetaDataVecRemote->V1.cNumProps;
    }

    // For each entry in the local meta data vector...
    for ( cNumPropsLocal = pDB->pMetaDataVec->V1.cNumProps,
            pMetaDataLocal = &pDB->pMetaDataVec->V1.rgMetaData[ 0 ];
          cNumPropsLocal > 0;
          cNumPropsLocal--, pMetaDataLocal++
        )
    {
        // Skip over irrelevant remote meta data.
        while (    ( NULL != pNextMetaDataRemote )
                && ( pNextMetaDataRemote->attrType < pMetaDataLocal->attrType )
              )
        {
            if ( --cNumPropsRemote )
                pNextMetaDataRemote++;
            else
                pNextMetaDataRemote = NULL;
        }

        // Get corresponding remote meta data (if any).
        if (    ( NULL != pNextMetaDataRemote )
             && ( pNextMetaDataRemote->attrType == pMetaDataLocal->attrType )
           )
        {
            pMetaDataRemote = pNextMetaDataRemote;
        }
        else
        {
            pMetaDataRemote = NULL;
        }

        if ( USN_PROPERTY_TOUCHED == pMetaDataLocal->usnProperty )
        {
            fReplicatedAttrChanged = TRUE;

            if (fWriteOptimizable)
            {
                // A property has been modifed inplace and changes in meta data vector
                // have been contiguous so far- potential candidate for optimization
                if (!pbStart)
                {
                    // this is the first element changed in meta data vector
                    // keep track of it
                    pbStart = (PBYTE) pMetaDataLocal;
                    cNumConsecutiveElemsChanged = 1;
                }
                else
                {
                    // this is not the first element changed, but see if it is consecutive
                    // with the block of elements that have been changed so far
                    PBYTE pbCurrent = (PBYTE) pMetaDataLocal;
                    if ((pbCurrent - pbStart) == (int) (cNumConsecutiveElemsChanged * sizeof(PROPERTY_META_DATA)))
                    {
                        // this change is also contiguous
                        cNumConsecutiveElemsChanged++;
                    }
                    else
                    {
                        // this changed element is not contiguous with 
                        // previously changed elements - we can't optimize 
                        // the meta data write for this kind of change
                        fWriteOptimizable = FALSE;
                    }
                }
            }

            // Attribute has been touched; update the meta data appropriately.
            if ( NULL == pMetaDataRemote )
            {
                // An originating write.
                pMetaDataLocal->usnProperty        = usn;
                if (fAuthoritative)
                {
                    pMetaDataLocal->dwVersion +=
                        dbCalculateVersionBump( pDB, timeCurrent );
                }
                else
                {
                    // non-authoritative - just increment the version by 1
                    pMetaDataLocal->dwVersion++;
                }
                pMetaDataLocal->timeChanged        = timeCurrent;
                pMetaDataLocal->uuidDsaOriginating = pTHS->InvocationID;
                pMetaDataLocal->usnOriginating     = usn;
            }
	    else if (USN_PROPERTY_GCREMOVED == pMetaDataRemote->usnProperty) {
		DRA_EXCEPT(DRAERR_InternalError, pMetaDataRemote->attrType);  
	    }
            else if (USN_PROPERTY_TOUCHED != pMetaDataRemote->usnProperty)
            {
                // A replicated write.
                Assert(!fAuthoritative);

                pMetaDataLocal->usnProperty        = usn;
                pMetaDataLocal->dwVersion          = pMetaDataRemote->dwVersion;
                pMetaDataLocal->timeChanged        = pMetaDataRemote->timeChanged;
                pMetaDataLocal->uuidDsaOriginating = pMetaDataRemote->uuidDsaOriginating;
                pMetaDataLocal->usnOriginating     = pMetaDataRemote->usnOriginating;
            }
            else
            {
                // Replication has decided to over- or underride a value.  (See
                // ReplOverrideMetaData() and ReplUnderrideMetaData().)
                //
                // 1. In both cases, we want to flag the change as having
                //    originated locally.
                // 2. In the override case, we want to make sure the change wins
                //    over all the values we've seen thus far -- the max thus
                //    far is pMetaDataRemote->dwVersion, and we're going to bump
                //    that by one to make our version "better."
                // 3. In the underride case, we want to make sure the change
                //    *loses* over other inbound values locally, and does not
                //    clobber any pre-existing values on remote machines.
                //    In this case pMetaDataRemote->dwVersion is ULONG_MAX, so
                //    when we bump it we will be setting the local dwVersion
                //    field to 0 -- a guaranteed loser.
                Assert(!fAuthoritative);

                pMetaDataLocal->usnProperty        = usn;
                pMetaDataLocal->dwVersion          = pMetaDataRemote->dwVersion + 1;
                pMetaDataLocal->timeChanged        = timeCurrent;
                pMetaDataLocal->uuidDsaOriginating = pTHS->InvocationID;
                pMetaDataLocal->usnOriginating     = usn;
            }
        }
        else if ( USN_PROPERTY_GCREMOVED == pMetaDataLocal->usnProperty ) { 
	    fReplicatedAttrDeleted = TRUE;
	    // Attribute has been deleted.  To delete an attributed, our schema
	    // must have validated this.  therefore any remote meta data for this
	    // attribute is irrelevant.
	    if (pMetaDataRemote) {
		if ( 
		    (USN_PROPERTY_TOUCHED == pMetaDataRemote->usnProperty) 
		    ||
		    (USN_PROPERTY_GCREMOVED == pMetaDataRemote->usnProperty) 
		    ) {
                    DRA_EXCEPT(DRAERR_InternalError, pMetaDataRemote->attrType);
		}
	    }
	
	     // shift left all entries to the right of the index we are deleting 
	    MoveMemory(pMetaDataLocal,
		       pMetaDataLocal+1,
		       sizeof(PROPERTY_META_DATA) * (cNumPropsLocal - 1));
      
	    pDB->pMetaDataVec->V1.cNumProps--;
	    //adjust value for pMetaDataLocal since we deleted the meta data it was pointing at.
	    pMetaDataLocal--; 
	    //we don't want to do any more calculations for this metadata pointer since it is 1 "behind"
	    //where it should be since the meta data was deleted, so continue...
	    continue;
	}
	else
        {
            // Attribute has not been touched or removed

            // Attributes not touched should have a lower local USN.
            Assert( pMetaDataLocal->usnProperty < usn );

            // Check for cases where ReplInsertMetaData was called but metadata was
            // not flagged as touched or removed.

            // Metadata attributes should be initialized
            // Unlike the checks in ReplInsertMetaData, these checks are for
            // metadata that has already been written to the database atleast once,
            // and should be completely filled in at this point.

            // dwVersion may be zero in the underridden case
            // Assert( pMetaDataLocal->dwVersion ); // fails for underriden metadata
            Assert( pMetaDataLocal->timeChanged );
            // Install time objects may be created before ginvocationid set
            Assert( DsaIsInstalling() || !fNullUuid( &(pMetaDataLocal->uuidDsaOriginating) ) );
            Assert( pMetaDataLocal->usnOriginating );
            Assert( pMetaDataLocal->usnProperty > 0 );
        }

        // Track highest property change time.
        timeMax = max(timeMax, pMetaDataLocal->timeChanged);
    }

    // If no replicated attributes were touched, then we shouldn't have had
    // cached meta data, in which case we would have bailed out above. Only exception 
    // to this is GCCleanup where we would have removed the metadata for properties that 
    // are cleaned up from the object.       
    Assert(fReplicatedAttrChanged || fReplicatedAttrDeleted || pTHS->fGCLocalCleanup);

    if (timeMax == 0) {
        // Handle the fReplicatedAttrDeleted case
        timeMax = timeCurrent;
    } else if (pDB->fIsLinkMetaDataCached) {
        // Check for more recent value change
        timeMax = max(timeMax, pDB->pLinkMetaData->MetaData.timeChanged );
    }

    // Update attributes only if a replicable change was made.
    if (fReplicatedAttrChanged || fReplicatedAttrDeleted) {
        // Update the Repl-Property-Meta-Data attribute.

#if DBG
        dbVerifyCachedObjectMetadata( pDB );
#endif

        if (fWriteOptimizable && pbStart)
        {
            Assert(pDB->fMetaDataWriteOptimizable);
            // contiguous block of data has been changed in-place in the meta
            // data vector we can really optimize this Jet write
            DBResetAttLVOptimized(pDB,
                                  ATT_REPL_PROPERTY_META_DATA,
                                  (DWORD)(pbStart - (PBYTE) pDB->pMetaDataVec),  // offset from the beginning
                                  cNumConsecutiveElemsChanged * sizeof(PROPERTY_META_DATA), //segment len
                                  pbStart,
                                  SYNTAX_OCTET_STRING_TYPE
                                  );
        }
        else
        {
            // changes are not in-place and/or contiguous; so we can't
            // explicitly optimize this write by writing only a portion of meta
            // data vector; 
            // But DBResetAtt() will still try to optimize it by setting the
            // appropriate grbits.
            DBResetAtt(pDB,
                       ATT_REPL_PROPERTY_META_DATA,
                       MetaDataVecV1Size( pDB->pMetaDataVec ),
                       pDB->pMetaDataVec,
                       SYNTAX_OCTET_STRING_TYPE
                       );
        }
	// Update the object-level When-Changed attribute.
        // Since replication writes can be batched and sorted, it is possible
        // for different attribute updates to the same object to be applied in
        // non-increasing time order. Only allow whenChanged to advance in time.
        if (timeMax > timeMostRecentChange ) {
            DBResetAtt(pDB,
                       ATT_WHEN_CHANGED,
                       sizeof( timeMax ),
                       &timeMax,
                       SYNTAX_TIME_TYPE
                );
	}
    }

    if (fReplicatedAttrChanged) {
	// only update the USN-Changed if something changed!
	// do not update if an attribute was deleted!

	// Update the USN-Changed value.
        DBResetAtt(pDB,
                   ATT_USN_CHANGED,
                   sizeof( usn ),
                   &usn,
                   SYNTAX_I8_TYPE
                   );
    }
}

BOOL
dbIsModifiedInMetaData (
        DBPOS *pDB,
        ATTRTYP att)
/*
 * Checks to see if the supplied ATT is marked as having been changed in the
 * but not yet committed by looking in the metadata 
 *
 * INPUT:
 *    pDB - DBPOS to use
 *    att - attribute to look to see if it has changed.
 *
 * RETURN VALUE:
 *    TRUE if we can find that the attribute has been changed and not committed,
 *    FALSE otherwise.
 */
{
    ULONG i, cProps;
    PROPERTY_META_DATA * pMetaData;

    Assert(VALID_DBPOS(pDB));

    if (   !pDB->fIsMetaDataCached
        || !pDB->pMetaDataVec
        || !pDB->pMetaDataVec->V1.cNumProps)  {
        // If meta data is not cached on the DBPOS that means either
        // no attribute has been touched, or we have already
        // flushed the cached meta data vector to the db
        // If meta data vector for the current object is empty that
        // means the object has no replicated property.
        return FALSE;
    }
    
    pMetaData = ReplLookupMetaData(att, pDB->pMetaDataVec, NULL);
     
    return ((NULL != pMetaData)
            && ((USN_PROPERTY_TOUCHED == pMetaData->usnProperty) || (USN_PROPERTY_GCREMOVED == pMetaData->usnProperty)));
}

ULONG
DBMetaDataModifiedList(
	DBPOS *pDB,
	ULONG *pCount,
	ATTRTYP **ppAttList)
/*
 * Returns an un-ordered list of all the attributes modified via this DBPOS 
 * until now and not yet committed.
 * 
 *
 * INPUT:
 *    pDB - DBPOS to use
 * OUTPUT:
 *    pCount - filled in with the number of modified attributes (i.e., the size of the AttList)
 *    ppAttList - filled in with a freshly THAlloced list of attrtyps.
 * RETURN VALUE:
 *    0 - success
 *   non-0 - a DB_ERR error code
 */
{
    ULONG i, cProps;

    Assert(VALID_DBPOS(pDB));
    Assert(pCount);
    Assert(ppAttList);

    *pCount = 0;
    *ppAttList = NULL;

    if (   !pDB->fIsMetaDataCached
        || !pDB->pMetaDataVec
        || !pDB->pMetaDataVec->V1.cNumProps) 
    {
        // If meta data is not cached on the DBPOS that means either
        // no attribute has been touched, or we have already
        // flushed the cached meta data vector to the db
        // If meta data vector for the current object is empty that
        // means the object has no replicated property.
        return DB_success;
    }

    // Allocate mem for maximum possible output
    *ppAttList = THAlloc(pDB->pMetaDataVec->V1.cNumProps * sizeof(ATTRTYP));
    if (!*ppAttList)
    {
        // couldn't locate an appropriate DB_ERR_ for out of memory
        return DB_ERR_SYSERROR;
    }

    for (i = 0, cProps = pDB->pMetaDataVec->V1.cNumProps; i < cProps; i++)
    {
        if ((USN_PROPERTY_TOUCHED == pDB->pMetaDataVec->V1.rgMetaData[i].usnProperty) || (USN_PROPERTY_GCREMOVED == pDB->pMetaDataVec->V1.rgMetaData[i].usnProperty))
        {
            (*ppAttList)[(*pCount)++] = pDB->pMetaDataVec->V1.rgMetaData[i].attrType;
        }
    }

    if (!(*pCount))
    {
        // no properties touched
        THFree(*ppAttList);
        *ppAttList = NULL;
    }
        
    return DB_success;       
}

void
dbFreeMetaDataVector(
    IN  DBPOS * pDB
    )
/*++

Routine Description:

    Free cached meta data (if any).

Arguments:

    pDB

Return Values:

    None.

--*/
{
    Assert(VALID_DBPOS(pDB));

    if ( NULL != pDB->pMetaDataVec )
    {
        Assert( pDB->fIsMetaDataCached );
        Assert( 0 != pDB->cbMetaDataVecAlloced );

        THFree( pDB->pMetaDataVec );

        pDB->pMetaDataVec = NULL;
        pDB->cbMetaDataVecAlloced = 0;
    }

    pDB->fIsMetaDataCached = FALSE;
}


void
DBGetLinkValueMetaData(
    IN  DBPOS *pDB,
    ATTCACHE *pAC,
    OUT VALUE_META_DATA *pMetaDataLocal
    )

/*++

Routine Description:

Get the metadata for an existing row.

The caller is expected to know whether the desired value has been created
already or not. This routine should only be called when the value has been
created and the metadata for the value is wanted. There may be some question
as to whether this is a legacy value or not.  This routine assumes that if the
metadata is not present, then this is a legacy value.

The internal form of the metadata is derived from
a. The external form of the metadata
b. The link base
c. The usn changed column

Arguments:

    pDB - dbpos, link cursor positioned on value.
    pAC - Attcache of value
    pMetaDataLocal - Local metadata read off object, or special metadata
                     returned from a legacy value

Return Value:

    None

--*/

{
    DWORD err, linkDnt = INVALIDDNT;
    VALUE_META_DATA_EXT metaDataExt;
    JET_RETRIEVECOLUMN attList[2];
    CHAR szIndexName[JET_cbNameMost];
    CHAR szTime1[SZDSTIME_LEN];
    CHAR szTime2[SZDSTIME_LEN];
    CHAR szUuid[ SZUUID_LEN ];

    Assert(VALID_DBPOS(pDB));
    Assert( pMetaDataLocal );

    // We don't support getting/setting metadata on backlinks because this
    // code assumes we are positioned (have DBPOS currency) on the object
    // which is the source object of the link.
    Assert( pAC->ulLinkID );
    Assert( !FIsBacklink(pAC->ulLinkID) );

    DPRINT1( 2, "DBGetLinkValueMeta, obj = %s\n", GetExtDN(pDB->pTHS, pDB) );

    pMetaDataLocal->MetaData.attrType = pAC->id;

    dbGetLinkTableData (pDB,
                        FALSE,           // fIsBacklink
                        FALSE,           // Warnings
                        &linkDnt,
                        NULL, //&ulValueDnt,
                        NULL // &ulNewLinkBase
        );

    Assert( linkDnt == pDB->DNT );
    if (linkDnt != pDB->DNT) {
        // Not positioned on valid link
        DsaExcept(DSA_DB_EXCEPTION, DB_ERR_ONLY_ON_LINKED_ATTRIBUTE, 0);
    }

    JetGetCurrentIndexEx( pDB->JetSessID, pDB->JetLinkTbl,
                          szIndexName, sizeof( szIndexName ) );

    memset(attList,0,sizeof(attList));
    // May not exist
    attList[0].columnid = linkusnchangedid;
    attList[0].pvData = &( pMetaDataLocal->MetaData.usnProperty );
    attList[0].cbData = sizeof( USN );
    attList[0].grbit = pDB->JetRetrieveBits;
    if ( (!strcmp( szIndexName, SZLINKDRAUSNINDEX )) ||
          (!strcmp( szIndexName, SZLINKATTRUSNINDEX )) ) {
        attList[0].grbit |= JET_bitRetrieveFromIndex;
    }
    attList[0].itagSequence = 1;

    // May not exist
    attList[1].columnid = linkmetadataid;
    attList[1].pvData = &metaDataExt;
    attList[1].cbData = sizeof( metaDataExt );
    attList[1].grbit = pDB->JetRetrieveBits;
    attList[1].itagSequence = 1;

    err = JetRetrieveColumnsWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                    attList, 2 );

    // Verify positioning

    // Detect a legacy row. It has a linkDnt column but none of the newer
    // columsn such as linkusnchangedid.
    if (attList[0].err) {
        DWORD dbErr;
        DSTIME timeCreated;

        // Metadata not present
        Assert( attList[1].err != JET_errSuccess );

        // The most important field we need to derive is the creation time.
        // Since legacy values always lose to LVR values, we should construct
        // *underridden* legacy metadata that will always lose.

        memset( pMetaDataLocal, 0, sizeof( VALUE_META_DATA ) );

        // Use the object's creation time
        dbErr = DBGetSingleValue( pDB, ATT_WHEN_CREATED,
                                  &timeCreated, sizeof(timeCreated),
                                  NULL );
        if (dbErr) {
            DsaExcept( DSA_DB_EXCEPTION, dbErr, 0 );
        }
        pMetaDataLocal->timeCreated = timeCreated;

#if DBG
        {
            CHAR szTime[SZDSTIME_LEN];
            DPRINT1( 5, "[%s,legacy]\n", DSTimeToDisplayString(timeCreated, szTime) );
        }
#endif
        return;
    }

    // Construct LVR metadata from the two fields we read above

    Assert( attList[1].err == JET_errSuccess );

    pMetaDataLocal->timeCreated = metaDataExt.timeCreated;
    pMetaDataLocal->MetaData.dwVersion = metaDataExt.MetaData.dwVersion;
    pMetaDataLocal->MetaData.timeChanged = metaDataExt.MetaData.timeChanged;
    pMetaDataLocal->MetaData.uuidDsaOriginating = metaDataExt.MetaData.uuidDsaOriginating;
    pMetaDataLocal->MetaData.usnOriginating = metaDataExt.MetaData.usnOriginating;
    // usnProperty is updated above

    DBLogLinkValueMetaData( pDB,
                            DIRLOG_LVR_GET_META_OP,
                            &( pMetaDataLocal->MetaData.usnProperty ),
                            &metaDataExt );

} /* DBGetLinkValueMetaData */


void
DBLogLinkValueMetaData(
    IN DBPOS *pDB,
    IN DWORD dwEventCode,
    IN USN *pUsn,
    IN VALUE_META_DATA_EXT *pMetaDataExt
    )

/*++

Routine Description:

Routine to dump metadata to the event log and/or kernel debugger. 

Since we read more data than usual, we only want the expense of collecting all
this info when requested.

Arguments:

    pDB - 
    dwEventCode - 
    pMetaDataExt - 

Return Value:

    None

--*/

{
    ULONG linkDnt = INVALIDDNT, linkBase = 0, backlinkDnt = INVALIDDNT, count;
    DWORD len, err;
    DSNAME *pValueDn = NULL;
    CHAR szTime[SZDSTIME_LEN];
    CHAR szTime1[SZDSTIME_LEN];
    CHAR szTime2[SZDSTIME_LEN];
    CHAR szUuid[ SZUUID_LEN ];
    CHAR  buf[150];
    LPSTR pszObjectDn;
    DSTIME timeDeletion = 0;
    BOOL fPresent;
    ATTCACHE *pAC;
    ULONG ulLinkID;

    Assert( pUsn );
    Assert( pMetaDataExt );

    // Short curcuit this routine if no logging desired

    // On free builds, only do if logging level elevated
    // On debug builds, also check if DPRINT level elevated
    if ( (!LogEventWouldLog( DS_EVENT_CAT_LVR, DS_EVENT_SEV_VERBOSE ))
#if DBG
         && (!DebugTest(2,DEBSUB))
#endif
         ) {
        return;
    }

    // Verify that we are positioned on the link's containing object
    // This also assumes that on an create, the linkdnt column has
    // been populated by now.

    dbGetLinkTableData (pDB,
                        FALSE,           // fIsBacklink
                        FALSE,           // Warnings
                        &linkDnt,
                        &backlinkDnt,
                        &linkBase);
    Assert( linkDnt == pDB->DNT );

    // Get deletion time
    err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                    linkdeltimeid,
                                    &timeDeletion, sizeof(timeDeletion), &len,
                                    JET_bitRetrieveCopy, NULL);
    fPresent = (err != JET_errSuccess);

    // Get ATTCACHE from linkbase
    ulLinkID = MakeLinkId( linkBase );
    // We don't support getting/setting metadata on backlinks because this
    // code assumes we are positioned (have DBPOS currency) on the object
    // which is the source object of the link.
    Assert( !FIsBacklink(ulLinkID) );
    pAC = SCGetAttByLinkId( pDB->pTHS, ulLinkID );
    Assert( pAC );

    // Get name of containing object
    pszObjectDn = GetExtDN( pDB->pTHS, pDB );

    // Translate the backlink dnt if possible
    // pValueDn is null if this doesn't work
    if (err = gDBSyntax[SYNTAX_DISTNAME_TYPE].IntExt(
        pDB,
        DBSYN_INQ,
        sizeof( ULONG ),
        (CHAR *) &backlinkDnt,
        &len,
        (CHAR **) &pValueDn,
        0,
        0,
        0 /*SyntaxFlags*/ )) {
        DPRINT2( 0, "IntExt of %d got error %d\n", backlinkDnt, err );
    }

    // Note, pValueDn is allocated in some temporary space. You will need to
    // copy the value out if you do any subsequent dblayer operations.

    //
    // Display the information
    //


    DPRINT6( 2, "DBLogLinkValueMeta, ncdnt = %d, obj = %s(%d), attr = %s, value = %ls(%d)\n",
             pDB->NCDNT,
             pszObjectDn, linkDnt,
             pAC->name,
             pValueDn ? pValueDn->StringName : L"(not available)", backlinkDnt );

    if (!fPresent) {
        DSTimeToDisplayString(timeDeletion, szTime);
        DPRINT1( 4, "\tdeltime = %s\n", szTime );
    }

    // Log the kind of operation that was performed
    LogEvent8( DS_EVENT_CAT_LVR,
               DS_EVENT_SEV_VERBOSE,
               dwEventCode,
               szInsertSz( pszObjectDn ),
               szInsertSz(pAC->name),
               pValueDn ? szInsertDN( pValueDn ) : szInsertSz("Not available"),
               fPresent ? szInsertSz("Not deleted") : szInsertSz( szTime ),
               NULL, NULL, NULL, NULL
        );

    DSTimeToDisplayString(pMetaDataExt->timeCreated, szTime1);
    DSTimeToDisplayString(pMetaDataExt->MetaData.timeChanged, szTime2);

    DPRINT6( 5, "[%s,%d,%s,%I64d,%s,%I64d]\n",
             szTime1,
             pMetaDataExt->MetaData.dwVersion,
             DsUuidToStructuredString(&pMetaDataExt->MetaData.uuidDsaOriginating, szUuid),
             pMetaDataExt->MetaData.usnOriginating,
             szTime2,
             *pUsn  );

    // Log the metadata
    LogEvent8( DS_EVENT_CAT_LVR,
               DS_EVENT_SEV_VERBOSE,
               DIRLOG_LVR_META_INFO,
               szInsertSz(szTime1),
               szInsertUL(pMetaDataExt->MetaData.dwVersion),
               szInsertUUID(&pMetaDataExt->MetaData.uuidDsaOriginating),
               szInsertUSN(pMetaDataExt->MetaData.usnOriginating),
               szInsertSz(szTime2),
               szInsertUSN(*pUsn),
               NULL, NULL
        );

} /* logLinkValueMetaData */


void
dbSetLinkValueMetaData(
    IN  DBPOS *pDB,
    IN  DWORD dwEventCode,
    IN  ATTCACHE *pAC,
    IN  VALUE_META_DATA *pMetaDataLocal OPTIONAL,
    IN  VALUE_META_DATA *pMetaDataRemote OPTIONAL,
    IN  DSTIME *ptimeCurrent OPTIONAL
    )

/*++

Routine Description:

Set the metadata properties on the value record.
We assume we are in a Jet Prepare Update.
There are three cases for the local metadata:
1. Fully populated because the row exists with LVR data
2. Partially populated because the row exists with legacy data
3. No local metadata cause new row being written.

   fGCLocalCleanup?
   Authoritative Modify?

The following is from section "Originating Writes" of the LVR spec:
On an originating write of a link-table row (identified by its <source DNT,
destination DNT, link-id>) the creation timestamp is assigned as follows:

Legacy row already exists on this replica. (This would happen e.g. if you are
removing a value that is included in the legacy part of a multivalue. Or if
you are changing the value of "stuff" in an instance of one of the "DN plus
stuff" syntaxes.) Convert the legacy row to LVR. Set the row's creation timestamp
by reading the creation time of the row's containing object (source DNT.)

LVR row already exists on this replica. (This would happen e.g. if you are adding
a value that was deleted less than a tombstone lifetime ago, so the value exists
as an absent value on this replica. Or if you are changing the value of "stuff"
in an instance of one of the "DN plus stuff" syntaxes.) Do not change
the creation timestamp.

Row does not exist on this replica. (This would happen e.g. if you are adding
a row that never existed, or that existed earlier but then was deleted and
finally garbage-collected.) Create a new LVR row. Set the creation timestamp of
the new row by reading the system clock.

The other metadata components in an LVR row are assigned on originating
update just as they are today for attribute updates: The version number
starts at 1 for a new row, increments the current value for an existing row.
The update timestamp comes from reading the system clock during the
originating update. The dc-guid is the invocation ID of the DC performing
the originating update.

Arguments:

    pDB - dbpos, in prepared update
    pMetaDataLocal - Metadata to be written
    pMetaDataRemote - remote metadata, if any, to be merged
    ptimeCurrent - Time to use if the caller desires to specify
                   Only used if pMetaDataRemote == NULL

Return Value:

    None

--*/

{
    THSTATE *pTHS = pDB->pTHS;
    USN usn;
    DSTIME timeCurrent;
    BOOL fWriteAllColumns;
    VALUE_META_DATA_EXT metaDataExt;
    VALUE_META_DATA_EXT *pMetaDataExt = &( metaDataExt );
    VALUE_META_DATA metaDataTouched;
    JET_SETCOLUMN attList[3];
    DWORD cAtts;

    Assert(VALID_DBPOS(pDB));
    // We don't support getting/setting metadata on backlinks because this
    // code assumes we are positioned (have DBPOS currency) on the object
    // which is the source object of the link.
    Assert( pAC->ulLinkID );
    Assert( !FIsBacklink(pAC->ulLinkID) );

    // We better be in LVR mode
    if (!pTHS->fLinkedValueReplication) {
        Assert( !"Can't apply value metadata when not in proper mode!" );
        DsaExcept(DSA_DB_EXCEPTION, ERROR_DS_INTERNAL_FAILURE, 0);
    }

    fWriteAllColumns = ( (pMetaDataLocal == NULL) ||
                          IsLegacyValueMetaData( pMetaDataLocal ) );

    usn = DBGetNewUsn();

    if (NULL == ptimeCurrent) {
        timeCurrent = DBTime();
        ptimeCurrent = &timeCurrent;
    }

    if (NULL == pMetaDataRemote) {

        //
        // An originating write
        //

        if (NULL == pMetaDataLocal) {

            // A new value
            pMetaDataExt->timeCreated = *ptimeCurrent;
            pMetaDataExt->MetaData.dwVersion = 1;

        } else {

            // An existing value
            // Legacy values should appear here, with metadata derived from the
            // containing object
            pMetaDataExt->timeCreated = pMetaDataLocal->timeCreated;
            pMetaDataExt->MetaData.dwVersion =
                pMetaDataLocal->MetaData.dwVersion + 1;
        }

        pMetaDataExt->MetaData.timeChanged = *ptimeCurrent;
        pMetaDataExt->MetaData.uuidDsaOriginating = pTHS->InvocationID;
        pMetaDataExt->MetaData.usnOriginating = usn;

    } else {

        //
        // A replicated write.
        //

        pMetaDataExt->timeCreated          = pMetaDataRemote->timeCreated;
        pMetaDataExt->MetaData.dwVersion   = pMetaDataRemote->MetaData.dwVersion;
        pMetaDataExt->MetaData.timeChanged = pMetaDataRemote->MetaData.timeChanged;
        pMetaDataExt->MetaData.uuidDsaOriginating =
            pMetaDataRemote->MetaData.uuidDsaOriginating;
        pMetaDataExt->MetaData.usnOriginating = pMetaDataRemote->MetaData.usnOriginating;
    }

    memset( attList, 0, sizeof( attList ) );

    cAtts = 2;
    // Set LINKUSNCHANGED
    attList[0].columnid = linkusnchangedid;
    attList[0].pvData = &usn;
    attList[0].cbData = sizeof( usn );
    attList[0].itagSequence = 1;
    // Set LINKMETADATA
    attList[1].columnid = linkmetadataid;
    attList[1].pvData = &metaDataExt;
    attList[1].cbData = sizeof( metaDataExt );
    attList[1].itagSequence = 1;
    // Set LINKNCDNT
    if (fWriteAllColumns) {
        attList[2].columnid = linkncdntid;
        attList[2].pvData = &(pDB->NCDNT);
        attList[2].cbData = sizeof( ULONG );
        attList[2].itagSequence = 1;
        cAtts++;
    }

    JetSetColumnsEx(pDB->JetSessID, pDB->JetLinkTbl, attList, cAtts );

    DBLogLinkValueMetaData( pDB, dwEventCode, &usn, pMetaDataExt );

    // This cached metadata is a summary: it is the highest value metadata
    // written in this transaction across all attributes on the local
    // machine.
    // timeChanged is the only thing we really care about.

    memset( &metaDataTouched, 0, sizeof( metaDataTouched ) );
    metaDataTouched.MetaData.timeChanged = pMetaDataExt->MetaData.timeChanged;
    metaDataTouched.MetaData.usnProperty = usn;

    dbTouchLinkMetaData( pDB, &metaDataTouched );

} /* dbSetValueMetaData */


BOOL
dbHasAttributeMetaData(
    IN  DBPOS *     pDB,
    IN  ATTCACHE *  pAC
    )
/*++

Routine Description:

    Detect whether attribute-granular meta data exists for a given attribute on
    the current object.  This routine specifically does *not* check for the
    presence of value-granular meta data.

Arguments:

    pDB (IN) - positioned on object for which meta data is being queried
    
    pAC (IN) - attribute for which meta data is to be checked
    
Return Values:

    TRUE if there exists attribute-granular meta data for this attribute,
    FALSE if not.
    
    Throws exception on catastrophic failure (e.g., failure to allocate memory).

--*/
{
    PROPERTY_META_DATA * pMetaData;
    
    // Caller should have already performed a dbInitRec().  This ensures that
    // if we are the first to cache the meta data for this object, we can rest
    // assured that the caller will eventually call either DBUpdateRec() or
    // DBCancelRec() to flush the meta data vector from the DBPOS.
    Assert(pDB->JetRetrieveBits == JET_bitRetrieveCopy);

    if (pAC->bIsNotReplicated) {
        // No meta data for non-replicated attributes.
        pMetaData = NULL;
    } else {
        // Cache pre-existing meta data if we haven't done so already.
        if (!pDB->fIsMetaDataCached) {
            dbCacheMetaDataVector(pDB);
        }
    
        // Determine if this object has attribute-level meta data for the given
        // attribute.
        pMetaData = ReplLookupMetaData(pAC->id, pDB->pMetaDataVec, NULL);
    }

    return (NULL != pMetaData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dbobj.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbobj.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <dsatools.h>                   // For pTHStls
#include <mdlocal.h>                    // IsRoot
#include <ntseapi.h>
#include <xdommove.h>

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>
#include "ntdsctr.h"

// Assorted DSA headers
#include "dsevent.h"
#include "dstaskq.h"
#include "dstrace.h"       /* needed for GetCallerTypeString*/
#include "objids.h"        /* needed for ATT_MEMBER and ATT_IS_MEMBER_OFDL */
#include <dsexcept.h>
#include <filtypes.h>      /* Def of FI_CHOICE_???                  */
#include <anchor.h>
#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DBOBJ:" /* define the subsystem for debugging */
#include <dsutil.h>

// DBLayer includes
#include "dbintrnl.h"

// Replication includes
#include "ReplStructInfo.hxx"

#include <fileno.h>
#define  FILENO FILENO_DBOBJ

/* Internal functions */

extern DWORD dbGetConstructedAtt(
   DBPOS **ppDB,
   ATTCACHE *pAC,
   ATTR *pAttr,
   DWORD dwBaseIndex,
   PDWORD pdwNumRequested,
   BOOL fExternal
);

DWORD
dbSetValueIfUniqueSlowVersion (
        DBPOS *pDB,
        ATTCACHE *pAC,
        PUCHAR pVal,
        DWORD  valLen);

int
IntExtSecDesc(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG intLen,   UCHAR *pIntVal,
              ULONG *pExtLen, UCHAR **ppExtVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG SecurityInformation);


DNList  *pAddListHead = NULL;
extern CRITICAL_SECTION csAddList;

DWORD gMaxTransactionTime;   // the threshold for logging a long-running transaction(in tick)

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/*
Routine Description:

   Open a database handle by allocating and initializing the value
   and DBPOS structures.  Create unique JET session, database, data table
   and search table ids for the DBPOS. Create an "INSERT" JET copy buffer.
   Callers to this routine must have both a thread state (from
   create_thread_state) and a JET session id and DBid (from InitJetThread)

Arguments:

   fNewTransaction - TRUE/FALSE whether to open a new nested transaction

   pPDB - where to store the newly opened DBPOS

Return Value:

   Throws an exception on error.

*/


void
DBOpen2(BOOL fNewTransaction, DBPOS FAR **pPDB)
{
    THSTATE *pTHS = pTHStls;
    DBPOS FAR *pDB;

    DPRINT(2, "DBOpen entered\n");

    pDB = NULL;  /*Needed for bootstrap incase initial allocation fails*/

    if (eServiceShutdown) {
        if (   (eServiceShutdown >= eSecuringDatabase)
            || (    pTHS->fSAM
                || !pTHS->fDSA)) {
            RaiseDsaExcept(DSA_DB_EXCEPTION,
                           DIRERR_SHUTTING_DOWN,
                           0,
                           DSID(FILENO,__LINE__),
                           DS_EVENT_SEV_NO_LOGGING);
        }
    }

    Assert(pTHS);

    if ((&(pTHS->pDB) == pPDB) && (pTHS->pDB)){
        /* Already have a dbPos for this THSTATE. */
        DPRINT(0,"DBOpen, pTHS->pDB pDB exists, exiting\n");
#ifdef INCLUDE_UNIT_TESTS
        DebugBreak();
#endif
        return;
    }

    pDB = dbAlloc(sizeof(DBPOS));
    memset(pDB, 0, sizeof(DBPOS));   /*zero out the structure*/


    /* Initialize value work buffer */

    DPRINT(5, "ALLOC and valBuf\n");
    pDB->pTHS = pTHS;
    pDB->pValBuf = dbAlloc(VALBUF_INITIAL);
    pDB->valBufSize = VALBUF_INITIAL;
    pDB->Key.pFilter = NULL;
    pDB->transType = pTHS->transType;
    pDB->transincount = 0;
    pDB->NewlyCreatedDNT = INVALIDDNT;
#if DBG
     pDB->TransactionLevelAtOpen = pTHS->transactionlevel;
#endif

    Assert(pTHS->JetCache.sesid);

    // get thread's JET session for new pDB
    pDB->JetSessID = pTHS->JetCache.sesid;
    pDB->JetDBID = pTHS->JetCache.dbid;

    if (pTHS->JetCache.tablesInUse) {
        // The cached set of tables for this session is already in use,
        // so we need to open a new set.

        // Note that the table handles in the cache are still valid, though,
        // so that instead of having to open a new set we can just duplicate
        // them, which is much faster.  The one oddity is that we don't know
        // whether or not it is legal/valid/safe to duplicate a cursor that
        // is in the middle of an update, and that being in the middle of
        // an update is the general reason that we end up calling DBOpen
        // to begin with.  However, only the objtbl cursor could be in the
        // middle of an update, since all updates on the link or search tables
        // are completed as soon as they're begun.  Since the search table
        // is nothing but a duplicate of the obj table to begin with, we
        // can safely duplicate the other direction to get an update-free
        // cursor.

        // Open the data table, from the cached search table
        JetDupCursorEx(pDB->JetSessID,
                       pTHS->JetCache.searchtbl,
                       &pDB->JetObjTbl,
                       0);

        // and the search table, from where you'd expect
        JetDupCursorEx(pDB->JetSessID,
                       pTHS->JetCache.searchtbl,
                       &pDB->JetSearchTbl,
                       0);

        // and the link table
        JetDupCursorEx(pDB->JetSessID,
                       pTHS->JetCache.linktbl,
                       &pDB->JetLinkTbl,
                       0);

        // and the propagator
        JetDupCursorEx(pDB->JetSessID,
                       pTHS->JetCache.sdproptbl,
                       &pDB->JetSDPropTbl,
                       0);

        // and the SD table
        JetDupCursorEx(pDB->JetSessID,
                       pTHS->JetCache.sdtbl,
                       &pDB->JetSDTbl,
                       0);
        // we usually need ID index (primary -- so pass NULL for better perf)
        JetSetCurrentIndex4Success(pDB->JetSessID,
                                   pTHS->JetCache.sdtbl,
                                   NULL,
                                   &idxSDId,
                                   0);
    }
    else {
        // The cached set of tables for this session is still available,
        // so all we need to do is copy the handles and mark them as in use.

        pDB->JetObjTbl = pTHS->JetCache.objtbl;
        pDB->JetSearchTbl = pTHS->JetCache.searchtbl;
        pDB->JetLinkTbl = pTHS->JetCache.linktbl;
        pDB->JetSDPropTbl = pTHS->JetCache.sdproptbl;
        pDB->JetSDTbl = pTHS->JetCache.sdtbl;
        pTHS->JetCache.tablesInUse = TRUE;
    }

    // Initialize new object

    DBSetFilter(pDB, NULL,NULL, NULL, 0,NULL);
    DBInitObj(pDB);
    if(fNewTransaction) {
        DBTransIn(pDB);
    }

    *pPDB = pDB;
    pTHS->opendbcount++;

#if DBG
    //
    // In debug builds set some tracking information
    //

    pTHS->Totaldbpos++;
    Assert(pTHS->opendbcount<MAX_PDB_COUNT);
    pTHS->pDBList[pTHS->opendbcount-1]= pDB;
    dbAddDBPOS (pDB, pTHS->JetCache.sesid);
#endif

    DPRINT1(2, "DBOpen complete pDB:%x\n", pDB);
    return;

}/*DBOpen*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Close the database handle by freeing all the resources associated with
   the handle. Free value buffer, and close the JET session
   (this will free all JET resources).  If this set of database tables are
   the set being cached for this JET session then we rely on DBCloseThread
   to actually do the resource freeing.
*/
DWORD APIENTRY
DBClose(DBPOS FAR *pDB, BOOL fCommit)
{
    DWORD TimeDiff;
    THSTATE *pTHS=pTHStls;

    if (!pDB)
    {
        DPRINT(0,"DBClose, pDB already freed, exiting\n");
#ifdef INCLUDE_UNIT_TESTS
        DebugBreak();
#endif
        return 0;
    }

    Assert(VALID_DBPOS(pDB));

    __try
    {
        if(pDB->transincount) {

            if (fCommit) {

                TimeDiff = GetTickCount() - pTHS->JetCache.cTickTransLevel1Started;

                // If a transaction lasts longer than expected, let's log it

                if ( TimeDiff > gMaxTransactionTime ) {
                    LogEvent(
                             DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_OVERLONG_TRANSACTION,
                             szInsertUL( TimeDiff/(60*1000) ),         //minutes
                             szInsertUL( TimeDiff/1000%60),            //seconds
                             szInsertSz( GetCallerTypeString(pTHS) )   //caller type
                             );
                }

                // if Commit is specified then assert that the transin
                // level is 1. Caller is responsible for calling DBTransOut
                // on all nested transactions  that were explicitly opened
                // using DBTransOut.

                Assert(1==pDB->transincount);
                DBTransOut(pDB, fCommit, FALSE);

            }
        }
    }
    __finally
    {
        // Free JET resources
        DBCloseSortTable(pDB);

        // Free Jet Resources
        dbCloseTempTables (pDB);

        // Rollback any open transactions we have at this point
        // Note for the commit case we should have committed with the
        // DBTransOut in the try and hence our pDB->transincount
        // should be 0. So we will not acutally try to rollback.
        // Also note that we always rollback till level 0.

        while(pDB->transincount)
        {
            DBTransOut(pDB,FALSE,FALSE);
        }

        if (pDB->JetObjTbl == pTHS->JetCache.objtbl) {
                // This is the cached set of tables for this session.  Don't
                // close them, just mark them as available again.
                Assert(pDB->JetSearchTbl == pTHS->JetCache.searchtbl);
                Assert(pDB->JetLinkTbl == pTHS->JetCache.linktbl);
                Assert(pDB->JetSDPropTbl == pTHS->JetCache.sdproptbl);
                Assert(pDB->JetSDTbl == pTHS->JetCache.sdtbl);
                Assert(pTHS->JetCache.tablesInUse);
                pTHS->JetCache.tablesInUse = FALSE;
        }
        else {
                // This is some nested set of tables.  Junk'em.
                Assert(pDB->JetSearchTbl != pTHS->JetCache.searchtbl);
                Assert(pDB->JetLinkTbl != pTHS->JetCache.linktbl);
                Assert(pDB->JetSDPropTbl != pTHS->JetCache.sdproptbl);
                Assert(pDB->JetSDTbl != pTHS->JetCache.sdtbl);
                JetCloseTable(pDB->JetSessID, pDB->JetObjTbl);
                JetCloseTable(pDB->JetSessID, pDB->JetSearchTbl);
                JetCloseTable(pDB->JetSessID, pDB->JetLinkTbl);
                JetCloseTable(pDB->JetSessID, pDB->JetSDPropTbl);
                JetCloseTable(pDB->JetSessID, pDB->JetSDTbl);
        }


        Assert (pDB->numTempTablesOpened == 0);

        // Free work buffers

        dbFree(pDB->pValBuf);

        if (pDB->fIsMetaDataCached) {
            dbFreeMetaDataVector(pDB);
        }

        Assert (pDB->transincount == 0);

        Assert (pDB->pDNsAdded == NULL);

        // free the filter used
        if (pDB->Key.pFilter) {
            dbFreeFilter (pDB, pDB->Key.pFilter);
        }

        // Free the database anchor

        dbFree(pDB);

#if DBG
        dbEndDBPOS (pDB);
#endif


        // Zero out the pDB pointer so we don't reuse it in error

        if (pTHS->pDB == pDB){
            pTHS->pDB = NULL;
        }

        pTHS->opendbcount--;
    }

    return 0;

}/*DBClose*/


DWORD APIENTRY
DBCloseSafe(DBPOS *pDB, BOOL fCommit)
{
    DWORD err;

    __try {
        err = DBClose(pDB, fCommit);
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        err = DB_ERR_EXCEPTION;
    }

    return err;
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Initialize the pDB and create a new record
*/
DWORD APIENTRY
DBInitObj(DBPOS FAR *pDB)
{

    dbInitpDB(pDB);
    pDB->JetNewRec = TRUE;

    return 0;
}               /*DBInitObj*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Initialize the pDB
*/
DWORD APIENTRY
dbInitpDB(DBPOS FAR *pDB)
{
    (pDB)->root         = FALSE;
    (pDB)->DNT          = ROOTTAG;
    (pDB)->PDNT         = 0L;

    // Initialize key

    pDB->Key.fSearchInProgress = FALSE;
    pDB->Key.ulSearchType = 0;
    pDB->Key.ulSearchRootDnt = 0;

    if (pDB->Key.pFilter) {
        dbFreeFilter (pDB, pDB->Key.pFilter);
        pDB->Key.pFilter = NULL;
    }
    if (pDB->Key.pIndex) {
        dbFreeKeyIndex(pDB->pTHS, pDB->Key.pIndex);
        pDB->Key.pIndex = NULL;
    }

    // If there is a record in the copy buffer, kill it

    DBCancelRec(pDB);

    return 0;
}


// returns: 0 - found next att; 1 - no more atts

DWORD APIENTRY
dbGetNextAttLinkTable (DBPOS FAR *pDB,
                       ATTCACHE **pAC,
                       ULONG SearchState
                       )
{

    JET_ERR           err;
    ULONG            cb;
    ULONG            ulLinkBase;
    ULONG            ulNewLinkBase, ulNewLinkID;
    ULONG            ulObjectDnt;

    Assert(VALID_DBPOS(pDB));

    if(*pAC)
        ulLinkBase = MakeLinkBase((*pAC)->ulLinkID) + 1;
    else
        ulLinkBase = 0;

    if(SearchState == ATTRSEARCHSTATELINKS) {
        JetSetCurrentIndexSuccess(pDB->JetSessID,
                                  pDB->JetLinkTbl,
          (pDB->fScopeLegacyLinks ? SZLINKLEGACYINDEX : SZLINKINDEX) );
    }
    else {
        JetSetCurrentIndexSuccess(pDB->JetSessID,
                                  pDB->JetLinkTbl,
                                  SZBACKLINKINDEX);
    }


 TryAgain:
     // find the next record


    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl, &(pDB->DNT),
        sizeof(pDB->DNT), JET_bitNewKey);
    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
        &ulLinkBase, sizeof(ulLinkBase), 0);
    err = JetSeekEx(pDB->JetSessID,
        pDB->JetLinkTbl, JET_bitSeekGE);

    if ((err != JET_errSuccess) && (err != JET_wrnSeekNotEqual))
    {
        // no more records - return
        return 1;
    }

    // test to verify that we found a qualifying record
    dbGetLinkTableData (pDB,
                        (SearchState != ATTRSEARCHSTATELINKS),
                        FALSE,
                        &ulObjectDnt,
                        NULL,
                        &ulNewLinkBase);

    if (ulObjectDnt != pDB->DNT)
    {
        //  record out of range - no more records so return

        return 1;
    }

    // we found the next attribute - set set up

    if(SearchState == ATTRSEARCHSTATELINKS)
        ulNewLinkID = MakeLinkId(ulNewLinkBase);
    else
        ulNewLinkID = MakeBacklinkId(ulNewLinkBase);

    if (!(*pAC = SCGetAttByLinkId(pDB->pTHS, ulNewLinkID))) {
        DPRINT1(1, "dbGetNextAttLinkTable Invalid Link Id:%ld\n",
                ulNewLinkBase);
        // We've encountered a record whose link base does not map to a
        // link or backlink attribute properly.  If we're looking for
        // backlinks, that just means that this is one of those rare
        // linked attributes for which no backlink is defined, which is
        // perfectly ok.  If we're looking for links, on the other hand,
        // that would mean that we found a backlink for which no link
        // exists, which is perfectly useless.
        Assert(SearchState != ATTRSEARCHSTATELINKS);
        ulLinkBase = ulNewLinkBase + 1;
        goto TryAgain;

    }

    return 0;
} /* dbGetNextAttLinkTable */

DWORD
dbGetNextAtt (
        DBPOS FAR *pDB,
        ATTCACHE **ppAC,
        ULONG *pSearchState
        )
/*++

Routine Description:

    Get the attcache of the next attribute in the link table.

Arguments:

    pDB - the DBPos to use.

    ppAC - pointer to pointer to attcache.  If an attcache is supplied, we
    will look forward in the link table for the next attribute.

    pSearchState - the current search state.  Must be ATTRSEARCHSTATELINKS
    (implying we are looking for link attributes) or ATTRSEARCHSTATEBACKLINKS
    (implying we are looking for backlink attributes).  We update this to
    backlinks after we are done looking for links.

Return Values:

    0 if we found an attribute, 1 otherwise.
    ppAC is filled with the attribute we found.
    pSearchState may be updated to show we are looking for backlinks.

    Note that if pSearchState is ATTRSEARCHSTATELINKS, we will return the first
    link OR backlink, while if pSearchState is ATTRSEARCHSTATEBACKLINKS, we
    will only return backlinks

--*/
{

   // find the first attr after the current attr with a different type

   DPRINT(2, "dbGetNextAtt entered\n");

   Assert(VALID_DBPOS(pDB));

   while (1)
   {
       switch (*pSearchState) {
       case ATTRSEARCHSTATELINKS:
           if (!dbGetNextAttLinkTable(pDB,
                                      ppAC,
                                      *pSearchState))
               return 0;

           // no more link attributes - look for backlinks
           *pSearchState = ATTRSEARCHSTATEBACKLINKS;
           *ppAC = NULL;
           break;

       case ATTRSEARCHSTATEBACKLINKS:
           if (!dbGetNextAttLinkTable(pDB,
                                      ppAC,
                                      *pSearchState))
               return 0;

           // no more backlink attributes - we're done

           return 1;

       default:
           Assert(FALSE);       // we should never be here
           return 1;
       }
   }
} /* dbGetNextAtt */

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Get the Nth attribute value.
   A non-zero return indicates that the requested value doesn't exist.

   The caller can choose to have values returned in internal or external
   format.

   return 0 - found value
   return DB_ERR_NO_VALUE - didn't find value
   return DB_ERR_BUFFER_INADEQUATE - buffer provided was not big enough
   return DB_ERR_UNKNOWN_ERROR - some other error

   NOTE!!!! This routine does not pass any SecurityDescriptorFlags to the
   internal to external data format conversions.  What this means is that you
   will always get back ALL parts of a Security Descriptor using this routine.
   DBGetMultipeAtts is wired to use SecurityDescriptorFlags, if it is important
   to you to trim parts from the SD, use that routine.

*/
DWORD
DBGetAttVal_AC (
        DBPOS FAR *pDB,
        DWORD tagSequence,
        ATTCACHE *pAC,
        DWORD Flags,
        ULONG InBuffSize,
        ULONG *pLen,
        UCHAR **ppVal
        )
{
    THSTATE             *pTHS=pDB->pTHS;
    JET_RETINFO         retinfo;
    JET_ERR             err;
    ULONG               actuallen = 0;
    int                 rtn;
    BOOL                MakeExt=!(Flags & DBGETATTVAL_fINTERNAL);
    BOOL                fReallocDown = FALSE;
    DWORD               dwSyntaxFlag = 0;
    JET_TABLEID         jTbl;

    if(Flags & DBGETATTVAL_fUSESEARCHTABLE) {
        jTbl = pDB->JetSearchTbl;
    }
    else {
        jTbl =  pDB->JetObjTbl;
    }

    if(Flags & DBGETATTVAL_fSHORTNAME) {
        dwSyntaxFlag = INTEXT_SHORTNAME;
    }
    else if(Flags &  DBGETATTVAL_fMAPINAME) {
        dwSyntaxFlag = INTEXT_MAPINAME;
    }

    DPRINT2(2, "DBGetAttVal_AC entered, fetching 0x%x (%s)\n",
            pAC->id, pAC->name);

    Assert(VALID_DBPOS(pDB));
    Assert(!(Flags & DBGETATTVAL_fCONSTANT) || ((PUCHAR)pLen != *ppVal));
    Assert(tagSequence != 0);  // tags are 1-based, not 0-based

    if (!InBuffSize && (Flags & DBGETATTVAL_fREALLOC)) {
        // We have been given permission to realloc, but nothing has been
        // alloced.  This is the same case as if we were not given realloc
        // permission and so must just alloc.  Unset the realloc flag, leaving
        // us at the default behaviour, which is to alloc.
        Flags = Flags & ~DBGETATTVAL_fREALLOC;
    }

    if(!(Flags & DBGETATTVAL_fCONSTANT) && !(Flags & DBGETATTVAL_fREALLOC)) {
        // Since we don't have a currently existing buffer, make sure the
        // InBuffSize is 0
        InBuffSize = 0;
    }

    // if this attribute is stored in the link table get it differently
    if (pAC->ulLinkID) {
        if (err = dbGetLinkVal(pDB,
                               tagSequence,
                               &pAC,
                               Flags,
                               InBuffSize,
                               ppVal,
                               &actuallen)) {
            return err;
        }
        // dbGetLinkVal makes sure that a big enough buffer already exists, so
        // set the InBuffSize to be big enough here so that we pass the checks
        // we make later during conversion to external format.
        InBuffSize = max(InBuffSize,actuallen);
    }
    else {
        // other attributes are columns in the data table record
        retinfo.cbStruct = sizeof(retinfo);
        retinfo.ibLongValue = 0;
        retinfo.itagSequence = tagSequence;
        retinfo.columnidNextTagged = 0;

        if ((0 == InBuffSize) &&
            !(Flags & DBGETATTVAL_fCONSTANT)) {
            // We *know* that the Jet call will fail with inadequate
            // buffer, because we don't have a buffer, and we also know
            // that the user wants us to alloc a buffer for him.
            // Since a realloc is felt to be cheaper than a Jet call,
            // let's fake up a buffer now based on the schema size for
            // this att and give that a try.
            switch (pAC->syntax) {
              case SYNTAX_OBJECT_ID_TYPE:
              case SYNTAX_INTEGER_TYPE:
                InBuffSize = sizeof(LONG);
                break;
              case SYNTAX_TIME_TYPE:
                InBuffSize = sizeof(DSTIME);
                break;
              case SYNTAX_I8_TYPE:
                InBuffSize = sizeof(LARGE_INTEGER);
                break;
              case SYNTAX_BOOLEAN_TYPE:
                InBuffSize = sizeof(BOOL);
                break;
              case SYNTAX_UNICODE_TYPE:
                if (pAC->rangeUpperPresent) {
                    InBuffSize = min(pAC->rangeUpper*sizeof(WCHAR), 1000);
                }
                break;
              case SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE:
                if (pAC->rangeUpperPresent) {
                    InBuffSize = min(pAC->rangeUpper, DEFAULT_SD_SIZE);
                }
                break;
              case SYNTAX_OCTET_STRING_TYPE:
              case SYNTAX_SID_TYPE:
              case SYNTAX_CASE_STRING_TYPE:
              case SYNTAX_NOCASE_STRING_TYPE:
              case SYNTAX_PRINT_CASE_STRING_TYPE:
              case SYNTAX_NUMERIC_STRING_TYPE:
                if (pAC->rangeUpperPresent) {
                    InBuffSize = min(pAC->rangeUpper, 1000);
                }
                break;
              case SYNTAX_DISTNAME_TYPE:
              case SYNTAX_DISTNAME_STRING_TYPE:
              case SYNTAX_DISTNAME_BINARY_TYPE:
              case SYNTAX_ADDRESS_TYPE:
                InBuffSize = DSNameSizeFromLen(MAX_RDN_SIZE);
                break;
              default:
                // Confusion.  Just don't do it.
                ;
            }
            if (InBuffSize) {
                *ppVal = THAllocEx(pTHS, InBuffSize);
                fReallocDown = TRUE;
            }
        }

        err = JetRetrieveColumnWarnings(
                pDB->JetSessID,
                jTbl,
                pAC->jColid,
                *ppVal,
                InBuffSize,
                &actuallen,
                pDB->JetRetrieveBits,
                &retinfo);

        if(err == JET_wrnBufferTruncated) {
            if (Flags & DBGETATTVAL_fCONSTANT)
                return DB_ERR_BUFFER_INADEQUATE;
            else if(Flags & DBGETATTVAL_fREALLOC) {
                // Buff given was too small.  THReAlloc it.
                Assert(InBuffSize < actuallen);
                *ppVal = THReAllocEx(pTHS, *ppVal, actuallen);
                InBuffSize = actuallen;
            }
            else {
                *ppVal = THAllocEx(pTHS, actuallen);
                 InBuffSize = actuallen;
            }

            err = JetRetrieveColumnWarnings(
                    pDB->JetSessID,
                    jTbl,
                    pAC->jColid,
                    *ppVal,
                    actuallen,
                    &actuallen,
                    pDB->JetRetrieveBits,
                    &retinfo);
            if(err) {
                if(fReallocDown ||
                   !(Flags & (DBGETATTVAL_fCONSTANT | DBGETATTVAL_fREALLOC))) {
                    // Hey, we just allocated this.
                    THFreeEx(pTHS, *ppVal);
                    *ppVal = NULL;
                }
                return DB_ERR_UNKNOWN_ERROR;
            }
        }

        if(err) {
            if (fReallocDown) {
                THFreeEx(pTHS, *ppVal);
                *ppVal = NULL;
            }

            // if we are trying to read the SD and this is NULL then
            // we enqueue a SD propagation to fix this.
            // Exception to this is when we deliberately try to remove
            // an attribute from this object (from DBRemAtt*)

            if(pAC->id == ATT_NT_SECURITY_DESCRIPTOR &&
               err == JET_wrnColumnNull &&
               !(Flags & DBGETATTVAL_fUSESEARCHTABLE) &&
               !(Flags & DBGETATTVAL_fDONT_FIX_MISSING_SD)) {
                // Security descriptor has no value in the object table.
                // Enqueue a propagation to get this fixed.
                InsertInTaskQueue(TQ_DelayedSDPropEnqueue,
                                  (void *)((DWORD_PTR) pDB->DNT),
                                  1);
            }
            // NOTE: the caller may have supplied a buffer.  With this error, we
            // are not telling them about any reallocing we may have done
            // (which, if we did it, would only be to allocate it larger), and
            // we are not touching *pLen, so if they are not tracking the size
            // of their buffer correctly could cause them to leak buffers
            // (i.e. if they aren't tracking the max size of the buffer returned
            // to them, but only the current size, they may think that the
            // current size is 0 after this call, and if they call back in with
            // InBuffSize of 0, even if they have a pointer to valid memory, we
            // will do a THAlloc and lose their buffer).
            return DB_ERR_NO_VALUE;
        }

    }

    *pLen = actuallen;

    // Convert DB value to external format if so desired.

    if (MakeExt) {
        ULONG extLen;
        PUCHAR pExtVal=NULL;

        // Find out if there any special handling
        // is required for this attribute.
        dwSyntaxFlag|=DBGetExtraHackyFlags(pAC->id);

        // Enable encryption or decryption if the
        // attribute is a secret data
        if (DBIsSecretData(pAC->id))
           dwSyntaxFlag|=INTEXT_SECRETDATA;

        if (rtn = gDBSyntax[pAC->syntax].IntExt (
                pDB,
                DBSYN_INQ,
                *pLen,
                *ppVal,
                &extLen,
                &pExtVal,
                0, 0,
                dwSyntaxFlag)) {
            DsaExcept(DSA_EXCEPTION, DIRERR_BAD_ATT_SYNTAX, rtn);
        }

        if(Flags & DBGETATTVAL_fCONSTANT) {
            // Existing buffer, better be room.  We'll check later.
        }
        else {
            if(InBuffSize < extLen &&
               *pLen < extLen) {
                // Reallocable buffer,
                *ppVal = THReAllocEx(pTHS, *ppVal, extLen);
                InBuffSize = extLen;
            }
        }

        if(InBuffSize < extLen)
            return DB_ERR_BUFFER_INADEQUATE;

        *pLen = extLen;

        memcpy(*ppVal, pExtVal, extLen);
    }

    if (fReallocDown && (InBuffSize > *pLen)) {
        *ppVal = THReAllocEx(pTHS, *ppVal, *pLen);
    }
    DPRINT1(2,"DBGetAttVal_AC: complete  val:<%s>\n",
            asciiz(*ppVal,(USHORT)*pLen));
    return 0;

} /* DBGetAttVal_AC */

DWORD
DBGetAttVal (
        DBPOS FAR *pDB,
        DWORD tagSequence,
        ATTRTYP aType,
        DWORD Flags,
        ULONG InBuffSize,
        ULONG *pLen,
        UCHAR **ppVal
        )
/*++

   NOTE!!!! This routine does not pass any SecurityDescriptorFlags to the
   internal to external data format conversions.  What this means is that you
   will always get back ALL parts of a Security Descriptor using this routine.
   DBGetMultipeAtts is wired to use SecurityDescriptorFlags, if it is important
   to you to trim parts from the SD, use that routine.

--*/
{
    ATTCACHE            *pAC;

    DPRINT(5, "DBGetAttVal entered\n");
    Assert(VALID_DBPOS(pDB));
    if (!(pAC = SCGetAttById(pDB->pTHS, aType))) {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, aType);
    }
    return DBGetAttVal_AC(pDB, tagSequence, pAC, Flags, InBuffSize, pLen,
                          ppVal);

} /* DBGetAttVal */



DWORD
DBAddAtt_AC (
        DBPOS FAR *pDB,
        ATTCACHE *pAC,
        UCHAR syntax
        )
/*++

Routine Description:

    Add an attribute with no values.  It is an error if the attribute already
    exists. Adding an attribute doesn't actually do anything to the database.

    This function assumes that we are positioned on a database object.

Argumets:

    pDB - the DBPos to use

    aType - the attribute to add.

    syntax - the expected syntax of the attribute.

Return Values:

    0 - no error
    DB_ERR_ATTRIBUTE_EXISTS - attribute already exists.
    DB_ERR_BAD_SYNTAX - attribute cannot be found in schema or syntax is
        incorrect.

--*/
{
    DPRINT1(2, "DBAddAtt_AC entered, add attr type <%lu>\n",pAC->id);

    Assert(VALID_DBPOS(pDB));

    // NOTE: this behaviour was not enforced before 5/20/96
    if(pAC->syntax != syntax        ) {
        Assert(0);
        return DB_ERR_BAD_SYNTAX;
    }

    // PERF 97/09/08 JeffParh TimWi
    //
    // Even though we're not necessarily about to perform a write, we need
    // to init the record because we _are_ about to perform a read, possibly
    // of what's supposed to be a brand new record.  This new record is never
    // actually created until dbInitRec() is performed, however -- until then,
    // we're still poitioned on the last record with currency; i.e., a read
    // would return data from this last record, rather than correctly claiming
    // that no such data exists on the new record.
    //
    // Perhaps we need a clearer notion of when such new records are created
    // (maybe create them immediately in DBInitObj()?)
    dbInitRec(pDB);

    //Check for existing values. Cannot add attribute that exists
    if (DBHasValues_AC(pDB, pAC)) {
        DPRINT(1, "DBAddAtt_AC: Attribute already exists\n");
        return DB_ERR_ATTRIBUTE_EXISTS;
    }

    // Touch replication meta data for this attribute.
    // Never optimize this out for fDRA.
    DBTouchMetaData(pDB, pAC);

    return 0;
}/*DBAddAtt*/

DWORD
DBAddAtt (
        DBPOS FAR *pDB,
        ATTRTYP aType,
        UCHAR syntax
        )
/*++

Routine Description:

    Add an attribute with no values.  It is an error if the attribute already
    exists. Adding an attribute doesn't actually do anything to the database.

    This function assumes that we are positioned on a database object.

    This function just looks up the attcache and calls DBAddAtt_AC

Argumets:

    pDB - the DBPos to use

    aType - the attribute to add.

    syntax - the expected syntax of the attribute.

Return Values:

    0 - no error
    DB_ERR_ATTRIBUTE_EXISTS - attribute already exists.
    DB_ERR_BAD_SYNTAX - attribute cannot be found in schema or syntax is
        incorrect.

--*/
{
    ATTCACHE *pAC;
    DPRINT1(5, "DBAddAtt entered, add attr type <%lu>\n",aType);

    Assert(VALID_DBPOS(pDB));

    if(!(pAC = SCGetAttById(pDB->pTHS, aType))) {
        return DB_ERR_BAD_SYNTAX;
    }

    return DBAddAtt_AC(pDB,pAC,syntax);

}/*DBAddAtt*/

DWORD
DBAddAttValEx_AC (
        DBPOS FAR *pDB,
        ATTCACHE *pAC,
        ULONG extLen,
        void *pExtVal,
        VALUE_META_DATA *pRemoteValueMetaData
        )
/*++

Routine Description:

    Add an attribute value to the given attribute in the current object.
    If the value already exists, it cannot be added.

Return Values:

    A non-zero return indicates an error.

*/
{
    ULONG        intLen;                // The length of the internal value
    UCHAR        *pIntVal;              // Points to the internal value
    int          rtn;                   // syntax return code
    JET_SETINFO  setinfo;
    JET_RETINFO  retinfo;
    ULONG        actuallen;
    JET_ERR      err;
    DWORD        dwSyntaxFlags=0;
    BOOL         fFound = FALSE;
    // Look up the attribute.

    DPRINT1(2, "DBAddAttVal_AC entered, get att with type <%lu>\n",pAC->id);

    Assert(VALID_DBPOS(pDB));

    // add new value
    dbInitRec(pDB);

    if (FIsBacklink(pAC->ulLinkID)) {
        // we do not allow adding backlinks explicitly - it's a mess
        return DB_ERR_NOT_ON_BACKLINK;
    }

    switch(pAC->id) {

    case ATT_OBJ_DIST_NAME:
        dwSyntaxFlags |= EXTINT_NEW_OBJ_NAME;
        break;
    case ATT_DN_REFERENCE_UPDATE:
        dwSyntaxFlags |= EXTINT_UPDATE_PHANTOM;
        break;
    default:
        if (DBIsSecretData(pAC->id)){
            dwSyntaxFlags |= EXTINT_SECRETDATA;
        }
        else if ( (pDB->pTHS->fDRA) && (pAC->ulLinkID) ) {
            // For inbound repl, for dn-valued, reject deleted
            dwSyntaxFlags = EXTINT_REJECT_TOMBSTONES;
        }
    }

    if (dwSyntaxFlags & EXTINT_REJECT_TOMBSTONES) {
        // Since we are doing tombstone rejection, try to use the INQ
        // mode first since it is optimized.
        rtn=gDBSyntax[pAC->syntax].ExtInt(
            pDB,
            DBSYN_INQ,
            extLen,
            pExtVal,
            &intLen,
            &pIntVal,
            pDB->DNT,
            pDB->JetObjTbl,
            dwSyntaxFlags);
        if (!rtn) {
            // Value exists, add a reference count
            dbAdjustRefCountByAttVal(pDB, pAC, pIntVal, intLen, 1);
            fFound = TRUE;
        } else if (rtn == ERROR_DS_NO_DELETED_NAME) {
            // If the value is deleted, silently succeed without adding anything
            return 0;
        } else {
            // Fall through and try the add path
            ;
        }
    }

    if (!fFound) {
        // Convert value to internal format
        if(rtn=gDBSyntax[pAC->syntax].ExtInt(
            pDB,
            DBSYN_ADD,
            extLen,
            pExtVal,
            &intLen,
            &pIntVal,
            pDB->DNT,
            pDB->JetObjTbl,
            dwSyntaxFlags)) {
            DPRINT1(1, "Ext-Int syntax conv failed <%u>..return\n", rtn);
            return DB_ERR_SYNTAX_CONVERSION_FAILED;
        }
    }

    // if the attribute is of type link or backlink, call dbAddIntLinkVal
    // to do the work

    if (pAC->ulLinkID)
       return dbAddIntLinkVal(pDB, pAC, intLen, pIntVal, pRemoteValueMetaData );

    // All is ok, Add new value

    switch(pAC->syntax) {
    case SYNTAX_UNICODE_TYPE:
    case SYNTAX_NOCASE_STRING_TYPE:
        // Because non-binary equal values of these syntaxes can be semantically
        // equal, these might require the old slow way of comparing.

        // First, try to use Jet for dup detection.
        setinfo.cbStruct = sizeof(setinfo);
        setinfo.ibLongValue = 0;
        setinfo.itagSequence = 0;
        switch(JetSetColumnWarnings(
                pDB->JetSessID,
                pDB->JetObjTbl,
                pAC->jColid,
                pIntVal,
                intLen,
                JET_bitSetUniqueNormalizedMultiValues,
                &setinfo)) {
        case JET_errMultiValuedDuplicate:
            // Duplicate value.
            return DB_ERR_VALUE_EXISTS;
            break;

        case JET_errMultiValuedDuplicateAfterTruncation:
            // Can't tell if this is unique or not.  Try the old fashioned way.
            if(rtn = dbSetValueIfUniqueSlowVersion (pDB,
                                                    pAC,
                                                    pIntVal,
                                                    intLen)) {
                return rtn;
            }
            break;

        default:
            // Successfully added, it's not a duplicate.
            break;
        }
        break;

    default:
        // Everything else can make use of jet to do the dup detection during
        // the set column.
        setinfo.cbStruct = sizeof(setinfo);
        setinfo.ibLongValue = 0;
        setinfo.itagSequence = 0;
        if(JET_errMultiValuedDuplicate ==
           JetSetColumnWarnings(pDB->JetSessID, pDB->JetObjTbl, pAC->jColid,
                                pIntVal, intLen, JET_bitSetUniqueMultiValues,
                                &setinfo)) {
            // Duplicate value.
            return DB_ERR_VALUE_EXISTS;
        }
    }

    // Touch replication meta data for this attribute.
    // Never optimize this out for fDRA.
    DBTouchMetaData(pDB, pAC);

    if (dbNeedToFlushDNCacheOnUpdate(pAC->id)) {
        pDB->fFlushCacheOnUpdate = TRUE;
    }

    return 0;
} // DBAddAttVal_AC

DWORD
DBAddAttVal_AC (
        DBPOS FAR *pDB,
        ATTCACHE *pAC,
        ULONG extLen,
        void *pExtVal
        )
/*++

Routine Description:

    Add an attribute value to the given attribute in the current object.
    If the value already exists, it cannot be added.

Return Values:

    A non-zero return indicates an error.

*/
{
    return DBAddAttValEx_AC( pDB, pAC, extLen, pExtVal, NULL );
}

DWORD
DBAddAttVal (
        DBPOS FAR *pDB,
        ATTRTYP aType,
        ULONG extLen,
        void *pExtVal
        )
/*++

Routine Description:

    Add an attribute value to the given attribute in the current object.
    If the value already exists, it cannot be added.

    A wrapper around DBAddAttVal_AC

Return Values:

    A non-zero return indicates an error.

*/
{
    ATTCACHE    *pAC;

    // Look up the attribute.

    DPRINT1(2, "DBAddAttVal entered, get att with type <%lu>\n",aType);

    Assert(VALID_DBPOS(pDB));

    if (!(pAC = SCGetAttById(pDB->pTHS, aType))) {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, aType);
    }

    return DBAddAttVal_AC(pDB,pAC, extLen,pExtVal);
} /* DBAddVal */

DWORD
DBReplaceAttVal (
    DBPOS FAR *pDB,
    ULONG tagSequence,
    ATTRTYP  aType,
    ULONG extLen,
    void *pExtVal)
{
    ATTCACHE    *pAC;

    // Look up the attribute
    DPRINT1(5, "DBReplaceAttVal entered, replace att with type <%lu>\n", aType);

    Assert(VALID_DBPOS(pDB));

    if (!(pAC = SCGetAttById(pDB->pTHS, aType)))
    {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, aType);
    }

    return DBReplaceAttVal_AC(pDB, tagSequence, pAC, extLen, pExtVal);
}

DWORD
DBReplaceAttVal_AC (
    DBPOS FAR *pDB,
    ULONG tagSequence,
    ATTCACHE *pAC,
    ULONG extLen,
    void *pExtVal)
/*++

  Routine Description:

    Replace an attribute value at the given position (tagSequence refers to the position).
    **LINK attributes are not handled in ReplaceAttVal_AC**.

  Return Values:
    DB_Success, if successfully replaced;
    DB_ERR_VALUE_EXISTS, if the new value is not unique;
    DB_ERR_BAD_SYNTAX, if the attribute is a LINK attribute;
    DB_ERR_SYNTAX_CONVERSION_FAILED, if syntax conversion failed;

*/
{
    THSTATE    *pTHS=pDB->pTHS;
    ULONG       intLen;         // length of the internal value
    UCHAR       *pIntVal;       // pointer to the internal representation of
                                // value
    int         rtn;            // syntax return code
    JET_SETINFO setinfo;
    JET_RETINFO retinfo;
    UCHAR       *pBuf;
    ULONG       cbBuf;
    ULONG       actuallen;
    DWORD       CurrAttrOccur;
    JET_ERR     err;
    ULONG       dwSyntaxFlags=0;
    UCHAR       *pOldValue = NULL;
    ULONG       cbOldValue;

    DPRINT1(2, "DBReplaceAttVal_AC entered, replace a value of att with type <%lu>\n", pAC->id);

    Assert(VALID_DBPOS(pDB));

    dbInitRec(pDB);

    if (pAC->ulLinkID)
    {
        // it is a link attribute - we don't support replacing values on a linked attribute
        return DB_ERR_BAD_SYNTAX;
    }

    if (pAC->id == ATT_OBJ_DIST_NAME){
        dwSyntaxFlags |= EXTINT_NEW_OBJ_NAME;
    }
    else if (DBIsSecretData(pAC->id)){
        dwSyntaxFlags |= EXTINT_SECRETDATA;
    }

    // convert value to internal format
    if (rtn = gDBSyntax[pAC->syntax].ExtInt(pDB,
                                            DBSYN_ADD,
                                            extLen,
                                            pExtVal,
                                            &intLen,
                                            &pIntVal,
                                            pDB->DNT,
                                            pDB->JetObjTbl,
                                            dwSyntaxFlags))
    {
        DPRINT1(1, "Ext-Int syntax conv failed and returned <%u> \n", rtn);
        return DB_ERR_SYNTAX_CONVERSION_FAILED;
    }

    // check to see the new value is unique (can appear in the position we replace
    //  though in which case the entire replace operation amounts to a no-op)

    cbBuf = intLen; // assume all internal values have the same length...
    pBuf = dbAlloc(cbBuf);
    CurrAttrOccur = 0;
    while (TRUE)
    {
        retinfo.cbStruct = sizeof(retinfo);
        retinfo.itagSequence = ++CurrAttrOccur;
        retinfo.ibLongValue = 0;
        retinfo.columnidNextTagged = 0;

        err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetObjTbl,
                                        pAC->jColid, pBuf, cbBuf,
                                        &actuallen, pDB->JetRetrieveBits,
                                        &retinfo);
        if (err == JET_wrnColumnNull)
        {
            // no values
            err = 0;
            break;
        }
        else if (err == JET_wrnBufferTruncated) {
            // realloc
            if (pBuf == NULL) {
                pBuf = dbAlloc(actuallen);
            }
            else {
                pBuf = dbReAlloc(pBuf, actuallen);
            }
            cbBuf = actuallen;
            // and get again...
            err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetObjTbl,
                                            pAC->jColid, pBuf, cbBuf,
                                            &actuallen, pDB->JetRetrieveBits,
                                            &retinfo);
        }
        if (err) {
            // something else happened...
            DPRINT(0, "Error reading value");
            break;
        }
        if (CurrAttrOccur == tagSequence) {
            // we are replacing this value. Remember it -- will need to deref it later
            pOldValue = pBuf;
            cbOldValue = actuallen;
            // reset pBuf -- a new one will be created on the next loop pass if needed
            pBuf = NULL;
            cbBuf = 0;
        }
        else {
            // looking at another value -- check that it is different
            if (gDBSyntax[pAC->syntax].Eval(
                    pDB,
                    FI_CHOICE_EQUALITY,
                    intLen,
                    pIntVal,
                    actuallen,
                    pBuf))
            {
                // there should be no duplicate
                Assert(!"Duplicate value found");
                err = DB_ERR_VALUE_EXISTS;
                break;
            }
        }
    }

    if (pBuf) {
        dbFree(pBuf);
    }
    if (err) {
        if (pOldValue) {
            dbFree(pOldValue);
        }
        return err;
    }

    if (pOldValue) {
        // adjust the refcount on the old value
        dbAdjustRefCountByAttVal(pDB, pAC, pOldValue, cbOldValue, -1);
        dbFree(pOldValue);
    }

    // Set the new value into position
    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = 0;
    setinfo.itagSequence = tagSequence;
    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, pAC->jColid,
                    pIntVal, intLen, 0, &setinfo);


    // Touch replication meta data for this attribute
    // Never optimize this out for fDRA.
    DBTouchMetaData(pDB, pAC);

    if (dbNeedToFlushDNCacheOnUpdate(pAC->id)) {
        pDB->fFlushCacheOnUpdate = TRUE;
    }

    return DB_success;

} /* DBReplaceAttVal_AC */

VOID
dbAdjustRefCountByAttVal(
        DBPOS    *pDB,
        ATTCACHE *pAC,
        PUCHAR   pVal,
        ULONG    valLen,
        int      adjust)
{
    DWORD tag, dwErr;
    DWORD   actualLength;
    int     refCount;

    if(FIsBacklink(pAC->ulLinkID)) {
        tag = pDB->DNT;
    }
    else {
        switch(pAC->syntax) {
            // These are DNTvalued attributes.  We need to adjust the
            // refcount.
        case SYNTAX_DISTNAME_BINARY_TYPE:
        case SYNTAX_DISTNAME_STRING_TYPE:
            tag = ((INTERNAL_SYNTAX_DISTNAME_STRING *)pVal)->tag;
            break;
        case SYNTAX_DISTNAME_TYPE:
            // Deref the object referenced by the property value being
            // removed.
            tag =  *((DWORD *)pVal);
            break;

        case SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE:
            // SDs are sitting in a separate table with refcounts...
            if (valLen < SECURITY_DESCRIPTOR_MIN_LENGTH) {
                // new-style SD
                Assert(valLen == sizeof(SDID));

                // position on the SD in the SD table (the index is already set)
                JetMakeKeyEx(pDB->JetSessID, pDB->JetSDTbl, pVal, valLen, JET_bitNewKey);

                dwErr = JetSeekEx(pDB->JetSessID, pDB->JetSDTbl, JET_bitSeekEQ);
                if (dwErr) {
                    // did not find a corresponding SD in the SD table
                    DPRINT2(0, "Failed to locate SD, id=%ld, err=%d\n", *((SDID*)pVal), dwErr);
                    Assert(!"Failed to locate SD -- not found in the SD table!");
                    DsaExcept(DSA_DB_EXCEPTION, dwErr, 0);
                }
                DPRINT2(1, "Located SD for id %ld, adjusting refcount by %+d\n", *((SDID*)pVal), adjust);

                // adjust the refcount
                JetEscrowUpdateEx(pDB->JetSessID,
                                  pDB->JetSDTbl,
                                  sdrefcountid,
                                  &adjust,
                                  sizeof(adjust),
                                  NULL,     // pvOld
                                  0,        // cbOldMax
                                  NULL,     // pcbOldActual
                                  0);       // grbit
            }

            // that's it for SDs...
            return;

        default:
            return;
            break;
        }
    }

    // we got here because it was one of the DN-refcounted attributes. tag variable was properly set.
    // now we can adjust the refcount
    DBAdjustRefCount(pDB, tag, adjust);

    return;
}

int __cdecl
DNTAttrValCompare(const void *keyval, const void *datum)
{
    ATTRVAL *pValKey = (ATTRVAL *)keyval;
    ATTRVAL *pValDatum = (ATTRVAL *)datum;
    Assert(pValKey->valLen == sizeof(DWORD));
    Assert(pValDatum->valLen == sizeof(DWORD));

    return ((*(DWORD *)(pValKey->pVal)) - (*(DWORD *)(pValDatum->pVal)));
}

DWORD
DBReplaceAtt_AC(
        PDBPOS  pDB,
        ATTCACHE *pAC,
        ATTRVALBLOCK *pAttrVal,
        BOOL         *pfChanged
        )
/*++

  Three phases to this call
  1) translate external values to internal values.
  2) walk through the existing values on the attribute, remove those values not
  on the list passed in, remove duplicate values from the internal version of
  the list passed in.
  3) Now, only values that must continue to be on the object are still there,
  and only values that must be added to the object are still in the list of
  internal values to add.  Add them.

  Note that pfChanged is optional, if NULL no indication of whether or not
  anything changed is returned to the caller.
--*/
{
    THSTATE     *pTHS = pDB->pTHS;
    ULONG        len;
    DWORD        err, rtn;
    ULONG        index, extIndex, i;
    ULONG        bufSize;
    UCHAR       *pVal;
    ATTRVAL     *pAVal;
    ATTRVALBLOCK IntAttrVal;
    DWORD        dwSyntaxFlags=0;
    BOOL         fNewAllocs=FALSE;
    DWORD        firstNewAtt;
    JET_SETINFO  setinfo;
    PUCHAR       pTemp = NULL;
    BOOL         fChangedSomething=FALSE;
    BOOL         fSorted = FALSE;
    DWORD        SortedValuesIndex;
    PUCHAR      *addAlreadyDoneFor = NULL;
    DWORD        addAlreadyDoneCount;
    BOOL         fAddAlreadyDone;

    if(pfChanged) {
        *pfChanged = FALSE;
    }

    IntAttrVal.pAVal = NULL;
    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = 0;

    // PHASE 1:
    // Translate the external values to internal values.

    // Look up the attribute.
    DPRINT1(2, "DBReplaceAtt_AC entered, get att with type <%lu>\n",pAC->id);

    Assert(VALID_DBPOS(pDB));

    if (FIsBacklink(pAC->ulLinkID)) {
        // we do not allow adding backlinks explicitly - it's a mess
        return DB_ERR_NOT_ON_BACKLINK;
    }

    if (pAC->id == ATT_OBJ_DIST_NAME){
        // We don't allow using this to mess with the OBJ_DIST_NAME, either.
        return DB_ERR_UNKNOWN_ERROR;
    }
    else if (DBIsSecretData(pAC->id)){
        dwSyntaxFlags = EXTINT_SECRETDATA;
    } else if ( (pTHS->fDRA) && (pAC->ulLinkID) ) {
        // For inbound repl, for dn-valued, reject deleted
        dwSyntaxFlags = EXTINT_REJECT_TOMBSTONES;
    }



    // assume we are to add new values
    dbInitRec(pDB);

    // OK, now translate the external values into internal values
    // extIndex iterates through the external array
    // index iterates through the internal array

    IntAttrVal.valCount = pAttrVal->valCount;
    IntAttrVal.pAVal = THAllocEx(pTHS, pAttrVal->valCount * sizeof(ATTRVAL));

    // alloc the array for the list of refCounted (DBSYN_ADDed) values
    addAlreadyDoneFor = THAllocEx(pTHS, pAttrVal->valCount * sizeof(PUCHAR));
    addAlreadyDoneCount = 0;

    index = 0;
    for(extIndex = 0; extIndex < pAttrVal->valCount; extIndex++) {
        // Convert value to internal format
        err = gDBSyntax[pAC->syntax].ExtInt(
                pDB,
                DBSYN_INQ,
                pAttrVal->pAVal[extIndex].valLen,
                pAttrVal->pAVal[extIndex].pVal,
                &IntAttrVal.pAVal[index].valLen,
                &IntAttrVal.pAVal[index].pVal,
                pDB->DNT,
                pDB->JetObjTbl,
                dwSyntaxFlags);

        fAddAlreadyDone = FALSE;
        if(err == DIRERR_OBJ_NOT_FOUND) {
            // This external value must be a DN or a syntax that has a DN in it,
            // and the DN doesn't exist yet.  Try the gdbSyntax[] again,
            // specifying DBSYN_ADD, which will create the appropriate phantom.
            // We are sure this attribute is not present in the current
            // set (i.e. it will not be optimized away) -- because otherwise a
            // phantom would be present. Thus, we can safely inc the refcount now.
            err = gDBSyntax[pAC->syntax].ExtInt(
                    pDB,
                    DBSYN_ADD,
                    pAttrVal->pAVal[extIndex].valLen,
                    pAttrVal->pAVal[extIndex].pVal,
                    &IntAttrVal.pAVal[index].valLen,
                    &IntAttrVal.pAVal[index].pVal,
                    pDB->DNT,
                    pDB->JetObjTbl,
                    dwSyntaxFlags);
            if(!err) {
                // remember that we already adjusted the refcount for this value
                fAddAlreadyDone = TRUE;
            }
        }

        if (err == ERROR_DS_NO_DELETED_NAME) {
            // Conversion rejected deleted dn
            IntAttrVal.valCount--;
            DPRINT1( 2, "Ext-Int rejecting deleted DSNAME %ws from attribute value\n",
                     ((DSNAME *) pAttrVal->pAVal[extIndex].pVal)->StringName );
            continue; // do not increment internal index
        } else if(err) {
            DPRINT1(1, "Ext-Int syntax conv failed <%u>..return\n", err);
            err = DB_ERR_SYNTAX_CONVERSION_FAILED;
            goto CleanUp;
        }
        if(IntAttrVal.pAVal[index].pVal != pAttrVal->pAVal[extIndex].pVal) {
            // The conversion process uses the dbsyntax temp buffer.  Copy the
            // value away to a safe location.
            pTemp = THAllocEx(pTHS, IntAttrVal.pAVal[index].valLen);
            // Remember the fact that we are allocating memory for the values,
            // we'll clean it up later.
            Assert((!fNewAllocs && !index) || (index && fNewAllocs));
            fNewAllocs=TRUE;
            memcpy(pTemp,
                   IntAttrVal.pAVal[index].pVal,
                   IntAttrVal.pAVal[index].valLen);
            IntAttrVal.pAVal[index].pVal = pTemp;
            pTemp = NULL;
        }
        if (fAddAlreadyDone) {
            // now that the value got copied, record that ADD was already called
            addAlreadyDoneFor[addAlreadyDoneCount++] = IntAttrVal.pAVal[index].pVal;
        }

        index++;
    }

    // Preliminary to phase 2:  If this is a link valued attribute, sort the
    // values (i.e. sort the values by DNT).  This is useful because we will be
    // able to short circuit a loop below if we know that the values in the DB
    // are sorted (which they are for link valued atts) AND the values being put
    // into the DB are also sorted.
    // TODO: handle SYNTAX_DISTNAME_BINARY and SYNTAX_DISTNAME_STRING
    // Do it be writing alternate comparision functions for them

    if (pAC->ulLinkID && (pAC->syntax == SYNTAX_DISTNAME_TYPE)) {
        // Yep, this is stored in the link table.  Sort it.
        qsort(IntAttrVal.pAVal,
              IntAttrVal.valCount,
              sizeof(ATTRVAL),
              DNTAttrValCompare);
        fSorted = TRUE;
    }
    // PHASE 2:
    // Now, walk through the existing vals, deleting the ones which do not exist
    // in the change list, and removing the ones in the change list that are
    // already there (I do this by swapping the last unchecked value in the list
    // with the one identified as already on the object.)

    pVal = NULL;
    len = 0;
    bufSize = 0;

    index = 1;
    if (pAC->ulLinkID) {
        err = DBGetNextLinkVal_AC (
                pDB,
                TRUE,
                pAC,
                DBGETATTVAL_fINTERNAL |  DBGETATTVAL_fREALLOC,
                bufSize,
                &len,
                &pVal);
    }
    else {
        err = DBGetAttVal_AC(pDB, index, pAC,
                             DBGETATTVAL_fINTERNAL |  DBGETATTVAL_fREALLOC,
                             bufSize, &len,
                             &pVal);
    }

    // Init pAVal to the front of the list.
    pAVal = IntAttrVal.pAVal;
    SortedValuesIndex = 0;
    while(!err) {
        BOOL fDone = FALSE;

        bufSize = max(bufSize, len);

        if(pAC->id != ATT_OBJECT_CLASS) {
            // Only look for existing atts if not object class.  This att is
            // handled differently because we MUST preserve the order of the
            // Attribute Values.

            if(fSorted) {
                BOOL fEndLoop = FALSE;

                // everything is sorted, do the simpler version of the loop
                // pAVal is already at the correct location.  Either this is the
                // first time through the while loop and we set it correctly
                // before we started, or we've been through here before and we
                // left pAVal pointing to the correct place on the previous exit
                // of loop.
                while(!fEndLoop && SortedValuesIndex < IntAttrVal.valCount) {
                    Assert(pAVal->valLen == sizeof(DWORD));
                    Assert(len == sizeof(DWORD));
                    if(*((DWORD *)pVal) == *((DWORD *)(pAVal->pVal))) {
                        // Matched.  Set the value to the magic value
                        *((DWORD *)pAVal->pVal) = INVALIDDNT;
                        pAVal++;
                        SortedValuesIndex++;
                        fDone = TRUE;
                        fEndLoop = TRUE;
                    }
                    else if(*((DWORD *)pVal) < *((DWORD *)(pAVal->pVal))) {
                        // The current value is greater than the value read from
                        // the DB.  That means that the value read from the DB
                        // isn't in the list, so we're done looking through the
                        // list.  The value in the DB must be removed.
                        fEndLoop = TRUE;
                    }
                    else {
                        // The current value is less than the value read from
                        // the DB.  That means that the value read from the DB
                        // might still be in the list, we have to increment our
                        // position in the list and keep going.
                        SortedValuesIndex++;
                        pAVal++;
                    }
                }
            }
            else {
                // Reinit pAVal to the front of the list.
                DWORD i;
                pAVal = IntAttrVal.pAVal;

                for(i=0;!fDone && i<IntAttrVal.valCount;i++) {
                    // We don't do syntax-sensitive comparisons for
                    // ReplaceAtt().  If someone's surname is changed from
                    // "smith" to "Smith," for example, we want to honor that
                    // change and quiesce to the updated casing across all
                    // replicas.  This is consistent with Exchange 4.0 behavior.
                    // Note that RDN changes do *not* go through this code path
                    // -- though changes in the RDN also quiesce to the same
                    // case across all replicas.
                    if ((len == pAVal->valLen)
                        && (0 == memcmp(pVal, pAVal->pVal, len))) {
                        // Matched
                        fDone = TRUE;
                        // swap this one with the one at the end of the list.
                        pAVal->valLen =
                            IntAttrVal.pAVal[IntAttrVal.valCount - 1].valLen;

                        pTemp = pAVal->pVal;
                        pAVal->pVal =
                            IntAttrVal.pAVal[IntAttrVal.valCount - 1].pVal;
                        IntAttrVal.pAVal[IntAttrVal.valCount - 1].pVal = pTemp;
                        pTemp = NULL;

                        IntAttrVal.valCount--;
                    }
                    else {
                        pAVal++;
                    }
                }
            }
        }


        if(!fDone) {
            // Didn't find it, remove this one.
            fChangedSomething=TRUE;

            Assert(!FIsBacklink(pAC->ulLinkID));

            /// OK, now really delete.
            if(pAC->ulLinkID) {
                dbSetLinkValueAbsent( pDB,
                                      DIRLOG_LVR_SET_META_REPLACE_MADE_ABSENT,
                                      pAC, pVal, NULL /*remote*/ );
            }
            else {
                // First, fix up the refcounts.
                dbAdjustRefCountByAttVal(pDB, pAC, pVal, len, -1);

                // attribute value lives in data table
                setinfo.itagSequence = index;
                JetSetColumnEx(pDB->JetSessID,
                               pDB->JetObjTbl, pAC->jColid,
                               NULL, 0, 0, &setinfo);
            }

            index--;
        }

        // Get the next value to consider.
        index++;
        if (pAC->ulLinkID) {
            err = dbGetNthNextLinkVal(
                    pDB,
                    1,
                    &pAC,
                    DBGETATTVAL_fINTERNAL |  DBGETATTVAL_fREALLOC,
                    bufSize,
                    &pVal,
                    &len);
        }
        else {
            err = DBGetAttVal_AC(pDB, index, pAC,
                                 DBGETATTVAL_fINTERNAL |  DBGETATTVAL_fREALLOC,
                                 bufSize, &len,
                                 &pVal);
        }
    }

    err = 0;
    // firstNewAtt is the index number of the first new value to be added to
    // the attribute.  It is 1 greater than the number of attributes we left on
    // the object in the DIT.
    firstNewAtt = index;

    if(bufSize)
        THFreeEx(pTHS, pVal);

    // PHASE 3:
    // Finally, add the remaining att values
    if(IntAttrVal.valCount) {
        pAVal = IntAttrVal.pAVal;

        for(index = 0; index < IntAttrVal.valCount; index++){
            Assert(!FIsBacklink(pAC->ulLinkID));

            // figure out if we already did a DBSYN_ADD on this value
            fAddAlreadyDone = FALSE;
            for (i = 0; i < addAlreadyDoneCount; i++) {
                if (addAlreadyDoneFor[i] == pAVal->pVal) {
                    fAddAlreadyDone = TRUE;
                    break;
                }
            }

            // Now really add the value.
            if (pAC->ulLinkID) {
                // Don't add values that are INVALID
                if(*(DWORD *)(pAVal->pVal) != INVALIDDNT) {
                    if (!fAddAlreadyDone) {
                        // Fix up the recounts.
                        dbAdjustRefCountByAttVal(pDB, pAC, pAVal->pVal, pAVal->valLen, 1);
                    }
                    fChangedSomething = TRUE;
                    err = dbAddIntLinkVal(pDB, pAC, pAVal->valLen, pAVal->pVal, NULL);
                }
            }
            else {
                if (!fAddAlreadyDone) {
                    // Fix up the recounts.
                    dbAdjustRefCountByAttVal(pDB, pAC, pAVal->pVal, pAVal->valLen, 1);
                }
                fChangedSomething=TRUE;

                // NOTE: if you add a value with no length, JET doesn't
                // complain, but it also doesn't change the DB in anyway.  So,
                // if you are doing that, you are just forcing the meta data to
                // change.  Don't do that.  If you hit this assert, your code
                // needs to change.
                //
                switch(pAC->syntax) {
                case SYNTAX_NOCASE_STRING_TYPE:
                case SYNTAX_UNICODE_TYPE:
                    // Because non-binary equal values of these syntaxes can be
                    // semantically equal, these require the old slow way of
                    // comparing.
                    // First, try to use Jet for dup detection.
                    setinfo.itagSequence = index + firstNewAtt;
                    switch(JetSetColumnWarnings(
                            pDB->JetSessID,
                            pDB->JetObjTbl,
                            pAC->jColid,
                            pAVal->pVal,
                            pAVal->valLen,
                            JET_bitSetUniqueNormalizedMultiValues,
                            &setinfo)) {
                    case JET_errMultiValuedDuplicate:
                        // Duplicate value.
                        return DB_ERR_VALUE_EXISTS;
                        break;

                    case JET_errMultiValuedDuplicateAfterTruncation:
                        // Can't tell if this is unique or not.  Try the old
                        // fashioned way.
                        if(rtn = dbSetValueIfUniqueSlowVersion(pDB,
                                                               pAC,
                                                               pAVal->pVal,
                                                               pAVal->valLen)) {
                            return rtn;
                        }
                        break;

                    default:
                        // Successfully added, it's not a duplicate.
                        break;
                    }
                    break;

                default:
                    // Everything else can make use of jet to do the dup
                    // detection during the set column.
                    setinfo.itagSequence = index + firstNewAtt;
                    if(JET_errMultiValuedDuplicate ==
                       JetSetColumnWarnings(pDB->JetSessID,
                                            pDB->JetObjTbl,
                                            pAC->jColid,
                                            pAVal->pVal,
                                            pAVal->valLen,
                                            JET_bitSetUniqueMultiValues,
                                            &setinfo)) {
                        err = DB_ERR_VALUE_EXISTS;
                    }
                    else {
                        err = 0;
                    }
                }
            }

            if(err) {
                goto CleanUp;
            }
            pAVal++;
        }
    }

CleanUp:
    // Free up allocated memory
    if(IntAttrVal.pAVal) {
        if(fNewAllocs) {
            for(index = 0;index < IntAttrVal.valCount;index++) {
                THFreeEx(pTHS, IntAttrVal.pAVal[index].pVal);
            }
        }
        THFreeEx(pTHS, IntAttrVal.pAVal);
    }
    if (addAlreadyDoneFor) {
        THFreeEx(pTHS, addAlreadyDoneFor);
    }

    if(!err && (pTHS->fDRA || fChangedSomething)) {
        // If the DRA did this call, we ALWAYS touch the metadata.  For anyone
        // else, we only touch the metadata if something changes.
        DBTouchMetaData(pDB, pAC);
    }

    if (fChangedSomething) {
        if (dbNeedToFlushDNCacheOnUpdate(pAC->id)) {
            pDB->fFlushCacheOnUpdate = TRUE;
        }
    }

    if(pfChanged) {
        *pfChanged = fChangedSomething;
    }
    return err;

}/*ReplaceAtt*/


DWORD
DBRemAtt_AC (
        DBPOS FAR *pDB,
        ATTCACHE *pAC
        )
/*++

Routine Description:

    Remove an entire attribute from the current object.  Removes all the
    attribute values.

    Returns DB_ERR_ATTRIBUTE_DOESNT_EXIST or Db_success.
--*/
{
    THSTATE *   pTHS = pDB->pTHS;
    DWORD       err = 0;
    DWORD       ret_err = 0;
    DWORD       bufSize;
    PUCHAR      pVal;
    DWORD       len;
    BOOL        fDidOne = FALSE;
    JET_SETINFO setinfo;

    DPRINT1(2, "DBRemAtt_AC entered, Remove attribute type <%lu>\n",pAC->id);

    Assert(VALID_DBPOS(pDB));

    dbInitRec(pDB);

    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = 0;
    setinfo.itagSequence = 1;

    // Find and delete all values for this attribute

    pVal = NULL;
    len = 0;
    bufSize = 0;

    if (pAC->ulLinkID) {
        err = DBGetNextLinkVal_AC (
                pDB,
                TRUE,
                pAC,
                DBGETATTVAL_fINTERNAL |  DBGETATTVAL_fREALLOC,
                bufSize,
                &len,
                &pVal);
    }
    else {
        err = DBGetAttVal_AC(pDB, 1, pAC,
                             DBGETATTVAL_fINTERNAL |
                             DBGETATTVAL_fREALLOC  |
                             DBGETATTVAL_fDONT_FIX_MISSING_SD,
                             bufSize, &len,
                             &pVal);
    }

    if (err == DB_ERR_NO_VALUE) {
        ret_err = DB_ERR_ATTRIBUTE_DOESNT_EXIST;
    }

    while(!err) {
        bufSize = max(bufSize, len);

        fDidOne = TRUE;
        // OK, now really delete.
        if(pAC->ulLinkID) {
            dbSetLinkValueAbsent( pDB,
                                  DIRLOG_LVR_SET_META_REMOVE_ATT_MADE_ABSENT,
                                  pAC, pVal, NULL /*remote*/ );
        }
        else {
            // First, fix up the refcounts.
            dbAdjustRefCountByAttVal(pDB, pAC, pVal, len, -1);

            // attribute value lives in data table
            JetSetColumnEx(pDB->JetSessID,
                           pDB->JetObjTbl, pAC->jColid,
                           NULL, 0, 0, &setinfo);
        }


        // Get the next value to delete.
        if (pAC->ulLinkID) {
            err = dbGetNthNextLinkVal(
                    pDB,
                    1,
                    &pAC,
                    DBGETATTVAL_fINTERNAL | DBGETATTVAL_fREALLOC,
                    bufSize,
                    &pVal,
                    &len);
        }
        else {
            err = DBGetAttVal_AC(pDB, 1, pAC,
                                 DBGETATTVAL_fINTERNAL |
                                 DBGETATTVAL_fREALLOC  |
                                 DBGETATTVAL_fDONT_FIX_MISSING_SD,
                                 bufSize, &len,
                                 &pVal);
        }
    }

    if (NULL != pVal) {
        THFreeEx(pTHS, pVal);
    }

    if (fDidOne || pTHS->fDRA) {
        // Touch replication meta data for this attribute.
        // Never optimize this out for fDRA.
        DBTouchMetaData(pDB, pAC);
    }

    if (fDidOne) {
        if (dbNeedToFlushDNCacheOnUpdate(pAC->id)) {
            pDB->fFlushCacheOnUpdate = TRUE;
        }
    }

    return ret_err;

}//DBRemAtt_AC

DWORD
DBRemAtt (
        DBPOS FAR *pDB,
        ATTRTYP aType
        )
/*++

Routine Description:

    Remove an entire attribute from the current object.  Removes all the
    attribute values.

    Returns DB_ERR_ATTRIBUTE_DOESNT_EXIST or Db_success.
--*/
{
    ATTCACHE      *pAC;

    // Find the attcache of the attribute to be removed

    DPRINT1(5, "DBRemAtt entered, Remove attribute type <%lu>\n",aType);

    Assert(VALID_DBPOS(pDB));

    if (!(pAC = SCGetAttById(pDB->pTHS, aType))) {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, aType);
    }
    return DBRemAtt_AC(pDB,pAC);
}//DBRemAtt

DWORD
DBRemAttValEx_AC (
        DBPOS FAR *pDB,
        ATTCACHE *pAC,
        ULONG extLen,
        void *pExtVal,
        VALUE_META_DATA *pRemoteValueMetaData
        )
/*++

Routine Description:

    Remove an attribute value.
    A non-zero return indicates a bad return.
--*/
{
    THSTATE          *pTHS=pDB->pTHS;
    PUCHAR            pTemp, pVal;
    ULONG             actuallen, len, bufSize;
    DWORD             index;
    UCHAR            *pIntVal;
    int               err;
    DWORD             dwSyntaxFlags=0;
    JET_SETINFO       setinfo;


    DPRINT1(2, "DBRemAttVal_AC entered, Remove attribute type <%lu>\n",pAC->id);

    Assert(VALID_DBPOS(pDB));

    // We disallow being called with the pExtVal == to the temp buffer
    // used by conversion.
    Assert(pExtVal != pDB->pValBuf);

    // We disallow removing backlinks.
    Assert(!FIsBacklink(pAC->ulLinkID));

    // assume we are to remove existing values
    dbInitRec(pDB);

    // Convert to internal value
    if (DBIsSecretData(pAC->id)){
        dwSyntaxFlags |= EXTINT_SECRETDATA;
    }

    if ( (pDB->pTHS->fDRA) && (pAC->ulLinkID) ) {

        // Replicating in a linked value removal
        dwSyntaxFlags = EXTINT_REJECT_TOMBSTONES;
        err = gDBSyntax[pAC->syntax].ExtInt(
            pDB,
            DBSYN_INQ,
            extLen,
            pExtVal,
            &actuallen,
            &pIntVal,
            0, 0,
            dwSyntaxFlags);
        if (err == ERROR_DS_NO_DELETED_NAME) {
            // If the value is deleted, silently succeed without adding anything
            return 0;
        } else if (err) {

            // Try to create the dn as a phantom
            err = gDBSyntax[pAC->syntax].ExtInt(
                pDB,
                DBSYN_ADD,
                extLen,
                pExtVal,
                &actuallen,
                &pIntVal,
                pDB->DNT,
                pDB->JetObjTbl,
                dwSyntaxFlags);
            if (!err) {
                // We just added a new phantom, and ExtInt has kindly increased
                // the ref-count for us. However, the code in dbRemIntLinkVal expects
                // in the case that the value row does not exist (which this HAS to be),
                // that it will add the ref count. So we reverse the extra ref-count.
                dbAdjustRefCountByAttVal(pDB, pAC, pIntVal, actuallen, -1 );
            } else {
                DPRINT1(1, "Ext-Int syntax conv failed <%u>..return\n", err);
                return DB_ERR_SYNTAX_CONVERSION_FAILED;
            }
        }

    } else {

        // Originating write case, or replicating in a non-linked attribute
        err = gDBSyntax[pAC->syntax].ExtInt(pDB,
                                            DBSYN_INQ,
                                            extLen,
                                            pExtVal,
                                            &actuallen,
                                            &pIntVal,
                                            0, 0,
                                            dwSyntaxFlags);
        if (err == DIRERR_OBJ_NOT_FOUND && pAC->syntax == SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE) {
            // this is allowed! Must be an old-style SD that is not present in the SD table
            // assign external value to internal value -- we will use this in Eval comparisons below
            pIntVal = pExtVal;
            actuallen = extLen;
            err = 0;
        }
        else if (err) {
            DPRINT1(0, "Ext-Int syntax conv failed <%u>..return\n",err);
            return  DB_ERR_SYNTAX_CONVERSION_FAILED;
        }

    }

    // allocate memory and copy internal value for comparing later

    pTemp = dbAlloc(actuallen);
    memcpy(pTemp, pIntVal, actuallen);
    pIntVal = pTemp;

    if (pAC->ulLinkID) {
        err = dbRemIntLinkVal( pDB, pAC, actuallen, pIntVal, pRemoteValueMetaData );

        dbFree(pIntVal);

        return err;
    }

    // Now, walk through the existing vals, looking for a match.  Delete the
    // match if we find it.

    pVal = NULL;
    len = 0;
    bufSize = 0;

    for(index = 1; ; index++) {
        err = DBGetAttVal_AC(pDB, index, pAC,
                             DBGETATTVAL_fINTERNAL |  DBGETATTVAL_fREALLOC,
                             bufSize, &len,
                             &pVal);
        if (err) {
            break;
        }

        bufSize = max(bufSize, len);

        if(gDBSyntax[pAC->syntax].Eval(
            pDB,
            FI_CHOICE_EQUALITY,
            actuallen,
            pIntVal,
            len,
            pVal)) {
            // Matched.  Do the remove.

            // Touch replication meta data for this attribute.
            DBTouchMetaData(pDB, pAC);

            if (dbNeedToFlushDNCacheOnUpdate(pAC->id)) {
                pDB->fFlushCacheOnUpdate = TRUE;
            }

            // OK, now really delete.

            // First, fix up the refcounts.
            // It is important that we are using the value that has been read, not
            // the pIntVal. Even though Eval thinks they are "the same", they might
            // be still different. This is the case for old-style security descriptors
            // that are stored directly in the obj table. dbAdjustRefCountByAttVal
            // knows how to deal with those (ignores them).
            dbAdjustRefCountByAttVal(pDB, pAC, pVal, len, -1);

            // attribute value lives in data table
            setinfo.cbStruct = sizeof(setinfo);
            setinfo.ibLongValue = 0;
            setinfo.itagSequence = index;
            JetSetColumnEx(pDB->JetSessID,
                           pDB->JetObjTbl, pAC->jColid,
                           NULL, 0, 0, &setinfo);

            THFreeEx(pDB->pTHS, pVal);
            dbFree(pIntVal);
            return 0;
        }
    } // end for

    THFreeEx(pDB->pTHS, pVal);

    dbFree(pIntVal);

    // We didn't find it.
    return DB_ERR_VALUE_DOESNT_EXIST;
}

DWORD
DBRemAttVal_AC (
        DBPOS FAR *pDB,
        ATTCACHE *pAC,
        ULONG extLen,
        void *pExtVal
        )
/*++

Routine Description:

    Remove an attribute value.
    A non-zero return indicates a bad return.
--*/
{
    return DBRemAttValEx_AC( pDB, pAC, extLen, pExtVal, NULL );
}


DWORD
DBFindAttLinkVal_AC(
    IN  DBPOS FAR *pDB,
    IN  ATTCACHE *pAC,
    IN  ULONG extLen,
    IN  void *pExtVal,
    OUT BOOL *pfPresent
    )

/*++

Routine Description:

Position on a external form linked value in the link table.

This routine will return an error if the DN doesn't exist. This routine only
determines if a link is present. This routine does not add a phantom for
DN's. If a phantom is not present, this implies that the linked value does
not exist, and we return with that indication.

Arguments:

    pDB -
    pAC -
    extLen -
    pExtVal -
    pfPresent - Only valid on success

Return Value:

    DWORD -
    ERROR_SUCCESS - Linked value was found and we are positioned on it
    ERROR_NO_DELETED_NAME - DN is to a deleted object
    DB_ERR_VALUE_DOESNT_EXIST - DN does not exist, or link is not present

--*/

{
    THSTATE *pTHS=pDB->pTHS;
    PUCHAR pTemp;
    ULONG actuallen, len, bufSize;
    UCHAR *pIntVal;
    int err;
    DWORD dwSyntaxFlags;

    DPRINT1(2, "DBFindttVal_AC entered, Find attribute type <%lu>\n",pAC->id);

    // Only for linked attributes right now
    Assert( pAC->ulLinkID );

    Assert(VALID_DBPOS(pDB));

    // We disallow being called with the pExtVal == to the temp buffer
    // used by conversion.
    Assert(pExtVal != pDB->pValBuf);

    // We disallow removing backlinks.
    Assert(!FIsBacklink(pAC->ulLinkID));

    // Check that DN does not refer to deleted object
    dwSyntaxFlags = EXTINT_REJECT_TOMBSTONES;

    // Convert to internal value
    if(err = gDBSyntax[pAC->syntax].ExtInt(
            pDB,
            DBSYN_INQ,
            extLen,
            pExtVal,
            &actuallen,
            &pIntVal,
            0, 0,
            dwSyntaxFlags)) {
        if (err == ERROR_DS_NO_DELETED_NAME) {
            return err;
        } else {
            // DNT doesn't exist => link doesn't exist, we're done
            return DB_ERR_VALUE_DOESNT_EXIST;
        }
    }

    // allocate memory and copy internal value for comparing later

    pTemp = dbAlloc(actuallen);
    memcpy(pTemp, pIntVal, actuallen);
    pIntVal = pTemp;

    // Position on exact value
    if (!dbFindIntLinkVal(
        pDB,
        pAC,
        actuallen,
        pIntVal,
        pfPresent
        )) {
        // We didn't find it.
        err = DB_ERR_VALUE_DOESNT_EXIST;
    }

    dbFree(pIntVal);

    return err;

} /* DBFindAttLinkVal_AC */


DWORD
DBRemAttVal (
        DBPOS FAR *pDB,
        ATTRTYP aType,
        ULONG extLen,
        void *pExtVal
        )
/*++

Routine Description:

    Remove an attribute value.
    A non-zero return indicates a bad return.
--*/
{
    ATTCACHE         *pAC;

    DPRINT1(5, "DBRemAttVal entered, Remove attribute type <%lu>\n",aType);

    Assert(VALID_DBPOS(pDB));

    if (!(pAC = SCGetAttById(pDB->pTHS, aType))) {
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, aType);
    }

    return DBRemAttVal_AC(pDB, pAC, extLen, pExtVal);

} /* DBRemAttVal */

DWORD
dbGetMultipleColumns (
        DBPOS *pDB,
        JET_RETRIEVECOLUMN **ppOutputCols,
        ULONG *pcOutputCols,
        JET_RETRIEVECOLUMN *pInputCols,
        ULONG cInputCols,
        BOOL fGetValues,
        BOOL fFromDB
        )
/*++

Routine Description:

    Retrieve many columns at once. First figure out how many columns we have,
    then allocate sructures to represent each one and figure out the size of the
    value of each one, then call Jet again and get the values for each column

    if the client is reading objectClass, we might return also auxClass if existing
    the client should take care of copying the values to the correct place in objectClass

--*/
{
    THSTATE            *pTHS=pDB->pTHS;
    JET_RETRIEVECOLUMN retcolCount;
    JET_RETRIEVECOLUMN *pOutputCols, *pCol;
    ULONG               cb;
    ULONG               i, j;
    DWORD               grbit, err;

    Assert(VALID_DBPOS(pDB));

    if(fFromDB) {
        // The caller wants to read from the DB, not the copy buffer, regardless
        // of the state of pDB->JetRetrieveBits.
        grbit = 0;
    }
    else {
        grbit = pDB->JetRetrieveBits;
    }

    // query Jet for the count of columns in this record

    // was a list of columns specified?

    if (cInputCols && pInputCols)
    {
        // yes - make sure itagSequence is set to 0
        for (i=0; i < cInputCols; i++) {
            pInputCols[i].itagSequence = 0;
            pInputCols[i].grbit = grbit;
        }
    }
    else
    {
        pInputCols = &retcolCount;
        cInputCols = 1;
        memset(&retcolCount, 0, sizeof(retcolCount));
        retcolCount.grbit = grbit;
    }

    JetRetrieveColumnsWarnings(pDB->JetSessID,
        pDB->JetObjTbl,
        pInputCols,
        cInputCols);

    // set the count of columns
    *pcOutputCols = 0;
    *ppOutputCols = NULL;

    for (i=0; i< cInputCols; i++)
        *pcOutputCols += pInputCols[i].itagSequence;

    if ((*pcOutputCols) == 0)
        return 0;

    // allocate and initialize the structures for calling JetRetrieveColumns to
    // find out the value sizes for all the columns

    cb = (*pcOutputCols) * sizeof(JET_RETRIEVECOLUMN);
    pOutputCols = (JET_RETRIEVECOLUMN *) THAllocEx(pTHS, cb);
    *ppOutputCols = pOutputCols;
    memset(pOutputCols, 0, cb);

    // set up all the new JET_RETRIEVECOLUMNS to have a column ID and
    // itagSequence.
    // The itagSequence is relative to columnid, and represents the value number
    // of this columnid in the record, starting at 1

    pCol = pOutputCols;
    for (j=0; j < cInputCols; j++)
    {
        for (i=0; i<pInputCols[j].itagSequence; i++)
        {
            pCol->columnid = pInputCols[j].columnid;
            pCol->itagSequence = i + 1;
            // Use the same grbit in the output columns as we used in the input
            // columns.
            pCol->grbit = pInputCols[j].grbit;
            pCol++;
        }
    }

    // call jet retrieve columns to find out the necessary buffer size for all
    // values

    JetRetrieveColumnsWarnings(pDB->JetSessID,
        pDB->JetObjTbl,
        pOutputCols,
        *pcOutputCols);

    // Look for internal columns and trim them out.  They are tagged, but is
    // treated different from all the other tagged columns, and should NEVER be
    // returned from this routine.
    // TODO: If we get many more of these, a more extensible mechanism of removing
    // them should be designed.

    // Remove the ancestorsid column
    if(*pcOutputCols) {
        if(pOutputCols[*pcOutputCols - 1].columnidNextTagged ==
           ancestorsid) {
            // It's last, just adjust the count.
            *pcOutputCols = *pcOutputCols - 1;
        }
        else {
            for(i=0; i< (*pcOutputCols - 1); i++) {
                if (pOutputCols[i].columnidNextTagged == ancestorsid) {
                    memmove(&pOutputCols[i],
                            &pOutputCols[i+1],
                            (*pcOutputCols - i - 1)*sizeof(JET_RETRIEVECOLUMN));
                    *pcOutputCols = *pcOutputCols - 1;
                    break;
                }
            }
        }
    }


    // Remove the cleanid column
    if(*pcOutputCols) {
        if(pOutputCols[*pcOutputCols - 1].columnidNextTagged ==
           cleanid) {
            // It's last, just adjust the count.
            *pcOutputCols = *pcOutputCols - 1;
        }
        else {
            for(i=0; i< (*pcOutputCols - 1); i++) {
                if (pOutputCols[i].columnidNextTagged == cleanid) {
                    memmove(&pOutputCols[i],
                            &pOutputCols[i+1],
                            (*pcOutputCols - i - 1)*sizeof(JET_RETRIEVECOLUMN));
                    *pcOutputCols = *pcOutputCols - 1;
                    break;
                }
            }
        }
    }

    // if we don't need to return the values we can return

    if (!fGetValues)
        return 0;

    // set up the structure to query for the values of all columns

    for (i = 0; i < *pcOutputCols; i ++)
    {
        pOutputCols[i].pvData = THAllocEx(pTHS, pOutputCols[i].cbActual);
        pOutputCols[i].cbData = pOutputCols[i].cbActual;
    }

    // call Jet to return the values

    JetRetrieveColumnsSuccess(pDB->JetSessID,
        pDB->JetObjTbl,
        pOutputCols,
        *pcOutputCols);

    // success

    return 0;
}

// Lock a DN we are trying to add to avoid multiple entries with the same DN
// We only need to do this while adding until the transaction is committed. We
// do this by maintaining a global list of objects being added and a local list,
// maintained on the DBPOS. At commit (or rollback) time, we remove the objects
// on the DBPOS list from the global list
// We also need to lock whole sections of tree when we are moving an object from
// one part of the tree to another via a rename.  We don't wan't anyone creating
// new objects or moving objects to be under an object we are moving.
//
// Flags for DBLockDN.
// DB_LOCK_DN_WHOLE_TREE: This flag means to lock the whole tree under the given
//   DN.
// DB_LOCK_DN_STICKY: Normal behaviour for locked DNs is that they are released
//   automatically when the DBPOS they were locked on is DBClosed.  This flags
//   means that the DN should remain locked on the global locked DN list until
//   explicitly freed via  DBUnlockStickyDN()

DWORD
DBLockDN (
        DBPOS  *pDB,
        DWORD   dwFlags,
        DSNAME *pDN
        )
{
    THSTATE *pTHS=pDB->pTHS;
    DWORD  dwLockConflictFlags = 0;
    DNList *pGlobalListElement;
    DNList *pLocalListElement;
    ULONG  cb;
    BOOL   bWholeTree = dwFlags & DB_LOCK_DN_WHOLE_TREE;
    DWORD  dwTid = GetCurrentThreadId();

    Assert(VALID_DBPOS(pDB));

    // don't lock the DN when in singleuser mode
    if (pTHS->fSingleUserModeThread) {
        return 0;
    }

    // Can't lock a DN w/o a StringName.  But allow lock of the root
    // which is identified by no GUID, SID or StringName.

    Assert(IsRoot(pDN) || (pDN->NameLen != 0));


    EnterCriticalSection(&csAddList);
#if DBG
    pGlobalListElement = pAddListHead;
    while(pGlobalListElement) {
        Assert(IsValidReadPointer(pGlobalListElement,sizeof(DNList)));
        pGlobalListElement = pGlobalListElement->pNext;
    }
    pLocalListElement = pDB->pDNsAdded;
    while(pLocalListElement) {
        Assert(IsValidReadPointer(pLocalListElement,sizeof(DNList)));
        pLocalListElement = pLocalListElement->pNext;
    }
#endif
    __try
    {
        // look to see if DN is already on global list
        for (pGlobalListElement = pAddListHead;
             (!dwLockConflictFlags && pGlobalListElement);
             pGlobalListElement = pGlobalListElement->pNext) {

            // If we're the replicator or the phantom daemon and we're the one
            // who put this entry in the global list, ignore it.  This
            // essentially allows replication and the phantom daemon to relock
            // DNs it locked in the first place. This is necessary for the
            // phantom daemon because it adds an entry and deletes it inside the
            // same transaction.
            if ((pTHS->fDRA || pTHS->fPhantomDaemon) &&
                (dwTid == pGlobalListElement->dwTid)    ) {
                continue;
            }

            // First, do we directly conflict?
            if (NameMatched(pDN, (PDSNAME) pGlobalListElement->rgb)) {
                // We found the object already locked on the list.
                dwLockConflictFlags |= DB_LOCK_DN_CONFLICT_NODE;
            }

            // And, do we conflict with a tree lock?
            if((pGlobalListElement->dwFlags & DB_LOCK_DN_WHOLE_TREE) &&
               NamePrefix((PDSNAME) pGlobalListElement->rgb, pDN)) {
                // We found that the object is in a locked portion of the tree
                dwLockConflictFlags |= DB_LOCK_DN_CONFLICT_TREE_ABOVE;
            }

            // Finally, does this tree lock conflict with some lock below us?
            if (bWholeTree &&
                NamePrefix(pDN,(PDSNAME) pGlobalListElement->rgb)) {
                // We are trying to lock the whole subtree and found an object
                // that is in that subtree and is already locked
                dwLockConflictFlags |= DB_LOCK_DN_CONFLICT_TREE_BELOW;
            }

            if(dwLockConflictFlags) {
                // We conflict with the current node.  See if it is a sticky
                // node
                if(pGlobalListElement->dwFlags & DB_LOCK_DN_STICKY) {
                    dwLockConflictFlags |= DB_LOCK_DN_CONFLICT_STICKY;
                }
            }
        }


        if (!dwLockConflictFlags) {
            cb = sizeof(DNList) + pDN->structLen;

            // allocate elements for global added list and DBPos added list
            // pGlobalListElement goes on global list so allocate global memory
            pGlobalListElement = malloc(cb);
            if (!pGlobalListElement)
                dwLockConflictFlags = DB_LOCK_DN_CONFLICT_UNKNOWN;
            else {
                // pLocalListElement goes on DBPOS, allocate transaction memory
                pLocalListElement = dbAlloc(cb);
                if (!pLocalListElement) {
                    free(pGlobalListElement);
                    dwLockConflictFlags = DB_LOCK_DN_CONFLICT_UNKNOWN;
                }
            }
        }

        if (!dwLockConflictFlags) {
            // Insert new elements at head of Global list and DBPos list. By
            // inserting at the head we insure that the order of elemnts is the
            // same in both lists allowing for a one pass removal

            // first the global list
            pGlobalListElement->pNext = pAddListHead;
            memcpy(pGlobalListElement->rgb, pDN, pDN->structLen);
            pGlobalListElement->dwFlags = dwFlags;
            pGlobalListElement->dwTid = dwTid;
            pAddListHead = pGlobalListElement;

            // now the DBPos list
            pLocalListElement->pNext = pDB->pDNsAdded;
            memcpy(pLocalListElement->rgb, pDN, pDN->structLen);
            pLocalListElement->dwFlags = dwFlags;
            pLocalListElement->dwTid = dwTid;
            pDB->pDNsAdded = pLocalListElement;
        }
    }
    __finally {
        LeaveCriticalSection(&csAddList);
    }

    return dwLockConflictFlags;
}


// Remove all the DNs on the added list (maintained  on the DBPOS) from the
// global list of objects.  Don't remove them from the global list if they were
// marked as STICKY. Because we make sure the lists have the
// same relative order, we can do this in one pass.  DNs should be locked by
// LocalAdd, LocalModifyDN, and LocalRemove, and PrivateLocalRemoveTree.  This
// routine should be called immediately following transaction conclusion
void
dbUnlockDNs (
        DBPOS *pDB
        )
{
    THSTATE *pTHS=pDB->pTHS;
    BOOL fFound;
    DNList **ppGlobalListElement, *pLocalListElement, *pDeadElement;
    DNList *pDbgGlobalListElement;

    Assert(VALID_DBPOS(pDB));

    EnterCriticalSection(&csAddList);
#if DBG
    pDbgGlobalListElement = pAddListHead;
    while(pDbgGlobalListElement) {
        Assert(IsValidReadPointer(pDbgGlobalListElement,sizeof(DNList)));
        pDbgGlobalListElement = pDbgGlobalListElement->pNext;
    }
    pLocalListElement = pDB->pDNsAdded;
    while(pLocalListElement) {
        Assert(IsValidReadPointer(pLocalListElement,sizeof(DNList)));
        pLocalListElement = pLocalListElement->pNext;
    }
#endif
    __try {
        ppGlobalListElement = &pAddListHead;
        pLocalListElement = pDB->pDNsAdded;
        pDB->pDNsAdded = NULL;

        while (pLocalListElement) {
            fFound = FALSE;
            while (!fFound && *ppGlobalListElement) {
                if (NameMatched((PDSNAME) (pLocalListElement->rgb),
                                (PDSNAME) ((*ppGlobalListElement)->rgb))) {

                    // found the local DN on the global list; remove it and
                    // patch the list

                    fFound = TRUE;
                    if((*ppGlobalListElement)->dwFlags & DB_LOCK_DN_STICKY) {
                        // This was put into the global in a sticky manner, so
                        // by definition, we don't remove it here.
                        ppGlobalListElement = &(*ppGlobalListElement)->pNext;
                    }
                    else {
                        // OK, normal object.  Remove it.
                        pDeadElement = *ppGlobalListElement;
                        *ppGlobalListElement = (*ppGlobalListElement)->pNext;
                        free(pDeadElement);
                    }
                }
                else {
                    ppGlobalListElement = &(*ppGlobalListElement)->pNext;
                }
            }

            Assert(fFound);

            pDeadElement = pLocalListElement;
            pLocalListElement = pLocalListElement->pNext;
            dbFree(pDeadElement);
        }
    }
    __finally {
        LeaveCriticalSection(&csAddList);
    }
    return;
}
DWORD
DBUnlockStickyDN (
        PDSNAME pObj
        )
/*++
 Remove a specific DN from the global LOCK list, but only if it was stuck
 there with the STICK bit set.
--*/
{
    BOOL fFound;
    DNList **ppGlobalListElement, *pLocalListElement, *pDeadElement;


    EnterCriticalSection(&csAddList);
    __try {
        ppGlobalListElement = &pAddListHead;

        fFound = FALSE;
        while (!fFound && *ppGlobalListElement) {
            if(NameMatched((PDSNAME) ((*ppGlobalListElement)->rgb), pObj)) {
                // found the requested  DN on the global list; remove it and
                // patch the list

                fFound = TRUE;
                if( !((*ppGlobalListElement)->dwFlags & DB_LOCK_DN_STICKY) ) {
                    // This wasn't put into the global in a sticky manner, so
                    // by definition, we don't remove it here.
                    fFound = FALSE;
                    __leave;
                }
                else {
                    // OK, normal sticky object.  Remove it.
                    pDeadElement = *ppGlobalListElement;
                    *ppGlobalListElement = (*ppGlobalListElement)->pNext;
                    free(pDeadElement);
                }
            }
            else {
                ppGlobalListElement = &(*ppGlobalListElement)->pNext;
            }
        }

    }
    __finally {
        LeaveCriticalSection(&csAddList);
    }

    if(fFound) {
        // Deleted the object;
        return 0;
    }
    else {
        return DB_ERR_UNKNOWN_ERROR;
    }
}

VOID
dbRegisterLimitReached (
        THSTATE *pTHS,
        RANGEINF *pRangeInf,
        ATTRTYP AttId,
        DWORD lower,
        DWORD upper
        )
/*++
    Keep track of the fact that a limit was reached for the specific attribute
    specified.  Called from DBGetMultipleAtts.

    pRangeInf - the data structure we fill in to show what attributes were range
                limited.
    AttId - the attribute for which a limited range was returned.
    lower - the beginning of the range of values we are returning for the att.
    upper - the end of the range.  0xFFFFFFFF is used to show that we returned
            all the values through the end.

--*/
{
    if(!pRangeInf->count) {
        pRangeInf->pRanges =
            THAllocEx(pTHS, sizeof(RANGEINFOITEM));
    }
    else {
        pRangeInf->pRanges = THReAllocEx(pTHS,
                pRangeInf->pRanges,
                ((pRangeInf->count + 1)*sizeof(RANGEINFOITEM)));
    }


    pRangeInf->pRanges[pRangeInf->count].AttId = AttId;
    pRangeInf->pRanges[pRangeInf->count].lower = lower;
    pRangeInf->pRanges[pRangeInf->count].upper = upper;

    pRangeInf->count++;
}
VOID
DBGetValueLimits (
        ATTCACHE *pAC,
        RANGEINFSEL *pRangeSel,
        DWORD *pStartIndex,
        DWORD *pNumValues,
        BOOL  *pDefault
        )
/*++

  Find the range limits for the values of the selected attribute.  Default
  limits are 0 - 0xFFFFFFFF.

  pAC - the attribute in question
  pRangeSel - a list of pairs of explictly stated ranges and attributes.  May be
              NULL, in which case always use the default range.  Also,
              pRangeSel->valueLimit is an overriding value limit to use (i.e. to
              request that no more than N values are returned for ALL
              attributes.)
  pStartIndex - where to put the index of the first value to return.  Zero
              indexed.
  pNumValues - where to put the number of values to return. 0xFFFFFFFF means to
               return all remaining values.
  pDefault   - Boolean, set to TRUE if an explicitly stated range for this
               attribute was found, FALSE otherwise.


  So, after returning from this routine, the caller knows that it
  should return vaues *pStartIndex through (*pStartIndex) + (*pNumValues).

  Called by DBGetMultipleAtts.

--*/
{
    DWORD i;

    // Assume no limits.
    *pStartIndex = 0;
    *pNumValues = 0xFFFFFFFF;
    *pDefault = TRUE;

    if(!pRangeSel) {
        // Yup, no limits.
        return;
    }

    // OK, assume only general limit, not specific match.
    *pNumValues = pRangeSel->valueLimit;

    // Look through the rangesel for a specific match
    for(i=0;i<pRangeSel->count;i++) {
        if(pAC->id == pRangeSel->pRanges[i].AttId) {
            *pDefault = FALSE;
            if(pRangeSel->pRanges[i].upper == 0xFFFFFFFF) {
                *pStartIndex = pRangeSel->pRanges[i].lower;
                return;
            }
            else if(pRangeSel->pRanges[i].lower <=pRangeSel->pRanges[i].upper) {
                DWORD tempNumVals;
                *pStartIndex = pRangeSel->pRanges[i].lower;
                tempNumVals = (pRangeSel->pRanges[i].upper -
                               pRangeSel->pRanges[i].lower   )+ 1;

                if(*pNumValues != 0xFFFFFFFF) {
                    *pNumValues = min(*pNumValues, tempNumVals);
                }
                else {
                    *pNumValues = tempNumVals;
                }
            }
            else {
                *pNumValues = 0;
            }
            return;
        }
    }
}
DWORD
dbGetMultipleAttsLinkHelp (
        DBPOS        *pDB,
        BOOL          fExternal,
        DWORD         SyntaxFlags,
        ATTCACHE     *pAC,
        RANGEINFSEL  *pRangeSel,
        RANGEINF     *pRangeInf,
        ATTRVALBLOCK *pAVBlock,
        DWORD        *pSearchState,
        DWORD        *pCurrentLinkBase
        )
/*++
  Description:
    Help routine called by dbGetMultipleAtts to read the values of a link
    attribute. Reads the values in O(N) instead of the old algorithm which was
    O(N*N).

    NOTE: assumes that currency in the link table is on the 0th value for the
    attribute specified in pAC.

--*/
{
    THSTATE  *pTHS=pDB->pTHS;
    ATTRVAL  *pAVal=NULL;
    DWORD     currLinkVal = 0;
    DWORD     linkVals = 20;
    PUCHAR    pVal=NULL;
    DWORD     cbVal=0;
    DWORD     cbAlloc=0;
    DWORD     initialValIndex;
    DWORD     valueLimit;
    BOOL      defaultLimit;
    DWORD     err;
    DWORD     ulLen;
    UCHAR    *pucTmp;

    // Since we don't know how many values there are until we read
    // them, guess and then realloc if we need to.

    DBGetValueLimits(pAC, pRangeSel, &initialValIndex,
                     &valueLimit, &defaultLimit);



    // Get the first value we care about.  Assumes we are on the 0th value
    // already, but doesn't check that assumption (except in the debug case).
    // We get back a failure if moving forward initialValueIndex rows in the
    // Link Table doesn't land us on a value of the attribute pAC.
    // As of 12/10/97, we only call dbGetMultipleAttsHelp from two places in
    // DBGetMultipleAtts, and both have already set us to the correct location
    // in the link table. If we ever start calling this routine from
    // places where we are not already on the 0th value, change this to
    // dbGetLinkVal to get the first value of the attribute.  dbGetLinkVal does
    // a JetSeek, guaranteeing  that we are on the first value.  By not using
    // dbGetLinkVal, we are avoiding the extra seek.
#if DBG
    {
        DWORD        ulObjectDnt, ulRecLinkBase;
        ULONG        ulLinkBase = MakeLinkBase(pAC->ulLinkID);
        DWORD        err;

        // Verify that we are on the first value for the attribute in question.
        dbGetLinkTableData (pDB,
                            FIsBacklink(pAC->ulLinkID),
                            FALSE,
                            &ulObjectDnt,
                            NULL,
                            &ulRecLinkBase);

        Assert((ulObjectDnt == pDB->DNT) && (ulLinkBase == ulRecLinkBase));

        // Now, back up one
        err = JetMoveEx(pDB->JetSessID, pDB->JetLinkTbl, -1, 0);
        switch(err) {
        case JET_errSuccess:
            // Successfully backed up.

            dbGetLinkTableData (pDB,
                                FIsBacklink(pAC->ulLinkID),
                                FALSE,
                                &ulObjectDnt,
                                NULL,
                                &ulRecLinkBase);

            // We better not be on a qualifying record.
            Assert((ulObjectDnt != pDB->DNT) || (ulLinkBase != ulRecLinkBase));

            // OK, go bak to where you once belonged.
            JetMoveEx(pDB->JetSessID, pDB->JetLinkTbl, 1, 0);
            break;

        case JET_errNoCurrentRecord:
            // We didn't manage to back up, so we must be on the very first
            // object in the tree. Actually, we did manage to back up in a
            // sense.  We are on a non-entry before the beginning of the table.
            // Move forward.
            JetMoveEx(pDB->JetSessID, pDB->JetLinkTbl, 1, 0);
            break;

        default:
            Assert(!"Verification of position in dbGetMultipleAttsHelp failed");
            break;
        }
    }

#endif

    // it might fail if there is no value for the Nth attribute
    if (err = dbGetNthNextLinkVal(pDB,
                                  initialValIndex,
                                  &pAC,
                                  0,
                                  0,
                                  &pVal,
                                  &cbVal)) {
        return err;
    }

    pAVal = THAllocEx(pTHS, linkVals * sizeof(ATTRVAL));
    do {
        cbAlloc = max(cbAlloc,cbVal);
        if(currLinkVal == linkVals) {
            // We need to allocate some more room
            linkVals *=2;
            pAVal = THReAllocEx(pTHS, pAVal,
                                linkVals * sizeof(ATTRVAL));
        }
        // Save the value.
        if(fExternal) {
            // They want external values.
            if(err = gDBSyntax[pAC->syntax].IntExt(
                    pDB,
                    DBSYN_INQ,
                    cbVal,
                    pVal,
                    &ulLen,
                    &pucTmp,
                    0,
                    0,
                    SyntaxFlags)) {
                return err;
            }

            pAVal[currLinkVal].valLen = ulLen;
            pAVal[currLinkVal].pVal = THAllocEx(pTHS, ulLen);
            memcpy(pAVal[currLinkVal].pVal,
                   pucTmp,
                   ulLen);
        }
        else {
            // internal format
            pAVal[currLinkVal].valLen = cbVal;
            pAVal[currLinkVal].pVal = pVal;
            // We're handing away our buffer, so we must mark our local
            // pointer to make sure we don't re-use it.
            pVal = NULL;
            cbAlloc = cbVal = 0;
        }
        currLinkVal++;
    } while (valueLimit > currLinkVal &&
             !(err = dbGetNthNextLinkVal(pDB,
                                         1,
                                         &pAC,
                                         (cbAlloc ? DBGETATTVAL_fREALLOC : 0),
                                         cbAlloc,
                                         &pVal,
                                         &cbVal)));


    if(!err) {
        // We stopped before we verified that we got the last value.  See if
        // we got the last value.
        if(!(err = dbGetNthNextLinkVal(pDB,
                                       1,
                                       &pAC,
                                       0,
                                       0,
                                       &pVal,
                                       &cbVal))) {
            // Yep, there are more values.  Set up the range
            // info accordingly
            dbRegisterLimitReached(pTHS,
                                   pRangeInf,
                                   pAC->id,
                                   initialValIndex,
                                   initialValIndex + currLinkVal - 1);
            THFreeEx(pTHS, pVal);
            // And, note that since we aren't on the first value of some
            // attribute, we don't really know where we are.
            *pSearchState = ATTRSEARCHSTATEUNDEFINED;
        }
    }

    if(err) {
        DWORD ActualDNT;

        // Some call to dbGetNthNextLinkVal returned an error, so there are
        // no more values, we got them all.
        if(!defaultLimit) {
            // OK, we returned through the end, but this wasn't
            // a default limit, so we need to register anyway
            dbRegisterLimitReached(pTHS,
                                   pRangeInf,
                                   pAC->id,
                                   initialValIndex,
                                   0xFFFFFFFF);
        }

        // Now, find out what linkbase we are on.
        dbGetLinkTableData(pDB,
                           (FIsBacklink(pAC->ulLinkID)),
                           TRUE,
                           &ActualDNT,
                           NULL,
                           pCurrentLinkBase);

        if(ActualDNT != pDB->DNT) {
            // Positioned on the first value of something, but it wasn't the
            // correct DNT.
            *pCurrentLinkBase = 0xFFFFFFFF;
        }
    }


    pAVal = THReAllocEx(pTHS, pAVal, currLinkVal * sizeof(ATTRVAL));
    pAVBlock->pAVal = pAVal;
    pAVBlock->valCount = currLinkVal;

    return 0;
}
DWORD
dbPositionOnLinkVal (
        IN  DBPOS *pDB,
        IN  ATTCACHE *pAC,
        OUT DWORD *pActualDNT,
        OUT DWORD *pCurrentLinkBase,
        OUT DWORD *pSearchState
        )
/*++
  Description:
    Attempt to position on the first value of the link or back link attribute
    passed in.  Do this by seeking for the first thing with the correct DNT and
    a link base greater than or equal to the link base of the attribute.

  Parameters:
    pDB - DBPOS to use
    pAC - attcache of the attribute to look up.  Should be a link or backlink
        attribute.
    pActualDNT - the actual DNT of the entry we ended up on in the link table
        after we do the seek.
    pCurrentLinkBase - the actual link base of the entry we ended up on in the
        link table after we do the seek.
    pSearchState - The "search state" we're in.  Essentially, what index in the
        link table are we using, the link index or the backlink index.

  Return Values:
    0 -  if we successfully positioned on the first value of the requested
        attribute.
    DB_ERR_NO_VALUE - didn't successfully positioned on the first value of the
        requested attribute.

    Regardless of whether we return 0 or DB_ERR_NO_VALUE, the OUT params are
    filled in with the data from the actual object we found.  Because of the
    seek, We are guaranteed to be on the first value of the attribute described
    by the OUT parameters.  Thus, callers can be aware of the state of currency
    in the link table, and optimize access accordingly.

    One exception is the case where therer are NO entries in the link table
    whose DNT is Greater than or Equal to the DNT of the current object and
    whose linkBase is Greater than or Equal to the linkbase requested.  In this
    case, we set the returned actualDNT to INVALIDDNT and the linkbase to
    0xFFFFFFFF.

    Examples of optimizations:
    1) if the search was for LinkBase 5, and the return says we are on LinkBase
    90, then we know for a fact that there are no values for any attribute whose
    linkbase is between 5 (inclusive) and 90 (exclusive), and that the attribute
    with linkbase 90 has at least 1 value, and we are positioned on the very
    first value.

    2) if the search was for LinkBase 5 for the objects whose DNT is 900, and
    the return says we are on linkbase X and DNT 901, then we know for a fact
    that there are no values for any attribute whose linkbase is greater than or
    equal to 5 for the objects whose DNT is 900.

--*/
{
    ULONG       ulLinkBase = MakeLinkBase(pAC->ulLinkID);
    JET_ERR     err;
    LPSTR       pszIndexName;

    Assert(VALID_DBPOS(pDB));

    *pSearchState = ATTRSEARCHSTATEUNDEFINED;
    if (FIsBacklink(pAC->ulLinkID)) {
        // backlink
        JetSetCurrentIndexSuccess(pDB->JetSessID,
                                  pDB->JetLinkTbl,
                                  SZBACKLINKINDEX);
        *pSearchState = ATTRSEARCHSTATEBACKLINKS;
    }
    else {
        //link
        // When not in LVR mode, values with metadata are invisible
        pszIndexName = pDB->fScopeLegacyLinks ? SZLINKLEGACYINDEX : SZLINKINDEX;
        JetSetCurrentIndexSuccess(pDB->JetSessID,
                                  pDB->JetLinkTbl,
                                  pszIndexName );
        *pSearchState = ATTRSEARCHSTATELINKS;
    }


    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetLinkTbl,
                 &(pDB->DNT),
                 sizeof(pDB->DNT),
                 JET_bitNewKey);

    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetLinkTbl,
                 &ulLinkBase,
                 sizeof(ulLinkBase),
                 0);

    // seek
    err = JetSeekEx(pDB->JetSessID, pDB->JetLinkTbl, JET_bitSeekGE);

    if((err) && (err != JET_wrnRecordFoundGreater)) {
        *pActualDNT = INVALIDDNT;
        *pCurrentLinkBase = 0xFFFFFFFF;
        return DB_ERR_NO_VALUE;
    }

    // We're on something.  What is it?
    // test to verify that we found a qualifying record
    dbGetLinkTableData (pDB,
                        (FIsBacklink(pAC->ulLinkID)),
                        FALSE,
                        pActualDNT,
                        NULL,
                        pCurrentLinkBase);

    if((*pActualDNT != pDB->DNT) ||
       (*pCurrentLinkBase != ulLinkBase)) {
        // Positioned on the first value of something, but it wasn't the
        // correct DNT.
        return DB_ERR_NO_VALUE;
    }

    // OK, positioned on the first value of the requested attribute.
    return 0;
}


VOID
DBFreeMultipleAtts(
        IN DBPOS *pDB,
        IN OUT ULONG *attrCount,
        IN OUT ATTR **ppAttr
        )
/*++

Routine Description:

    Free the ATTR array returned by DBGetMultipleAtts

Arguments:

    pTHS - thread state

    attrCount - addr of number of attributes returned by DBGetMultipleAtts

    ppAttr - array returned by DBGetMultipleAtts

Return Value:

    None. *pnAtts is set to 0. *ppAttr is set to NULL.

--*/
{
    THSTATE *pTHS = pDB->pTHS;
    DWORD   nAtt, nVal;
    ATTR    *pAttr;
    ATTRVAL *pAVal;

    if (*attrCount && *ppAttr) {
        pAttr = *ppAttr;
        for (nAtt = 0; nAtt < *attrCount; ++nAtt, ++pAttr) {
            if (pAttr->AttrVal.valCount && pAttr->AttrVal.pAVal) {
                pAVal = pAttr->AttrVal.pAVal;
                for (nVal = 0; nVal < pAttr->AttrVal.valCount; ++nVal, ++pAVal) {
                    if (pAVal->valLen && pAVal->pVal) {
                        THFreeEx(pTHS, pAVal->pVal);
                    }
                }
                THFreeEx(pTHS, pAttr->AttrVal.pAVal);
            }
        }
        THFreeEx(pTHS, *ppAttr);
    }

    *ppAttr = NULL;
    *attrCount = 0;
}


void* JET_API dbGetMultipleAttsRealloc(
    THSTATE*    pTHS,
    void*       pv,
    ULONG       cb
    )
{
    void* pvRet = NULL;
    
    if (!pv) {
        pvRet = THAllocNoEx(pTHS, cb);
    } else if (!cb) {
        THFreeNoEx(pTHS, pv);
    } else {
        pvRet = THReAllocNoEx(pTHS, pv, cb);
    }

    return pvRet;
}

void dbGetMultipleAttsFreeData(
    THSTATE*            pTHS,
    ULONG               cEnumColumn,
    JET_ENUMCOLUMN*     rgEnumColumn
    )
{
    size_t                  iEnumColumn         = 0;
    JET_ENUMCOLUMN*         pEnumColumn         = NULL;
    size_t                  iEnumColumnValue    = 0;
    JET_ENUMCOLUMNVALUE*    pEnumColumnValue    = NULL;

    if (rgEnumColumn) {
        for (iEnumColumn = 0; iEnumColumn < cEnumColumn; iEnumColumn++) {
            pEnumColumn = rgEnumColumn + iEnumColumn;

            if (pEnumColumn->err != JET_wrnColumnSingleValue) {
                if (pEnumColumn->rgEnumColumnValue) {
                    for (   iEnumColumnValue = 0;
                            iEnumColumnValue < pEnumColumn->cEnumColumnValue;
                            iEnumColumnValue++) {
                        pEnumColumnValue = pEnumColumn->rgEnumColumnValue + iEnumColumnValue;

                        if (pEnumColumnValue->pvData) {
                            THFreeEx(pTHS, pEnumColumnValue->pvData);
                        }
                    }

                    THFreeEx(pTHS, pEnumColumn->rgEnumColumnValue);
                }
            } else {
                if (pEnumColumn->pvData) {
                    THFreeEx(pTHS, pEnumColumn->pvData);
                }
            }
        }

        THFreeEx(pTHS, rgEnumColumn);
    }
}
    

DWORD
DBGetMultipleAtts(
        DBPOS *pDB,
        ULONG cReqAtts,
        ATTCACHE *pReqAtts[],
        RANGEINFSEL *pRangeSel,
        RANGEINF *pRangeInf,
        ULONG *attrCount,
        ATTR **ppAttr,
        DWORD Flags,
        DWORD SecurityDescriptorFlags
        )
/*++

Routine Description:

    Get multiple attributes in internal or external format. If cReqAtts is 0,
    all attributes are returned. Otherwise, the attributes in pReqAtts present
    on the object are returned, in the same order. Attributes are returned in an
    array of ATTRs with a count.  We use dbGetMultipleColumns to return columns
    from the data table and dbGetNextAtt to retrieve attributes from
    the link table. Flags specify what values to return and how to return them

    The memory returned by this routine is allocated using THAlloc. Free with
    DBFreeMutlipleAtts.

Arguments:

    pDB - the DBPos to use.

    cReqAtts - the number of requested attributes, 0 if requesting all
    attributes.

    pReqAtts - array of attcache pointers specifying which attributes to read.
    Null if asking for all attributes.  Null pointers may be elements of the
    array; if so this routine simply skips that element of the array.

    attrCount - the number of attributes actually read.

    ppAttr - place to put an array of ATTRS, allocated here, filled with the
    attributes read.

    Flags - fEXTERNAL means return values and translate them to external
        format.  fGETVALS means return values and leave them in internal
        format. fREPLICATION means to trim out values that don't flow over
        replication links.  If no flags are specified, return the list of all
        attributes which exist on the object, but don't return any values.

Return Value:

    0 if all went well, non-zero otherwise. Free ppAttr w/DBFreeMultipleAtts.

--*/
{
    THSTATE              *pTHS=pDB->pTHS;
    ULONG                cEnumColumnId = 0;
    JET_ENUMCOLUMNID     *rgEnumColumnId = NULL;
    JET_GRBIT            grbit;
    ULONG                cEnumColumn = 0;
    JET_ENUMCOLUMN       *rgEnumColumn = NULL;
    JET_ENUMCOLUMN       *pEnumColumn;
    JET_ENUMCOLUMNVALUE  EnumColumnValueT = { 1, JET_errSuccess, 0, NULL };
    JET_ENUMCOLUMN       EnumColumnT = { 0, JET_errSuccess, 1, &EnumColumnValueT };
    ULONG                *pInConstr = NULL;
    ULONG                cInConstr = 0;
    ULONG                cb;
    ULONG                i, j;
    ULONG                ulCurrentColumnId = 0;
    ULONG                ulLen;
    UCHAR                *pucTmp;
    UCHAR                aSyntax;
    ATTCACHE             *pAC=NULL;
    BOOL                 fReadCols = FALSE;
    BOOL                 fReadConstr = FALSE;
    ATTR                 *pLinkAttList = NULL;
    ATTR                 *pColAttList = NULL;
    ATTR                 *pConstrAttList = NULL;
    ULONG                currLinkCol;
    DWORD                currCol = 0;
    DWORD                currConstr = 0;
    ULONG                linkAtts;
    DWORD                valueLimit = 0xFFFFFFFF;
    DWORD                initialValIndex;
    DWORD                NthAttIndex;
    BOOL                 defaultLimit;
    DWORD                err;
    DWORD                SyntaxFlags=0;
    DWORD                savedExtraFlags=0;
    BOOL                 fGetValues;
    BOOL                 fTrim;
    BOOL                 fExternal;
    BOOL                 fPublic;
    BOOL                 fOriginal;
    ULONG                SearchState;
    ULONG                lastLinkBase = 0;  //initialized to avoid C4701
    ULONG                currentLinkBase;

    // Set up some flags we'll need later on.

    // DBGETMULITPLEATTS_fEXTERNAL implies fGETVALS (i.e. fEXTERNAL = 3,
    // fGETVALS = 1).  So to truly see if we need to get external vals, we
    // need to see if ((FLAGS & 3) & ~1).  Therefore, the complex boolean
    // on the nextline.
    fExternal = ((Flags & DBGETMULTIPLEATTS_fEXTERNAL) &
                 ~DBGETMULTIPLEATTS_fGETVALS);

    fGetValues = Flags & DBGETMULTIPLEATTS_fGETVALS;
    fTrim      = Flags & DBGETMULTIPLEATTS_fREPLICATION;
    fPublic    = Flags & DBGETMULTIPLEATTS_fREPLICATION_PUBLIC;
    fOriginal  = Flags & DBGETMULTIPLEATTS_fOriginalValues;

    Assert(VALID_DBPOS(pDB));

    Assert(!(SecurityDescriptorFlags & 0xFFFFF0));
    SyntaxFlags = SecurityDescriptorFlags;
    // INTEXT_SHORTNAME and INTEXT_MAPINAME are in the same space as valid
    // security descriptor flags.  Or in the appropriate value to pass to the
    // intext routines.
    if(Flags & DBGETMULTIPLEATTS_fSHORTNAMES) {
        SyntaxFlags |= INTEXT_SHORTNAME;
    }
    if(Flags & DBGETMULTIPLEATTS_fMAPINAMES) {
        SyntaxFlags |= INTEXT_MAPINAME;
    }

    // if we have a range selection, we must have a range information thing to
    // fill up.
    Assert(!pRangeSel || pRangeInf);

    if(pRangeSel) {
        pRangeInf->count = 0;
        pRangeInf->pRanges = NULL;
    }

    // First, set up the memory to hold link atts.  We may not need to hold any
    // link atts, but finding out first is difficult and not worth it.
    // We are looking for the 0th link att and we have allocated 5 ATTRs to
    // hold links.
    currLinkCol = 0;
    linkAtts = 5;
    pLinkAttList = THAllocEx(pTHS, linkAtts * sizeof(ATTR));


    // Now determine if we need to retrieve all attributes or a selection
    if (!cReqAtts) {
        ULONG SearchState = ATTRSEARCHSTATELINKS;
        // No atts have been specified, so retrieve all attributes

        fReadCols = TRUE;
        // First, read all the link attributes

        // Set the search state for dbGetNextAtt to look only for links
        // and backlinks

        while (!dbGetNextAtt(pDB, &pAC, &SearchState)) {

            // We now have a link attribute that has values on this object.
            // Furthermore, currency in the link table is already on this
            // object.

            if (fTrim && FIsBacklink(pAC->ulLinkID)) {
                // We don't want to use this one anyway, skip it
                continue;
            }

            if(currLinkCol == linkAtts) {
                // We need to allocate some more room
                linkAtts *=2;
                pLinkAttList=THReAllocEx(pTHS, pLinkAttList, linkAtts * sizeof(ATTR));
            }

            pLinkAttList[currLinkCol].attrTyp = pAC->id;

            // Add the values - only if necessary
            if(fGetValues) {
                DWORD dummy;
                if(err = dbGetMultipleAttsLinkHelp (
                        pDB,
                        fExternal,
                        SyntaxFlags,
                        pAC,
                        pRangeSel,
                        pRangeInf,
                        &pLinkAttList[currLinkCol].AttrVal,
                        &dummy,
                        &dummy)) {
                    return err;
                }
                if(pLinkAttList[currLinkCol].AttrVal.valCount) {
                    currLinkCol++;
                }
            }
            else {
                // We don't really care about the values.
                pLinkAttList[currLinkCol].AttrVal.valCount = 0;
                pLinkAttList[currLinkCol].AttrVal.pAVal = NULL;
                currLinkCol++;
            }
        }
    }
    else {
        // allocate JET_RETRIEVECOLUMN structures for all selected attributes,
        // and read the link attributes directly now.
        SearchState = ATTRSEARCHSTATEUNDEFINED;

        cb = cReqAtts * sizeof(JET_ENUMCOLUMNID);
        rgEnumColumnId = (JET_ENUMCOLUMNID *) THAllocEx(pTHS,cb);
        pInConstr = (ULONG *) THAllocEx(pTHS,cReqAtts*sizeof(ULONG));

        for (i = 0; i < cReqAtts; i++) {
            BOOL fChecked = FALSE;
            if (!pReqAtts[i]) {
                // They didn't really want an attribute.
                continue;
            }

            if (pReqAtts[i]->ulLinkID) {
                DWORD requestedLinkBase = MakeLinkBase(pReqAtts[i]->ulLinkID);

                // The attribute they are asking for is a link or backlink

                if (fTrim && FIsBacklink(pReqAtts[i]->ulLinkID)) {
                    // We don't want to use this one, skip it
                    continue;
                }

                // Position on the correct value.
                fChecked = FALSE;
                // Try using state to position
                if(FIsBacklink((pReqAtts[i]->ulLinkID))) {
                    // We're looking up a backlink.
                    if(SearchState == ATTRSEARCHSTATEBACKLINKS) {
                        // And, our state is in the backlink table.
                        if((requestedLinkBase > lastLinkBase) &&
                           (requestedLinkBase < currentLinkBase)) {
                            // We're looking up an attribute that we know
                            // has no values, because it is in between the
                            // last link ID we tried to look up and
                            // the current link ID we are positioned on.
                            continue;
                        }
                        else if(requestedLinkBase == currentLinkBase) {
                            // We're on the right entry in the
                            // table, and it has values.
                            fChecked = TRUE;
                        }
                        // ELSE
                        //   We don't really know anything about whether
                        //   this has values.  We have to look it up.
                    }
                    // ELSE
                    //   We don't have currency in the correct index in the
                    //   link table.  We have to look it up.
                }
                else {
                    // We're looking up a link.
                    if(SearchState == ATTRSEARCHSTATELINKS) {
                        // And, our state is in the link table.
                        if((requestedLinkBase > lastLinkBase) &&
                           (requestedLinkBase < currentLinkBase)) {
                            // We're looking up an attribute that we know
                            // has no values, because it is in between the
                            // last link ID we tried to look up and
                            // the current link ID we are positioned on.
                            continue;
                        }
                        else if(requestedLinkBase == currentLinkBase) {
                            // Finally, we're on the right entry in the
                            // table, and it has values.
                            fChecked = TRUE;
                        }
                        // ELSE
                        //   We don't really know anything about whether
                        //   this has values.  We have to look it up.
                    }
                    // ELSE
                    //   We don't have currency in the correct index in the
                    //   link table.  We have to look it up.
                }

                if(!fChecked) {
                    DWORD ActualDNT;

                    err = dbPositionOnLinkVal(pDB,
                                              pReqAtts[i],
                                              &ActualDNT,
                                              &currentLinkBase,
                                              &SearchState);
                    lastLinkBase =  requestedLinkBase;
                    if(ActualDNT != pDB->DNT) {
                        // Oops, positioned on the next object, not really a
                        // value of this object at all.
                        currentLinkBase = 0xFFFFFFFF;
                    }

                    if(err) {
                        // No such attribute or we have no values.  Skip it.
                        continue;
                    }
                }

                // The attribute is present and has values.  Furthermore,
                // currency in the Link Table is on the first value.

                if(currLinkCol == linkAtts) {
                    // We need to allocate some more room
                    linkAtts *=2;
                    pLinkAttList =
                        THReAllocEx(pTHS, pLinkAttList, linkAtts * sizeof(ATTR));
                }

                pLinkAttList[currLinkCol].attrTyp = pReqAtts[i]->id;


                // Add the values - only if necessary
                if(fGetValues ) {
                    if(err = dbGetMultipleAttsLinkHelp (
                            pDB,
                            fExternal,
                            SyntaxFlags,
                            pReqAtts[i],
                            pRangeSel,
                            pRangeInf,
                            &pLinkAttList[currLinkCol].AttrVal,
                            &SearchState,
                            &currentLinkBase)) {

                        THFreeEx(pTHS, rgEnumColumnId);
                        THFreeEx(pTHS, pInConstr);
                        return err;
                    }
                    if(pLinkAttList[currLinkCol].AttrVal.valCount) {
                        currLinkCol++;
                    }
                }
                else {
                    // They don't want values.
                    pLinkAttList[currLinkCol].AttrVal.valCount = 0;
                    pLinkAttList[currLinkCol].AttrVal.pAVal = NULL;
                    currLinkCol++;
                }
            }
            else if (pReqAtts[i]->bIsConstructed) {
                // constructed atts, save to read at end
                pInConstr[cInConstr] = pReqAtts[i]->id;
                cInConstr++;
                fReadConstr = TRUE;
            }
            else {
                // Attribute is a column - setup and read it later
                rgEnumColumnId[cEnumColumnId].columnid = pReqAtts[i]->jColid;
                rgEnumColumnId[cEnumColumnId].ctagSequence = 0;
                cEnumColumnId++;
                fReadCols = TRUE;
            }
        }
    }

    // Now we need to read the columns - if necessary
    if (fReadCols) {

        grbit = JET_bitEnumerateCompressOutput;
        if (!fOriginal) {
            // JET_bitEnumerateCopy == JET_bitRetrieveCopy
            Assert(pDB->JetRetrieveBits == 0 || pDB->JetRetrieveBits == JET_bitEnumerateCopy);
            grbit = grbit | pDB->JetRetrieveBits;
        }
        if (!fGetValues) {
            grbit = grbit | JET_bitEnumeratePresenceOnly;
        }
        if (!cEnumColumnId) {
            grbit = grbit | JET_bitEnumerateTaggedOnly;
        }
        JetEnumerateColumnsEx(
            pDB->JetSessID,
            pDB->JetObjTbl,
            cEnumColumnId,
            rgEnumColumnId,
            &cEnumColumn,
            &rgEnumColumn,
            (JET_PFNREALLOC)dbGetMultipleAttsRealloc,
            pTHS,
            -1,  // never truncate values
            grbit );

        i = 0;
        if(cEnumColumn) {
            // We have some columns, turn them into an attrblock
            DWORD numColsNeeded = 0;
            // Count the number of columns we read.
            numColsNeeded = cEnumColumn;

            // Tack this onto the end of the already allocated ATTRs we used for
            // the link atts.  Saves allocations later if the caller doesn't
            // care about what order we return things in
            numColsNeeded = currLinkCol + numColsNeeded;
            pLinkAttList =
                THReAllocEx(pTHS, pLinkAttList, numColsNeeded * sizeof(ATTR));
            pColAttList = &(pLinkAttList[currLinkCol]);

            i=0;
            while(i< cEnumColumn) {
                DWORD numVals;

                ulCurrentColumnId = rgEnumColumn[i].columnid;

                // Look for internal columns and trim them out.  They are tagged, but is
                // treated different from all the other tagged columns, and should NEVER be
                // returned from this routine.
                if(     ulCurrentColumnId == ancestorsid ||
                        ulCurrentColumnId == cleanid) {
                    i++;
                    continue;
                }

                if(rgEnumColumn[i].err == JET_wrnColumnNull) {
                    // We get this when we have removed a value in this
                    // transaction
                    i++;
                    continue;
                }

                // Get the attcache for this column
                if (!(pAC = SCGetAttByCol(pTHS, ulCurrentColumnId))) {
                    if (rgEnumColumnId) THFreeEx(pTHS, rgEnumColumnId);
                    dbGetMultipleAttsFreeData(pTHS, cEnumColumn, rgEnumColumn);
                    if (pInConstr) THFreeEx(pTHS, pInConstr);
                    return DB_ERR_SYSERROR;
                }

                // Find out if there is anything special about the
                // attribute.  First clear any flags that we might
                // have set in a previous pass.  Then set any flags
                // as appropriate.
                SyntaxFlags &= (~savedExtraFlags);
                savedExtraFlags = DBGetExtraHackyFlags(pAC->id);
                SyntaxFlags |= savedExtraFlags;

                // Pass the flags for decryption, if the attribute is
                // a secret data
                if (DBIsSecretData(pAC->id)){

                    // Filter out secrets if requested
                    if ( fTrim && fPublic ) {
                        i++;
                        continue; // note - jump to bottom of loop
                    }

                    SyntaxFlags|=INTEXT_SECRETDATA;
                }
                else
                {
                    SyntaxFlags&=(~((ULONG) INTEXT_SECRETDATA));
                }

                DBGetValueLimits(pAC, pRangeSel, &initialValIndex,
                                 &valueLimit, &defaultLimit);
                NthAttIndex = initialValIndex;

                if(fTrim) {
                    switch(pAC->id) {
                      case ATT_REPS_TO:
                      case ATT_REPS_FROM:
                      case ATT_OBJECT_GUID:
                      case ATT_REPL_PROPERTY_META_DATA:
                      case ATT_REPL_UPTODATE_VECTOR:

                        // We don't want to use this one.  We trim these out
                        // to support replication, as replication doesn't
                        // send any of these across a replication link
                        i++;
                        continue; // note - jump to bottom of loop

                      default:
                        ;
                    }

                }

                pEnumColumn = &rgEnumColumn[i];
                if(pEnumColumn->err == JET_wrnColumnSingleValue) {
                    // Decompress this column value to a temp enum column struct
                    EnumColumnT.columnid = pEnumColumn->columnid;
                    EnumColumnValueT.cbData = pEnumColumn->cbData;
                    EnumColumnValueT.pvData = pEnumColumn->pvData;
                    pEnumColumn = &EnumColumnT;
                }

                if(fGetValues) {
                    if (NthAttIndex > pEnumColumn->cEnumColumnValue) {
                        // We were told via range to skip all the values
                        i++;
                        continue;
                    }
                }

                // At this point, we definitely have some values left to return.
                pColAttList[currCol].attrTyp = pAC->id;

                // Count the values for this attribute.
                if (NthAttIndex >= pEnumColumn->cEnumColumnValue) {
                    numVals = 0;
                } else {
                    numVals = pEnumColumn->cEnumColumnValue - NthAttIndex;
                }

                if(numVals > valueLimit) {
                    dbRegisterLimitReached(pTHS,
                                           pRangeInf,
                                           pAC->id,
                                           initialValIndex,
                                           initialValIndex + valueLimit - 1);
                    numVals = valueLimit;
                }
                else if (!defaultLimit) {
                    // We're going to get all the rest of the values, but we
                    // need to register because they explicitly asked for limits
                    dbRegisterLimitReached(pTHS,
                                           pRangeInf,
                                           pAC->id,
                                           initialValIndex,
                                           0xFFFFFFFF);
                }

                // Set up the AttrValBlock
                if(fGetValues) {

                    pColAttList[currCol].AttrVal.valCount= numVals;
                    pColAttList[currCol].AttrVal.pAVal =
                        THAllocEx(pTHS, numVals * sizeof(ATTRVAL));
                }
                else {
                    // They don't want values at all.
                    pColAttList[currCol].AttrVal.valCount = 0;
                    pColAttList[currCol].AttrVal.pAVal = NULL;
                }

                // Now put the values into the AttrValBlock from the jet
                // columns
                for (j = 0; j < numVals; j++ ) {

                    // get the current column value
                    ULONG cbData = pEnumColumn->rgEnumColumnValue[j + NthAttIndex].cbData;
                    void* pvData = pEnumColumn->rgEnumColumnValue[j + NthAttIndex].pvData;

                    // pvData now owns the memory containing the column value
                    if (rgEnumColumn[i].err == JET_wrnColumnSingleValue) {
                        rgEnumColumn[i].pvData = NULL;
                    } else {
                        rgEnumColumn[i].rgEnumColumnValue[j + NthAttIndex].pvData = NULL;
                    }
                    
                    if (j < valueLimit && fExternal && fGetValues) {
                        // They want external values.
                        
                        if(err = gDBSyntax[pAC->syntax].IntExt(
                                pDB,
                                DBSYN_INQ,
                                cbData,
                                pvData,
                                &ulLen,
                                &pucTmp,
                                0,
                                0,
                                SyntaxFlags)) {
                            THFreeEx(pTHS, pvData);
                            if (rgEnumColumnId) THFreeEx(pTHS, rgEnumColumnId);
                            dbGetMultipleAttsFreeData(pTHS, cEnumColumn, rgEnumColumn);
                            if (pInConstr) THFreeEx(pTHS, pInConstr);
                            return err;
                        }
                        if (    ulLen == cbData &&
                                (   pucTmp == pvData ||
                                    memcmp(pucTmp, pvData, ulLen ) == 0) ) {
                            // Internal and external are the same, don't
                            // alloc any more memory.
                            pColAttList[currCol].AttrVal.pAVal[j].valLen =
                                cbData;
                            pColAttList[currCol].AttrVal.pAVal[j].pVal =
                                pvData;
                        }
                        else {
                            pColAttList[currCol].AttrVal.pAVal[j].valLen =
                                ulLen;
                            pColAttList[currCol].AttrVal.pAVal[j].pVal =
                                THAllocEx(pTHS, ulLen);
                            memcpy(pColAttList[currCol].AttrVal.pAVal[j].pVal,
                                   pucTmp,
                                   ulLen);
                            THFreeEx(pTHS, pvData);
                        }
                    }
                    else if (j < valueLimit && fGetValues) {
                        // They want values in internal format
                        pColAttList[currCol].AttrVal.pAVal[j].valLen =
                            cbData;
                        pColAttList[currCol].AttrVal.pAVal[j].pVal =
                            pvData;
                    }
                    else {
                        // They don't want these values at all.
                        THFreeEx(pTHS, pvData);
                    }
                }

                // Consume the source column and an attr block
                i++;
                currCol++;
            }
        }
    }


    // Don't need this anymore.
    if (rgEnumColumnId) THFreeEx(pTHS,rgEnumColumnId);
    dbGetMultipleAttsFreeData(pTHS, cEnumColumn, rgEnumColumn);

    // Now read and add any constructed atts

    if (fReadConstr) {

        DWORD numColsNeeded = 0, err = 0;

        Assert(cReqAtts);
        // maximum space needed
        numColsNeeded = currLinkCol + currCol + cInConstr;
        pLinkAttList =
                THReAllocEx(pTHS, pLinkAttList, numColsNeeded * sizeof(ATTR));
        pColAttList = &(pLinkAttList[currLinkCol]);
        pConstrAttList = &(pLinkAttList[currLinkCol + currCol]);

        for (i=0; i<cReqAtts; i++) {
            // For every constructed attribute (pAC)
            DWORD dwBaseIndex;
            DWORD dwNumRequeseted;
            DWORD bDefault;

            if (pInConstr[i]) {
                if (!(pAC = SCGetAttById(pTHS, pInConstr[i]))) {
                    if (pInConstr) THFreeEx(pTHS, pInConstr);
                    return DB_ERR_SYSERROR;
                };

                // Get value range information. If no range information was explicitly provided using
                // the ;range= syntax default ranges will be used and bDefault will be true
                DBGetValueLimits(pAC, pRangeSel, &dwBaseIndex, &dwNumRequeseted, &bDefault);

                // tokenGroups or tokenGroupsNoGCAcceptable may have to
                // go off machine, in which case they close the current
                // transaction and open a new one. pDB will contain the
                // new dbpos in that case
                err = dbGetConstructedAtt(&pDB,
                                          pAC,
                                          &pConstrAttList[currConstr],
                                          dwBaseIndex,
                                          &dwNumRequeseted,
                                          fExternal);

                switch (err) {
                case DB_success:
                    if (!bDefault) {
                        // Register limits for return to client
                        DPRINT2(1,"Registering Limits = %d-%d \n", dwBaseIndex, dwNumRequeseted);
                        dbRegisterLimitReached(pTHS,
                                               pRangeInf,
                                               pAC->id,
                                               dwBaseIndex,
                                               dwNumRequeseted);
                    }

                    // got the constructed att. see if value is needed
                    pConstrAttList[currConstr].attrTyp = pInConstr[i];
                    if (!fGetValues) {
                        pConstrAttList[currConstr].AttrVal.valCount = 0;
                        pConstrAttList[currConstr].AttrVal.pAVal = NULL;
                    }
                    currConstr++;
                        break;
                case DB_ERR_NO_VALUE:
                       // this constructed att is not defined on this object
                       break;
                default:
                       // some other error
                      if (pInConstr) THFreeEx(pTHS, pInConstr);
                      return err;
                }
             }
          } // for

     }


    // Merge the lists into a sorted array - if necessary
    i = 0;
    if (!cReqAtts) {
        // No need for any particular order.  The ATTRs have all been allocated
        // using the pLinkAttList variable, just return that.
        *attrCount = currLinkCol + currCol;
        if(*attrCount)
            *ppAttr = pLinkAttList;
        else {
            *ppAttr = NULL;
            // since we don't return anything, free it
            THFreeEx (pTHS, pLinkAttList);
        }
    }
    else {
        ULONG iCol=0;
        ULONG iLink=0;
        ULONG iConstr=0;

        // We could conceivable play shuffling games using the already allocated
        // ATTR array, but for ease of coding I just allocate a new array.
        (*ppAttr) = THAllocEx(pTHS, (currLinkCol + currCol + currConstr)*sizeof(ATTR));

        i=0;
        for (j=0; j<cReqAtts; j++) {
            if(!pReqAtts[j]) {
                // They didn't ask for anything using this element.
                continue;
            }
            if ((iCol < currCol) &&
                (pReqAtts[j]->id == pColAttList[iCol].attrTyp)) {
                // The next one to put in the return array is a non-link att
                (*ppAttr)[i] = pColAttList[iCol];
                iCol++;
                i++;
            }
            else if((iLink < currLinkCol) &&
                    (pReqAtts[j]->id == pLinkAttList[iLink].attrTyp)) {
                // The next one to put in the return array is a link att
                (*ppAttr)[i] = pLinkAttList[iLink];
                iLink++;
                i++;
            }
            else if((iConstr < currConstr) &&
                    (pReqAtts[j]->id == pConstrAttList[iConstr].attrTyp)) {
                // The next one to put in the return array is a Constr att
                (*ppAttr)[i] = pConstrAttList[iConstr];
                iConstr++;
                i++;
            }
            else
                // The next one to put in the return array was not found on this
                // object, skip it.
                continue;

        }
        *attrCount = i;

        // since we already copied all the entries, free it
        THFreeEx (pTHS, pLinkAttList);
    }


    if (pInConstr) THFreeEx(pTHS, pInConstr);
    return 0;
}


extern BOOL gStoreSDsInMainTable;
#ifdef DBG
LONG gSecurityCacheHits = 0;
LONG gSecurityCacheMisses = 0;
#endif

/*++
DBGetObjectSecurityInfo

Description:

    Get SD, DN, Sid and pointer to CLASSCACHE for an object that is
    current in the table.

    NOTE!!! This routine returns an abbreviated form of the DSNAME GUID and SID
    filled in, but no string name.

Arguments:

    pDB - the DBPos to use.

    tag -- the DNT to check

    pulLen - (optional) the size of the buffer allocated to hold the security descriptor

    pNTSD - (optional) pointer to pointer to security descriptor found.

    ppCC - (optional) pointer to pointer to classcache to fill in.

    ppDN - (optional) pointer to DN (only SID and GUID are filled!).

    pObjFlag -- (optional) pointer to objFlag

    flags -- which table to use:
                DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE or DBGETOBJECTSECURITYINFO_fUSE_SEARCH_TABLE
             are we positioned on the correct row already or we need to seek the dnt?
                DBGETOBJECTSECURITYINFO_fSEEK_ROW (only seeks on Search table are allowed!)

--*/
DWORD
DBGetObjectSecurityInfo(
    PDBPOS pDB,
    DWORD dnt,
    PULONG pulLen,
    PSECURITY_DESCRIPTOR *ppNTSD,
    CLASSCACHE **ppCC,
    PDSNAME pDN,
    char    *pObjFlag,
    DWORD   flags
    )
{
    THSTATE  *pTHS=pDB->pTHS;
    JET_RETRIEVECOLUMN attList[5];
    DWORD cAtt, ntsdIndex, sidIndex, guidIndex, ccIndex, objflagIndex;
    ATTRTYP class;
    JET_ERR err;
    SDID sdId; // temp buffer for SD ID
    UCHAR *sdBuf;
    d_memname* pname;
    JET_TABLEID table = flags & DBGETOBJECTSECURITYINFO_fUSE_SEARCH_TABLE ? pDB->JetSearchTbl : pDB->JetObjTbl;

    Assert(VALID_DBPOS(pDB));

    // make sure they are asking for at least something
    Assert((ppNTSD && pulLen) || ppCC || pDN || pObjFlag);
    // seeks on the object table are not allowed
    Assert((flags & DBGETOBJECTSECURITYINFO_fSEEK_ROW) == 0 || (flags & DBGETOBJECTSECURITYINFO_fUSE_SEARCH_TABLE) != 0);

    if (pDN) {
        pDN->structLen = DSNameSizeFromLen(0);
        pDN->NameLen = 0;
    }

    if (ppNTSD) {
        *ppNTSD = NULL;
        *pulLen = 0;
    }
    if (ppCC) {
        *ppCC = NULL;
    }

    // try to find the entry in the cache
    // don't use cache if buffer copy is requested
    // don't use cache if NTSD is requested and is in old-style format
    if (pDB->JetRetrieveBits == 0 &&
        dnGetCacheByDNT(pDB, dnt, &pname) &&
        (ppNTSD && pname->sdId != (SDID)-1))
    {
#ifdef DBG
        InterlockedIncrement(&gSecurityCacheHits);
#endif
        // ok, we got some useful info in the cache... use it.
        if (ppNTSD) {
            ntsdIndex = 0;
            if (pname->sdId == (SDID)0) {
                // this object has no SD.
                attList[ntsdIndex].pvData = NULL;
                attList[ntsdIndex].err = JET_wrnColumnNull;
                attList[ntsdIndex].cbActual = 0;
            }
            else {
                // grab sdid
                attList[ntsdIndex].pvData = &sdId;
                sdId = pname->sdId;
                attList[ntsdIndex].cbActual = sizeof(SDID);
                attList[ntsdIndex].err = JET_errSuccess;
            }
        }

        class = pname->dwObjectClass;

        if (pDN) {
            // copy sid and guid
            memcpy(&pDN->Guid, &pname->Guid, sizeof(GUID));
            memcpy(&pDN->Sid, &pname->Sid, pname->SidLen);
            pDN->SidLen = pname->SidLen;
            // sid is already InPlaceSwapSid'ed
        }

        if (pObjFlag) {
            *pObjFlag = pname->objflag ? 1 : 0;
        }
    }
    else {
        // no luck with the cache, let's read the data from the DB
#ifdef DBG
        if (pDB->JetRetrieveBits == 0) {
            // we hoped to find it in the cache...
            InterlockedIncrement(&gSecurityCacheMisses);
        }
#endif

        if (flags & DBGETOBJECTSECURITYINFO_fSEEK_ROW) {
            // need to position on the DNT first
            JetSetCurrentIndexSuccess(pDB->JetSessID,
                                      table,
                                      SZDNTINDEX);

            JetMakeKeyEx(pDB->JetSessID, table, &dnt, sizeof(dnt), JET_bitNewKey);
            if (err = JetSeekEx(pDB->JetSessID, table, JET_bitSeekEQ)) {
                DsaExcept(DSA_DB_EXCEPTION, err, dnt);
            }
            pDB->SDNT = dnt;
        }
        else {
#ifdef DBG
            // let's check we are positioned on the right row
            DWORD checkDNT, cbActual;
            err = JetRetrieveColumn(pDB->JetSessID, table, dntid, &checkDNT, sizeof(checkDNT), &cbActual, 0, NULL);
            Assert(err == 0 && checkDNT == dnt);
#endif
        }

        // Set up the RetrieveColumn structure to do the JetRetrieveColumns

        cAtt = 0;
        memset(attList, 0, sizeof(attList));

        if (ppNTSD) {
            // First, the Security Descriptor hash
            ntsdIndex = cAtt;
            cAtt++;
            attList[ntsdIndex].pvData = (void *)&sdId;
            attList[ntsdIndex].cbData = sizeof(sdId);
            attList[ntsdIndex].columnid = ntsecdescid;
            attList[ntsdIndex].grbit = pDB->JetRetrieveBits;
            attList[ntsdIndex].itagSequence = 1;
        }
        else {
            ntsdIndex = -1;
        }

        if (pDN) {
            sidIndex = cAtt;
            cAtt++;
            // Next, the SID
            attList[sidIndex].pvData = (void *)&pDN->Sid;
            attList[sidIndex].columnid = sidid;
            attList[sidIndex].cbData = sizeof(NT4SID);
            attList[sidIndex].grbit = pDB->JetRetrieveBits;
            attList[sidIndex].itagSequence = 1;

            // And, the GUID
            guidIndex = cAtt;
            cAtt++;
            attList[guidIndex].pvData = (void *)&pDN->Guid;
            attList[guidIndex].columnid = guidid;
            attList[guidIndex].cbData = sizeof(GUID);
            attList[guidIndex].grbit = pDB->JetRetrieveBits;
            attList[guidIndex].itagSequence = 1;
        }
        else {
            sidIndex = guidIndex = -1;
        }

        if (ppCC) {
            // the class
            ccIndex = cAtt;
            cAtt++;
            attList[ccIndex].pvData = (void *)&class;
            attList[ccIndex].columnid = objclassid;
            attList[ccIndex].cbData = sizeof(class);
            attList[ccIndex].grbit = pDB->JetRetrieveBits;
            attList[ccIndex].itagSequence = 1;
        }
        else {
            ccIndex = -1;
        }

        if (pObjFlag) {
            // the object flag
            objflagIndex = cAtt;
            cAtt++;
            attList[objflagIndex].pvData = (void *)pObjFlag;
            attList[objflagIndex].columnid = objid;
            attList[objflagIndex].cbData = sizeof(*pObjFlag);
            attList[objflagIndex].grbit = pDB->JetRetrieveBits;
            attList[objflagIndex].itagSequence = 1;
        }
        else {
            objflagIndex = -1;
        }

        err = JetRetrieveColumnsWarnings(pDB->JetSessID,
                                         table,
                                         attList,
                                         cAtt);

        if((err != JET_errSuccess && err != JET_wrnBufferTruncated)           ||
           // overall error not Buffer Truncated or success
           (ntsdIndex != -1 && attList[ntsdIndex].err != JET_wrnBufferTruncated &&
            attList[ntsdIndex].err != JET_errSuccess && attList[ntsdIndex].err != JET_wrnColumnNull) ||
           // or specific error for NTSD not Buffer truncated or success or NULL
           (guidIndex != -1 && attList[guidIndex].err != JET_errSuccess)         ||
           // or no GUID
           (sidIndex != -1 && attList[sidIndex].err != JET_errSuccess && attList[sidIndex].err != JET_wrnColumnNull ) ||
           // or some erro other than no SID (sid is not always there)
           (ccIndex != -1 && attList[ccIndex].err != JET_errSuccess)          ||
           // or no Class
           (objflagIndex != -1 && attList[objflagIndex].err != JET_errSuccess && attList[objflagIndex].err != JET_wrnColumnNull)
          )
        {
            return DB_ERR_UNKNOWN_ERROR;
        }

        if (ntsdIndex != -1 && attList[ntsdIndex].err == JET_wrnBufferTruncated) {
            // This is the expected case for old style SDs. We didn't allocate enough for the
            // Security Descriptor because we needed to know how big it was.  Now we
            // know, allocate and remake the call.

            attList[ntsdIndex].pvData = THAllocEx(pTHS, attList[ntsdIndex].cbActual);
            attList[ntsdIndex].cbData = attList[ntsdIndex].cbActual;

            err = JetRetrieveColumnsWarnings(pDB->JetSessID, table, &attList[ntsdIndex], 1);

            if(err || attList[ntsdIndex].err) {
                THFreeEx(pTHS, attList[ntsdIndex].pvData);
                return DB_ERR_UNKNOWN_ERROR;
            }
        }

        if (sidIndex != -1) {
            // Convert the Sid to external val
            pDN->SidLen = attList[sidIndex].cbActual;
            if (pDN->SidLen) {
                InPlaceSwapSid(&pDN->Sid);
            }
        }

        if (objflagIndex != -1 && attList[objflagIndex].err == JET_wrnColumnNull) {
            // phantom...
            *pObjFlag = 0;
        }
    }

    if (ppNTSD) {
        if (attList[ntsdIndex].err == JET_errSuccess) {
            // got the NTSD. Convert it to external format.
            err = IntExtSecDesc(pDB, DBSYN_INQ, attList[ntsdIndex].cbActual, attList[ntsdIndex].pvData, pulLen, &sdBuf, 0, 0, 0);

            if (attList[ntsdIndex].pvData != &sdId) {
                // we don't need this internal value anymore
                THFreeEx(pTHS, attList[ntsdIndex].pvData);
            }

            if(err) {
                // something bad happened in IntExtSecDesc...
                *ppNTSD = NULL;
                *pulLen = 0;
                return DB_ERR_UNKNOWN_ERROR;
            }
            *ppNTSD = THAllocEx(pTHS, *pulLen);
            memcpy(*ppNTSD, sdBuf, *pulLen);
        }
        else {
            // null ntsd
            Assert(attList[ntsdIndex].err == JET_wrnColumnNull);
            *ppNTSD = NULL;
            *pulLen = 0;
        }
    }

    if (ppCC) {
        // And get the classcache pointer.
        *ppCC = SCGetClassById(pTHS, class);
        if(NULL == *ppCC) {
            // Um, we have a problem, but it's not a JET error.  Oh, well, return it
            // anyway.
            if (ppNTSD) {
                THFreeEx(pTHS, *ppNTSD);
                *ppNTSD = NULL;
                *pulLen = 0;
            }
            return 1;
        }
    }

    return 0;
}

/*++
DBGetParentSecurityInfo

Routine Description:

    Get the security descriptor, DN, and pointer to CLASSCACHE for the object
    class  of the parent of the current object.  Do this using the search table
    so that the currency and current index of the object table is unnafected.

    The memory returned by this routine is allocated using THAlloc.

    NOTE!!! This routine returns an abbreviated form of the DSNAME GUID and SID
    filled in, but no string name.

Arguments:

    pDB - the DBPos to use.

    pulLen - the size of the buffer allocated to hold the security descriptor.

    pNTSD - pointer to pointer to security descriptor found.

    ppCC - pointer to pointer to classcache to fill in.

    ppDN - pointer to pointer to DN. See NOTE above.

Return Value:

    0 if all went well, non-zero otherwise.

--*/
DWORD
DBGetParentSecurityInfo (
        PDBPOS pDB,
        PULONG pulLen,
        PSECURITY_DESCRIPTOR *ppNTSD,
        CLASSCACHE **ppCC,
        PDSNAME *ppDN
        )
{
    JET_ERR err;
    PDSNAME pDN;
    THSTATE* pTHS = pDB->pTHS;
    JET_GRBIT saveJetRetrieveBits = pDB->JetRetrieveBits;

    *ppNTSD = NULL;
    *ppCC = NULL;
    *ppDN = NULL;
    *pulLen = 0;
    // reset JetRetrieveBits so that we can use the cache
    pDB->JetRetrieveBits = 0;

    pDN = THAllocEx(pTHS, sizeof(DSNAME));

    // call DBGetObjectSecurityInfo. We are not positioned on the row!
    err = DBGetObjectSecurityInfo(
            pDB,
            pDB->PDNT,
            pulLen,
            ppNTSD,
            ppCC,
            pDN,
            NULL,
            DBGETOBJECTSECURITYINFO_fUSE_SEARCH_TABLE | DBGETOBJECTSECURITYINFO_fSEEK_ROW
        );

    // restore JetRetrieveBits
    pDB->JetRetrieveBits = saveJetRetrieveBits;

    if (err == 0 && *pulLen == 0) {
        // no NTSD. Not allowed.
        err = DB_ERR_UNKNOWN_ERROR;
    }
    if (err) {
        THFreeEx(pTHS, pDN);
        return err;
    }
    *ppDN = pDN;
    return 0;
}

extern DWORD
DBFillGuidAndSid (
        DBPOS *pDB,
        DSNAME *pDN
        )
/*++

Routine Description:

    Fills in the GUID and SID fields of the DSNAME structure passed in by
    reading the GUID and SID from the current object in the pDB.  Completely
    ignores any string portion of the DSNAME.

Parameters:

    pDB - DBPos to use

    pDN - Pointer to a DSNAME.  The DSNAME must be preallocated and must be at
    least large enough to hold the GUID and SID.

Return Values:

    0 if all went well.
--*/
{
    JET_RETRIEVECOLUMN attList[2];
    DWORD cbActual;
    DWORD err;
    NT4SID  objectSid;


#if DBG
    // In the debug case, track the value of the old guid for an assert later.
    GUID  oldGuid;

    memcpy(&oldGuid, &pDN->Guid, sizeof(GUID));
#endif

    Assert(VALID_DBPOS(pDB));

    memset(&objectSid, 0, sizeof(NT4SID));

    memset(attList, 0, sizeof(attList));
    attList[0].pvData = (void *)&pDN->Guid;
    attList[0].columnid = guidid;
    attList[0].cbData = sizeof(GUID);
    attList[0].grbit = pDB->JetRetrieveBits;
    attList[0].itagSequence = 1;

    attList[1].pvData = (void *)&objectSid;
    attList[1].columnid = sidid;
    attList[1].cbData = sizeof(NT4SID);
    attList[1].grbit = pDB->JetRetrieveBits;
    attList[1].itagSequence = 1;

    err = JetRetrieveColumnsWarnings(pDB->JetSessID,
                                     pDB->JetObjTbl,
                                     attList,
                                     2);
    switch(err) {
    case JET_errSuccess:
        pDN->SidLen = attList[1].cbActual;
        if(attList[1].cbActual) {
            //
            // Convert the Sid to external val
            //
            InPlaceSwapSid(&objectSid);
            memcpy(&pDN->Sid, &objectSid, sizeof(NT4SID));
        }
        return 0;
        break;

    default:
        return DB_ERR_UNKNOWN_ERROR;
        break;
    }

#if DBG
    // either we didn't have a guid, or we did and we ended up with the same
    // guid.  This is here because I was too chicken to bail out of this request
    // if the dsname already had a GUID, and I wanted to see if anyone ever
    // tried to fill in a GUID on top of a different GUID (which they shouldn't
    // do.)
    Assert(fNullUuid(&oldGuid) || !memcmp(&oldGuid,&pDN->Guid,sizeof(GUID)));
#endif


    return DB_ERR_UNKNOWN_ERROR;
}

//
//  On October 22 1997, the NTWSTA Self Host Domain
//  lost all builtin group memberships. To track the
//  problem down if it happens again, have a hard coded
//  check for Administrator being removed from Administrators
//  The check works by reading in the DNT of Administrators
//  and the DNT of Administrator at boot time, and then
//  checking for them in DBRemoveLinkVal
//

#ifdef CHECK_FOR_ADMINISTRATOR_LOSS

ULONG ulDNTAdministrators=0;
ULONG ulDNTAdministrator=0;
BOOL  AdminDNTsAreValid=FALSE;

VOID
DBCheckForAdministratorLoss(
    ULONG ulDNTObject,
    ULONG ulDNTAttribute
   )
{

    if ((ulDNTObject==ulDNTAdministrators)
        && (ulDNTAttribute==ulDNTAdministrator)
        && (AdminDNTsAreValid))
    {
       KdPrint(("Possible removal of Administrator Account"
                "From the Administrators Group. Please "
                "Contact DS Development\n"));

       DebugBreak();
    }
}

/*++dbFindObjectWithSidInNc
 *
 *     Given a DS Name Specifying  a SID and an ULONG specifying the
 *     naming context, this routine will try to find an Object with
 *     the given Sid in the specified naming context
 *
 *
 *     Returns
 *          0                       - Found the Object Successfully
 *          DIRERR_OBJECT_NOT_FOUND - If the Object Was not found
 *          DIRERR_NOT_AN_OBJECT    - If the Object is a Phantom
 *
 --*/
DWORD APIENTRY
dbFindObjectWithSidInNc(DBPOS FAR *pDB, DSNAME * pDN, ULONG ulGivenNc)
{

    NT4SID InternalFormatSid;
    DWORD err;
    ULONG ulDNT;
    ULONG cbActual;


    Assert(VALID_DBPOS(pDB));
    Assert(pDN->SidLen>0);
    Assert(RtlValidSid(&pDN->Sid));


    err = DBSetCurrentIndex(pDB, Idx_Sid, NULL, FALSE);
    Assert(err == 0);       // the index must always be there

    // Convert the Sid to Internal Representation
    memcpy(&InternalFormatSid,&(pDN->Sid),RtlLengthSid(&(pDN->Sid)));
    InPlaceSwapSid(&InternalFormatSid);

    // Make a Jet Key
    JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl,
             &InternalFormatSid,RtlLengthSid(&InternalFormatSid), JET_bitNewKey);

    // Seek on Equal to the SId, Set the Index range
    err = JetSeek(pDB->JetSessID, pDB->JetObjTbl, JET_bitSeekEQ|JET_bitSetIndexRange);
    if ( 0 == err )
    {
#ifndef JET_BIT_SET_INDEX_RANGE_SUPPORT_FIXED
        JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl,
                 &InternalFormatSid,RtlLengthSid(&InternalFormatSid), JET_bitNewKey);

        JetSetIndexRangeEx(pDB->JetSessID, pDB->JetObjTbl,
            (JET_bitRangeUpperLimit | JET_bitRangeInclusive ));
#endif
        //
        // Ok We found the object. Keep Moving Forward Until either the SID does not
        // Match or we reached the given object
        //

       do
       {
            ULONG ulNcDNT;

            err = JetRetrieveColumn(pDB->JetSessID, pDB->JetObjTbl,ncdntid,
                &ulNcDNT, sizeof(ulNcDNT), &cbActual, 0 , NULL);

            if (0==err)
            {
                // We read the NC DNT of the object

                if (ulNcDNT==ulGivenNc)
                    break;
            }
            else if (JET_wrnColumnNull==err)
            {
                // It is Ok to find an object with No Value for NC DNT
                // this occurs on Phantoms. Try next object

                err = 0;
            }
            else
            {
                break;
            }

            err = JetMove(
                    pDB->JetSessID,
                    pDB->JetObjTbl,
                    JET_MoveNext,
                    0);


        }  while (0==err);

        if (0==err)
        {
            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, dntid,
                             &ulDNT, sizeof(ulDNT), &cbActual, 0, NULL);


            #if DBG

            // On Checked Builds verify that the Sid is unique within the NC

            err = JetMove(
                    pDB->JetSessID,
                    pDB->JetObjTbl,
                    JET_MoveNext,
                    0);

            if (0==err)
            {
                ULONG ulNcDNT2=0;

                 err = JetRetrieveColumn(pDB->JetSessID, pDB->JetObjTbl,ncdntid,
                            &ulNcDNT2, sizeof(ulNcDNT2), &cbActual, 0 , NULL);

                 if ((0==err) && (ulNcDNT2==ulGivenNc))
                 {
                     // This is a case of a duplicate Sid . Assert this
                     Assert(FALSE && "Duplicate Sid Found By dbFindObjectWithSidinNc");
                 }
            }

            // Reset error back to 0
            err = 0;

            // Don't worry that we lost currency. DBFindDNT will restore it.
            #endif

            // Establish currency on the object found.
            DBFindDNT(pDB, ulDNT);

            // check if the record found is an object

            // DO NOT REMOVE FOLLOWING CHECK OR CHANGE ERROR CODE AS OTHER
            // OTHER ROUTINES DEPEND ON THIS BEHAVIOUR.

            if (!DBCheckObj(pDB))
            {
                DPRINT1(1, "dbFindObjectWithSidInNC: success on DNT=%ld of non object \n",
                        (pDB)->DNT);
                err = DIRERR_NOT_AN_OBJECT;
            }
        }
        else
        {
            err = DIRERR_OBJ_NOT_FOUND;
        }
    }
    else
    {
        err = DIRERR_OBJ_NOT_FOUND;
    }

    return err;
}



VOID
DBGetAdministratorAndAdministratorsDNT()
{
   ULONG AdministratorsSid[] = {0x201,0x05000000,0x20,0x220};
   DSNAME Administrator;
   DSNAME Administrators;
   ULONG  RidAuthority=0;
   DBPOS  *pDB=NULL;
   ULONG  err=0;


   AdminDNTsAreValid = FALSE;

   __try
   {
      //
      // Compose the DSNames
      //

      RtlZeroMemory(&Administrator,sizeof(DSNAME));
      RtlZeroMemory(&Administrators,sizeof(DSNAME));

      //
      // Compose the administrator user
      //

      //
      // This function is called so early on in the initialization
      // phase that we don't know if we are installing or not; only
      // do the search if the gAnchor has been setup correctly.
      // We will assert otherwise.
      //
      if ( RtlValidSid( &(gAnchor.pDomainDN->Sid) ) )
      {

      RtlCopyMemory(&Administrator.Sid,
                 &gAnchor.pDomainDN->Sid,
                 RtlLengthSid(&gAnchor.pDomainDN->Sid));

      RidAuthority= (*(RtlSubAuthorityCountSid(&Administrator.Sid)))++;
      *RtlSubAuthoritySid(&Administrator.Sid,RidAuthority) = DOMAIN_USER_RID_ADMIN;
      Administrator.structLen = DSNameSizeFromLen(0);
      Administrator.SidLen = RtlLengthSid(&Administrator.Sid);

      //
      // This function is called so early on in the initialization
      // phase that we don't know if we are installing or not; only
      // do the search if the gAnchor has been setup correctly.
      // We will assert otherwise.
      //
      if ( RtlValidSid( &(gAnchor.pDomainDN->Sid) ) )
      {

          RtlCopyMemory(&Administrator.Sid,
                     &gAnchor.pDomainDN->Sid,
                     RtlLengthSid(&gAnchor.pDomainDN->Sid));

          RidAuthority= (*(RtlSubAuthorityCountSid(&Administrator.Sid)))++;
          *RtlSubAuthoritySid(&Administrator.Sid,RidAuthority) = DOMAIN_USER_RID_ADMIN;
          Administrator.structLen = DSNameSizeFromLen(0);
          Administrator.SidLen = RtlLengthSid(&Administrator.Sid);

          //
          // Compose DSNAME for Administrators Alias
          //

          RtlCopyMemory(&Administrators.Sid,
                        AdministratorsSid,
                        RtlLengthSid((PSID)AdministratorsSid)
                        );

          Administrators.structLen = DSNameSizeFromLen(0);
          Administrators.SidLen = RtlLengthSid(&Administrators.Sid);

          __try
              {

             DBOpen(&pDB);
             err = dbFindObjectWithSidInNc(
                      pDB,
                      &Administrator,
                      gAnchor.ulDNTDomain
                      );


             if (0==err)
             {
                ulDNTAdministrator = pDB->DNT;

                err = dbFindObjectWithSidInNc(
                          pDB,
                          &Administrators,
                          gAnchor.ulDNTDomain
                          );

                if (0==err)
                {
                   ulDNTAdministrators = pDB->DNT;
                   AdminDNTsAreValid = TRUE;
                }
             }

          }
          __finally
          {
             DBClose(pDB,TRUE);
          }
      }
   }
   }
   __except (EXCEPTION_EXECUTE_HANDLER)
   {

       AdminDNTsAreValid = FALSE;
   }

}
#endif

DWORD
dbSetValueIfUniqueSlowVersion (
        DBPOS *pDB,
        ATTCACHE *pAC,
        PUCHAR pVal,
        DWORD  valLen)
/*++
  Description:

    Read all the values on the current object and compare against the incoming
    value.  If the new value is unique, add it.  Otherwise, return an error.

    NOTE: only works for non link table attributes.  Don't call otherwise.

--*/
{
    JET_SETINFO  setinfo;
    JET_RETINFO  retinfo;
    BOOL         fDone = FALSE;
    DWORD        CurrAttrOccur = 1;
    PUCHAR       pTempVal=NULL;
    DWORD        cbTempVal=0;
    DWORD        actuallen;
    DWORD        err;

    Assert(!pAC->ulLinkID);

    // Start by allocating a buffer as big as the one we are comparing.
    pTempVal = THAllocEx(pDB->pTHS, valLen);
    cbTempVal = valLen;

    while(!fDone) {
        // Read the next value.
        retinfo.cbStruct = sizeof(retinfo);
        retinfo.itagSequence = CurrAttrOccur;
        retinfo.ibLongValue = 0;
        retinfo.columnidNextTagged = 0;

        err = JetRetrieveColumnWarnings(
                pDB->JetSessID,
                pDB->JetObjTbl,
                pAC->jColid,
                pTempVal,
                cbTempVal,
                &actuallen,
                pDB->JetRetrieveBits,
                &retinfo);

        switch(err) {
        case 0:
            // Got the value.  Compare.
            if (gDBSyntax[pAC->syntax].Eval(
                    pDB,
                    FI_CHOICE_EQUALITY,
                    valLen,
                    pVal,
                    actuallen,
                    pTempVal)) {
                // Duplicate value.
                return DB_ERR_VALUE_EXISTS;
            }
            CurrAttrOccur++;
            break;

        case JET_wrnBufferTruncated:
            // The buffer was not big enough.  Resize, then redo the
            // JetRetrieveColumnWarnings (i.e. end the loop but don't advance
            // CurrAttrOccur.
            pTempVal = THReAllocEx(pDB->pTHS, pTempVal, actuallen);
            cbTempVal = actuallen;
            break;

        case JET_wrnColumnNull:
            // no more values.
            fDone = TRUE;
            break;

        default:
            // Huh?
            THFreeEx(pDB->pTHS, pTempVal);
            DsaExcept(DSA_DB_EXCEPTION, err, pAC->id);
            break;
        }
    }

    THFreeEx(pDB->pTHS, pTempVal);

    // OK, we got here, so it must not be duplicate.  Add it in.
    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = 0;
    setinfo.itagSequence = 0;
    JetSetColumnEx(pDB->JetSessID,
                   pDB->JetObjTbl,
                   pAC->jColid,
                   pVal,
                   valLen,
                   0,
                   &setinfo);

    return 0;

}

DWORD
DBFindBestProxy(
    DBPOS   *pDB,
    BOOL    *pfFound,
    DWORD   *pdwEpoch
    )
/*++

  Description:

    Iterates over all proxy objects whose ATT_PROXIED_OBJECT_NAME references
    the current object and returns the highest valued epoch from that set.
    See also PreProcessProxyInfo() in drancrep.c.

  Arguments:

    pDB - Active DBPOS.

    pfFound - OUT which indicates if any matching proxy objects were found.

    pdwEpoch - OUT which holds highest matching epoch number if any matching
        proxy objects were found.

  Return Values:

    0 on success, !0 otherwise.

--*/
{
    DWORD                           dwErr;
    JET_RETINFO                     retInfo;
    ATTCACHE                        *pAC;
    UCHAR                           buff[PROXY_SIZE_INTERNAL];
    INTERNAL_SYNTAX_DISTNAME_STRING *pVal = NULL;
    ULONG                           len;
    BOOL                            fContinue = TRUE;

    Assert(VALID_DBPOS(pDB));
    Assert(VALID_THSTATE(pDB->pTHS));

    *pfFound = FALSE;
    *pdwEpoch = 0;

    if ( !(pAC = SCGetAttById(pDB->pTHS, ATT_PROXIED_OBJECT_NAME)) )
    {
        return(DIRERR_ATT_NOT_DEF_IN_SCHEMA);
    }

    if ( dwErr = JetSetCurrentIndex2(pDB->JetSessID,
                                     pDB->JetSearchTbl,
                                     SZPROXIEDINDEX,
                                     0) )
    {
        return(dwErr);
    }

    // Internal representation for DISTNAME_BINARY (syntax of
    // ATT_PROXIED_OBJECT_NAME) is INTERNAL_SYNTAX_DISTNAME_STRING
    // whose first DWORD is the DNT of the proxied object, followed
    // by the BOB structlen, followed by the proxy type, followed
    // by the epoch number.  (see xdommove.h).  So we can find all
    // matching proxy objects for the current object with a key whose
    // prefix is: { DNT, proxyLen, PROXY_TYPE_PROXY }.

    len = sizeof(buff);
    MakeProxyKeyInternal(pDB->DNT, PROXY_TYPE_PROXY, &len, buff);
    JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl,
                 buff, len, JET_bitNewKey);

    dwErr = JetSeekEx(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekGE);

    switch ( dwErr )
    {
    case JET_wrnSeekNotEqual:   break;
    case JET_errRecordNotFound: return(0);
    default:                    return(dwErr);
    }

    while ( fContinue )
    {
        pVal = (INTERNAL_SYNTAX_DISTNAME_STRING *) buff;

        retInfo.cbStruct = sizeof(retInfo);
        retInfo.ibLongValue = 0;
        retInfo.itagSequence = 1;
        retInfo.columnidNextTagged = 0;

        if ( dwErr = JetRetrieveColumnWarnings(
                                    pDB->JetSessID,
                                    pDB->JetSearchTbl,
                                    pAC->jColid,
                                    (UCHAR *) pVal,
                                    sizeof(buff),
                                    &len,
                                    JET_bitRetrieveFromIndex,
                                    &retInfo) )
        {
            if ( JET_wrnBufferTruncated != dwErr )
            {
                return(dwErr);
            }

            // ATT_PROXIED_OBJECT_NAME value is only 4 DWORDs in internal
            // format and static buffer we used above was big enough, so if
            // we get here it means we have a malformed value.  However,
            // go ahead and read it so we can dump it in the debugger and
            // understand what it is and how it got here.
            Assert(!"Malformed ATT_PROXIED_OBJECT_NAME key");


            pVal = (INTERNAL_SYNTAX_DISTNAME_STRING *)
                                            THAllocEx(pDB->pTHS, len);

            retInfo.cbStruct = sizeof(retInfo);
            retInfo.ibLongValue = 0;
            retInfo.itagSequence = 1;
            retInfo.columnidNextTagged = 0;

            if ( dwErr = JetRetrieveColumnWarnings(
                                    pDB->JetSessID,
                                    pDB->JetSearchTbl,
                                    pAC->jColid,
                                    (UCHAR *) pVal,
                                    len,
                                    &len,
                                    JET_bitRetrieveFromIndex,
                                    &retInfo) )
            {
                THFreeEx(pDB->pTHS, pVal);
                return(dwErr);
            }
        }

        if (    (pVal->tag != pDB->DNT)
             || (PROXY_SIZE_INTERNAL != len)
             || (PROXY_BLOB_SIZE != pVal->data.structLen)
             || (PROXY_TYPE_PROXY != GetProxyTypeInternal(len, pVal)) )
        {
            // We've moved past the object of interest or its a malformed
            // ATT_PROXIED_OBJECT_NAME value.  There could theoretically
            // be additional ATT_PROXIED_OBJECT_NAME values for this DNT
            // which aren't malformed, but the malformed test is just to
            // gracefully handle values which pre-existed before we
            // got rid of the bogus DWORD on the end of the value.
            fContinue = FALSE;
        }
        else
        {
            *pfFound = TRUE;

            // Save epoch number if better/greater then current.

            if ( GetProxyEpochInternal(len, pVal) > *pdwEpoch )
            {
                *pdwEpoch = GetProxyEpochInternal(len, pVal);
            }

            // Advance to next item in index.

            dwErr = JetMoveEx(pDB->JetSessID, pDB->JetSearchTbl,
                              JET_MoveNext, 0);

            switch ( dwErr )
            {
            case JET_errSuccess:

                break;

            case JET_wrnRecordFoundGreater:
            case JET_errNoCurrentRecord:

                dwErr = 0;
                // fall through ...

            default:

                fContinue = FALSE;
                break;
            }
        }

        if ( pVal && (buff != (UCHAR *) pVal) )
        {
            THFreeEx(pDB->pTHS, pVal);
            pVal = NULL;
        }
    }

    return(dwErr);
}


DWORD
DBGetValueCount_AC(
    DBPOS *pDB,
    ATTCACHE *pAC
    )

/*++

Routine Description:

    Return the number of values which an attribute has.

    This code adapted from dbGetMultipleColumns

Arguments:

    pDB - Valid DB position
    Att - Attribute id to be queried for number of values

Return Value:

    DWORD - Number of values

--*/

{
    JET_RETRIEVECOLUMN  inputCol;
    DWORD err;

    Assert(VALID_DBPOS(pDB));
    Assert( pAC );

    // query Jet for the count of columns in this record

    memset(&inputCol, 0, sizeof(inputCol));
    inputCol.columnid = pAC->jColid;
    // Read from copy buffer if in prepared update, otherwise from db
    inputCol.grbit = pDB->JetRetrieveBits;

    // Use the non-excepting version so we can handle Column Not Found
    err = JetRetrieveColumns(
        pDB->JetSessID,
        pDB->JetObjTbl,
        &inputCol,
        1);
    switch (err) {
    case JET_errSuccess:
        break;
    case JET_errColumnNotFound:
        inputCol.itagSequence = 0;
        break;
    default:
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
        break;
    }

    return inputCol.itagSequence;
} /* DBGetValueCount */

void
DBGetObjectTableDataUsn (
    PDBPOS           pDB,
    DWORD           *pulNcDnt OPTIONAL,
    USN             *pusnChanged OPTIONAL,
    DWORD           *pulDnt OPTIONAL
    )

/*++

Routine Description:

    Return the fields from the object table dra usn index.

    You must be positioned on SZDRAUSNINDEX in order for this to work.

Arguments:

    pDB -
    pulNcDnt -
    pusnChanged -

Return Value:

    None

--*/

{
    JET_RETRIEVECOLUMN attList[3];
    DWORD              grbit, cAtt = 0;

    // Always retrieve from index
    grbit = pDB->JetRetrieveBits | JET_bitRetrieveFromIndex;

    memset(attList,0,sizeof(attList));
    // First, try to retrieve everything from the index.

    if (pulNcDnt) {
        attList[cAtt].pvData = pulNcDnt;
        attList[cAtt].columnid = ncdntid;
        attList[cAtt].cbData = sizeof(DWORD);
        attList[cAtt].grbit = grbit;
        attList[cAtt].itagSequence = 1;
        cAtt++;
    }

    if (pusnChanged) {
        attList[cAtt].pvData = pusnChanged;
        attList[cAtt].columnid = usnchangedid;
        attList[cAtt].cbData = sizeof(USN);
        attList[cAtt].grbit = grbit;
        attList[cAtt].itagSequence = 1;
        cAtt++;
    }

    if (pulDnt) {
        attList[cAtt].pvData = pulDnt;
        attList[cAtt].columnid = dntid;
        attList[cAtt].cbData = sizeof(DWORD);
        attList[cAtt].grbit = grbit;
        attList[cAtt].itagSequence = 1;
        cAtt++;
    }

    JetRetrieveColumnsSuccess(pDB->JetSessID,
                              pDB->JetObjTbl,
                              attList,
                              cAtt);
    return;
} /* DBGetLinkTableDataUsn  */


void DBFreeSearhRes (THSTATE *pTHS, SEARCHRES *pSearchRes, BOOL fFreeOriginal)
{
    DWORD        i,j,k;
    ENTINFLIST  *pEntList=NULL, *pTemp;
    ATTR        *pAttr=NULL;
    ATTRVAL     *pAVal=NULL;
    
    if(!pSearchRes) {
        return;
    }

    // We don't actually free most of the search result.
    pEntList = &pSearchRes->FirstEntInf;
    
    for(i=0;i < pSearchRes->count; i++) {
        // Free the values in the EntInf.
        THFreeEx(pTHS, pEntList->Entinf.pName);
        
        pAttr = pEntList->Entinf.AttrBlock.pAttr;
        for(j=0;j<pEntList->Entinf.AttrBlock.attrCount;j++) {
            pAVal = pAttr->AttrVal.pAVal;
            for(k=0;k<pAttr->AttrVal.valCount;k++) {
                THFreeEx(pTHS, pAVal->pVal);
                pAVal++;
            }
            THFreeEx(pTHS, pAttr->AttrVal.pAVal);
            pAttr++;
        }
        THFreeEx (pTHS, pEntList->Entinf.AttrBlock.pAttr);
        
        // hold a back pointer
        pTemp = pEntList;
        
        // step forward
        pEntList = pEntList->pNextEntInf;
        
        // free the back pointer.
        if(i) {
            // But, dont free the first one.
            THFreeEx(pTHS, pTemp);
        }
    }
    
    if (fFreeOriginal) {
        THFreeEx(pTHS, pSearchRes);
    }
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dbprop.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dbprop.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module implements the dblayer routines to manage the security
    descriptor propagation queue table.

Author:

    Tim Williams     [TimWi]    2-Dec-1996

Revision History:

--*/
#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <dsatools.h>                   // For pTHS

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>

// Assorted DSA headers
#include "dsevent.h"
#include "ntdsctr.h"
#include "objids.h"        /* needed for ATT_MEMBER and ATT_IS_MEMBER_OFDL */
#include <dsexcept.h>
#include <filtypes.h>      /* Def of FI_CHOICE_???                  */
#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DBOBJ:" /* define the subsystem for debugging */

// DBLayer includes
#include "dbintrnl.h"

#include <anchor.h>

#include <fileno.h>
#define  FILENO FILENO_DBPROP

/*++
Routine Description:

    Adds a row to the propagation queue table identifying a pending propagation
    starting at the current object in the data table.

Parameters:

    pDB - the active database handle

Return Codes:

    returns 0 if all went well, a non-zero error code otherwise.

--*/
DWORD
DBEnqueueSDPropagationEx(
        DBPOS * pDB,
        BOOL bTrimmable,
        DWORD dwFlags
        )
{
    THSTATE *pTHS=pDB->pTHS;
    JET_TABLEID table;
    JET_ERR     err=0;
    DWORD       index, cbActual;
    JET_SETCOLUMN attList[4];
    DWORD cAtts;
    BYTE bTrim;

    Assert(VALID_DBPOS(pDB));

    //
    //
    if (pDB->DNT == gAnchor.ulDNTDomain) {
        // The domain's SD is cached in gAnchor, so schedule a rebuild
        pTHS->fAnchorInvalidated = TRUE;
    }

    Assert(pDB->JetSDPropTbl);
    table = pDB->JetSDPropTbl;

    // Prepare the insert, which will automatically give us the index column
    err = JetPrepareUpdate(pDB->JetSessID,table,JET_prepInsert);
    if(err != DB_success) {
        return err;
    }

    memset(attList, 0, sizeof(attList));
    attList[0].columnid = begindntid;
    attList[0].pvData = &pDB->DNT;
    attList[0].cbData = sizeof(pDB->DNT);
    attList[0].itagSequence = 1;
    cAtts = 1;

    if (bTrimmable) {
        bTrim = 1;
        attList[cAtts].columnid = trimmableid;
        attList[cAtts].pvData = &bTrim;
        attList[cAtts].cbData = sizeof(bTrim);
        attList[cAtts].itagSequence = 1;
        cAtts++;
    }

    if (pTHS->dwClientID) {
        attList[cAtts].columnid = clientidid;
        attList[cAtts].pvData = &pTHS->dwClientID;
        attList[cAtts].cbData = sizeof(pTHS->dwClientID);
        attList[cAtts].itagSequence = 1;
        cAtts++;
    }

    if (dwFlags) {
        attList[cAtts].columnid = sdpropflagsid;
        attList[cAtts].pvData = &dwFlags;
        attList[cAtts].cbData = sizeof(dwFlags);
        attList[cAtts].itagSequence = 1;
        cAtts++;
    }

    err = JetSetColumnsEx(pDB->JetSessID, table, attList, cAtts);

    if(err != DB_success)   {
        JetPrepareUpdate(pDB->JetSessID,table,JET_prepCancel);
        return err;
    }

    // why do we retrieve the index??? It's not used anywhere!
    err = JetRetrieveColumn(pDB->JetSessID, table, orderid, &index,
                            sizeof(index), &cbActual, JET_bitRetrieveCopy,
                            NULL);


    err = JetUpdate(pDB->JetSessID,
                    table,
                    NULL,
                    0,
                    NULL);
    if(err != DB_success)  {
        JetPrepareUpdate(pDB->JetSessID,table,JET_prepCancel);
        return err;
    }

    pDB->SDEvents++;
    return 0;
}


/*++
Routine Description:

    Deletes a row to the propagation queue table identifying a pending
    propagation that has been completed.

Parameters:

    pDB - the active database handle
    index - the index number of the propagation.  If 0, the lowest event is
    removed.

Return Codes:

    returns 0 if all went well, a non-zero error code otherwise.

--*/
DWORD
DBPopSDPropagation (
        DBPOS * pDB,
        DWORD index
        )
{
    JET_TABLEID table;
    JET_ERR     err=0;

    Assert(VALID_DBPOS(pDB));
    Assert(pDB->pTHS->fSDP);

    Assert(pDB->JetSDPropTbl);

    table = pDB->JetSDPropTbl;

    if(err)
        return err;

    // Set to the order index.
    if(err = JetSetCurrentIndex2(pDB->JetSessID, table, SZORDERINDEX, 0))
        return err;


    // Find the appropriate index.

    if(err = JetMakeKey(pDB->JetSessID, table, &index, sizeof(index),
                        JET_bitNewKey))
        return err;

    // Find the appropriate object.
    if(err = JetSeek(pDB->JetSessID, table, JET_bitSeekEQ))
        return err;

    // Delete the row.
    if(err = JetDelete(pDB->JetSessID, table))
        return err;

    pDB->SDEvents--;
    return 0;
}

/*++
Routine Description:

    Returns an array of information describing the remaining propagation events
    in the queue.

Parameters:

    pDB - the active database handle
    dwClientID - the clientid that we should restrict to. 0 means they don't
            want the list restricted.
    pdwSize - the number of elements found that match the criteria.
    ppInfo - Returns a list of filled in propinfo structures.  If NULL, no
            values are returned.

Return Codes:

    returns 0 if all went well (as well as the requested data).  A non-zero
    error code otherwise.

--*/
DWORD
DBSDPropagationInfo (
        DBPOS * pDB,
        DWORD dwClientID,
        DWORD *pdwSize,
        SDPropInfo **ppInfo
        )
{
    // For now, we just run through the queue and return the count.
    THSTATE     *pTHS=pDB->pTHS;
    JET_TABLEID table;
    JET_ERR     err=0;
    DWORD       dwNumAllocated = 0;
    SDPropInfo  *pInfo=NULL;
    JET_RETRIEVECOLUMN attList[4];

    Assert(VALID_DBPOS(pDB));

    *pdwSize = 0;
    if(ppInfo) {
        *ppInfo = NULL;
    }

    Assert(pDB->JetSDPropTbl);
    table = pDB->JetSDPropTbl;

    if(dwClientID) {
        // They are looking specifically for propagations from a single client,
        // use the clientid index
        if(err = JetSetCurrentIndex2(pDB->JetSessID, table, SZCLIENTIDINDEX, 0))
            return err;

        // Now, seek to the right range
        if(err = JetMakeKey(pDB->JetSessID, table, &dwClientID,
                            sizeof(dwClientID), JET_bitNewKey))
            return err;

        // Find the appropriate object.
        err = JetSeek(pDB->JetSessID, table,
                      JET_bitSeekEQ | JET_bitSetIndexRange);
            if(err == JET_errRecordNotFound) {
                // Nothing in the list.
                return 0;
            }
            else {
#ifndef JET_BIT_SET_INDEX_RANGE_SUPPORT_FIXED
                if (!err) {
                    err = JetMakeKey(pDB->JetSessID, table, &dwClientID,
                            sizeof(dwClientID), JET_bitNewKey);

                    if (!err) {
                        err = JetSetIndexRange(pDB->JetSessID, table,
                            (JET_bitRangeUpperLimit | JET_bitRangeInclusive ));
                    }
                }
#endif

                return err;
            }
    }
    else {
        if(err = JetSetCurrentIndex2(pDB->JetSessID, table, SZORDERINDEX, 0))
            return err;

        // Seek to the beginning.
        err = JetMove(pDB->JetSessID, table, JET_MoveFirst, 0);

        if(err) {
            if(err == JET_errNoCurrentRecord) {
                // Nothing in the list.
                return 0;
            }
            else {
                return err;
            }
        }
    }

    // OK, we're on the first object
    if(ppInfo) {
        // Allocate some
        dwNumAllocated = 20;
        pInfo = (SDPropInfo *)THAllocEx(pTHS,
                                        dwNumAllocated * sizeof(SDPropInfo));
    }

    do {
        if(ppInfo) {
            if(*pdwSize == dwNumAllocated) {
                // Grow the list
                dwNumAllocated *= 2;
                pInfo = (SDPropInfo *)
                    THReAllocEx(pTHS, pInfo, dwNumAllocated * sizeof(SDPropInfo));
            }

            memset(attList, 0, sizeof(attList));
            attList[0].columnid = orderid;
            attList[0].pvData = &(pInfo[*pdwSize].index);
            attList[0].cbData = sizeof(pInfo[*pdwSize].index);
            attList[0].itagSequence = 1;
            attList[1].columnid = begindntid;
            attList[1].pvData = &(pInfo[*pdwSize].beginDNT);
            attList[1].cbData = sizeof(pInfo[*pdwSize].beginDNT);
            attList[1].itagSequence = 1;
            attList[2].columnid = clientidid;
            attList[2].pvData = &(pInfo[*pdwSize].clientID);
            attList[2].cbData = sizeof(pInfo[*pdwSize].clientID);
            attList[2].itagSequence = 1;
            attList[3].columnid = sdpropflagsid;
            attList[3].pvData = &(pInfo[*pdwSize].flags);
            attList[3].cbData = sizeof(pInfo[*pdwSize].flags);
            attList[3].itagSequence = 1;

            err = JetRetrieveColumnsWarnings(pDB->JetSessID, table, attList, 4);
            if (err == JET_wrnColumnNull) {
                if (attList[2].err == JET_wrnColumnNull) {
                    pInfo[*pdwSize].clientID = 0;
                }
                if (attList[3].err == JET_wrnColumnNull) {
                    pInfo[*pdwSize].flags = 0;
                }
                if (attList[0].err == JET_wrnColumnNull || attList[1].err == JET_wrnColumnNull) {
                    return err;
                }
                err = 0;
            }
            else if (err) {
                return err;
            }
        }
        (*pdwSize) += 1;
    } while((!eServiceShutdown) &&
            (JET_errSuccess == JetMove(pDB->JetSessID, table, JET_MoveNext,0)));

    if(eServiceShutdown) {
        return DIRERR_SHUTTING_DOWN;
    }

    if(ppInfo) {
        *ppInfo = (SDPropInfo *)THReAllocEx(
                pTHS,
                pInfo,
                *pdwSize * sizeof(SDPropInfo));
    }

    return 0;
}

/*++
Routine Description:

    Walk the array of objects in the SD table and set the clientid field to
    NULL, unless the client id is negative, in which case we leave it alone.

Parameters:

    pDB - the active database handle

Return Codes:

    returns 0 if all went well (as well as the requested data).  A non-zero
    error code otherwise.

--*/
DWORD
DBSDPropInitClientIDs (
        DBPOS * pDB
        )
{
    JET_TABLEID table;
    JET_ERR     err=0;
    DWORD       zero=0;
#if DBG
    DWORD       thisId;
    DWORD       cbActual;
#endif

    Assert(VALID_DBPOS(pDB));

    // only the SDPropagator can do this
    Assert(pDB->pTHS->fSDP);

    Assert(pDB->JetSDPropTbl);

    table = pDB->JetSDPropTbl;


    if(err = JetSetCurrentIndex2(pDB->JetSessID, table, SZCLIENTIDINDEX, 0))
        return err;


    // Seek to the first non-null that's greater than 0.  Note that the sd
    // propagator itself occasionally enqueues with a client id of (-1).  This
    // should skip all those.

    if(err = JetMakeKey(pDB->JetSessID, table, &zero, sizeof(zero),
                        JET_bitNewKey))
        return err;

    err = JetSeek(pDB->JetSessID, table, JET_bitSeekGE);
    if(err == JET_wrnSeekNotEqual)
        err = 0;

    while(!eServiceShutdown && !err) {
        // Ok, we're on the first object with a client id.

#if DBG
        thisId = 0;
        // Get the current clientid.
        err = JetRetrieveColumn(pDB->JetSessID, table,clientidid,
                                &thisId, sizeof(thisId),
                                &cbActual, 0,
                                NULL);
        Assert(!err);
        Assert(thisId != ((DWORD)(-1)));
#endif

        // Prepare the replace,
        err = JetPrepareUpdate(pDB->JetSessID,table,JET_prepReplace);
        if(err != DB_success) {
            return err;
        }


        // Set the clientID column to NULL
        err = JetSetColumn(pDB->JetSessID,
                           table,
                           clientidid,
                           NULL,
                           0,
                           0,
                           NULL);
        if(err != DB_success) {
            JetPrepareUpdate(pDB->JetSessID,table,JET_prepCancel);
            return err;
        }

        // Put it in the DB.
        err = JetUpdate(pDB->JetSessID,
                        table,
                        NULL,
                        0,
                        NULL);
        if(err != DB_success)  {
            JetPrepareUpdate(pDB->JetSessID,table,JET_prepCancel);
            return err;
        }

        // We commit lazily after update.

        JetCommitTransactionEx(pDB->JetSessID,
                               JET_bitCommitLazyFlush);
        JetBeginTransactionEx(pDB->JetSessID);

        // We are messing with the very column we are indexed over, so reseek
        err = JetMakeKey(pDB->JetSessID, table, &zero, sizeof(zero),
                         JET_bitNewKey);
        if(!err) {
            err = JetSeek(pDB->JetSessID, table, JET_bitSeekGE);
            if(err == JET_wrnSeekNotEqual)
                err = 0;
        }
    }

    if(eServiceShutdown) {
        return DIRERR_SHUTTING_DOWN;
    }

    if(err != JET_errRecordNotFound) {
        return err;
    }

    return 0;
}


/*++
Routine Description:

    Returns information describing a propagation event in the queue.

Parameters:

    pDB - the active database handle
    pInfo - A preallocated propinfo structure.


Return Codes:

    returns 0 if all went well (as well as the requested data).  A non-zero
    error code otherwise.

--*/
DWORD
DBGetNextPropEvent (
        DBPOS * pDB,
        SDPropInfo *pInfo
        )
{
    JET_TABLEID table;
    JET_ERR     err=0;
    DWORD       index;
    JET_RETRIEVECOLUMN attList[4];


    Assert(VALID_DBPOS(pDB));

    Assert(pDB->JetSDPropTbl);
    table = pDB->JetSDPropTbl;

    // Set to the order index.
    if(err = JetSetCurrentIndex2(pDB->JetSessID, table, SZORDERINDEX, 0))
        return err;


    // Seek to the beginning.
    err = JetMove(pDB->JetSessID, table, JET_MoveFirst, 0);

    if(err) {
        if(err == JET_errNoCurrentRecord) {
            return DB_ERR_NO_PROPAGATIONS;
        }
        else {
            return err;
        }
    }

    memset(attList, 0, sizeof(attList));
    attList[0].columnid = orderid;
    attList[0].pvData = &(pInfo->index);
    attList[0].cbData = sizeof(pInfo->index);
    attList[0].itagSequence = 1;
    attList[1].columnid = begindntid;
    attList[1].pvData = &(pInfo->beginDNT);
    attList[1].cbData = sizeof(pInfo->beginDNT);
    attList[1].itagSequence = 1;
    attList[2].columnid = clientidid;
    attList[2].pvData = &(pInfo->clientID);
    attList[2].cbData = sizeof(pInfo->clientID);
    attList[2].itagSequence = 1;
    attList[3].columnid = sdpropflagsid;
    attList[3].pvData = &(pInfo->flags);
    attList[3].cbData = sizeof(pInfo->flags);
    attList[3].itagSequence = 1;

    err = JetRetrieveColumnsWarnings(pDB->JetSessID, table, attList, 4);
    if (err == JET_wrnColumnNull) {
        if (attList[2].err == JET_wrnColumnNull) {
            pInfo->clientID = 0;
        }
        if (attList[3].err == JET_wrnColumnNull) {
            pInfo->flags = 0;
        }
        if (attList[0].err == JET_wrnColumnNull || attList[1].err == JET_wrnColumnNull) {
            return err;
        }
        err = 0;
    }
    else if (err) {
        return err;
    }

    return 0;
}

/*++
Routine Description:

    Returns the index of the last object in the propagation queue.

Parameters:

    pDB - the active database handle
    pInfo - A preallocated propinfo structure.


Return Codes:

    returns 0 if all went well (as well as the requested data).  A non-zero
    error code otherwise.

--*/
DWORD
DBGetLastPropIndex (
        DBPOS * pDB,
        DWORD * pIndex
        )
{
    JET_TABLEID table;
    JET_ERR     err=0;
    DWORD       cbActual;


    Assert(VALID_DBPOS(pDB));

    Assert(pDB->JetSDPropTbl);
    table = pDB->JetSDPropTbl;

    *pIndex = 0xFFFFFFFF;

    // Set to the order index.
    if(err = JetSetCurrentIndex2(pDB->JetSessID, table, SZORDERINDEX, 0))
        return err;


    // Seek to the End
    err = JetMove(pDB->JetSessID, table, JET_MoveLast, 0);

    if(err) {
        return err;
    }

    // Get the info.
    err = JetRetrieveColumn(pDB->JetSessID, table, orderid,
                            pIndex, sizeof(DWORD),
                            &cbActual, 0,
                            NULL);

    return err;
}

/*++
Routine Description:

    Removes all duplicate searches in the prop queue, regardless of the
    trimmable flag.  Expected to be called at start up to trim out duplicate
    events in our queue.  Since we are just starting, no client is waiting
    around for answers, we can consider everything trimmable.


Parameters:

    pDB - the active database handle

Return Codes:

    returns 0 if all went well.  A non-zero error code otherwise.

--*/
DWORD
DBThinPropQueue (
        DBPOS * pDB,
        DWORD DNT
        )
{
    JET_TABLEID table;
    JET_ERR     err=0;
    DWORD       cbActual;
    DWORD       ThisDNT;

    Assert(VALID_DBPOS(pDB));

    // only the SDPropagator can do this
    Assert(pDB->pTHS->fSDP);

    Assert(pDB->JetSDPropTbl);

    table = pDB->JetSDPropTbl;

    // Set to the order index.
    if(err = JetSetCurrentIndex2(pDB->JetSessID, table, SZTRIMINDEX, 0))
        return err;

    if(!DNT) {
        // We're trimming the whole list, so seek to the beginning.
        err = JetMove(pDB->JetSessID, table, JET_MoveFirst, 0);

        if (err == JET_errNoCurrentRecord) {
            // OK, no records to trim.  Bail
            return 0;
        }

    }
    else {
        BYTE Trim=1;
        // We only want to trim objects with the correct DNT and which are
        // marked as trimmable.  Seek and set an index range.

        if((err = JetMakeKey(pDB->JetSessID,
                             table,
                             &DNT,
                             sizeof(DNT),
                             JET_bitNewKey)) ||
           (err = JetMakeKey(pDB->JetSessID,
                             table,
                             &Trim,
                             sizeof(Trim),
                             0))) {
            return err;
        }

        // Find the appropriate object.
        err = JetSeek(pDB->JetSessID, table,
                      JET_bitSeekEQ | JET_bitSetIndexRange);

        if(err == JET_errRecordNotFound) {
            // OK, no records to trim.  Bail
            return 0;
        }
#ifndef JET_BIT_SET_INDEX_RANGE_SUPPORT_FIXED
        if (!err) {
            if((err = JetMakeKey(pDB->JetSessID,
                                 table,
                                 &DNT,
                                 sizeof(DNT),
                                 JET_bitNewKey)) ||
               (err = JetMakeKey(pDB->JetSessID,
                                 table,
                                 &Trim,
                                 sizeof(Trim),
                                 0)) ||
               (err = JetSetIndexRange(pDB->JetSessID, table,
                        (JET_bitRangeUpperLimit | JET_bitRangeInclusive)))) {
                return err;
            }
        }
#endif
    }

    if(err) {
        // Something 'orrible 'appened.
        return err;
    }
    if(err = JetRetrieveColumn(pDB->JetSessID, table, begindntid,
                               &(DNT), sizeof(DNT),
                               &cbActual, 0,
                               NULL))
        return err;

    while(!eServiceShutdown && !err) {
        // Step forward.
        err = JetMove(pDB->JetSessID, table, JET_MoveNext, 0);
        if(err == JET_errNoCurrentRecord) {
            // No more objects, return
            return 0;
        }
        else if(!err) {
            // Ok, we're still on an object.
            err = JetRetrieveColumn(pDB->JetSessID, table, begindntid,
                                    &(ThisDNT), sizeof(ThisDNT),
                                    &cbActual, 0,
                                    NULL);

            if(err)
                return err;

            if(DNT == ThisDNT) {
                // Commit from the last delete
                JetCommitTransactionEx(pDB->JetSessID,
                                       JET_bitCommitLazyFlush);
                JetBeginTransactionEx(pDB->JetSessID);


                // Duplicate event, kill it.
                if(err = JetDelete(pDB->JetSessID, table)) {
                    return err;
                }

                pDB->SDEvents--;
            }
            else {
                DNT = ThisDNT;
            }
        }
    }

    if(eServiceShutdown) {
        return DIRERR_SHUTTING_DOWN;
    }

    return err;
}



JET_RETRIEVECOLUMN dbAddSDPropTimeReadTemplate[] = {
        { 0, 0, sizeof(DSTIME), 0, 0, 0, 1, 0, 0},
        { 0, 0, sizeof(DSTIME), 0, 0, 0, 5, 0, 0},
        { 0, 0, sizeof(DSTIME), 0, 0, 0, 6, 0, 0}
    };

JET_SETCOLUMN dbAddSDPropTimeWriteTemplate[] = {
        { 0, NULL, sizeof(DSTIME), 0, 0, 1, 0},
        { 0, NULL, sizeof(DSTIME), 0, 0, 6, 0},
        { 0, NULL, 0, 0, 0, 2, 0}
    };

DWORD
DBAddSDPropTime (
        DBPOS *pDB,
        BYTE flags
        )
/*++
  Description:
      This routine is called by the SD propagator to write some time and flag
      information onto an object that the propagator is touching for some
      reason.  We are maintaining the attribute DS_CORE_PROPAGATION__DATA.

      This attribute will hold at most 5 values. (Remember, Jet values are 1
      indexed).  Value 1 holds flags.  Values 2 through 5 hold times.  The flags
      in value 1 apply to the times in values 2 through 5.  To get the flags
      associated with value 2, mask value 1 with 0xFF.  To get the flags
      associated with value 3, mask vlaue 1 with 0xFF00, etc.

      The flags are BYTES, and we hold 4 of them.  That accounts for 32 bits of
      the 64 bit value held in value 1.  We don't use the top 32 bits (and must
      never use the top 24 bits, since that make the conversion of this value to
      a time string choke).

      The attribute in question is time valued.  So, when reading this attribute
      from an outside call, you get 4 normal looking times and 1 very odd time
      (the flags value).  Parsing the odd looking time back into bits is left as
      an exercise for the student.

      Note that we keep these ordered.  If 4 time values are already being held,
      we delete value 2 and add value 6.  Jet then collapses the values back to
      being indexed 2 through 5 after we commit changes to this object.

      Note that if the attribute is currently empty, this writes the flags and 1
      time value.  If the attribute has fewer than 4 time values, we touch up
      the flags and add a new time value.  We only delete time values if we are
      already holding 4.

      NOTE: Given that everything this routine does is for debugging and
      tracking purposes, it must not raise exceptions of any sort on
      failure, but just return an error code that the caller can ignore.

   Parameters:
      pDB - DBPOS to use
      flags - flags to associate with this time.
--*/
{
    DWORD  err, i;
    DSTIME timeNow = DBTime();
    DSTIME data;
    DSTIME localFlags;
    JET_RETRIEVECOLUMN jCol[3];
    JET_SETCOLUMN jColIn[3];
    DSTIME dummy;

    Assert(pDB->pTHS->fSDP);

    // Set up the parameters to the JetRetrieveColumns and JetWriteColumns
    // calls. All the static portions are defined in the data structures
    // dbAddSDPropTimeWriteTemplate and dbAddSDPropTimeReadTemplate.  DBINIT.C
    // has already written the jet columnids into these constant structures.
    // All we have to do is copy the constant structures and get local pointers
    // to data.
    memcpy(jColIn, dbAddSDPropTimeWriteTemplate,
           sizeof(dbAddSDPropTimeWriteTemplate));

    memcpy(jCol, dbAddSDPropTimeReadTemplate,
           sizeof(dbAddSDPropTimeReadTemplate));


    // First thing to write back is the flags.  Writes to index 1.
    jColIn[0].pvData = &localFlags;
    // Second thing to write back is the time now.  Writes to index 6.
    jColIn[1].pvData = &timeNow;
    // Final thing we might write is a null to erase index 2.
    jColIn[2].pvData = NULL;


    // First thing we read is the flags already on the attribute (index 1)
    jCol[0].pvData = &localFlags;
    // Second thing we read is the 4th time value (index 5).  We read this to
    // find out whether we need to delete a time value or not.
    jCol[1].pvData = &data;
#if DBG
    // Only bother trying to read this value in the debug case, we only use it
    // in an assert.  The assert is that we have no value at index 6 (i.e. the
    // most we have is 1 flags value and 4 time values.
    jCol[2].pvData = &dummy;

    err = JetRetrieveColumns(pDB->JetSessID, pDB->JetObjTbl, jCol, 3);
#else
    err = JetRetrieveColumns(pDB->JetSessID, pDB->JetObjTbl, jCol, 2);
#endif

    if(err) {
        // Something went wrong.  This is not critical, just return.
        return err;
    }

    switch(jCol[0].err) {
    case 0:
        localFlags = ((localFlags << 8) | flags);
        break;

    case JET_wrnColumnNull:
        // No flags value yet.  This is the first time the SDProp has touched
        // this object.
        localFlags = flags;
        // If we have no flags, we better have no times either.
        Assert(jCol[1].err == JET_wrnColumnNull);
        break;

    default:
        // Something went wrong.  This is not critical, just return.
        return jCol[0].err;
        break;
    }

    // We only track flags in the low 32 bits (4 8 bit flags).  So, the hi part
    // is 0.
    localFlags &= 0xFFFFFFFF;

    // And, we never have 6 values, right?
    Assert(jCol[2].err == JET_wrnColumnNull);

    if(!jCol[1].err) {
        // There are 4 times already, we don't hold more than 4.  So, we need to
        // delete the oldest time.  It's at index 2.  Use all three entries in
        // the jColIn structer, the third entry is the delete of index 2.
        i = 3;
    }
    else {
        // Just need to update the flags and tack a date onto the end.
        i = 2;
    }


    // Now, write back the new data
    err = JetSetColumns(pDB->JetSessID,
                        pDB->JetObjTbl,
                        jColIn,
                        i);
    return err;

}

DWORD
DBPropExists (
        DBPOS * pDB,
        DWORD DNT
        )
{
    JET_TABLEID table;
    JET_ERR     err=0;
    DWORD       cbActual;
    DWORD       ThisDNT;

    Assert(VALID_DBPOS(pDB));

    // only the SDPropagator can do this
    table = pDB->JetSDPropTbl;

    if(err = JetSetCurrentIndex2(pDB->JetSessID,
                                 table,
                                 SZTRIMINDEX,
                                 0)) {
        return err;
    }

    if(err = JetMakeKey(pDB->JetSessID,
                        table,
                        &DNT,
                        sizeof(DNT),
                        JET_bitNewKey)) {
        return err;
    }

    // Find the appropriate object.
    err = JetSeek(pDB->JetSessID, table, JET_bitSeekGE);

    if(err && err != JET_wrnSeekNotEqual) {
        return err;
    }

    if(err = JetRetrieveColumn(pDB->JetSessID,
                               table,
                               begindntid,
                               &(ThisDNT),
                               sizeof(ThisDNT),
                               &cbActual, 0,
                               NULL))
        return err;

    if(ThisDNT != DNT) {
        return 1;
    }

    return 0;
}


DWORD
DBPropagationsExist (
        DBPOS * pDB
        )
{
    JET_TABLEID table;
    JET_ERR     err=0;

    Assert(VALID_DBPOS(pDB));

    // only the SDPropagator can do this
    table = pDB->JetSDPropTbl;
    if(err = JetSetCurrentIndex2(pDB->JetSessID,
                                 table,
                                 SZTRIMINDEX,
                                 0)) {
        return err;
    }

    err = JetMove (pDB->JetSessID, table, JET_MoveFirst, 0);

    // if the table is empty, then there are no pending propagations
    if (err == JET_errNoCurrentRecord) {
        return FALSE;
    }

    return TRUE;
}


DWORD
dbGrowChildrenDNTList (
        DWORD **ppDNTs,
        DWORD *pBeginIndex,
        DWORD *pEndIndex,
        DWORD *pArraySize
        )
/*++
Routine Description:
    Helper routine for DBGetChildrenDNTs.  Grows the DNTlist, called when the
    list needs to hold more DNTs than it has space for.
    An example of what this code does is:
    List = (4, 5, 1, 2, 3)
    becomes
    List = (1, 2, 3, 4, 5, _, _, _, _, _)

    Indices are adjusted appropriately.


Arguments:
    None.

Return Values:
    0 if all went well, error code otherwise.
--*/
{
    DWORD *LocalNewArray;
    DWORD NewListSize = *pArraySize * 2;

    // First, grow the allocation.
    LocalNewArray = THAlloc(NewListSize * sizeof(DWORD));
    if(!LocalNewArray) {
        MemoryPanic(NewListSize * sizeof(DWORD));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Now, move the elements into the new list.
    // first, move the tail of the original list to the beginning of the newly
    // allocated array.
    memcpy(LocalNewArray,
           &((*ppDNTs)[*pEndIndex]),
           ((*pArraySize - *pEndIndex) * sizeof(DWORD)));

    if(*pBeginIndex) {
        // Now, tack the head of the list on.
        memcpy(&LocalNewArray[*pArraySize - *pEndIndex],
               *ppDNTs,
               (*pBeginIndex * sizeof(DWORD)));
    }

    // Done with the original list
    THFree(*ppDNTs);

    // Set up the new indices for the queue
    *pEndIndex = 0;
    *pBeginIndex = *pArraySize;


    // Set up the new queue
    *ppDNTs = LocalNewArray;
    *pArraySize = NewListSize;

    return 0;
}

DWORD
DBGetChildrenDNTs(
        DBPOS *pDB,
        DWORD ParentDNT,
        DWORD **ppDNTs,
        DWORD *pBeginDNTIndex,
        DWORD *pEndDNTIndex,
        DWORD *pArraySize
        )
/*++
Routine Description:
    Identifies all the children of a given parent, adding them to the array
    passed in, reallocing the array as necessary.  This is a special purpose
    routine for the SD propagator.  The SD propagator used to do this for
    itself, managing the list and using DBMove, etc.  That is very inefficient,
    this way we get to do a lot of bare JET work and get everything we need from
    the secondary index without ever having to actually visit the data pages.

    Indices are adjusted appropriately.

Arguments:
    ParentDNT - DNT of the parent object.

Return Values:
    0 if all went well, error code otherwise.
--*/
{
    DWORD        err;
    INDEX_VALUE  IV[1];
    DWORD       *pDNTs = *ppDNTs;
    DWORD        beginIndex = *pBeginDNTIndex;
    DWORD        endIndex = *pEndDNTIndex;
    DWORD        arraySize = *pArraySize;
    DWORD        ThisDNT;
    DWORD        cb;

    Assert(pDB->pTHS->fSDP);

    IV[0].pvData = &ParentDNT;
    IV[0].cbData = sizeof(ParentDNT);

    // Set to the PDNT index
    JetSetCurrentIndexSuccess(pDB->JetSessID, pDB->JetObjTbl, SZPDNTINDEX);

    // Now, set an index range in the PDNT index to get all the children.
    // Use GE because this is a compound index.
    err = DBSeek(pDB, IV, 1, DB_SeekGE);
    if(err && err != JET_wrnSeekNotEqual) {
        // Couldn't find anything.  So, no objects are children.
        return 0;
    }
    // Get the PDNT of the object we are on, since we may already be beyond the
    // range we care about.
    JetRetrieveColumnSuccess(pDB->JetSessID,
                             pDB->JetObjTbl,
                             pdntid,
                             &ThisDNT,
                             sizeof(ThisDNT),
                             &cb,
                             JET_bitRetrieveFromIndex,
                             NULL);
    if(ThisDNT != ParentDNT) {
        // No objects are children
        return 0;
    }

    err = DBSetIndexRange(pDB, IV, 1);
    if(err) {
        // Huh?
        return err;
    }

    do {
        // inc perfcounter (counting "activity" by the sd propagator)
        INC(pcSDPropRuntimeQueue);
        PERFINC(pcSDProps);


        // Get the DNT of the current object.  Note that we use the grbit saying
        // that we want the data (which is the primary key) retrieved from the
        // secondary index.  This should let us satisfy this call with only the
        // pages already accessed by JET, and not force us to visit the primary
        // index or the actual data page.
        JetRetrieveColumnSuccess(pDB->JetSessID,
                                 pDB->JetObjTbl,
                                 dntid,
                                 &ThisDNT,
                                 sizeof(ThisDNT),
                                 &cb,
                                 JET_bitRetrieveFromPrimaryBookmark,
                                 NULL);

        // Note that we keep beginINdex valid by checking it after we
        // increment it.
        pDNTs[beginIndex] = ThisDNT;

        // The list is a circular queue held in an array.
        beginIndex = (beginIndex + 1) % arraySize;
        if(beginIndex == endIndex) {
            // Grow the list
            if(err = dbGrowChildrenDNTList (&pDNTs,
                                            &beginIndex,
                                            &endIndex,
                                            &arraySize)) {
                return err;
            }
        }
    } while(!eServiceShutdown && ! JetMove(pDB->JetSessID,
                                           pDB->JetObjTbl,
                                           JET_MoveNext,
                                            0));

    if(eServiceShutdown) {
        return DIRERR_SHUTTING_DOWN;
    }

    // Go home
    *ppDNTs = pDNTs;
    *pBeginDNTIndex= beginIndex;
    *pEndDNTIndex = endIndex;
    *pArraySize = arraySize;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dra\addsid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       addsid.c
//
//--------------------------------------------------------------------------
/*++

Module Name:

    addsid.c

Abstract:

    This module implements IDL_DRSAddSidHistory.
    This module implements IDL_DRSInheritSecurityIdentity.

Author:

    Dave Straube    (DaveStr)   03/09/99

Revision History:

    Dave Straube    (DaveStr)   05/11/99
        Added IDL_DRSInheritSecurityIdentity.

--*/

#include <NTDSpch.h>
#pragma hdrstop

// Core headers.
#include <winldap.h>
#include <samrpc.h>
#include <ntlsa.h>
#include <samsrvp.h>
#include <samisrv.h>
#include <samicli2.h>
#include <lsarpc.h>
#include <lsaisrv.h>
#include <lmaccess.h>                   // UF_*
#include <lmerr.h>                      // NERR_*
#include <msaudite.h>                   // SE_AUDITID_*
#include <lmcons.h>                     // MAPI constants req'd for lmapibuf.h
#include <lmapibuf.h>                   // NetApiBufferFree()
#include <nlwrap.h>                     // (ds)DsrGetDcNameEx2()
#include <ntdsa.h>                      // Core data types
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <mdlocal.h>                    // SPN
#include <debug.h>                      // Assert()
#include <dsatools.h>                   // Memory, etc.
#include <winsock2.h>                   // gethostbyname, etc.
#include <drs.h>                        // prototypes and CONTEXT_HANDLE_TYPE_*
#include <drautil.h>                    // DRS_CLIENT_CONTEXT
#include <anchor.h>
#include <attids.h>
#include <filtypes.h>
#include <cracknam.h>
#include <mappings.h>
#include "drarpc.h"

// Logging headers.
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <dsevent.h>                    // Only needed for LogUnhandledError
#include <dstrace.h>

// Assorted DSA headers.
#include <dsexcept.h>

#define DEBSUB "DRASERV:"               // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_ADDSID

extern DWORD DsaExceptionToWin32(DWORD xCode);
extern VOID  SampBuildNT4FullSid(NT4SID *DomSid, ULONG Rid, NT4SID *NewSid);
extern VOID  SampSplitNT4SID(NT4SID *pObjSid, NT4SID *pDomSid, ULONG *pRid);
extern DWORD mapApiErrorToWin32(THSTATE *pTHS, DWORD ApiError);
extern ULONG IDL_DRSInheritSecurityIdentity(DRS_HANDLE hDrs,
                                            DWORD dwInVersion,
                                            DRS_MSG_ADDSIDREQ *pmsgIn,
                                            DWORD *pdwOutVersion,
                                            DRS_MSG_ADDSIDREPLY *pmsgOut);

// DsAddSidHistory may operate on machine accounts, but not interdomain
// trust accounts, nor on temp duplicate accounts.  Define UF_ versions
// of legal bits for later use.

#define LEGAL_UF_ACCOUNT_CONTROL    (   UF_NORMAL_ACCOUNT               \
                                      | UF_WORKSTATION_TRUST_ACCOUNT    \
                                      | UF_SERVER_TRUST_ACCOUNT )

DWORD
BuildDstObjATTRMODLIST(
    THSTATE                     *pTHS,                      // in
    ATTR                        *pSrcSid,                   // in
    ATTR                        *pSrcSidHistory,            // in
    ATTR                        *pDstSid,                   // in
    ATTR                        *pDstSidHistory,            // in
    MODIFYARG                   *pModifyArg);               // out

DWORD
BuildCheckAndUpdateArgs(
    THSTATE                     *pTHS,                      // in
    BOOL                        fSrcIsW2K,                  // in
    WCHAR                       *SrcDomainController,       // in
    WCHAR                       *SrcDomain,                 // in
    SEC_WINNT_AUTH_IDENTITY_W   *pAuthInfo,                 // in
    NT4SID                      *pSrcObjSid,                // in
    DWORD                       Flags,                      // in
    BOOL                        NeedImpersonation,          // in
    DWORD                       *pcNames,                   // out
    WCHAR                       ***prpNames,                // out
    ATTR                        **ppSrcSid,                 // out
    ATTR                        **ppSrcSidHistory,          // out
    DWORD                       *pDsid,                     // out
    BOOL                        *pImpersonating);           // out

DWORD
VerifySrcAuditingEnabledAndGetFlatName(
    IN  UNICODE_STRING  *usSrcDC,
    OUT WCHAR           **pSrcDomainFlatName,
    OUT DWORD           *pdsid
    );

DWORD
VerifySrcIsSP4OrGreater(
    IN  BOOL    fSrcIsW2K,
    IN  PWCHAR  SrcDc,
    OUT DWORD   *pdsid
    );

DWORD
VerifyIsPDC(
    IN  PWCHAR  DC,
    OUT DWORD   *pdsid
    );

DWORD
ForceAuditOnSrcObj(
    IN  WCHAR   *SrcDc,
    IN  NT4SID  *pSrcObjSid,
    IN  WCHAR   *pSrcDomainFlatName,
    OUT DWORD   *pdsid
    );

DWORD
ImpersonateSrcAdmin(
    IN  SEC_WINNT_AUTH_IDENTITY_W   *pauthInfo,
    IN  BOOL                        NeedImpersonation,
    OUT DWORD                       *pdsid,
    OUT BOOL                        *pImpersonating,
    OUT HANDLE                      *phToken
    );

DWORD
UnimpersonateSrcAdmin(
    IN  BOOL        NeedImpersonation,
    OUT DWORD       *pdsid,
    IN OUT BOOL     *pImpersonating,
    IN OUT HANDLE   *phToken
    );

// set DSID in subroutine
#define SetDsid(_pdsid_)    \
    *_pdsid_ = (FILENO << 16) | __LINE__;

DWORD
VerifyAuditingEnabled(
    )
/*++

  Description:

    Verify auditing is enabled for the domain this DC hosts.  Note that
    LSA assumes only one domain per DC this which domain does not need
    to be specified.

  Arguments:

    None

  Return Value:

    WIN32 return code.

--*/
{
    NTSTATUS                    status;
    POLICY_AUDIT_EVENTS_INFO    *pPolicy = NULL;
    BOOL                        fAuditing = FALSE;

    // Verify auditing is enabled for destination domain.
    // Note that the LSA API assumes one domain per DC.

    if ( status = LsaIQueryInformationPolicyTrusted(
                                PolicyAuditEventsInformation,
                                (PLSAPR_POLICY_INFORMATION *) &pPolicy) ) {
        return(RtlNtStatusToDosError(status));
    }

    if ( pPolicy->AuditingMode
            &&
         (pPolicy->EventAuditingOptions[AuditCategoryAccountManagement]
                                           & POLICY_AUDIT_EVENT_SUCCESS)
             &&
         (pPolicy->EventAuditingOptions[AuditCategoryAccountManagement]
                                           & POLICY_AUDIT_EVENT_FAILURE) ) {
        fAuditing = TRUE;
    }

    LsaIFree_LSAPR_POLICY_INFORMATION(PolicyAuditEventsInformation,
                                      (PLSAPR_POLICY_INFORMATION) pPolicy);

    if ( !fAuditing ) {
        return(ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED);
    }

    return(ERROR_SUCCESS);
}

DWORD
VerifyCallerIsDomainAdminOrLocalAdmin(
    THSTATE *pTHS,
    PSID    pDomainSid,
    BOOL    *pfAdminSidPresent
    )
/*++

  Description:

    Verify the current caller is a member of domain admins
    for the domain in question or a member of the local
    admins on this DC.

  Arguments:

    pDomainSid - SID of domain to verify against.

    pfAdminSidPresent - Receives admin status on success.

  Return Value:

    WIN32 error code.

--*/
{
    DWORD   dwErr;
    NT4SID  adminSid;
    PSID    OtherSid;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    *pfAdminSidPresent = FALSE;

    // clear client context on the thread state since we are going to change context
    AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);
    if ( dwErr = RpcImpersonateClient(NULL) ) {
        return(dwErr);
    }

    // check if member of domain admins
    SampBuildNT4FullSid(pDomainSid,
                        DOMAIN_GROUP_RID_ADMINS,
                        &adminSid);

    if ( !CheckTokenMembership(NULL, &adminSid, pfAdminSidPresent) ) {
        dwErr = GetLastError();
    } else if (!*pfAdminSidPresent) {
        // not member of domain admins, check if member of local admins
        if (!AllocateAndInitializeSid(&NtAuthority, 2,
                                      SECURITY_BUILTIN_DOMAIN_RID,
                                      DOMAIN_ALIAS_RID_ADMINS,
                                      0, 0, 0, 0, 0, 0,
                                      &OtherSid)) {
            dwErr = GetLastError();
        } else {
            if ( !CheckTokenMembership(NULL, OtherSid, pfAdminSidPresent) ) {
                dwErr = GetLastError();
            }
            FreeSid(OtherSid);
        }
    }

    RpcRevertToSelf();
    return(dwErr);
}

WCHAR *
FindSrcDomainController(
    WCHAR   *SrcDomain
    )
/*++

  Routine Description:

    Finds a domain controller for the source domain from which we are
    going to grab a SID.  Works for both NT4 and W2K domains.

  Arguments:

    SrcDomain - UNICODE source domain name.  Can be either NetBIOS flat
        name or DNS domain name.  DsGetDcName handles either.

  Return Value:

    LocalAlloc'd DC name or NULL.

--*/
{
    DWORD                   dwErr;
    DWORD                   flags;
    DWORD                   i;
    WCHAR                   *pDc;
    DOMAIN_CONTROLLER_INFOW *pDCInfo = NULL;
    WCHAR                   *pRet = NULL;

    // Set DsGetDcName flags such that we get exactly what we want regardless
    // of whether source domain is NT4 or NT5.  Asking for a writable DC gets
    // the PDC in the NT4 case. PDC's are now required.

    flags = ( DS_DIRECTORY_SERVICE_PREFERRED |
              DS_PDC_REQUIRED |
              DS_WRITABLE_REQUIRED);

    for ( i = 0; i < 2; i++ ) {
        if ( 1 == i ) {
            // Normally one shouldn't force discovery indiscriminately.
            // But considering that the source domain is ex-forest, this
            // won't invalidate the cache for domains inside the forest.

            flags |= DS_FORCE_REDISCOVERY;
        }

        RpcTryExcept {
            dwErr = dsDsrGetDcNameEx2(
                    NULL,                   // computer name
                    NULL,                   // account name
                    0x0,                    // allowable account control
                    SrcDomain,              // domain name
                    NULL,                   // domain guid
                    NULL,                   // site name
                    flags,
                    &pDCInfo);
        } RpcExcept(1) {
            dwErr = RpcExceptionCode();
        } RpcEndExcept;

        if ( !dwErr ) {
            break;
        }
    }

    if ( !dwErr && pDCInfo ) {
        // ldap_initW cannot handle the leading "\\".
        pDc = pDCInfo->DomainControllerName;
        i = (wcslen(pDc) + 1) * sizeof(WCHAR);
        if (i > (sizeof(WCHAR) * 2)) {
            if (*pDc == L'\\' && *(pDc + 1) == L'\\') {
                pDc += 2;
                i -= (sizeof(WCHAR) * 2);
            }
        }

        if ( pRet = (WCHAR *) LocalAlloc(LPTR, i) ) {
            wcscpy(pRet, pDc);
        }
    }

    if ( pDCInfo ) {
        NetApiBufferFree(pDCInfo);
    }

    return(pRet);
}

DWORD
GetDomainHandleAndSid(
    SAM_HANDLE  hSam,
    WCHAR       *SrcDomain,
    SAM_HANDLE  *phDom,
    NT4SID      *pDomSid
    )
/*++

  Routine Description:

    Opens the source domain using calls guaranteed to work on NT4 or later
    and returns both a domain handle and the domain SID.

  Arguments:

    hSam - Valid SAM handle for source domain controller.

    SrcDomain - Name of source domain.

    phDom - Received valid domain handle on success.  Should be released
        via SamCloseHandle().

    pDomSid - Receives domain SID on success.

  Return Value:

    WIN32 error code.

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    NTSTATUS        status;
    UNICODE_STRING  usSrcDomain;
    PSID            pSid;

    *phDom = NULL;

    // Map domain name to SID.
    RtlInitUnicodeString(&usSrcDomain, SrcDomain);
    status = SamLookupDomainInSamServer(hSam, &usSrcDomain, &pSid);

    if ( !NT_SUCCESS(status) ) {
        dwErr = RtlNtStatusToDosError(status);
    } else {
        // Get a handle to the domain.
        status = SamOpenDomain(hSam, DOMAIN_LOOKUP, pSid, phDom);

        if ( !NT_SUCCESS(status) ) {
            dwErr = RtlNtStatusToDosError(status);
        } else {
            Assert(RtlLengthSid(pSid) <= sizeof(NT4SID));
            memcpy(pDomSid, pSid, RtlLengthSid(pSid));
        }

        SamFreeMemory(pSid);
    }

    return(dwErr);
}

DWORD
VerifySrcDomainAdminRights(
    SAM_HANDLE  hDom
    )
/*++

  Routine Description:

    Verifies that the principal which obtained the domain handle has
    domain admin rights in the domain.

  Arguments:

    hDom - Valid domain handle.

  Return Value:

    WIN32 error code.

--*/
{
    // We need to verify that the credentials used to get hSam have domain
    // admin rights in the source domain.  RichardW observes that we can
    // do this easily for both NT4 and NT5 cases by checking whether we
    // can open the domain admins object for write.  On NT4, the principal
    // would have to be an immediate member of domain admins.  On NT5 the
    // principal may transitively be a member of domain admins.  But rather
    // than checking memberships per se, the ability to open domain admins
    // for write proves that the principal could add himself if he wanted
    // to, thus he/she is essentially a domain admin.  I.e. The premise is
    // that security is set up such that only domain admins can modify the
    // domain admins group.  If that's not the case, the customer has far
    // worse security issues to deal with than someone stealing a SID.

    DWORD       dwErr = ERROR_SUCCESS;
    NTSTATUS    status;
    SAM_HANDLE  hGroup;
    ACCESS_MASK access;

    // You'd think we should ask for GROUP_ALL_ACCESS.  But it turns out
    // that in 2000.3 DELETE is not given by default to domain admins.
    // So we modify the access required accordingly.  PraeritG has been
    // notified of this phenomena.

    access = GROUP_ALL_ACCESS & ~DELETE;
    status = SamOpenGroup(hDom, access, DOMAIN_GROUP_RID_ADMINS, &hGroup);

    if ( !NT_SUCCESS(status) ) {
        dwErr = RtlNtStatusToDosError(status);
    } else {
        SamCloseHandle(hGroup);
    }

    return(dwErr);
}


DWORD
ForceSuccessAuditOnDstObj(
    WCHAR       *srcAccountName,
    WCHAR       *srcDomainName,
    NT4SID      *pSrcObjSid,
    NT4SID      *pDstObjSid,
    WCHAR       *flatAccountName,
    WCHAR       *flatDomainName
    )
/*++

  Routine Description:

    Forces a success audit event on the object whose ATT_SID_HISTORY
    was extended.

  Arguments:

    srcAccountName - SAM account name of the source object.

    srcDomainName - SAM account name of the source domain.

    pSrcObjSid - SID of the source object.

    pDstObjSid - SID of destination object.

    flatAccountName - SAM account name of destination object.

    flatDomainName - SAM account name of destination domain.

  Return Value:

    WIN32 error code.

--*/
{
    NTSTATUS        status;
    DWORD           dwErr = ERROR_SUCCESS;
    NT4SID          dstDomainSid;
    ULONG           dstObjRid;
    UNICODE_STRING  usAccountName;
    UNICODE_STRING  usDomainName;
    UNICODE_STRING  srcName;    // Source Account Name. (including domain name)
    PWCHAR          temp = NULL;
    ULONG           cb = 0;
    THSTATE         *pTHS = pTHStls;

    Assert(srcAccountName && srcDomainName && pSrcObjSid && pDstObjSid && flatAccountName && flatDomainName);

    SampSplitNT4SID(pDstObjSid, &dstDomainSid, &dstObjRid);
    RtlInitUnicodeString(&usAccountName, flatAccountName);
    RtlInitUnicodeString(&usDomainName, flatDomainName);

    //
    // Construct the Source Account Name (including Domain Name)
    //
    cb = sizeof(WCHAR) * (wcslen(srcDomainName) + wcslen(srcAccountName) + 2);
    temp = THAllocEx(pTHS, cb);

    if (NULL == temp)
        return(ERROR_NOT_ENOUGH_MEMORY);

    memset(temp, 0, cb);
    swprintf(temp, L"%s\\%s", srcDomainName, srcAccountName);
    RtlInitUnicodeString(&srcName, temp);

    status = LsaIAuditSamEvent(
                    STATUS_SUCCESS,                 // operation status
                    SE_AUDITID_ADD_SID_HISTORY,     // audit ID
                    &dstDomainSid,                  // domain SID
                    &srcName,                       // Additional Info - Src Account Name
                    NULL,                           // member RID - NULL
                    pSrcObjSid,                     // member SID - Src Principal SID
                    &usAccountName,                 // object's SAM name
                    &usDomainName,                  // domain's SAM name
                    &dstObjRid,                     // object RID
                    NULL);                          // privileges


    if ( !NT_SUCCESS(status) ) {
        dwErr = RtlNtStatusToDosError(status);
    }

    THFreeEx(pTHS, temp);

    return(dwErr);
}

VOID
ForceFailureAuditOnDstDom(
    WCHAR       *srcAccountName,
    WCHAR       *srcDomainName,
    NT4SID      *pDstDomSid,
    WCHAR       *flatAccountName,
    WCHAR       *flatDomainName
    )
/*++

  Routine Description:

    Forces a failure audit event on the destination domain.

  Arguments:

    srcAccountName - SAM account name of the source object.

    srcDomainName - SAM account name of the source domain.

    pDstDomSid - SID of destination domain.

    flatAccountName - SAM account name of the destination account.

    flatDomainName - SAM account name of destination domain.

  Return Value:

    None.

--*/
{
    UNICODE_STRING  usAccountName;
    UNICODE_STRING  usDomainName;
    UNICODE_STRING  srcName;    // Source Account Name. (including domain name)
    PWCHAR          temp = NULL;
    ULONG           cb = 0;
    THSTATE         *pTHS = pTHStls;

    Assert(srcAccountName && srcDomainName && pDstDomSid && flatAccountName && flatDomainName);
    //
    // Construct the Source Account Name (including Domain Name)
    //
    cb = sizeof(WCHAR) * (wcslen(srcAccountName) + wcslen(srcDomainName) + 2);
    temp = THAllocEx(pTHS, cb);

    if (NULL == temp)
        return;

    memset(temp, 0, cb);
    swprintf(temp, L"%s\\%s", srcDomainName, srcAccountName);
    RtlInitUnicodeString(&srcName, temp);

    RtlInitUnicodeString(&usAccountName, flatAccountName);
    RtlInitUnicodeString(&usDomainName, flatDomainName);
    LsaIAuditSamEvent(
                    STATUS_ACCESS_DENIED,           // operation status
                    SE_AUDITID_ADD_SID_HISTORY,     // audit ID
                    pDstDomSid,                     // domain SID
                    &srcName,                       // Source Account Name
                    NULL,                           // member RID
                    NULL,                           // member SID
                    &usAccountName,                 // object's SAM name
                    &usDomainName,                  // domain's SAM name
                    NULL,                           // object RID
                    NULL);                          // privileges

    THFreeEx(pTHS, temp);
}

DWORD
GetSrcPrincipalSid(
    SAM_HANDLE      hDom,
    WCHAR           *SrcPrincipal,
    NT4SID          *pSrcDomSid,
    NT4SID          *pSrcObjSid,
    SID_NAME_USE    *pSrcObjUse,
    DWORD           *pSrcObjControl,
    WCHAR           *dstDomainName
    )
/*++

  Routine Description:

    Derive the SID and object type of an object in the source domain.

  Arguments:

    hDom - Valid domain handle.

    SrcPrincipal - SAM Account Name of a principal in the domain.

    pSrcDomSid - SID of the domain.

    pSrcObjSid - Receives SID of the principal if found.

    pSrcObjUse - Receives the object type of the principal if found.

    pSrcObjControl - Receives the account control of the sourc object.
        These are returned in UF_* format, not USER_* format.  I.e. The
        returned data matches the format stored in the DS, not in legacy SAM.

    dstDomainName - SAM account name of destination domain.

  Return Value:

    WIN32 error code.

--*/
{
    DWORD                       dwErr = ERROR_SUCCESS;
    NTSTATUS                    status;
    UNICODE_STRING              usObj;
    SID_NAME_USE                *pUse = NULL;
    ULONG                       *pRid = NULL;
    SAM_HANDLE                  hObj = NULL;
    USER_CONTROL_INFORMATION    *pUserControl = NULL;

    memset(pSrcObjSid, 0, sizeof(NT4SID));
    *pSrcObjUse = SidTypeUnknown;
    *pSrcObjControl = 0;

    // Map name to SID.
    RtlInitUnicodeString(&usObj, SrcPrincipal);
    status = SamLookupNamesInDomain(hDom, 1, &usObj, &pRid, &pUse);

    if ( !NT_SUCCESS(status) ) {
        dwErr = RtlNtStatusToDosError(status);
    } else if (NULL == pUse) {
        // PREFIX: claims pUse may be NULL
        dwErr = ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER;
    } else {
        // Force audit - though source auditing is not a requirement.
        switch ( *pUse ) {
        case SidTypeUser:
            status = SamOpenUser(hDom, MAXIMUM_ALLOWED, *pRid, &hObj);
            if ( NT_SUCCESS(status) ) {
                // Users may be computers, etc. via account control.
                status = SamQueryInformationUser(hObj,
                                                 UserControlInformation,
                                                 &pUserControl);
                if ( NT_SUCCESS(status) ) {
                    *pSrcObjControl = SampAccountControlToFlags(
                                            pUserControl->UserAccountControl);
                    *pSrcObjControl &= UF_ACCOUNT_TYPE_MASK;
                    if ( *pSrcObjControl & ~LEGAL_UF_ACCOUNT_CONTROL ) {
                        dwErr = ERROR_DS_UNWILLING_TO_PERFORM;
                    }
                    SamFreeMemory(pUserControl);
                } else {
                    dwErr = RtlNtStatusToDosError(status);
                }
                SamCloseHandle(hObj);
            } else {
                dwErr = RtlNtStatusToDosError(status);
            }
            break;
        case SidTypeGroup:
            status = SamOpenGroup(hDom, MAXIMUM_ALLOWED, *pRid, &hObj);
            if ( NT_SUCCESS(status) ) {
                SamCloseHandle(hObj);
            } else {
                dwErr = RtlNtStatusToDosError(status);
            }
            break;
        case SidTypeAlias:
            status = SamOpenAlias(hDom, MAXIMUM_ALLOWED, *pRid, &hObj);
            if ( NT_SUCCESS(status) ) {
                SamCloseHandle(hObj);
            } else {
                dwErr = RtlNtStatusToDosError(status);
            }
            break;
        case SidTypeWellKnownGroup:
            // Eg: "Everyone" - illegal to move.
        case SidTypeComputer:
            // Not supported by NT4, nor by later versions for compatability.
        case SidTypeDomain:
            // Illegal to move.
        case SidTypeDeletedAccount:
            // Illegal to move.
        case SidTypeInvalid:
            // Illegal to move.
        case SidTypeUnknown:
            // Illegal to move.
        default:
            dwErr = ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER;
            break;
        }

        if ( !dwErr ) {
            // Set up return data.
            SampBuildNT4FullSid(pSrcDomSid, *pRid, pSrcObjSid);
            *pSrcObjUse = *pUse;
        }

        SamFreeMemory(pRid);
        SamFreeMemory(pUse);
    }

    return(dwErr);
}

DWORD
CheckIfSidsInForest(
    DWORD           cSids,
    WCHAR           **rpStringSids,
    GUID            *pGuid
    )
/*++

  Routine Description:

    Determines whether some SIDs are already present in the forest as either
    an ATT_OBJECT_SID or ATT_SID_HISTORY value.  If there is exactly one
    such object, then returns success and fills in pGuid with the GUID
    of that one object.

  Arguments:

    cSids - Count of SIDs to verify.

    rpStringSids - Array of string-ized SIDs to verify.

    pGuid - Receives GUID of object with this SID if it already exists.

  Return Value:

    WIN32 error code.

--*/
{
    DWORD           pass, i, dwErr = ERROR_SUCCESS;
    WCHAR           dnsName[256+1];
    WCHAR           guidName[40];
    DWORD           dnsNameLen;
    DWORD           guidNameLen;
    NTSTATUS        status;
    DWORD           nameErr;
    PVOID           pvSave;
    GUID            tmpGuid;
    BOOL            fCrackAtGC;

    memset(pGuid, 0, sizeof(GUID));

    // Verify src SIDs are not present in this forest.  There will always
    // be latency problems with this test, but we try to mitigate them
    // by going to a GC _AND_ performing the search locally in case the
    // SID was just added on this machine and hasn't made it to the GC yet.
    // Note that cracking a name by SID checks both ATT_OBJECT_SID
    // and ATT_SID_HISTORY.

    // PERFHINT: CrackSingleName assumes there is no THSTATE so we must
    // save/restore. This is incredibly inefficient and intended as a quick
    // prototyping solution only.  The efficient mechanism is to call
    // IDL_DRSCrackNames() if required, then open a DB and do a local
    // CrackNames().

    pvSave = THSave();

    __try {
        // Perform two passes - first against the GC, second locally.
        for ( pass = 0; pass < 2; pass++ ) {
            if ( 0 == pass ) {
                // First pass always at a GC - which could be ourself.
                fCrackAtGC = TRUE;
            } else if ( gAnchor.fAmVirtualGC ) {
                // Since we're a GC, pass 0 executed locally already.
                break;
            } else {
                fCrackAtGC = FALSE;
            }

            for ( i = 0; i < cSids; i++ ) {
                dnsNameLen = sizeof(dnsName) / sizeof(WCHAR);
                guidNameLen = sizeof(guidName) / sizeof(WCHAR);
                status = CrackSingleName(DS_STRING_SID_NAME, 
                                         (fCrackAtGC)?DS_NAME_FLAG_GCVERIFY:DS_NAME_NO_FLAGS,
                                         rpStringSids[i], DS_UNIQUE_ID_NAME,
                                         &dnsNameLen, dnsName,
                                         &guidNameLen, guidName,
                                         &nameErr);

                if ( !NT_SUCCESS(status) ) {
                    dwErr = RtlNtStatusToDosError(status);
                    break;
                } else if ( CrackNameStatusSuccess(nameErr) ) {
                    // Object with this SID exists once in forest.
                    if ( IsStringGuid(guidName, &tmpGuid) ) {
                        if ( fNullUuid(pGuid) ) {
                            // This is the first GUID we've found - save it.
                            *pGuid = tmpGuid;
                        } else if ( memcmp(pGuid, &tmpGuid, sizeof(GUID)) ) {
                            // Same SID on two different objects - bail.
                            dwErr = ERROR_DS_SRC_SID_EXISTS_IN_FOREST;
                            break;
                        } else {
                            // Two SIDs mapped to same object - this is OK.
                            Assert(ERROR_SUCCESS == dwErr);
                        }
                    } else {
                        // Malformed response from CrackSingleName.
                        dwErr = ERROR_DS_INTERNAL_FAILURE;
                        break;
                    }
                } else if ( DS_NAME_ERROR_NOT_UNIQUE == nameErr ) {
                    // SID exists more than once in the forest.
                    dwErr = ERROR_DS_SRC_SID_EXISTS_IN_FOREST;
                    break;
                } else if ( DS_NAME_ERROR_NOT_FOUND != nameErr ) {
                    // Random processing error.
                    dwErr = ERROR_DS_INTERNAL_FAILURE;
                    break;
                }
            }

            if ( dwErr ) {
                // Break from outer loop.
                break;
            }
        }
    } __finally {
        THRestore(pvSave);
    }

    return(dwErr);
}

BOOL
IsDomainInForest(
    WCHAR       *pDomain,
    CROSS_REF   **ppCR
    )
/*++

  Routine Description:

    Determines whether a domain is in the forest or not.  Domain name
    can be either flat NetBIOS name or DNS domain name, with or without
    trailing '.'.

  Arguments:

    pDomain - Domain name to find.

    ppCR - Receives address of corresponding CROSS_REF if domain is found.

  Return Value:

    TRUE if yes.

--*/
{
    THSTATE     *pTHS = pTHStls;
    WCHAR       *pTmp;
    DWORD       cChar;
    DWORD       cBytes;

    *ppCR = NULL;

    // Don't know if this is a flat or DNS name - so attempt both.

    if ( *ppCR = FindExactCrossRefForAltNcName(ATT_NETBIOS_NAME,
                                               (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN),
                                               pDomain) ) {
        return(TRUE);
    }

    if ( *ppCR = FindExactCrossRefForAltNcName(ATT_DNS_ROOT,
                                               (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN),
                                               pDomain) ) {
        return(TRUE);
    }

    // Retry with/without trailing '.' on DNS name as required.

    cChar = wcslen(pDomain);
    pTmp = (WCHAR *) THAllocEx(pTHS,(cChar + 2) * sizeof(WCHAR));
    
    wcscpy(pTmp, pDomain);

    if ( L'.' == pTmp[cChar-1] ) {
        pTmp[cChar-1] = L'\0';
    } else {
        pTmp[cChar] = L'.';
        pTmp[cChar+1] = L'\0';
    }

    if ( *ppCR = FindExactCrossRefForAltNcName(ATT_DNS_ROOT,
                                               (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN),
                                               pTmp) ) {
        THFreeEx(pTHS,pTmp);
        return(TRUE);
    }
    THFreeEx(pTHS,pTmp);
    return(FALSE);
}

VOID
THFreeATTR(
    THSTATE     *pTHS,
    ATTR        *pAttr,
    BOOL        fFreeBasePointer
    )
/*++

  Description:

    Deallocates a THAlloc'd ATTR and all that it points to.

  Arguments:

    pTHS - Valid THSTATE pointer.

    pAttr - Pointer to ATTR to deallocate.

    fFreeBasePointer - Flag indicating whether to free pAttr itself.  For
        example, set this to FALSE if passing in &MODIFYARG.FirstMod.AttrInf.

  Return Value:

    None.

--*/
{
    DWORD   i;

    if ( pTHS ) {
        if ( pAttr ) {
            if ( pAttr->AttrVal.pAVal ) {
                for ( i = 0; i < pAttr->AttrVal.valCount; i++ ) {
                    if ( pAttr->AttrVal.pAVal[i].pVal ) {
                        THFreeEx(pTHS, pAttr->AttrVal.pAVal[i].pVal);
                    }
                }
                THFreeEx(pTHS, pAttr->AttrVal.pAVal);
            }
            if ( fFreeBasePointer ) {
                THFreeEx(pTHS, pAttr);
            }
        }
    }
}


#define ADDSID_SECURE_KEY_SIZE (128)
DWORD AddSidSecureKeySize = ADDSID_SECURE_KEY_SIZE;
DWORD
VerifyCallIsSecure(
    IN DRS_CLIENT_CONTEXT   *pCtx,
    OUT DWORD               *pdsid
    )
/*++

  Description:

    This routine verifies that the call is local or, if remote, is
    using >= 128bit encryption. Addsid requires a secure connection
    in case the credentials for the src domain are being sent over the
    wire.

    A local connection is determined by checking the ip address in the
    context handle. If the ip addr is INADDR_NONE or matches one of the
    ip addresses for this computer then the call is local.

    If the call isn't local, then the keysize is extracted from the
    security context of the caller. If the extracted keysize is less
    than 128, an ERROR_DS_MUST_BE_RUN_ON_DST_DC is returned.

  Arguments:

    pCtx - explicit context handle

    pdsid - dsid returned to caller for error logging

  Return Value:

    Win32 error code.

--*/
{
    DWORD                   dwErr;
    DWORD                   i;
    ULONG                   KeySize;
    struct hostent          *phe;
    VOID                    *pSecurityContext;
    SecPkgContext_KeyInfo   KeyInfo;

    // LRPC (aka LPC_PROTSEQ, aka local call) has an ipaddr of INADDR_NONE
    if (pCtx->IPAddr == INADDR_NONE) {
        return ERROR_SUCCESS;
    }

    // this computer's list of ip addresses
    phe = gethostbyname(NULL);
    if (phe == NULL) {
        dwErr = WSAGetLastError();
        SetDsid(pdsid);
        return dwErr;
    }

    // Does the client's ip address match one of this computer's ip addresses
    if (phe->h_addr_list) {
        for (i = 0; phe->h_addr_list[i]; ++i) {
            if (pCtx->IPAddr == *((ULONG *)phe->h_addr_list[i])) {
                return (ERROR_SUCCESS);
            }
        }
    }

    // Get the security context from the RPC handle
    dwErr = I_RpcBindingInqSecurityContext(I_RpcGetCurrentCallHandle(),
                                           &pSecurityContext);
    if (dwErr) {
        SetDsid(pdsid);
        return (dwErr);
    }

    // get the keysize
    dwErr = QueryContextAttributesW(pSecurityContext,
                                    SECPKG_ATTR_KEY_INFO,
                                    &KeyInfo);
    if (dwErr) {
        // treat "not supported" as "not secure"
        if (dwErr != SEC_E_UNSUPPORTED_FUNCTION) {
            SetDsid(pdsid);
            return (dwErr);
        }
        KeySize = 0;
    } else {
        KeySize = KeyInfo.KeySize;
        FreeContextBuffer(KeyInfo.sSignatureAlgorithmName);
        FreeContextBuffer(KeyInfo.sEncryptAlgorithmName);
    }

    // is the key size large enough?
    if (KeySize < AddSidSecureKeySize) {
        DPRINT2(0, "AddSid: keysize is %d (minimum is %d)\n",
                KeySize, AddSidSecureKeySize);
        return ERROR_DS_MUST_BE_RUN_ON_DST_DC;
    }

    return ERROR_SUCCESS;
}

ULONG
IDL_DRSAddSidHistory(
    DRS_HANDLE              hDrs,
    DWORD                   dwInVersion,
    DRS_MSG_ADDSIDREQ       *pmsgIn,
    DWORD                   *pdwOutVersion,
    DRS_MSG_ADDSIDREPLY     *pmsgOut
    )
/*++

  Routine Description:

    Grabs a SID from a principal in an ex-forest domain and adds it to the
    SID history of in-forest principal.  However, many, many conditions
    must be met for this to actually be performed.

    Auditing is performed since this operation can have a high security
    impact.  The source DC is responsible for auditing all operations at
    its end.  We, the destination DC, need to audit successful operations
    and any operations which fail for security reasons.  There's only one
    occurrence of the latter and that is when we check the caller for
    membership in domain admins of the destination domain.  The actual
    update to ATT_SID_HISTORY occurs with fDSA set, so it passes all
    security checks by definition.

  Arguments:

    hDrs - Valid DRS_HANDLE from RPC run times.

    dwInVersion - Identifies union version in DRS_MSG_ADDSIDREQ.

    pmsgIn - Input argument block.

    pdwOutVersion - Receives union version in DRS_MSG_ADDSIDREPLY.

    pmsgOut - Receives return data.

  Return Value:

    WIN32 error code.

--*/
{
    THSTATE                     *pTHS = pTHStls;
    DWORD                       i, cAtts, id, dsid = 0;
    DWORD                       ret = 0;
    BOOL                        fDbOpen = FALSE;
    BOOL                        fCommit = FALSE;
    DWORD                       dwErr = ERROR_INVALID_PARAMETER;
    DWORD                       xCode;
    RPC_AUTHZ_HANDLE            hAuthz;
    ULONG                       authnLevel;
    CROSS_REF                   *pSrcCR, *pDstCR;
    NT4SID                      dstAdminSid;
    BOOL                        fAdminSidPresent = FALSE;
    NTSTATUS                    status;
    WCHAR                       *SrcDomainController = NULL;
    SEC_WINNT_AUTH_IDENTITY_W   authInfo;
    OBJECT_ATTRIBUTES           oa;
    BOOL                        fSrcIsW2K;
    UNICODE_STRING              usSrcDC;
    SAM_HANDLE                  hSam = NULL;
    SAM_HANDLE                  hDom = NULL;
    NT4SID                      srcDomSid;
    NT4SID                      srcObjSid;
    NT4SID                      tmpSid;
    ULONG                       srcObjRid;
    ULONG                       dstObjRid;
    SID_NAME_USE                srcObjUse;
    BOOLEAN                     fMixedMode = TRUE;
    WCHAR                       *NT4Name;
    DWORD                       cBytes;
    DWORD                       cNamesOut;
    CrackedName                 *pCrackedName = NULL;
    ATTRTYP                     objClass;
    DWORD                       srcControl = 0;     // UF_* format
    DWORD                       dstControl = 0;     // UF_* format
    DWORD                       groupType;
    NT4_GROUP_TYPE              groupTypeNT4;
    NT5_GROUP_TYPE              groupTypeNT5;
    BOOLEAN                     fSecEnabled;
    MODIFYARG                   modifyArg;
    ATTRVAL                     attrVal;
    BOOL                        fLog = FALSE;
    GUID                        guidPreExists;
    ULONG                       mostBasicClass;
    BOOL                        fInheritSecurityIdentity = FALSE;
    DWORD                       cSids = 0;
    WCHAR                       **rpStringSids = NULL;
    ATTR                        *pSrcSid = NULL;
    ATTR                        *pSrcSidHistory = NULL;
    ATTR                        *pDstSidHistory = NULL;
    ATTR                        *pDstSid = NULL;
    ATTCACHE                    *pAC;
    BOOL                        Impersonating = FALSE;
    BOOL                        NeedImpersonation = FALSE;
    WCHAR                       *SrcSpn = NULL;
    HANDLE                      hToken = INVALID_HANDLE_VALUE;
    WCHAR                       *pSrcDomainFlatName = NULL;

    drsReferenceContext( hDrs, IDL_DRSADDSIDHISTORY);
	__try { 
		// Since we have in args which were THAlloc'd we should have a THSTATE.
		Assert(pTHS);

		__try {
			// Sanity check arguments.

			if (    ( NULL == hDrs )
					|| ( NULL == pmsgIn )
					|| ( NULL == pmsgOut )
					|| ( NULL == pdwOutVersion )
					|| ( 1 != dwInVersion ) ) {
				ret = ERROR_INVALID_PARAMETER;
				__leave;
			}

			memset(&modifyArg, 0, sizeof(modifyArg));
			*pdwOutVersion = 1;
			memset(pmsgOut, 0, sizeof(*pmsgOut));
			pmsgOut->V1.dwWin32Error = ERROR_DS_INTERNAL_FAILURE;

			// Flag dependent argument checks.

			if ( DS_ADDSID_FLAG_PRIVATE_DEL_SRC_OBJ & pmsgIn->V1.Flags ) {
				// Disable logging and such outside the primary try/except
				// as IDL_DRSInheritSecurityPrincipal does its own.
				fInheritSecurityIdentity = TRUE;
				ret = IDL_DRSInheritSecurityIdentity(hDrs, dwInVersion, pmsgIn,
													 pdwOutVersion, pmsgOut);
				__leave;
			}

			if ( pmsgIn->V1.Flags & ~DS_ADDSID_FLAG_PRIVATE_CHK_SECURE ) {
				ret = ERROR_INVALID_PARAMETER;
				__leave;
			}

			#define SetAddSidError(err)                         \
			dwErr = pmsgOut->V1.dwWin32Error = err;     \
			dsid = (FILENO << 16) | __LINE__;

			#define SetAddSidErrorWithDsid(err, id)             \
			dwErr = pmsgOut->V1.dwWin32Error = err;     \
			dsid = id;

			// The caller is checking if the connection is secure enough for
			// addsid. At this time, this means the connection is local or,
			// if remote, is using encryption keys that are at least 128bits
			// in length.
			if ( DS_ADDSID_FLAG_PRIVATE_CHK_SECURE & pmsgIn->V1.Flags ) {

				// verify that the call is local or keysize >= 128bits.
				dwErr = VerifyCallIsSecure(hDrs, &id);
				SetAddSidErrorWithDsid(dwErr, id);
				__leave;
			}

			if (    ( NULL == pmsgIn->V1.SrcDomain )
					|| ( 0 == wcslen(pmsgIn->V1.SrcDomain) )
					|| ( NULL == pmsgIn->V1.SrcPrincipal )
					|| ( 0 == wcslen(pmsgIn->V1.SrcPrincipal) )
					|| (    (0 != pmsgIn->V1.SrcCredsUserLength)
							&& (NULL == pmsgIn->V1.SrcCredsUser) )
					|| (    (0 != pmsgIn->V1.SrcCredsDomainLength)
							&& (NULL == pmsgIn->V1.SrcCredsDomain) )
					|| (    (0 != pmsgIn->V1.SrcCredsPasswordLength)
							&& (NULL == pmsgIn->V1.SrcCredsPassword) )
					|| ( NULL == pmsgIn->V1.DstDomain )
					|| ( 0 == wcslen(pmsgIn->V1.DstDomain) )
					|| ( NULL == pmsgIn->V1.DstPrincipal )
					|| ( 0 == wcslen(pmsgIn->V1.DstPrincipal) ) ) {

				ret = ERROR_INVALID_PARAMETER;
				__leave;
			}

			// Verify caller used integrity and privacy.  RPC considers privacy
			// a superset of integrity, so if we have privacy we have integrity
			// as well.  NULL binding handle tells RPC you're interested in
			// this thread's info - i.e. that associated with hDrs.

			if ( dwErr = RpcBindingInqAuthClient(NULL, &hAuthz, NULL,
												 &authnLevel, NULL, NULL) ) {
				SetAddSidError(dwErr);
				__leave;
			}

			if ( authnLevel < RPC_C_PROTECT_LEVEL_PKT_PRIVACY ) {
				SetAddSidError(ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION);
				__leave;
			}

			// Verify source domain is outside forest.

			if ( IsDomainInForest(pmsgIn->V1.SrcDomain, &pSrcCR) ) {
				SetAddSidError(ERROR_DS_SOURCE_DOMAIN_IN_FOREST);
				__leave;
			}

			// Verify destination domain is in forest.

			if ( !IsDomainInForest(pmsgIn->V1.DstDomain, &pDstCR) ) {
				SetAddSidError(ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST);
				__leave;
			}

			// Verify destination domain is writeable at this replica.

			if (    !gAnchor.pDomainDN
					|| !NameMatched(gAnchor.pDomainDN, pDstCR->pNC) ) {
				SetAddSidError(ERROR_DS_MASTERDSA_REQUIRED);
				__leave;
			}

			// Verify existence of stuff we will need from pDstCR,

			if ( !pDstCR->pNC->SidLen || !pDstCR->NetbiosName ) {
				SetAddSidError(ERROR_DS_INTERNAL_FAILURE);
				__leave;
			}

			// Verify auditing is enabled for destination domain.

			if ( dwErr = VerifyAuditingEnabled() ) {
				SetAddSidError(dwErr);
				__leave;
			}

			// Verify caller is a member of domain admins for destination domain.

			if ( dwErr = VerifyCallerIsDomainAdminOrLocalAdmin(pTHS,
															   &pDstCR->pNC->Sid,
															   &fAdminSidPresent) ) {
				SetAddSidError(dwErr);
				__leave;
			}

			if ( !fAdminSidPresent ) {
				ForceFailureAuditOnDstDom(pmsgIn->V1.SrcPrincipal,
										  pmsgIn->V1.SrcDomain,
										  &pDstCR->pNC->Sid,
										  pmsgIn->V1.DstPrincipal,
										  pDstCR->NetbiosName);
				SetAddSidError(ERROR_DS_INSUFF_ACCESS_RIGHTS);
				__leave;
			}

			// Verify destination domain is in native mode.

			status = SamIMixedDomain2((PSID) &pDstCR->pNC->Sid, &fMixedMode);

			if ( !NT_SUCCESS(status) ) {
				SetAddSidError(RtlNtStatusToDosError(status));
				__leave;
			}

			if ( fMixedMode ) {
				SetAddSidError(ERROR_DS_DST_DOMAIN_NOT_NATIVE);
				__leave;
			}

			// Find a domain controller in the source domain if required.

			if ( pmsgIn->V1.SrcDomainController ) {
				SrcDomainController = pmsgIn->V1.SrcDomainController;
			}
			else
				{
				SrcDomainController = FindSrcDomainController(
					pmsgIn->V1.SrcDomain);

				if ( !SrcDomainController ) {
					SetAddSidError(ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN);
					__leave;
				}
			}

			// Connect to source domain using explicitly provided credentials.

			memset(&authInfo, 0, sizeof(authInfo));
			authInfo.UserLength = pmsgIn->V1.SrcCredsUserLength;
			authInfo.User = pmsgIn->V1.SrcCredsUser;
			authInfo.DomainLength = pmsgIn->V1.SrcCredsDomainLength;
			authInfo.Domain = pmsgIn->V1.SrcCredsDomain;
			authInfo.PasswordLength = pmsgIn->V1.SrcCredsPasswordLength;
			authInfo.Password = pmsgIn->V1.SrcCredsPassword;
			authInfo.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
			// No creds; need to impersonate caller
			if (   0 == authInfo.UserLength
				   && 0 == authInfo.DomainLength
				   && 0 == authInfo.PasswordLength) {
				authInfo.User = NULL;
				authInfo.Domain = NULL;
				authInfo.Password = NULL;
				NeedImpersonation = TRUE;
			} else if (0 == authInfo.PasswordLength) {
				// Password may be a garbage pointer if PasswordLength is 0
				// because of the semantics of the [size_is(xxx)] IDL definition.
				authInfo.Password = L"";
			}

			InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
			RtlInitUnicodeString(&usSrcDC, SrcDomainController);

			// No creds; impersonate caller
			if (NeedImpersonation) {
				// clear client context on the thread state since we are going to change context
				AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);
				if (dwErr = RpcImpersonateClient(NULL)) {
					SetAddSidError(dwErr);
					__leave;
				}
				Impersonating = TRUE;

				// build an Spn for binding to the SrcDc
				SrcSpn = THAllocEx(pTHS, (  wcslen(L"HOST/")
											+ wcslen(SrcDomainController)
											+ wcslen(L"@")
											+ wcslen(pmsgIn->V1.SrcDomain)
											+ 1) * sizeof (WCHAR));
				wcscpy(SrcSpn, L"HOST/");
				wcscat(SrcSpn, SrcDomainController);
				wcscat(SrcSpn, L"@");
				wcscat(SrcSpn, pmsgIn->V1.SrcDomain);
			}

			// connect with PKT_INTEGRITY
			if ( status = SamConnectWithCreds(&usSrcDC, &hSam, MAXIMUM_ALLOWED,
											  &oa, &authInfo, SrcSpn, &fSrcIsW2K) ) {
				// It might be that the SrcDc is NT4 and the client is
				// running locally. This config is supported so try the
				// binding with a NULL SrcSpn to force the underlying code
				// to use AUTH_WINNT instead of AUTH_NEGOTIATE.
				if (status == RPC_NT_UNKNOWN_AUTHN_SERVICE && SrcSpn) {
					status = SamConnectWithCreds(&usSrcDC, &hSam,
												 MAXIMUM_ALLOWED,
												 &oa, &authInfo,
												 NULL, &fSrcIsW2K);
				}
				if (status) {
					SetAddSidError(RtlNtStatusToDosError(status));
					__leave;
				}
			}
			// stop impersonation
			if (Impersonating) {
				Impersonating = FALSE;
				RpcRevertToSelf();
			}

			// Get a handle to the source domain.
			if ( dwErr = GetDomainHandleAndSid(hSam, pmsgIn->V1.SrcDomain,
											   &hDom, &srcDomSid) ) {
				SetAddSidError(dwErr);
				__leave;
			}

			// Verify source domain credentials have admin rights.
			if ( dwErr = VerifySrcDomainAdminRights(hDom) ) {
				SetAddSidError(dwErr);
				__leave;
			}

			if ( dwErr = GetSrcPrincipalSid(hDom, pmsgIn->V1.SrcPrincipal ,
											&srcDomSid, &srcObjSid,
											&srcObjUse, &srcControl,
											pDstCR->NetbiosName) ) {
				SetAddSidError(dwErr);
				__leave;
			}

			Assert(    (SidTypeUser == srcObjUse)
					   || (SidTypeGroup == srcObjUse)
					   || (SidTypeAlias == srcObjUse) );

			if ( dwErr = BuildCheckAndUpdateArgs(pTHS, fSrcIsW2K,
												 SrcDomainController,
												 pmsgIn->V1.SrcDomain,
												 &authInfo,
												 &srcObjSid,
												 pmsgIn->V1.Flags,
												 NeedImpersonation,
												 &cSids, &rpStringSids,
												 &pSrcSid, &pSrcSidHistory, &id,
												 &Impersonating) ) {
				SetAddSidErrorWithDsid(dwErr, id);
				__leave;
			}

			// String-ized src object SID is in now rpStringSids[0].
			Assert(rpStringSids && rpStringSids[0]);

			if ( dwErr = CheckIfSidsInForest(cSids, rpStringSids,
											 &guidPreExists) ) {
				SetAddSidError(dwErr);
				__leave;
			}

			// -----
			// BEGIN SRC CREDS IMPERSONATION
			// -----

			// Impersonate implicit or explicit Src admin creds
			if ( dwErr = ImpersonateSrcAdmin(&authInfo,
											 NeedImpersonation,
											 &id,
											 &Impersonating,
											 &hToken) ) {
				SetAddSidErrorWithDsid(dwErr, id);
				__leave;
			}

			// Verify source domain is auditing
			if ( dwErr = VerifySrcAuditingEnabledAndGetFlatName(&usSrcDC,
																&pSrcDomainFlatName,
																&id) ) {
				SetAddSidErrorWithDsid(dwErr, id);
				__leave;
			}

			// Verify source dc is SP4 or greater
			if ( dwErr = VerifySrcIsSP4OrGreater(fSrcIsW2K,
												 SrcDomainController,
												 &id) ) {
				SetAddSidErrorWithDsid(dwErr, id);
				__leave;
			}

			// Verify source dc is PDC
			if ( dwErr = VerifyIsPDC(SrcDomainController, &id) ) {
				SetAddSidErrorWithDsid(dwErr, id);
				__leave;
			}

			// Force audit on src dc by adding the src object's sid to the
			// SrcDomainFlatName$$$ group on the SrcDc and then deleting it.
			//
			// This has the added benefit of requiring the src admin
			// to create the SrcDomainFlatName$$$ group before Addsid will
			// steal sids from the SrcDomain. And it leaves a much more
			// obvious audit trail.
			if ( dwErr = ForceAuditOnSrcObj(SrcDomainController,
											&srcObjSid,
											pSrcDomainFlatName,
											&id) ) {
				SetAddSidErrorWithDsid(dwErr, id);
				__leave;
			}

			// Unimpersonate src admin
			if ( dwErr = UnimpersonateSrcAdmin(NeedImpersonation,
											   &id,
											   &Impersonating,
											   &hToken) ) {
				SetAddSidErrorWithDsid(dwErr, id);
				__leave;
			}
			// -----
			// END SRC CREDS IMPERSONATION
			// -----

			// Initialize thread state and open DB - this is not quite a no-op
			// if pTHS already exists.  I.e. It sets the caller type and refreshes
			// various things.

			if ( !(pTHS = InitTHSTATE(CALLERTYPE_NTDSAPI)) ) {
				SetAddSidError(ERROR_DS_INTERNAL_FAILURE);
				__leave;
			}

			// WARNING - DO NOT GO OFF MACHINE AFTER THIS POINT AS THERE IS A
			// TRANSACTION OPEN!  (and long transactions exhaust version store)

			DBOpen2(TRUE, &pTHS->pDB);
			fDbOpen = TRUE;

			__try
				{
				// Crack domain\samAccountName for destination principal to a DN.

				cBytes =   wcslen(pDstCR->NetbiosName)
				+ wcslen(pmsgIn->V1.DstPrincipal)
				+ 2;
				cBytes *= sizeof(WCHAR);
				NT4Name = (WCHAR *) THAllocEx(pTHS,cBytes);
				wcscpy(NT4Name, pDstCR->NetbiosName);
				wcscat(NT4Name, L"\\");
				wcscat(NT4Name, pmsgIn->V1.DstPrincipal);
				CrackNames(DS_NAME_NO_FLAGS, GetACP(), GetUserDefaultLCID(),
						   DS_NT4_ACCOUNT_NAME, DS_FQDN_1779_NAME, 1,
						   &NT4Name, &cNamesOut, &pCrackedName);
				THFreeEx(pTHS,NT4Name);

				if ( DS_NAME_ERROR_NOT_FOUND == pCrackedName->status ) {
					SetAddSidError(ERROR_DS_OBJ_NOT_FOUND);
					__leave;
				} else if ( DS_NAME_ERROR_NOT_UNIQUE == pCrackedName->status ) {
					SetAddSidError(ERROR_DS_NAME_ERROR_NOT_UNIQUE);
					__leave;
				} else if ( !CrackNameStatusSuccess(pCrackedName->status) ) {
					SetAddSidError(ERROR_DS_INTERNAL_FAILURE);
					__leave;
				}

				// We now have enough info to do logging.

				fLog = TRUE;

				// Bail with error if any SIDs pre-existed on any other object.

				if (    !fNullUuid(&guidPreExists)
						&& memcmp(&guidPreExists, &pCrackedName->pDSName->Guid,
								  sizeof(GUID)) ) {
					SetAddSidError(ERROR_DS_SRC_SID_EXISTS_IN_FOREST);
					__leave;
				}

				// Verify that we are doing user-to-user, group-to-group,
				// alias-to-alias, workstation-to-workstation, server-to-server,
				// but not mix and match of object classes or object types.

				if (    DBFindDSName(pTHS->pDB, pCrackedName->pDSName)
						|| DBGetSingleValue(pTHS->pDB, ATT_OBJECT_CLASS,
											&objClass, sizeof(objClass), NULL) ) {
					SetAddSidError(ERROR_DS_INTERNAL_FAILURE);
					__leave;
				}

				mostBasicClass = SampDeriveMostBasicDsClass(objClass);

				switch ( mostBasicClass ) {
				case CLASS_USER:
				case CLASS_COMPUTER:
					// Computers added via legacy APIs can be user objects.
					// But all computers are SidTypeUser for legacy reasons.
					if ( SidTypeUser != srcObjUse) {
						SetAddSidError(ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH);
						__leave;
					}
					if ( DBGetSingleValue(pTHS->pDB, ATT_USER_ACCOUNT_CONTROL,
										  &dstControl, sizeof(dstControl), NULL) ) {
						SetAddSidError(ERROR_DS_INTERNAL_FAILURE);
						__leave;
					}
					dstControl &= UF_ACCOUNT_TYPE_MASK;
					// Users and computers must have same account control bits set.
					if (    (dstControl & ~LEGAL_UF_ACCOUNT_CONTROL)
							|| (srcControl != dstControl) ) {
						SetAddSidError(ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH);
						_leave;
					}
					break;
				case CLASS_GROUP:
					// Group objects don't have an account control.
					if (    (SidTypeGroup != srcObjUse)
							&& (SidTypeAlias != srcObjUse) ) {
						SetAddSidError(ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH);
						__leave;
					}
					if ( DBGetSingleValue(pTHS->pDB, ATT_GROUP_TYPE, &groupType,
										  sizeof(groupType), NULL) ) {
						SetAddSidError(ERROR_DS_INTERNAL_FAILURE);
						__leave;
					}
					status = SampComputeGroupType(objClass, groupType,
												  &groupTypeNT4, &groupTypeNT5,
												  &fSecEnabled);
					if ( !NT_SUCCESS(status) ) {
						SetAddSidError(RtlNtStatusToDosError(status));
						__leave;
					}
					if (    (    (SidTypeGroup == srcObjUse)
								 && (NT4GlobalGroup != groupTypeNT4))
							|| (    (SidTypeAlias == srcObjUse)
									&& (NT4LocalGroup != groupTypeNT4)) ) {
						SetAddSidError(ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH);
						__leave;
					}
					break;
				default:
					SetAddSidError(ERROR_DS_OBJ_CLASS_VIOLATION);
					__leave;
				}

				// Security principals must have SIDs.

				Assert(pCrackedName->pDSName->SidLen > 0);

				// Disallow theft of built in accounts.

				if ( SECURITY_BUILTIN_DOMAIN_RID ==
					 *RtlSubAuthoritySid(&srcObjSid, 0) ) {
					SetAddSidError(ERROR_DS_UNWILLING_TO_PERFORM);
					__leave;
				}

				// Require that well known SIDs (which also have well known RIDs)
				// are only added to like accounts.  Eg: Administrators of source
				// can only be assigned to Administrators of destination.

				SampSplitNT4SID(&srcObjSid, &tmpSid, &srcObjRid);
				SampSplitNT4SID(&pCrackedName->pDSName->Sid, &tmpSid, &dstObjRid);

				if (    (srcObjRid < SAMP_RESTRICTED_ACCOUNT_COUNT)
						&& (srcObjRid != dstObjRid) ) {
					SetAddSidError(ERROR_DS_UNWILLING_TO_PERFORM);
					__leave;
				}

				// Read dst object's ATT_SID_HISTORY and ATT_OBJECT_SID so we
				// can do duplicate checks. Must read it in external form as
				// we will check against external form SIDs.

				if (    !(pAC = SCGetAttById(pTHS, ATT_SID_HISTORY))
						|| DBGetMultipleAtts(pTHS->pDB, 1, &pAC, NULL, NULL,
											 &cAtts, &pDstSidHistory,
											 DBGETMULTIPLEATTS_fEXTERNAL, 0) ) {
					SetAddSidError(ERROR_DS_INTERNAL_FAILURE);
					__leave;
				}

				if ( 0 == cAtts ) {
					pDstSidHistory = NULL;
				}

				if (    !(pAC = SCGetAttById(pTHS, ATT_OBJECT_SID))
						|| DBGetMultipleAtts(pTHS->pDB, 1, &pAC, NULL, NULL,
											 &cAtts, &pDstSid,
											 DBGETMULTIPLEATTS_fEXTERNAL, 0) ) {
					SetAddSidError(ERROR_DS_INTERNAL_FAILURE);
					__leave;
				}

				if ( 0 == cAtts ) {
					pDstSid = NULL;
				}

				// Everything checks out.  Now add src object's SID and SID
				// history, if present, to dst object's SID history.  We
				// need to filter out duplicate values in order to avoid
				// ERROR_DS_ATT_VAL_ALREADY_EXISTS errors.

				modifyArg.pObject = pCrackedName->pDSName;
				modifyArg.count = 1;
				modifyArg.FirstMod.choice = AT_CHOICE_ADD_VALUES;
				InitCommarg(&modifyArg.CommArg);
				modifyArg.pResObj = CreateResObj(pTHS->pDB, pCrackedName->pDSName);

				if ( dwErr = BuildDstObjATTRMODLIST(pTHS,
													pSrcSid, pSrcSidHistory,
													pDstSid, pDstSidHistory,
													&modifyArg) ) {
					SetAddSidError(dwErr);
					__leave;
				}

				// Bail with success if all SIDs pre-existed on this object
				// already.  Note that the earlier test against guidPreExists
				// only proved that there was at least one SID which mapped
				// to some object other than the destination object.  If
				// guidPreExists matched the destination object, then its only
				// now that we know whether some vs all SIDs were present already.
				// We exit with success rather than complain the SIDs are already
				// present so that the customer can re-run half-finished scripts
				// and not error out when re-doing previous SID additions.

				if ( 0 == modifyArg.FirstMod.AttrInf.AttrVal.valCount ) {
					SetAddSidError(ERROR_SUCCESS);
					__leave;
				}

				// Perform the write as fDSA as all checks have passed and
				// ATT_SID_HISTORY is protected otherwise.

				pTHS->fDSA = TRUE;
				__try {
					LocalModify(pTHS, &modifyArg);
				} __finally {
					pTHS->fDSA = FALSE;
				}

				if ( pTHS->errCode ) {
					// OK to leave w/o auditing since there can be no security
					// errors at this point due to fDSA being set during modify.
					SetAddSidError(mapApiErrorToWin32(pTHS, pTHS->errCode));
					__leave;
				}

				pTHS->fDSA = FALSE;

				// Force local audit and fail entire operation if we can't do it.

				if ( dwErr = ForceSuccessAuditOnDstObj(pmsgIn->V1.SrcPrincipal,
													   pmsgIn->V1.SrcDomain,
													   &srcObjSid,
													   &pCrackedName->pDSName->Sid,
													   pmsgIn->V1.DstPrincipal,
													   pDstCR->NetbiosName) ) {
					SetAddSidError(dwErr);
					__leave;
				}

				fCommit = TRUE;
			}
			__finally
				{
				if ( fDbOpen )
					{
					DBClose(pTHS->pDB, fCommit);
				}
			}

			pmsgOut->V1.dwWin32Error = dwErr;

		}
		__except(HandleMostExceptions(xCode = GetExceptionCode()))
		{
			ret = DsaExceptionToWin32(xCode);
		}

		__try {
			// stop impersonation (ignore errors)
			UnimpersonateSrcAdmin(NeedImpersonation,
								  &id,
								  &Impersonating,
								  &hToken);

			// Misc cleanup (moved outside of try/except to avoid resouce
			// exhaustion (eg, sam handles).

			if (    SrcDomainController
					&& (SrcDomainController != pmsgIn->V1.SrcDomainController) ) {
				LocalFree(SrcDomainController);
			}

			if ( hDom ) {
				SamCloseHandle(hDom);
			}

			if ( hSam ) {
				SamCloseHandle(hSam);
			}

			if ( pSrcSid ) {
				THFreeATTR(pTHS, pSrcSid, TRUE);
			}

			if ( pSrcSidHistory ) {
				THFreeATTR(pTHS, pSrcSidHistory, TRUE);
			}

			if ( pDstSid ) {
				THFreeATTR(pTHS, pDstSid, TRUE);
			}

			if ( pDstSidHistory ) {
				THFreeATTR(pTHS, pDstSidHistory, TRUE);
			}

			if ( modifyArg.pResObj ) {
				THFreeEx(pTHS, modifyArg.pResObj);
			}

			if ( SrcSpn ) {
				THFreeEx(pTHS, SrcSpn);
			}

			if ( pSrcDomainFlatName ) {
				THFreeEx(pTHS, pSrcDomainFlatName);
			}

			// Log to Directory Service event log.  Log exception error if there
			// is one, operation error otherwise.
			if ( pTHS && !fInheritSecurityIdentity ) {
				LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
						 ( !ret && !dwErr )
						 ? DS_EVENT_SEV_MINIMAL
						 : DS_EVENT_SEV_ALWAYS,
					( !ret && !dwErr )
				? DIRLOG_SID_HISTORY_MODIFIED
					: DIRLOG_FAILED_TO_ADD_SID_HISTORY,
					( fLog )
				? szInsertWC(pCrackedName->pDSName->StringName)
				: szInsertWC(L"?"),
							 ( !ret && !dwErr )
						 ? (( fLog )
							? szInsertWC(rpStringSids[0])
							: szInsertWC(L"?"))
						 : szInsertHex(dsid),
						szInsertInt(ret ? ret : dwErr));
			}

			// Clean up those items which we needed around for logging.

			if ( pCrackedName ) {
				if ( pCrackedName->pDSName ) {
					THFreeEx(pTHS, pCrackedName->pDSName);
				}
				if ( pCrackedName->pFormattedName ) {
					THFreeEx(pTHS, pCrackedName->pFormattedName);
				}
				if ( pCrackedName->pDnsDomain ) {
					THFreeEx(pTHS, pCrackedName->pDnsDomain);
				}
				THFreeEx(pTHS, pCrackedName);
			}

			if ( rpStringSids ) {
				for ( i = 0; i < cSids; i++ ) {
					if ( rpStringSids[i] ) {
						THFreeEx(pTHS, rpStringSids[i]);
					}
				}
				THFreeEx(pTHS, rpStringSids);
			}
		} __except(HandleMostExceptions(xCode = GetExceptionCode())) {
			  if (!ret) {
				  ret = DsaExceptionToWin32(xCode);
			  }
		}
    }
	__finally { 
		drsDereferenceContext( hDrs, IDL_DRSADDSIDHISTORY );
	}
	return(ret);
}

BOOL
ExistsSidInSidHistory(
    ATTRVAL     *pAVal,
    ATTR        *pDstSidHistory
    )
/*++

  Description:

    Determines whether the ATTRVAL presented already exists in the ATTR.

  Arguments:

    pAVal - ATTRVAL for which to test.

    pDstSidHistory - ATTR to test against representing dst object's SID
        history.  May be NULL.

  Return Values:

    TRUE or FALSE

--*/
{
    DWORD   i;

    if ( pDstSidHistory ) {
        for ( i = 0; i < pDstSidHistory->AttrVal.valCount; i++ ) {
            if (    (pAVal->valLen == pDstSidHistory->AttrVal.pAVal[i].valLen)
                 && !memcmp(pAVal->pVal,
                            pDstSidHistory->AttrVal.pAVal[i].pVal,
                            pAVal->valLen) ) {
                return(TRUE);
            }
        }
    }

    return(FALSE);
}

DWORD
BuildDstObjATTRMODLIST(
    THSTATE     *pTHS,
    ATTR        *pSrcSid,
    ATTR        *pSrcSidHistory,
    ATTR        *pDstSid,
    ATTR        *pDstSidHistory,
    MODIFYARG   *pModifyArg
    )
/*++

  Description:

    Constructs an ATTRMODLIST which has only those SIDs from the src object
    which are not already present on the dst object's SID history or as
    the dst object's sid.

  Arguments:

    pTHS - Valid THSTATE.

    pSrcSid - ATTR representing source object's SID.

    pSrcSidHistory - ATTR representing source object's SID history - may
        be NULL.

    pDstSid - ATTR representing destination object's SID.

    pDstSidHistory - ATTR representing destination object's SID history -
        may be NULL.

  Return Values:

    Win32 error code

--*/
{
    DWORD       i, j, cSids;
    ATTR        *rAttr[] = { pSrcSid, pSrcSidHistory, NULL };
    ATTR        *pAttr;
    ULONG       *pulValCount;

    // Count SIDs on src object.

    cSids = pSrcSid->AttrVal.valCount;
    if ( pSrcSidHistory ) {
        cSids += pSrcSidHistory->AttrVal.valCount;
    }

    // Allocate for max # of SIDs in MODIFYARG - some may not get used.

    pModifyArg->FirstMod.AttrInf.attrTyp = ATT_SID_HISTORY;
    pModifyArg->FirstMod.AttrInf.AttrVal.valCount = 0;
    pModifyArg->FirstMod.AttrInf.AttrVal.pAVal =
            (ATTRVAL *) THAllocEx(pTHS, cSids * sizeof(ATTRVAL));
    if ( !pModifyArg->FirstMod.AttrInf.AttrVal.pAVal ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    // Now add each SID in source to ATTRMODLIST if it is not yet present
    // in destination.  We run the same multi-value algorithm for both
    // SID and SID history though we know that object SID is single valued.

    pulValCount = &pModifyArg->FirstMod.AttrInf.AttrVal.valCount;
    for ( i = 0, pAttr = rAttr[0];  NULL != pAttr; i++, pAttr = rAttr[i] ) {
        for ( j = 0; j < pAttr->AttrVal.valCount; j++ ) {
            if (   (!ExistsSidInSidHistory(&pAttr->AttrVal.pAVal[j],
                                           pDstSid))
                && (!ExistsSidInSidHistory(&pAttr->AttrVal.pAVal[j],
                                           pDstSidHistory)) ) {
                pModifyArg->FirstMod.AttrInf.AttrVal.pAVal[(*pulValCount)++] =
                                                    pAttr->AttrVal.pAVal[j];
            }
        }
    }

    return(ERROR_SUCCESS);
}

ULONG
IDL_DRSInheritSecurityIdentity(
    DRS_HANDLE              hDrs,
    DWORD                   dwInVersion,
    DRS_MSG_ADDSIDREQ       *pmsgIn,
    DWORD                   *pdwOutVersion,
    DRS_MSG_ADDSIDREPLY     *pmsgOut
    )
/*++

  Routine Description:

    Grabs SID and SID history from src principal and adds it to the SID
    history of the dst principal and deletes the src principal.  Both
    principals must be in the same domain such that the entire operation
    can be transacted.

    Auditing is performed since this operation can have a high security
    impact.

    The routine is called IDL_DRSInheritSecurityIdentity although it isn't
    truly a drs.idl entry point.  The name is chosen to highlight that the
    implementation should do all the same checks and logging as would a
    drs.idl entry point even though it comes across the wire on the
    IDL_DRSAddSidHistory entry point.

  Arguments:

    hDrs - Valid DRS_HANDLE from RPC run times.

    dwInVersion - Identifies union version in DRS_MSG_ADDSIDREQ.

    pmsgIn - Input argument block.

    pdwOutVersion - Receives union version in DRS_MSG_ADDSIDREPLY.

    pmsgOut - Receives return data.

  Return Value:

    WIN32 error code.

--*/
{
    THSTATE                     *pTHS = pTHStls;
    DWORD                       dsid = 0;
    DWORD                       ret = 0;
    BOOL                        fDbOpen = FALSE;
    BOOL                        fCommit = FALSE;
    DWORD                       dwErr = ERROR_INVALID_PARAMETER;
    DWORD                       xCode;
    CROSS_REF                   *pSrcCR, *pDstCR;
    BOOL                        fAdminSidPresent = FALSE;
    NTSTATUS                    status;
    BOOLEAN                     fMixedMode = TRUE;
    MODIFYARG                   modifyArg;
    ATTRVAL                     attrVal;
    BOOL                        fLog = FALSE;
    COMMARG                     commArg;
    ATTCACHE                    *rAC[3];
    DSNAME                      *pSrcDSName = NULL;
    DSNAME                      *pDstDSName = NULL;
    DWORD                       cb1, cb2;
    ULONG                       cAttsSrc = 0;
    ATTR                        *rAttsSrc = NULL;
    ULONG                       cAttsDst = 0;
    ATTR                        *pSrcSid = NULL;
    ATTR                        *pSrcSidHistory = NULL;
    ATTR                        *rAttsDst = NULL;
    ATTR                        *pDstSid = NULL;
    ATTR                        *pDstSidHistory = NULL;
    ATTR                        *pDstSamAcctName = NULL;
    WCHAR                       *pwszSamAcctName = NULL;
    DWORD                       i, j;
    ULONG                       mostBasicClass;
    REMOVEARG                   removeArg;
    ATTRTYP                     dstClass;
    NT4SID                      domainSid;
    DWORD                       srcRid, dstRid;
    RESOBJ                      *pSrcResObj = NULL;
    RESOBJ                      *pDstResObj = NULL;
 
    drsReferenceContext( hDrs, IDL_DRSINHERITSECURITYIDENTITY);
	__try { 

		// Since we have in args which were THAlloc'd we should have a THSTATE.
		Assert(pTHS);

		__try {
			// Assert all the things which caller (IDL_DRSAddSidHistory) should
			// have set up or verified for us.

			Assert(NULL != hDrs);
			Assert(NULL != pmsgIn);
			Assert(NULL != pmsgOut);
			Assert(NULL != pdwOutVersion);
			Assert(1 == *pdwOutVersion);
			Assert(ERROR_DS_INTERNAL_FAILURE == pmsgOut->V1.dwWin32Error);
			Assert(DS_ADDSID_FLAG_PRIVATE_DEL_SRC_OBJ & pmsgIn->V1.Flags);

			// Sanity check remaining arguments.

			if (    ( pmsgIn->V1.Flags & ~DS_ADDSID_FLAG_PRIVATE_DEL_SRC_OBJ )
					|| ( NULL != pmsgIn->V1.SrcDomain )
					|| ( NULL == pmsgIn->V1.SrcPrincipal )
					|| ( 0 == wcslen(pmsgIn->V1.SrcPrincipal) )
					|| ( 0 != pmsgIn->V1.SrcCredsUserLength )
					|| ( NULL != pmsgIn->V1.SrcCredsUser )
					|| ( 0 != pmsgIn->V1.SrcCredsDomainLength )
					|| ( NULL != pmsgIn->V1.SrcCredsDomain )
					|| ( 0 != pmsgIn->V1.SrcCredsPasswordLength )
					|| ( NULL != pmsgIn->V1.SrcCredsPassword )
					|| ( NULL != pmsgIn->V1.DstDomain )
					|| ( NULL == pmsgIn->V1.DstPrincipal )
					|| ( 0 == wcslen(pmsgIn->V1.DstPrincipal) ) ) {
				ret = ERROR_INVALID_PARAMETER;
				__leave;
			} 

			#define SetInheritSidError(err)                         \
			dwErr = pmsgOut->V1.dwWin32Error = err;         \
			dsid = (FILENO << 16) | __LINE__;

			// All we need for logging is valid SrcPrincipal and DstPrincipal args.

			fLog = TRUE;

			// Construct DSNAMEs for src and dst objects.

			cb1 = (DWORD)DSNameSizeFromLen(wcslen(pmsgIn->V1.SrcPrincipal));
			cb2 = (DWORD)DSNameSizeFromLen(wcslen(pmsgIn->V1.DstPrincipal));
			pSrcDSName = (DSNAME *) THAllocEx(pTHS, cb1);
			pDstDSName = (DSNAME *) THAllocEx(pTHS, cb2);

			if ( !pSrcDSName || !pDstDSName ) {
				SetInheritSidError(ERROR_NOT_ENOUGH_MEMORY);
				__leave;
			}

			pSrcDSName->structLen = cb1;
			wcscpy(pSrcDSName->StringName, pmsgIn->V1.SrcPrincipal);
			pSrcDSName->NameLen = wcslen(pmsgIn->V1.SrcPrincipal);

			pDstDSName->structLen = cb2;
			wcscpy(pDstDSName->StringName, pmsgIn->V1.DstPrincipal);
			pDstDSName->NameLen = wcslen(pmsgIn->V1.DstPrincipal);

			// Map objects to domains and verify they are in the same domain.

			InitCommarg(&commArg);
			commArg.Svccntl.dontUseCopy = TRUE;
			pSrcCR = FindBestCrossRef(pSrcDSName, &commArg);
			pDstCR = FindBestCrossRef(pDstDSName, &commArg);

			if ( !pSrcCR || !pDstCR || (pSrcCR != pDstCR) ) {
				SetInheritSidError(ERROR_INVALID_PARAMETER);
				__leave;
			}

			// Verify domain is writeable at this replica.

			if (    !gAnchor.pDomainDN
					|| !NameMatched(gAnchor.pDomainDN, pDstCR->pNC) ) {
				SetInheritSidError(ERROR_DS_MASTERDSA_REQUIRED);
				__leave;
			}

			// Verify existence of stuff we will need from pDstCR,

			if ( !pDstCR->pNC->SidLen || !pDstCR->NetbiosName ) {
				SetInheritSidError(ERROR_DS_INTERNAL_FAILURE);
				__leave;
			}

			// Verify auditing is enabled for destination domain.

			if ( dwErr = VerifyAuditingEnabled() ) {
				SetInheritSidError(dwErr);
				__leave;
			}

			// Verify caller is a member of domain admins for destination domain.

			if ( dwErr = VerifyCallerIsDomainAdminOrLocalAdmin(pTHS,
															   &pDstCR->pNC->Sid,
															   &fAdminSidPresent) ) {
				SetInheritSidError(dwErr);
				__leave;
			} else if ( !fAdminSidPresent ) {
				ForceFailureAuditOnDstDom(pmsgIn->V1.SrcPrincipal,
										  pDstCR->NetbiosName,
										  &pDstCR->pNC->Sid,
										  pmsgIn->V1.DstPrincipal,
										  pDstCR->NetbiosName);
				SetInheritSidError(ERROR_DS_INSUFF_ACCESS_RIGHTS);
				__leave;
			}

			// Verify destination domain is in native mode.

			status = SamIMixedDomain2((PSID) &pDstCR->pNC->Sid, &fMixedMode);

			if ( !NT_SUCCESS(status) ) {
				SetInheritSidError(RtlNtStatusToDosError(status));
				__leave;
			} else if ( fMixedMode ) {
				SetInheritSidError(ERROR_DS_DST_DOMAIN_NOT_NATIVE);
				__leave;
			}

			// Initialize thread state and open DB - this is not quite a no-op
			// if pTHS already exists.  I.e. It sets the caller type and refreshes
			// various things.

			if ( !(pTHS = InitTHSTATE(CALLERTYPE_NTDSAPI)) ) {
				SetInheritSidError(ERROR_DS_INTERNAL_FAILURE);
				__leave;
			}

			DBOpen2(TRUE, &pTHS->pDB);
			fDbOpen = TRUE;

			__try
				{
				// Obtain various ATTCACHE entries we will need.

				if (    !(rAC[0] = SCGetAttById(pTHS, ATT_OBJECT_SID))
						|| !(rAC[1] = SCGetAttById(pTHS, ATT_SID_HISTORY))
						|| !(rAC[2] = SCGetAttById(pTHS, ATT_SAM_ACCOUNT_NAME)) ) {
					SetInheritSidError(ERROR_DS_INTERNAL_FAILURE);
					__leave;
				}

				// Position on the source object.

				if ( DBFindDSName(pTHS->pDB, pSrcDSName) ) {
					SetInheritSidError(ERROR_INVALID_PARAMETER);
					__leave;
				}

				// Create src object RESOBJ which nets us class info.

				if ( !(pSrcResObj = CreateResObj(pTHS->pDB, pSrcDSName)) ) {
					SetInheritSidError(ERROR_DS_INTERNAL_FAILURE);
					__leave;
				}

				// Is this a security principal?

				mostBasicClass = SampDeriveMostBasicDsClass(
					pSrcResObj->MostSpecificObjClass);

				if (    (CLASS_USER != mostBasicClass)
						&& (CLASS_GROUP != mostBasicClass)
						&& (CLASS_COMPUTER != mostBasicClass) ) {
					SetInheritSidError(ERROR_INVALID_PARAMETER);
					__leave;
				}

				// Read various other source object properties.
				// Get everything in external form as we will write it back
				// later via LocalModify which expects external form arguments.

				if ( dwErr = DBGetMultipleAtts(pTHS->pDB, 3, rAC, NULL, NULL,
											   &cAttsSrc, &rAttsSrc,
											   DBGETMULTIPLEATTS_fEXTERNAL, 0) ) {
					SetInheritSidError(ERROR_DS_INTERNAL_FAILURE);
					__leave;
				}

				// See what we've got.

				for ( i = 0; i < cAttsSrc; i++ ) {
					switch ( rAttsSrc[i].attrTyp ) {
					case ATT_OBJECT_SID:    pSrcSid = &rAttsSrc[i];         break;
					case ATT_SID_HISTORY:   pSrcSidHistory = &rAttsSrc[i];  break;
					}
				}

				// It is a security principal, it better have a SID.

				if ( !pSrcSid ) {
					SetInheritSidError(ERROR_DS_INTERNAL_FAILURE);
					__leave;
				}

				// Delete source object now that we have its SIDs in hand.  Do
				// this with full security checking to insure caller is bumped
				// if he doesn't have delete rights.  The reason we delete before
				// adding SIDs to dst object is to avoid any duplicate SID
				// scenarios the core may check for.

				// We're still positioned on the src object and thus can call
				// CreateResObj directly.

				memset(&removeArg, 0, sizeof(removeArg));
				removeArg.pObject = pSrcDSName;
				memcpy(&removeArg.CommArg, &commArg, sizeof(commArg));
				removeArg.pResObj = pSrcResObj;

				if ( LocalRemove(pTHS, &removeArg) ) {
					SetInheritSidError(mapApiErrorToWin32(pTHS, pTHS->errCode));
					__leave;
				}

				// Now operate on dst object.  There is no problem if things fail
				// after this point although we've already deleted the src object
				// as the entire transaction is only committed if we get to the
				// end without errors.

				// Position at dst object.

				if ( DBFindDSName(pTHS->pDB, pDstDSName) ) {
					SetInheritSidError(ERROR_INVALID_PARAMETER);
					__leave;
				}

				// Create dst object RESOBJ which nets us class info.

				if ( !(pDstResObj = CreateResObj(pTHS->pDB, pDstDSName)) ) {
					SetInheritSidError(ERROR_DS_INTERNAL_FAILURE);
					__leave;
				}

				// Is this a security principal?

				mostBasicClass = SampDeriveMostBasicDsClass(
					pDstResObj->MostSpecificObjClass);

				if (    (CLASS_USER != mostBasicClass)
						&& (CLASS_GROUP != mostBasicClass)
						&& (CLASS_COMPUTER != mostBasicClass) ) {
					SetInheritSidError(ERROR_INVALID_PARAMETER);
					__leave;
				}

				// Read various other destination object properties.
				// Get everything in external form as we will write it back
				// later via LocalModify which expects external form arguments.

				if ( dwErr = DBGetMultipleAtts(pTHS->pDB, 3, rAC, NULL, NULL,
											   &cAttsDst, &rAttsDst,
											   DBGETMULTIPLEATTS_fEXTERNAL, 0) ) {
					SetInheritSidError(ERROR_DS_INTERNAL_FAILURE);
					__leave;
				}

				// See what we've got.

				for ( i = 0; i < cAttsDst; i++ ) {
					switch ( rAttsDst[i].attrTyp ) {
					case ATT_OBJECT_SID:
						pDstSid = &rAttsDst[i];
						break;
					case ATT_SID_HISTORY:
						pDstSidHistory = &rAttsDst[i];
						break;
					case ATT_SAM_ACCOUNT_NAME:
						pDstSamAcctName = &rAttsDst[i];
						break;
					}
				}

				// It is a security principal, it better have a SID.  Also
				// need SAM account name for logging.

				if ( !pDstSid || !pDstSamAcctName ) {
					SetInheritSidError(ERROR_DS_INTERNAL_FAILURE);
					__leave;
				}

				// Disallow operations on well known SIDs.

				SampSplitNT4SID((PNT4SID) pSrcSid->AttrVal.pAVal[0].pVal,
								&domainSid, &srcRid);
				SampSplitNT4SID((PNT4SID) pDstSid->AttrVal.pAVal[0].pVal,
								&domainSid, &dstRid);

				if (    (srcRid < SAMP_RESTRICTED_ACCOUNT_COUNT)
						|| (dstRid < SAMP_RESTRICTED_ACCOUNT_COUNT) ) {
					SetInheritSidError(ERROR_INVALID_PARAMETER);
					__leave;
				}

				// Src and dst may not be the same object.

				if ( RtlEqualSid(pSrcSid->AttrVal.pAVal[0].pVal,
								 pDstSid->AttrVal.pAVal[0].pVal) ) {
					SetInheritSidError(ERROR_INVALID_PARAMETER);
					__leave;
				}

				// Everything checks out.  Now add src object's SID and SID
				// history, if present, to dst object's SID history.  We
				// need to filter out duplicate values in order to avoid
				// ERROR_DS_ATT_VAL_ALREADY_EXISTS errors.

				memset(&modifyArg, 0, sizeof(modifyArg));
				modifyArg.pObject = pDstDSName;
				modifyArg.count = 1;
				modifyArg.FirstMod.choice = AT_CHOICE_ADD_VALUES;
				memcpy(&modifyArg.CommArg, &commArg, sizeof(commArg));
				modifyArg.pResObj = pDstResObj;

				if ( dwErr = BuildDstObjATTRMODLIST(pTHS,
													pSrcSid, pSrcSidHistory,
													pDstSid, pDstSidHistory,
													&modifyArg) ) {
					SetInheritSidError(dwErr);
					__leave;
				}

				// Perform the write as fDSA as all checks have passed and
				// ATT_SID_HISTORY is protected otherwise.

				pTHS->fDSA = TRUE;
				__try {
					LocalModify(pTHS, &modifyArg);
				} __finally {
					pTHS->fDSA = FALSE;
				}

				if ( pTHS->errCode ) {
					SetInheritSidError(mapApiErrorToWin32(pTHS, pTHS->errCode));
					__leave;
				}

				// Set up for auditing.  Need null terminated version of
				// destination object's SAM account name.

				cb1 = pDstSamAcctName->AttrVal.pAVal[0].valLen + sizeof(WCHAR);
				pwszSamAcctName = (WCHAR *) THAllocEx(pTHS, cb1);
				memcpy(pwszSamAcctName,
					   pDstSamAcctName->AttrVal.pAVal[0].pVal,
					   pDstSamAcctName->AttrVal.pAVal[0].valLen);
				pwszSamAcctName[(cb1 / sizeof(WCHAR)) - 1] = L'\0';

				// Force local audit and fail entire operation if we can't do it.

				if ( dwErr = ForceSuccessAuditOnDstObj(
					pmsgIn->V1.SrcPrincipal,
					pDstCR->NetbiosName,
					(PNT4SID) pSrcSid->AttrVal.pAVal[0].pVal,
					(PNT4SID) pDstSid->AttrVal.pAVal[0].pVal,
					pwszSamAcctName,
					pDstCR->NetbiosName) ) {
					SetInheritSidError(dwErr);
					__leave;
				}

				fCommit = TRUE;
			}
			__finally
				{
				if ( fDbOpen )
					{
					DBClose(pTHS->pDB, fCommit);
				}
			}

			pmsgOut->V1.dwWin32Error = dwErr;

			// Miscellaneous cleanup.

			if ( rAttsSrc ) {
				if ( pSrcSid ) {
					THFreeATTR(pTHS, pSrcSid, FALSE);
				}
				if ( pSrcSidHistory ) {
					THFreeATTR(pTHS, pSrcSidHistory, FALSE);
				}
				THFreeEx(pTHS, rAttsSrc);
			}

			if ( rAttsDst ) {
				if ( pDstSid ) {
					THFreeATTR(pTHS, pDstSid, FALSE);
				}
				if ( pDstSidHistory ) {
					THFreeATTR(pTHS, pDstSidHistory, FALSE);
				}
				if ( pDstSamAcctName ) {
					THFreeATTR(pTHS, pDstSamAcctName, FALSE);
				}
				THFreeEx(pTHS, rAttsDst);
			}

			if ( pSrcDSName ) {
				THFreeEx(pTHS, pSrcDSName);
			}

			if ( pDstDSName ) {
				THFreeEx(pTHS, pDstDSName);
			}

			if ( pSrcResObj ) {
				THFreeEx(pTHS, pSrcResObj);
			}

			if ( pDstResObj ) {
				THFreeEx(pTHS, pDstResObj);
			}

			if ( pwszSamAcctName ) {
				THFreeEx(pTHS, pwszSamAcctName);
			}
		}
		__except(HandleMostExceptions(xCode = GetExceptionCode()))
		{
			ret = DsaExceptionToWin32(xCode);
		}

		// Log to Directory Service event log.  Log exception error if there
		// is one, operation error otherwise.
		if ( pTHS ) {
			LogEvent(DS_EVENT_CAT_DIRECTORY_ACCESS,
					 ( !ret && !dwErr )
					 ? DS_EVENT_SEV_MINIMAL
					 : DS_EVENT_SEV_ALWAYS,
				( !ret && !dwErr )
			? DIRLOG_INHERIT_SECURITY_IDENTITY_SUCCEEDED
				: DIRLOG_INHERIT_SECURITY_IDENTITY_FAILURE,
				( fLog )
			? szInsertWC(pmsgIn->V1.SrcPrincipal)
			: szInsertWC(L"?"),
						 ( !ret && !dwErr )
					 ? (( fLog )
						? szInsertWC(pmsgIn->V1.SrcPrincipal)
						: szInsertWC(L"?"))
					 : szInsertHex(dsid),
					szInsertInt(ret ? ret : dwErr));
		}
	}
	__finally { 
		drsDereferenceContext( hDrs, IDL_DRSINHERITSECURITYIDENTITY );
	}
	return(ret);
}

DWORD
BuildCheckAndUpdateArgs(
    THSTATE                     *pTHS,                      // in
    BOOL                        fSrcIsW2K,                  // in
    WCHAR                       *SrcDomainController,       // in
    WCHAR                       *SrcDomain,                 // in
    SEC_WINNT_AUTH_IDENTITY_W   *pAuthInfo,                 // in
    NT4SID                      *pSrcObjSid,                // in
    DWORD                       Flags,                      // in
    BOOL                        NeedImpersonation,          // in
    DWORD                       *pcNames,                   // out
    WCHAR                       ***prpNames,                // out
    ATTR                        **ppSrcSid,                 // out
    ATTR                        **ppSrcSidHistory,          // out
    DWORD                       *pDsid,                     // out
    BOOL                        *pImpersonating             // out
    )
/*++

  Description:

    This routine constructs the arguments required for SID verification
    and local database modification.  It additionally reads the source
    object's ATT_SID_HISTORY if the source is W2K or better.

    The ATT_SID_HISTORY is read using LDAP as opposed to IDL_DRSVerifyNames
    over RPC.  This is because we may not have trust with the source domain
    and the DRS binding handle cache mechanism does not support per-handle
    credentials outside the install-time scenario.

    All OUT parameters are THAlloc'd and thus need to be THFree'd by caller.

  Arguments:

    pTHS - Valid THSTATE pointer.

    fSrcIsW2K - Indicates whether SrcDomainController is W2K or better and
        thus ATT_SID_HISTORY should be obtained via LDAP.

    SrcDomainController - DNS Name of domain controller to which the LDAP
        connection is to be made.  This should be identical to what the
        caller used for the SamConnectWithCreds call. It must be the
        dns name for LDAP_OPT_SIGN to work. Ignored if src is NT4.

    SrcDomain - DNS Name of domain to which the LDAP connection is
        to be made. It must be the dns name for LDAP_OPT_SIGN to work.
        Ignored if src is NT4.

    pAuthInfo - Explicit credentials to use for authentication.

    pSrcObjSid - Source object's ATT_OBJECT_SID, i.e. primary SID.

    Flags - From client call

    NeedImpersonation - TRUE if need to impersonate client

    pcNames - Receives count of SIDs in prpNames.

    prpNames - Receives array of string-ized SIDs which can subsequently
        be handed directly to DsCrackNames.  This array minimally includes
        the source object's ATT_OBJECT_SID and additionally includes all
        values from the source object's ATT_SID_HSITORY, if any exist.

    ppSrcSid - Receives ATTR representing the source object's ATT_OBJECT_SID.

    ppSrcSidHistory - Receives ATTR representing the source object's
        ATT_SID_HISTORY if it exists, NULL otherwise.

    pDsid - Receives DSID of failing line on error, zero otherwise.

    pImpersonating - Set to TRUE if impersonation is active

  Return Value:

    Win32 error code.

--*/
{
    LDAP            *hLdap = NULL;
    DWORD           ret = ERROR_SUCCESS;
    DWORD           i, dwErr;
    NTSTATUS        status;
    ULONG           ver = LDAP_VERSION3;
    ULONG           on = PtrToUlong(LDAP_OPT_ON);
    UNICODE_STRING  uniStr = { 0, 0, NULL };
    WCHAR           *pSearchBase = NULL;
    WCHAR           *pTmp;
    WCHAR           *attrs[2] = { L"sidHistory", NULL };
    PLDAPMessage    ldapMsg = NULL;
    PLDAPMessage    ldapEntry = NULL;
    PLDAP_BERVAL    *ldapBVals = NULL;
    ULONG           cVals = 0;
    DWORD           cBytes;
    UCHAR           uc0, uc1;

    *pcNames = 0;
    *prpNames = NULL;
    *ppSrcSid = NULL;
    *ppSrcSidHistory = NULL;
    *pDsid = 0;

#define SetReadSidHistoryError(err)                 \
        ret = err;                                  \
        *pDsid = (FILENO << 16) | __LINE__;

    __try {

        if ( fSrcIsW2K ) {
            // Source is W2K or better and thus might have a SID history.

            // Fail if a secure ldap port could not be opened
            if (    !(hLdap = ldap_initW(SrcDomainController, LDAP_PORT))
                 || (dwErr = ldap_set_option(hLdap, LDAP_OPT_VERSION, &ver))
                 || (dwErr = ldap_set_option(hLdap, LDAP_OPT_SIGN, &on))
                 || (dwErr = ldap_set_option(hLdap, LDAP_OPT_AREC_EXCLUSIVE, &on))
                 || (dwErr = ldap_set_optionW(hLdap, LDAP_OPT_DNSDOMAIN_NAME, &SrcDomain)) ) {
                SetReadSidHistoryError(ERROR_DS_UNAVAILABLE);
                __leave;
            }

            // No creds; impersonate caller
            if (NeedImpersonation) {
                // clear client context on the thread state since we are going to change context
                AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);
                if (dwErr = RpcImpersonateClient(NULL)) {
                    SetReadSidHistoryError(dwErr);
                    __leave;
                }
                *pImpersonating = TRUE;
            }

            // Authenticate using explicit credentials.
            if ( dwErr = ldap_bind_sW(hLdap, NULL,
                                      (NeedImpersonation) ? NULL : (PWCHAR) pAuthInfo,
                                      LDAP_AUTH_NEGOTIATE) ) {
                DPRINT1(0, "ldap_bind_sW() %08x\n", dwErr);
                SetReadSidHistoryError(ERROR_DS_INAPPROPRIATE_AUTH);
                __leave;
            }
            // stop impersonation
            if (*pImpersonating) {
                *pImpersonating = FALSE;
                RpcRevertToSelf();
            }

            // Construct <SID=xxx> value which we will use as search base
            // for reading ATT_SID_HISTORY.

            cBytes = RtlLengthSid(pSrcObjSid);
            pSearchBase = (WCHAR *) THAllocEx(pTHS, sizeof(WCHAR) *
                                (   wcslen(L"<SID=>")   // key words, etc.
                                  + 1                   // null terminator
                                  + (2 * cBytes) ) );   // 2 hex chars per byte
            if ( !pSearchBase ) {
                SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
                __leave;
            }

            wcscpy(pSearchBase, L"<SID=");
            pTmp = pSearchBase + 5;
            for ( i = 0; i < cBytes; i++ ) {
                uc0 = ((PUCHAR) pSrcObjSid)[i] & 0x0f;
                uc1 = (((PUCHAR) pSrcObjSid)[i] >> 4) & 0x0f;
                *pTmp++ = ((uc1 < 0xa) ? L'0' + uc1 : L'A' + (uc1 - 0xa));
                *pTmp++ = ((uc0 < 0xa) ? L'0' + uc0 : L'A' + (uc0 - 0xa));
            }
            *pTmp = L'>';

            // Read ATT_SID_HISTORY off the source object.

            if ( dwErr = ldap_search_ext_sW(hLdap, pSearchBase,
                                            LDAP_SCOPE_BASE, L"objectClass=*",
                                            attrs, 0, NULL, NULL,
                                            NULL, 10000, &ldapMsg) ) {
                SetReadSidHistoryError(LdapMapErrorToWin32(dwErr));
                __leave;
            }

            if ( ldapEntry = ldap_first_entry(hLdap, ldapMsg) ) {
                if ( ldapBVals = ldap_get_values_lenW(hLdap, ldapMsg,
                                                      attrs[0]) ) {
                    cVals = ldap_count_values_len(ldapBVals);
                }
            }
        }

        // cVals now holds the count of values in the source object's
        // ATT_SID_HISTORY and the values are in ldapBVals[i].bv_val.
        // Our caller verified that the RPC client was an admin in the
        // source domain.  Thus we assume that if no values were returned
        // it is not due to insufficient rights.  This is not a totally
        // safe assumption of course, but the best we can do.

        // Construct the out args.  The total number of SIDs is (cVals+1)
        // where the +1 is for the original ATT_OBJECT_SID.
        // Do prpNames first.

        *prpNames = (PWCHAR *) THAllocEx(pTHS, sizeof(PWCHAR) * (cVals+1));
        if ( !*prpNames ) {
            SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }

        // Put ATT_OBJECT_SID in first slot.

        status = RtlConvertSidToUnicodeString(&uniStr, pSrcObjSid, TRUE);

        if ( !NT_SUCCESS(status) ) {
            SetReadSidHistoryError(RtlNtStatusToDosError(status));
            __leave;
        }

        cBytes = sizeof(WCHAR) * (wcslen(uniStr.Buffer) + 1);
        (*prpNames)[0] = (PWCHAR) THAllocEx(pTHS, cBytes);
        if ( !(*prpNames)[0] ) {
            SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }
        memcpy((*prpNames)[0], uniStr.Buffer, cBytes);
        *pcNames += 1;

        // Put ATT_SID_HISTORY in subsequent slots.

        for ( i = 0; i < cVals; i++ ) {
            // Convert ith SID in SID history to string for name cracking.
            if ( uniStr.Buffer ) {
                RtlFreeHeap(RtlProcessHeap(), 0, uniStr.Buffer);
                uniStr.Buffer = NULL;
            }
            status = RtlConvertSidToUnicodeString(&uniStr,
                                                  ldapBVals[i]->bv_val, TRUE);

            if ( !NT_SUCCESS(status) ) {
                SetReadSidHistoryError(RtlNtStatusToDosError(status));
                __leave;
            }

            cBytes = sizeof(WCHAR) * (wcslen(uniStr.Buffer) + 1);
            (*prpNames)[i+1] = (PWCHAR) THAllocEx(pTHS, cBytes);
            if ( !(*prpNames)[i+1] ) {
                SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
                __leave;
            }
            memcpy((*prpNames)[i+1], uniStr.Buffer, cBytes);
            *pcNames += 1;
        }

        // Make ppSrcSid.

        *ppSrcSid = (ATTR *) THAllocEx(pTHS, sizeof(ATTR));
        if ( !(*ppSrcSid) ) {
            SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }

        (*ppSrcSid)->attrTyp = ATT_OBJECT_SID;
        (*ppSrcSid)->AttrVal.pAVal = (ATTRVAL *) THAllocEx(
                                                    pTHS, sizeof(ATTRVAL));
        if ( !(*ppSrcSid)->AttrVal.pAVal ) {
            SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }
        (*ppSrcSid)->AttrVal.valCount = 1;

        cBytes = RtlLengthSid(pSrcObjSid);
        (*ppSrcSid)->AttrVal.pAVal[0].pVal = (UCHAR *) THAllocEx(pTHS, cBytes);
        if ( !(*ppSrcSid)->AttrVal.pAVal[0].pVal ) {
            SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }
        (*ppSrcSid)->AttrVal.pAVal[0].valLen = cBytes;
        memcpy((*ppSrcSid)->AttrVal.pAVal[0].pVal, pSrcObjSid, cBytes);

        // Make ppSrcSidHistory.

        if ( cVals ) {
            *ppSrcSidHistory = (ATTR *) THAllocEx(pTHS, sizeof(ATTR));
            if ( !(*ppSrcSidHistory) ) {
                SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
                __leave;
            }

            (*ppSrcSidHistory)->attrTyp = ATT_SID_HISTORY;
            (*ppSrcSidHistory)->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS,
                                                    cVals * sizeof(ATTRVAL));
            if ( !(*ppSrcSidHistory)->AttrVal.pAVal ) {
                SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
                __leave;
            }
            (*ppSrcSidHistory)->AttrVal.valCount = cVals;

            for ( i = 0; i < cVals; i++ ) {
                cBytes = RtlLengthSid(ldapBVals[i]->bv_val);
                (*ppSrcSidHistory)->AttrVal.pAVal[i].pVal =
                                            (UCHAR *) THAllocEx(pTHS, cBytes);
                if ( !(*ppSrcSidHistory)->AttrVal.pAVal[i].pVal ) {
                    SetReadSidHistoryError(ERROR_NOT_ENOUGH_MEMORY);
                    __leave;
                }
                (*ppSrcSidHistory)->AttrVal.pAVal[i].valLen = cBytes;
                memcpy((*ppSrcSidHistory)->AttrVal.pAVal[i].pVal,
                       ldapBVals[i]->bv_val, cBytes);
            }
        }

        Assert(!ret);
    } __finally {

        if ( hLdap ) {
            ldap_unbind(hLdap);
        }

        if ( uniStr.Buffer ) {
            RtlFreeHeap(RtlProcessHeap(), 0, uniStr.Buffer);
        }

        if ( pSearchBase ) {
            THFreeEx(pTHS, pSearchBase);
        }

        if ( ldapBVals ) {
            ldap_value_free_len(ldapBVals);
        }

        if ( ldapMsg ) {
            ldap_msgfree(ldapMsg);
        }

        // Clean up out args on error.
        if ( ret ) {
            if ( *prpNames ) {
                for ( i = 0; i < *pcNames; i++ ) {
                    if ( (*prpNames)[i] ) {
                        THFreeEx(pTHS, (*prpNames)[i]);
                    }
                }
                THFreeEx(pTHS, (*prpNames));
            }
            THFreeATTR(pTHS, *ppSrcSid, TRUE);
            THFreeATTR(pTHS, *ppSrcSidHistory, TRUE);
            *pcNames = 0;
            *prpNames = NULL;
            *ppSrcSid = NULL;
            *ppSrcSidHistory = NULL;
        }
    }

    return(ret);
}

DWORD
VerifySrcAuditingEnabledAndGetFlatName(
    IN  UNICODE_STRING  *usSrcDC,
    OUT WCHAR           **pSrcDomainFlatName,
    OUT DWORD           *pdsid
    )
/*++

  Description:

    Verify auditing is enabled at the Src DC and fetch the SrcDomain's
    NetBIOS name (flat name) using the same LsaQuery API.

    CALLER IS RESPONSIBLE FOR IMPERSONATION!

    Since a domain admin on the SrcDc can surely query audit info
    an access denied must be caused by an outstanding NetUseAdd()
    by some code running as LocalSystem (or as the domain admin?).
    The LsaOpenPolicy() is using the cached creds from that NetUseAdd()
    instead of the creds from the impersonation. Map the error
    to something that may help the user diagnose the problem.

  Arguments:

    usSrcDC - name of Src DC
    pdsid   - Inform caller of line number of failure

  Return Value:

    WIN32 return code.

--*/
{
    THSTATE                     *pTHS = pTHStls;
    DWORD                       dwErr;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           policy;
    WCHAR                       *FlatName;
    HANDLE                      hPolicy = INVALID_HANDLE_VALUE;
    POLICY_AUDIT_EVENTS_INFO    *pPolicy = NULL;
    POLICY_PRIMARY_DOMAIN_INFO  *pDomain = NULL;

    // Since we have IN args which were THAlloc'd we should have a THSTATE.
    Assert(pTHS);

    // initialize return value
    *pSrcDomainFlatName = NULL;

    // Open the remote LSA
    InitializeObjectAttributes(&policy,
                               NULL,             // Name
                               0,                // Attributes
                               NULL,             // Root
                               NULL);            // Security Descriptor

    status = LsaOpenPolicy(usSrcDC,
                           &policy,
                             POLICY_VIEW_AUDIT_INFORMATION
                           | POLICY_VIEW_LOCAL_INFORMATION,
                           &hPolicy);
    if (!NT_SUCCESS(status)) {
        // Since a domain admin on the SrcDc can surely query audit info
        // this access denied must be caused by an outstanding NetUseAdd()
        // by some code running as LocalSystem (or as the domain admin?).
        // The LsaOpenPolicy() is using the cached creds from that NetUseAdd()
        // instead of the creds from the impersonation. Map the error
        // to something that may help the user diagnose the problem.
        dwErr = RtlNtStatusToDosError(status);
        SetDsid(pdsid);
        // 390672 - Security guys have suggested that I not map this error
        // if (dwErr == ERROR_ACCESS_DENIED) {
            // dwErr = ERROR_SESSION_CREDENTIAL_CONFLICT;
        // }
        goto cleanup;
    }

    // Fetch the auditing info from the src server
    status = LsaQueryInformationPolicy(hPolicy,
                                       PolicyAuditEventsInformation,
                                       &pPolicy);
    if (!NT_SUCCESS(status)) {
        dwErr = RtlNtStatusToDosError(status);
        SetDsid(pdsid);
        goto cleanup;
    }

    // Verify auditing is enabled
    if ( pPolicy->AuditingMode
            &&
         (pPolicy->EventAuditingOptions[AuditCategoryAccountManagement]
                                           & POLICY_AUDIT_EVENT_SUCCESS)
            &&
        (pPolicy->EventAuditingOptions[AuditCategoryAccountManagement]
                                          & POLICY_AUDIT_EVENT_FAILURE) ) {
        dwErr = ERROR_SUCCESS;
    } else {
        dwErr = ERROR_DS_SOURCE_AUDITING_NOT_ENABLED;
        SetDsid(pdsid);
        goto cleanup;
    }

    // Fetch the domain info from the src server
    status = LsaQueryInformationPolicy(hPolicy,
                                       PolicyPrimaryDomainInformation,
                                       &pDomain);
    if (!NT_SUCCESS(status)) {
        dwErr = RtlNtStatusToDosError(status);
        SetDsid(pdsid);
        goto cleanup;
    }
    Assert(pDomain->Name.Length && pDomain->Name.Buffer);

    // Create the name SrcDomainFlatName$$$
    FlatName = THAllocEx(pTHS,
                         pDomain->Name.Length +
                         ((wcslen(L"$$$") + 1) * sizeof(WCHAR)));
    memcpy(FlatName, pDomain->Name.Buffer, pDomain->Name.Length);
    *(FlatName + (pDomain->Name.Length / sizeof(WCHAR))) = L'\0';
    wcscat(FlatName, L"$$$");
    *pSrcDomainFlatName = FlatName;

    // SUCCESS
    dwErr = ERROR_SUCCESS;

cleanup:
    // close policy
    if (hPolicy && hPolicy != INVALID_HANDLE_VALUE) {
        status = LsaClose(hPolicy);
        if (!NT_SUCCESS(status) && ERROR_SUCCESS == dwErr) {
            dwErr = RtlNtStatusToDosError(status);
            SetDsid(pdsid);
        }
    }
    if (pPolicy) {
        LsaFreeMemory(pPolicy);
    }
    if (pDomain) {
        LsaFreeMemory(pDomain);
    }

    return(dwErr);
}

DWORD
VerifySrcIsSP4OrGreater(
    IN  BOOL    fSrcIsW2K,
    IN  PWCHAR  SrcDc,
    OUT DWORD   *pdsid
    )
/*++

  Description:

    Verify SrcDomain is SP4 or greater.
    CALLER IS RESPONSIBLE FOR IMPERSONATION!

  Arguments:

    fSrcIsW2K - SrcDc is NT5?
    SrcDC     - name of Src DC (not UNICODE_STRING)
    pdsid     - Inform caller of line number of failure

  Return Value:

    WIN32 return code.

--*/
{
    THSTATE *pTHS = pTHStls;
    DWORD   dwErr;
    WCHAR   *pwszCSDVersion = NULL;
    HKEY    hRemoteKey = 0;
    HKEY    hVersionKey = 0;
    PWCHAR  CSDVersion;
    BOOL    CSDVersionOk;
    DWORD   ValType;
    DWORD   ValLen;

    // NT5; definitely SP4 or greater
    if (fSrcIsW2K) {
        dwErr = 0;
        goto cleanup;
    }

    // Is the NT4 computer at least Service Pack 4?

    // connect to the SrcDc
    if (dwErr = RegConnectRegistryW(SrcDc,
                                    HKEY_LOCAL_MACHINE,
                                    &hRemoteKey)) {
        SetDsid(pdsid);
        goto cleanup;
    }
    if (dwErr = RegOpenKeyExW(hRemoteKey,
                              L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion",
                              0,
                              KEY_QUERY_VALUE,
                              &hVersionKey)) {
        SetDsid(pdsid);
        goto cleanup;
    }
    // Get the length of the service pack version
    ValLen = 0;
    if (dwErr = RegQueryValueExW(hVersionKey,
                                 L"CSDVersion",
                                 NULL,
                                 &ValType,
                                 NULL,
                                 &ValLen)) {
        SetDsid(pdsid);
        goto cleanup;
    }
    // Get the service pack version
    CSDVersionOk = FALSE;
    if (ValLen) {
        pwszCSDVersion = THAllocEx(pTHS, ValLen);
        if (dwErr = RegQueryValueExW(hVersionKey,
                                     L"CSDVersion",
                                     NULL,
                                     &ValType,
                                     (PCHAR)pwszCSDVersion,
                                     &ValLen)) {
            SetDsid(pdsid);
            goto cleanup;
        }
        if (ValType == REG_SZ && ValLen) {
            // Check for not Service Pack 0, 1, 2, and 3 (hence >= SP4)
            CSDVersionOk = (   _wcsicmp(pwszCSDVersion, L"Service Pack 0")
                            && _wcsicmp(pwszCSDVersion, L"Service Pack 1")
                            && _wcsicmp(pwszCSDVersion, L"Service Pack 2")
                            && _wcsicmp(pwszCSDVersion, L"Service Pack 3"));
        }
    }
    if (!CSDVersionOk) {
        dwErr = ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER;
        SetDsid(pdsid);
        goto cleanup;
    }

cleanup:
    // This error code is more useful than the generic errors 
    // returned by the individual functions. A developer then
    // uses the DSID in the eventlog to identify which function
    // actually failed.
    if (dwErr) {
        dwErr = ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER;
    }

    if (pwszCSDVersion) {
        THFreeEx(pTHS, pwszCSDVersion);
    }
    if (hRemoteKey) {
        RegCloseKey(hRemoteKey);
    }
    if (hVersionKey) {
        RegCloseKey(hVersionKey);
    }

    return(dwErr);
}

DWORD
VerifyIsPDC(
    IN  PWCHAR  DC,
    OUT DWORD   *pdsid
    )
/*++

  Description:

    Verify DC is a PDC
    CALLER IS RESPONSIBLE FOR IMPERSONATION!

  Arguments:

    DC - name of DC (not UNICODE_STRING)
    pdsid - Inform caller of line number of failure

  Return Value:

    WIN32 return code.

--*/
{
    DWORD              dwErr;
    USER_MODALS_INFO_1 *Role;

    // Get DC's role (good for both NT4 and NT5 DCs)
    if (dwErr = NetUserModalsGet(DC,
                                 1,
                                 (PUCHAR *)&Role) ) {

        // NetUserModalsGet returns mixed mode error codes; yuk!
        if (dwErr == NERR_InvalidComputer) {
            dwErr = ERROR_INVALID_COMPUTERNAME;
        }
        SetDsid(pdsid);
        return (dwErr);
    }

    // PREFIX: claims Role may be NULL.
    if (NULL == Role) {
        SetDsid(pdsid);
        return (ERROR_INVALID_DOMAIN_ROLE);
    }

    // Must be PDC
    if (Role->usrmod1_role != UAS_ROLE_PRIMARY) {
        dwErr = ERROR_INVALID_DOMAIN_ROLE;
        SetDsid(pdsid);
    }
    NetApiBufferFree(Role);
    return (dwErr);
}

DWORD
ForceAuditOnSrcObj(
    IN  WCHAR   *SrcDc,
    IN  NT4SID  *pSrcObjSid,
    IN  WCHAR   *pSrcDomainFlatName,
    OUT DWORD   *pdsid
    )
/*++

  Description:

    Force audit on src dc by adding the src object's sid to the
    SrcDomainFlatName$$$ group on the SrcDc and then deleting it.

    This has the added benefit of requiring the src admin
    to create the SrcDomainFlatName$$$ group before Addsid will
    steal sids from the SrcDomain. And it leaves a much more
    obvious audit trail.

    CALLER IS RESPONSIBLE FOR IMPERSONATION!

  Arguments:

    SrcDc              - src dc
    pSrcObjSid         - Object sid of src object (sid being stolen)
    pSrcDomainFlatName - NetBIOS name of src domain
    pdsid              - Inform caller of line number of failure

  Return Value:

    WIN32 return code.

--*/
{
    DWORD                       dwErr;
    LOCALGROUP_MEMBERS_INFO_0   Members;

    // Add src object sid to SrcDomainFlatName$$$ group on SrcDc
    memset(&Members, 0, sizeof(Members));
    Members.lgrmi0_sid = pSrcObjSid;
    if (dwErr = NetLocalGroupAddMembers(SrcDc,
                                        pSrcDomainFlatName,
                                        0,
                                        (PUCHAR)&Members,
                                        1) ) {
        SetDsid(pdsid);
        // NetLocalGroupAddMembers returns mixed mode error codes; yuk!
        if (dwErr == NERR_GroupNotFound) {
            dwErr = ERROR_NO_SUCH_ALIAS;
        }

        // These errors occur when attempting to add a Local Group
        // to SrcDomainFlatName$$$ when SrcDc is NT4 or NT5 in Mixed
        // Mode. Ignore since it is safe to clone the sids of
        // local groups without auditing.
        if (   dwErr == ERROR_INVALID_MEMBER
            || dwErr == ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN ) {
            dwErr = ERROR_SUCCESS;
        }
        return (dwErr);
    }

    // Del src object sid from SrcDomainFlatName$$$ group on SrcDc
    if (dwErr = NetLocalGroupDelMembers(SrcDc,
                                        pSrcDomainFlatName,
                                        0,
                                        (PUCHAR)&Members,
                                        1) ) {
        SetDsid(pdsid);
        // NetLocalGroupDelMembers returns mixed mode error codes; yuk!
        if (dwErr == NERR_GroupNotFound) {
            dwErr = ERROR_NO_SUCH_ALIAS;
        }
    }

    return(dwErr);
}

DWORD
ImpersonateSrcAdmin(
    IN  SEC_WINNT_AUTH_IDENTITY_W   *pauthInfo,
    IN  BOOL                        NeedImpersonation,
    OUT DWORD                       *pdsid,
    OUT BOOL                        *pImpersonating,
    OUT HANDLE                      *phToken
    )
/*++

  Description:

    Impersonate implicit or explicit Src creds.
    Call UnimpersonateSrcAdmin to undo.

  Arguments:

    pauthInfo         - Contains counted strings for dom, user, and password
    NeedImpersonation - Set to TRUE if client impersonation is needed
    pdsid             - Inform caller of line number of failure
    pImpersonating    - Set to TRUE if client impersonation is still active
    phToken           - pointer to HANDLE for logon/impersonation token

  Return Value:

    WIN32 return code.

--*/
{
    THSTATE *pTHS = pTHStls;
    DWORD   dwErr;
    WCHAR   *pwszSrcUser = NULL;
    WCHAR   *pwszSrcDomain = NULL;
    WCHAR   *pwszSrcPassword = NULL;
    HANDLE  hToken = INVALID_HANDLE_VALUE;

    // Since we have IN args which were THAlloc'd we should have a THSTATE.
    Assert(pTHS);

    // Not impersonating anyone at the moment
    *phToken = INVALID_HANDLE_VALUE;

    // No creds; impersonate caller
    if (NeedImpersonation) {
        // clear client context on the thread state since we are going to change context
        AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);
        dwErr = RpcImpersonateClient(NULL);
        if (dwErr) {
            SetDsid(pdsid);
        } else {
            *pImpersonating = TRUE;
        }
        goto cleanup;
    }

    // Explicit creds; impersonate logon user

    // Convert the counted strings into null-terminated strings

    // User
    if (pauthInfo->UserLength) {
        pwszSrcUser = THAllocEx(pTHS,
                                (pauthInfo->UserLength + 1) * sizeof(WCHAR));
        memcpy(pwszSrcUser, pauthInfo->User, pauthInfo->UserLength * sizeof(WCHAR));
        pwszSrcUser[pauthInfo->UserLength] = L'\0';
    }
    // Domain
    if (pauthInfo->DomainLength) {
        pwszSrcDomain = THAllocEx(pTHS,
                                (pauthInfo->DomainLength + 1) * sizeof(WCHAR));
        memcpy(pwszSrcDomain, pauthInfo->Domain, pauthInfo->DomainLength * sizeof(WCHAR));
        pwszSrcDomain[pauthInfo->DomainLength] = L'\0';
    }
    // Password
    if (pauthInfo->PasswordLength) {
        pwszSrcPassword = THAllocEx(pTHS,
                                (pauthInfo->PasswordLength + 1) * sizeof(WCHAR));
        memcpy(pwszSrcPassword, pauthInfo->Password, pauthInfo->PasswordLength * sizeof(WCHAR));
        pwszSrcPassword[pauthInfo->PasswordLength] = L'\0';
    }

    // Establish credentials for later calls (eg, LsaOpenPolicy())
    if (!LogonUserW(pwszSrcUser,
                    pwszSrcDomain,
                    pwszSrcPassword,
                    LOGON32_LOGON_NEW_CREDENTIALS,
                    LOGON32_PROVIDER_WINNT50,
                    &hToken)) {
        dwErr = GetLastError();
        SetDsid(pdsid);
        goto cleanup;
    }
    // clear client context on the thread state since we are going to change context
    AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);
    if (!ImpersonateLoggedOnUser(hToken)) {
        dwErr = GetLastError();
        SetDsid(pdsid);
        goto cleanup;
    }

    // SUCCESSFUL IMPERSONATION
    dwErr = ERROR_SUCCESS;
    *phToken = hToken;
    hToken = INVALID_HANDLE_VALUE;

cleanup:
    // free the null-terminated strings
    if (pwszSrcUser) {
        THFreeEx(pTHS, pwszSrcUser);
    }
    if (pwszSrcDomain) {
        THFreeEx(pTHS, pwszSrcDomain);
    }
    if (pwszSrcPassword) {
        THFreeEx(pTHS, pwszSrcPassword);
    }
    if (hToken && hToken != INVALID_HANDLE_VALUE) {
        CloseHandle(hToken);
    }
    return(dwErr);
}

DWORD
UnimpersonateSrcAdmin(
    IN  BOOL        NeedImpersonation,
    OUT DWORD       *pdsid,
    IN OUT BOOL     *pImpersonating,
    IN OUT HANDLE   *phToken
    )
/*++

  Description:

    Stop impersonation

  Arguments:

    NeedImpersonation - Set to TRUE if client impersonation is needed
    pdsid             - Inform caller of line number of failure
    pImpersonating    - Set to TRUE if client impersonation is still active
    phToken           - impersonation/logon handle

  Return Value:

    WIN32 return code.

--*/
{
    DWORD   dwErr = 0;

    // stop impersonation (NULL creds)
    if (*pImpersonating) {
        *pImpersonating = FALSE;
        if (dwErr = RpcRevertToSelf()) {
            SetDsid(pdsid);
        }
    }

    // stop impersonation (explicit creds)
    if (*phToken && *phToken != INVALID_HANDLE_VALUE) {
        if (!RevertToSelf()) {
            dwErr = GetLastError();
            SetDsid(pdsid);
        }
        if (!CloseHandle(*phToken)) {
            if (!dwErr) {
                dwErr = GetLastError();
                SetDsid(pdsid);
            }
        } else {
            *phToken = INVALID_HANDLE_VALUE;
        }
    }
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dbsyntax.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dbsyntax.c
//
//--------------------------------------------------------------------------


#include <NTDSpch.h>
#pragma  hdrstop


#include <dsjet.h>
#include <ntrtl.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <mdglobal.h>                   // For dsatools.h
#include <dbglobal.h>                   //
#include <dsatools.h>                   // For pTHStls
#include <dsexcept.h>
#include <attids.h>
#include <crypto\md5.h>

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>
#include <dsevent.h>

// Assorted DSA headers
#include <filtypes.h>                   // Def of FI_CHOICE_???
#include   "debug.h"                    // standard debugging header
#define DEBSUB     "DBSYNTAX:"          // define the subsystem for debugging

// Password encryption
#include <pek.h>

// DBLayer includes
#include "dbintrnl.h"

#include <fileno.h>
#define  FILENO FILENO_DBSYNTAX

// Yes, I know this looks like it overwrites the pValBuf with a NULL if the
// dbReAlloc fails.  However, dbReAlloc is wired to throw an exception if it
// fails, so either the realloc works and life is good, or it fails and we
// except out without overwriting pDB->pValBuf.  In both cases, pDB->pValBuf and
// pDB->valBufSize are maintained as a valid pair.
// Also note: pDBHiddens val buf is malloced and should never have to grow, but
// we have code here to do it if we need to.
//
// WARNING: Any pointers that references the buffer returned by a MAKEBIG call
// can be invalidated by a second MAKEBIG call. This is because the Realloc call
// that this macro makes can change the value of pDB->pValBuf.
//

#define MAKEBIG_VALBUF(size)                                    \
        if ((size) > pDB->valBufSize){                          \
            if(pDB == pDBhidden) {                              \
                PUCHAR pTemp;                                   \
                Assert(!"Growing hidden dbpos's valbuf!\n");    \
                pTemp = malloc((size));                         \
                if(!pTemp) {                                    \
                    DsaExcept(DSA_MEM_EXCEPTION, (size),0);     \
                }                                               \
                free(pDB->pValBuf);                             \
                pDB->pValBuf = pTemp;                           \
                pDB->valBufSize = (size);                       \
            }                                                   \
            else {                                              \
                pDB->pValBuf = dbReAlloc(pDB->pValBuf, (size)); \
                pDB->valBufSize = (size);                       \
            }                                                   \
        }

#define NULLTAG ((ULONG) 0)

#define MAXSYNTAX       18  // The largest number of att syntaxes

/* The type of test for syntax Eval. */

#define DBSYN_EQUAL     0
#define DBSYN_SUB       1
#define DBSYN_GREQ      2
#define DBSYN_LEEQ      3
#define DBSYN_PRES      4

/* Error codes from syntax functions*/

#define DBSYN_BADOP   10
#define DBSYN_BADCONV 11
#define DBSYN_SYSERR  12


// Table of valid relational operators indexed by syntax
WORD    rgValidOperators[] =
{
    (WORD) 0,                               // syntax undefined

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax distname
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax object id
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax case string
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_SUBSTRING) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax no case string
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_SUBSTRING) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax print case string
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_SUBSTRING) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax numeric print case string
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_SUBSTRING) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_PRESENT)  | // Distname + Binary
    RelOpMask(FI_CHOICE_EQUALITY)      |
    RelOpMask(FI_CHOICE_NOT_EQUAL)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax boolean
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax integer
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
        RelOpMask(FI_CHOICE_PRESENT) |
        RelOpMask(FI_CHOICE_BIT_OR) |
        RelOpMask(FI_CHOICE_BIT_AND)),


    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax octet string
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_SUBSTRING) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax time
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax unicode
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_SUBSTRING) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax address
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax distname string
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT)) ,

    (WORD) 0,                           // syntax security descriptor

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax large integer
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT) |
        RelOpMask(FI_CHOICE_BIT_OR) |
        RelOpMask(FI_CHOICE_BIT_AND)),

    (WORD) (RelOpMask(FI_CHOICE_EQUALITY) | // syntax  SID
    RelOpMask(FI_CHOICE_GREATER) |
    RelOpMask(FI_CHOICE_SUBSTRING) |
    RelOpMask(FI_CHOICE_GREATER_OR_EQ) |
    RelOpMask(FI_CHOICE_LESS) |
    RelOpMask(FI_CHOICE_LESS_OR_EQ) |
    RelOpMask(FI_CHOICE_NOT_EQUAL) |
    RelOpMask(FI_CHOICE_PRESENT))
};


/*Internal functions*/

void CompressStr(UCHAR inStr[], ULONG inSLen
                ,UCHAR outStr[], ULONG *pOutSLen);

signed short SubCompare(BOOL Case
                      , UCHAR Sub[], signed long subSize
                      , UCHAR String[], signed long stringSize);

BOOL CompareSubStr(BOOL Case
                 ,SUBSTRING * pSub, UCHAR * pIntVal, ULONG intValLen);

BOOL CompareUnicodeSubStr(THSTATE *pTHS,
                          SUBSTRING *pSub, UCHAR *pIntVal, ULONG intValLen);

ULONG UnicodeSubCompare(THSTATE *pTHS,
                        SYNTAX_UNICODE *sub, ULONG cchSub,
            SYNTAX_UNICODE *str, ULONG cchStr);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int IntExtUnd(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG intLen,   UCHAR *pIntVal,
              ULONG *pExtLen, UCHAR **ppExtVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG flags)
{
    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));
   DPRINT(3,"IntExtUnd entered\n");
    *ppExtVal = pIntVal;
   *pExtLen   = intLen;
   return 0;

   (void) flags;           /*NotReferenced*/
   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtUnd*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int ExtIntUnd(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG extLen,   UCHAR *pExtVal,
              ULONG *pIntLen, UCHAR **ppIntVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG flags)
{
   DPRINT(3,"ExtIntUnd entered\n");
   *ppIntVal  = pExtVal;
   *pIntLen = extLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntUnd*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Undefined syntax only supports a check for presence */

int EvalUnd(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
            UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2){

    DPRINT(3,"EvalUnd entered\n");

   if (Oper == FI_CHOICE_PRESENT)
      return TRUE;
   else
      return DBSYN_BADOP;

   (void *) pDB;           /*NotReferenced*/
   (void)   intLen1;       /*NotReferenced*/
   (void)   intLen2;       /*NotReferenced*/
   (void *) pIntVal1;      /*NotReferenced*/
   (void *) pIntVal2;      /*NotReferenced*/

}/*EvalUnd*/

/*
 * What an appalling hack.  We have a perfectly good dsname allocated off
 * of the transaction heap, but we may need to copy it into the db heap
 */
void PossiblyCopyDSName(DBPOS * pDB, DSNAME *pDN)
{
    THSTATE  *pTHS=pDB->pTHS;

    if (pDB->pTHS->hHeapOrg || pDB == pDBhidden) {
    /* We've allocated this DSNAME off of the wrong heap,
     * because someone is using that trouble-ridden mark/free-to-mark
     * stuff, and we're on an inferior heap, and we need to return
     * this data off of the original heap, in order to match
     * "normal" dbAlloc semantics.  If the current DBPOS buffer isn't
     * big enough we'll need to allocate a larger one, and then we
     * must copy the data from the current buffer into the DBPOS one.
     */
        // NOTE: the assert is here because we want to find pople who are
    // reading external format dsnames on the hidden dbpos.
        Assert(pDB != pDBhidden);
    MAKEBIG_VALBUF(pDN->structLen);
    memcpy(pDB->pValBuf, pDN, pDN->structLen);
    THFree(pDN);
    }
    else {
    /* We've allocated the data from the right heap, but we still
     * need to make it appear as though our freshly allocated buffer
     * is the DBPOS's normal output buffer.
     */
    if (pDB->valBufSize) {
        dbFree(pDB->pValBuf);
    }
    pDB->valBufSize = pDN->structLen;
    pDB->pValBuf = (UCHAR *)pDN;
    }
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Converts an internal DistName (ULONG) to a syntax_distname by calling the
   subject table translation routines.
*/

int
IntExtDist(DBPOS FAR *pDB, USHORT extTableOp,
           ULONG intLen, UCHAR *pIntVal,
           ULONG *pExtLen, UCHAR **ppExtVal,
           ULONG ulUpdateDnt, JET_TABLEID jTbl,
           ULONG flags)
{
    int    rtn;
    ULONG  tag;
    DBPOS  *pDBtmp;
    DSNAME *pDNTmp;

    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

    DPRINT(3,"IntExtDist entered\n");
    if (intLen != sizeof(ULONG))             /*Must have a name tag */
        return DBSYN_BADCONV;

    tag = *(ULONG*)pIntVal;

    /* First retrieve the Dist Name based on the tag */
    Assert (extTableOp != DBSYN_ADD);
    switch (extTableOp) {
    case DBSYN_REM:
        if(rtn = sbTableGetDSName(pDB,
                                  tag,
                  &pDNTmp,
                                  0)) {
            DPRINT1(1,"DN DistName retrieval failed <%u>..returning\n",rtn);
            return rtn;
        }
        else {
            *pExtLen = pDNTmp->structLen;
            PossiblyCopyDSName(pDB, pDNTmp);
            *ppExtVal = pDB->pValBuf;
        }

        if ( flags & INTEXT_BACKLINK )
        {
            // In the DBSYN_REM case, the flag means this is a backlink.
            // We allow deleting backlinks but this should really only be
            // done when deleting an object. Anyway, All we need to do is
            // adjust the reference count on the current object since the
            // backlink is created as the result of adding a link which
            // updated the reference count on the object that gets the
            // backlink. (this object)

            DBAdjustRefCount(pDB, ulUpdateDnt, -1);
        }
        else
        {
            // Deref the object referenced by the property value being removed.
            DBAdjustRefCount(pDB, tag, -1);
        }

        return 0;
        break;

    case DBSYN_INQ:
        if(rtn=sbTableGetDSName(pDB, tag, &pDNTmp,flags)) {
            DPRINT1(1,"DN DistName retrieval failed <%u>..returning\n",rtn);
            return rtn;
        }
        else {
            *pExtLen = pDNTmp->structLen;
            PossiblyCopyDSName(pDB, pDNTmp);
            *ppExtVal = pDB->pValBuf;
        }
        break;
    default:
        DPRINT(1,"We should never be here\n");
        return DBSYN_BADOP;
    }


    (void) flags;           /*NotReferenced*/

    return 0;
}/*IntExtDist*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Converts an external syntax_distname to an internal DistName (ULONG)  by
   calling the subject table translation routines.
*/

int ExtIntDist(DBPOS FAR *pDB, USHORT extTableOp,
               ULONG extLen,   UCHAR *pExtVal,
               ULONG *pIntLen, UCHAR **ppIntVal,
               ULONG ulUpdateDnt, JET_TABLEID jTbl,
               ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;
    int    rtn;
    PDSNAME pDN = (PDSNAME)pExtVal;
    ULONG *pTag;
    ULONG actuallen;
    BOOL Deleted = FALSE;

    DPRINT(3,"EXTIntDist entered\n");

    /* Insure that val buf is atleast as big  as the max DN */

    MAKEBIG_VALBUF(sizeof(ULONG));
    pTag = (ULONG *)pDB->pValBuf;       // Convenient rename.
    *ppIntVal = pDB->pValBuf;           // user output points to val buf
    *pIntLen = sizeof(ULONG);           // The size of a name tag

    Assert(extTableOp != DBSYN_REM);

    if ((DBSYN_INQ == extTableOp)
        && (flags & EXTINT_REJECT_TOMBSTONES)
        && !fNullUuid(&pDN->Guid)) {
        // This is a special case where we're resolving a DSNAME into a DNT in
        // order to add it as the value of a linked attribute during inbound
        // replication.  We don't really care about the vast majority of
        // information on the record; all we want to know is (a) the DNT and
        // (b) whether the record is a deleted object (phantoms are okay).
        //
        // Shortcut the lookup to avoid pulling in the record's page -- this
        // will make e.g. adding large groups much faster, which will also help
        // minimize write conflicts (see bug 419338).
        Assert(pTHS->fDRA);

        JetSetCurrentIndex4Success(pDB->JetSessID,
                                   pDB->JetSearchTbl,
                                   SZGUIDINDEX,
                                   &idxGuid,
                                   0);

        JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl, &pDN->Guid,
                     sizeof(GUID), JET_bitNewKey);

        rtn = JetSeekEx(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekEQ);
        if (!rtn) {
            // We have a record with this guid.  Switch to DNT+isDeleted index,
            // preserving currency on the record we just found.
            JetSetCurrentIndex4Success(pDB->JetSessID,
                                       pDB->JetSearchTbl,
                                       SZDNTDELINDEX,
                                       &idxDntDel,
                                       JET_bitNoMove);

            // Read the DNT of the record.
            JetRetrieveColumnSuccess(pDB->JetSessID,
                                     pDB->JetSearchTbl,
                                     dntid,
                                     pTag,
                                     sizeof(*pTag),
                                     &actuallen,
                                     JET_bitRetrieveFromIndex,
                                     NULL);
            pDB->SDNT = *pTag;

            // Read the deletion state of the record.  Note that only objects
            // have an isDeleted attribute; phantoms have a deletion *time* but
            // no isDeleted attribute.
            rtn = JetRetrieveColumnWarnings(pDB->JetSessID,
                                            pDB->JetSearchTbl,
                                            isdeletedid,
                                            &Deleted,
                                            sizeof(Deleted),
                                            &actuallen,
                                            JET_bitRetrieveFromIndex,
                                            NULL);
            if (!rtn && Deleted) {
                // Record is a deleted object.
                DPRINT1(1, "ExtIntDist: fDRA INQ EXTINT_REJECT_TOMBSTONES"
                           " -- DNT %d is deleted!\n", *pTag);
                return ERROR_DS_NO_DELETED_NAME;
            } else {
                // Record is a phantom or a live object.
                DPRINT1(2, "ExtIntDist: fDRA INQ EXTINT_REJECT_TOMBSTONES"
                           " -- DNT %d is ok\n", *pTag);
                return 0;
            }
        } else {
            // Failed to find a record with this GUID.  Continue on to normal
            // code path, where we'll try to find the record by DN, etc.
            ;
        }
    }

    switch (extTableOp) {
    case DBSYN_ADD:
        if((flags & EXTINT_UPDATE_PHANTOM)&&(flags & EXTINT_NEW_OBJ_NAME)) {
            return DBSYN_BADCONV;
        }
        if(rtn = sbTableAddRef(pDB,
                               (flags & (EXTINT_UPDATE_PHANTOM |
                                         EXTINT_NEW_OBJ_NAME     )),
                               pDN,
                               pTag)) {
            DPRINT1(1,"Bad return on DN ADD REF <%u>\n",rtn);
            return DBSYN_BADCONV;
        }

        return 0;
        break;

    case DBSYN_INQ:
    {
        ULONG ulSbtFlags = 0;
        if (flags & EXTINT_REJECT_TOMBSTONES) {
            // Force search table currency
            ulSbtFlags |= SBTGETTAG_fMakeCurrent;
        }
        rtn = sbTableGetTagFromDSName(pDB, pDN, ulSbtFlags, pTag, NULL);

        if (rtn && (DIRERR_NOT_AN_OBJECT != rtn)) {
            DPRINT1(1,
                    "DN DistName to tag retrieval failed <%u>..returning\n",
                    rtn);
            return rtn;
        } else if (flags & EXTINT_REJECT_TOMBSTONES) {
            // PERFORMANCE: For performance, someday push this support into dbsubj
            // so the cache knows about deletion status of objects

            // dn is present, see if tombstone
            rtn = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetSearchTbl,
                   isdeletedid, &Deleted, sizeof(Deleted), &actuallen, 0, NULL);
            if ( (!rtn) && (Deleted) ) {
                return ERROR_DS_NO_DELETED_NAME;
            }
        }
        return 0;
    }

    default:
        DPRINT(1,"We should never be here\n");
        return DBSYN_BADOP;
    }/*switch*/

}/*ExtIntDist*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare SYNTAX_DIST_NAMEs.  Only presence and equality tests allowed */

int
EvalDist (
        DBPOS FAR *pDB,
        UCHAR Oper,
        ULONG intLen1,
        UCHAR *pIntVal1,
        ULONG intLen2,
        UCHAR *pIntVal2
        )
{

    DPRINT(3,"EvalDist entered\n");

    if (Oper == FI_CHOICE_PRESENT)
    return TRUE;

    if (  intLen1 != sizeof(ULONG)  || intLen2 != sizeof(ULONG))
    {
    DPRINT(1,"Problem with DISTNAME on comparison values return error\n");
    return DBSYN_BADCONV;
    }

    switch(Oper)
    {
    case FI_CHOICE_EQUALITY:
        return (*(ULONG *)pIntVal1) == (*(ULONG *)pIntVal2);

    case FI_CHOICE_NOT_EQUAL:
        return (*(ULONG *)pIntVal1) != (*(ULONG *)pIntVal2);

    default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
   }/*switch*/

   (void *) pDB;           /*NotReferenced*/
}/*EvalDist*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* SYNTAX_OBJECT_ID attributes are returned as is*/

int IntExtID(DBPOS FAR *pDB, USHORT extTableOp,
             ULONG intLen,   UCHAR *pIntVal,
             ULONG *pExtLen, UCHAR **ppExtVal,
             ULONG ulUpdateDnt, JET_TABLEID jTbl,
             ULONG flags)
{
    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

   DPRINT(3,"IntExtId entered\n");
   *ppExtVal = pIntVal;
   *pExtLen   = intLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtID*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* SYNTAX_OBJECT_ID attributes are returned as is*/

int ExtIntID(DBPOS FAR *pDB, USHORT extTableOp,
             ULONG extLen,   UCHAR *pExtVal,
             ULONG *pIntLen, UCHAR **ppIntVal,
             ULONG ulUpdateDnt, JET_TABLEID jTbl,
             ULONG flags)
{
   DPRINT(3,"ExtIntId entered\n");
   *ppIntVal  = pExtVal;
   *pIntLen = extLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntID*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare SYNTAX_OBJECT_IDs.  Only presence and equality tests allowed */

int EvalID(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
           UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2){

    DPRINT(3,"EvalID entered\n");

   if (Oper == FI_CHOICE_PRESENT)
      return TRUE;

   if (  intLen1 != sizeof(SYNTAX_OBJECT_ID)
      || intLen2 != sizeof(SYNTAX_OBJECT_ID)){

      DPRINT(1,"Problem with SYNTAX_OBJECT_ID values return error\n");
      return DBSYN_BADCONV;
   }

   switch(Oper)
   {
      case FI_CHOICE_EQUALITY:
        return     (((*(SYNTAX_OBJECT_ID *)pIntVal1)
                  == (*(SYNTAX_OBJECT_ID *)pIntVal2)) ? TRUE : FALSE);
        break;

      case FI_CHOICE_NOT_EQUAL:
        return     (((*(SYNTAX_OBJECT_ID *)pIntVal1)
                  != (*(SYNTAX_OBJECT_ID *)pIntVal2)) ? TRUE : FALSE);
        break;

      case FI_CHOICE_LESS_OR_EQ:
        return     (((*(SYNTAX_OBJECT_ID *)pIntVal2)
                  <= (*(SYNTAX_OBJECT_ID *)pIntVal1)) ? TRUE : FALSE);
        break;

      case FI_CHOICE_LESS:
        return     ((*(SYNTAX_OBJECT_ID *)pIntVal2) < (*(SYNTAX_OBJECT_ID *)pIntVal1));
        break;

      case FI_CHOICE_GREATER_OR_EQ:
        return     (((*(SYNTAX_OBJECT_ID *)pIntVal2)
                  >= (*(SYNTAX_OBJECT_ID *)pIntVal1)) ? TRUE : FALSE);
        break;

      case FI_CHOICE_GREATER:
        return     ((*(SYNTAX_OBJECT_ID *)pIntVal2) > (*(SYNTAX_OBJECT_ID *)pIntVal1));
        break;
      default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
   }/*switch*/

   (void *) pDB;           /*NotReferenced*/

}/*EvalID*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* SYNTAX_CASE_STRING have the same internal and external form*/

int IntExtCase(DBPOS FAR *pDB, USHORT extTableOp,
               ULONG intLen,   UCHAR *pIntVal,
               ULONG *pExtLen, UCHAR **ppExtVal,
               ULONG ulUpdateDnt, JET_TABLEID jTbl,
               ULONG flags)
{

    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

  DPRINT(3,"Internal to external case sensitive conv entered\n");

   *ppExtVal = pIntVal;
   *pExtLen  = intLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtCase*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* SYNTAX_CASE_STRING have the same internal and external form.
*/

int ExtIntCase(DBPOS FAR *pDB, USHORT extTableOp,
               ULONG extLen,   UCHAR *pExtVal,
               ULONG *pIntLen, UCHAR **ppIntVal,
               ULONG ulUpdateDnt, JET_TABLEID jTbl,
               ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;

    DPRINT(3,"External to internal case sensitive conv entered\n");

   MAKEBIG_VALBUF (extLen);    /*Make output str atleast as large as input*/
   *ppIntVal = pDB->pValBuf;             /*user output points to valbuf*/
   *pIntLen = extLen;
   memcpy(*ppIntVal, pExtVal, extLen);

   return 0;

   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntCase*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare Case strings.  Presence, equality and substring tests allowed.
   All comparisons are case sensitive. This is a CASE SENSITIVE STRING.
*/

int EvalCase(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
             UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2)
{
    int comp;

    DPRINT(3,"EvalCase entered\n");
    comp =  memcmp(pIntVal2, pIntVal1,(intLen1 < intLen2)?intLen1 : intLen2);

    switch(Oper){
    case FI_CHOICE_PRESENT:
        return TRUE;
        break;

    case FI_CHOICE_EQUALITY:
            return (comp == 0 && intLen1 == intLen2)
        ? TRUE : FALSE;
            break;

    case FI_CHOICE_NOT_EQUAL:
            return !(comp == 0 && intLen1 == intLen2);

    case FI_CHOICE_LESS:
        return ((comp < 0) || ((!comp ) && (intLen2 < intLen1)));
        break;

    case FI_CHOICE_LESS_OR_EQ:
        return (comp < 0 || (comp == 0 && intLen2 <= intLen1)) ? TRUE : FALSE;
            break;

    case FI_CHOICE_GREATER_OR_EQ:
        return (comp > 0 || (comp == 0 && intLen2 >= intLen1))
                ? TRUE : FALSE;
        break;

    case FI_CHOICE_GREATER:
        return (comp > 0 || (!comp && (intLen2 > intLen1)));
        break;

    case FI_CHOICE_SUBSTRING:
        return  CompareSubStr(TRUE, /*Case sensitive*/
        (SUBSTRING *) pIntVal1, pIntVal2, intLen2);

        break;

    default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
   }/*switch*/

   (void *) pDB;           /*NotReferenced*/

}/*EvalCase*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* SYNTAX_NOCASE_STRING have the same internal and external form*/

int IntExtNoCase(DBPOS FAR *pDB, USHORT extTableOp,
                 ULONG intLen,   UCHAR *pIntVal,
                 ULONG *pExtLen, UCHAR **ppExtVal,
                 ULONG ulUpdateDnt, JET_TABLEID jTbl,
                 ULONG flags)
{

    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

  DPRINT(3,"Internal to external NO case sensitive conv entered\n");

   *ppExtVal = pIntVal;
   *pExtLen   = intLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtNoCase*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* SYNTAX_NOCASE_STRING have the same internal and external form but all
   leading and trailing blanks are removed.  Also multiple contiguous
   blanks are reduced to a single blank.
*/

int ExtIntNoCase(DBPOS FAR *pDB, USHORT extTableOp,
                 ULONG extLen,   UCHAR *pExtVal,
                 ULONG *pIntLen, UCHAR **ppIntVal,
                 ULONG ulUpdateDnt, JET_TABLEID jTbl,
                 ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;
    DPRINT(3,"External to internal NO case sensitive conv entered\n");

   MAKEBIG_VALBUF (extLen);    /*Make output str atleast as large as input*/
   *ppIntVal = pDB->pValBuf;             /*user output points to valbuf*/
   *pIntLen = extLen;
   memcpy(*ppIntVal, pExtVal, extLen);

   return 0;

   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntNoCase*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare NoCase strings.  Presence, equality and substring tests allowed.
   All comparisons are case insensitive. This is a CASE INSENSITIVE STRING.
*/


int EvalNoCase(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
               UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2){


    int comp;

    DPRINT(3,"EvalNoCase entered\n");
    comp =  _strnicmp(pIntVal2, pIntVal1,(intLen1 < intLen2)?intLen1 : intLen2);

    switch(Oper){
    case FI_CHOICE_PRESENT:
        return TRUE;
        break;

    case FI_CHOICE_EQUALITY:
            return (comp == 0 && intLen1 == intLen2)
        ? TRUE : FALSE;
            break;

    case FI_CHOICE_NOT_EQUAL:
            return !(comp == 0 && intLen1 == intLen2);

    case FI_CHOICE_LESS:
        return ((comp < 0) || ((!comp ) && (intLen2 < intLen1)));
        break;

    case FI_CHOICE_LESS_OR_EQ:
        return (comp < 0 || (comp == 0 && intLen2 <= intLen1)) ? TRUE : FALSE;
            break;

    case FI_CHOICE_GREATER_OR_EQ:
        return (comp > 0 || (comp == 0 && intLen2 >= intLen1))
                ? TRUE : FALSE;
        break;

    case FI_CHOICE_GREATER:
        return (comp > 0 || (!comp && (intLen2 > intLen1)));
        break;

    case FI_CHOICE_SUBSTRING:
        return  CompareSubStr(FALSE, /*Case insensitive*/
        (SUBSTRING *) pIntVal1, pIntVal2, intLen2);

        break;

    default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
   }/*switch*/

   (void *) pDB;           /*NotReferenced*/

}/*EvalNoCase*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int IntExtError(DBPOS FAR *pDB, USHORT extTableOp,
                ULONG intLen,   UCHAR *pIntVal,
                ULONG *pExtLen, UCHAR **ppExtVal,
                ULONG ulUpdateDnt, JET_TABLEID jTbl,
                ULONG flags)
{

    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

   DPRINT(3,"IntExtError entered bad syntax return conv err\n");
   return DBSYN_BADCONV;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   intLen;        /*NotReferenced*/
   (void *) pExtLen;       /*NotReferenced*/
   (void *) pIntVal;       /*NotReferenced*/
   (void **)ppExtVal;      /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtError*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

int ExtIntError(DBPOS FAR *pDB, USHORT extTableOp,
                ULONG extLen,   UCHAR *pExtVal,
                ULONG *pIntLen, UCHAR **ppIntVal,
                ULONG ulUpdateDnt, JET_TABLEID jTbl,
                ULONG flags)
{

   DPRINT(3,"ExtIntError entered bad syntax return conv err\n");
   return DBSYN_BADCONV;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   extLen;        /*NotReferenced*/
   (void *) pIntLen;       /*NotReferenced*/
   (void *) pExtVal;       /*NotReferenced*/
   (void **)ppIntVal;      /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntError*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

int EvalError(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
              UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2){

   DPRINT(3,"EvalError entered return bad syntax return conv err\n");
   return DBSYN_BADCONV;

   (void *) pDB;           /*NotReferenced*/
   (void)   Oper;          /*NotReferenced*/
   (void)   intLen1;       /*NotReferenced*/
   (void)   intLen2;       /*NotReferenced*/
   (void *) pIntVal1;      /*NotReferenced*/
   (void *) pIntVal2;      /*NotReferenced*/

}/*EvalError*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int IntExtBool(DBPOS FAR *pDB, USHORT extTableOp,
               ULONG intLen,   UCHAR *pIntVal,
               ULONG *pExtLen, UCHAR **ppExtVal,
               ULONG ulUpdateDnt, JET_TABLEID jTbl,
               ULONG flags)
{

    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

    DPRINT(3,"IntExtBool entered\n");

    if (intLen ==sizeof(BOOL) && (   (*(BOOL *)pIntVal) == FALSE
                                  || (*(BOOL *)pIntVal) == TRUE)){

       *ppExtVal  = pIntVal;
       *pExtLen   = intLen;
       return 0;
    }

    DPRINT(1,"Not a boolean value....CONVERR\n");
    return DBSYN_BADCONV;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtBool*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* In C 0 is FALSE and !0 is TRUE.  In the Directory 0 is FALSE and
   1 is TRUE... Convert !0 value to internal form.
*/

int ExtIntBool(DBPOS FAR *pDB, USHORT extTableOp,
               ULONG extLen,   UCHAR *pExtVal,
               ULONG *pIntLen, UCHAR **ppIntVal,
               ULONG ulUpdateDnt, JET_TABLEID jTbl,
               ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;

    DPRINT(3,"ExtIntBool entered\n");

    if (extLen ==sizeof(BOOL)){

       MAKEBIG_VALBUF (extLen);  /*Make output str atleast as large as input*/
       *ppIntVal = pDB->pValBuf; /*user output points to valbuf*/

       (*(BOOL *)*ppIntVal)  = ((*(BOOL *)pExtVal) == FALSE) ? FALSE : TRUE;
       *pIntLen   = extLen;
       return 0;
    }

    DPRINT(1,"Not a boolean value....CONVERR\n");
    return DBSYN_BADCONV;

   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntBool*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare boolean values.  Only presence and equality test is allowed */

int EvalBool(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
             UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2){

    DPRINT(3,"EvalBool entered\n");

   if (Oper == FI_CHOICE_PRESENT)
      return TRUE;

   if (intLen1 != sizeof(BOOL) || intLen2 != sizeof(BOOL)){
      DPRINT(1,"Problem with BOOLEAN values return error\n");
      return DBSYN_BADCONV;
   }

   switch(Oper){
      case FI_CHOICE_EQUALITY:
        return     (((*(BOOL *)pIntVal1)
                  == (*(BOOL *)pIntVal2)) ? TRUE : FALSE);
        break;

      case FI_CHOICE_NOT_EQUAL:
        return     (*(BOOL *)pIntVal1 != *(BOOL *)pIntVal2);

      case FI_CHOICE_LESS_OR_EQ:
        return     (((*(BOOL *)pIntVal2)
                  <= (*(BOOL *)pIntVal1)) ? TRUE : FALSE);
        break;

      case FI_CHOICE_LESS:
        return     ((*(BOOL *)pIntVal2) < (*(BOOL *)pIntVal1));
        break;

      case FI_CHOICE_GREATER_OR_EQ:
        return     (((*(BOOL *)pIntVal2)
                  >= (*(BOOL *)pIntVal1)) ? TRUE : FALSE);
        break;

      case FI_CHOICE_GREATER:
        return     ((*(BOOL *)pIntVal2) > (*(BOOL *)pIntVal1));
        break;


      default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
   }/*switch*/

   (void *) pDB;           /*NotReferenced*/

}/*EvalBool*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Integer Internal to External conversion */

int IntExtInt(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG intLen,   UCHAR *pIntVal,
              ULONG *pExtLen, UCHAR **ppExtVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG flags)
{
    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

   DPRINT(3,"IntExtInt entered\n");
   *ppExtVal  = pIntVal;
   *pExtLen   = intLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtInt*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Integer Externalto Internal conversion */

int ExtIntInt(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG extLen,   UCHAR *pExtVal,
              ULONG *pIntLen, UCHAR **ppIntVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG flags)
{
   DPRINT(3,"ExtIntInt entered\n");
   *ppIntVal  = pExtVal;
   *pIntLen   = extLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntInt*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare integer values.  "Presence,=,<=,>=" tests are allowed */

int
EvalInt(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
        UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2)
{
    SYNTAX_INTEGER IntVal1, IntVal2;

    DPRINT(3,"EvalInt entered\n");

   if (Oper == FI_CHOICE_PRESENT)
      return TRUE;

   if (  intLen1 != sizeof(SYNTAX_INTEGER)
      || intLen2 != sizeof(SYNTAX_INTEGER)){

      DPRINT(1,"Problem with Integer on comparison values return error\n");
      return DBSYN_BADCONV;
   }

    IntVal1 =  (*(SYNTAX_INTEGER *)pIntVal1);
    IntVal2 =  (*(SYNTAX_INTEGER *)pIntVal2);

    switch(Oper){
    case FI_CHOICE_EQUALITY:
        return    (IntVal1 == IntVal2);
        break;
    case FI_CHOICE_NOT_EQUAL:
        return     (IntVal1 != IntVal2);

    case FI_CHOICE_LESS_OR_EQ:
        return     (IntVal2 <= IntVal1);
        break;

    case FI_CHOICE_LESS:
        return     (IntVal2 < IntVal1);
        break;

    case FI_CHOICE_GREATER_OR_EQ:
        return     (IntVal2 >= IntVal1);
        break;

    case FI_CHOICE_GREATER:
        return     (IntVal2 > IntVal1);
        break;

    case FI_CHOICE_BIT_OR:
        // True if any bits in common.
        return     ((IntVal2 & IntVal1) != 0);
        break;

    case FI_CHOICE_BIT_AND:
        // True if all bits in intval2 are set in intval1
        return     ((IntVal2 & IntVal1) == IntVal1);
        break;

    default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
   }/*switch*/

   (void *) pDB;           /*NotReferenced*/

}/*EvalInt*/


/*-------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------*/
/* Time Internal to External conversion */

int IntExtTime(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG intLen,   UCHAR *pIntVal,
              ULONG *pExtLen, UCHAR **ppExtVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG flags)
{
    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

   DPRINT(3,"IntExtTime entered\n");
   *ppExtVal  = pIntVal;
   *pExtLen   = intLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtTime*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Time Externalto Internal conversion */

int ExtIntTime(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG extLen,   UCHAR *pExtVal,
              ULONG *pIntLen, UCHAR **ppIntVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG flags)
{
   DPRINT(3,"ExtIntTime entered\n");
   *ppIntVal  = pExtVal;
   *pIntLen   = extLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntInt*/

/*-------------------------------------------------------------------------*/

int
EvalTime(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
         UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2)
{
    SYNTAX_TIME IntVal1, IntVal2;

    DPRINT(3,"EvalTime entered\n");

    if (Oper == FI_CHOICE_PRESENT)
        return TRUE;

    if (intLen1 != sizeof(SYNTAX_TIME)
        || intLen2 != sizeof(SYNTAX_TIME)) {

        DPRINT(1,"Problem with Time on comparison values return error\n");
        return DBSYN_BADCONV;
    }

    memcpy(&IntVal1, pIntVal1, sizeof(SYNTAX_TIME));
    memcpy(&IntVal2, pIntVal2, sizeof(SYNTAX_TIME));

    switch(Oper){
    case FI_CHOICE_EQUALITY:
        return    (IntVal1 == IntVal2);
        break;
    case FI_CHOICE_NOT_EQUAL:
        return     (IntVal1 != IntVal2);

    case FI_CHOICE_LESS_OR_EQ:
        return     (IntVal2 <= IntVal1);
        break;

    case FI_CHOICE_LESS:
        return     (IntVal2 < IntVal1);
        break;

    case FI_CHOICE_GREATER_OR_EQ:
        return     (IntVal2 >= IntVal1);
        break;

    case FI_CHOICE_GREATER:
        return     (IntVal2 > IntVal1);
        break;

    case FI_CHOICE_BIT_OR:
        // True if any bits in common.
        return     ((IntVal2 & IntVal1) != 0);
        break;

    case FI_CHOICE_BIT_AND:
        // True if all bits in intval2 are set in intval1
        return     ((IntVal2 & IntVal1) == IntVal1);
        break;

    default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
    }/*switch*/

    (void *) pDB;           /*NotReferenced*/

}/*EvalTime*/


/*-------------------------------------------------------------------------*/
/* Large Integer Internal to External conversion */

int IntExtI8(DBPOS FAR *pDB, USHORT extTableOp,
             ULONG intLen,   UCHAR *pIntVal,
             ULONG *pExtLen, UCHAR **ppExtVal,
             ULONG ulUpdateDnt, JET_TABLEID jTbl,
             ULONG flags)
{
    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

   DPRINT(3,"IntExtI8 entered\n");
   *ppExtVal  = pIntVal;
   *pExtLen   = intLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtInt*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Large Integer Externalto Internal conversion */

int ExtIntI8(DBPOS FAR *pDB, USHORT extTableOp,
             ULONG extLen,   UCHAR *pExtVal,
             ULONG *pIntLen, UCHAR **ppIntVal,
             ULONG ulUpdateDnt, JET_TABLEID jTbl,
             ULONG flags)
{
   DPRINT(3,"ExtIntI8 entered\n");
   *ppIntVal  = pExtVal;
   *pIntLen   = extLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntInt*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare large integer values.*/

int
EvalI8(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
       UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2)
{

    SYNTAX_I8 Val1;
    SYNTAX_I8 Val2;

    DPRINT(3,"EvalI8 entered\n");

    if (Oper == FI_CHOICE_PRESENT)
        return TRUE;

    if (  intLen1 != sizeof(SYNTAX_I8)
        || intLen2 != sizeof(SYNTAX_I8)){

        DPRINT(1,"Problem with large Integer on comparison values "
               "return error\n");
        return DBSYN_BADCONV;
    }

    memcpy(&Val1, pIntVal1, sizeof(SYNTAX_I8));
    memcpy(&Val2, pIntVal2, sizeof(SYNTAX_I8));

    switch(Oper){
    case FI_CHOICE_EQUALITY:
        return (Val2.QuadPart == Val1.QuadPart);
        break;

    case FI_CHOICE_NOT_EQUAL:
        return (Val2.QuadPart != Val1.QuadPart);
        break;

    case FI_CHOICE_LESS_OR_EQ:
        return (Val2.QuadPart <= Val1.QuadPart);
        break;

    case FI_CHOICE_LESS:
        return (Val2.QuadPart <  Val1.QuadPart);
        break;

    case FI_CHOICE_GREATER_OR_EQ:
        return (Val2.QuadPart >= Val1.QuadPart);
        break;

    case FI_CHOICE_GREATER:
        return (Val2.QuadPart >  Val1.QuadPart);
        break;

    case FI_CHOICE_BIT_OR:
        // True if any bits in common.
        return ((Val2.QuadPart & Val1.QuadPart) != 0i64);
        break;

    case FI_CHOICE_BIT_AND:
        // True if all bits in intval2 are set in intval1
        return ((Val2.QuadPart & Val1.QuadPart) == Val1.QuadPart);
        break;


    default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
    }/*switch*/

    (void *) pDB;           /*NotReferenced*/

}/*EvalI8*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Octet Internal to External conversion */

int IntExtOctet(DBPOS FAR *pDB, USHORT extTableOp,
                ULONG intLen,   UCHAR *pIntVal,
                ULONG *pExtLen, UCHAR **ppExtVal,
                ULONG ulUpdateDnt, JET_TABLEID jTbl,
                ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;
    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

   DPRINT(3,"IntExtOctet entered\n");

   if (flags & INTEXT_SECRETDATA)
   {
       // Need to decrypt the data.

       if (!gfRunningInsideLsa) {
           return DB_ERR_SYNTAX_CONVERSION_FAILED;
       }

       // Jet will never pass us back 0 length
       // values. The Decryption routine may
       // barf on 0 length values
       Assert(intLen>0);
       // First get the length
       PEKDecrypt(pDB->pTHS,pIntVal,intLen,NULL,pExtLen);
       // Get a buffer large enough to hold the data
       MAKEBIG_VALBUF(*pExtLen);
       *ppExtVal = pDB->pValBuf;
       // Decrypt the Data
       PEKDecrypt(pDB->pTHS,pIntVal,intLen,*ppExtVal,pExtLen);
   }
   else
   {
        *ppExtVal  = pIntVal;
        *pExtLen   = intLen;
   }
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtOctet*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Octet External to Internal conversion */

int ExtIntOctet(DBPOS FAR *pDB, USHORT extTableOp,
                ULONG extLen,   UCHAR *pExtVal,
                ULONG *pIntLen, UCHAR **ppIntVal,
                ULONG ulUpdateDnt, JET_TABLEID jTbl,
                ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;
    DPRINT(3,"ExtIntOctet entered\n");

   if ((flags & EXTINT_SECRETDATA) && (extLen>0))
   {
        // Need to encrypt the data. Do not call the
        // encryption routines if the data is 0 size

       // we return this error if we are not in LSA
       if (!gfRunningInsideLsa) {
           return DB_ERR_SYNTAX_CONVERSION_FAILED;
       }

        // First the get the length of the encrypted data
        PEKEncrypt(pDB->pTHS,pExtVal, extLen,NULL,pIntLen);
        // Get a buffer large enough to hold the data
        MAKEBIG_VALBUF (*pIntLen);
        *ppIntVal = pDB->pValBuf;
        // Now encrypt the data
        PEKEncrypt(pDB->pTHS,pExtVal, extLen,*ppIntVal,pIntLen);
   }
   else
   {
        *ppIntVal  = pExtVal;
        *pIntLen   = extLen;
   }
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntOctet*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare Octet values.  "Presence,=,<=,>=, Substring" tests are allowed.
   Test are from low-high memory byte by byte
*/

int EvalOctet(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
              UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2){

    int comp;

    DPRINT(3,"EvalOctet entered\n");

   if (Oper == FI_CHOICE_PRESENT) {
      return TRUE;
   }
   else if (Oper == FI_CHOICE_SUBSTRING) {
    return CompareSubStr(TRUE  /*Case sensitive*/
                  ,(SUBSTRING *) pIntVal1, pIntVal2, intLen2);
   }

   comp =  memcmp(pIntVal2, pIntVal1,(intLen1 < intLen2)?intLen1 : intLen2);

   switch(Oper){
      case FI_CHOICE_EQUALITY:
        return (comp == 0 && intLen1 == intLen2)
                ? TRUE : FALSE;
        break;
      case FI_CHOICE_NOT_EQUAL:
        return !(comp == 0 && intLen1 == intLen2);

      case FI_CHOICE_LESS:
        return ((comp < 0) || ((!comp ) && (intLen2 < intLen1)));
        break;
      case FI_CHOICE_LESS_OR_EQ:
        return (comp < 0 || (comp == 0 && intLen2 <= intLen1))
                ? TRUE : FALSE;
        break;
      case FI_CHOICE_GREATER_OR_EQ:
        return (comp > 0 || (comp == 0 && intLen2 >= intLen1))
                ? TRUE : FALSE;
    break;
      case FI_CHOICE_GREATER:
        return (comp > 0 || (!comp && (intLen2 > intLen1)));
    break;
      default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
   }/*switch*/

   (void *) pDB;           /*NotReferenced*/

}/*EvalOctet*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* SYNTAX_UNICODE have the same internal and external form*/

int IntExtUnicode(DBPOS FAR *pDB, USHORT extTableOp,
                  ULONG intLen,   UCHAR *pIntVal,
                  ULONG *pExtLen, UCHAR **ppExtVal,
                  ULONG ulUpdateDnt, JET_TABLEID jTbl,
                  ULONG flags)
{

    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

  DPRINT(3,"Internal to external case sensitive conv entered\n");

   *ppExtVal = pIntVal;
   *pExtLen  = intLen;
   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtUnicode*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* SYNTAX_UNICODE have the same internal and external form.
*/

int ExtIntUnicode(DBPOS FAR *pDB, USHORT extTableOp,
                  ULONG extLen,   UCHAR *pExtVal,
                  ULONG *pIntLen, UCHAR **ppIntVal,
                  ULONG ulUpdateDnt, JET_TABLEID jTbl,
                  ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;

    DPRINT(3,"External to internal unicode conversion entered\n");

   *pIntLen = extLen;
   MAKEBIG_VALBUF (extLen);    /*Make output str atleast as large as input*/
   *ppIntVal = pDB->pValBuf;   /*user output points to valbuf*/
   memcpy(*ppIntVal, pExtVal, extLen);

   return 0;

   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntUnicode*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare Unicode strings.  Presence, equality and substring tests allowed.
   All comparisons are case insensitive. This is a CASE INSENSITIVE STRING.
*/

int EvalUnicode(DBPOS *pDB,  UCHAR Oper, ULONG intLen1,
             UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2)
{
    int comp;

    DPRINT(3,"EvalUnicode entered\n");

    if (Oper == FI_CHOICE_PRESENT) {
        return TRUE;
    }
    else if (Oper == FI_CHOICE_SUBSTRING) {
           return  CompareUnicodeSubStr(pDB->pTHS,
                                        (SUBSTRING *) pIntVal1,
                                        pIntVal2,
                                        intLen2);
    }

    comp =  CompareStringW( pDB->pTHS->dwLcid,
               (pDB->pTHS->fDefaultLcid ?
                DS_DEFAULT_LOCALE_COMPARE_FLAGS :
                LOCALE_SENSITIVE_COMPARE_FLAGS),
               (LPCWSTR) pIntVal2,
               (intLen2 / sizeof(SYNTAX_UNICODE)),
               (LPCWSTR) pIntVal1,
               (intLen1 / sizeof(SYNTAX_UNICODE))) - 2;

    switch(Oper)
    {
    case FI_CHOICE_EQUALITY:
        return (comp == 0) ? TRUE : FALSE;
        break;

    case FI_CHOICE_NOT_EQUAL:
        return !(comp == 0);
        break;

    case FI_CHOICE_LESS:
        return (comp < 0);
        break;

    case FI_CHOICE_LESS_OR_EQ:
        return (comp <= 0) ? TRUE : FALSE;
        break;

    case FI_CHOICE_GREATER_OR_EQ:
        return (comp >= 0) ? TRUE : FALSE;
        break;

    case FI_CHOICE_GREATER:
        return (comp > 0);
        break;

    default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
   }/*switch*/

}/*EvalUnicode*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/*Internal - External Distname+String translation.  Use distname function to
  get the external representation of a distname.  Move the value to a temp
  area because we must resize the VALBUF to accomodate the distname+string.
  Finally, move in the distname and the string.
*/

int
IntExtDistString (
        DBPOS FAR *pDB, USHORT extTableOp,
        ULONG intLen, UCHAR *pIntVal,
        ULONG *pExtLen, UCHAR **ppExtVal,
        ULONG ulUpdateDnt, JET_TABLEID jTbl,
        ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;
    UCHAR            *buf;
    ULONG            DNLen;
    int              rtn;
    DSNAME           *pDN;
    DSNAME          *pDNTemp;
    INTERNAL_SYNTAX_DISTNAME_STRING *pINT_DNS;

    /* Copy internal value out of pDB->pValBuf */

    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

    DPRINT(3,"IntExtDistString entered\n");
    buf = THAllocEx(pTHS,intLen);
    pINT_DNS = (INTERNAL_SYNTAX_DISTNAME_STRING *)buf;
    memcpy(buf, pIntVal, intLen);

    // Make sure its a valid value
    if (intLen != (sizeof(ULONG)+pINT_DNS->data.structLen)) {
        DPRINT(1,"Internal DN-Address length is incorrect\n");
        THFreeEx(pTHS,buf);
        return DBSYN_BADCONV;
    }

    // It is an assumption that no attributes of this type are backlinks.
    // If that assumption is not true, then the final paramater to IntExtDist
    // must be set to
    // newflags =
    //     ((extTableOp == DBSYN_REM &&
    //       (FIsBackLink(this attribute))) ? INTEXT_BACKLINK : 0);
    // Note that this_attribute is not available here, so if we need to
    // change this,then we need to make that data available here.


    // Translate DN portion to external form
    if (rtn = IntExtDist(pDB, extTableOp, sizeof(ULONG),
             (UCHAR *)(&pINT_DNS->tag),
                         &DNLen, (UCHAR **)&pDN,
             ulUpdateDnt, jTbl, flags)) {
        DPRINT1(1,"INT to EXT DIST returned an error code of %u..return\n",rtn);
        THFreeEx(pTHS,buf);
        return rtn;
    }

    pDNTemp = THAllocEx(pTHS, pDN->structLen);
    memcpy(pDNTemp, pDN, pDN->structLen); /*Hold value while we resize VALBUF*/
    *pExtLen = DERIVE_NAME_DATA_SIZE(pDNTemp, &pINT_DNS->data);
    MAKEBIG_VALBUF (*pExtLen);
    *ppExtVal = pDB->pValBuf;              /*user output points to valbuf*/
    BUILD_NAME_DATA((SYNTAX_DISTNAME_STRING*)*ppExtVal, pDNTemp,
            &pINT_DNS->data);
    THFreeEx(pTHS,buf);
    THFreeEx(pTHS,pDNTemp);
    return 0;

}/*IntExtDistString*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/*External - Internal DistString translation.  Use distname function to
  get the Internal representation of a distname.  Move the value to a temp
  area because we must resize the VALBUF to accomodate the distname-string.
  Finally, move in the distname and the string.
*/

int
ExtIntDistString (
        DBPOS FAR *pDB, USHORT extTableOp,
        ULONG extLen,   UCHAR *pExtVal,
        ULONG *pIntLen, UCHAR **ppIntVal,
        ULONG ulUpdateDnt, JET_TABLEID jTbl,
        ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;
    ULONG       len;
    int         rtn;
    INTERNAL_SYNTAX_DISTNAME_STRING *pINT_DNS;
    ULONG       *pTag;
    DWORD       tag;
    SYNTAX_DISTNAME_STRING *pEXT_DNS = (SYNTAX_DISTNAME_STRING *)pExtVal;

    DPRINT(3,"ExtIntDistSTring entered\n");

    if (extLen != (ULONG)NAME_DATA_SIZE(pEXT_DNS)){
        DPRINT(1,"External DN-Address length is incorrect\n");
        return DBSYN_BADCONV;
    }

    // It is an assumption that this is not the OBJ_DIST_NAME.  If that
    // assumption is not true, then the final paramater to ExtIntDist must be
    // set to
    // newflags =
    //     ((extTableOp == DBSYN_ADD &&
    //       (this attribute == OBJ_DIST_NAME)) ? EXTINT_NEW_OBJ_NAME:0);
    // Note that this_attribute is not available here, so if we need to
    // change this,then we need to make that data available here.

    if(rtn = ExtIntDist(pDB,
                        extTableOp,
                        NAMEPTR(pEXT_DNS)->structLen,
                        (PUCHAR)NAMEPTR(pEXT_DNS),
                        &len,
                        (UCHAR **)&pTag,
                        ulUpdateDnt,
                        jTbl,
                        0)) {

        DPRINT1(1,"EXT to INTDIST returned an error %u\n",rtn);
        return rtn;
    }

    //
    // copy off the tag because the MAKEBIG call can modify the pointer
    //

    tag = *pTag;
    *pIntLen = (sizeof(ULONG) + DATAPTR(pEXT_DNS)->structLen);

    MAKEBIG_VALBUF (*pIntLen);  /*Internal is never larger than external rep*/
    *ppIntVal = pDB->pValBuf;   /*user output points to valbuf*/

    pINT_DNS = (INTERNAL_SYNTAX_DISTNAME_STRING *)*ppIntVal;

    pINT_DNS->tag = tag;

    memcpy(&pINT_DNS->data, DATAPTR(pEXT_DNS), DATAPTR(pEXT_DNS)->structLen);

    return 0;

}/*ExtIntDistString*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Eval name-adress syntax.  only presence and equality tests are allowed*/

int
EvalDistString (
        DBPOS FAR *pDB,
        UCHAR Oper,
        ULONG intLen1,
        UCHAR *pIntVal1,
        ULONG intLen2,
        UCHAR *pIntVal2
        )
{
    INTERNAL_SYNTAX_DISTNAME_STRING *pIntDistString_1;
    INTERNAL_SYNTAX_DISTNAME_STRING *pIntDistString_2;
    pIntDistString_1=(INTERNAL_SYNTAX_DISTNAME_STRING *) pIntVal1;
    pIntDistString_2=(INTERNAL_SYNTAX_DISTNAME_STRING *) pIntVal2;
    DPRINT(3,"EvalDistString entered\n");

    // A diststring is a dnt + a unicode string, so the length must be even.
    if((intLen1 & 1) || (intLen2 & 1)) {
        return DBSYN_BADCONV;
    }

    if((intLen1 > sizeof(DWORD)) &&
       (pIntDistString_1->data.structLen + sizeof(DWORD)) != intLen1) {
        // length passed in doesn't match the internal encoding of the length of
        // the string.
        return DBSYN_BADCONV;
    }

    if((intLen2 > sizeof(DWORD)) &&
       (pIntDistString_2->data.structLen + sizeof(DWORD)) != intLen2) {
        // length passed in doesn't match the internal encoding of the length of
        // the string.
        return DBSYN_BADCONV;
    }

    switch(Oper){
    case FI_CHOICE_PRESENT:
        return TRUE;

    case FI_CHOICE_EQUALITY:
        if(pIntDistString_1->tag != pIntDistString_2->tag) {
            return FALSE;
        }
        // compare the string;
        return EvalUnicode(pDB,  FI_CHOICE_EQUALITY,
                           PAYLOAD_LEN_FROM_STRUCTLEN(pIntDistString_1->data.structLen),
                           pIntDistString_1->data.byteVal,
                           PAYLOAD_LEN_FROM_STRUCTLEN(pIntDistString_2->data.structLen),
                           pIntDistString_2->data.byteVal);
        break;

    case FI_CHOICE_NOT_EQUAL:
        if(pIntDistString_1->tag != pIntDistString_2->tag) {
            return TRUE;
        }
        // compare the string;
        return EvalUnicode(pDB,  FI_CHOICE_NOT_EQUAL,
                           PAYLOAD_LEN_FROM_STRUCTLEN(pIntDistString_1->data.structLen),
                           pIntDistString_1->data.byteVal,
                           PAYLOAD_LEN_FROM_STRUCTLEN(pIntDistString_2->data.structLen),
                           pIntDistString_2->data.byteVal);
        break;

    default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
    }/*switch*/

    (void *) pDB;           /*NotReferenced*/

}/*EvalDistString*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
int
IntExtDistBinary (
        DBPOS FAR *pDB, USHORT extTableOp,
        ULONG intLen,   UCHAR *pIntVal,
        ULONG *pExtLen, UCHAR **ppExtVal,
        ULONG ulUpdateDnt, JET_TABLEID jTbl,
        ULONG flags)
{
    int             returnCode;
    SYNTAX_ADDRESS  *pSyntaxAddr;
    DWORD           dwSizeDiff;

    returnCode = IntExtDistString (pDB, extTableOp, intLen, pIntVal,
                             pExtLen, ppExtVal,
                             ulUpdateDnt, jTbl, flags);

    if (flags & INTEXT_WELLKNOWNOBJ) {
        // Early on in development the structlen of SYNTAX_ADDRESS's
        // was being calculated incorrectly.  In order to fix the
        // bug and allow users to upgrade, we need to fix those
        // values up before handing them up the stack.

        pSyntaxAddr = (SYNTAX_ADDRESS *)DATAPTR((SYNTAX_DISTNAME_BINARY*)*ppExtVal);
        if (pSyntaxAddr->structLen != (sizeof(GUID) + sizeof(ULONG)) ) {

            // Fix up the size of the buffer we hand back up.
            dwSizeDiff = pSyntaxAddr->structLen - (sizeof(GUID) + sizeof(ULONG));
            *pExtLen -= dwSizeDiff;

            // Fix up the structLen
            pSyntaxAddr->structLen = sizeof(GUID) + sizeof(ULONG);
        }
    }

    return returnCode;
}/*IntExtDistBinar*/
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

int
ExtIntDistBinary (
        DBPOS FAR *pDB, USHORT extTableOp,
        ULONG extLen,   UCHAR *pExtVal,
        ULONG *pIntLen, UCHAR **ppIntVal,
        ULONG ulUpdateDnt, JET_TABLEID jTbl,
        ULONG flags)
{
    return ExtIntDistString (pDB, extTableOp, extLen, pExtVal,
                             pIntLen, ppIntVal,
                             ulUpdateDnt, jTbl, flags);
}/*ExtIntDistBinary*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

int
EvalDistBinary (
        DBPOS FAR *pDB,
        UCHAR Oper,
        ULONG intLen1,
        UCHAR *pIntVal1,
        ULONG intLen2,
        UCHAR *pIntVal2
        )
{

    DPRINT(3,"EvalDistBinary entered\n");

    switch(Oper) {
    case FI_CHOICE_PRESENT:
        return TRUE;
        break;

    case FI_CHOICE_EQUALITY:
        return  (  intLen1 == intLen2
                 && memcmp(pIntVal1, pIntVal2, intLen1) == 0)
            ? TRUE : FALSE;
        break;

    case FI_CHOICE_NOT_EQUAL:
        return  !(intLen1 == intLen2 &&
                  (memcmp(pIntVal1, pIntVal2, intLen1) == 0));

    default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
    }/*switch*/

    (void *) pDB;           /*NotReferenced*/

}/*EvalDistBinary*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Substring match function.  If Case, all matches are case sensitive,
   otherwise they are case insensitive.  Both the substring and the
   target string are non-NULL otherwise a false is used.  PRESENT test
   should be used for NULL strings.

   The optional initial value is equivalent to "pattern*", the optional
   final value is equivalent to "*pattern" and any number of intermediate
   patterns which are equivalent to "*pattern*" are allowed.
*/


BOOL CompareSubStr(BOOL Case
                 ,SUBSTRING * pSub, UCHAR * pIntVal, ULONG intValLen){


   ULONG  start;
   USHORT newPos, num;
   ANYSTRINGLIST *pAnyList;

    DPRINT(3,"CompareSubStr entered\n");


   /* A NULL substring is not allowed*/

   if (!pSub || !pSub->initialProvided && pSub->AnyVal.count == 0
                                       && !pSub->finalProvided){
    DPRINT(1,"an empty substring was provided return FALSE\n");
    return FALSE;
   }


   /* Check optional initial left string match "pattern*" */

   if (pSub->initialProvided){
      if (SubCompare(Case, pSub->InitialVal.pVal, pSub->InitialVal.valLen
                   ,pIntVal, intValLen)  != 1){

         DPRINT1(1,"String failed initial substring test <%s>\n"
                 ,asciiz(pSub->InitialVal.pVal, (USHORT)pSub->InitialVal.valLen));
         return FALSE;
      }
      start =  pSub->InitialVal.valLen;
   }
   else
      start = 0;


   /* Check all intermediate patterns "*pattern1*pattern2*..." */


   for (num = 0, pAnyList = &(pSub->AnyVal.FirstAnyVal);
        num < pSub->AnyVal.count;
        num++, pAnyList = pAnyList->pNextAnyVal){

      newPos = SubCompare(Case, pAnyList->AnyVal.pVal, pAnyList->AnyVal.valLen
             ,(UCHAR *)(pIntVal + start),(SHORT)(intValLen - start));
      if (newPos == 0){
         DPRINT1(1,"String failed any test with string  <%s>\n"
                ,asciiz(pAnyList->AnyVal.pVal,(USHORT)pAnyList->AnyVal.valLen));
         return FALSE;
      }

      /* Move to new position in target string */

      start += newPos + pAnyList->AnyVal.valLen - 1;

   }

   /* Check optional final right string match "*pattern" */

   if (pSub->finalProvided){

      for (;;){

          newPos = SubCompare(Case, pSub->FinalVal.pVal, pSub->FinalVal.valLen
             ,(UCHAR *)(pIntVal + start),(SHORT)(intValLen - start));

          if (newPos == 0){

             /* No match ...return FALSE*/

             DPRINT1(1,"String failed final substring test <%s>\n"
                    ,asciiz(pSub->FinalVal.pVal, (USHORT)pSub->FinalVal.valLen));
             return FALSE;
          }
      else if (newPos == (intValLen - (start + pSub->FinalVal.valLen) + 1))
      {
             /* matched the end of the string....return TRUE*/

             DPRINT(3,"Substring matched\n");
             return TRUE;

          }
          else {

             /* Match but it wasn't the final substring..try again*/

             start += newPos + pSub->FinalVal.valLen - 1;
          }
      }/* For(;;)*/
   }/* if*/


   DPRINT(3,"Substring matched\n");
   return TRUE;


}/*CompareSubStr*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Match a ASCII substring and return the position in the ASCII string (1-n).
   These strings are not NULL terminated. A 0 indicates no match.  Null
   substrings and NULL strings are not allowed and always fail.  Case
   determines if the comparison is case sensitive or insensitive.  This
   function can be optimized if we find that substrings are often used.
*/

signed short SubCompare(BOOL Case
                      , UCHAR Sub[], signed long subSize
                      , UCHAR String[], signed long stringSize){

   int strPos, subPos;

   DPRINT(3,"SubCompare entered\n");

   if (subSize <= 0 || stringSize < subSize)
      return 0;

   for (strPos = 0 ; strPos < stringSize - subSize + 1; strPos++){

     if ( (Case  && Sub[0] == String[strPos])
        ||(!Case && (toupper((int)Sub[0]) == toupper((int)String[strPos])))){

          for (subPos = 1; subPos < subSize; subPos++){

             if ( (Case  && Sub[subPos] != String[subPos + strPos])
               ||(!Case && (toupper((int)Sub[subPos])
                         != toupper((int)String[subPos + strPos])))){
                break;
             }
          } /*substring match loop*/

          /* Check if the substring matched */

          if (subPos == subSize)
        return (SHORT)(strPos + 1);
      }
   }  /*string loop*/

   return 0;   /* Fail*/

}/*SubCompare*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Substring match function for unicode. All matches are case insensitive,
   Both the substring and the target string are non-NULL, otherwise false is
   returned.

*/


BOOL CompareUnicodeSubStr(THSTATE *pTHS,
                          SUBSTRING *pSub,
                          UCHAR *pIntVal,
                          ULONG intValLen)
{


   ULONG  start;
   ULONG  newPos, num, cchSub;
   ULONG  cchStr = (intValLen / sizeof(SYNTAX_UNICODE));
   SYNTAX_UNICODE  *pStr = (SYNTAX_UNICODE *) pIntVal;
   SYNTAX_UNICODE  *pSubString;
   ANYSTRINGLIST *pAnyList;

   DPRINT(3,"CompareUnicodeSubStr entered\n");

   /* A NULL substring is not allowed*/

   if (!pSub || !pSub->initialProvided && pSub->AnyVal.count == 0
                                       && !pSub->finalProvided){
    DPRINT(1,"an empty substring was provided return FALSE\n");
    return FALSE;
   }


   /* Check optional initial left string match "pattern*" */

   if (pSub->initialProvided)
   {
      pSubString = (SYNTAX_UNICODE *) pSub->InitialVal.pVal;
      cchSub = (pSub->InitialVal.valLen / sizeof(SYNTAX_UNICODE));
      if (UnicodeSubCompare(pTHS,
                            pSubString,
                cchSub,
                pStr,
                cchStr)  != 1)
      {
         DPRINT(3,"String failed initial substring test\n");
         return FALSE;
      }

      start =  (pSub->InitialVal.valLen / sizeof(SYNTAX_UNICODE));
   }
   else
      start = 0;


   /* Check all intermediate patterns "*pattern1*pattern2*..." */

   for (num = 0, pAnyList = &(pSub->AnyVal.FirstAnyVal);
        num < pSub->AnyVal.count;
        num++, pAnyList = pAnyList->pNextAnyVal)
   {
      pSubString = (SYNTAX_UNICODE *) pAnyList->AnyVal.pVal;
      cchSub = (pAnyList->AnyVal.valLen / sizeof(SYNTAX_UNICODE));
      newPos = UnicodeSubCompare(pTHS,
                                 pSubString,
                 cchSub,
                     (SYNTAX_UNICODE *) &(pStr[start]),
                 (cchStr - start));
      if (newPos == 0){
         DPRINT(3,"String failed any test with string\n");
         return FALSE;
      }

      /* Move to new position in target string */

      start += newPos + (pAnyList->AnyVal.valLen / sizeof(SYNTAX_UNICODE)) - 1;

   }

   /* Check optional final right string match "*pattern" */

   if (pSub->finalProvided){

      pSubString = (SYNTAX_UNICODE *) pSub->FinalVal.pVal;
      cchSub = (pSub->FinalVal.valLen / sizeof (SYNTAX_UNICODE));

      // find from what position from the end of pStr to compare

      // make sure we have enough characters and that we will not go back
      // into the medial/initial substring positions. (for ex., if the
      // initial substring in the filter is A, the medial substring  is B,
      // and the final substring is BC, we don't want it to match ABC,
      // the minimum possible matching string is ABBC)

      if ( (cchStr < cchSub) || ((cchStr - cchSub) < start) ) {
         // cannot match anyway
         return FALSE;
      }

      start = cchStr - cchSub;
      newPos = UnicodeSubCompare(pTHS,
                                 pSubString,
                 cchSub,
                 (SYNTAX_UNICODE *) &(pStr[start]),
                 cchSub);
      if (newPos == 0) {
          /* No match ...return FALSE*/
          DPRINT(3,"String failed final substring test\n");
          return FALSE;
      }
      else {
          /* matched the end of the string....return TRUE*/

          DPRINT(3,"Substring matched\n");
          return TRUE;

      }

   }/* if*/


   DPRINT(3,"Substring matched\n");
   return TRUE;


}/*CompareUnicodeSubStr*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Find the location of a unicode substring in a unicode string. (1-n)    */

ULONG
UnicodeSubCompare(THSTATE *pTHS,
                  SYNTAX_UNICODE *sub, ULONG cchSub,
                  SYNTAX_UNICODE *str, ULONG cchStr)
{
   ULONG strPos;
   ULONG cchMax;

   DPRINT(3,"UnicodeSubCompare entered\n");

   if (cchSub == 0 || cchSub > cchStr)
      return 0;

   cchMax = (cchStr - cchSub) + 1;

   for (strPos = 0 ; strPos < cchMax; strPos++, str++ )
   {
    if (CompareStringW(pTHS->dwLcid,
               (pTHS->fDefaultLcid ?
                DS_DEFAULT_LOCALE_COMPARE_FLAGS :
                LOCALE_SENSITIVE_COMPARE_FLAGS),
               (LPCWSTR) sub,
               cchSub,
               (LPCWSTR) str,
               cchSub) == 2)
        return (strPos + 1);
   }

   return 0;   /* Fail*/

}/*UnicodeSubCompare*/

#ifdef DBG
// global flag to turn on SD hash collision modeling
BOOL gfModelSDCollisions = FALSE;
#endif

// compute SD hash, pHash should point to a 16-byte buffer
VOID __inline computeSDhash(PSECURITY_DESCRIPTOR pSD, DWORD cbSD, BYTE* pHash, DWORD cbHash)
{
    MD5_CTX md5Ctx;
    Assert(cbHash == MD5DIGESTLEN);

    MD5Init(&md5Ctx);
    MD5Update(&md5Ctx, pSD, cbSD);
    MD5Final(&md5Ctx);

#ifdef DBG
    if (gfModelSDCollisions) {
        // screw up the hash so we get more collisions
        memset(&md5Ctx.digest[1], 0, MD5DIGESTLEN-1);
        // just keep the first bits
        md5Ctx.digest[0] &= 0x80;
    }
#endif

    memcpy(pHash, md5Ctx.digest, MD5DIGESTLEN);
}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Security Descriptor Internal to External conversion */

// NOTE!!!! When called without any value for SecurityInformation, all 4 parts
// of the SecurityDescriptor are returned.  Since DBGetAttVal and DBGetAttVal_AC
// DO NOT SET this value when calling here, those routines will always get the
// full Security Descriptor.

#define SEC_INFO_ALL (SACL_SECURITY_INFORMATION  | \
                      OWNER_SECURITY_INFORMATION | \
                      GROUP_SECURITY_INFORMATION | \
                      DACL_SECURITY_INFORMATION    )

// global flag controlling how SDs are stored
BOOL gStoreSDsInMainTable = FALSE;

int
IntExtSecDesc(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG intLen,   UCHAR *pIntVal,
              ULONG *pExtLen, UCHAR **ppExtVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG SecurityInformation)
{
    THSTATE  *pTHS=pDB->pTHS;
    NTSTATUS NtStatus;
    PISECURITY_DESCRIPTOR_RELATIVE RetrieveSD = NULL;
    ULONG ReturnSDLength;
    DWORD dwErr = 0;
    DWORD actualLength;
    int   delta;
    BOOL bIsStoredInSDTable;
    JET_RETINFO retinfo;
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD cbSD;

    Assert((SecurityInformation & ~INTEXT_VALID_FLAGS) == 0 && extTableOp != DBSYN_ADD);

    DPRINT(3,"IntExtSecDesc entered\n");

    // NOTE: to distinguish between the old SDs stored directly in the data table
    // and the new ones stored in the SD table we use the fact that the SD ID
    // (which is used as a key to point to the SD) is 8 bytes and the minimum
    // size of a SD is SECURITY_DESCRIPTOR_MIN_LENGTH, which is
    // 2 bytes + 1 word + 4 pointers = 20 bytes (or 36 bytes on Win64). Thus, if the
    // intLen is less than SECURITY_DESCRIPTOR_MIN_LENGTH then we must be looking
    // at an SD ID and should go to the SD table to pick up the actual SD.
    bIsStoredInSDTable = intLen < SECURITY_DESCRIPTOR_MIN_LENGTH;
    if (bIsStoredInSDTable) {
        Assert(intLen == sizeof(SDID));

        // position on the SD in the SD table (index is already set)
        JetMakeKeyEx(pDB->JetSessID, pDB->JetSDTbl, pIntVal, intLen, JET_bitNewKey);

        dwErr = JetSeekEx(pDB->JetSessID, pDB->JetSDTbl, JET_bitSeekEQ);
        if (dwErr) {
            // did not find a corresponding SD in the SD table
            DPRINT2(0, "Failed to locate SD for id=%ld, err=%d\n", *((SDID*)pIntVal), dwErr);
            Assert(!"Failed to locate SD -- not found in the SD table!");
            return dwErr;
        }
        DPRINT1(1, "Located SD for id %ld\n", *((SDID*)pIntVal));
    }

    switch (extTableOp) {
    case DBSYN_INQ:
        // read the SD
        if (bIsStoredInSDTable) {
            // try to guess the size of SD
            cbSD = DEFAULT_SD_SIZE;
            pSD = dbAlloc(cbSD);

            memset(&retinfo, 0, sizeof(retinfo));
            retinfo.cbStruct = sizeof(retinfo);
            retinfo.itagSequence = 1;

            // read the SD
            dwErr = JetRetrieveColumnWarnings(pDB->JetSessID,
                                              pDB->JetSDTbl,
                                              sdvalueid,
                                              pSD,
                                              cbSD,
                                              &cbSD,
                                              0,
                                              &retinfo);
            if (dwErr == JET_wrnBufferTruncated) {
                // grab more memory as asked
                pSD = dbReAlloc(pSD, cbSD);
                // and read again...
                dwErr = JetRetrieveColumnWarnings(pDB->JetSessID,
                                                  pDB->JetSDTbl,
                                                  sdvalueid,
                                                  pSD,
                                                  cbSD,
                                                  &cbSD,
                                                  0,
                                                  &retinfo);
            }

            if (dwErr != 0) {
                DPRINT1(0, "Error reading SD: 0x%x\n", dwErr);
                // failed!
                goto Exit;
            }

            pIntVal = pSD;
            intLen = cbSD;
        }

        RetrieveSD = (PISECURITY_DESCRIPTOR_RELATIVE)pIntVal;

        // Mask out just the important bits
        SecurityInformation &= SEC_INFO_ALL;

        if(!SecurityInformation ||
           SecurityInformation == SEC_INFO_ALL) {

            // They are really asking for everything
            SecurityInformation = SEC_INFO_ALL;

            *pExtLen   = intLen;

            MAKEBIG_VALBUF(*pExtLen);
            *ppExtVal = pDB->pValBuf;       // user output points to val buf

            memcpy(*ppExtVal, pIntVal, intLen);
        }
        else {
            //
            // blank out the parts that aren't to be returned
            //

            if ( !(SecurityInformation & SACL_SECURITY_INFORMATION) ) {
                RetrieveSD->Control  &= ~SE_SACL_PRESENT;
            }

            if ( !(SecurityInformation & DACL_SECURITY_INFORMATION) ) {
                RetrieveSD->Control  &= ~SE_DACL_PRESENT;
            }

            if ( !(SecurityInformation & OWNER_SECURITY_INFORMATION) ) {
                RetrieveSD->Owner = 0;
            }

            if ( !(SecurityInformation & GROUP_SECURITY_INFORMATION) ) {
                RetrieveSD->Group = 0;
            }


            //
            // Determine how much memory is needed for a self-relative
            // security descriptor containing just this information.
            //
            ReturnSDLength = 0;
            NtStatus = RtlMakeSelfRelativeSD(
                    (PSECURITY_DESCRIPTOR)RetrieveSD,
                    NULL,
                    &ReturnSDLength
                    );

            if (NtStatus != STATUS_BUFFER_TOO_SMALL) {
                dwErr = DBSYN_SYSERR;
                goto Exit;
            }

            *pExtLen = ReturnSDLength;

            MAKEBIG_VALBUF(ReturnSDLength);
            *ppExtVal = pDB->pValBuf;       // user output points to val buf

            //
            // make an appropriate self-relative security descriptor
            //

            NtStatus = RtlMakeSelfRelativeSD(
                    (PSECURITY_DESCRIPTOR)RetrieveSD,
                    *ppExtVal,
                    &ReturnSDLength);

            if(!NT_SUCCESS(NtStatus)) {
                dwErr = DBSYN_SYSERR;
                goto Exit;
            }
        }
Exit:
        if (pSD) {
            dbFree(pSD);
        }
        break;

    case DBSYN_REM:
        // remove the SD
        if (bIsStoredInSDTable) {
            DPRINT(1, "Successfully located SD, decrementing refcount\n");
            // need to dereference the SD. We are positioned on the right row in SD table
            delta = -1;
            JetEscrowUpdateEx(pDB->JetSessID,
                              pDB->JetSDTbl,
                              sdrefcountid,
                              &delta,
                              sizeof(delta),
                              NULL,     // pvOld
                              0,        // cbOldMax
                              NULL,     // pcbOldActual
                              0);       // grbit


        }
        break;

    default:
        DPRINT(1,"We should never be here\n");
        dwErr = DBSYN_BADOP;
    }

    return dwErr;

    (void)   jTbl;          /*NotReferenced*/
    (void)   ulUpdateDnt;   /*NotReferenced*/
#undef SEC_INFO_ALL
}/*IntExtSecDesc*/


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Security Descriptor External to Internal conversion */

int
ExtIntSecDesc(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG extLen,   UCHAR *pExtVal,
              ULONG *pIntLen, UCHAR **ppIntVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG flags)
{
    THSTATE *pTHS=pDB->pTHS;
    DWORD   dwErr = 0;
    int     refCount;
    JET_SETINFO setinfo;
    BOOL    bSdIsPresent;
    BYTE    sdHash[MD5DIGESTLEN];
    DWORD   cbActual;

    Assert(extTableOp != DBSYN_REM);

    DPRINT(3,"ExtIntDescDesc entered\n");

    if (gStoreSDsInMainTable) {
        // no conversion required!
        *ppIntVal  = pExtVal;
        *pIntLen   = extLen;
        return 0;
    }

    // compute the MD5 hash of the value.
    // we need to do this for both DBSYN_INQ and DBSYN_ADD
    computeSDhash((PSECURITY_DESCRIPTOR)pExtVal, extLen, sdHash, sizeof(sdHash));

    // change the index to hash
    JetSetCurrentIndex4Success(pDB->JetSessID, pDB->JetSDTbl, SZSDHASHINDEX, &idxSDHash, 0);

    // position on the SD in the SD table (index is already set)
    JetMakeKeyEx(pDB->JetSessID, pDB->JetSDTbl, &sdHash, sizeof(sdHash), JET_bitNewKey);
    dwErr = JetSeekEx(pDB->JetSessID, pDB->JetSDTbl, JET_bitSeekEQ | JET_bitSetIndexRange);

    if (dwErr == JET_errRecordNotFound) {
        bSdIsPresent = FALSE;
        dwErr = 0;
    }
    else if (dwErr) {
        // some other error happened
        DPRINT1(0, "Error locating SD 0x%x\n", dwErr);
        goto Exit;
    }
    else {
#ifdef WE_ARE_NOT_PARANOID
        // assume that if MD5 hashes match, then the values will also match
        bSdIsPresent = TRUE;
#else
        // Let's be paranoid and check that the SD is the same
        PBYTE pSD;
        pSD = THAllocEx(pTHS, extLen);
        bSdIsPresent = FALSE;
        while (dwErr == 0) {
            // read the SD
            dwErr = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetSDTbl, sdvalueid, pSD, extLen, &cbActual, 0, NULL);
            if (dwErr == 0 && cbActual == extLen && memcmp(pSD, pExtVal, extLen) == 0) {
                // we found a match!
                bSdIsPresent = TRUE;
                break;
            }
#ifdef DBG
            if (gfModelSDCollisions) {
                DPRINT(0, "SD hash collision. This is normal -- hash collision modeling is ON\n");
            }
            else {
                // ok, according to DonH, the universe nears its end.
                Assert(!"MD5 hash collision occured! Run for your lives!");
            }
#endif
            dwErr = JetMove(pDB->JetSessID, pDB->JetSDTbl, JET_MoveNext, 0);
        }
        if (dwErr == JET_errNoCurrentRecord) {
            // ok, no more records.
            dwErr = 0;
        }
        THFreeEx(pTHS, pSD);
#endif
    }

    if (bSdIsPresent) {
        // compute the internal value: read the ID
        MAKEBIG_VALBUF(sizeof(SDID));
        *pIntLen = sizeof(SDID);
        *ppIntVal = pDB->pValBuf;
        dwErr = JetRetrieveColumn(pDB->JetSessID, pDB->JetSDTbl, sdidid, *ppIntVal, *pIntLen, &cbActual, 0, NULL);
    }

    switch (extTableOp) {
    case DBSYN_INQ:
        if (!bSdIsPresent) {
            dwErr = DIRERR_OBJ_NOT_FOUND;
        }
        // nothing else to do, internal value is already computed
        break;

    case DBSYN_ADD:
        if (!bSdIsPresent) {
            // did not find a corresponding SD in the SD table
            DPRINT(1, "Failed to locate SD, adding a new record\n");

            memset(&setinfo, 0, sizeof(setinfo));
            setinfo.cbStruct = sizeof(setinfo);
            setinfo.itagSequence = 1;

            MAKEBIG_VALBUF(sizeof(SDID));
            *pIntLen = sizeof(SDID);
            *ppIntVal = pDB->pValBuf;

            // note: we are not setting sdrefcount, since its default value is 1 -- that's what we need
            if ((dwErr = JetPrepareUpdate(pDB->JetSessID, pDB->JetSDTbl, JET_prepInsert)) ||
                // read the new ID right away
                (dwErr = JetRetrieveColumn(pDB->JetSessID, pDB->JetSDTbl, sdidid, *ppIntVal, sizeof(SDID), &cbActual, JET_bitRetrieveCopy, NULL)) ||
                (dwErr = JetSetColumn(pDB->JetSessID, pDB->JetSDTbl, sdhashid, sdHash, sizeof(sdHash), 0, NULL)) ||
                (dwErr = JetSetColumn(pDB->JetSessID, pDB->JetSDTbl, sdvalueid, pExtVal, extLen, 0, &setinfo)) ||
                (dwErr = JetUpdate(pDB->JetSessID, pDB->JetSDTbl, NULL, 0, 0))
                ) {
                // one of the above calls failed. Cancel.
                JetPrepareUpdate(pDB->JetSessID, pDB->JetSDTbl, JET_prepCancel);
            }
        }
        else {
            // found a matching SD, increment the refcount
            DPRINT(1, "Successfully located SD, incrementing refcount\n");

            refCount = 1;
            JetEscrowUpdateEx(pDB->JetSessID,
                              pDB->JetSDTbl,
                              sdrefcountid,
                              &refCount,
                              sizeof(refCount),
                              NULL,     // pvOld
                              0,        // cbOldMax
                              NULL,     // pcbOldActual
                              0);       // grbit
        }
    }

Exit:
    // change the index back to SDID (pass NULL to set primary index)
    JetSetCurrentIndex4Success(pDB->JetSessID, pDB->JetSDTbl, NULL, &idxSDId, 0);

    return dwErr;

    (void)   jTbl;     /*NotReferenced*/
    (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntSecDesc*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare SD value.  "Presence,=" tests are allowed.
*/

int
EvalSecDesc (DBPOS FAR *pDB,  UCHAR Oper,
             ULONG intLen1, UCHAR *pIntVal1,
             ULONG intLen2,  UCHAR *pIntVal2
             )
{
    PUCHAR pExtVal1, pExtVal2;
    DWORD extLen1, extLen2;
    DWORD err;
    BOOL match;
    THSTATE* pTHS = pDB->pTHS;

    DPRINT(3,"EvalSecDesc entered\n");

    switch(Oper) {
    case FI_CHOICE_PRESENT:
        return TRUE;
        break;

    case FI_CHOICE_EQUALITY:
        // You'll note that we don't advertise this comparitor in the
        // rgValidOperators array.  That is because this is binary comparison,
        // not functional comparison.  However, it is good enough (and
        // necessary) for internal use.

        if (intLen1 == sizeof(SDID) && intLen2 == sizeof(SDID)) {
            // most probable case -- both SDs are in the new format. Compare the ids
            if (*(SDID*)pIntVal1 == *(SDID*)pIntVal2) {
                return TRUE;
            }
            // even though SDIDs are different, we can not tell if the actual
            // SDs are different. We must read them an compare.
        }
        // Convert them both to actual SD values
        if (intLen1 == sizeof(SDID)) {
            // first one is in the new format, convert to external
            PUCHAR tmp;
            err = IntExtSecDesc(pDB, DBSYN_INQ, intLen1, pIntVal1, &extLen1, &tmp, 0, 0, 0);
            if (err) {
                return err;
            }
            // must make a copy, because the second IntExtSecDesc might use the conversion buffer
            pExtVal1 = dbAlloc(extLen1);
            memcpy(pExtVal1, tmp, extLen1);
        }
        else {
            // first one in the old format, leave it as is
            pExtVal1 = pIntVal1;
            extLen1 = intLen1;
        }
        if (intLen2 == sizeof(SDID)) {
            // second one is in the new format, convert to external
            err = IntExtSecDesc(pDB, DBSYN_INQ, intLen2, pIntVal2, &extLen2, &pExtVal2, 0, 0, 0);
            if (err) {
                if (pExtVal1 != pIntVal1) {
                    dbFree(pExtVal1);
                }
                return err;
            }
        }
        else {
            // second one in the old format, leave it as is
            pExtVal2 = pIntVal2;
            extLen2 = intLen2;
        }
        // now compare the external values
        match = extLen1 == extLen2 && memcmp(pExtVal1, pExtVal2, extLen1) == 0;
        if (pExtVal1 != pIntVal1) {
            dbFree(pExtVal1);
        }
        return match;
        break;

    default:
        DPRINT(1,"Problem with OPERATION TYPE return error\n");
        return DBSYN_BADOP;
        break;
    }

}/*EvalSecDesc*/

/*--------------------------------------------------------------------------*/
/*--------------------------------------------------------------------------*/
/* This routine does in place swap of the the last sub-authority of the SID */
void
InPlaceSwapSid(PSID pSid)
{
    ULONG ulSubAuthorityCount;

    ulSubAuthorityCount= *(RtlSubAuthorityCountSid(pSid));
    if (ulSubAuthorityCount > 0)
    {
        PBYTE  RidLocation;
        BYTE   Tmp[4];

        RidLocation =  (PBYTE) RtlSubAuthoritySid(
                             pSid,
                             ulSubAuthorityCount-1
                             );

        //
        // Now byte swap the Rid location
        //

        Tmp[0] = RidLocation[3];
        Tmp[1] = RidLocation[2];
        Tmp[2] = RidLocation[1];
        Tmp[3] = RidLocation[0];

        RtlCopyMemory(RidLocation,Tmp,sizeof(ULONG));
    }
}
/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Sid External to Internal conversion  requires byte swapping the Rid, in case
   of Account Sids. However since we cannot apriori determine wether a given Sid
   is a domain Sid or Account Sid we will byte swap the last subauthority on the
   Sid
*/
int ExtIntSid(DBPOS FAR *pDB, USHORT extTableOp,
                ULONG extLen,   UCHAR *pExtVal,
                ULONG *pIntLen, UCHAR **ppIntVal,
                ULONG ulUpdateDnt, JET_TABLEID jTbl,
                ULONG flags)
{
    THSTATE  *pTHS=pDB->pTHS;
    DWORD    cb;

   DPRINT(3,"ExtIntSid entered\n");

   // Validate The Sid

   if (    !RtlValidSid(pExtVal)
        || ((cb = RtlLengthSid(pExtVal)) != extLen)
        || (cb > sizeof(NT4SID)) )
   {
       return 1;
   }

   MAKEBIG_VALBUF(extLen);
   *ppIntVal  = pDB->pValBuf;
   *pIntLen   = extLen;

   RtlCopyMemory(*ppIntVal,pExtVal,extLen);

   InPlaceSwapSid(*ppIntVal);


   return 0;

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*ExtIntSid*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Sid Internal to External conversion */

int IntExtSid(DBPOS FAR *pDB, USHORT extTableOp,
                ULONG intLen,   UCHAR *pIntVal,
                ULONG *pExtLen, UCHAR **ppExtVal,
                ULONG ulUpdateDnt, JET_TABLEID jTbl,
                ULONG flags)
{
    Assert(!(flags & ~(INTEXT_VALID_FLAGS)));

   DPRINT(3,"IntExtSid entered\n");

   //
   // For an Account Sid byte swap the Rid portion, so
   // that we index it correctly.
   //

   //
   // Since Internal to external conversion a Sid is just a
   // byte swapping on the Rid portion, the same code can be
   // used to do both
   //

   return ( ExtIntSid(pDB,extTableOp,intLen,pIntVal,
                        pExtLen, ppExtVal, ulUpdateDnt, jTbl,
                        flags));

   (void *) pDB;           /*NotReferenced*/
   (void)   extTableOp;    /*NotReferenced*/
   (void)   jTbl;      /*NotReferenced*/
   (void)   ulUpdateDnt;   /*NotReferenced*/

}/*IntExtSid*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Compare Sid values.  Since values to be compared are always internal
   values we can call EvalOctet
*/

int EvalSid(DBPOS FAR *pDB,  UCHAR Oper, ULONG intLen1,
              UCHAR *pIntVal1, ULONG intLen2,  UCHAR *pIntVal2)
{
    DPRINT(3,"EvalSid entered\n");

    return(EvalOctet(pDB,Oper,intLen1,pIntVal1,intLen2,pIntVal2));
}


// Now, put all thse into an array so the rest of the world can use them.
#define TESTFUN(test) {IntExt##test, ExtInt##test, Eval##test}
const DBSyntaxStruct gDBSyntax[MAXSYNTAX]   = {
    TESTFUN(Und),                       //syntax 0
    TESTFUN(Dist),                      //syntax 1
    TESTFUN(ID),                        //syntax 2
    TESTFUN(Case),                      //syntax 3
    TESTFUN(NoCase),                    //syntax 4
    TESTFUN(Case),         //Print_case
    TESTFUN(Case),         //Numeric print
    TESTFUN(DistBinary),                    //syntax 7
    TESTFUN(Bool),                      //syntax 8
    TESTFUN(Int),                       //syntax 9
    TESTFUN(Octet),                     //syntax 10
    TESTFUN(Time),          //Time
    TESTFUN(Unicode),      //Unicode
    TESTFUN(ID),           //Address
    TESTFUN(DistString),                  //syntax 14
    TESTFUN(SecDesc),      // Security Descriptor
    TESTFUN(I8),           //Large Integer
    TESTFUN(Sid)
};

// Small routine to determine attributes that are "Secret Data"
// None of the atts here can be GC-replicated. If you add anything here
// make sure that the att is not GC-replicated or will not need to be
// GC-replicated ever. Schema validation code makes sure that no att
// in this list can be marked as GC-replicated. If you add an att to this
// list that is already GC-replicated, any modification of that attribute
// in the schema, except to take un-GC-Replicate it, will fail.

BOOL
DBIsSecretData(ATTRTYP attrType)
{
    switch(attrType)
    {
    case ATT_UNICODE_PWD:
    case ATT_DBCS_PWD:
    case ATT_NT_PWD_HISTORY:
    case ATT_LM_PWD_HISTORY:
    case ATT_SUPPLEMENTAL_CREDENTIALS:
    case ATT_CURRENT_VALUE:
    case ATT_PRIOR_VALUE:
    case ATT_INITIAL_AUTH_INCOMING:
    case ATT_INITIAL_AUTH_OUTGOING:
    case ATT_TRUST_AUTH_INCOMING:
    case ATT_TRUST_AUTH_OUTGOING:
    case ATT_MS_DS_EXECUTESCRIPTPASSWORD:
        return(TRUE);
    default:
        return(FALSE);
    }
}

DWORD
DBGetExtraHackyFlags(ATTRTYP attrType)
{
    DWORD dwRetFlags = 0;

    switch (attrType) {
    case ATT_WELL_KNOWN_OBJECTS:
    case ATT_OTHER_WELL_KNOWN_OBJECTS:
        dwRetFlags |= INTEXT_WELLKNOWNOBJ;
    }

    return dwRetFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dbsubj.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1989 - 1999
//
//  File:       dbsubj.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Defines various functions for ref-counting DNs and translating them to/from
    DNTs (aka tags).

DETAILS:

    All DNs are stored internally as DNTs (ULONGs).  There is exactly one such
    DNT for each object or phantom in the local database.

    Phantoms generally have one, two, or three attributes -- ATT_RDN (always),
    ATT_OBJECT_GUID (if a reference phantom rather than a structural phantom),
    and ATT_OBJECT_SID (if ATT_OBJECT_GUID is present and the object referenced
    has a SID).  Noticeably absent is ATT_OBJ_DIST_NAME -- this property is
    unique to instantiated objects (be they deleted or not).
    
    (Reference phantoms (i.e., those with GUIDs) may also have ATT_USN_CHANGED
    attributes, used by the stale phantom cleanup daemon.)

    A DN receives one ref-count for:

      o  each direct child, whether that child is an object or phantom, and
      o  each DN-valued attribute that references it, whether that attribute
         is hosted on itself or on some other object.
      o  whether the clean_col column is non-null

    A corollary to the above is that since ATT_OBJ_DIST_NAME is present on a
    record if-and-only-if that record is an instantiated object (not a phantom)
    and ATT_OBJ_DIST_NAME is a DN-valued attribute, all objects have a minimum
    ref-count of 1.

    Note that no distinction is made between link and non-link attributes.  Even
    though a link attribute causes a backlink attribute to be added to its
    target, only one ref-count is added as a result of adding a link attribute,
    and as with non-link attributes that ref-count is added to the target DN.
    No ref-count is added to the host DN for being the target of the backlink.
    No dangling backlink reference is possible since if the host DN is removed
    it must have first been logically deleted, which implicitly removes all link
    attributes and their associated targets' backlinks.  The only difference
    that should be noted between link and non-link attributes with respect to DN
    ref-counting is that logical deletions remove both links and backlinks from
    the object, but do not remove other DN-valued attributes.  (Actually, even
    this distinction has partially disappeared -- most non-linked attributes
    are removed during logical deletion these days, too.)

    If an object is deleted, one tombstone lifetime later that object's
    non-essential attributes are stripped (including ATT_OBJ_DIST_NAME) and the
    object is demoted to a phantom.  Should the ref-count on a phantom reach 0,
    and after one tombstone lifetime has transpired since the record was created
    (if it was never a real object) or logically deleted (if it was once a real
    object), that DN is removed by the next pass of DN garbage collection.

CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <mdlocal.h>
#include <dsatools.h>

#include <mdcodes.h>
#include <dsevent.h>
#include <dstaskq.h>
#include <dsexcept.h>
#include "objids.h"	/* Contains hard-coded Att-ids and Class-ids */
#include "debug.h"	/* standard debugging header */
#define DEBSUB "DBSUBJ:" /* define the subsystem for debugging */

#include "dbintrnl.h"
#include "anchor.h"
#include <ntdsctr.h>
#include <filtypes.h>

#include <fileno.h>
#define  FILENO FILENO_DBSUBJ

static ULONG FakeCtr;
volatile ULONG *pcNameCacheTry = &FakeCtr;
volatile ULONG *pcNameCacheHit = &FakeCtr;

/* DNRead flags.*/
#define DN_READ_SET_CURRENCY        1

#ifdef INCLUDE_UNIT_TESTS
// Test hook for refcount test.
GUID gLastGuidUsedToCoalescePhantoms = {0};
GUID gLastGuidUsedToRenamePhantom = {0};
#endif

extern
DWORD
DBPropagationsExist (
        DBPOS * pDB
        );

void
sbTablePromotePhantom(
    IN OUT  DBPOS *     pDB,
    IN      ULONG       dntPhantom,
    IN      ULONG       dntObjParent,
    IN      WCHAR *     pwchRDN,
    IN      DWORD       cbRDN
    );

DWORD
sbTableGetTagFromGuid(
    IN OUT  DBPOS *       pDB,
    IN      JET_TABLEID   tblid,
    IN      GUID *        pGuid,
    OUT     ULONG *       pTag,             OPTIONAL
    OUT     d_memname **  ppname,           OPTIONAL
    OUT     BOOL *        pfIsRecordCurrent OPTIONAL
    );

DWORD
sbTableGetTagFromStringName(
    IN  DBPOS *       pDB,
    IN  JET_TABLEID   tblid,
    IN  DSNAME *      pDN,
    IN  BOOL          fAddRef,
    IN  BOOL          fAnyRDNType,    
    IN  DWORD         dwExtIntFlags,
    OUT ULONG *       pTag,             OPTIONAL
    OUT d_memname **  ppname,           OPTIONAL
    OUT BOOL *        pfIsRecordCurrent OPTIONAL
    );

void __inline SwapDWORD(DWORD * px, DWORD * py)
{
    DWORD tmp = *px;
    *px = *py;
    *py = tmp;
}

void __inline SwapPTR(VOID ** ppx, VOID ** ppy)
{
    VOID * tmp = *ppx;
    *ppx = *ppy;
    *ppy = tmp;
}

ULONG
DNwrite(
    IN OUT  DBPOS *     pDB,
    IN OUT  d_memname * rec,
    IN      ULONG       dwFlags
    )
/*++

Routine Description:

    Inserts a new record/DNT.  This record may correspond to either a phantom or
    an object.
    
    Adds no refcount for itself, but *does* add-ref its parent.

Arguments:

    pDB (IN/OUT)
    
    rec (IN/OUT) - holds the RDN, RDN type, parent DNT, ancestors, and optional
        GUID/SID.  On return, the ancestors list is updated to include the DNT
        of the current record.
    
    dwFlags (IN) - 0 or EXTINT_NEW_OBJ_NAME.  The latter asserts that this
        record is being inserted for a new object, and therefore should be
        updated in the object table cursor (pDB->JetObjTbl).

Return Values:

    The DNT of the inserted record.

    Throws database exception on error.

--*/
{
    char		objval = 0;
    JET_TABLEID		tblid;
    DSTIME		ulDelTime;
    ULONG		cb;
    NT4SID              sidInternalFormat;
    ULONG               ulDNT;
    DWORD               cRef = 0;
    BOOL                fRecHasGuid;
    
    DPRINT(2, "DNwrite entered\n");

    fRecHasGuid = !fNullUuid(&rec->Guid);

    Assert(VALID_DBPOS(pDB));
    Assert((0 == rec->SidLen) || fRecHasGuid);
    Assert((0 == rec->SidLen) || RtlValidSid(&rec->Sid));

    if ( dwFlags & EXTINT_NEW_OBJ_NAME )
    {
        // Inserting a new object; since we're already udpating this DNT in
        // the object table, use its update context.
        tblid = pDB->JetObjTbl;
    }
    else
    {
        // Inserting a phantom DNT; the object table is already prepared in an
        // update of a different DNT, so use the search table (which requires
        // us to prepare and terminate our own update).
        tblid = pDB->JetSearchTbl;

        // We're going to use the search table to do the write, so we must do a
        // JetPrepare first.
        JetPrepareUpdateEx(pDB->JetSessID, pDB->JetSearchTbl, JET_prepInsert);
    }

    /* indicate that data portion is missing;
     * set the deletion time in case this record will never become an
     * object. If it does become an object the del time is removed. If
     * it doesn't and the reference count drops to 0, this record will be
     * removed by garbage collection;
     * Set the Parent DNT
     */

    ulDelTime = DBTime();
    /* get the DNT */

    JetRetrieveColumnSuccess(pDB->JetSessID, tblid, dntid, &ulDNT,
                             sizeof(ulDNT), &cb, JET_bitRetrieveCopy, NULL);

    // A newly created row is treated differently when flushing
    // the dnread cache. Namely, the global cache's invalidation
    // logic is not triggered because a newly created row could
    // not be in the cache.
    pDB->NewlyCreatedDNT = ulDNT;

    rec->pAncestors[rec->cAncestors] = ulDNT;
    rec->cAncestors++;

    JetSetColumnEx(pDB->JetSessID, tblid, objid, &objval,
                   sizeof(objval), 0, NULL);
    JetSetColumnEx(pDB->JetSessID, tblid, deltimeid, &ulDelTime,
                   sizeof(ulDelTime), 0, NULL);
    JetSetColumnEx(pDB->JetSessID, tblid, pdntid, &rec->tag.PDNT,
                   sizeof(rec->tag.PDNT),  0, NULL);
    JetSetColumnEx(pDB->JetSessID, tblid, ancestorsid, rec->pAncestors,
                   rec->cAncestors * sizeof(DWORD), 0, NULL);
    // The rdnType is stored in the DIT as the msDS_IntId, not the
    // attributeId. This means an object retains its birth name
    // even if unforeseen circumstances allow the attributeId
    // to be reused.
    JetSetColumnEx(pDB->JetSessID, tblid, rdntypid, &rec->tag.rdnType,
                   sizeof(rec->tag.rdnType), 0, NULL);
    JetSetColumnEx(pDB->JetSessID, tblid, rdnid, rec->tag.pRdn,
                   rec->tag.cbRdn, 0, NULL);

    if (!(dwFlags & EXTINT_NEW_OBJ_NAME) && fRecHasGuid) {
        USN usnChanged;
        
        // We're inserting a new reference phantom -- add its GUID and SID
        // (if any) to the record. Also, give it a USN changed so that the code
        // to freshen stale phantoms can find it.
        JetSetColumnEx(pDB->JetSessID, tblid, guidid, &rec->Guid,
                       sizeof(GUID), 0, NULL);

        if (0 != rec->SidLen) {
            // Write SID in internal format.
            memcpy(&sidInternalFormat, &rec->Sid, rec->SidLen);
            InPlaceSwapSid(&sidInternalFormat);

            JetSetColumnEx(pDB->JetSessID, tblid, sidid, &sidInternalFormat,
                           rec->SidLen, 0, NULL);
        }

        usnChanged = DBGetNewUsn();
        
        JetSetColumnEx(pDB->JetSessID, tblid, usnchangedid,
                       &usnChanged, sizeof(usnChanged), 0, NULL);
    }

    /* Set reference count */

    JetSetColumnEx(pDB->JetSessID, tblid, cntid, &cRef, sizeof(cRef), 0, NULL);
        

    /* update the record. */

    if ( !( dwFlags & EXTINT_NEW_OBJ_NAME ) )
    {
        Assert( tblid == pDB->JetSearchTbl );

        JetUpdateEx(pDB->JetSessID, tblid, NULL, 0, 0);

        // Note that pDB->JetSearchTbl is no longer positioned on the inserted
        // object -- it's positioned wherever it was prior to the
        // JetPrepareUpdate() (which should be the record with DNT pDB->SDNT).
    }

    // Add a refcount to the parent, since we've just given it a new child.
    DBAdjustRefCount(pDB, rec->tag.PDNT, 1);
    
    /* return the DNT of the record written */
    return ulDNT;
}



d_memname *
DNread(DBPOS *pDB,
       ULONG tag,
       DWORD dwFlags)
/*++

  Find a record by DNT.  Look in the cache first.  If no luck there, read
  the record and put it in the cache.

--*/    
{

    DWORD        index, i;
    JET_ERR	 err;
    d_memname *  pname = NULL;

    DPRINT1(4, "DNread entered tag: 0x%x\n", tag);

    Assert(VALID_DBPOS(pDB));

    if(pDB != pDBhidden) {
        /* Now, look in the cache to avoid doing the read. */
        dnGetCacheByDNT(pDB,tag,&pname);
    }
    
    if ((NULL == pname) || (dwFlags & DN_READ_SET_CURRENCY)) {
        /* Make target record current for pDB->JetSearchTbl */
        pDB->SDNT = 0;
        
        JetSetCurrentIndex4Success(pDB->JetSessID,
                                   pDB->JetSearchTbl,
                                   SZDNTINDEX,
                                   &idxDnt,
                                   0);
        
        JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl, &tag, sizeof(tag),
                     JET_bitNewKey);

        err = JetSeek(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekEQ);
        if (err) {
            DsaExcept(DSA_DB_EXCEPTION, err, tag);
        }

        pDB->SDNT = tag;

        // Add record to read cache if it isn't there already.
        if (NULL == pname) {
            pname = DNcache(pDB, pDB->JetSearchTbl, FALSE);
        }
    }

    Assert(NULL != pname);

    return pname;
}


/*++ DNChildFind
 *
 * Given a DNT and an RDN, returns a cache element for the entry with
 * the specified RDN that is a child of the specified DNT.  If no such
 * object exists, returns ERROR_DS_OBJ_NOT_FOUND.  
 * The attribute type of the RDN is mandatory, and checked for accuracy.
 */
ULONG
DNChildFind(DBPOS *pDB,
            JET_TABLEID tblid,
            BOOL fEnforceType,
	    ULONG parenttag,
	    WCHAR *pRDN,
	    ULONG cbRDN,
	    ATTRTYP rdnType,
	    d_memname **ppname,
	    BOOL * pfIsRecordCurrent)
{
    THSTATE *pTHS = pDB->pTHS;
    d_memname *pname=NULL;
    DWORD i,j;
    JET_ERR err;
    ULONG childtag;
    ULONG actuallen;
    ATTRTYP trialtype;
    BYTE *pLocalRDN = NULL;
    DWORD cbActual;
#if DBG
    // We assume we are on the SZPDNTINDEX
    char    szIndexName[JET_cbNameMost];
    JetGetCurrentIndex(pDB->JetSessID, tblid,
                       szIndexName, JET_cbNameMost);
    Assert(strcmp(szIndexName,SZPDNTINDEX)==0);
#endif
    
    Assert(VALID_DBPOS(pDB));

    /* Now, look in the cache to avoid doing the read. */
    if(pDB != pDBhidden) {
        // Note that this is enforcing type here, even if fEnforceType = FALSE.
        // If we don't find it here with a type checking on, we will continue
        // and do a DB lookup with type checking off.
        if(dnGetCacheByPDNTRdn(pDB,parenttag, cbRDN, pRDN, rdnType, ppname)) {
            // found it.
            *pfIsRecordCurrent = FALSE;
            return 0;
        }
    }

    // ok, we couldn't find it in the cache.  go to the record directly
    // and then read it in a cache friendly manner
    HEAPVALIDATE
    JetMakeKeyEx(pDB->JetSessID,
		 tblid,
		 &parenttag,
		 sizeof(parenttag),
		 JET_bitNewKey);
    
    JetMakeKeyEx(pDB->JetSessID,
		 tblid,
		 pRDN,
		 cbRDN,
		 0);
    err = JetSeek(pDB->JetSessID,
		  tblid,
		  JET_bitSeekEQ );
    if (err) {
        DPRINT4(3, "No child '%*.*S' with parent tag 0x%x.\n",
                cbRDN/2, cbRDN/2, pRDN, parenttag);
	return ERROR_DS_OBJ_NOT_FOUND;
    }


    // Was our key truncated?
    err = JetRetrieveKey(pDB->JetSessID, tblid, NULL, 0, &cbActual, 0);
    if((err != JET_errSuccess) && (err != JET_wrnBufferTruncated)) {
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
    }

    if(cbActual >= JET_cbKeyMost) {
        // OK we've found something, but not necessarily the right thing since
        // key was potentially truncated.
        pLocalRDN = THAllocEx(pTHS,cbRDN);
        
        err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                        tblid,
                                        rdnid,
                                        pLocalRDN,
                                        cbRDN,
                                        &cbActual,
                                        0,
                                        NULL);
        switch (err) {
        case JET_errSuccess:
            // Successfully read an RDN
            if (gDBSyntax[SYNTAX_UNICODE_TYPE].Eval(
                    pDB,
                    FI_CHOICE_EQUALITY,
                    cbRDN,
                    (PUCHAR)pRDN,
                    cbActual,
                    pLocalRDN)) {
                // And it's the correct RDN.
                break;
            }
            // Else, 
            //   The key was right, but the value was wrong.  It's not the
            // correct object.  fall through and return OBJ_NOT_FOUND
        case JET_wrnBufferTruncated:
            // The RDN found was clearly too long, so it can't be the correct
            // object.  Return OBJ_NOT_FOUND
            // Didn't find the object.
            DPRINT5(3, "No child '%*.*S' with type 0x%x, parent tag 0x%x.\n",
                    cbRDN/2, cbRDN/2, pRDN, rdnType, parenttag);
            THFreeEx(pTHS,pLocalRDN);
            return ERROR_DS_KEY_NOT_UNIQUE;
            break;
            
        default:
            // The retrievecolumn failed in some obscure way.  We can't be sure
            // of anything.  Raise the same exception that
            // JetRetrieveColumnSuccess would have raised.
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
            break;
        }
        THFreeEx(pTHS,pLocalRDN);
    }

    // OK, we are now definitely on an object with the correct RDN and PDNT.
    // See if the type is correct.
    err = JetRetrieveColumnSuccess(pDB->JetSessID,
                                   tblid,
                                   rdntypid,
                                   &trialtype,
                                   sizeof(trialtype),
                                   &cbActual,
                                   0,
                                   NULL);
    Assert(!err);
    // The rdnType is stored in the DIT as the msDS_IntId, not the
    // attributeId. This means an object retains its birth name
    // even if unforeseen circumstances allow the attributeId
    // to be reused.
    if(rdnType != trialtype) {
        if(fEnforceType) {
            // Nope.  We found an object with the correct PDNT-RDN,
            // but the types were incorrect.  Return an error.
            DPRINT5(3, "No child '%*.*S' with type 0x%x, parent tag 0x%x.\n",
                    cbRDN/2, cbRDN/2, pRDN, rdnType, parenttag);
            return ERROR_DS_OBJ_NOT_FOUND;
        }
        else {
            // Hmm. Types are incorrect, but we don't care.  Call
            // DNcache to finish building the d_memname and add it
            // to the read cache, but tell the cache handler that we
            // don't know if this object is in the cache already or
            // not. 
            *ppname = DNcache(pDB, tblid, TRUE);
            *pfIsRecordCurrent = TRUE;
            return 0;
        }
    }
    else {
        // Yep.  Exact match on PDNT-RDN + RDNType. OK, call
        // DNcache to finish building the d_memname and add it
        // to the read cache.  Note that we can tell the DNcache
        // handler that we know this object is not already in the
        // cache because we tried to look it up at the top of this
        // routine and didn't find it (which does enforce type).
        *ppname = DNcache(pDB, tblid, FALSE);
        *pfIsRecordCurrent = TRUE;
        return 0;
    }
    
    Assert(!"You can't get here.\n");
    return ERROR_DS_OBJ_NOT_FOUND;
}

/*++ sbTableGetDSName
 *
 * This routine converts a DNT into the corresponding DSNAME.
 *
 * To eliminate all disagreements over how long a DSNAME can be, we no
 * longer allow callers to furnish a buffer.  sbTableGetDSName now allocates
 * a DSNAME off of the thread heap, and returns it "properly sized", meaning
 * that the heap block is the size indicated by pDN->structLen.
 *
 * Always unlocks cache before exit.
 *
 * Input:
 *	pDB	DBPOS to use
 *	tag	DNT of entry whose name should be returned
 *	ppName	pointer to pointer to returned name
 * Output:
 *	*ppName	filled in with pointer to DSNAME for object
 * Return Value:
 *	0 on success, error code on error
 *
 */
DWORD APIENTRY
sbTableGetDSName(DBPOS FAR *pDB, 
		 ULONG tag,
		 DSNAME **ppName,
                 DWORD  fFlag
                 )
{
    THSTATE  *pTHS=pDB->pTHS;
    d_memname * pname;
    unsigned len, quotelen;
    ULONG allocLen;                     // Count of Unicode Chars allocated for
                                        // the stringname.
    DWORD dwReadFlags = 0;
    DWORD cChars;
    
    Assert(VALID_DBPOS(pDB));

    DPRINT1( 2, "SBTableGetDSName entered tag: 0x%x\n", tag );

    // Allocate enough memory for most names.
    allocLen = sizeof(wchar_t)*(MAX_RDN_SIZE + MAX_RDN_KEY_SIZE);
    *ppName = THAllocEx(pTHS, DSNameSizeFromLen(allocLen));

    if( tag == ROOTTAG ) {
	/* it's the root! */
	(*ppName)->structLen = DSNameSizeFromLen(0);
	*ppName = THReAllocEx(pTHS, *ppName, DSNameSizeFromLen(0));
	return 0;
    }

    // Read the first component, which determines the GUID and SID

    if(fFlag & INTEXT_MAPINAME) {
        // In this case, we're going to have to read a property from the object,
        // so go ahead and set currency.
        dwReadFlags = DN_READ_SET_CURRENCY;
    }
    
    pname = DNread(pDB, tag, dwReadFlags);
    (*ppName)->Guid = pname->Guid;
    (*ppName)->Sid = pname->Sid;
    (*ppName)->SidLen = pname->SidLen;

    if(fFlag & INTEXT_SHORTNAME) {
        Assert(allocLen > sizeof(DWORD)/sizeof(wchar_t));
        
        // NOTE! assumes that the initial allocation is long enough to hold the
        // tag. 
        (*ppName)->NameLen = 0;
        *((DWORD *)((*ppName)->StringName)) = tag;
        // 2 unicode chars == sizeof DWORD, that's why the (2) in the next line
        (*ppName)->structLen = DSNameSizeFromLen(2);
        DPRINT1( 2, "SBTableGetDSName returning: 0x%x\n", tag);
    }
    else if(fFlag & INTEXT_MAPINAME) {
        CHAR     MapiDN[512];
        wchar_t *pTemp = (*ppName)->StringName;
        DWORD    err, i,cb;
        ATTRTYP  objClass;

        // PERFORMANCE: optimize use jetretrievecolumnS
        
        // First, get the object class
	err = JetRetrieveColumnWarnings(
                pDB->JetSessID,
                pDB->JetSearchTbl,
                objclassid,
                &objClass,
                sizeof(objClass),
                &cb,
                0,
                NULL);

        dbMapiTypeFromObjClass(objClass,pTemp);
        pTemp=&pTemp[2];
        
        // Now, the legacy dn, if one exists
	err = JetRetrieveColumnWarnings(
                pDB->JetSessID,
                pDB->JetSearchTbl,
                mapidnid,
                MapiDN,
                512,
                &cb,
                0,
                NULL);
        
        if(!err) {
            // The constant 2 is for the two chars we used to encode the mapi
            // type. 
            if(allocLen < cb + 2) {
                // need to alloc more.
                allocLen = cb + 2;
                *ppName = THReAllocEx(pTHS, *ppName, DSNameSizeFromLen(allocLen));
            }
            
            (*ppName)->NameLen = cb + 2;
            (*ppName)->structLen = DSNameSizeFromLen(cb + 2);
            // The mapidn is 7 bit ascii, but the string dn is expected to be
            // unicode, so stretch it.
            MultiByteToWideChar(CP_TELETEX,
                                0,
                                MapiDN,
                                cb,
                                pTemp,
                                cb);
        }
        else {
            // Failed to get a stored legacy name - we'll have to fake one
            DWORD ncdnt;
            ULONG cb;
            DSNAME * pNCDN;
            DWORD it;

            // We need to get the GUID of the NC head for this object, but
            // first we need to find out if this object is the NC head itself.
            JetRetrieveColumnSuccess(pDB->JetSessID,
                                     pDB->JetSearchTbl,
                                     insttypeid,
                                     &it,
                                     sizeof(it),
                                     &cb,
                                     0,
                                     NULL);

            // Now we get the NCDNT from the appropriate column
            JetRetrieveColumnSuccess(pDB->JetSessID,
                                     pDB->JetSearchTbl,
                                     ((it & IT_NC_HEAD)
                                      ? dntid
                                      : ncdntid),
                                     &ncdnt,
                                     sizeof(ncdnt),
                                     &cb,
                                     0,
                                     NULL);
            pNCDN = FindNCLFromNCDNT(ncdnt, FALSE)->pNC;

            (*ppName)->NameLen =  2 + DBMapiNameFromGuid_W (
                    pTemp,
                    allocLen - 2,
                    &pname->Guid,
                    &pNCDN->Guid,
                    &cChars);
            if((*ppName)->NameLen != cChars + 2) {
                // Failed to fill in the name, size we didn't give it enough
                // space. We need to alloc more
                allocLen = cChars + 2;
                *ppName = THReAllocEx(pTHS, *ppName, DSNameSizeFromLen(allocLen));
                pTemp = &(*ppName)->StringName[2];
                (*ppName)->NameLen =  DBMapiNameFromGuid_W (pTemp,
                                                            cChars,
                                                            &pname->Guid,
                                                            &pNCDN->Guid,
                                                            &cChars);
            }
            
            (*ppName)->structLen = DSNameSizeFromLen((*ppName)->NameLen);
        }
        (*ppName)->StringName[(*ppName)->NameLen] =  L'\0';
    }      
    else {
        Assert(!(fFlag&INTEXT_MAPINAME));
        Assert(!(fFlag&INTEXT_SHORTNAME));
        
        len = AttrTypeToKey(pname->tag.rdnType, (*ppName)->StringName);
        (*ppName)->StringName[len++] = L'=';

        quotelen= QuoteRDNValue(pname->tag.pRdn,
                                pname->tag.cbRdn/sizeof(WCHAR),
                                &(*ppName)->StringName[len],
                                allocLen - len);

        while (quotelen > (allocLen - len)) {
            allocLen += MAX_RDN_SIZE + MAX_RDN_KEY_SIZE + 2;
            *ppName = THReAllocEx(pTHS, *ppName, DSNameSizeFromLen(allocLen));
            quotelen= QuoteRDNValue(pname->tag.pRdn,
                                    pname->tag.cbRdn/sizeof(WCHAR),
                                    &(*ppName)->StringName[len],
                                    allocLen - len);
        }
        len += quotelen;
        
        // Pull naming info off of each component, until we're done.
        
        while (pname->tag.PDNT != ROOTTAG) {
            if ((allocLen - len) < (MAX_RDN_SIZE + MAX_RDN_KEY_SIZE + 2)) {
                // We might not have enough buffer to add another component,
                // so we need to reallocate the buffer up.  We allocate
                // enough for the maximal key, the maximal value, plus two
                // characters more for the comma and equal sign
                allocLen += MAX_RDN_SIZE + MAX_RDN_KEY_SIZE + 2;
                *ppName = THReAllocEx(pTHS, *ppName, DSNameSizeFromLen(allocLen));
            }
            (*ppName)->StringName[len++] = L',';
            pname = DNread(pDB, pname->tag.PDNT, 0);
            len += AttrTypeToKey(pname->tag.rdnType, &(*ppName)->StringName[len]);
            (*ppName)->StringName[len++] = L'=';
            quotelen = QuoteRDNValue(pname->tag.pRdn,
                                     pname->tag.cbRdn/sizeof(WCHAR),
                                     &(*ppName)->StringName[len],
                                     allocLen - len);
            
            while (quotelen > (allocLen - len)) {
                allocLen += MAX_RDN_SIZE + MAX_RDN_KEY_SIZE + 2;
                *ppName = THReAllocEx(pTHS, *ppName, DSNameSizeFromLen(allocLen));
                quotelen = QuoteRDNValue(pname->tag.pRdn,
                                         pname->tag.cbRdn/sizeof(WCHAR),
                                         &(*ppName)->StringName[len],
                                         allocLen - len);
            }
            len += quotelen;

            // We should not have run out of buffer
            Assert(len < allocLen);
        }
        
        (*ppName)->StringName[len] =  L'\0';
        
        (*ppName)->NameLen = len;
        (*ppName)->structLen = DSNameSizeFromLen(len);

        DPRINT1(2, "SBTableGetDSName returning: %S\n", (*ppName)->StringName );
    }
    // Our buffer is probably too big, so reallocate it down to fit.
    *ppName = THReAllocEx(pTHS, *ppName, (*ppName)->structLen);


    return 0;

} /* sbTableGetDSName */

/*++

Routine Description:

    Return true if the DNT passed in is an ancestor of the current object in the
    object table.  False otherwise.  Uses the DNRead cache.
    
Arguments:

    ulAncestor - DNT of object you care about.

Return Values:

    TRUE or FALSE, as appropriate.

--*/ 
BOOL
dbFIsAnAncestor (
        DBPOS FAR *pDB,
        ULONG ulAncestor
        )
{
    d_memname * pname;
    int i;
    ULONG curtag=pDB->DNT;
    
    Assert(VALID_DBPOS(pDB));

    // We assume that pDB->DNT is correct.
    

    if(curtag == ulAncestor) {
        // I have defined that an object is an ancestor of itself (nice for the
        // whole subtree search case, which is the main user of this routine)
        return TRUE;
    }

    
    if( curtag == ROOTTAG ) {
	// it's the root and the potential ancestor is not.  Therefore, the
        // potential ancestor is clearly not an real ancestor.
        return FALSE;
    }

    // Fetch a dnread element for each component of the name, up to the root
    do {
	pname = DNread(pDB, curtag, 0);
	Assert(curtag == pname->DNT);
	curtag = pname->tag.PDNT;
        if(curtag == ulAncestor)
            return TRUE;
    } while (curtag != ROOTTAG);

    // We didn't find the DNT they were asking for, so return FALSE
    return 0;
}


void
dbGetAncestorsSlowly(
    IN      DBPOS *  pDB,
    ULONG            DNT,
    IN OUT  DWORD *  pcbAncestorsSize,
    IN OUT  ULONG ** ppdntAncestors,
    OUT     DWORD *  pcNumAncestors
    );

void
DBGetAncestors(
    IN      DBPOS *  pDB,
    IN OUT  DWORD *  pcbAncestorsSize,
    IN OUT  ULONG ** ppdntAncestors,
    OUT     DWORD *  pcNumAncestors
    )
/*++

Routine Description:

    Return the ancestor DNTs of the current object (pTHS->pDB), all the way
    up to the root, as an array of ULONGs.

    Assumes pDB->DNT is correct,

    The caller is responsible for eventually calling THFree( *ppdntAncestors ).

Arguments:

    pDB

    pcbAncestorsSize (IN/OUT) - Size in bytes of ancestors array.

    ppdntAncestors (IN/OUT) - Address of the thread-allocated ancestors array.

    pcNumAncestors (OUT) - Count of ancestors.

Return Values:

    None.  Throws exception on memory allocation failure - Database Failure.

--*/
{
    THSTATE    *pTHS=pDB->pTHS;
    d_memname * pname;
    BOOL        bReadAncestryFromDisk = FALSE;
    
    if(pTHS->fSDP) {
        DWORD err;
        DWORD actuallen=0;
        
        // The SDP doesn't want to put things in the dnread cache, it just wants
        // the ancestors

        // the SDP must provide a start buffer.  It's the price it pays for
        // special handling in this call.
        Assert(*pcbAncestorsSize);

        
        err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                        pDB->JetObjTbl,
                                        ancestorsid,
                                        *ppdntAncestors,
                                        *pcbAncestorsSize,
                                        &actuallen, 0, NULL);
        switch (err) {
        case 0:
            // OK, we got the ancestors.  Don't bother reallocing down.
            // This gives a guarantee to the SDProp that this buffer never
            // shrinks, so it can track it's real allocated size.
            // This is useful for when the sdprop thread repeatedly uses the
            // same buffer. 
            break;
            
        case JET_wrnBufferTruncated:
            // Failed to read, not enough memory.  Realloc it larger.
            *ppdntAncestors = THReAllocOrgEx(pTHS, *ppdntAncestors,
                                               actuallen); 
            
            if(err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                               pDB->JetObjTbl,
                                               ancestorsid,
                                               *ppdntAncestors,
                                               actuallen,
                                               &actuallen, 0, NULL)) {
                // Failed again.
                DsaExcept(DSA_DB_EXCEPTION, err, 0);
            }
            break;
            
        default:
            // Failed badly.
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
            break;
        }
        *pcNumAncestors = actuallen / sizeof(DWORD);
        *pcbAncestorsSize = actuallen;
    }
    else {

        // if there are enqueued SD events, then we are going to 
        // read the ancestry from disk
        if (*pcSDEvents) {
            // This operation does not reposition pDB on JetObjTbl. 
            // It only affects JetSDPropTbl.
            bReadAncestryFromDisk = DBPropagationsExist(pDB);
        }

        if (bReadAncestryFromDisk == FALSE) {

            pname = DNread(pDB, pDB->DNT, 0);

            if(*pcbAncestorsSize < pname->cAncestors * sizeof(DWORD)) {
                // buffer is too small (or not there).
                if(*ppdntAncestors) {
                    *ppdntAncestors =
                        THReAllocEx(pTHS, *ppdntAncestors,
                                    pname->cAncestors * sizeof(DWORD)); 
                }
                else {
                    *ppdntAncestors = THAllocEx(pTHS,
                                                pname->cAncestors * sizeof(DWORD));
                }

            }

            // Tell 'em how big it is.
            *pcbAncestorsSize = pname->cAncestors * sizeof(DWORD);


            memcpy((*ppdntAncestors),
                   pname->pAncestors,
                   pname->cAncestors * sizeof(DWORD));

            *pcNumAncestors = pname->cAncestors;
        }
        else {

            dbGetAncestorsSlowly (pDB, 
                                  pDB->DNT,
                                  pcbAncestorsSize,
                                  ppdntAncestors,
                                  pcNumAncestors);
        }
    }

    return;
}

void
dbGetAncestorsSlowly(
    IN      DBPOS *  pDB,
    ULONG            DNT,
    IN OUT  DWORD *  pcbAncestorsSize,
    IN OUT  ULONG ** ppdntAncestors,
    OUT     DWORD *  pcNumAncestors
    )
/*
Routine Description:

    Return the ancestor DNTs of the object with DNT, all the way
    up to the root, as an array of ULONGs.

    Assumes DNT is correct,

    The caller is responsible for eventually calling THFree( *ppdntAncestors ).
    
    Uses DNRead internally, and as a result uses SearchIndex.
    
    Note that DNT will NOT be included in the reuslting array. The client calling
    this func has to take care of adding the DNT if needed.

Arguments:

    pDB

    pcbAncestorsSize (IN/OUT) - Size in bytes of ancestors array.

    ppdntAncestors (IN/OUT) - Address of the thread-allocated ancestors array.

    pcNumAncestors (OUT) - Count of ancestors.

Return Values:

    None.  Throws exception on memory allocation failure - Database Failure.

*/

{
    THSTATE    *pTHS=pDB->pTHS;
    d_memname * pname;
    ULONG   curtag = DNT;
    DWORD   iAncestor1;
    DWORD   iAncestor2;

    if ( *pcbAncestorsSize < 16 * sizeof( DWORD ) ) {
        // Allocate a buffer to start off with, adequate for most calls.
        *pcbAncestorsSize = 16 * sizeof( DWORD );

        if(*ppdntAncestors) {
            *ppdntAncestors =
                THReAllocEx(pTHS, *ppdntAncestors, 16 * sizeof(DWORD)); 
        }
        else {
            *ppdntAncestors = THAllocEx(pTHS, 16 * sizeof(DWORD));
        }
    }

    if ( curtag == ROOTTAG )
    {
        // Root.
        *pcNumAncestors = 1;
        (*ppdntAncestors)[ 0 ] = ROOTTAG;
    }
    else
    {
        // Not root.

        // Fetch a dnread element for each component of the name (up to the
        // root) and add its parent's DNT to the array.

        for ( (*pcNumAncestors) = 0; curtag != ROOTTAG; (*pcNumAncestors)++ )
        {
            // Get the d_memname corresponding to this tag.
            pname = DNread(pDB, curtag, 0);
            Assert(curtag == pname->DNT);

            // Expand the ancestors array if necessary.
            if (*pcNumAncestors * sizeof( DWORD ) >= *pcbAncestorsSize) {

                *pcbAncestorsSize *= 2;
                *ppdntAncestors = THReAllocEx(pTHS,
                                        *ppdntAncestors,
                                        *pcbAncestorsSize
                                        );
            }

            // Add the parent of this tag to the ancestors array.
            (*ppdntAncestors)[ *pcNumAncestors ] = curtag;
            curtag = pname->tag.PDNT;
        }

        if ( curtag == ROOTTAG )
        {
            if (*pcNumAncestors * sizeof( DWORD ) >= *pcbAncestorsSize) {

                *pcbAncestorsSize += sizeof(DWORD);
                *ppdntAncestors = THReAllocEx(pTHS,
                                        *ppdntAncestors,
                                        *pcbAncestorsSize
                                        );
            }

            (*ppdntAncestors)[ *pcNumAncestors ] = curtag;
            (*pcNumAncestors)++;
        }


        // Reverse the ancestors array such that parents precede children.
        for ( iAncestor1 = 0; iAncestor1 < (*pcNumAncestors)/2; iAncestor1++ )
        {
            iAncestor2 = *pcNumAncestors - iAncestor1 - 1;

            curtag = (*ppdntAncestors)[ iAncestor1 ];
            (*ppdntAncestors)[ iAncestor1 ] = (*ppdntAncestors)[ iAncestor2 ];
            (*ppdntAncestors)[ iAncestor2 ] = curtag;
        }

    }
    // Tell 'em how big it is.
    *pcbAncestorsSize = *pcNumAncestors * sizeof( DWORD );
}



/* DBRenumberLinks - looks for all records in the link table with the
value of ulOldDnt in the column col, and changes that value to ulNewDnt.
This routine is used when copying the attributes of a new object to an
existing deleted one, and then aborting the insertion of the new one. This
is done when adding the OBJ_DISTNAME attribute in sbTableAddRefHelp if the
DN of the record to be inserted already exists */

DWORD APIENTRY
dbRenumberLinks(DBPOS FAR *pDB, ULONG ulOldDnt, ULONG ulNewDnt)
{
    THSTATE     *pTHS = pDB->pTHS;
    BYTE        *rgb = 0;
    ULONG       cbRgb = 0;
    ULONG       ulLinkDnt;
    ULONG       ulBacklinkDnt;
    ULONG       ulLinkBase;
    ULONG       nDesc;
    DSTIME              timeDeleted;
    USN                 usnChanged;
    ULONG               ulNcDnt;
    JET_ERR     err;
    ULONG       cb;
    JET_TABLEID     tblid;

    Assert(VALID_DBPOS(pDB));

    // set the index

    // Include all links, absent or present
    JetSetCurrentIndexSuccess(pDB->JetSessID,
                              pDB->JetLinkTbl, SZLINKALLINDEX);
    JetMakeKeyEx(pDB->JetSessID, pDB->JetLinkTbl,
                 &ulOldDnt, sizeof(ulOldDnt), JET_bitNewKey);

    err = JetSeekEx(pDB->JetSessID, pDB->JetLinkTbl, JET_bitSeekGE);
    if ((err != JET_errSuccess) &&
        (err != JET_wrnRecordFoundGreater))
    {
        return 0;
    }

    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                             linkdntid, &ulLinkDnt, sizeof(ulLinkDnt), &cb, 0, NULL);

    if (ulLinkDnt != ulOldDnt)
    {
        return 0;
    }

    // clone the cursor for updates

    JetDupCursorEx(pDB->JetSessID, pDB->JetLinkTbl, &tblid, 0);

    do
    {
        JetPrepareUpdateEx(pDB->JetSessID, tblid, JET_prepInsert);
        JetPrepareUpdateEx(pDB->JetSessID, pDB->JetLinkTbl, DS_JET_PREPARE_FOR_REPLACE);

        // link dnt

        JetSetColumnEx(pDB->JetSessID, tblid,
                       linkdntid, &ulNewDnt, sizeof(ulNewDnt), 0,0);

        // backlink dnt

        JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                                 backlinkdntid, &ulBacklinkDnt, sizeof(ulBacklinkDnt), &cb, 0, NULL);
        JetSetColumnEx(pDB->JetSessID, tblid,
                       backlinkdntid, &ulBacklinkDnt, sizeof(ulBacklinkDnt), 0,0);

        // linkbase

        JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                                 linkbaseid, &ulLinkBase, sizeof(ulLinkBase), &cb, 0, NULL);
        JetSetColumnEx(pDB->JetSessID, tblid,
                       linkbaseid, &ulLinkBase, sizeof(ulLinkBase), 0,0);

        // link ndesc

        if ((err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                             linkndescid, &nDesc, sizeof(nDesc), &cb, 0, NULL)) == JET_errSuccess)
        {
            JetSetColumnEx(pDB->JetSessID, tblid,
                           linkndescid, &nDesc, sizeof(nDesc), 0,0);
        }


        // member address
        if ((err=JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                           linkdataid, rgb, cbRgb, &cb, 0, NULL)) == JET_wrnBufferTruncated)
        {
            cbRgb = cb;
            rgb = THAllocEx(pTHS,cb);
            err = JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                                           linkdataid, rgb, cbRgb, &cb, 0, NULL);
        }

        if (err ==  JET_errSuccess)
        {
            JetSetColumnEx(pDB->JetSessID, tblid, linkdataid, rgb, cb, 0, 0);
        }

        // Link del time (only exists on absent rows)
        err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                        linkdeltimeid, &timeDeleted, sizeof(timeDeleted), &cb, 0, NULL);
        if (err == JET_errSuccess) {
            JetSetColumnEx(pDB->JetSessID, tblid,
                           linkdeltimeid, &timeDeleted, sizeof(timeDeleted), 0,0);
        }

        // Link usn changed (does not exist for legacy rows)
        err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                        linkusnchangedid, &usnChanged, sizeof(usnChanged), &cb, 0, NULL);
        if (err == JET_errSuccess) {
            JetSetColumnEx(pDB->JetSessID, tblid,
                           linkusnchangedid, &usnChanged, sizeof(usnChanged), 0,0);
        }

        // Link nc dnt (does not exist for legacy rows)
        err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                        linkncdntid, &ulNcDnt, sizeof(ulNcDnt), &cb, 0, NULL);
        if (err == JET_errSuccess) {
            JetSetColumnEx(pDB->JetSessID, tblid,
                           linkncdntid, &ulNcDnt, sizeof(ulNcDnt), 0,0);
        }

        // Link metadata (does not exist for legacy rows)
        // Handle any size item
        if (rgb) THFreeEx(pTHS,rgb);
        rgb = NULL;
        cbRgb = 0;
        if ((err=JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetLinkTbl,
                                           linkmetadataid, rgb, cbRgb, &cb, 0, NULL)) == JET_wrnBufferTruncated)
        {
            cbRgb = cb;
            rgb = THAllocEx( pDB->pTHS, cb);
            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                                     linkmetadataid, rgb, cbRgb, &cb, 0, NULL);
            JetSetColumnEx(pDB->JetSessID, tblid, linkmetadataid, rgb, cb, 0, 0);
            THFreeEx( pDB->pTHS, rgb );
            rgb = NULL;
        } else {
            // Since we are not support zero-sized items, the only other valid
            // error is null column
            Assert( err == JET_wrnColumnNull );
        }

        // update the new record and delete the old

        JetUpdateEx(pDB->JetSessID, tblid, NULL, 0, 0);
        JetDeleteEx(pDB->JetSessID, pDB->JetLinkTbl);

        // move to next record

        if ((err = JetMoveEx(pDB->JetSessID, pDB->JetLinkTbl,
                             JET_MoveNext, 0)) == JET_errSuccess)
        {

            // retrieve tag of found record and compare to old Dnt

            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetLinkTbl,
                                     linkdntid, &ulLinkDnt, sizeof(ulLinkDnt), &cb, 0, NULL);
        }
    } while (!err && (ulLinkDnt == ulOldDnt));

    JetCloseTableEx(pDB->JetSessID, tblid);

    // done

    return 0;
}

void
sbTableUpdateRecordIdentity(
    IN OUT  DBPOS * pDB,
    IN      DWORD   DNT,
    IN      WCHAR * pwchRDN,    OPTIONAL
    IN      DWORD   cchRDN,
    IN      GUID *  pGuid,      OPTIONAL
    IN      SID *   pSid,       OPTIONAL
    IN      DWORD   cbSid
    )
/*++

Routine Description:

    Updates the GUID, SID, and/or RDN of the record with the given tag.  Handles
    flushing the cache, etc.

Arguments:

    pDB (IN/OUT)
    
    pwchRDN (IN, OPTIONAL) - New RDN for the record, if 0 != cchRDN.

    cchRDN (IN) - Size in characters of the new RDN, or 0 if no change.
    
    pGuid (IN, OPTIONAL) - New GUID for the record, or NULL if no change.
    
    pSid (IN, OPTIONAL) - New SID for the record, if 0 != cbSid.
    
    cbSid (IN) - Size in bytes if the new SID, or 0 if no change.

Return Values:

    None.  Throws database exception on JET errors.

--*/
{
    int err;

    Assert((0 != cchRDN) || (NULL != pGuid) || (0 != cbSid));

    JetSetCurrentIndex4Success(pDB->JetSessID,
                               pDB->JetSearchTbl,
                               SZDNTINDEX,
                               &idxDnt,
                               0);
    JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl, &DNT,
                 sizeof(ULONG), JET_bitNewKey);

    err = JetSeek(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekEQ);
    if (err) {
        DsaExcept(DSA_DB_EXCEPTION, err, DNT);
    }

    pDB->SDNT = DNT;

    JetPrepareUpdateEx(pDB->JetSessID, pDB->JetSearchTbl,
                       DS_JET_PREPARE_FOR_REPLACE);

    if (0 != cchRDN) {
        // Replace the RDN.
        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, rdnid,
                       pwchRDN, cchRDN * sizeof(WCHAR), 0, NULL);
    }

    if (NULL != pGuid) {
        // Add the guid.  We should never replace the guid of a pre-existing
        // record.
        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, guidid, pGuid,
                       sizeof(GUID), 0, NULL);
    }

    if (0 != cbSid) {
        // Add the SID (in internal format).
        NT4SID sidInternalFormat;

        memcpy(&sidInternalFormat, pSid, cbSid);
        InPlaceSwapSid(&sidInternalFormat);

        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, sidid,
                       &sidInternalFormat, cbSid, 0, NULL);
    }

    JetUpdateEx(pDB->JetSessID, pDB->JetSearchTbl, NULL, 0, 0);

    // Reset entry in DN read cache.
    dbFlushDNReadCache(pDB, DNT);
}

DWORD
APIENTRY
sbTableGetTagFromDSName(
    IN OUT DBPOS *      pDB,
    IN     DSNAME *     pName,
    IN     ULONG        ulFlags,
    OUT    ULONG *      pTag,       OPTIONAL
    OUT    d_memname ** ppname      OPTIONAL
    )
/*++

Routine Description:

    Returns the DN tag associated with a given DSNAME.

Arguments:

    pDB (IN/OUT)
    pName (IN) - DSNAME of the object to map to a tag.
    ulFlags (IN) - 0 or more of the following bits:
        SBTGETTAG_fAnyRDNType - Don't check for the type of the RDN.  Therefore,
                 "cn=foo,dc=bar,dc=com" matches against "ou=foo,dc=bar,dc=com",
                 but not "cn=foo,cn=bar,dc=com".
        SBTGETTAG_fMakeCurrent - make the target record current.
        SBTGETTAG_fUseObjTbl - use pDB->JetObjTbl rather than pDB->JetSearchTbl.
    pTag (OUT, OPTIONAL) - on return, holds the tag associated with pName if the
        return value is 0; otherwise, holds the closest match.
    ppname (OUT, OPTIONAL) - on successful return, holds a pointer to the read
        cache entry for the record found UNLESS THE DSNAME REQUESTED WAS THE
        ROOT, IN WHICH CASE IT WILL BE SET TO NULL

Return Values:

    0 - successfully found a corresponding object.
    ERROR_DS_NOT_AN_OBJECT - successfully found a corresponding phantom.
    ERROR_DS_NAME_NOT_UNIQUE - found an object with a duplicate sid
    ERROR_DS_OBJ_NOT_FOUND - didn't find the object
    other DB_ERR_* - failure.

    Throws database exception on unexpected JET errors.

--*/             
{
    DWORD           ret = 0;
    unsigned        curlen;
    ULONG           curtag = ROOTTAG;
    ATTRTYP         type;
    DWORD           err;
    WCHAR           *pKey, *pQVal;
    unsigned        ccKey, ccQVal, ccVal;
    WCHAR           rdnbuf[MAX_RDN_SIZE];
    BOOL            fSearchByGuid, fSearchByStringName, fSearchBySid;
    BOOL            fFoundRecord = FALSE;
    BOOL            fIsRecordCurrent = FALSE;
    d_memname       *pTempName = NULL;
    DWORD           SidDNT = 0;     //initialized to avoid C4701
    JET_TABLEID     tblid;

    Assert(VALID_DBPOS(pDB));

    DPRINT2(2, "sbTableGetTagFromDSName(): Looking for \"%ls\" (DSNAME @ %p).\n",
            pName->StringName, pName);

    if (ulFlags & SBTGETTAG_fUseObjTbl) {
        tblid = pDB->JetObjTbl;
    }
    else {
        tblid = pDB->JetSearchTbl;
    }
    if (ppname) {
        *ppname = NULL;
    }

    // Always search by GUID if one is present.
    fSearchByGuid = !fNullUuid(&pName->Guid);
    Assert(fSearchByGuid || !(ulFlags & SBTGETTAG_fSearchByGuidOnly));

    // Search by string name if one is present, or if none is present but
    // neither is a GUID or SID (in which case we're being asked to find the
    // root).
    fSearchByStringName = !(ulFlags & SBTGETTAG_fSearchByGuidOnly)
                          && ((0 != pName->NameLen)
                              || ((0 == pName->SidLen) && !fSearchByGuid));

    // Search by SID only if it's valid and no other identifier is present in
    // the name.
    fSearchBySid = !fSearchByGuid && (0==pName->NameLen)
        && (pName->SidLen>0) && (RtlValidSid(&(pName->Sid)));
    
    if (fSearchByGuid) {
        ret = sbTableGetTagFromGuid(pDB,
                                    tblid,
                                    &pName->Guid,
                                    &curtag,
                                    &pTempName,
                                    &fIsRecordCurrent);
        fFoundRecord = (0 == ret);
    }
    else if (fSearchBySid) {
        NT4SID SidPrefix;
        // Or, attempt to find the record in the read cache.
        
        // Note that we leave the string name-based cache lookups to
        // DNChildFind(), as it requires multiple lookups to identify a record
        // as the "right" one (one for each component of the name), and one or
        // more of those components might not be in the cache.

        // We only look up things by SID if they are in a domain we host.  For
        // now, we only host one domain.  Copy the Sid, since we munge it while
        // checking see if it is in our domain

        SidDNT = INVALIDDNT;
        
        if (!gAnchor.pDomainDN || !gAnchor.pDomainDN->SidLen) {
            // No domain DN.  Assume that they are looking up in the domain.
            SidDNT = gAnchor.ulDNTDomain;
        }
        else {
            // verify the domain.
            SidPrefix = pName->Sid;
            (*RtlSubAuthorityCountSid(&SidPrefix))--;

            Assert(gAnchor.pDomainDN);
            Assert(pgdbBuiltinDomain);
            
            if(RtlEqualSid(&pName->Sid, &gAnchor.pDomainDN->Sid)) {
                // Case 1, they passed in the Sid of the Domain.
                // Shortcut and just look up the object which is the root of the
                // domain.
                if(pDB != pDBhidden) {
                    fFoundRecord = dnGetCacheByDNT(pDB,
                                                   gAnchor.ulDNTDomain,
                                                   &pTempName);
                }
                else {
                    fFoundRecord = FALSE;
                }
            }
            else if(RtlEqualSid(&SidPrefix, &gAnchor.pDomainDN->Sid) ||
                    // Case 2, an account in the domain.
                    RtlEqualSid(&SidPrefix, pgdbBuiltinDomain)       ||
                    // Case 4, an account in the builtin domain.
                    RtlEqualSid(&pName->Sid, pgdbBuiltinDomain)
                    // Case 3, the sid of the builtin domain
                                                                        ) {
                
                SidDNT = gAnchor.ulDNTDomain;
            }
            else {
                SidDNT = INVALIDDNT;
            }
            
        }   

        if (fFoundRecord) {
            curtag = pTempName->DNT;
        }
        
    }

    if (!fFoundRecord && fSearchBySid && (SidDNT != INVALIDDNT)) {
        // Search for the record by SID.
        NT4SID InternalFormatSid;
        ULONG  ulNcDNT;

        Assert(!pTempName);
        
        JetSetCurrentIndex4Success(pDB->JetSessID,
                                   tblid,
                                   SZSIDINDEX,
                                   &idxSid,
                                   0);

        // Convert the SID to internal format.
        Assert(pName->SidLen == RtlLengthSid(&pName->Sid));
        memcpy(&InternalFormatSid, &pName->Sid, pName->SidLen);
        InPlaceSwapSid(&InternalFormatSid);

        JetMakeKeyEx(pDB->JetSessID, tblid, &InternalFormatSid, pName->SidLen,
                     JET_bitNewKey);

        // Seek on Equal to the SId, Set the Index range
        err = JetSeek(pDB->JetSessID, tblid,
                      JET_bitSeekEQ|JET_bitSetIndexRange);
        if ( 0 == err ) {
            DWORD cbActual;
#ifndef JET_BIT_SET_INDEX_RANGE_SUPPORT_FIXED
            JetMakeKeyEx(pDB->JetSessID, tblid, &InternalFormatSid,
                         pName->SidLen, JET_bitNewKey); 
            
            JetSetIndexRangeEx(pDB->JetSessID, tblid,
                               (JET_bitRangeUpperLimit|JET_bitRangeInclusive ));
#endif            
            //
            // Ok We found the object. Keep Moving Forward Until either the SID
            // does not Match or we reached the given object
            //
            
            do {
                
                err = JetRetrieveColumn(pDB->JetSessID, tblid, ncdntid,
                                        &ulNcDNT, sizeof(ulNcDNT), &cbActual, 0
                                        , NULL); 
                
                if (0==err) {
                    // We read the NC DNT of the object
                    if (ulNcDNT==SidDNT)
                        break;
                }
                else if (JET_wrnColumnNull==err) {
                    // It is Ok to find an object with No Value for NC DNT
                    // this occurs on Phantoms. Try next object
                    
                    err = 0;
                }
                else {
                    break;
                }
                
                err = JetMove(pDB->JetSessID, tblid, JET_MoveNext,  0);
                
                
            }  while (0==err);
            
                
            // We have a match.  
            if (0==err) {
                // The TRUE param to DNcache says that the current object may
                // already be in the cache, we haven't checked.
                pTempName = DNcache(pDB, tblid, TRUE);
                Assert(pTempName);
                fFoundRecord = TRUE;
                fIsRecordCurrent = FALSE;
                curtag = pTempName->DNT;

                // Now, verify that there is only one match.                
                err = JetMove(pDB->JetSessID, tblid, JET_MoveNext, 0);
                
                if (0==err) {
                    err = JetRetrieveColumn(pDB->JetSessID, tblid, ncdntid, 
                                            &ulNcDNT, sizeof(ulNcDNT),
                                            &cbActual, 0 , NULL); 
                    
                    if ((0==err) && (ulNcDNT==SidDNT)) {
                        // This is a case of a duplicate Sid.
                        ret = ERROR_DS_NAME_NOT_UNIQUE;
                        pTempName = NULL;
                    }
                }
            }
        }
    }

    if (!fFoundRecord && fSearchByStringName) {
        // Search for the record by string name.
        if (IsRoot(pName)) {
            Assert(ROOTTAG == curtag);
            Assert(!fIsRecordCurrent);
            Assert(NULL == pTempName);
            fFoundRecord = TRUE;
        }
        else {
            ret = sbTableGetTagFromStringName(pDB,
                                              tblid,
                                              pName,
                                              FALSE,
                                              (ulFlags & SBTGETTAG_fAnyRDNType),
                                              0,
                                              &curtag,
                                              &pTempName,
                                              &fIsRecordCurrent);
            fFoundRecord = (0 == ret);
        
            if (fFoundRecord) {
                DPRINT6(2,
                        "sbTableGetTagFromDSName() found DNT 0x%x by string "
                            "name: RDN '%*.*ls', RDN type 0x%x, PDNT 0x%x.\n",
                        pTempName->DNT,
                        pTempName->tag.cbRdn/2,
                        pTempName->tag.cbRdn/2,
                        pTempName->tag.pRdn,
                        pTempName->tag.rdnType,
                        pTempName->tag.PDNT);
            }
        }
    }

    if (!fFoundRecord && !ret) {
        // No matching record found.
        ret = ERROR_DS_OBJ_NOT_FOUND;
    }

    if (!ret) {
        // Found the requested record.
        Assert((NULL != pTempName) || (ROOTTAG == curtag));

        if (NULL != ppname) {
            // Return pointer to populated cache structure (unless we found
            // the root).
            *ppname = pTempName;
        }

        if (!fIsRecordCurrent && (ulFlags & SBTGETTAG_fMakeCurrent)) {
            // Record was found through the cache, but caller wants currency;
            // give it to him.
            JetSetCurrentIndex4Success(pDB->JetSessID,
                                       tblid,
                                       SZDNTINDEX,
                                       &idxDnt,
                                       0);
            
            JetMakeKeyEx(pDB->JetSessID, tblid, &curtag, sizeof(curtag),
                         JET_bitNewKey);

            if (err = JetSeekEx(pDB->JetSessID, tblid, JET_bitSeekEQ)) {
                DsaExcept(DSA_DB_EXCEPTION, err, curtag);
            }

            fIsRecordCurrent = TRUE;
        }

        if (fIsRecordCurrent) {
            // Currency has been successfully changed; update pDB state.
            if (ulFlags & SBTGETTAG_fUseObjTbl) {
                dbMakeCurrent(pDB, pTempName);
            }
            else {
                pDB->SDNT = curtag;
            }
        }

        if ((ROOTTAG != curtag) && !pTempName->objflag) {
            // Found a phantom; return distinct error code.
            // NOTE THAT THE ROOT *IS* AN OBJECT.
            ret = ERROR_DS_NOT_AN_OBJECT;
        }
    }
    else {
        // Whatever currency was previously held in tblid is lost; update the
        // currency state in pDB.
        if (ulFlags & SBTGETTAG_fUseObjTbl) {
            pDB->DNT = pDB->PDNT = pDB->NCDNT = 0;
            pDB->JetNewRec = pDB->root = pDB->fFlushCacheOnUpdate = FALSE;
        }
        else {
            pDB->SDNT = 0;
        }

        DPRINT(3, "sbTableGetTagFromDSName() failed.\n");
    }

    // Always set the return tag to our best match (i.e. tag of longest subname
    // of the DSNAME given if we were allowed to search by string name, the
    // root tag otherwise).
    if (pTag) {
        *pTag = curtag;
    }

    return ret;
} /* sbTableGetTagFromDSName */

DWORD
sbTableGetTagFromGuid(
    IN OUT  DBPOS *       pDB,
    IN      JET_TABLEID   tblid,
    IN      GUID *        pGuid,
    OUT     ULONG *       pTag,             OPTIONAL
    OUT     d_memname **  ppname,           OPTIONAL
    OUT     BOOL *        pfIsRecordCurrent OPTIONAL
    )
/*++

Routine Description:

    Returns the DN tag associated with a given DSNAME's guid.

Arguments:

    pDB (IN/OUT) - Currency can be changed.
    
    tblid (IN) - Which table to use -- pDB->JetSearchTbl or pDB->JetObjTbl.
    
    pGuid (IN) - Guid of the object to map to a tag.
    
    pTag (OUT, OPTIONAL) - On successful return, holds the tag associated with
        this guid.
    
    ppname (OUT, OPTIONAL) - On successful return, holds a pointer to the
        d_memname struct (from the cache) associated with this guid.
        
    pfRecordIsCurrent (OUT, OPTIONAL) - On successful return, indicates whether
        the cursor tblid is positioned on the target record.

Return Values:

    0 - successfully found a record -- may be phantom or object.
    ERROR_DS_* - failure

    Throws database exception on unexpected JET errors.

--*/
{
    DWORD       ret = ERROR_DS_OBJ_NOT_FOUND;
    int         err = 0;
    BOOL        fIsRecordCurrent = FALSE;
    d_memname * pname = NULL;
    BOOL        fFoundRecord = FALSE;
    CHAR        szGuid[SZUUID_LEN];

    // First attempt to find the record in the read cache by guid
    // Don't use the cache for the hidden record.  The cache is associated with
    // the THSTATE its transaction state. The pDBhidden is not necessarily
    // associated with this threads thstate.
    if (pDB != pDBhidden) {
        fFoundRecord = dnGetCacheByGuid(pDB, pGuid, &pname);
    
        if (fFoundRecord) {
            DPRINT6(2,
                    "sbTableGetTagFromGuid() found DNT 0x%x in cache: "
                        "RDN '%*.*ls', RDN type 0x%x, PDNT 0x%x.\n",
                    pname->DNT, pname->tag.cbRdn/2, pname->tag.cbRdn/2,
                    pname->tag.pRdn, pname->tag.rdnType, pname->tag.PDNT);
        }
    }
    
    if (!fFoundRecord) {
        // Search for the record by GUID.
        JetSetCurrentIndex4Success(pDB->JetSessID,
                                   tblid,
                                   SZGUIDINDEX,
                                   &idxGuid,
                                   0);

        JetMakeKeyEx(pDB->JetSessID, tblid, pGuid, sizeof(GUID), JET_bitNewKey);

        err = JetSeekEx(pDB->JetSessID, tblid, JET_bitSeekEQ);
        if (!err) {
            fFoundRecord = TRUE;
            fIsRecordCurrent = TRUE;
            pname = DNcache(pDB, tblid, FALSE);
        
            DPRINT6(2,
                    "sbTableGetTagFromGuid() seeked to DNT 0x%x: "
                        "RDN '%*.*ls', RDN type 0x%x, PDNT 0x%x.\n",
                    pname->DNT, pname->tag.cbRdn/2, pname->tag.cbRdn/2,
                    pname->tag.pRdn, pname->tag.rdnType, pname->tag.PDNT);
        }
    }

    if (fFoundRecord) {
        if (NULL != ppname) {
            *ppname = pname;
        }
    
        if (NULL != pTag) {
            *pTag = pname->DNT;
        }
    
        if (NULL != pfIsRecordCurrent) {
            *pfIsRecordCurrent = fIsRecordCurrent;
        }

        ret = 0;
    }
    else {
        Assert(ERROR_DS_OBJ_NOT_FOUND == ret);
    
        DPRINT1(2,
                "sbTableGetTagFromGuid() failed to find record with "
                    "guid %s.\n",
                UuidToStr(pGuid, szGuid));
    }

    return ret;
}

DWORD
sbTableGetTagFromStringName(
    IN OUT  DBPOS *       pDB,
    IN      JET_TABLEID   tblid,
    IN      DSNAME *      pDN,
    IN      BOOL          fAddRef,
    IN      BOOL          fAnyRDNType,
    IN      DWORD         dwExtIntFlags,
    OUT     ULONG *       pTag,             OPTIONAL
    OUT     d_memname **  ppname,           OPTIONAL
    OUT     BOOL *        pfIsRecordCurrent OPTIONAL
    )
/*++

Routine Description:

    Returns the DN tag associated with a given DSNAME's string name, and
    optionally adds a ref count for it (in which case it creates records as
    needed).

Arguments:

    pDB (IN/OUT) - Currency can be changed.
    
    tblid (IN) - Which table to use -- pDB->JetSearchTbl or pDB->JetObjTbl.
    
    pDN (IN) - DSNAME of the object to map to a tag.
    
    fAddRef (IN) - If TRUE, add a ref count to the record associated with this
        DN.  Creates records as necessary.  May not be combined with ppname.
        Also, may not be combined with fAnyRDNType.

    fAnyRDNType (IN) - If TRUE, ignore the type of the final RDN in the name
        (e.g. treat "cn=foo,dc=bar,dc=com" and "ou=foo,dc=bar,dc=com" as equal).
        May not be combined with fAddRef.
        
    dwExtIntFlags (IN) - 0 or EXTINT_NEW_OBJ_NAME.  The latter is valid only
        in combination with fAddRef, and indicates the DN we're add-refing is
        a new record in a prepard update in pDB->JetObjTbl.
    
    pTag (OUT, OPTIONAL) - On return, holds the tag associated with pDN if the
        return value is 0; otherwise, holds the closest match.
    
    ppname (OUT, OPTIONAL) - On return, holds a pointer to the d_memname struct
        (from the cache) associated with this DN if the return value is 0;
        otherwise, holds the closest match.  May not be combined with fAddRef.
        
    pfRecordIsCurrent (OUT, OPTIONAL) - On successful return, indicatess whether
        the cursor tblid is positioned on the target record.

Return Values:

    0 - successfully found a record -- may be phantom or object.
    DB_ERR_* - failure.

    Throws database exception on unexpected JET errors.

--*/
{
    THSTATE *   pTHS = pDB->pTHS;
    DWORD       ret = 0;
    unsigned    curlen;
    ULONG       curtag = ROOTTAG;
    BOOL        fIsRecordCurrent = FALSE;
    d_memname * pname = NULL;
    d_memname   search = {0};
    DWORD       cNameParts;
    DWORD       cAncestorsAllocated = 0;
    DWORD       cTempAncestorsAllocated = 0;
    DWORD       cTempAncestors = 0;
    DWORD *     pTempAncestors = NULL;
    DWORD       iNamePart;
    WCHAR       rdnbuf[MAX_RDN_SIZE];
    BOOL        fOnPDNTIndex = FALSE;
    WCHAR *     pKey;
    BOOL        fPromotePhantom = fAddRef
                                  && (dwExtIntFlags & EXTINT_NEW_OBJ_NAME);
    BOOL        fUseExtractedGuids = fAddRef;

    // Note that we extract and use the GUIDs of mangled RDNs only in the case
    // where we're doing an add-ref.  This is specifically required to avoid
    // creating multiple records for the same object -- some mangled, some not,
    // some with guids, some without.  Lack of this support in the add-ref case
    // led to bug 188247.  Note that this support *CANNOT* be restricted to only
    // fDRA -- see JeffParh.  This add-ref behavior should not be visible to
    // LDAP clients due to the way that we verify names fed to us via LDAP
    // up-front.
    //
    // We do *NOT* enable this in the normal read case so as not to perplex LDAP
    // clients.

    // We don't accurately track pname in the fAddRef case.
    Assert((NULL == ppname) || !fAddRef);

    // You can't be both adding a reference AND not caring about RDN type.
    Assert(!fAddRef || !fAnyRDNType);
    
    Assert((tblid == pDB->JetSearchTbl) || (tblid == pDB->JetObjTbl));
    Assert(fAddRef || (0 == dwExtIntFlags));

    if (NULL != ppname) {
        *ppname = NULL;
    }

    if (NULL != pfIsRecordCurrent) {
        *pfIsRecordCurrent = FALSE;
    }

    if (NULL != pTag) {
        *pTag = ROOTTAG;
    }

    ret = CountNameParts(pDN, &cNameParts);
    if (ret || (0 == cNameParts)) {
        // Failure, or we were asked to find the root.  We're done.
        return ret;
    }

    if (fAddRef) {
        // Pre-allocate the probable ancestors list size, based on the number of
        // name components.  Note that since we can find some records by guid,
        // the final ancestors count may be different.
        cAncestorsAllocated = 1 + cNameParts; // don't forget one for ROOTTAG!
        search.pAncestors = THAllocEx(pTHS,
                                      cAncestorsAllocated * sizeof(DWORD));
        search.pAncestors[0] = ROOTTAG;
        search.cAncestors = 1;

        cTempAncestorsAllocated = cAncestorsAllocated;
        pTempAncestors = THAllocEx(pTHS,
                                   cTempAncestorsAllocated * sizeof(DWORD));
        cTempAncestors = 0;
    }

    search.tag.pRdn = rdnbuf;

    // For each RDN in the name, starting with the most significant
    // (e.g., DC=COM)...
    for (iNamePart = 0, curlen = pDN->NameLen;
         iNamePart < cNameParts;
         iNamePart++,   curlen = (UINT)(pKey - pDN->StringName)) {
        
        BOOL    fIsLastNameComponent = (iNamePart == cNameParts-1);
        DWORD   cbSid = 0;
        SID *   pSid = NULL;
        GUID *  pGuid = NULL;
        BOOL    fNameConflict = FALSE;
        ATTRTYP type;
        WCHAR * pQVal;
        DWORD   ccKey, ccQVal, ccVal;

        // Parse out the RDN that's iNameParts from the top (most significant).
        ret = GetTopNameComponent(pDN->StringName, curlen, &pKey,
                                  &ccKey, &pQVal, &ccQVal);
        if (ret) {
            break;
        }

        Assert(pKey);
        Assert(ccKey != 0);
        Assert(pQVal != 0);
        Assert(ccQVal != 0);

        type = KeyToAttrType(pDB->pTHS, pKey, ccKey);
        if (0 == type) {
            ret = DIRERR_NAME_TYPE_UNKNOWN;
            break;
        }

        ccVal = UnquoteRDNValue(pQVal, ccQVal, rdnbuf);
        if (0 == ccVal) {
            ret = DIRERR_NAME_UNPARSEABLE;
            break;
        }

        Assert(search.tag.pRdn == rdnbuf);
        search.tag.PDNT    = curtag;
        search.tag.rdnType = type;
        search.tag.cbRdn   = ccVal * sizeof(WCHAR);

        if (fIsLastNameComponent && !fNullUuid(&pDN->Guid)) {
            // This is the last component of the DSNAME and the DSNAME has a
            // guid -- the guid for this record is that of the DSNAME.
            // Note that we assume we can't find this record by guid -- the
            // caller should have tried finding the target by guid before
            // calling us.  (We assert to this effect below.)
            search.Guid   = pDN->Guid;
            search.Sid    = pDN->Sid;
            search.SidLen = pDN->SidLen;
            
            pGuid = &search.Guid;
        }
        else if (fUseExtractedGuids
                 && IsMangledRDN(search.tag.pRdn,
                                 search.tag.cbRdn / sizeof(WCHAR),
                                 &search.Guid,
                                 NULL)) {
            // We successfully decoded the GUID from a previously mangled
            // RDN.  This RDN was mangled on some server due to deletion or
            // a name conflict; at any rate, we now have the guid, so we
            // should first try to see if we can find the record by guid.
            
            // sbTableGetTagFromGuid() will switch over to the GUID index.
            fOnPDNTIndex = FALSE;

            ret = sbTableGetTagFromGuid(pDB, tblid, &search.Guid, NULL, &pname,
                                        &fIsRecordCurrent);
            if (0 == ret) {
                // Found record by guid.
                
                Assert(!(fIsLastNameComponent
                         && fAddRef
                         && (dwExtIntFlags & EXTINT_NEW_OBJ_NAME)
                         && pname->objflag
                         && "Object conflict should have been detected in "
                                "CheckNameForAdd()!"));
                
                // Copy the ancestors list.
                if (pname->cAncestors) {
                    if (pname->cAncestors >= cAncestorsAllocated) {
                        cAncestorsAllocated = pname->cAncestors + 1;
                        search.pAncestors =
                            THReAllocEx(pTHS, search.pAncestors,
                                        cAncestorsAllocated * sizeof(DWORD));
                    }
                    
                    memcpy(search.pAncestors, pname->pAncestors,
                           pname->cAncestors * sizeof(DWORD));
                }
    
                search.cAncestors = pname->cAncestors;
                
                curtag = pname->DNT;
    
                Assert(0 == ret);

                // Move on to next name component.
                continue;
            }
            else {
                // Okay, we didn't find this record by GUID.  If we're add-
                // refing and find it by string name or we have to create it,
                // we should add the GUID to the record.
                pGuid = &search.Guid;
            }
        }
        else {
            // No GUID available for this record.
            memset(&search.Guid, 0, sizeof(GUID));
            pGuid = NULL;
        }

        Assert(fIsLastNameComponent || (0 == search.SidLen));
        
        // pGuid is NULL iff search.Guid is a null guid.
        Assert(((&search.Guid == pGuid) && !fNullUuid(&search.Guid))
               || ((NULL == pGuid) && fNullUuid(&search.Guid)));

        if (!fOnPDNTIndex) {
            // Set the index for the DNChildFind below.
            JetSetCurrentIndex4Success(pDB->JetSessID,
                                       tblid,
                                       SZPDNTINDEX,
                                       &idxPdnt,
                                       0);
            fOnPDNTIndex = TRUE;
        }


        ret = DNChildFind(pDB,
                          tblid,
                          // enforce type if this is not the last component or
                          // we are not allowing any rdn type
                          (!fIsLastNameComponent || !fAnyRDNType),
                          curtag,
                          search.tag.pRdn,
                          search.tag.cbRdn,
                          search.tag.rdnType,
                          &pname,
                          &fIsRecordCurrent);
        if(ret == ERROR_DS_KEY_NOT_UNIQUE) {
            // massage error code to be the one downstream callers expect.
            ret = DIRERR_OBJ_NOT_FOUND;
        }
        
        Assert((0 == ret) || (DIRERR_OBJ_NOT_FOUND == ret));

        if (0 == ret) {
            // Found this name component by string name -- it may or may not
            // actually be the record we're looking for.  All we know for
            // sure is that it has the right string DN.
            Assert((type == pname->tag.rdnType) ||
                   (fIsLastNameComponent && fAnyRDNType));
            Assert(curtag == pname->tag.PDNT);
            
            curtag = pname->DNT;

            if (fAddRef) {
                // Save ancestors list.  Operations below like
                // sbTableUpdateRecordIdentity() can nuke the ancestors list.
                if (pname->cAncestors >= cTempAncestorsAllocated) {
                    cTempAncestorsAllocated = pname->cAncestors;
                    pTempAncestors =
                        THReAllocEx(pTHS, pTempAncestors,
                                    cTempAncestorsAllocated * sizeof(DWORD));
                }
                memcpy(pTempAncestors, pname->pAncestors,
                       pname->cAncestors * sizeof(DWORD));
                cTempAncestors = pname->cAncestors;
            }

            if (NULL != pGuid) {
                if (!fAddRef) {
                    // String name matches.  However, we also know what the
                    // guid of the record is supposed to be.  If the record
                    // we found has a guid and it's not the same, the record
                    // is not a match.

                    if (!fNullUuid(&pname->Guid)) {
                        if (0 != memcmp(pGuid, &pname->Guid, sizeof(GUID))) {
                            // Same DN, different guid -- record not found!
                            ret = DIRERR_OBJ_NOT_FOUND;
                            break;
                        }
                        else if (fIsLastNameComponent) {
                            Assert(!"Found target record by string name when "
                                    "we should have searched for (and found) "
                                    "it by guid before we entered this "
                                    "function.");
                            Assert(0 == ret);
                        }
                        else {
                            Assert(!"Found and decoded mangled guid in an RDN "
                                    "other than the last (leaf-most) one in "
                                    "the DN; failed to find record by guid, "
                                    "but found it by string name and then "
                                    "found the guid *is* present -- "
                                    "sbTableGetTagFromGuid() failure?");
                            Assert(0 == ret);
                        }
                    }
                }
                else if (fNullUuid(&pname->Guid)) {
                    // Add-ref case.
                    // The record we found is a structural phantom, lacking a
                    // GUID and SID (if any).
                    
                    // This record has no GUID, so it had better be a
                    // phantom and not an object!
                    Assert(!pname->objflag);

                    if (!(dwExtIntFlags & EXTINT_NEW_OBJ_NAME)) {
                        // We're not adding a new object -- okay to go ahead
                        // and add the GUID (& SID, if any) to the phantom.
                        sbTableUpdateRecordIdentity(pDB, curtag, NULL, 0,
                                                    pGuid, (SID *) &search.Sid,
                                                    search.SidLen);
                    }
                
                    Assert(0 == ret);
                }
                else if (0 != memcmp(&pname->Guid, pGuid, sizeof(GUID))) {
                    // Add-ref case.
                    // The record we found has the right string name but the
                    // wrong GUID.  If it is a phantom, mangle its name and
                    // allow this latest reference to have the name it wants.
                    // If it's an object, mangle the name in the reference
                    // instead.
                    DWORD cchNewRDN;
                    
                    Assert(!fNameConflict);
                    fNameConflict = TRUE;
                    
                    if (!pname->objflag) {
                        // The record we found is a phantom; allow the new
                        // reference to take the name, and rename the record we
                        // found to avoid conflicts.
                        WCHAR szNewRDN[MAX_RDN_SIZE];
                    
                        memcpy(szNewRDN, pname->tag.pRdn, pname->tag.cbRdn);
                        cchNewRDN = pname->tag.cbRdn / sizeof(WCHAR);
                    
                        MangleRDN(MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT,
                                  &pname->Guid, szNewRDN, &cchNewRDN);
                        
                        sbTableUpdateRecordIdentity(pDB, curtag, szNewRDN,
                                                    cchNewRDN, NULL, NULL, 0);
                    }
                    else {
                        // The record we found is a pre-existing object, so it
                        // has dibs on the name.  Go ahead and create a new
                        // record for what we're looking for, but give our new
                        // record a mangled name to resolve the conflict.
                        cchNewRDN = search.tag.cbRdn / sizeof(WCHAR);

                        MangleRDN(MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT,
                                  &search.Guid, search.tag.pRdn, &cchNewRDN);

                        search.tag.cbRdn = cchNewRDN * sizeof(WCHAR);
                    }

                    // Treat this as the "not found" case -- add a new record.
                    ret = DIRERR_OBJ_NOT_FOUND;
                }
                else if (fIsLastNameComponent) {
                    // Add-ref case.
                    Assert(!"Found target record by string name when we should "
                            "have searched for (and found) it by guid before "
                            "we entered this function.");
                    Assert(0 == ret);
                }
                else {
                    // Add-ref case.
                    Assert(!"Found and decoded mangled guid in an RDN other "
                            "than the last (leaf-most) one in the DN; failed "
                            "to find record by guid, but found it by string "
                            "name and then found the guid *is* present -- "
                            "sbTableGetTagFromGuid() failure?");
                    Assert(0 == ret);
                }
            }
            else {
                Assert(!(fIsLastNameComponent
                         && fAddRef
                         && (dwExtIntFlags & EXTINT_NEW_OBJ_NAME)
                         && pname->objflag
                         && "Object conflict should have been detected in "
                                "CheckNameForAdd()!"));
            }
            
            if ((0 == ret) && fAddRef) {
                // This record does indeed match the component we were looking
                // for -- save its ancestors.
                SwapDWORD(&cTempAncestorsAllocated, &cAncestorsAllocated);
                SwapDWORD(&cTempAncestors, &search.cAncestors);
                SwapPTR(&pTempAncestors, &search.pAncestors);
            }
        }
        
        if (0 != ret) {
            // This name component was not found.
            Assert(DIRERR_OBJ_NOT_FOUND == ret);

            if (fAddRef) {
                // Add a new record for this name component.
                if (search.cAncestors >= cAncestorsAllocated) {
                    // Hmm.  I don't have enough room to add my own DNT to the
                    // end of the ancestors I got from my parent.  Add one to
                    // the size of the allocated ancestors buffer so I can add
                    // my own DNT.  Should occur only if we've grown the depth
                    // of the DN due to using extracted GUIDs.
                    Assert(fUseExtractedGuids);
                    cAncestorsAllocated = search.cAncestors + 1;
                    search.pAncestors =
                        THReAllocEx(pTHS, search.pAncestors,
                                    cAncestorsAllocated * sizeof(DWORD));
                }

                curtag = DNwrite(pDB,
                                 &search,
                                 fIsLastNameComponent ? dwExtIntFlags : 0);
                pname = NULL;

                // Note that DNwrite() has added the DNT of the new record
                // to the pAncestors array, so pAncestors is all set for the
                // next iteration.

                if (fIsLastNameComponent) {
                    // No record matching the string name we wanted to add-ref
                    // (which we just stamped in the obj table) -- no need to
                    // promote a phantom.
                    fPromotePhantom = FALSE;
                }

                // Successfully added this name component -- nnnext!
                ret = 0;
            }
            else {
                break;
            }
        }
    }

    // We either successfully walked all the RDNs or we encountered an error.
    Assert((0 != ret) || (iNamePart == cNameParts));
    Assert((0 != ret) || fAddRef || (NULL != pname));
    Assert((0 != ret) || fAddRef || (curtag == pname->DNT));
    
    if (0 == ret) {
        if (fAddRef) {
            if (fPromotePhantom) {
                // An add-ref for a new object currently in a prepared update in
                // pDB->JetObjTbl.  We found a phantom with the new object's DN
                // -- we need to promote it to an object and merge in the
                // object's attributes from JetObjTbl.
                sbTablePromotePhantom(pDB, curtag, search.tag.PDNT,
                                      search.tag.pRdn, search.tag.cbRdn);
            
                DPRINT2(1,
                        "Promoted phantom \"%ls\" (@ DNT 0x%x) and ref-counted "
                            "by string name!\n",
                        pDN->StringName, curtag);
            }
            else {
                DPRINT2(1, "Ref-counted \"%ls\" (@ DNT 0x%x) by string name.\n",
                        pDN->StringName, curtag);
            }
        
            DBAdjustRefCount(pDB, curtag, 1);
        }
        else {
            DPRINT2(1, "Found \"%ls\" (@ DNT 0x%x) by string name.\n",
                    pDN->StringName, curtag);
        }
    }

    // Note that even in the error case (0 != ret), we return the best match
    // we could find.  This functionality is used by sbTableGetTagFromDSName().
    if (NULL != ppname) {
        *ppname = pname;
    }

    if (NULL != pTag) {
        *pTag = curtag;
    }

    if (NULL != pfIsRecordCurrent) {
        *pfIsRecordCurrent = fIsRecordCurrent;
    }

    return ret;
}

void
sbTablePromotePhantom(
    IN OUT  DBPOS *     pDB,
    IN      ULONG       dntPhantom,
    IN      ULONG       dntObjParent,
    IN      WCHAR *     pwchRDN,
    IN      DWORD       cbRDN
    )
/*++

Routine Description:

    Promote the phantom at the given DNT into the object with currency in
    pDB->JetObjTbl.  The phantom is promoted in-place such that any pre-existing
    references to it (e.g., by children or DN-valued attributes of other
    objects) are not left dangling, and it acquires all attributes from the
    pDB->JetObjTbl record.  The pDB->JetObjTbl record is subsequently lost.

Arguments:

    pDB (IN/OUT)

    dntPhantom - DNT of the phantom to promote.

    dntObjParent - DNT of the object's parent (which might be different from the
        current parent of the phantom).

    pwchRDN - the new object's RDN (_not_ null-terminated)

    cbRDN - the size IN BYTES of pwchRDN.

Return Values:

    0 on success, non-zero on failure.

--*/
{
    THSTATE                    *pTHS=pDB->pTHS;
    JET_ERR                     err;
    JET_RETINFO                 retinfo;
    JET_SETINFO                 setinfo;
    char *                      buf;
    ULONG                       cbBuf;
    ULONG                       cbCol;
    ULONG                       dntNewObj;
    ULONG                       CurrRecOccur = 1;
    char                        objval = 0;
    BOOL                        fIsMetaDataCached;
    BOOL                        fMetaDataWriteOptimizable;
    DWORD                       cbMetaDataVecAlloced;
    PROPERTY_META_DATA_VECTOR * pMetaDataVec;
    d_memname *                 pname;
    ULONG                       dntPhantomParent;

    Assert(VALID_DBPOS(pDB));

    // cbRDN is a size in BYTES, not WCHARS
    Assert( 0 == ( cbRDN % sizeof( WCHAR ) ) );

    // Save meta data vector we've created thus far; we'll restore it once
    // we've moved over to the phantom's DNT.

    fIsMetaDataCached = pDB->fIsMetaDataCached;
    fMetaDataWriteOptimizable = pDB->fMetaDataWriteOptimizable;
    cbMetaDataVecAlloced = pDB->cbMetaDataVecAlloced;
    if ( fIsMetaDataCached && cbMetaDataVecAlloced )
    {
        pMetaDataVec = THAllocEx(pTHS,  cbMetaDataVecAlloced );
        memcpy( pMetaDataVec, pDB->pMetaDataVec,
                cbMetaDataVecAlloced );
    }
    else
    {
        pMetaDataVec = NULL;
    }

    /* update the record using SearchTbl */

    pname = DNread(pDB, dntPhantom, DN_READ_SET_CURRENCY);
    dntPhantomParent = pname->tag.PDNT;

    JetPrepareUpdateEx(pDB->JetSessID, pDB->JetSearchTbl,
                       DS_JET_PREPARE_FOR_REPLACE);

    /* get the DNT of the record to be inserted so we can
     * replace references to it
     */

    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl,
                             dntid, &dntNewObj, sizeof(dntNewObj),
                             &cbCol,  pDB->JetRetrieveBits, NULL);

    // Copy record's attributes from ObjTbl to SearchTbl. All the non-tagged
    // columns are already set on the older object. So, copy all the tagged
    // columns from JetObjTbl (with currency on the new DNT we're aborting) to
    // JetSearchTbl (with currency on the phantom we're promoting).

    retinfo.cbStruct = sizeof(retinfo);
    retinfo.ibLongValue = 0;
    retinfo.itagSequence = CurrRecOccur;
    retinfo.columnidNextTagged = 0;
    setinfo.cbStruct = sizeof(setinfo);
    setinfo.ibLongValue = 0;
    setinfo.itagSequence = 0;   /* New tag */
    cbBuf =  DB_INITIAL_BUF_SIZE;
    buf = dbAlloc(cbBuf);

    while (((err=JetRetrieveColumnWarnings(pDB->JetSessID,
                                           pDB->JetObjTbl,
                                           0, buf, cbBuf,
                                           &cbCol,
                                           pDB->JetRetrieveBits,
                                           &retinfo)) ==
             JET_errSuccess) ||
           (err == JET_wrnBufferTruncated)) {

        if (err == JET_errSuccess) {

            // Don't copy RDN; it will be blasted onto the phantom below.
            if (rdnid != retinfo.columnidNextTagged) {

                if ((guidid == retinfo.columnidNextTagged)
                    || (sidid == retinfo.columnidNextTagged)) {
                    // This attribute may or may not already exist on the
                    // phantom; if it already exists, the following will
                    // prevent us from having a duplicate on the final,
                    // promoted object.
                    setinfo.itagSequence = 1;
                }

                JetSetColumnEx(pDB->JetSessID,
                               pDB->JetSearchTbl,
                               retinfo.columnidNextTagged,
                               buf, cbCol, 0, &setinfo);

                setinfo.itagSequence = 0;   /* New tag */
            }
        
            retinfo.itagSequence = ++CurrRecOccur;
            retinfo.columnidNextTagged = 0;
        }
        else {
            cbBuf = cbCol;
            dbFree(buf);
            buf = dbAlloc(cbBuf);
        }
    }

    dbFree(buf);

    // Set ATT_RDN and PDNT on the phantom being promoted to those derived from
    // the DN of the new object.  This is necessary since we most likely found
    // this phantom by GUID, implying the object might have been renamed and/or
    // moved since the phantom was created.

    Assert(setinfo.cbStruct == sizeof(setinfo));
    Assert(setinfo.ibLongValue == 0);
    setinfo.itagSequence = 1;

    JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, rdnid,
                   pwchRDN, cbRDN, 0, &setinfo);

    if (dntObjParent != pname->tag.PDNT) {
        // Object has indeed been moved; change its parent.
        // Note that this implies we need to move the parent refcount from the
        // phantom's parent to the object's parent.
        DBAdjustRefCount(pDB, dntPhantomParent, -1);
        DBAdjustRefCount(pDB, dntObjParent, 1);

        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, pdntid,
                       &dntObjParent, sizeof(dntObjParent), 0, &setinfo);
    }

    /* replace any referencesto the aborted DNT in the links
     * table
     */

    dbRenumberLinks(pDB, dntNewObj, dntPhantom);
    DBCancelRec(pDB);

    // We're promoting a phantom to real object.  Move all the refcounts
    // from temporary real object to phantom which is being promoted.
    dbEscrowPromote(dntPhantom,     // phantom being promoted
                    dntNewObj);     // temporary real object

    /* indicate that data portion is missing */

    JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, objid,
                   &objval, sizeof(objval), 0, NULL);

    JetUpdateEx(pDB->JetSessID, pDB->JetSearchTbl,
                NULL, 0, 0);

    // Future updates should occur to the now-promoted phantom's DNT.
    pDB->JetNewRec = FALSE;
    DBFindDNT(pDB, dntPhantom);
    dbInitRec(pDB);

    // Flush the phantom's DNT (which may have just undergone an RDN change)
    // from the read cache.
    dbFlushDNReadCache( pDB, dntPhantom );

    // ...and flush it again when we make the update, since we're changing the
    // value of its objflag.
    pDB->fFlushCacheOnUpdate = TRUE;

    // Restore meta data we've constructed thus far.
    Assert( !pDB->fIsMetaDataCached );

    pDB->fIsMetaDataCached    = fIsMetaDataCached;
    pDB->fMetaDataWriteOptimizable = fMetaDataWriteOptimizable;
    pDB->cbMetaDataVecAlloced = cbMetaDataVecAlloced;
    pDB->pMetaDataVec         = pMetaDataVec;

    DPRINT2(1, "Promoted phantom @ DNT 0x%x from new object @ DNT 0x%x.\n",
            dntPhantom, dntNewObj);

} /* sbTablePromotePhantom */

void
sbTableUpdatePhantomDNCase (
        IN OUT DBPOS      *pDB,
        IN     DWORD       DNT,
        IN     ATTRBLOCK  *pNowBlockName,
        IN     ATTRBLOCK  *pRefBlockName)
/*++     
  Description.
      Iteratively walks up the PDNT chain starting at the DNT passed in.
      Compares two blocknames and if the RDN of this object differs, write a new
      RDN.  Only do this for structural phantoms, I.E. halt recursion anytime
      the object passed in is NOT a structural phantom.

      This routine is very sensitive to it's parameters.  It is expected that
      the two blocknames passed in are identical in every way except for a
      casing difference in some of the RDNs.  The DNT passed in should be the
      DNT for the object whose DSNAME is implied by the blocknames. 

      This routine is a helper for sbTableUpdatePhantomName.  It is called when
      we are updating a phantom name where the case of some parent objects RDN
      has changed.  sbTableUpdatePhantomName is very careful with the
      parameters, so we don't verify them here.

      This routine modifies objects on the search table, but only phantoms.  It
      does not make any change which is replicable, only strictly local.

  Parameters:    
      pDB - the DBPos to use
      DNT - the DNT of the object implied by the blocknames.
      pNowBlockName - BlockName which represents the actual contents of the
          database. 
      pRefBlockName - BlockName which represents what we want the actual
          contents of the database to be.

  Returns           
      None.  Either success or we except out.
--*/
{
    JET_RETRIEVECOLUMN jCol[2];
    DWORD              err;
    DWORD              cb;
    DWORD              level;

    Assert(pRefBlockName->attrCount == pNowBlockName->attrCount);
    
    JetSetCurrentIndex4Success(pDB->JetSessID,
                               pDB->JetSearchTbl,
                               SZDNTINDEX,
                               &idxDnt,
                               0);
    
    for(level = pRefBlockName->attrCount - 1;level;level--) {
        // First, position on the object in the search table.
        pDB->SDNT = 0;
        JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl, &DNT, sizeof(DNT),
                     JET_bitNewKey);
        err = JetSeek(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekEQ);
        if (err) {
            DsaExcept(DSA_DB_EXCEPTION, err, DNT);
        }
        pDB->SDNT = DNT;
        
        // See if it is a structural phantom.  You do this by checking for the
        // absence of both a GUID and a OBJ_DIST_NAME
        memset(jCol, 0, sizeof(jCol));
        jCol[0].columnid = distnameid;
        jCol[0].itagSequence = 1;
        jCol[1].columnid = guidid;
        jCol[1].itagSequence = 1;
         
        JetRetrieveColumnsWarnings(pDB->JetSessID,
                                   pDB->JetSearchTbl,
                                   jCol,
                                   2);
        if((jCol[0].err != JET_wrnColumnNull) ||
           (jCol[1].err != JET_wrnColumnNull)     ) {
            // It is not a structural phantom.  Leave, we're done.
            return;
        }
        
        // Now, look at the RDN info in the names
        Assert(pNowBlockName->pAttr[level].attrTyp ==
               pRefBlockName->pAttr[level].attrTyp    );
        Assert(pNowBlockName->pAttr[level].AttrVal.pAVal->valLen ==
               pRefBlockName->pAttr[level].AttrVal.pAVal->valLen    );
        
        if(memcmp(pNowBlockName->pAttr[level].AttrVal.pAVal->pVal,
                  pRefBlockName->pAttr[level].AttrVal.pAVal->pVal,
                  pRefBlockName->pAttr[level].AttrVal.pAVal->valLen)) {
            // Yes, the RDN needs to change.
            JetPrepareUpdateEx(pDB->JetSessID, pDB->JetSearchTbl,
                               DS_JET_PREPARE_FOR_REPLACE);
            JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, rdnid,
                           pRefBlockName->pAttr[level].AttrVal.pAVal->pVal,
                           pRefBlockName->pAttr[level].AttrVal.pAVal->valLen,
                           0, NULL);
            
            JetUpdateEx(pDB->JetSessID, pDB->JetSearchTbl, NULL, 0, 0);
            
            // Reset entry in DN read cache, since the RDN has changed.
            dbFlushDNReadCache(pDB, DNT);
        }
        
        // Finally, get the PDNT of the current object as the next DNT to look
        // at and then continue the loop
        cb = 0;
        JetRetrieveColumnSuccess(pDB->JetSessID,
                                 pDB->JetSearchTbl, pdntid,
                                 &DNT,
                                 sizeof(DNT),
                                 &cb,
                                 JET_bitRetrieveCopy,
                                 NULL);
        
        Assert(cb = sizeof(DNT));
    }
    return;
}

DWORD
sbTableUpdatePhantomName (
        IN  OUT DBPOS     *pDB,
        IN      d_memname *pdnName,
        IN      DWORD      dnt,
        IN      DSNAME    *pdnRef,
        IN      DSNAME    *pdnNow)
/*++

Routine Description:

    Update phantom names.  Looks at the stringname of the phantom passed in and
    the stringname of the phantom in the DIT and modifies appropriately.  This
    can be as simple as modifying the RDN, or as complex as creating a new
    structural phantom to be a parent of the phantom, moving the phantom to be a
    child of the new structural phantom, modifying it's RDN, and modifying its
    SID.

    It is expected that this routine is called after already finding that the
    string name of the phantom is stale.

    pdnRef must have a stringname and a guid.  No check is made here.

    If the stringname in the dsname passed in is already in use and the object
    using that name is a phantom, the existing object which uses that name has
    it's RDN mangled to free up the name.  It is expected that a later
    modification will give the mangled object a better name.  If the name is in
    use by an instantiated object, this routine does nothing and returns.
    
Arguments:

    pDB (IN/OUT) - PDB to do this work on.  This routine uses the search table.
                 pDB->SDNT may change, etc.

    pdnName (IN) - memname of the existing phantom object whose name is to be
        updated.  This is the data that exists in the DIT and is to be changed
        by this routine.

    dnt (IN) - dnt of the existing phantom object whose name is to be updated.

    pdnRef (IN) - DSNAME of the object whose name is to be updated.  The
        stringname holds the name that is to be written into the DIT.  This
        is expected to be different from the stringname already on the object in
        the DIT (and reflected in pdnName).

Return Values:

    0 on success, non-zero DIRERR_* on failure.

--*/
{
    DWORD       err;
    WCHAR       rgwchRDN[MAX_RDN_SIZE];
    WCHAR       rgwchMangledRDN[MAX_RDN_SIZE];
    DWORD       cchRDN;
    ATTRTYP     attidRDN;
    DSNAME *    pdnRefParent;
    DSNAME *    pdnNowParent;
    DWORD       PDNT;
    NT4SID      sidRefInt;
    BOOL        fWriteNewRDN;
    BOOL        fWriteNewSid;
    BOOL        fWriteNewPDNT;
    USN         usnChanged;
    BOOL        fNewParentCreated = FALSE;
    DWORD       DNTConflict;
    GUID        GuidConflict, objGuid;
    DWORD       objSidLen;
    DWORD       actuallen, cchMangledRDN;
    ATTRBLOCK  *pNowBlockName=NULL;
    ATTRBLOCK  *pRefBlockName=NULL;
    THSTATE     *pTHS = pDB->pTHS;
    d_memname  *pconflPhantom = NULL;
    DWORD      *pdntAncestors = NULL;
    DWORD      cbAncestorsSize = 0, cNumAncestors = 0;
    

    // First, examine the parent.  There are three possible outcomes:
    // 1) The new name implies a completely new parent.  In this case, find the
    //    PDNT of the new parent (and add a new structural phantom if the new
    //    parent doesn't yet exist.)
    // 2) The new name implies exactly the same parent.  In this case, we do
    //    nothing more for the parent name, it is already correct.
    // 3) The new name implies the same parent via NameMatch, but the case of
    //    some part of the parents DN has changed.  In this case, we traverse up
    //    our parent chain and fix any RDN case changes for phantom objects.
    pdnRefParent = THAllocEx(pTHS, pdnRef->structLen);
    TrimDSNameBy(pdnRef, 1, pdnRefParent);
    pdnNowParent = THAllocEx(pTHS, pdnNow->structLen);
    TrimDSNameBy(pdnNow, 1, pdnNowParent);
    err = 0;
    if(NameMatchedStringNameOnly(pdnRefParent, pdnNowParent)) {
        // Same parent.
        fWriteNewPDNT = FALSE;
        if(memcmp(pdnNowParent->StringName,
                  pdnRefParent->StringName,
                  pdnRefParent->NameLen)) {
            // however, some case change has occurred.  Fix it up.
            // Transform the names to a block names.
            err = DSNameToBlockName(pTHS,
                                    pdnRefParent,
                                    &pRefBlockName,
                                    DN2BN_PRESERVE_CASE);
            if(!err) {
                err = DSNameToBlockName(pTHS,
                                        pdnNowParent,
                                        &pNowBlockName,
                                        DN2BN_PRESERVE_CASE);
                
                if(!err) {
                    sbTableUpdatePhantomDNCase(
                            pDB,
                            pdnName->tag.PDNT,
                            pNowBlockName,
                            pRefBlockName);
                }
            }
        }
    }
    else {
        fWriteNewPDNT = TRUE;
        
        // Parent seems to have changed -- add ref the new parent.
        Assert(fNullUuid(&pdnRefParent->Guid));
        err = sbTableGetTagFromStringName(pDB,
                                          pDB->JetSearchTbl,
                                          pdnRefParent,
                                          TRUE,
                                          FALSE,
                                          0,
                                          &PDNT,
                                          NULL,
                                          NULL);
        
        // Drop the refcount of the old parent by one.
        DBAdjustRefCount(pDB, pdnName->tag.PDNT, -1);

        if (!err) {

            // also read the ancestry from the parent so as to put it later 
            // on the child
            dbGetAncestorsSlowly(pDB, PDNT, &cbAncestorsSize, &pdntAncestors, &cNumAncestors);

            // if our parent was not ROOT, we need two more entries on the resulting array
            if (PDNT != ROOTTAG) {
                if (cbAncestorsSize < (cNumAncestors + 2) * sizeof(*pdntAncestors)) {
                    // Make room for an additional DNT at the end of the ancestors list.
                    cbAncestorsSize = (cNumAncestors + 2) * sizeof(*pdntAncestors);
                    pdntAncestors = THReAllocEx(pDB->pTHS, pdntAncestors, cbAncestorsSize);
                }
                pdntAncestors[cNumAncestors++] = PDNT;
            }
            else {
                // ROOTTAG is already on the list
                if (cbAncestorsSize < (cNumAncestors + 1) * sizeof(*pdntAncestors)) {
                    // Make room for an additional DNT at the end of the ancestors list.
                    cbAncestorsSize = (cNumAncestors + 1) * sizeof(*pdntAncestors);
                    pdntAncestors = THReAllocEx(pDB->pTHS, pdntAncestors, cbAncestorsSize);
                }
            }
        }
    }

    if(pNowBlockName)
        FreeBlockName(pNowBlockName);
    if(pRefBlockName)
        FreeBlockName(pRefBlockName);
    THFreeEx(pTHS, pdnNowParent);
    THFreeEx(pTHS, pdnRefParent);

    if(err) {
        // Something went wrong with the parent verification.
        return err;
    }
    
    // Second, examine the SID.  There are only two outcomes.
    // 1) The sid hasn't changed.  Do nothing.
    // 2) There is a new sid.  In this case, write that SID on the object
    //    instead of the SID that's already there.
    if ((pdnName->SidLen != pdnRef->SidLen)
        || memcmp(&pdnName->Sid, &pdnRef->Sid, pdnRef->SidLen)) {
        // The phantom's SID is either absent (in which case we want
        // to add the one from the reference) or different (in which
        // case we still want to add the one from the reference).
        
        // Convert the SID from the reference into internal format.
        memcpy(&sidRefInt, &pdnRef->Sid, pdnRef->SidLen);
        InPlaceSwapSid(&sidRefInt);
        fWriteNewSid = TRUE;
    }
    else {
        fWriteNewSid = FALSE;
    }
        

    // Finally, examine the RDN.  There are three outcomes.
    // 1) The RDN has not changed in any way, so there is nothing to do.
    // 2) The RDN has only changed cases.
    // 3) The RDN is completely different.
    // In cases 2 and 3, we're going to need to write a new RDN on the object.

    GetRDNInfo(pTHS, pdnRef, rgwchRDN, &cchRDN, &attidRDN);
    if((pdnName->tag.cbRdn != cchRDN * sizeof(WCHAR)) ||
       (pdnName->tag.rdnType != attidRDN) ||
       (memcmp(pdnName->tag.pRdn, rgwchRDN, pdnName->tag.cbRdn))) {
        // The RDN has changed, reset it.
        fWriteNewRDN = TRUE;

        // this assert should never hit in a real system, unless we are 
        // doing refcount testing. 
        // an existing object can never change its rdntype.
        Assert ( (pdnName->tag.rdnType == attidRDN) && "Disable this Assert if your are doing a refcount test." );
    }
    else {
        fWriteNewRDN = FALSE;
    }



    // A side bit of work.  If the RDN has changed, it might have changed to a
    // name for a deleted object.  If it has, we need to romp through the link
    // table and sever link/backlink connections.
    if(fWriteNewRDN) {
        GUID tmpGuid;
        MANGLE_FOR reasonMangled;
        // See if the new RDN is for a deleted object and the old RDN is not
        if((IsMangledRDN(rgwchRDN, cchRDN, &tmpGuid, &reasonMangled)) &&
           (reasonMangled == MANGLE_OBJECT_RDN_FOR_DELETION) &&
           !(IsMangledRDN(pdnName->tag.pRdn,
                          pdnName->tag.cbRdn/2,
                          &tmpGuid,
                          NULL))) {
            // RemoveBackLinksFromPhantom
            dbRemoveAllLinks( pDB, pdnName->DNT, TRUE /*isbacklink*/ );
        }
    }
    
    if(fWriteNewRDN || fWriteNewPDNT) {
        // We are changing the RDN or PDNT.  In either case, we might end up
        // conflicting with an existing object.  Check by temporarily nulling
        // the guid and sidLen out of the existing name and then looking up the
        // name (thus forcing lookup by string name).  Remember to put back the
        // guid and sidLen.
        objGuid = pdnRef->Guid;
        objSidLen = pdnRef->SidLen;
        memset(&pdnRef->Guid, 0, sizeof(GUID));
        pdnRef->SidLen = 0;
        __try {
            err = sbTableGetTagFromDSName(
                    pDB,
                    pdnRef,
                    SBTGETTAG_fMakeCurrent | SBTGETTAG_fAnyRDNType,
                    &DNTConflict,
                    NULL);
        }
        __finally {
            pdnRef->Guid = objGuid;
            pdnRef->SidLen = objSidLen;
        }
            
        
        
        switch(err) {
        case 0:
            // Normal object.  This should never happen. 
            Assert(!"Phantom attempted rename of instantiated object!");
            // Silently fail, since we don't have the authority to rename an
            // instantiated object.
            return 0;
            break;
            
        case ERROR_DS_NOT_AN_OBJECT:
            if(DNTConflict == dnt) {
                // We conflict with ourselves.  This must mean we are NOT
                // changing PDNT, we ARE changing RDN, and the only difference
                // in RDN is a case change or a RDN type change
                Assert(!fWriteNewPDNT);
                Assert(fWriteNewRDN);
                err = 0;
            }
            else {
                // The object we conflict with is a Phantom.  We need to mangle
                // it's RDN.  Later (if the object is a reference phantom),
                // someone else should update the object to whatever its new
                // name should be (it must need a new name, since the phantom
                // we're updating wants to steal the name.)  If the object is a
                // structural phantom, someday someone will update some
                // reference child, and that will clean everything up.

                // Get the phantoms guid if it has one.
                switch(err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                                       pDB->JetSearchTbl,
                                                       guidid,
                                                       &GuidConflict,
                                                       sizeof(GuidConflict),
                                                       &actuallen,
                                                       0,
                                                       NULL)) {
                case 0:
                    // got a guid, no problem.
                    break;
                    
                case JET_wrnColumnNull:
                    // phantom has no guid.  It's a structural phantom.  Just
                    // fake one.
                    // If we try to reparent children of this structural
                    // phantom before munging its name, there is the danger
                    // of a number of conflicts while reparenting the objects
                    // so we don't do anything
                    DsUuidCreate(&GuidConflict);
                    err = 0;
                    break;
                    
                default:
                    // Something badly wrong.  Raise the same exception we would
                    // have raised in JetRetrieveColumnWarnings.
                    DsaExcept(DSA_DB_EXCEPTION, err, 0);
                    break;
                }

                pconflPhantom = DNread (pDB, DNTConflict, 0);
                
                memcpy(rgwchMangledRDN, pconflPhantom->tag.pRdn, pconflPhantom->tag.cbRdn);
                cchMangledRDN = pconflPhantom->tag.cbRdn / sizeof(WCHAR);

                MangleRDN(MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT,
                          &GuidConflict,
                          rgwchMangledRDN,
                          &cchMangledRDN);
                
                // Write new new RDN on the object we conflict with.
                JetPrepareUpdateEx(pDB->JetSessID, pDB->JetSearchTbl,
                                   DS_JET_PREPARE_FOR_REPLACE);

                JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, rdnid,
                               rgwchMangledRDN, cchMangledRDN * sizeof(WCHAR),
                               0, NULL);

                JetUpdateEx(pDB->JetSessID, pDB->JetSearchTbl, NULL, 0, 0);
                
                // Reset entry in DN read cache, since the RDN has changed.
                dbFlushDNReadCache(pDB, DNTConflict);
            }
            break;

        case ERROR_DS_NAME_NOT_UNIQUE:
            return err;

        default:
            // Didn't find anything, the name is free for use.
            err = 0;
            break;
        }
    }

    // OK, we've done all the preperatory work.  Do the actual update. Note
    // that we might not actually have a new RDN, PDNT, or SID to write here
    // because we might have needed to just change some case of some ancestors
    // RDN.  However, no matter what, we are going to write a new USN changed to
    // this object to show that we've done some processing while verifying it's
    // name. 

    // Set Currency and prepare to update.
    DNread(pDB, dnt, DN_READ_SET_CURRENCY);

    JetPrepareUpdateEx(pDB->JetSessID, pDB->JetSearchTbl,
                       DS_JET_PREPARE_FOR_REPLACE);
    if(fWriteNewSid) {
        // Update the SID.
        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, sidid,
                       &sidRefInt, pdnRef->SidLen, 0, NULL);
    }
    if(fWriteNewRDN) {
        // Update the RDN.
        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, rdnid,
                       rgwchRDN, cchRDN * sizeof(WCHAR), 0, NULL);

        // The rdnType is stored in the DIT as the msDS_IntId, not the
        // attributeId. This means an object retains its birth name
        // even if unforeseen circumstances allow the attributeId
        // to be reused.
        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, rdntypid,
                       &attidRDN, sizeof (attidRDN), 0, NULL);
    }
    if(fWriteNewPDNT) {
        // Update the PDNT.  Old/new parent refcounts have already been
        // adjusted.
        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, pdntid,
                       &PDNT, sizeof(PDNT), 0, NULL);
    
        // also update the ancestors
        if (cNumAncestors) {
            DPRINT (3, "Updating ancestry for phantom\n");
            Assert ((cNumAncestors+1) * sizeof (DWORD) <= cbAncestorsSize);
            pdntAncestors[cNumAncestors] = dnt;

            JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, ancestorsid,
                           &pdntAncestors, cbAncestorsSize, 0, NULL);
        }
    }

    usnChanged = DBGetNewUsn();
    JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, usnchangedid,
                   &usnChanged, sizeof(usnChanged), 0, NULL);
    
    JetUpdateEx(pDB->JetSessID, pDB->JetSearchTbl, NULL, 0, 0);


    
    // Reset entry in DN read cache, since either the RDN or the PDNT had to
    // have changed.
    dbFlushDNReadCache(pDB, dnt);
    
    return err;
}

DWORD
sbTableAddRefByGuid(
    IN OUT  DBPOS *     pDB,
    IN      DWORD       dwFlags,
    IN      DSNAME *    pdnRef,
    OUT     ULONG *     pTag
    )
/*++

Routine Description:

    Increment the ref count on a DN, finding the appropriate record by GUID.
    Fails if the appropriate record does not already exist.

Arguments:

    pDB (IN/OUT)

    dwFlags (IN) - 0, EXTINT_NEW_OBJ_NAME, or EXTINT_UPDATE_PHANTOM.
        EXTINT_NEW_OBJ_NAME indicates that we're adding a refcount for a new,
            instantiated object's name.
        EXTINT_UPDATE_PHANTOM indicates we want to update a phantom if found

    pdnRef (IN) - fully populated name of the phantom or object.

    pTag (OUT) - on return, holds the DNT of the record written (i.e., the
        record corresponding to the given DN).

Return Values:

    0 on success, non-zero DIRERR_* on failure.

--*/
{
    THSTATE *   pTHS = pDB->pTHS;
    DWORD       err;
    DSNAME *    pdnCurrent;
    DSNAME *    pdnOldParent;
    DSNAME *    pdnNewParent;
    WCHAR       rgwchRDN[MAX_RDN_SIZE];
    DWORD       cchRDN;
    d_memname * pname;
    ULONG       PDNT;
    BOOL        fCurrency = FALSE;
    DWORD       insttype = 0;  // 0 is not a valid instance type
    DWORD       cbActual;

    Assert(VALID_DBPOS(pDB));
    Assert(!fNullUuid(&pdnRef->Guid));

    err = sbTableGetTagFromGuid(pDB, pDB->JetSearchTbl, &pdnRef->Guid, pTag,
                                &pname, &fCurrency);

    if (   (0 == err) 
        && (dwFlags & EXTINT_UPDATE_PHANTOM)
        && pname->objflag ) {

        // We found the record and it is not a phantom.  Read the object's 
        // instance type since we want to update subrefs, too
        if ( !fCurrency ) {

            // Position on the object
            JetSetCurrentIndex4Success(pDB->JetSessID,
                                       pDB->JetSearchTbl,
                                       SZDNTINDEX,
                                       &idxDnt,
                                       0);
            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetSearchTbl,
                         &pname->DNT,
                         sizeof(pname->DNT),
                         JET_bitNewKey);
            err = JetSeekEx(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekEQ);
            if (err) {
                DsaExcept(DSA_DB_EXCEPTION, err, pname->DNT);
            }
        }

        // Read the instance type
        err = JetRetrieveColumn(pDB->JetSessID,
                                pDB->JetSearchTbl,
                                insttypeid,
                                &insttype,
                                sizeof(insttype),
                                &cbActual,
                                0,
                                NULL);
        if( err ) {
            DPRINT1(0, "Couldn't read instance type, error %d\n", err);
            // this error is continuable; we won't treat the object
            // like a subref
            insttype = 0;
            err = 0;
        }
    }

    if ((0 == err) && (dwFlags & EXTINT_NEW_OBJ_NAME)) {
        // The record we're trying to add-ref is the new record with currency
        // in pDB->JetObjTbl, which is in the middle of a prepared update.
        
        // There may or may not be another record with this same guid -- if
        // there is, we need to promote it.  If not, we just need to add the
        // appropriate columns.

        d_memname search = {0};
        BOOL      fPromotePhantom = !pname->objflag;
        
        Assert(pDB->JetRetrieveBits == JET_bitRetrieveCopy);
        Assert(pDB->JetNewRec);
        
        Assert(!pname->objflag
               && "Object conflict should have been detected in "
                  "CheckNameForAdd()!");
        
        // Derive RDN of the new object from its DN.
        GetRDNInfo(pDB->pTHS, pdnRef, rgwchRDN, &cchRDN,
                   &search.tag.rdnType);
        search.tag.cbRdn = cchRDN * sizeof(WCHAR);
        search.tag.pRdn  = rgwchRDN;
        
        // Copy other identities from the DSNAME.
        search.Guid   = pdnRef->Guid;
        search.Sid    = pdnRef->Sid;
        search.SidLen = pdnRef->SidLen;

        // Derive PDNT that should go on the new object.
        pdnNewParent = THAllocEx(pTHS,pdnRef->structLen);
        TrimDSNameBy(pdnRef, 1, pdnNewParent);

        err = sbTableGetTagFromStringName(pDB,
                                          pDB->JetSearchTbl,
                                          pdnNewParent,
                                          FALSE,
                                          FALSE,
                                          0,
                                          &search.tag.PDNT,
                                          &pname,
                                          NULL);
        THFreeEx(pTHS,pdnNewParent);

        if (0 != err) {
            // The parent of the object we're adding does not exist --
            // this should have been detected (and rejected) earlier.
            // Note that the parent can be a phantom; e.g., when the object
            // we're adding is the head of a new NC.
            DPRINT2(0,
                    "Parent of new object %ls not found, error %u.\n",
                    pdnRef->StringName, err);
            Assert(FALSE);
            DsaExcept(DSA_EXCEPTION, DS_ERR_NO_PARENT_OBJECT, err);
        }

        
        // Promote the phantom to be the full-fledged object.
        sbTablePromotePhantom(pDB, *pTag, search.tag.PDNT, rgwchRDN,
                              cchRDN * sizeof(WCHAR));
        DBAdjustRefCount(pDB, *pTag, 1);

        DPRINT2(1,
                "Promoted phantom \"%ls\" (@ DNT 0x%x) and "
                    "ref-counted by GUID!\n",
                pdnRef->StringName, *pTag);

        // Success!
        Assert(0 == err);
    }
    else if (!err) {
        // Found DN by GUID!
        BOOL fProcessed = FALSE;
        err = 0;

        // If the record is a phantom and the phantom updater is calling us
        // then proceed
        if (  !pname->objflag 
           && (dwFlags & EXTINT_UPDATE_PHANTOM) ) {

            DSNAME *pDNTmp=NULL;
            // We're adding a reference to a phantom which already exists,
            // and we were told to update the name if we need to

            // Simple test for changed name.  Get the DN of the object in
            // question and compare it to the string portion of the DN
            // passed in.  We do an exact byte-for-byte comparison to catch
            // case changes.  Note that we expect both names to be
            // "canonical", that is, both should be in the format returned
            // by sbTableGetDSName.  That's obviously true of pDNTmp.  At
            // the moment, only the stale phantom daemon or replication ever
            // writes this attribute, and they both ultimately get the value
            // via sbTableGetDSName.
            if(err=sbTableGetDSName(pDB, pname->DNT, &pDNTmp,0)) {
                return err;
            }
            if((pdnRef->NameLen != pDNTmp->NameLen) ||
               memcmp(pdnRef->StringName, pDNTmp->StringName,
                      pdnRef->NameLen * sizeof(WCHAR))) {
                err = sbTableUpdatePhantomName(pDB, pname,*pTag,
                                               pdnRef,
                                               pDNTmp);
                if(err) {
                    return err;
                }
                fProcessed = TRUE;
                
            }
            // ELSE
            //  The string name is the same.  Just pass it on through
            THFreeEx(pDB->pTHS, pDNTmp);
        }
            
        // If we have processed the reference and the object is a phantom
        // then enter
        // OR if this object is a subref, then enter so its sid can get updated.

        if (   ((!fProcessed) && (!pname->objflag))
            || (insttype & SUBREF) ) {

            if ( insttype & SUBREF ) {
                // If we are here becuase of a subref update, then only the
                // phantom cleanup task should be calling us
                Assert( (dwFlags & EXTINT_UPDATE_PHANTOM) )
            }

            if (pdnRef->SidLen) {
                // We're add-refing an existing phantom that already has a GUID.
                // Update its SID if it's different from that in the reference.
                
                if ((pname->SidLen != pdnRef->SidLen)
                    || memcmp(&pname->Sid, &pdnRef->Sid, pdnRef->SidLen)) {
                    // The phantom's SID is either absent (in which case we want
                    // to add the one from the reference) or different (in which
                    // case we want to make the assumption that the reference's
                    // SID is more recent and update the phantom's SID).
                    NT4SID sidRefInt;
                    
                    // Convert the SID from the reference into internal format.
                    memcpy(&sidRefInt, &pdnRef->Sid, pdnRef->SidLen);
                    InPlaceSwapSid(&sidRefInt);
                    
                    // Set currency.
                    DNread(pDB, *pTag, DN_READ_SET_CURRENCY);
                    
                    // Update the SID.
                    JetPrepareUpdateEx(pDB->JetSessID, pDB->JetSearchTbl,
                                       DS_JET_PREPARE_FOR_REPLACE);
                    
                    JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, sidid,
                                   &sidRefInt, pdnRef->SidLen, 0, NULL);
                    
                    JetUpdateEx(pDB->JetSessID, pDB->JetSearchTbl, NULL, 0, 0);
                    
                    // Reset entry in DN read cache.
                    dbFlushDNReadCache(pDB, *pTag);
                }
            }
        }

        if (0 == err) {
            DBAdjustRefCount(pDB, *pTag, 1 );

            DPRINT2(1, "Ref-counted \"%ls\" (@ DNT 0x%x) by GUID!\n",
                    pdnRef->StringName, *pTag);
        }
    }

    return err;
}

/*--------------------------------------------------------------------------- */
/*--------------------------------------------------------------------------- */
DWORD APIENTRY sbTableAddRef(DBPOS FAR *pDB,
                             DWORD dwFlags,
                             DSNAME *pNameArg,
                             ULONG *pTag)
/*++

Routine Description:

    Increment the ref count on a DN.  Creates the appropriate records for the
    various components of the name if they do not already exist.

Arguments:

    pDB (IN/OUT)

    dwFlags (IN) - 0 or EXTINT_NEW_OBJ_NAME or EXTINT_UPDATE_PHANTOM
        EXTINT_NEW_OBJ_NAME indicates that we're adding a refcount for a new, 
            instantiated object's name.
        EXTINT_UPDATE_PHANTOM indicates we want to update a phantom if found

    pNameArg (IN) - fully populated name of the phantom or object.

    pTag (OUT) - on return, holds the DNT of the record written (i.e., the
        record corresponding to the given DN).

Return Values:

    0 on success, non-zero on failure.

--*/
{
    THSTATE         *pTHS=pDB->pTHS;
    d_tagname        *tagarray;
    unsigned int     partno, i;
    ATTRBLOCK        *pBlockName;
    DWORD            code;
    BOOL             fNameHasGuid;
    BOOL             fRetry;
    DSNAME *         pName = pNameArg;
    DWORD           *pAncestors=NULL;
    DWORD            cAncestors=0;
    DWORD            cAncestorsAllocated;
    
    DPRINT(2, "sbTableAddRef entered\n");

    Assert(VALID_DBPOS(pDB));

    fNameHasGuid = !fNullUuid( &pName->Guid );

    // Attempt to ref-count record by GUID first.
    if (fNameHasGuid) {

        code = sbTableAddRefByGuid(pDB, dwFlags, pName, pTag);

        if (!code) {
            // Successfully ref-counted by GUID!
            return 0;
        }
    }

    // No guid in DN or guid was not found in the database.

    DPRINT1(1, "Ref-counting \"%ls\" by string name.\n", pName->StringName);

    code = sbTableGetTagFromStringName(pDB,
                                       pDB->JetSearchTbl,
                                       pName,
                                       TRUE,
                                       FALSE,
                                       dwFlags,
                                       pTag,
                                       NULL,
                                       NULL);
    
    return code;

}


/*

Routine Description:
    This routine resets the RDN.  Note that since the RDN has become a normal
    attribute, one could reset the RDN through normal DBSetAttVal calls.
    However, this routine was created to reset the RDN and give us a place to
    hang code to update the DNReadCache as necessary.

Arguments:
    pAVal - An attrval that we will use the first value of as the new RDN

Return Values:
    Returns 0 if all went well.  Currently, only 0 is returned.  Note that if
    the JetSetColumnEx fails, an exception is thrown.

*/
DWORD
DBResetRDN (
        DBPOS *pDB,
        ATTRVAL *pAVal
        )
{
    ATTCACHE * pAC;

    Assert(VALID_DBPOS(pDB));

    dbInitRec(pDB);

    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, rdnid,
                   pAVal->pVal,
                   pAVal->valLen, 0, NULL);

    // Touch replication meta data for this attribute.
    pAC = SCGetAttById(pDB->pTHS, ATT_RDN);
    // prefix complains about pAC being NULL, 447340, bogus since we are using constant
    Assert(pAC != NULL);
    DBTouchMetaData(pDB, pAC);

    pDB->fFlushCacheOnUpdate = TRUE;

    return 0;
}


DB_ERR
DBMangleRDN(
    IN OUT  DBPOS * pDB,
    IN      GUID *  pGuid
    )
/*++

Routine Description:

    Mangle the name of the current record to avoid name conflicts.

    Currently designed to work only for phantoms.

Arguments:

    pDB (IN/OUT)
    pGuid (IN) - guid of the record.

Return Values:

    0 on success, DB_ERR_* on failure.

--*/
{
    GUID    guid;
    WCHAR   szRDN[ MAX_RDN_SIZE ];
    DWORD   cchRDN;
    DWORD   cb;
    DB_ERR  err;
    ATTRVAL AValNewRDN;

    Assert(VALID_DBPOS(pDB));

    // We currently only mangle the ATT_RDN; to handle objects, we'd also need
    // to mangle the value of the class-specific RDN attribute.
    Assert(!DBCheckObj(pDB));

    err = DBGetSingleValue(pDB, ATT_RDN, szRDN, sizeof(szRDN), &cb);
    Assert(!err);

    // prefix complains about cb unassigned,  447348, bogus
    cchRDN = cb / sizeof(WCHAR);

    MangleRDN(MANGLE_PHANTOM_RDN_FOR_NAME_CONFLICT, pGuid, szRDN, &cchRDN);

    AValNewRDN.valLen = cchRDN * sizeof(WCHAR);
    AValNewRDN.pVal   = (BYTE *) szRDN;

    return DBResetRDN(pDB, &AValNewRDN);
}


DWORD
DBResetParent(
    DBPOS *pDB,
    DSNAME *pNewParentName,
    ULONG ulFlags
    )

/*++

Routine Description:

    This routine resets an object's parent, decrements the reference count
    on the original parent, and increments the count on the new parent.

Arguments:

    pDB - Pointer, current position in the database table, points to the
        record of the source object (of the move).

    pNewParentName - Pointer, DS name of the destination parent.

    ulFlags - 0 or DBRESETPARENT_CreatePhantomParent (indicates a phantom
        parent should be created if the new parent doesn't exist.

Return Value:

    This routine returns zero if successful, otherwise a DS error code is
    returned.

--*/

{
    THSTATE *pTHS = pDB->pTHS;
    DBPOS *pDBTemp = NULL;
    DWORD *pdwParentDNT = 0;
    DWORD dwParentDNT = 0;
    DWORD dwStatus = 1;
    DWORD dwLength = 0;
    JET_ERR JetErr = 0;
    BOOL fCommit = FALSE;
    d_memname *pname=NULL;
    DWORD     *pAncestors=NULL;
    DWORD      cAncestors = 0;
    ATTCACHE  *pAC;
    DWORD     *pOldAncestors, cOldAncestors, cbOldAncestorsBuff;

    Assert(VALID_DBPOS(pDB));

    // Find the DNT of the new parent name, using a temporary DBPOS so that
    // cursor position associated with pDB is not changed. IsCrossDomain is
    // TRUE when the pNewParentName is in a different domain. It is set to
    // FALSE when simply moving an object within the same domain. Note that
    // in the first release of the product, cross NC moves within the same
    // domain are handled by the LocalModifyDN case (IsCrossDomain == FALSE)
    // while cross NC moves across domains is handled by the RemoteAdd case
    // (IsCrossDomain == TRUE).

    dbInitRec(pDB);

    DBOpen(&pDBTemp);

    __try
    {
     if ( DBRESETPARENT_SetNullNCDNT & ulFlags)
        {
            // The caller wanted the NCDNT to be set to NULL.
            DBResetAtt(pDB,
                       FIXED_ATT_NCDNT,
                       0,
                       NULL,
                       SYNTAX_INTEGER_TYPE);
        }
#if DBG
        else
        {
            // Either the object has no NCDNT, or we are moving within an NCDNT,
            // right?
            DWORD err;
            DWORD ulTempDNT;
            DWORD actuallen;
            
            err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                           pDB->JetObjTbl,
                                           ncdntid,
                                           &ulTempDNT,
                                           sizeof(ulTempDNT),
                                           &actuallen,
                                           JET_bitRetrieveCopy,
                                           NULL);
            
            Assert((err == JET_wrnColumnNull) ||
                   (!err && pDB->NCDNT == ulTempDNT));
        }
#endif

        // In the !cross-domain move case we expect the new parent
        // to exist so we just DBFindDSName to it.  In the cross-domain
        // move case we want the parent to be created as a phantom if it
        // doesn't exist so we leverage that side effect of ExtIntDist.

        if ( DBRESETPARENT_CreatePhantomParent & ulFlags )
        {
            dwStatus = ExtIntDist(pDB,
                                DBSYN_ADD,
                                pNewParentName->structLen,
                                (PUCHAR)(pNewParentName),
                                &dwLength,
                                (UCHAR **)&pdwParentDNT,
                                pDB->DNT,
                                pDB->JetObjTbl,
                                0);
        }
        else
        {
            dwStatus = DBFindDSName(pDBTemp, pNewParentName);
            Assert(0 == dwStatus);

            if ( 0 == dwStatus )
            {
                dwParentDNT = (pDBTemp->DNT);
                pdwParentDNT = &dwParentDNT;
            }
        }

        if ( 0 == dwStatus )
        {
            // Reset the object's Ancestors to the value of the new parent's
            // ancestors with the DNT of the object concatenated.
            pname = DNread(pDB, *pdwParentDNT, 0);

            // get the previous ancestry. needed for notifications
            //
            cbOldAncestorsBuff = sizeof(DWORD) * 12;
            pOldAncestors = THAllocEx(pDB->pTHS, cbOldAncestorsBuff);
            DBGetAncestors(pDB,
                           &cbOldAncestorsBuff,
                           &pOldAncestors,
                           &cOldAncestors);

            
            cAncestors = pname->cAncestors + 1;
            pAncestors = THAllocEx(pTHS,cAncestors * sizeof(DWORD));
            memcpy(pAncestors, pname->pAncestors,
                   pname->cAncestors * sizeof(DWORD));
            pAncestors[cAncestors - 1] = pDB->DNT;

            JetErr = JetSetColumnEx(pDB->JetSessID,
                                    pDB->JetObjTbl,
                                    ancestorsid,
                                    pAncestors,
                                    cAncestors * sizeof(DWORD),
                                    0,
                                    NULL);

            if(0 == JetErr) {
                JetErr = JetSetColumnEx(pDB->JetSessID,
                                        pDB->JetObjTbl,
                                        pdntid,
                                        pdwParentDNT,
                                        sizeof(dwParentDNT),
                                        0,
                                        NULL);
            }
            
            if (0 == JetErr)
            {
                DBEnqueueSDPropagation (pDB, FALSE);
                
                pDB->fFlushCacheOnUpdate = TRUE;

                if ( DBRESETPARENT_CreatePhantomParent & ulFlags )
                {
                    // The reference count on the new parent was incremented
                    // by ExtIntDist, so do not increment it again here.
                    NULL;
                }
                else
                {
                    // Adjust the refcount on the new parent.
                    DBAdjustRefCount(pDB, pDBTemp->DNT, 1);
                }

                // Adjust the refcount on the original parent.
                DBAdjustRefCount(pDB, pDB->PDNT, -1);

                dwStatus = 0;
                fCommit = TRUE;
            }
        }
     
        if ( 0 == dwStatus )
        {
            dbTrackModifiedDNTsForTransaction(
                    pDB,
                    pDB->NCDNT,
                    cOldAncestors,
                    pOldAncestors,
                    TRUE,
                    (( DBRESETPARENT_CreatePhantomParent & ulFlags ) ?
                     MODIFIED_OBJ_intersite_move :
                     MODIFIED_OBJ_intrasite_move));
            
        }
    }
    __finally
    {
        DBClose(pDBTemp, fCommit);
        if (pAncestors) {
            THFreeEx(pTHS,pAncestors);
        }
    }

    // Touch replication meta data for ATT_RDN, which signals to replication
    // that this object has been renamed (new parent, new RDN, or both).
    pAC = SCGetAttById(pDB->pTHS, ATT_RDN);
    // prefix complains about pAC being NULL, 447341, bogus since we are using constant
    Assert(pAC != NULL);
    DBTouchMetaData(pDB, pAC);

    return(dwStatus);
}

DWORD
DBResetParentByDNT(
        DBPOS *pDB,
        DWORD dwParentDNT,
        BOOL  fTouchMetadata

    )

/*++

Routine Description:

    This routine resets an object's parent, decrements the reference count
    on the original parent, and increments the count on the new parent.  Unlike
    DBResetParent, it takes a DNT.

Arguments:

    pDB - Pointer, current position in the database table, points to the
        record of the source object (of the move).

    dwParentDNT - Pointer, DS name of the destination parent.
    
    fTouchMetadata - whether this function should touch the replication 
                     metadata of the object.

Return Value:

    This routine returns zero if successful, otherwise a DS error code is
    returned.

--*/

{
    JET_ERR    err = 0;
    d_memname *pname=NULL;
    DWORD     *pAncestors=NULL;
    DWORD      cAncestors = 0;
    ATTCACHE  *pAC;
    DWORD      ulTempDNT, actuallen;
    DWORD     *pOldAncestors, cOldAncestors, cbOldAncestorsBuff;
    
    Assert(VALID_DBPOS(pDB));

    // We're already inside an update, right?  LocalDelete should take care of
    // this. 
    Assert(pDB->JetRetrieveBits == JET_bitRetrieveCopy);

    // We aren't trying to move objects to be under the root, right?
    Assert(dwParentDNT != ROOTTAG);

    // We should already be flushing the cache for the current
    // object. 
    Assert(pDB->fFlushCacheOnUpdate);
            

    if(dwParentDNT == pDB->PDNT) {
        // already there.
        return 0;
    }

    cbOldAncestorsBuff = sizeof(DWORD) * 12;
    pOldAncestors = THAllocEx(pDB->pTHS, cbOldAncestorsBuff);
    DBGetAncestors(pDB,
                   &cbOldAncestorsBuff,
                   &pOldAncestors,
                   &cOldAncestors);

    // Find the new parent name by DNT, using a the search table on the DBPOS
    // so that cursor position associated with pDB is not changed. This routine
    // should only be called to move objects within an NC.
    JetSetCurrentIndex4Success(pDB->JetSessID,
                               pDB->JetSearchTbl,
                               SZDNTINDEX,
                               &idxDnt,
                               0);
    
    JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl,
                 &dwParentDNT, sizeof(dwParentDNT), JET_bitNewKey);
    
    if (JetSeekEx(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekEQ)) {
        return DIRERR_OBJ_NOT_FOUND;
    }

#if DBG
    // We're moving inside a NC, right?
    JetRetrieveColumnSuccess(pDB->JetSessID,
                             pDB->JetSearchTbl,
                             ncdntid,
                             &ulTempDNT,
                             sizeof(ulTempDNT),
                             &actuallen,
                             JET_bitRetrieveCopy,
                             NULL);

    Assert(pDB->NCDNT == ulTempDNT);
#endif    

    // OK we found the new parent.  Reset the object's Ancestors to the value of
    // the new parent's ancestors with the DNT of the object concatenated.
    pname = DNread(pDB, dwParentDNT, 0);
    cAncestors = pname->cAncestors + 1;
    // Don't use alloca, they might have a huge number of ancestors.
    pAncestors = THAllocEx(pDB->pTHS, cAncestors * sizeof(DWORD));
    memcpy(pAncestors, pname->pAncestors,
           pname->cAncestors * sizeof(DWORD));
    pAncestors[cAncestors - 1] = pDB->DNT;
    
    err = JetSetColumnEx(pDB->JetSessID,
                         pDB->JetObjTbl,
                         ancestorsid,
                         pAncestors,
                         cAncestors * sizeof(DWORD),
                         0,
                         NULL);
    
    THFreeEx(pDB->pTHS, pAncestors);
    
    if(err) {
        return DIRERR_UNKNOWN_ERROR;
    }
    
    if(JetSetColumnEx(pDB->JetSessID,
                      pDB->JetObjTbl,
                      pdntid,
                      &dwParentDNT,
                      sizeof(dwParentDNT),
                      0,
                      NULL)) {
        return DIRERR_UNKNOWN_ERROR;
    }
    
    // Now, see if there are any children.  Usually, there won't be.
    // But it is possible, and if there are, we have to enqueue an SD
    // propagation.
    JetSetCurrentIndex4Success(pDB->JetSessID,
                               pDB->JetSearchTbl,
                               SZPDNTINDEX,
                               &idxPdnt,
                               0);
    
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetSearchTbl,
                 &pDB->DNT,
                 sizeof(pDB->DNT),
                 JET_bitNewKey);
    
    switch(JetSeek(pDB->JetSessID,
                   pDB->JetSearchTbl,
                   JET_bitSeekGE)) {
    case 0:
        // Huh?  we should have at least gotten a wrn not equal.
        Assert(FALSE && "Seek equal on a JET_bitSeekGE?");
        // fall through.
    case  JET_wrnRecordFoundGreater:
        // We're on something.  See if it's the correct thing.  Get the
        // PDNT .
        JetRetrieveColumnSuccess(pDB->JetSessID,
                                 pDB->JetSearchTbl,
                                 pdntid,
                                 &ulTempDNT,
                                 sizeof(ulTempDNT),
                                 &actuallen,
                                 JET_bitRetrieveCopy,
                                 NULL);                
        
        
        if(ulTempDNT == pDB->DNT) {
            // Object has children.
            DBEnqueueSDPropagation (pDB, FALSE);
        }
        break;
    default:
        // Apparantly, no children.
        break;
    }

    
    // Cool.  We reset the PDNT and the Ancestors on the object
    // in question, and enqueued an SD propagation if we had to.
    
    
    // Adjust the refcount on the new parent.
    DBAdjustRefCount(pDB, dwParentDNT, 1);
    
    // Adjust the refcount on the original parent.
    DBAdjustRefCount(pDB, pDB->PDNT, -1);
    
    dbTrackModifiedDNTsForTransaction(
            pDB,
            pDB->NCDNT,
            cOldAncestors,
            pOldAncestors,
            TRUE,
            MODIFIED_OBJ_intrasite_move);
    

    // Touch replication meta data for ATT_RDN, which signals to replication
    // that this object has been renamed (new parent, new RDN, or both).
    if (fTouchMetadata) {
        pAC = SCGetAttById(pDB->pTHS, ATT_RDN);
        Assert(pAC != NULL);
        // prefix complains about pAC being NULL, 447342, bogus since we are using constant

        DBTouchMetaData(pDB, pAC);
    }

    return 0;
}


ULONG
DBResetDN(
    IN  DBPOS *     pDB,
    IN  DSNAME *    pParentDN,
    IN  ATTRVAL *   pAttrValRDN
    )
/*++

Routine Description:

    Reset the DN of the record (phantom or object) to that given.

    Note that we assume the RDN type (e.g., CN, DC, OU, ...) is unchanged,
    though this could easily be remedied if needed.

Arguments:

    pDB (IN) - Has currency on the record for which the DN is to be reset.

    pParentDN (IN) - DSNAME of the record's new parent.

    pAttrRDN (IN) - The record's new RDN (or NULL to leave RDN as-is).

Return Values:

    0 - Success.

--*/
{
    THSTATE     *pTHS = pDB->pTHS;
    JET_ERR     JetErr = 0;
    d_memname * pname=NULL;
    DWORD *     pAncestors=NULL;
    DWORD       cAncestors = 0;
    ATTCACHE *  pAC;
    BOOL        fIsObject;
    ULONG       PDNT;
    ULONG       dbError;

    // Prepare for update if we haven't already done so.
    dbInitRec(pDB);

    dbError = sbTableGetTagFromDSName(pDB, pParentDN, 0, &PDNT, &pname);
    if (dbError && (ERROR_DS_NOT_AN_OBJECT != dbError)) {
        return dbError;
    }

    if (pname) {
        // The 99%+ case - the parent is not ROOT

        // Reset the object's Ancestors to the value of the new parents
        // ancestors with the DNT of the object concatenated.
        cAncestors = pname->cAncestors + 1;
        pAncestors = THAllocEx(pTHS, cAncestors * sizeof(DWORD));
        memcpy(pAncestors,
               pname->pAncestors,
               pname->cAncestors * sizeof(DWORD));
        pAncestors[cAncestors - 1] = pDB->DNT;
    }
    else {
        Assert(IsRoot(pParentDN));

        cAncestors = 2;
        pAncestors = THAllocEx(pTHS,cAncestors * sizeof(DWORD));
        pAncestors[0] = ROOTTAG;
        pAncestors[1] = pDB->DNT;
    }

    fIsObject = DBCheckObj(pDB);

    JetErr = JetSetColumnEx(pDB->JetSessID,
                            pDB->JetObjTbl,
                            ancestorsid,
                            pAncestors,
                            cAncestors * sizeof(DWORD),
                            0,
                            NULL);
    Assert(0 == JetErr);

    THFreeEx(pTHS,pAncestors);

    if (0 == JetErr) {
        // Reset PDNT.
        JetErr = JetSetColumnEx(pDB->JetSessID,
                                pDB->JetObjTbl,
                                pdntid,
                                &PDNT,
                                sizeof(PDNT),
                                0,
                                NULL);
        Assert(0 == JetErr);
    }

    if ((0 == JetErr) && (NULL != pAttrValRDN)) {
        // Reset RDN.
        JetErr = JetSetColumnEx(pDB->JetSessID,
                                pDB->JetObjTbl,
                                rdnid,
                                pAttrValRDN->pVal,
                                pAttrValRDN->valLen,
                                0,
                                NULL);

        if ((0 == JetErr) && fIsObject) {
            // Touch replication meta data for this attribute.
            pAC = SCGetAttById(pDB->pTHS, ATT_RDN);
            Assert(pAC != NULL);
            DBTouchMetaData(pDB, pAC);
        }
    }

    if (0 == JetErr) {
        if (fIsObject) {
            DBEnqueueSDPropagation(pDB, FALSE);
        }
        
        pDB->fFlushCacheOnUpdate = TRUE;

        // Adjust the refcount on the new parent.
        DBAdjustRefCount(pDB, PDNT, 1);

        // Adjust the refcount on the original parent.
        DBAdjustRefCount(pDB, pDB->PDNT, -1);

        pDB->PDNT = PDNT;
    }

    return JetErr ? DB_ERR_SYSERROR : 0;
}


void
DBCoalescePhantoms(
    IN OUT  DBPOS * pDB,
    IN      ULONG   dntRefPhantom,
    IN      ULONG   dntStructPhantom
    )
/*++

Routine Description:

    Collapses references to dntStructPhantom to dntRefPhantom as follows:
    
    (1) moves all children of dntStructPhantom to be children of dntRefPhantom
    (2) asserts that, with the pending escrowed update ref count changes,
        dntStructPhantom has no further references
    (3) generates a guid G and mangles dntStructPhantom from its original
        string name S to its new string name mangle(S, G)
    (4) renames dntRefPhantom to S
    
    Note that step (3) violates the general rule that you can always unmangle
    a mangled RDN to produce its objectGuid, as in this case we don't have the
    objectGuid with which to mangle the name (since it's a structural phantom,
    which by definition has no guid).  However, following this routine
    dntStructPhantom will have no remaining references and therefore these
    semantics are no longer important.
    
    One might declare that instead of renaming dntStructPhantom we could simply
    delete its record, but in the case of gamma rays causing the above refcount
    assertion to fail, it's far better not to have references to DNTs that no
    longer exist and instead opt to allow them to expire through normal garbage
    collection.
    
    This routine is intended to be invoked when an existing GUIDed phantom needs
    its string name changed, but that string name is already occupied by an
    existing phantom with no GUID.

Arguments:

    pDB (IN/OUT)

    dntRefPhantom (IN) - On successful return, acquires the string name of
        dntStructPhantom and receives all of dntStructPhantom's children.

    dntStructPhantom (IN) - On successful return, has no remaining references
        and is name munged, quietly awaiting its garbage collection.

Return Values:

    None.  Throws exception on catastrophic failure.

--*/
{
    DWORD   err;
    DWORD   cbAncestorsSize = 0;
    DWORD * pdntAncestors = NULL;
    DWORD   cNumAncestors = 0;
    int     cNumChildren = 0;
    GUID    guid;
    WCHAR   rgwchRDN[MAX_RDN_SIZE];
    DWORD   cbRDN;
    ATTRTYP rdnType;
    DWORD   cbActual;
    DWORD   DNT;
    DWORD   PDNT;
#if DBG
    DWORD   cnt;
#endif

    //
    // Move all children of dntStructPhantom to be children of dntRefPhantom.
    //

    // Retrieve the ancestors of dntStructPhantom.
    if (err = DBFindDNT(pDB, dntStructPhantom)) {
        DsaExcept(DSA_DB_EXCEPTION, err, dntStructPhantom);
    }

    Assert(!DBCheckObj(pDB));
    Assert(!DBHasValues(pDB, ATT_OBJECT_GUID));

    if ((err = DBGetSingleValue(pDB, ATT_RDN, rgwchRDN,
                                sizeof(rgwchRDN), &cbRDN))
        || (err = DBGetSingleValue(pDB, FIXED_ATT_RDN_TYPE, &rdnType,
                                   sizeof(rdnType), NULL))) {
        DsaExcept(DSA_DB_EXCEPTION, err, dntStructPhantom);
    }

#if DBG
    JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, cntid,
                             &cnt, sizeof(cnt), &cbActual, 0, NULL);
#endif

    dbGetAncestorsSlowly(pDB, pDB->DNT, &cbAncestorsSize, &pdntAncestors, &cNumAncestors);
    if (cNumAncestors < 2) {
        // Can't replace root!
        DsaExcept(DSA_DB_EXCEPTION, DIRERR_INTERNAL_FAILURE, dntStructPhantom);
    }

    if (cbAncestorsSize < (cNumAncestors + 1) * sizeof(*pdntAncestors)) {
        // Make room for an additional DNT at the end of the ancestors list.
        cbAncestorsSize = (cNumAncestors + 1) * sizeof(*pdntAncestors);
        pdntAncestors = THReAllocEx(pDB->pTHS, pdntAncestors, cbAncestorsSize);
    }

    Assert(pdntAncestors[cNumAncestors-1] == dntStructPhantom);
    pdntAncestors[cNumAncestors-1] = dntRefPhantom;

    JetSetCurrentIndex4Success(pDB->JetSessID,
                               pDB->JetSearchTbl,
                               SZPDNTINDEX,
                               &idxPdnt,
                               0);
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetSearchTbl,
                 &dntStructPhantom,
                 sizeof(dntStructPhantom),
                 JET_bitNewKey);
    
    err = JetSeekEx(pDB->JetSessID, pDB->JetSearchTbl, JET_bitSeekGE);
    if (JET_wrnSeekNotEqual == err) {
        err = 0;
    }

    while (0 == err) {
        JetRetrieveColumnSuccess(pDB->JetSessID,
                                 pDB->JetSearchTbl,
                                 pdntid,
                                 &PDNT,
                                 sizeof(PDNT),
                                 &cbActual,
                                 JET_bitRetrieveFromIndex,
                                 NULL);
        if (PDNT != dntStructPhantom) {
            // No more children.
            break;
        }

        // Found a direct child of dntStructPhantom.  Reset its PDNT & ancestors
        // to make it a child of dntRefPhantom.
        JetRetrieveColumnSuccess(pDB->JetSessID,
                                 pDB->JetSearchTbl,
                                 dntid,
                                 &DNT,
                                 sizeof(DNT),
                                 &cbActual,
                                 0,
                                 NULL);
        pdntAncestors[cNumAncestors] = DNT;

        JetPrepareUpdateEx(pDB->JetSessID,
                           pDB->JetSearchTbl,
                           DS_JET_PREPARE_FOR_REPLACE);

        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, ancestorsid,
                       pdntAncestors,
                       (cNumAncestors + 1) * sizeof(*pdntAncestors), 0, NULL);
        
        JetSetColumnEx(pDB->JetSessID, pDB->JetSearchTbl, pdntid,
                       &dntRefPhantom, sizeof(dntRefPhantom), 0, NULL);

        JetUpdateEx(pDB->JetSessID, pDB->JetSearchTbl, NULL, 0, 0);
        dbFlushDNReadCache(pDB, DNT);

        cNumChildren++;
        
        // Move on to next (potential) child.
        err = JetMove(pDB->JetSessID, pDB->JetSearchTbl, JET_MoveNext, 0);
    }
    
    // Adjust refcounts.
    if (cNumChildren) {
        DBAdjustRefCount(pDB, dntRefPhantom, cNumChildren);
        DBAdjustRefCount(pDB, dntStructPhantom, -cNumChildren);
    }

    
    //
    // Assert that, with the pending escrowed update ref count changes,
    // dntStructPhantom has no further references.
    //

    Assert(cnt == (DWORD) cNumChildren);

    
    //
    // Generate a guid G and mangle dntStructPhantom from its original string
    // name S to its new string name mangle(S, G).
    //

    DsUuidCreate(&guid);
    Assert(pDB->DNT == dntStructPhantom);
    if ((err = DBMangleRDN(pDB, &guid))
        || (err = DBUpdateRec(pDB))) {
        DsaExcept(DSA_DB_EXCEPTION, err, dntStructPhantom);
    }
     
    
    //
    // Rename dntRefPhantom to S.
    //

    if (err = DBFindDNT(pDB, dntRefPhantom)) {
        DsaExcept(DSA_DB_EXCEPTION, err, dntRefPhantom);
    }

    Assert(!DBCheckObj(pDB));
    Assert(DBHasValues(pDB, ATT_OBJECT_GUID));

    JetPrepareUpdateEx(pDB->JetSessID,
                       pDB->JetObjTbl,
                       DS_JET_PREPARE_FOR_REPLACE);

    // Ancestors.
    Assert(pdntAncestors[cNumAncestors-1] == dntRefPhantom);
    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, ancestorsid,
                   pdntAncestors, cNumAncestors * sizeof(*pdntAncestors),
                   0, NULL);
    
    // PDNT.
    JetSetColumnEx(pDB->JetSessID,
                   pDB->JetObjTbl,
                   pdntid,
                   &pdntAncestors[cNumAncestors-2],
                   sizeof(pdntAncestors[cNumAncestors-2]),
                   0,
                   NULL);

    // RDN.
    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, rdnid,
                   rgwchRDN, cbRDN, 0, NULL);

    // RDN type.
    // The rdnType is stored in the DIT as the msDS_IntId, not the
    // attributeId. This means an object retains its birth name
    // even if unforeseen circumstances allow the attributeId
    // to be reused. No need to convert here because rdnType
    // was read from the DIT above.
    JetSetColumnEx(pDB->JetSessID, pDB->JetObjTbl, rdntypid,
                   &rdnType, sizeof(rdnType), 0, NULL);

    JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);
    dbFlushDNReadCache(pDB, dntRefPhantom);

    // Enqueue a propagation to ensure that all descendants of dntRefPhantom
    // get their ancestors column properly updated.
    DBEnqueueSDPropagation(pDB, FALSE);

    THFreeEx(pDB->pTHS, pdntAncestors);

#ifdef INCLUDE_UNIT_TESTS
    // Test hook for refcount test.
    gLastGuidUsedToCoalescePhantoms = guid;
#endif
}

#ifdef INCLUDE_UNIT_TESTS
void
AncestorsTest(
        )
{
    THSTATE   *pTHS = pTHStls;
    DBPOS     *pDB;
    DWORD      ThisDNT, ThisPDNT, cThisAncestors, cParentAncestors;
    DWORD      pThisAncestors[500], pParentAncestors[500];
    DWORD      cbActual;
    d_memname *pname;
    DWORD      err, i, count=0;
    wchar_t    NameBuff[512];
    
    DPRINT(0, "Beginning Ancestors test\n");
    DBOpen2(TRUE, &pTHS->pDB);
    __try {
        pDB = pTHS->pDB;
        
        // Walk the DNT index, get the ancestors of each object, get the
        // parent's ancestors, check em.
        JetSetCurrentIndex4Success(pDB->JetSessID,
                                   pDB->JetObjTbl,
                                   SZDNTINDEX,
                                   &idxDnt,
                                   0);
        
        err = JetMoveEx(pDB->JetSessID, pDB->JetObjTbl, JET_MoveFirst, 0);
        
        while(!err) {
            count++;
            if(!(count % 100)) {
                DPRINT2(0,
                        "Ancestors test, current DNT = %X, iteration = %d\n",
                        ThisDNT, count);
            }
            
            // Get the ancestors, the dnt, and the pdnt
            err = JetRetrieveColumn(pDB->JetSessID,
                                    pDB->JetObjTbl,
                                    dntid,
                                    &ThisDNT,
                                    sizeof(ThisDNT),
                                    &cbActual,
                                    0,
                                    NULL);
            if(err) {
                DPRINT2(0, "Failed to get DNT, %X (last DNT was %X)\n", err,
                        ThisDNT);
                goto move;
            }

            if(ThisDNT == 1) {
                // DNT 1 has no PDNT or ancestors
                goto move;
            }
            
            err = JetRetrieveColumn(pDB->JetSessID,
                                    pDB->JetObjTbl,
                                    pdntid,
                                    &ThisPDNT,
                                    sizeof(ThisPDNT),
                                    &cbActual,
                                    0,
                                    NULL);
            if(err) {
                DPRINT2(0, "(%X), Failed to get PDNT, %X\n", ThisDNT,err);
                goto move;
            }
            err = JetRetrieveColumn(pDB->JetSessID,
                                    pDB->JetObjTbl,
                                    ancestorsid,
                                    pThisAncestors,
                                    500 * sizeof(DWORD),
                                    &cbActual,
                                    0,
                                    NULL);
            if(err) {
                DPRINT2(0, "(%X), Failed to get ancestors, %X\n", ThisDNT,err);
                goto move;
            }
            cThisAncestors = cbActual /sizeof(DWORD);
            
            pname = DNread(pDB, ThisDNT, 0);
            memset(NameBuff, 0, sizeof(NameBuff));
            memcpy(NameBuff, pname->tag.pRdn, pname->tag.cbRdn);
            
            // First, make sure that the DNread cache has the correct info
            if(pname->cAncestors != cThisAncestors) {
                DPRINT1(0,"RDN = %S\n",NameBuff);
                DPRINT3(0, "DNT %X, count of ancestors from disk (%d) != "
                        "from DNread cache (%d).\n", ThisDNT,
                        cThisAncestors, pname->cAncestors );
                for(i=0;i<min(cThisAncestors, pname->cAncestors);i++) {
                    DPRINT2(0, "Disk-%X, Cache-%X.\n", pThisAncestors[i],
                            pname->pAncestors[i]);
                }
                goto move;
            }
            if(memcmp(pname->pAncestors, pThisAncestors, cbActual)) {
                DPRINT1(0,"RDN = %S\n",NameBuff);
                DPRINT1(0,"DNT %X, ancestors from disk != from DNread cache.\n",
                        ThisDNT);
                for(i=0;i<cThisAncestors;i++) {
                    DPRINT2(0, "Disk-%X, Cache-%X.\n", pThisAncestors[i],
                            pname->pAncestors[i]);
                }
                goto move;
            }
            if(pThisAncestors[cThisAncestors - 1] != ThisDNT) {
                DPRINT1(0,"RDN = %S\n",NameBuff);
                DPRINT3(0, "DNT %X, final ancestor (%X) != DNT (%X).\n",
                        ThisDNT, pThisAncestors[cThisAncestors - 1], ThisPDNT);
                goto move;
            }

            if(ThisDNT == ROOTTAG) {
                // ROOTTAG should have 1 ancestor, itself.  It has no parent, so
                // verify the ancestors and then  skip the rest of the
                // test.
                if((cThisAncestors != 1) || (pThisAncestors[0] != ROOTTAG)) {
                    DPRINT1(0,"RDN = %S\n",NameBuff);
                    DPRINT1(0,
                            "Root has wrong ancestors count (%d) or val.\n",
                            cThisAncestors);
                    for(i=0;i<cThisAncestors;i++) {
                        DPRINT1(0, "Ancestors, -%X.\n", pThisAncestors[i]);
                    }
                }
                    
                goto move;
            }
            

            // OK, now find the parent and get it's ancestors
            if(err = JetSetCurrentIndex4Warnings(pDB->JetSessID,
                                                 pDB->JetSearchTbl,
                                                 SZDNTINDEX,
                                                 &idxDnt,
                                                 0)) {
                DPRINT2(0, "(%X), couldn't set search table to dntindex, %X.\n",
                        ThisDNT, err);
                goto move;
            }

            
            JetMakeKeyEx(pDB->JetSessID, pDB->JetSearchTbl, 
                         &ThisPDNT, sizeof(ThisPDNT), JET_bitNewKey);
            
            if (err = JetSeekEx(pDB->JetSessID,
                                pDB->JetSearchTbl, JET_bitSeekEQ)) {
                if(err) {
                    DPRINT3(0, "(%X), Failed to move to (%X), %X\n",
                            ThisDNT,ThisPDNT, err);
                    goto move;
                }
                // Huh? couldn't find it.
            }
            
            err = JetRetrieveColumn(pDB->JetSessID,
                                    pDB->JetSearchTbl,
                                    ancestorsid,
                                    pParentAncestors,
                                    100 * sizeof(DWORD),
                                    &cbActual,
                                    0,
                                    NULL);
            cParentAncestors = cbActual /sizeof(DWORD);
            if(err) {
                if(ThisPDNT == ROOTTAG) {
                    // This is ok.
                }
                else {
                    DPRINT2(0, "PDNT (%X), Failed to get ancestors, %X\n",
                            ThisPDNT,err);
                    goto move;
                }
            }
                
            
            if(cParentAncestors + 1 != cThisAncestors) {
                DPRINT1(0,"RDN = %S\n",NameBuff);
                DPRINT4(0,
                        "DNT %X, anc. size (%d) !=PDNT %X, anc. size (%d) +1\n",
                        ThisDNT, cThisAncestors, ThisPDNT, cParentAncestors);
                if(!memcmp(
                        pParentAncestors,pThisAncestors,
                        min(cThisAncestors,cParentAncestors) * sizeof(DWORD))) {
                    DPRINT(0,"Value equal through lesser count.\n");
                }
                else {
                    for(i=0;i<(min(cThisAncestors,cParentAncestors));i++) {
                        DPRINT2(0, "This-%X, Parent-%X.\n", pThisAncestors[i],
                                pParentAncestors[i]);
                    }
                }
                goto move;
            }
            if(memcmp(pParentAncestors, pThisAncestors, cbActual)) {
                DPRINT1(0,"RDN = %S\n",NameBuff);
                DPRINT1(0,
                        "DNT %X, ancestors != parents ancestors + PDNT.\n",
                        ThisDNT); 
                for(i=0;i<cParentAncestors;i++) {
                    DPRINT2(0, "This-%X, Parent-%X.\n", pThisAncestors[i],
                            pParentAncestors[i]);
                }
                goto move;
            }
             
        move:
            err = JetMoveEx(pDB->JetSessID, pDB->JetObjTbl, JET_MoveNext, 0);
        }
    }
    __finally {
        DBClose(pTHS->pDB, TRUE);
    }

    DPRINT(0, "Completed Ancestors test\n");
    return;
}
        
#endif
 

DWORD
DBFindChildAnyRDNType (
        DBPOS *pDB,
        DWORD PDNT,
        WCHAR *pRDN,
        DWORD ccRDN
        )
/*++
  Description:
      Find a child of the DNT passed in that uses the RDN specified, ignoring
      RDN type.

  Parameters:      
      pDB   - dbpos to use
      pDNT  - the DNT of the proposed parent
      pRDN  - pointer to the RDN value we're looking for
      ccRDN - number of characters in pRDN

  Return:
      0 if we found the object requested.  Currency is placed on this object.

      ERROR_DS_NOT_AN_OBJECT if we found the object requested but it wasn't an
        object.  In this case, we put currency on the phantom found.

      ERROR_DS_KEY_NOT_UNIQUE if we didn't find an object with the requested
        name, but did find an object with the same key in the PDNT-RDN index.
        In this case, we put currency on the object found.

      ERROR_DS_OBJ_NOT_FOUND if we couldn't find anything with that name or that
        key. 

      Assorted other errors may be returned (DNChildFind errors).
--*/
{
    DWORD           ret, err;
    BOOL            fIsRecordCurrent;
    d_memname       *pname=NULL;

    JetSetCurrentIndex4Success(pDB->JetSessID,
                               pDB->JetObjTbl,
                               SZPDNTINDEX,
                               &idxPdnt,
                               0);
    ret = DNChildFind(pDB,
                      pDB->JetObjTbl,
                      FALSE,
                      PDNT,
                      pRDN,
                      ccRDN * sizeof(WCHAR),
                      0,
                      &pname,
                      &fIsRecordCurrent);
    switch(ret) {
    case 0:
        // Found an object with the requested RDN (ignoring attrtyp)
        Assert(pname);
        if (!fIsRecordCurrent) {
            // Record was found through the cache, but caller wants currency;
            // give it to him.
            JetSetCurrentIndex4Success(pDB->JetSessID,
                                       pDB->JetObjTbl,
                                       SZDNTINDEX,
                                       &idxDnt,
                                       0);
            
            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetObjTbl,
                         &pname->DNT,
                         sizeof(pname->DNT),
                         JET_bitNewKey);
            
            if (err = JetSeekEx(pDB->JetSessID,
                                pDB->JetObjTbl,
                                JET_bitSeekEQ)) {
                DsaExcept(DSA_DB_EXCEPTION, err, pname->DNT);
            }
            
        }
        
        // Currency has been successfully changed; update pDB state.
        dbMakeCurrent(pDB, pname);
        
        if (!pname->objflag) {
            // Found a phantom; return distinct error code.
            // NOTE THAT THE ROOT *IS* AN OBJECT.
            ret = ERROR_DS_NOT_AN_OBJECT;
        }
        break;

    case ERROR_DS_KEY_NOT_UNIQUE:
        // No objects with the requested name exist, but an object with the same
        // key exists (and DB currency is pointing at it)
        dbMakeCurrent(pDB, NULL);
        break;

    default:
        // Only one other error code is expected.
        Assert(ret == ERROR_DS_OBJ_NOT_FOUND);
        break;
    }
    
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dbsetup.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dbsetup.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module implements DBLayer functions to deal with initial setup.  This
    includes moving the schema that is in the boot DB to the correct place, and
    then walking through that schema fixing up a number of attributes.


Author:

    Tim Williams (timwi) 5-June-1998

Revision History:

--*/
#include <NTDSpch.h>
#pragma  hdrstop

#include <limits.h>

#include <dsjet.h>

#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <dsatools.h>
#include <mdlocal.h>

#include <mdcodes.h>
#include <dsevent.h>
#include <anchor.h>

#include <sddlp.h>

#include <dsexcept.h>
#include "objids.h"     /* Contains hard-coded Att-ids and Class-ids */
#include "debug.h"      /* standard debugging header */
#define DEBSUB     "DBSETUP:"   /* define the subsystem for debugging */

#include "dbintrnl.h"

#include <fileno.h>
#define FILENO_DBSETUP 1
#define  FILENO FILENO_DBSETUP

int
IntExtSecDesc(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG intLen,   UCHAR *pIntVal,
              ULONG *pExtLen, UCHAR **ppExtVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG SecurityInformation);

int
ExtIntSecDesc(DBPOS FAR *pDB, USHORT extTableOp,
              ULONG extLen,   UCHAR *pExtVal,
              ULONG *pIntLen, UCHAR **ppIntVal,
              ULONG ulUpdateDnt, JET_TABLEID jTbl,
              ULONG flags);

VOID
dbGetSDForSchemaObjects(
        IN  DBPOS *pDB,
        OUT DWORD *pcbAttSD,
        OUT BYTE **ppAttSD,
        OUT DWORD *pcbClassSD,
        OUT BYTE **ppClassSD,
        OUT DWORD *pcbSubSchemaSD,
        OUT BYTE **ppSubSchemaSD
        )
/*++

  Description:
     Read the SD on the current object (which should be the new schema
     container).  Create the default SD for schema objects.  Merge the two.
     Return the merged SD as the SD that is written on schema objects.

  Parameters:
     pDB - The current dbpos to use
     pcbSD - place to return the size in bytes of the SD to write on schema
           objects.
     ppAncestors - place to return an SD to write on schema objects.

  Return values:
     None.  It either succeeds, or it causes an exception.
--*/
{
    BYTE  *pContainerSD;
    DWORD  cbContainerSD;
    DWORD  err;
    CLASSCACHE *pClassSch=SCGetClassById(pDB->pTHS,CLASS_CLASS_SCHEMA);
    CLASSCACHE *pAttSch = SCGetClassById(pDB->pTHS, CLASS_ATTRIBUTE_SCHEMA);
    CLASSCACHE *pAggregate = SCGetClassById(pDB->pTHS, CLASS_SUBSCHEMA);
    PSECURITY_DESCRIPTOR pDefaultSD = NULL;
    DWORD                cbDefaultSD;
    PSECURITY_DESCRIPTOR pMergedSD=NULL;     // SD to write on the object.
    DWORD                cbMergedSD;
    GUID                 *ppGuid[1];


    *ppAttSD = NULL;
    *ppClassSD = NULL;
    *ppSubSchemaSD = NULL;

    // Get the SD
    err = DBGetAttVal(pDB, 1, ATT_NT_SECURITY_DESCRIPTOR, 0, 0, &cbContainerSD, (UCHAR**) &pContainerSD);
    if (err) {
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
        return; // just to fool PREFIX
    }

#define DEFAULT_SD_FOR_SCHEMA_OBJECTS "O:SAG:SAD:S:"
    // OK, create the default SD from the string.
    if(!ConvertStringSDToSDRootDomainA (
            gpRootDomainSid,
            DEFAULT_SD_FOR_SCHEMA_OBJECTS,
            SDDL_REVISION_1,
            &pDefaultSD,
            &cbDefaultSD
            )) {
        // Failed.
        DsaExcept(DSA_DB_EXCEPTION, GetLastError(), 0);
    }

    __try {
        ppGuid[0] = &(pClassSch->propGuid);


        // Make the CLASS_CLASS_SCHEMA version of the SD
        err = MergeSecurityDescriptorAnyClient(
                pContainerSD,
                cbContainerSD,
                pDefaultSD,
                cbDefaultSD,
                (SACL_SECURITY_INFORMATION  |
                 OWNER_SECURITY_INFORMATION |
                 GROUP_SECURITY_INFORMATION |
                 DACL_SECURITY_INFORMATION   ),
                (MERGE_CREATE | MERGE_AS_DSA),
                ppGuid,
                1,
                &pMergedSD,
                &cbMergedSD
                );

        if(err) {
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
        }

        (*ppClassSD) = THAllocEx(pDB->pTHS, cbMergedSD);
        *pcbClassSD = cbMergedSD;
        memcpy((*ppClassSD), pMergedSD, cbMergedSD);
        DestroyPrivateObjectSecurity(&pMergedSD);
        pMergedSD = NULL;
        ppGuid[0] = &(pAttSch->propGuid);

        // Make the CLASS_ATTRIBUTE_SCHEMA version of the SD
        err = MergeSecurityDescriptorAnyClient(
                pContainerSD,
                cbContainerSD,
                pDefaultSD,
                cbDefaultSD,
                (SACL_SECURITY_INFORMATION  |
                 OWNER_SECURITY_INFORMATION |
                 GROUP_SECURITY_INFORMATION |
                 DACL_SECURITY_INFORMATION   ),
                (MERGE_CREATE | MERGE_AS_DSA),
                ppGuid,
                1,
                &pMergedSD,
                &cbMergedSD
                );
        if(err) {
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
        }

        (*ppAttSD) = THAllocEx(pDB->pTHS, cbMergedSD);
        *pcbAttSD = cbMergedSD;
        memcpy((*ppAttSD), pMergedSD, cbMergedSD);
        DestroyPrivateObjectSecurity(&pMergedSD);
        pMergedSD = NULL;
        ppGuid[0] = &(pAggregate->propGuid);

        // Make the CLASS_SUBSCHEMA_SCHEMA version of the SD
        err = MergeSecurityDescriptorAnyClient(
                pContainerSD,
                cbContainerSD,
                pDefaultSD,
                cbDefaultSD,
                (SACL_SECURITY_INFORMATION  |
                 OWNER_SECURITY_INFORMATION |
                 GROUP_SECURITY_INFORMATION |
                 DACL_SECURITY_INFORMATION   ),
                (MERGE_CREATE | MERGE_AS_DSA),
                ppGuid,
                1,
                &pMergedSD,
                &cbMergedSD
                );
        if(err) {
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
        }

        (*ppSubSchemaSD) = THAllocEx(pDB->pTHS, cbMergedSD);
        *pcbSubSchemaSD = cbMergedSD;
        memcpy((*ppSubSchemaSD), pMergedSD, cbMergedSD);
        DestroyPrivateObjectSecurity(&pMergedSD);
        pMergedSD = NULL;
    }
    __finally {
        if (AbnormalTermination()) {
            // get rid of allocated memory
            if (*ppAttSD) {
                THFreeEx(pDB->pTHS, *ppAttSD);
                *ppAttSD = NULL;
            }
            if (*ppClassSD) {
                THFreeEx(pDB->pTHS, *ppClassSD);
                *ppClassSD = NULL;
            }
            if (*ppSubSchemaSD) {
                THFreeEx(pDB->pTHS, *ppSubSchemaSD);
                *ppSubSchemaSD = NULL;
            }
        }
        if(pMergedSD) {
            DestroyPrivateObjectSecurity(&pMergedSD);
        }
        LocalFree(pDefaultSD);
        THFreeEx(pDB->pTHS, pContainerSD);
    }

    return;
}

VOID
dbGetAncestorsForSetup(
        IN  DBPOS *pDB,
        OUT DWORD *pcAncestors,
        OUT DWORD **ppAncestors
        )
/*++

  Description:
     Read the ancestors value for the object that has DB currency.  Allocate one
     extra DWORD on the end.  We use this to set new ancestors on the objects in
     the schema that we are about to reparent from the boot schema to the
     runtime schema.

  Parameters:
     pDB - The current dbpos to use
     pcAncestors - place to return the number of DWORDs in the ppAncestors
           array.
     ppAncestors - place to return an ancestors array.

  Return values:
     None.  It either succeeds, or it causes an exception.
--*/
{
    DWORD *pAncestors;
    DWORD  err;
    DWORD  actuallen;
    BOOL   done = FALSE;
    DWORD  cNumAncestors = 24;

    // Guess at a number of ancestors.
    pAncestors = THAllocEx(pDB->pTHS, (cNumAncestors + 1) * sizeof(DWORD));

    while(!done) {
        err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                        pDB->JetObjTbl,
                                        ancestorsid,
                                        pAncestors,
                                        cNumAncestors * sizeof(DWORD),
                                        &actuallen, 0, NULL);
        switch (err) {
        case 0:
            // OK, we got the ancestors.  Realloc down
            pAncestors = THReAllocEx(pDB->pTHS, pAncestors,
                                     (actuallen + sizeof(DWORD)));
            done = TRUE;
            break;

        case JET_wrnBufferTruncated:
            // Failed to read, not enough memory.  Realloc it larger.
            pAncestors = THReAllocEx(pDB->pTHS, pAncestors,
                                     (actuallen +  sizeof(DWORD)));

            cNumAncestors = actuallen / sizeof(DWORD);
            break;

        default:
            // Failed badly.
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
            break;
        }
    }

    *pcAncestors = actuallen / sizeof(DWORD);
    *ppAncestors = pAncestors;
    return;
}

VOID
dbGetAndFixMetaData (
        IN     DBPOS *pDB,
        IN     ATTCACHE *pAC,
        IN OUT BYTE **ppMetaData,
        IN OUT DWORD *pcbMetaDataAlloced,
        OUT    DWORD *pcbMetaDataUsed)
/*++

  Description:
      Read the metadata of the object that has currency in the object table.
      Then, spin through the metadata retrieved and fix some fields:
                uuidDsaOriginating
                timeChanged

  Parameters
     pDB - The current dbpos to use
     pAC - attcache pointer of the metadata attribute.  Passed in since we use
           this routine a lot and passing it in saves us from looking it up all
           the time.
     ppMetaData - pointer to a THReAllocable buffer (i.e. some buffer has
           already been THAlloc'ed, and this routine may THReAlloc if it
           wishes.)
     pcbMetaDataAlloced - size of ppMetaData.  If this routine reallocs, it
           needs to update this count.
     pcbMetaDataUsed - Actual size of the metadata read during this routine.

  Return Value:
     None.  This routine succeeds in reading a metadata and then fixing it up,
     or it causes an exception.

--*/
{
    THSTATE *pTHS = pDB->pTHS;
    DWORD err;
    BOOL done = FALSE;
    PROPERTY_META_DATA_VECTOR *pMeta;
    DWORD  i;
    DSTIME timeNow = DBTime();

    while(!done) {
        err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                        pDB->JetObjTbl,
                                        pAC->jColid,
                                        *ppMetaData,
                                        *pcbMetaDataAlloced,
                                        pcbMetaDataUsed,
                                        JET_bitRetrieveCopy, NULL);
        switch(err) {
        case 0:
            // Read it.  return
            done = TRUE;
            break;

        case JET_wrnBufferTruncated:
            // Need more space
            *ppMetaData = THReAllocEx(pTHS, *ppMetaData, *pcbMetaDataUsed);
            *pcbMetaDataAlloced = *pcbMetaDataUsed;
            break;

        default:
            // Huh?
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
            break;
        }
    }

    pMeta = (PROPERTY_META_DATA_VECTOR *)*ppMetaData;
    // OK, we need to spin through here and fix the uuidDsaOriginating and
    // timeChanged.
    for(i=0;i<pMeta->V1.cNumProps;i++) {
        pMeta->V1.rgMetaData[i].uuidDsaOriginating = pTHS->InvocationID;
        pMeta->V1.rgMetaData[i].timeChanged = timeNow;
    }
    return;

}

// These are the DNTs of the distribution boot tree. They are magic.  If we
// change mkdit.exe, then these numbers might need to change.  Note, however,
// that if mkdit does end up changing these numbers, then we have an
// incompatable change in the DIT; new binaries will be necessary to deal with
// the new DNTs.
#define MAGIC_DNT_BOOT         4
#define MAGIC_DNT_BOOT_SCHEMA  5
#define MAGIC_DNT_BOOT_MACHINE 7

DWORD
DBInitialSetup(
        IN WCHAR *pName
        )
/*
   Description:
         This routine spins through the schema that is in the distribution DIT
     and moves the objects in that schema to the new schema container specified
     as a parameter.  This involves changing a few of the attributes on each
     object.  This code is called from the install code in the boot code.  It
     should only ever be called from there.
         If pName is NULL, then spin through the distribution schema and delete
     objects.
   Parameters:
     pName - the friendly name of the new schema container
         (e.g. "CN=Schema,CN=Configuration,DC=Microsoft,DC=COM").
             NULL means to delete the boot schema.

   Return Values:
      Three main cases:
      1) returns 0 on success.
      2) returns non zero on some simple failures.
      3) Causes an exception on other errors.
-*/
{
    PDBPOS        pDB;
    ATTCACHE     *pAC;
    PDSNAME       pDN=NULL;
    DWORD         cAncestors;
    DWORD        *pAncestors;
    GUID          newGuid;
    DWORD         DNTNewContainer;
    DWORD         PDNT;
    DWORD         BootSchemaDNT = MAGIC_DNT_BOOT_SCHEMA;
    DWORD         BootMachineDNT = MAGIC_DNT_BOOT_MACHINE;
    DWORD         BootDNT = MAGIC_DNT_BOOT;
    DWORD         cb;
    BYTE         *pMetaData;
    DWORD         cbMetaDataAlloced;
    DWORD         cbMetaDataUsed;
    JET_SETCOLUMN setColumnInfo[6];
    JET_SETCOLUMN deleteSetColumnInfo[2];
    BOOL          fCommit = FALSE;
    DWORD         count=0;
    DWORD         err=0;
    ATTRTYP       objClass;
    JET_RETRIEVECOLUMN retColumnInfo[4];
    DWORD         cbClassSD;
    BYTE         *pClassSD=NULL;
    DWORD         cbAttSD;
    BYTE         *pAttSD=NULL;
    DWORD         cbAggregateSD;
    BYTE         *pAggregateSD=NULL;
    INDEX_VALUE   IV;
    DSTIME        time=1;
    DWORD         cColumns, cReadColumns, cDeleteColumns;
    BOOL          isDeletedVal = TRUE;
    PUCHAR       *pOldSD = NULL, pNewSD = NULL, pIntSD = NULL;
    DWORD         cbOldSD, cbNewSD, cbIntSD;

    DBOpen(&pDB);

    if (!pDB) {
        return DB_ERR_UNKNOWN_ERROR;
    }

    __try {
#if DBG
        {
            ATTRTYP objClass;
            DWORD err2, len;

            // Verify the boot schema container.
            DBFindDNT(pDB, BootSchemaDNT);
            err2 = DBGetSingleValue(pDB,
                                    ATT_OBJECT_CLASS,
                                    &objClass,
                                    sizeof(objClass),
                                    &len);

            Assert(!err2);
            Assert(len == sizeof(DWORD));
            Assert(objClass == CLASS_DMD);
        }
#endif

        if(pName) {
            // Moving things to a new container.  Set up a buffer we'll need for
            // updating the meta data vector for the objects we move.
            pAC = SCGetAttById(pDB->pTHS, ATT_REPL_PROPERTY_META_DATA);

            pMetaData = THAllocEx(pDB->pTHS, 0x500);
            cbMetaDataAlloced = 0x500;
            cbMetaDataUsed = 0;

            // Find the DNT of the new schema container.
            UserFriendlyNameToDSName(pName, wcslen(pName), &pDN);

            err = DBFindDSName(pDB, pDN);
            if(err) {
                __leave;
            }

            DNTNewContainer = pDB->DNT;

            // The ancestors value on the schema objects need to inherit from
            // this container.
            dbGetAncestorsForSetup( pDB, &cAncestors, &pAncestors);
            cAncestors++;

            // Finally, get the security descriptors we're going to put on the
            // various classes of objects we move.
            dbGetSDForSchemaObjects(pDB,
                                    &cbAttSD,
                                    &pAttSD,
                                    &cbClassSD,
                                    &pClassSD,
                                    &cbAggregateSD,
                                    &pAggregateSD);
        }
        // ELSE {
        //       Delete case.  Obviously, we don't need to find any new
        //       container DNT, we don't have a new container.
        // }


        // Set up the Jet data structure we use to read information off of each
        // schema object.

        memset(retColumnInfo, 0, sizeof(retColumnInfo));
        retColumnInfo[0].columnid = pdntid;
        retColumnInfo[0].pvData = &PDNT;
        retColumnInfo[0].cbData = sizeof(PDNT);
        retColumnInfo[0].cbActual = sizeof(PDNT);
        retColumnInfo[0].grbit = JET_bitRetrieveCopy;
        retColumnInfo[0].itagSequence = 1;

        retColumnInfo[1].columnid = dntid;
        retColumnInfo[1].pvData = &pAncestors[cAncestors - 1];
        retColumnInfo[1].cbData = sizeof(DWORD);
        retColumnInfo[1].cbActual = sizeof(DWORD);
        retColumnInfo[1].grbit = JET_bitRetrieveCopy;
        retColumnInfo[1].itagSequence = 1;

        retColumnInfo[2].columnid = objclassid;
        retColumnInfo[2].pvData = &objClass;
        retColumnInfo[2].cbData = sizeof(objClass);
        retColumnInfo[2].cbActual = sizeof(objClass);
        retColumnInfo[2].grbit = JET_bitRetrieveCopy;
        retColumnInfo[2].itagSequence = 1;

        retColumnInfo[3].columnid = ntsecdescid;
        retColumnInfo[3].pvData = THAllocEx(pDB->pTHS, sizeof(SDID));
        retColumnInfo[3].cbData = sizeof(SDID);
        retColumnInfo[3].cbActual = sizeof(SDID);
        retColumnInfo[3].grbit = JET_bitRetrieveCopy;
        retColumnInfo[3].itagSequence = 1;


        if(pName) {
            // In the move case, we need all four data items we set up to read.
            cReadColumns = 4;
        }
        else {
            // In the delete case, we need only the first of the four data
            // items we set up to read.
            cReadColumns = 1;
        }

        // Setup the invariant portions of the deleteSetColumnInfo.  We use this
        // in both the deletion case and the move case.
        memset(deleteSetColumnInfo, 0, sizeof(deleteSetColumnInfo));

        deleteSetColumnInfo[0].columnid = isdeletedid;
        deleteSetColumnInfo[0].pvData = &isDeletedVal;
        deleteSetColumnInfo[0].cbData = sizeof(isDeletedVal);
        deleteSetColumnInfo[0].itagSequence = 1;

        deleteSetColumnInfo[1].columnid = deltimeid;
        deleteSetColumnInfo[1].pvData = &time;
        deleteSetColumnInfo[1].cbData = sizeof(time);
        deleteSetColumnInfo[1].itagSequence = 1;

        cDeleteColumns = 2;

        if(pName) {
            // Setup the invariant portions of the setColumnInfo for the move
            // case.
            memset(setColumnInfo, 0, sizeof(setColumnInfo));

            setColumnInfo[0].columnid = pdntid;
            setColumnInfo[0].pvData = &DNTNewContainer;
            setColumnInfo[0].cbData = sizeof(DNTNewContainer);
            setColumnInfo[0].itagSequence = 1;

            setColumnInfo[1].columnid = ncdntid;
            setColumnInfo[1].pvData = &DNTNewContainer;
            setColumnInfo[1].cbData = sizeof(DNTNewContainer);
            setColumnInfo[1].itagSequence = 1;

            setColumnInfo[2].columnid = ancestorsid;
            setColumnInfo[2].pvData = pAncestors;
            setColumnInfo[2].cbData = cAncestors * sizeof(DWORD);
            setColumnInfo[2].itagSequence = 1;

            setColumnInfo[3].columnid = guidid;
            setColumnInfo[3].pvData = &newGuid;
            setColumnInfo[3].cbData = sizeof(newGuid);
            setColumnInfo[3].itagSequence = 1;

            setColumnInfo[4].columnid = ntsecdescid;
            // setColumnInfo[4] actual data pointers set inside the loop
            setColumnInfo[4].itagSequence = 1;

            setColumnInfo[5].columnid = pAC->jColid;
            setColumnInfo[5].itagSequence = 1;
            // setColumnInfo[5] actual data pointers set inside the loop

            cColumns = 6;
        }
        else {
            // Setup the invariant portions of the setColumnInfo for the
            // deletion case.  In this case, use exactly the same data we set up
            // for the deleteSetColumn case.
            memcpy(setColumnInfo, deleteSetColumnInfo,
                   sizeof(deleteSetColumnInfo));

            cColumns =  cDeleteColumns;
        }

        // Now, spin over all the children of the boot schema container and
        // do the following:
        // 1) Retrieve the DNT, used to fix up the Ancestors attribute.
        // 2) Retrieve and fix up the repl meta data on the object
        // 3) Modify the PDNT to be the new schema container.
        // 4) Modify the NCDNT to be the new schema container.
        // 5) Modify the Ancestors attribute to hold the correct value based on
        //    the new position.
        // 6) Give the object a new GUID.
        // 7) Write the default SD for the object.
        // 8) Write back the edited meta data

        JetSetCurrentIndexSuccess(pDB->JetSessID,
                                  pDB->JetObjTbl,
                                  SZPDNTINDEX);


        JetMakeKeyEx(pDB->JetSessID,
                     pDB->JetObjTbl,
                     &BootSchemaDNT,
                     sizeof(BootSchemaDNT),
                     JET_bitNewKey);


        JetSeekEx(pDB->JetSessID, pDB->JetObjTbl, JET_bitSeekGE);

        while(TRUE) {
            // Read the PDNT, the DNT, the objectclass and the SD of the current object.
            err = JetRetrieveColumnsWarnings(pDB->JetSessID,
                                             pDB->JetObjTbl,
                                             retColumnInfo,
                                             cReadColumns);
            if (err == JET_wrnBufferTruncated && retColumnInfo[3].err == JET_wrnBufferTruncated) {
                DPRINT(0, "SD in data table longer than SDHASHLENGTH: using an old-style initial DIT???");
                if (PDNT == BootSchemaDNT) {
                    // realloc the sd buffer
                    retColumnInfo[3].pvData = THReAllocEx(pDB->pTHS, retColumnInfo[3].pvData, retColumnInfo[3].cbActual);
                    retColumnInfo[3].cbData = retColumnInfo[3].cbActual;
                    // reget the SD
                    err = JetRetrieveColumnsWarnings(pDB->JetSessID,
                                                     pDB->JetObjTbl,
                                                     &retColumnInfo[3],
                                                     1);
                }
                else {
                    // we are going to break out of the loop anyway. Don't bother reading the SD.
                    err = 0;
                }
            }
            if (err) {
                // a problem reading
                DsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0);
            }

            if (PDNT != BootSchemaDNT) {
                break;
            }

            if(pName) {
                // dereference the old value
                err = IntExtSecDesc(pDB, DBSYN_REM, retColumnInfo[3].cbActual, retColumnInfo[3].pvData,
                                    &cbOldSD, (UCHAR**)&pOldSD, 0, 0, 0);
                if (err) {
                    // a problem occured
                    DsaExcept(DSA_DB_EXCEPTION, (ULONG) err, 0);
                }
                // don't need to get rid of old value -- it is alloced and freed automacially as pDB->valBuf

                // Get the variant portions of the setColumnInfo for the move
                // case.

                // First, what SD do we put on the object.
                switch(objClass) {
                case CLASS_ATTRIBUTE_SCHEMA:
                    pNewSD = pAttSD;
                    cbNewSD = cbAttSD;
                    break;
                case CLASS_CLASS_SCHEMA:
                    pNewSD = pClassSD;
                    cbNewSD = cbClassSD;
                    break;
                case CLASS_SUBSCHEMA:
                    pNewSD = pAggregateSD;
                    cbNewSD = cbAggregateSD;
                    break;
                default:
                    DsaExcept(DSA_DB_EXCEPTION, DB_ERR_UNKNOWN_ERROR,0);
                }

                // convert to internal and inc refCount
                // don't need to worry about int value buffer -- it is alloced and freed automatically as pDB->valBuf
                err = ExtIntSecDesc(pDB, DBSYN_ADD, cbNewSD, pNewSD, &cbIntSD, &pIntSD, 0, 0, 0);
                if (err) {
                    DsaExcept(DSA_DB_EXCEPTION, err, 0);
                }

                setColumnInfo[4].pvData = pIntSD;
                setColumnInfo[4].cbData = cbIntSD;

                // Get the data specific to this new object.
                DsUuidCreate(&newGuid);

                // Fixup the metadata
                dbGetAndFixMetaData(pDB, pAC, &pMetaData,
                                    &cbMetaDataAlloced, &cbMetaDataUsed);
                setColumnInfo[5].pvData = pMetaData;
                setColumnInfo[5].cbData = cbMetaDataUsed;
            }
            // ELSE {
            //       There is no variant portion of the setCOlumnInfo for the
            // delete case.
            // }

            JetPrepareUpdateEx(pDB->JetSessID, pDB->JetObjTbl, JET_prepReplace);

            JetSetColumnsEx(pDB->JetSessID, pDB->JetObjTbl, setColumnInfo,
                            cColumns);

            JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);

            count++;

            JetMoveEx(pDB->JetSessID, pDB->JetObjTbl, JET_MoveNext, 0);
        }

        if(pName) {
            // In the move case, we need to adjust the refcount of the old and
            // new parents.
            DBAdjustRefCount(pDB, DNTNewContainer, count);
            DBAdjustRefCount(pDB, BootSchemaDNT, (-1 * count));
        }


        // Now, move to the distribution machine object.  We're going to
        // delete it. Note that we set the deleteTime to 2, so that garbage
        // collection will find and delete all the schema objects with a
        // deletion time of 1 first, so when it gets around to deleting this
        // object, it will have no refcounts on it.

        DBFindDNT(pDB, BootMachineDNT);
        JetPrepareUpdateEx(pDB->JetSessID, pDB->JetObjTbl, JET_prepReplace);
        JetSetColumnsEx(pDB->JetSessID, pDB->JetObjTbl, deleteSetColumnInfo,
                        cDeleteColumns);
        JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);
        // dbRemoveBackLinksFromPhantom
        dbRemoveAllLinks( pDB, BootMachineDNT, TRUE /*isbacklink*/ );


        // Now, move to the distribution schema container.  We're going to
        // delete it.  It's deletion time is 3, so that garbage collection
        // will  find and delete all the schema objects with a deletion time of
        // 1 first, and then the boot machine with a del time of 2 (which also
        // has some references to the schema), so when it gets around to
        // deleting this object, it will have no refcounts on it.
        time=3;
        DBFindDNT(pDB, BootSchemaDNT);
        JetPrepareUpdateEx(pDB->JetSessID, pDB->JetObjTbl, JET_prepReplace);
        JetSetColumnsEx(pDB->JetSessID, pDB->JetObjTbl, deleteSetColumnInfo,
                        cDeleteColumns);
        JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);
        // dbRemoveBackLinksFromPhantom
        dbRemoveAllLinks( pDB, BootSchemaDNT, TRUE /*isbacklink*/ );

        // Finally, move to the o=BOOT object, We're going to delete it also.
        // Note that we set the deleteTime to 4, so that garbage
        // collection will find and delete the distribution schema container and
        // the distribution machine (which have deletion times of 3 and 2)
        // first, then find this object after it's children are deleted.  It
        // will have no refcounts on it.
        time=4;
        DBFindDNT(pDB, BootDNT);
        JetPrepareUpdateEx(pDB->JetSessID, pDB->JetObjTbl, JET_prepReplace);
        JetSetColumnsEx(pDB->JetSessID, pDB->JetObjTbl, deleteSetColumnInfo,
                        cDeleteColumns);
        JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);
        // dbRemoveBackLinksFromPhantom
        dbRemoveAllLinks( pDB, BootDNT, TRUE /*isbacklink*/ );




        // All done.
        fCommit = TRUE;

    }
    __finally {
        THFreeEx(pDB->pTHS, retColumnInfo[3].pvData); // buffer for reading old SDs
        DBClose(pDB, fCommit);
        if(!err && !fCommit) {
            err = DB_ERR_UNKNOWN_ERROR;
        }
    }

    return err;

}

DWORD
DBMoveObjectDeletionTimeToInfinite(
        DSNAME *pDN
        )
/*++
  Description
      Given a DSNAME, find the object and set it's deletion time to be Later.
      The object must already be deleted, although we don't care if it yet has a
      value for the deletion time column or not.

      Two things get touched here.
      1) Deletion time column gets set.
      2) The modified time for the is-deleted attribute in the metadata is
         modified to Later.  This is so that when this object replicates, the
         deletion time get set appropriately on replicas.  Replication uses the
         modifed time of the is-deleted property to set the deletion time.

      This is a very special purpose routine.  It is currently only called
      during install.

  Parameters
      pDN - dsname of the object to set deletion time on.

  Return values:
      returns 0 if all went well, non-zero for some errors, and excepts for some
      others.

--*/
{
    DBPOS                     *pDB = NULL;
    ATTCACHE                  *pAC = NULL;
    BOOL                       done;
    BOOL                       isDeletedVal;
    BOOL                       fCommit = FALSE;
    DWORD                      cbMeta, cb, i;
    DWORD                      err;
    PROPERTY_META_DATA_VECTOR *pMeta;
    JET_SETCOLUMN              deleteSetColumnInfo[2];
    DSTIME                     Later=0x3db6022f7f;
    // Later = December 30, 23:59:59, year 9999

    DBOpen(&pDB);
    __try {
        // First, find the object.
        err = DBFindDSName(pDB, pDN);
        if(err) {
            __leave;
        }

        // Now, get the isDeleted attribute.  We will succeed this call if that
        // attribute is already set to true.
        if(err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                           pDB->JetObjTbl,
                                           isdeletedid,
                                           &isDeletedVal,
                                           sizeof(isDeletedVal),
                                           &cb,
                                           JET_bitRetrieveCopy, NULL)) {
            // Oops, couldn't read isDeleted,  fail.
            __leave;
        }

        // OK we read a value.  Make sure it was TRUE
        if(!isDeletedVal) {
            err = DB_ERR_UNKNOWN_ERROR;
            __leave;
        }


        pAC = SCGetAttById(pDB->pTHS, ATT_REPL_PROPERTY_META_DATA);
        Assert(pAC);
        if (!pAC)
            return DB_ERR_UNKNOWN_ERROR;

        pMeta = THAllocEx(pDB->pTHS, 0x500);
        cbMeta = 0x500;

        // Get the metadata that's on the object.   We need to tweak it some.
        done = FALSE;
        while(!done) {
            err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                            pDB->JetObjTbl,
                                            pAC->jColid,
                                            pMeta,
                                            cbMeta,
                                            &cbMeta,
                                            JET_bitRetrieveCopy, NULL);
            switch(err) {
            case 0:
                // Read it.  return
                done = TRUE;
                break;

            case JET_wrnBufferTruncated:
                // Need more space
                pMeta = THReAllocEx(pDB->pTHS, pMeta, cbMeta);
                break;

            default:
                // Huh?
                DsaExcept(DSA_DB_EXCEPTION, err, 0);
                break;
            }
        }

        Assert(!err);
        // Now, look through the metadata to find the is-deleted entry.  It must
        // be there, or we will fail.  Once found, set the modified time for the
        // is-deleted attribute to 0xFFFFFFFF
        done = FALSE;

        for(i=0;i<pMeta->V1.cNumProps;i++) {
            if(pMeta->V1.rgMetaData[i].attrType == ATT_IS_DELETED) {
                done = TRUE;
                pMeta->V1.rgMetaData[i].timeChanged = Later;
                break;
            }
        }

        if(!done) {
            // failed to find a deletion time already in the index.
            err = DB_ERR_UNKNOWN_ERROR;
            __leave;
        }

        // Setup the setColumnInfo data structure for the JetSetColumns call.
        memset(deleteSetColumnInfo, 0, sizeof(deleteSetColumnInfo));

        // Shove the tweaked metadata back into the object.
        deleteSetColumnInfo[0].columnid = pAC->jColid;
        deleteSetColumnInfo[0].pvData = pMeta;
        deleteSetColumnInfo[0].cbData = cbMeta;
        deleteSetColumnInfo[0].itagSequence = 1;

        // Set the local delete time to much later so we can avoid garbage
        // collection.  Note that we don't care if it actually has a value right
        // now, we are going to unilaterally set it to Later.
        deleteSetColumnInfo[1].columnid = deltimeid;
        deleteSetColumnInfo[1].pvData = &Later;
        deleteSetColumnInfo[1].cbData = sizeof(Later);
        deleteSetColumnInfo[1].itagSequence = 1;

        JetPrepareUpdateEx(pDB->JetSessID, pDB->JetObjTbl, JET_prepReplace);
        JetSetColumnsEx(pDB->JetSessID, pDB->JetObjTbl, deleteSetColumnInfo,
                        2);
        JetUpdateEx(pDB->JetSessID, pDB->JetObjTbl, NULL, 0, 0);

        // All done.
        fCommit = TRUE;
    }
    __finally {
        DBClose(pDB, fCommit);
        if(!err && !fCommit) {
            err = DB_ERR_UNKNOWN_ERROR;
        }
    }

    return err;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dbsearch.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       dbsearch.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <mdlocal.h>
#include <dsatools.h>                   // For pTHS
#include <limits.h>


// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>
#include "ntdsctr.h"

// Assorted DSA headers
#include <anchor.h>
#include <mappings.h>
#include <dsevent.h>
#include <filtypes.h>                   // Def of FI_CHOICE_???     
#include "objids.h"                     // Hard-coded Att-ids and Class-ids 
#include "dsconfig.h"
#include "debug.h"                      // standard debugging header 
#define DEBSUB "DBSEARCH:"              // define the subsystem for debugging

// LDAP errors
#include <winldap.h>

// DBLayer includes
#include "dbintrnl.h"
#include "lht.h"

#include <fileno.h>
#define  FILENO FILENO_DBSEARCH

#if (DB_CB_MAX_KEY != JET_cbKeyMost) 
#error DB_CB_MAX_KEY not equal to JET_cbKeyMost
#endif
 
#define MAX_UPPER_KEY  "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\
\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"


// How close to ends do we get before doing our own positioning
#define EPSILON     100

#define NormalizeIndexPosition(BeginNum, EndNum) \
            (  ((EndNum) <= (BeginNum)) ?  1  : ( (EndNum) - (BeginNum) )  ) 
            


/* Internal functions */
DWORD
dbCreateASQTable (
        IN DBPOS *pDB,
        IN DWORD StartTick,
        IN DWORD DeltaTick,
        IN DWORD MaxTableSize,
        IN BOOL  fSort,
        IN DWORD SortAttr
        );



void
dbFreeKeyIndex(
        THSTATE *pTHS,
        KEY_INDEX *pIndex
        )
{
    KEY_INDEX *pTemp;

    while(pIndex) {
        pTemp = pIndex->pNext;
        
        if(pIndex->szIndexName) {
            DPRINT1 (2, "dbFreeKeyIndex: freeing %s\n", pIndex->szIndexName);
            dbFree(pIndex->szIndexName);
        }
        if(pIndex->rgbDBKeyLower) {
            dbFree(pIndex->rgbDBKeyLower);
        }
        
        if(pIndex->rgbDBKeyUpper) {
            dbFree(pIndex->rgbDBKeyUpper);
        }

        if (pIndex->bIsIntersection) {

            Assert (pIndex->tblIntersection);
            JetCloseTable (pTHS->pDB->JetSessID, pIndex->tblIntersection );

            pIndex->bIsIntersection = 0;
            pIndex->tblIntersection = 0;
            #if DBG
            pTHS->pDB->numTempTablesOpened--;
            #endif
        }

        Assert (pIndex->tblIntersection == 0);
        
        dbFree(pIndex);
        
        pIndex = pTemp;
    }
    
    return;
}

DWORD
dbGetAncestorsFromDB(
        DBPOS *pDB,
        JET_TABLEID tblId
        )
/*++
  Description:
      Get the ancestors from Jet, not the dnreadcache.  This is called MANY
      times during a whole subtree search, so let's avoid filling the dnread
      cache with a copy of the entire dit.

  Parameters:
      pDB - What, are you kidding or something?
      tblId - jet table to use.  Should be either pDB->JetObjTbl or
                                                     ->JetSearchTbl  
      pAncestors - THAlloc'ed memory to put things into
      pcbAllocated - number of bytes in pAncestors

  Return values:
      Number of bytes in resulting ancestors blob.
--*/
{
    DWORD err;
    DWORD actuallen=0;
    
    err = JetRetrieveColumnWarnings(pDB->JetSessID,
                                    tblId,
                                    ancestorsid,
                                    pDB->pAncestorsBuff,
                                    pDB->cbAncestorsBuff,
                                    &actuallen,
                                    0,
                                    NULL);
    
    if(err) {
        if(err != JET_wrnBufferTruncated) {
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
        }
        // Value too small
        if(pDB->pAncestorsBuff) {
            pDB->pAncestorsBuff = THReAllocOrgEx(pDB->pTHS,
                                        pDB->pAncestorsBuff,
                                        actuallen); 
            pDB->cbAncestorsBuff = actuallen;
        }
        else {
            pDB->pAncestorsBuff = THAllocOrgEx(pDB->pTHS, actuallen);
            pDB->cbAncestorsBuff = actuallen;
        }
        
        JetRetrieveColumnSuccess(pDB->JetSessID,
                                 tblId,
                                 ancestorsid,
                                 pDB->pAncestorsBuff,
                                 actuallen,
                                 &actuallen,
                                 0,
                                 NULL);
    }

    return actuallen;
}

void
dbAdjustCurrentKeyToSkipSubtree (
        DBPOS *pDB
        )
/*++
  Description:
    OK, pay attention.  We're going to do adjust the current key to skip an
    entire subtree.  We're going to do this by modifying the jet key in the
    index structure, then setting the flag to  indicate we are NOT already in a
    search.  This will cause reposition to the next sibling and reset our jet
    index ranges appropriately.  Essentially, it is equivalent to abondoning our
    position in the current KeyIndex structure and building a better KeyIndex
    structure that trims out uninteresting portions of the tree.

    This should only be called from moveToNextSearchCandidate below.

--*/    
{
    THSTATE   *pTHS = pDB->pTHS;
    BYTE       rgbKey[DB_CB_MAX_KEY];
    DWORD      cbActualKey = 0;
    DWORD      cbAncestors;
    DWORD      pseudoDNT, realDNT;

    Assert(!strcmp(pDB->Key.pIndex->szIndexName, SZANCESTORSINDEX));
    
    // Start by refreshing the ancestors info in the dbpos.
    cbAncestors = dbGetAncestorsFromDB(pDB, pDB->JetObjTbl);
    
    // Now, tweak to get the next subtree.
    // We used to just increment the last DNT in the array, until
    // we discovered that the index is not in DNT order, it's in *byte*
    // order.  This means that what we need is not the next-higher DNT,
    // but the next higher byte pattern.  We thus take the last DNT and
    // byte swap it (so that it's in big-endian order), increment it,
    // and then re-swap it.  This gives us the DNT that would be next in
    // byte order.  Presumably this could all be done better via clever
    // use of JetMakeKey flags.
    realDNT = pDB->pAncestorsBuff[(cbAncestors/sizeof(DWORD)) - 1];
    pseudoDNT = (realDNT >> 24) & 0x000000ff;
    pseudoDNT |= (realDNT >> 8) & 0x0000ff00;
    pseudoDNT |= (realDNT << 8) & 0x00ff0000;
    pseudoDNT |= (realDNT << 24) & 0xff000000;
    ++pseudoDNT;
    realDNT = (pseudoDNT >> 24) & 0x000000ff;
    realDNT |= (pseudoDNT >> 8) & 0x0000ff00;
    realDNT |= (pseudoDNT << 8) & 0x00ff0000;
    realDNT |= (pseudoDNT << 24) & 0xff000000;
    pDB->pAncestorsBuff[(cbAncestors/sizeof(DWORD)) - 1] = realDNT;
    
    // Now, recalculate the normalized key for the new beginning
    // of the search.
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetObjTbl,
                 pDB->pAncestorsBuff,
                 cbAncestors,
                 JET_bitNewKey);
    
    
    JetRetrieveKeyEx(pDB->JetSessID,
                     pDB->JetObjTbl,
                     rgbKey,
                     sizeof(rgbKey),
                     &cbActualKey,
                     JET_bitRetrieveCopy);
    
    // OK, put that key in place.
    if(pDB->Key.pIndex->cbDBKeyLower < cbActualKey) {
        pDB->Key.pIndex->rgbDBKeyLower =
            dbReAlloc(pDB->Key.pIndex->rgbDBKeyLower,
                      cbActualKey);
    }
    pDB->Key.pIndex->cbDBKeyLower = cbActualKey;
    memcpy(pDB->Key.pIndex->rgbDBKeyLower,
           rgbKey,
           cbActualKey);
    
    // Finally, set the flag to say we are NOT in an active
    // search for this KEY.
    pDB->Key.fSearchInProgress = FALSE;
    pDB->Key.indexType = UNSET_INDEX_TYPE;

    return;
}


//
// Checks to see if we have a local copy of the object
//
// Returns FALSE if the object is not a local one (phantom, read-only copy)
// TRUE otherwise
//
BOOL
dbIsObjectLocal (
        DBPOS *pDB,
        JET_TABLEID tblId
        )
{
    SYNTAX_INTEGER it;
    DWORD actuallen;
    
    Assert(VALID_DBPOS(pDB));

    if (JetRetrieveColumnWarnings(pDB->JetSessID,
                                  tblId,
                                  insttypeid,
                                  &it,
                                  sizeof( it ),
                                  &actuallen,
                                  0,
                                  NULL)) {
        // No instance type; must be a phantom, so skip it.
        return FALSE;
    }

    if (it & IT_WRITE) {
        return TRUE;
    }

    return FALSE;
}

BOOL
dbFObjectInCorrectNC (
        DBPOS *pDB,
        ULONG DNT,
        JET_TABLEID tblId
        )
/*++

Routine Description:

    Checks that the current object on the table passed in is correctly located
    for the search root DNT in the key in the pDB.

Arguments:    

    pDB - DBPOS to use.

    DNT - the DNT of the current object.  Note that a caller could potentially
          lie and pass us a DNT which is not the DNT of the current object in
          the specified table, but in the interest of efficiency, we trust the
          caller to get this right.

    tblId - jet table to use.  Should be either pDB->JetObjTbl or ->JetSearchTbl

Return Value:
    
    TRUE if we could verify that the object was in correct portion of the DIT,
    FALSE otherwise.

--*/
{
    SYNTAX_INTEGER        it = 0;
    ULONG                 Ncdnt=0;
    JET_RETRIEVECOLUMN    attList[2];

    // first the instancetype
    attList[0].pvData = &it;
    attList[0].columnid = insttypeid;
    attList[0].cbData = sizeof(it);
    attList[0].grbit = pDB->JetRetrieveBits;
    attList[0].itagSequence = 1;
    attList[0].ibLongValue = 0;

    // then the NC
    attList[1].pvData = &Ncdnt;
    attList[1].columnid = ncdntid;
    attList[1].cbData = sizeof(Ncdnt);
    attList[1].grbit = pDB->JetRetrieveBits;
    attList[1].itagSequence = 1;
    attList[1].ibLongValue = 0;
    
    Assert(VALID_DBPOS(pDB));

    // This search is constrained to a single Naming Context.
    // Verify. 
    
    /* Retrieve column parameter structure for JetRetrieveColumns */

    if(JetRetrieveColumnsWarnings(pDB->JetSessID, tblId, attList, 2) ||
       // Note the instanceType was in the first slot of the array.
       attList[0].err ){
        Assert(attList[0].err == JET_errColumnNotFound ||
               attList[0].err == JET_wrnColumnNull);
        // No instance type; must be a phantom, so skip it.
        return FALSE;
    }

    if(it & IT_UNINSTANT) {
        
        // Hey, this isn't real, so even if we're not constrainted to a
        // particular NC, we don't wan't this object.
        return FALSE;
    }

    if (!pDB->Key.bOneNC) {

        // We're in GC search, so we need to make sure that this
        // NC isn't one of the NCs were not supposed to search.
        // Note gAnchor.pNoGCSearchList will be NULL if there is
        // not even one NC to _not_ search.  This is the typical
        // case, so I've optimized for that case.

        if(it & IT_NC_HEAD){
            // In this rare rare case, we need to use the DNT of
            // this object, because the ncdnt will be the parent 
            // NC's dnt, not the DNT of the current NC head.
            Ncdnt = DNT;
        }

        if(gAnchor.pNoGCSearchList &&
           bsearch(&Ncdnt, // The Key to search for.
                   gAnchor.pNoGCSearchList->pList, // sorted array to search.
                   gAnchor.pNoGCSearchList->cNCs, // number of elements in array.
                   sizeof(DNT), // sizeof each element in array.
                   CompareDNT) ){
            // This was one of the NCs weren't not supposed to
            // return objects from, so return FALSE.
            return(FALSE);
        }

        return(TRUE);
    }

    // NOT a GC search.
    if (it & IT_NC_HEAD) {
        // NC head; in this case, the object is in the correct
        // NC only if the base of the search was the NC head
        // and this is the NC head we found.
        return (DNT == pDB->Key.ulSearchRootNcdnt );
    } else {
        // Interior node; in this case, the object is in
        // the correct NC if its NCDNT matches that of
        // the search root in the key.
 

        // If only in one NC, then we're in the correct NC only
        // if the object's NCDNT matches that of the search root
        // in the key.

        if (Ncdnt != pDB->Key.ulSearchRootNcdnt &&
            pDB->Key.asqRequest.fPresent) {
            DPRINT (1, "Doing ASQ and found an object from another NC\n");

            if (!pDB->Key.asqRequest.Err) {
                pDB->Key.asqRequest.Err = LDAP_AFFECTS_MULTIPLE_DSAS;
            }
            return TRUE;
        }

        return ( Ncdnt == pDB->Key.ulSearchRootNcdnt );
    }
}

BOOL
dbFObjectInCorrectDITLocation (
        DBPOS *pDB,
        JET_TABLEID tblId
        )
/*++

Routine Description:

    Checks that the current object on the table passed in is correctly located
    for the search key in the pDB.

Arguments:    

    pDB - DBPOS to use.

    tblId - jet table to use.  Should be either pDB->JetObjTbl or ->JetSearchTbl

Return Value:
    
    TRUE if we could verify that the object was in correct portion of the DIT,
    FALSE otherwise.

--*/
{
    ULONG       actuallen;
    ULONG       ulTempDNT;
    DWORD       i;
    DWORD       cbAncestors;
    
    Assert(VALID_DBPOS(pDB));

    //
    // Sam search hints are only used in whole subtree
    // searches
    //

    ASSERT((pDB->Key.ulSearchType==SE_CHOICE_WHOLE_SUBTREE)
             ||(pDB->pTHS->pSamSearchInformation==NULL));

    switch (pDB->Key.ulSearchType) {

    case SE_CHOICE_BASE_ONLY:
        if (!pDB->Key.asqRequest.fPresent) {
            JetRetrieveColumnSuccess(pDB->JetSessID,
                                     tblId,
                                     dntid,
                                     &ulTempDNT,
                                     sizeof(ulTempDNT),
                                     &actuallen,
                                     0,
                                     NULL);
            return (pDB->Key.ulSearchRootDnt == ulTempDNT);
        }
        else {
            // in ASQ all the returned objects are ok
            return TRUE;
        }
        break;
        
    case SE_CHOICE_IMMED_CHLDRN:

        if (pDB->Key.pVLV && pDB->Key.pVLV->bUsingMAPIContainer) {
            // we might add a test to see that indeed one of the 
            // showInAddressBook values in this record is the one we want
            return TRUE;
        }

        JetRetrieveColumnSuccess(pDB->JetSessID,
                                 tblId,
                                 pdntid,
                                 &ulTempDNT,
                                 sizeof(ulTempDNT),
                                 &actuallen,
                                 0,
                                 NULL);
        return (pDB->Key.ulSearchRootDnt == ulTempDNT);
        break;
        
    case SE_CHOICE_WHOLE_SUBTREE:
        if(pDB->Key.ulSearchRootDnt == ROOTTAG) {
            // The root is a subtree ancestor of everything
            return TRUE;
        }
        
        //
        // If pSamsearch information indicates that ancestors need
        // not be checked then return true always
        //
        
        if (pDB->pTHS->pSamSearchInformation) {
            SAMP_SEARCH_INFORMATION * pSamSearchInformation
                = pDB->pTHS->pSamSearchInformation;
            
            if (pSamSearchInformation->bRootOfSearchIsNcHead) {
                //
                // If the root of the search is an NC head, then
                // the test for Same NC is sufficient to determine
                // wether the object is in the correct DIT location.
                // There fore we may simply return true in here.
                //
                return TRUE;
            }
        }


        cbAncestors = dbGetAncestorsFromDB(pDB, tblId);
        
        for(i=0;i<(cbAncestors / sizeof(DWORD));i++) {
            if(pDB->pAncestorsBuff[i] == pDB->Key.ulSearchRootDnt) {
                return TRUE;
            }
        }

        return FALSE;
        break;
        
    default:                // shouldn't be here
        Assert(FALSE);
        return FALSE;
    }
} // dbFObjectInCorrectDITLocation

BOOL
dbIsInVLVContainer (DBPOS *pDB, DWORD ContainerID)
/*++

Routine Description:

    Verifies that the current index position is on the specified container.
    It reads the container info directly from the index, so it requires that 
    the index is PDNT based or MAPI based.

    NOTE: assumes the DBPOS already is set up on the appropriate index for the
    Container in question.
    
Arguments:

    ContainerID - the Container to abstract this seek inside.
                  if PDNT based reads the PDNT from the index
                  if MAPI based, read the showInAddrBook from index

Return Values:

    TRUE if positioned on the specified container, FALSE otherwise.

--*/
{
    DWORD dwThisContainerID=!ContainerID;
    
    // Read the container id FROM THE INDEX KEY! and see if it is the one passed in.
    if (pDB->Key.pVLV->bUsingMAPIContainer) {
        DBGetSingleValueFromIndex (
                pDB,
                ATT_SHOW_IN_ADDRESS_BOOK,
                &dwThisContainerID,
                sizeof(DWORD),
                NULL);
    }
    else {
        DBGetSingleValueFromIndex (
                pDB,
                FIXED_ATT_PDNT,
                &dwThisContainerID,
                sizeof(DWORD),
                NULL);
    }

    return (dwThisContainerID == ContainerID);
} // dbIsInVLVContainer

DWORD
dbVlvSeek (
        DBPOS *pDB,
        void * pvData,
        DWORD cbData,
        DWORD ContainerID
      )
/*++

Routine Description:

    Abstracts a DBSeek inside a VLV container.  Assumes at most one
    value to seek on.  If no values are specified, it seeks to the 
    beginning of the appropriate container.  

    NOTE: assumes the DBPOS already is set up on the appropriate index for the
    VLV Container in question.
    
Arguments:

    pvData - the Data to look for.

    cbData - the count of bytes of the data.

    ContainerID - the Container to abstract this seek inside.

Return Values:

    0 if all went well, an error code otherwise.

--*/
{
    INDEX_VALUE index_values[2];
    ULONG       cVals = 0;
    ULONG       dataindex=0;
    DWORD       err;

    index_values[0].pvData = &ContainerID;
    index_values[0].cbData = sizeof(DWORD);
    dataindex++;
    cVals++;

    // PVData == 0 only for the abstraction of DB_MoveFirst in a container.  To
    // handle ascending and descending sorts correctly, this only seeks on
    // ContainerID.
    
    if(pvData) {
        index_values[dataindex].pvData = pvData;
        index_values[dataindex].cbData = cbData;
        cVals++;
    }

    // We should never be called both without a ContainerID and without data.
    Assert(cVals);
    
    err = DBSeek(pDB, index_values, cVals, DB_SeekGE);

    // Make sure we are in the correct container.
    if((err != DB_ERR_RECORD_NOT_FOUND) && 
       !dbIsInVLVContainer(pDB, ContainerID)) {
            err = DB_ERR_RECORD_NOT_FOUND;
    }
    
    return err;
} // dbVlvSeek



DWORD 
dbVlvMove (DBPOS *pDB, long Delta, BOOL fForward, DWORD ContainerID)
/*++

Routine Description:
    Abstracts movement within a container used for VLV.

    Note that moving backward past the beginning of the VLV container leaves us
    on the first entry of the container, while moving forward past the end of
    the container leaves us one row past the end of the VLV container.

Arguments:

    Delta - The distance to move.  Accepts numeric arguments and DB_MoveFirst,
        DB_MoveLast, DB_MoveNext, DB_MovePrevious.
        
    fForward - forward / backward movement

    ContainerID - the ID of the Container to move around in.
    
Return Value:

    Returns 0 if successful, an error code otherwise. 

--*/
{
    DWORD err;

    if(!Delta )                     // check for the null case
        return DB_success;          // nothing to do, and we did it well!

    Assert(ContainerID);

    switch(Delta) {
    case DB_MoveFirst:
        err = dbVlvSeek(pDB, NULL, 0, ContainerID);

        if((err == DB_success &&
            (!dbIsInVLVContainer(pDB, ContainerID)) ||
             err == DB_ERR_NO_CURRENT_RECORD           ||
             err == DB_ERR_RECORD_NOT_FOUND   )) {
                // Couldn't find the first object in this container.  The
                // container must be empty.  
                err = DB_ERR_NO_CURRENT_RECORD;
        }
        break;
        
    case DB_MoveLast:
        // dbVlvSeek will always leave us in the correct place (one past the
        // end of the container, even if the container is empty.)
        dbVlvSeek(pDB, NULL, 0, ContainerID+1);
        
        // Back up to the last object in the container.
        err = DBMovePartial(pDB, DB_MovePrevious);
        if(err != DB_success ||
           !dbIsInVLVContainer(pDB, ContainerID)) {
            // We couldn't back up to the last row or we did back up and we
            // weren't in the correct container after we did.  Either way,
            // set the flags to indicate we are not in the container.
            err = DB_ERR_NO_CURRENT_RECORD;
        }
        break;
        
    default:
        err = DBMovePartial(pDB, Delta);
        if((err != DB_ERR_NO_CURRENT_RECORD) &&
           !dbIsInVLVContainer(pDB, ContainerID)) {
            // we moved to a valid row, but ended up outside of the
            // container.  Set the error to be the same as the error for not
            // moving to a valid row. 
            err=DB_ERR_NO_CURRENT_RECORD;
        }
        
        switch( err ) {
        case DB_success:
            break;
            
        case DB_ERR_NO_CURRENT_RECORD:
            if (fForward) {
                // After the move, we did not end up on a valid row.
                if (Delta < 0) {
                    // Moving back, off the front, so move to the first record
                    dbVlvMove(pDB, DB_MoveFirst, fForward, ContainerID);
                }
                else {
                    // position on the first record of the next container, which
                    // is the same thing as being one past the last row of the
                    // current container.
                    dbVlvSeek(pDB, NULL, 0, ContainerID+1);
                }
            }
            else {
                // After the move, we did not end up on a valid row.
                if (Delta < 0) {
                    // position on the first record of the next container, which
                    // is the same thing as being one past the last row of the
                    // current container.
                    dbVlvSeek(pDB, NULL, 0, ContainerID+1);
                }
                else {
                    // Moving back, off the front, so move to the last record
                    // since we are moving backwards
                    dbVlvMove(pDB, DB_MoveLast, fForward, ContainerID);
                }
            }
            break;
            
        default:
            break;
        }                           // switch on err
        break;
    }                               // switch on Delta

    return err;
} // dbVlvMove

DWORD
dbVlvSetFractionalPosition (DBPOS *pDB, ULONG Flags)
/*++

Routine Description:
    Abstracts fractional positioning within an container / InMemory Result Set.

    The position is determined from the pDB->key.pVLV argument.
    Takes into considaration the beforeCount argument of the VLV request
    and positions accordingly. 
    
    If it is near the start of the container, and there are not enough entries
    before the targetPosition, the total number of returned entries is adjusted
    accordingly.
    
Return Value:
    Returns 0 if successful, Jet error otherwise.
    
    the following are updated accordingly:
        pDB->Key.pVLV->currPosition
        pDB->Key.pVLV->requestedEntries

--*/ 
{
    THSTATE    *pTHS=pDB->pTHS;
    BOOL        fForward = Flags & DB_SEARCH_FORWARD;
    DWORD       deltaCount;
    VLV_SEARCH   *pVLV = pDB->Key.pVLV;

    Assert (pVLV);

    // vlv positioning within a memory array
    //
    if (pDB->Key.indexType == TEMP_TABLE_MEMORY_ARRAY_TYPE) {
        if (pVLV->positionOp == VLV_MOVE_FIRST) {
            pVLV->currPosition = 1;

            if(fForward) {
                // set to first Entry
                pDB->Key.currRecPos = 1;

            } else {
                // set to last entry
                pDB->Key.currRecPos = pDB->Key.cdwCountDNTs;
            }

            // since we start at the first entry, we are not interested 
            // in the entries before this
            pVLV->requestedEntries -= pVLV->pVLVRequest->beforeCount;
        }
        else if (pVLV->positionOp == VLV_MOVE_LAST) {
            
            pVLV->currPosition = pDB->Key.cdwCountDNTs;
            
            // since we start at the last entry, we are not interested 
            // in the entries after this
            pVLV->requestedEntries -= pVLV->pVLVRequest->afterCount;

            if(fForward) {
                // set to last entry
                pDB->Key.currRecPos = pDB->Key.cdwCountDNTs;
            } else {
                // set to first Entry
                pDB->Key.currRecPos = 1;
            }


            // adjust for the before Count
            deltaCount = pVLV->pVLVRequest->beforeCount;
            
            if (fForward) {
                if (pVLV->currPosition > deltaCount) {
                    pDB->Key.currRecPos -= deltaCount;
                }
                else {
                    deltaCount = deltaCount - pVLV->currPosition + 1;
                    pVLV->requestedEntries -= deltaCount;
                    pDB->Key.currRecPos = 1;
                }
            }
            else {
                if (pVLV->currPosition > deltaCount) {
                    pDB->Key.currRecPos += deltaCount;
                }
                else {
                    deltaCount = deltaCount - pDB->Key.currRecPos + 1;
                    pVLV->requestedEntries -= deltaCount;
                    pDB->Key.currRecPos = pDB->Key.cdwCountDNTs;
                }
            }
        }
        else {
            // pDB->Key.vlvSearch.positionOp == VLV_CALC_POSITION

            if ( pVLV->clnContentCount == 0 ) {
                pVLV->clnContentCount = pVLV->contentCount;
            }

            pVLV->currPosition = 
                        MulDiv (pVLV->contentCount,
                                pVLV->clnCurrPos,
                                pVLV->clnContentCount);
                
                // same as:
                //(ULONG) (pDB->Key.vlvSearch.contentCount * 
                //         ( ((float)pDB->Key.vlvSearch.clnCurrPos)) / 
                //                  pDB->Key.vlvSearch.clnContentCount);


            if (pVLV->currPosition >= pVLV->contentCount) {
                pVLV->currPosition = pVLV->contentCount;
            }
            else if (pVLV->currPosition <= 1) {
                pVLV->currPosition = 1;
            }

            // adjust for the before Count
            deltaCount = pVLV->pVLVRequest->beforeCount;
            
            if (fForward) {
                pDB->Key.currRecPos = pVLV->currPosition;

                if (pVLV->currPosition > deltaCount) {
                    pDB->Key.currRecPos -= deltaCount;
                }
                else {
                    deltaCount = deltaCount - pVLV->currPosition + 1;
                    pVLV->requestedEntries -= deltaCount;
                    pDB->Key.currRecPos = 1;
                }
            }
            else {
                pDB->Key.currRecPos = pDB->Key.cdwCountDNTs - pVLV->currPosition + 1;

                if (pVLV->currPosition > deltaCount) {
                    pDB->Key.currRecPos += deltaCount;
                }
                else {
                    deltaCount = deltaCount - pDB->Key.currRecPos + 1;
                    pVLV->requestedEntries -= deltaCount;
                    pDB->Key.currRecPos = pDB->Key.cdwCountDNTs;
                }
            }
        }
    }
    // do the real thing. vlv position in the database
    // 
    else {
        DWORD err;
        DWORD ContainerID = pDB->Key.pVLV->bUsingMAPIContainer ? 
                                    pDB->Key.pVLV->MAPIContainerDNT : 
                                    pDB->Key.ulSearchRootDnt;
        DWORD ContainerDenominator, ContainerNumeratorBegin, ContainerNumeratorEnd;
        DWORD Denominator, Numerator;
        DWORD BeginDenom, BeginNum, EndDenom, EndNum;
        LONG  requiredPos;
        LONG lastPosition = pVLV->currPosition;

        // We are Moving in a container.  
        // 
        // 1) Get the fractional position of the beginning of the appropriate
        //  container.  This is the offset from the beginning of the index to
        //  the first element of the subcontainer.
        //
        // 2) Get the fractional position of the end of the appropriate
        //  container.  This is the offset from the beginning of the index to
        //  the last element of the subcontainer.
        //
        // 3) Calculate the size of the container.
        //
        // 4) Calculate the new requested position in the container.
        //
        // 5) Find the new position relative to the start of the index
        //
        // 6) Go to the specified position. Check to see if target record belongs 
        //    to container. If not move to the first record and move X records
        //    forward, or move to the last record and move X records backwards.
        //
        // There, that wasn't that hard, was it?


        // Get fractional position of beginning
        if (err = dbVlvMove(pDB, DB_MoveFirst, TRUE, ContainerID)) {
                return err;
        }
        DBGetFractionalPosition(pDB, &BeginNum, &BeginDenom);

        // Get fractional position of ending
        if (err = dbVlvMove(pDB, DB_MoveLast, TRUE, ContainerID)) {
                return err;
        }
        DBGetFractionalPosition(pDB, &EndNum, &EndDenom);

        DPRINT2 (1, "Start of Container: %d / %d \n", BeginNum, BeginDenom);
        DPRINT2 (1, "End of Container: %d / %d \n", EndNum, EndDenom);

        // Normalize the fractions of the fractional position to the average of
        // the two denominators.
        // denominator
        Denominator = (BeginDenom + EndDenom)/2;
        EndNum = MulDiv(EndNum, Denominator, EndDenom);
        BeginNum = MulDiv(BeginNum, Denominator, BeginDenom);

        // keep values for later
        ContainerNumeratorBegin = BeginNum;
        ContainerNumeratorEnd = EndNum;
        ContainerDenominator = Denominator;

        DPRINT2 (1, "Adj. Start of Container: %d / %d \n", BeginNum, Denominator);
        DPRINT2 (1, "Adj. End of Container: %d / %d \n", EndNum, Denominator);

        // calculate container size, since it might have changed
        pVLV->contentCount = NormalizeIndexPosition (BeginNum, EndNum);

        // we need better content size estimation since this container does not 
        // have enough entries
        // we are positioned in the end
        if (pVLV->contentCount < EPSILON) {
            ULONG newCount=0;
            if (dbIsInVLVContainer(pDB, ContainerID)) {
                newCount=1;

                while ( !(err = dbVlvMove(pDB, DB_MovePrevious, TRUE, ContainerID))) {
                    newCount++;
                }
            }
            pVLV->contentCount = newCount;
        }
        DPRINT1 (1, "Size of Container: %d\n", pVLV->contentCount);

        if ( pVLV->clnContentCount == 0 ) {
            pVLV->clnContentCount = pVLV->contentCount;
        }

        // position accordingly
        //
        if ( pVLV->positionOp == VLV_MOVE_FIRST) {

            if (fForward) {
                dbVlvMove(pDB, DB_MoveFirst, fForward, ContainerID);
            }
            else {
                dbVlvMove(pDB, DB_MoveLast, fForward, ContainerID);
            }
            
            pVLV->currPosition = 1;

        } else if (pVLV->positionOp == VLV_MOVE_LAST) {
            if (fForward) {
                dbVlvMove(pDB, DB_MoveLast, fForward, ContainerID);
            }
            else {
                dbVlvMove(pDB, DB_MoveFirst, fForward, ContainerID);
            }
            pVLV->currPosition = pVLV->contentCount;
        }
        else {
            // pVLV->positionOp == VLV_CALC_POSITION
            
            // calculate the required position
            requiredPos = MulDiv (pVLV->contentCount,
                                  pVLV->clnCurrPos,
                                  pVLV->clnContentCount);

            // see if we are near ends so we have todo precise positioning
            //
            if (requiredPos < EPSILON) {
                if (fForward) {
                    DPRINT (1, "Precise Positioning Near Start of Container\n");
                    dbVlvMove(pDB, DB_MoveFirst, fForward, ContainerID );
                    dbVlvMove(pDB, pVLV->clnCurrPos-1, fForward, ContainerID );
                }
                else {
                    DPRINT (1, "Precise Positioning Near End of Container\n");
                    dbVlvMove(pDB, DB_MoveLast, fForward, ContainerID );
                    dbVlvMove(pDB, 0 - pVLV->clnCurrPos, fForward, ContainerID );
                }

                pVLV->currPosition = requiredPos;
            }
            else if ((deltaCount = pVLV->contentCount - requiredPos) <= EPSILON) {

                if (fForward) {
                    DPRINT (1, "Precise Positioning Near End of Container\n");
                    // Go to the end of the table
                    dbVlvMove(pDB, DB_MoveLast, fForward, ContainerID); 
                    // Now move back -deltaCount 
                    dbVlvMove(pDB, 0-deltaCount, fForward, ContainerID); 
                }
                else {
                    DPRINT (1, "Precise Positioning Near Start of Container\n");
                    // Go to the start of the table
                    dbVlvMove(pDB, DB_MoveFirst, fForward, ContainerID); 
                    // Now move forward deltaCount 
                    dbVlvMove(pDB, deltaCount, fForward, ContainerID); 
                }

                pVLV->currPosition = requiredPos;
            }
            else {
                BOOL fPositioned = FALSE;

                if (lastPosition) {
                    if ((lastPosition-EPSILON) < requiredPos &&
                        (lastPosition+EPSILON) > requiredPos ) {

                        DPRINT (1, "Precise Positioning in the Middle of the Container\n");

                        JetMakeKeyEx(pDB->JetSessID,
                                     pDB->JetObjTbl,
                                     pVLV->rgbCurrPositionKey,
                                     pVLV->cbCurrPositionKey,
                                     JET_bitNormalizedKey);

                        if (err = JetSeekEx(pDB->JetSessID, 
                                            pDB->JetObjTbl, 
                                            JET_bitSeekEQ)) {

                            DPRINT(0,"dbVlvSetFractionalPosition: repositioning failed\n");
                        }
                        else {
                            // still on the same container ?
                            if (dbIsInVLVContainer(pDB, ContainerID)) {

                                if (fForward) {
                                    deltaCount = requiredPos - lastPosition;
                                }
                                else {
                                    deltaCount = lastPosition - requiredPos;
                                }
                                dbVlvMove(pDB, deltaCount, fForward, ContainerID); 

                                if (dbIsInVLVContainer(pDB, ContainerID)) {
                                    fPositioned = TRUE;

                                    pVLV->currPosition = requiredPos;
                                }
                            }
                        }
                    }
                }

                // we didn't think we had to position precisely, 
                // so we position approximately
                //
                if (!fPositioned) {
                    // adjust the values to reflect the start of the index
                    if (EndNum > BeginNum) {
                        Numerator = BeginNum + MulDiv (requiredPos, 
                                                       (EndNum - BeginNum),
                                                       pVLV->contentCount);
                    }
                    else {
                        Numerator = BeginNum;
                    }

                    DPRINT2 (1, "Requested Position: %d / %d \n", Numerator, Denominator);

                    err = DBSetFractionalPosition(pDB, Numerator, Denominator);
                    if(err != DB_success ) {
                        return DB_ERR_NO_CURRENT_RECORD;
                    }

                    if(!dbIsInVLVContainer(pDB, ContainerID)) {
                        // not in the right container.  Do this the long way.
                        if((2 * Numerator) < Denominator ) {
                            // Closer to the front. 
                            if (fForward) {
                                DPRINT (1, "Positioned out of container near front\n");
                                dbVlvMove(pDB, DB_MoveFirst, fForward, ContainerID);
                                dbVlvMove(pDB, requiredPos, fForward, ContainerID);
                            }
                            else {
                                DPRINT (1, "Positioned out of container near end\n");
                                dbVlvMove(pDB, DB_MoveLast, fForward, ContainerID);
                                // Now move back.  
                                // we use 1 - containerSize + requirePosition because our "end"
                                // is on the last entry of the Container.
                                dbVlvMove(pDB, 1 - pVLV->contentCount + requiredPos, fForward, ContainerID);
                            }
                        }
                        else {
                            if (fForward) {
                                DPRINT (1, "Positioned out of container near end\n");
                                dbVlvMove(pDB, DB_MoveLast, fForward, ContainerID);
                                // Now move back.  
                                // we use 1 - containerSize + requirePosition because our "end"
                                // is on the last entry of the Container.
                                dbVlvMove(pDB, 1 - pVLV->contentCount + requiredPos, fForward, ContainerID);
                            }
                            else {
                                DPRINT (1, "Positioned out of container near front\n");
                                dbVlvMove(pDB, DB_MoveFirst, fForward, ContainerID);
                                dbVlvMove(pDB, requiredPos, fForward, ContainerID);
                            }
                        }

                        if(!dbIsInVLVContainer(pDB, ContainerID)) {
                            DPRINT (1, "FAILED adjusting position\n");
                            return DB_ERR_NO_CURRENT_RECORD;
                        }
                    }

                    // Get fractional position of current position.
                    DBGetFractionalPosition(pDB, &EndNum, &EndDenom);

                    DPRINT2 (1, "Found Position: %d / %d \n", EndNum, EndDenom);

                    EndNum = MulDiv(EndNum, ContainerDenominator, EndDenom);

                    DPRINT2 (1, "Adj. Position: %d / %d \n", EndNum, ContainerDenominator);

                    pVLV->currPosition = NormalizeIndexPosition (ContainerNumeratorBegin, EndNum);

                    DPRINT2 (1, "Calculated Position: %d / %d \n", 
                             pVLV->currPosition, pVLV->contentCount);
                }
            }
        }

        // get the key on the current position for later
        pVLV->cbCurrPositionKey = sizeof (pVLV->rgbCurrPositionKey);
        DBGetKeyFromObjTable(pDB,
                             pVLV->rgbCurrPositionKey,
                             &pVLV->cbCurrPositionKey);

        // now account for the beforeCount
        deltaCount = pVLV->pVLVRequest->beforeCount;

        while (deltaCount > 0) {
            err = dbVlvMove(pDB, fForward ? DB_MovePrevious : DB_MoveNext, fForward, ContainerID);

            if (err!=0) {
                break;
            }
            deltaCount--;
        }

        if (deltaCount) {
            pVLV->requestedEntries -= deltaCount;
        }
    }

    return 0;
} // dbVlvSetFractionalPosition

DWORD
dbMoveToNextSearchCandidateOnInMemoryTempTable (
        DBPOS *pDB,
        ULONG Flags,
        DWORD StartTick,
        DWORD DeltaTick
        )
/*++

Routine Description:

    Move to the next object in the in memory temp table. 
    If we are seeking to a value, this is treated accordingly.
    The current position in the array is updated.

Arguments:

    same as dbMoveToNextSearchCandidate

Return Values:

    0 if all went well and we found a next candidate, DB_ERR_NEXTCHILD_NOTFOUND
    if no next candidate could be found.

--*/
{
    THSTATE  *pTHS=pDB->pTHS;
    BOOL      fForward = Flags & DB_SEARCH_FORWARD;
    DWORD     err;

    wchar_t  *pTempW = NULL;
    DWORD     cb=0;
    DWORD     dwBegin, dwEnd, dwMiddle, compValue, deltaCount;
    BOOL      fFound=FALSE;
    ATTCACHE *pAC;
    ATTRVAL  *seekVal;
    VLV_SEARCH *pVLV = pDB->Key.pVLV;

    Assert (pVLV);
    
    // If the restriction is empty, we can't find anything.
    if (pDB->Key.cdwCountDNTs == 0) {
        pDB->Key.currRecPos = 0;
        return DB_ERR_NEXTCHILD_NOTFOUND;
    }

    pAC = SCGetAttById(pTHS, pVLV->SortAttr);
    Assert (pAC);  // PREFIX: it is valid not to check the pAC

    // if we are seeking to a particular value for the first time
    if (!pDB->Key.fSearchInProgress) {

        // we are looking for a specific key value
        if (pVLV->pVLVRequest->fseekToValue) {

            seekVal= &pVLV->pVLVRequest->seekValue;
            
            // get the last entry
            if (fForward) {
                if (err = DBTryToFindDNT(pDB, pDB->Key.pDNTs[pDB->Key.cdwCountDNTs-1])) {
                    return err;
                }
            }
            else {
                if (err = DBTryToFindDNT(pDB, pDB->Key.pDNTs[0])) {
                    return err;
                }
            }

            cb = DB_CB_MAX_KEY;
            pTempW = THAllocEx (pTHS, cb);

            switch(err = DBGetSingleValue(pDB, pAC->id, pTempW, cb, &cb)) {
                case DB_ERR_VALUE_TRUNCATED:
                    pTempW = THReAllocEx (pTHS, pTempW, cb + sizeof(wchar_t));
                    err = DBGetSingleValue(pDB, pAC->id, pTempW, cb, &cb);
                    // Fall through
                case 0:
                    // Fall through
                default:
                    break;
            }

            // check if last entry is less than our target
            compValue = CompareStringW(pTHS->dwLcid,
                              DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                              (wchar_t *)seekVal->pVal,
                              seekVal->valLen / sizeof(wchar_t),
                              pTempW,
                              cb / sizeof(wchar_t) );
                
            if (compValue > 2 && fForward) {
                DPRINT1 (1, "VLV Seek Last Beyond End of List: %ws\n", pTempW);

                // Nothing in restriction is GE the target.
                // set to last entry
                pVLV->currPosition = pDB->Key.currRecPos = pDB->Key.cdwCountDNTs;
            }
            else if (!fForward && compValue < 2) {
                DPRINT1 (1, "VLV Seek Last Beyond Start of List: %ws\n", pTempW);
                
                // Nothing in restriction is LE the target.
                // set to last entry
                pVLV->currPosition = pDB->Key.cdwCountDNTs;
                pDB->Key.currRecPos = 1;
            }
            else {
                // Set the bounds for our binary sort
                dwMiddle = dwBegin = 0;
                dwEnd = pDB->Key.cdwCountDNTs - 1;

                while(!fFound) {
                    dwMiddle = (dwBegin + dwEnd ) / 2;
                    if (err = DBTryToFindDNT(pDB, pDB->Key.pDNTs[dwMiddle] )) {
                        return err;
                    }

                    switch(DBGetSingleValue(pDB, pAC->id, pTempW, cb, &cb)) {
                        case DB_ERR_VALUE_TRUNCATED:
                            pTempW = THReAllocEx (pTHS, pTempW, cb + sizeof(wchar_t));
                            DBGetSingleValue(pDB, pAC->id, pTempW, cb, &cb);
                            // Fall through
                        case 0:
                            // Fall through
                        default:
                            break;
                    }

                    compValue = CompareStringW(pTHS->dwLcid,
                                               DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                               (wchar_t *)seekVal->pVal,
                                               seekVal->valLen / sizeof(wchar_t),
                                               pTempW,
                                               cb / sizeof(wchar_t) );

                    if(compValue <= 2) {
                        // target is LE this one, search front 
                        if(dwEnd == dwMiddle) { // this last entry left?   
                            dwMiddle = dwBegin; // then we're done         
                            fFound = TRUE;      // break out of while loop 
                        }
                        dwEnd = dwMiddle;
                    }
                    else {
                        if(dwBegin == dwMiddle) { // this last entry?        
                            dwMiddle++;
                            fFound = TRUE;        // break out of while loop 
                        }
                        dwBegin = dwMiddle;
                    }
                }

                // We're at the first dnt >= the target. 
                pVLV->currPosition = pDB->Key.currRecPos = dwMiddle + 1;

                // adjust our pos depending on the direction of the navigation
                if (!fForward) {
                    pVLV->currPosition = pVLV->contentCount - pVLV->currPosition + 1;
                }
            }


            // adjust for the before Count
            deltaCount = pVLV->pVLVRequest->beforeCount;
            
            if (fForward) {
                if (pVLV->currPosition > deltaCount) {
                    pDB->Key.currRecPos -= deltaCount;
                }
                else {
                    deltaCount = deltaCount - pVLV->currPosition + 1;
                    pVLV->requestedEntries -= deltaCount;
                    pDB->Key.currRecPos = 1;
                }
            }
            else {
                if (pVLV->currPosition > deltaCount) {
                    pDB->Key.currRecPos += deltaCount;
                }
                else {
                    deltaCount = deltaCount - pDB->Key.currRecPos + 1;
                    pVLV->requestedEntries -= deltaCount;
                    pDB->Key.currRecPos = pDB->Key.cdwCountDNTs;
                }
            }

            if (err = DBTryToFindDNT(pDB, pDB->Key.pDNTs[pDB->Key.currRecPos-1] )) {
                return err;
            }

            #ifdef DBG
                DBGetSingleValue(pDB, pAC->id, pTempW, cb, &cb);
                DPRINT1 (1, "VLV Positioned on %ws\n", pTempW);
            #endif

            THFreeEx(pTHS, pTempW);
        }
        // we are looking for a specified position
        else {
            Assert (pDB->Key.cdwCountDNTs == pVLV->contentCount);

            dbVlvSetFractionalPosition (pDB, Flags);

            if (err = DBTryToFindDNT(pDB, pDB->Key.pDNTs[pDB->Key.currRecPos-1] )) {
                return err;
            }
            
            #ifdef DBG
                cb = DB_CB_MAX_KEY;
                pTempW = THAllocEx (pTHS, cb);

                DBGetSingleValue(pDB, pAC->id, pTempW, cb, &cb);
                DPRINT1 (1, "VLV Positioned on %ws\n", pTempW);

                THFreeEx(pTHS, pTempW);
            #endif
        }
    }
    // search already in progress
    else {
        // we are already positioned on the InMemory sorted table
        // either by seeking to a value or directly

        // going forward
        if(fForward) {
            if (pDB->Key.fSearchInProgress) {
                // if we are already positioned, go to next
                pDB->Key.currRecPos++;
            }
            else {
                // set to first Entry
                pDB->Key.currRecPos = 1;
            }

            if (pDB->Key.currRecPos <= pDB->Key.cdwCountDNTs) {
                if (err = DBTryToFindDNT(pDB, pDB->Key.pDNTs[pDB->Key.currRecPos - 1] )) {
                    return err;
                }
            }
            else {
                // set to EOF
                pDB->Key.currRecPos = pDB->Key.cdwCountDNTs + 1;
                return DB_ERR_NEXTCHILD_NOTFOUND;
            }
        }
        // going backward
        else {
            if (pDB->Key.fSearchInProgress) {
                // if we are already positioned, go to previous
                if (pDB->Key.currRecPos >=1) {
                    pDB->Key.currRecPos--;
                }
            }
            else {
                // set to last entry
                pDB->Key.currRecPos = pDB->Key.cdwCountDNTs;
            }

            if (pDB->Key.currRecPos &&
                pDB->Key.currRecPos <= pDB->Key.cdwCountDNTs) {
                if (err = DBTryToFindDNT(pDB, pDB->Key.pDNTs[pDB->Key.currRecPos - 1] )) {
                    return err;
                }
            }
            else {
                pDB->Key.currRecPos = 0;
                return DB_ERR_NEXTCHILD_NOTFOUND;
            }
        }
    }

    return 0;
} // dbMoveToNextSearchCandidateOnInMemoryTempTable 

DWORD dbMoveToNextSearchCandidateOnASQ (DBPOS *pDB,
                                        ULONG Flags,
                                        DWORD StartTick,
                                        DWORD DeltaTick)
/*++

Routine Description:

    Move to the next object in the memory table used for ASQ. 
    If more entries are needed to be read, we read more.
    Paged requests are handled accordingly.

Arguments:

    same as dbMoveToNextSearchCandidate

Return Values:

    0 if all went well and we found a next candidate, DB_ERR_NEXTCHILD_NOTFOUND
    if no next candidate could be found.

--*/
{
    DWORD err;
    BOOL  fForward = Flags & DB_SEARCH_FORWARD;

    if (!pDB->Key.cdwCountDNTs) {
        return DB_ERR_NEXTCHILD_NOTFOUND;
    }

    Assert (pDB->Key.pDNTs);

    // if we are seeking to a particular value for the first time
    if (!pDB->Key.fSearchInProgress) {

        if (fForward) {
            // if this is not a paged search, we start at the beggining of
            // the database records (ulASQLastUpperBound=0)
            if (! (pDB->Key.asqMode & ASQ_PAGED) ) {
                pDB->Key.ulASQLastUpperBound = 0;
                pDB->Key.currRecPos = 1;
            }
            // if this is sorted and paged, we start at the point we were
            // before (ulASQLastUpperBound+1). all the data are in the array
            else if ( (pDB->Key.asqMode == (ASQ_SORTED | ASQ_PAGED)) ) {
                pDB->Key.currRecPos = pDB->Key.ulASQLastUpperBound + 1;
            }
            // this is a paged search. we start at the start of the array 
            // and we keep our database position unchanged (ulASQLastUpperBound)
            else {
                pDB->Key.currRecPos = 1;
            }
        }
        else {
            // we cannot do paged results in reverse order, unless
            // we are using sorted results, so we have all the data
            // in memory

            if (pDB->Key.ulASQLastUpperBound == 0 &&
                pDB->Key.cdwCountDNTs != pDB->Key.ulASQLastUpperBound) {
                pDB->Key.ulASQLastUpperBound = pDB->Key.cdwCountDNTs - 1;
            }
            
            // so if this is not paged, we start at the end of the array
            // otherwise where we left last time
            if (! (pDB->Key.asqMode & ASQ_PAGED) ) {
                pDB->Key.ulASQLastUpperBound = pDB->Key.cdwCountDNTs - 1;
                pDB->Key.currRecPos = pDB->Key.cdwCountDNTs;
            }
            else if ( (pDB->Key.asqMode == (ASQ_SORTED | ASQ_PAGED)) ) {
                pDB->Key.currRecPos = pDB->Key.ulASQLastUpperBound + 1;
            }
            else {
                Assert (!"Reverse ASQ paged search");
                pDB->Key.currRecPos = pDB->Key.cdwCountDNTs;
            }
        }
    }
    else {
        if (fForward) {
            // advance our position on the array and on the database
            pDB->Key.currRecPos++;
            pDB->Key.ulASQLastUpperBound++;

            // if we run out of entries in memory, and we are not doing sorted 
            // search, read some more
            if (pDB->Key.currRecPos > pDB->Key.cdwCountDNTs) {
                if (! (pDB->Key.asqMode & ASQ_SORTED) ) {
                    if (err = dbCreateASQTable(pDB, 
                                               StartTick, 
                                               DeltaTick, 
                                               pDB->Key.ulASQSizeLimit,
                                               FALSE,
                                               0) ) {

                        return DB_ERR_NEXTCHILD_NOTFOUND;
                    }

                    pDB->Key.currRecPos = 1;
                }
                else {
                    return DB_ERR_NEXTCHILD_NOTFOUND;
                }
            }
        }
        else {
            pDB->Key.currRecPos--;
            
            // we don't support getting paged results backwards, 
            // since we don't know the total number of entries
            // unless we were doing a sorted search
            if (pDB->Key.currRecPos == 0) {
                return DB_ERR_NEXTCHILD_NOTFOUND;
            }

            if (pDB->Key.ulASQLastUpperBound) {
                pDB->Key.ulASQLastUpperBound--;
            }
            else {
                return DB_ERR_NEXTCHILD_NOTFOUND;
            }
        }
    }

    if (err = DBTryToFindDNT(pDB, pDB->Key.pDNTs[pDB->Key.currRecPos - 1] )) {
        return err;
    }

    return 0;
}

DWORD
dbMoveToNextSearchCandidateOnIndex(DBPOS *pDB, ULONG Flags)
/*++

Routine Description:

    Move to the next object position on the current index.
    Assumes that we are already positioned on the index.

Arguments:

    same as dbMoveToNextSearchCandidate

Return Values:

    0 if all went well and we found a next candidate, Jet error otherwise.

--*/
{
    DWORD       err;
    BOOL        fForward = Flags & DB_SEARCH_FORWARD;
    
    err = JetMoveEx(pDB->JetSessID, 
                    pDB->JetObjTbl, 
                    (fForward?JET_MoveNext:JET_MovePrevious),
                    0);

    if (pDB->Key.pVLV) {
        
        Assert (pDB->Key.ulSearchType == SE_CHOICE_IMMED_CHLDRN);
        Assert (pDB->Key.pIndex->bIsPDNTBased || pDB->Key.pVLV->bUsingMAPIContainer);

        if (err != JET_errNoCurrentRecord) {


            if ( !dbIsInVLVContainer(pDB, pDB->Key.pVLV->bUsingMAPIContainer ?
                                     pDB->Key.pVLV->MAPIContainerDNT : 
                                     pDB->Key.ulSearchRootDnt)) {
                err = JET_errNoCurrentRecord;
            }
        }
    }

    return err;
} // dbMoveToNextSearchCandidateOnIndex 

DWORD
dbMoveToNextSearchCandidatePositionOnVLVIndex(
                DBPOS *pDB,
                ULONG Flags
                )
/*++

Routine Description:

    Position on the first candidate on the VLV index.

Arguments:

    pDB - the DBPos to use.
    
    Flags - flags describing the behaviour.  Values are:
      DB_SEARCH_FORWARD - movement in the database is forward, not backward.

Return Values:

    0 if all went well and we found a next candidate, Jet error otherwise.

--*/

{
    DWORD    err;
    BOOL     fForward = Flags & DB_SEARCH_FORWARD;
    ATTRVAL *seekVal;
    DWORD    deltaCount;
    VLV_SEARCH *pVLV = pDB->Key.pVLV;


    Assert (pVLV);
    Assert (pDB->Key.ulSearchType == SE_CHOICE_IMMED_CHLDRN);
    Assert (pDB->Key.pIndex->bIsPDNTBased || pDB->Key.pVLV->bUsingMAPIContainer);

    // we are looking for a specific value
    if (pVLV->pVLVRequest->fseekToValue) {
        DWORD Denominator, Numerator;
        DWORD BeginDenom, BeginNum, EndDenom, EndNum;
        DWORD ContainerDenominator, ContainerNumerator;
        DWORD ContainerID = pDB->Key.pVLV->bUsingMAPIContainer ? 
                                    pDB->Key.pVLV->MAPIContainerDNT : 
                                    pDB->Key.ulSearchRootDnt;

        seekVal = &pVLV->pVLVRequest->seekValue;

        // Get fractional position of beginning
        if (err = dbVlvMove(pDB, DB_MoveFirst, TRUE, ContainerID)) {
            return err;
        }
        DBGetFractionalPosition(pDB, &BeginNum, &BeginDenom);

        // Get fractional position of ending
        if (err = dbVlvMove(pDB, DB_MoveLast, TRUE, ContainerID)) {
            return err;
        }
        DBGetFractionalPosition(pDB, &EndNum, &EndDenom);

        // Normalize the fractions of the fractional position to the average of
        // the two denominators.
        Denominator = (BeginDenom + EndDenom)/2;
        EndNum = MulDiv(EndNum, Denominator, EndDenom);
        BeginNum = MulDiv(BeginNum, Denominator, BeginDenom);

        // keep values for later
        ContainerNumerator = BeginNum;
        ContainerDenominator = Denominator;

        // calculate container size, since it might have changed
        pVLV->contentCount = NormalizeIndexPosition (BeginNum, EndNum);
        
        // we need better content size estimation since this container does not 
        // have enough entries
        // note we are positioned in the end of the container
        if (pVLV->contentCount < EPSILON) {
            ULONG newCount=0;
            if (dbIsInVLVContainer(pDB, ContainerID)) {
                newCount=1;

                while ( !(err = dbVlvMove(pDB, DB_MovePrevious, TRUE, ContainerID))) {
                    newCount++;
                }
            }
            pVLV->contentCount = newCount;
        }

        // position on the first record that matches
        // our criteria
        JetMakeKeyEx(pDB->JetSessID,
                     pDB->JetObjTbl,
                     &ContainerID,
                     sizeof(ContainerID),
                     JET_bitNewKey);

        JetMakeKeyEx(pDB->JetSessID, 
                     pDB->JetObjTbl,
                     seekVal->pVal,
                     seekVal->valLen,
                     0);

        err = JetSeekEx(pDB->JetSessID, 
                        pDB->JetObjTbl,
                        JET_bitSeekGE);

        // if we couldn't find a record, we want to be positioned
        // on the last record of this container
        if (err == JET_errRecordNotFound) {

            pVLV->currPosition = pVLV->contentCount;
            
            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetObjTbl,
                         pDB->Key.pIndex->rgbDBKeyUpper,
                         pDB->Key.pIndex->cbDBKeyUpper,
                         JET_bitNormalizedKey);

            err = JetSeekEx(pDB->JetSessID, pDB->JetObjTbl, JET_bitSeekLE); 
            
            if((err != JET_errRecordNotFound) &&
               !dbIsInVLVContainer(pDB, ContainerID)) {
                    return  DB_ERR_NO_CURRENT_RECORD;
            }
        }

        // Get fractional position of current position.
        DBGetFractionalPosition(pDB, &EndNum, &EndDenom);

        DPRINT2 (1, "Found Position: %d / %d \n", EndNum, EndDenom);

        EndNum = MulDiv(EndNum, ContainerDenominator, EndDenom);
        pVLV->currPosition = NormalizeIndexPosition (ContainerNumerator, EndNum);

        if (pVLV->currPosition > pVLV->contentCount) {
            pVLV->currPosition = pVLV->contentCount;
        }
        
        DPRINT2 (0, "Calculated Position: %d / %d \n", 
                 pVLV->currPosition, pVLV->contentCount);

        // adjust our pos depending on the direction of the navigation
        if (!fForward) {
            pVLV->currPosition = pVLV->contentCount - pVLV->currPosition + 1;
        }

        DPRINT2 (0, "Calculated Position: %d / %d \n", 
                 pVLV->currPosition, pVLV->contentCount);


        if ( (err != JET_errRecordNotFound) &&
             (err != JET_errNoCurrentRecord) ) {

            // get the key on the current position for later
            pVLV->cbCurrPositionKey = sizeof (pVLV->rgbCurrPositionKey);
            DBGetKeyFromObjTable(pDB,
                                 pVLV->rgbCurrPositionKey,
                                 &pVLV->cbCurrPositionKey);

            // now we want to move backwards for beforeCount entries,
            // staying in the same container

            deltaCount = pVLV->pVLVRequest->beforeCount;

            DPRINT1 (1, "Moving Backwards %d \n", deltaCount);

            while (deltaCount) {

                // forward is backward and vice versa
                err = JetMoveEx(pDB->JetSessID, 
                                pDB->JetObjTbl, 
                                (fForward?JET_MovePrevious:JET_MoveNext ),
                                0);

                // we moved past one end of the index or the container
                // back up one
                if ((err == JET_errNoCurrentRecord) ||
                    !dbIsInVLVContainer(pDB, ContainerID)) {

                    DPRINT1 (0, "Moved past one end (remaining: %d) \n", deltaCount);

                    err = JetMoveEx(pDB->JetSessID, 
                                    pDB->JetObjTbl, 
                                    (fForward?JET_MoveNext:JET_MovePrevious ),
                                    0);
                    break;
                }
                deltaCount--;
            }

            // now we are positioned on the correct entry
            // adjust requested entries since we might be before start
            pVLV->requestedEntries -= deltaCount;
        }

    }
    else {
        return dbVlvSetFractionalPosition (pDB, Flags);
    }

    return err;
}

DWORD
dbMoveToNextSearchCandidatePositionOnIndex(
                DBPOS *pDB,
                ULONG Flags
                )
/*++

Routine Description:

    Position on the first candidate on the index.

Arguments:

    pDB - the DBPos to use.
    
    Flags - flags describing the behaviour.  Values are:
      DB_SEARCH_FORWARD - movement in the database is forward, not backward.

Return Values:

    0 if all went well and we found a next candidate, Jet error otherwise.
--*/
{
    BOOL        fForward = Flags & DB_SEARCH_FORWARD;
    ULONG       actuallen;
    DWORD       err = 0;

    JetSetCurrentIndexSuccess(pDB->JetSessID, pDB->JetObjTbl,
                              pDB->Key.pIndex->szIndexName);
    if(!strcmp(pDB->Key.pIndex->szIndexName, SZANCESTORSINDEX)) {
        pDB->Key.indexType = ANCESTORS_INDEX_TYPE;
    }
    else if (!strncmp(pDB->Key.pIndex->szIndexName, SZTUPLEINDEXPREFIX, (sizeof(SZTUPLEINDEXPREFIX) - 1))) {
        pDB->Key.indexType = TUPLE_INDEX_TYPE;
    }
    else {
        pDB->Key.indexType = GENERIC_INDEX_TYPE;
    }

    // this is a VLV search 
    if (pDB->Key.pVLV) {
        return dbMoveToNextSearchCandidatePositionOnVLVIndex (pDB, Flags);
    }
    // simple search (non VLV).
    else if(fForward) {
        if (pDB->Key.pIndex->cbDBKeyLower) {
            JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl,
                         pDB->Key.pIndex->rgbDBKeyLower,
                         pDB->Key.pIndex->cbDBKeyLower,
                         JET_bitNormalizedKey);

            err = JetSeekEx(pDB->JetSessID, pDB->JetObjTbl,
                            JET_bitSeekGE); 
        }
        else {
            err = JetMoveEx(pDB->JetSessID, pDB->JetObjTbl,
                            JET_MoveFirst, 0);
        }

        switch (err) {
        case JET_errSuccess:
        case JET_wrnRecordFoundGreater:
            if(pDB->Key.pIndex->cbDBKeyUpper) {
                // Now, set an index range.
#if DBG
                BYTE        rgbKey[DB_CB_MAX_KEY];
                // For the debug case, we're going to do some extra
                // verification.  This is just checking, not necessary
                // for the algorithm.
                JetRetrieveKeyEx(pDB->JetSessID,
                                 pDB->JetObjTbl,
                                 rgbKey,
                                 sizeof(rgbKey),
                                 &actuallen, 0);
#endif                        

                JetMakeKeyEx(pDB->JetSessID,
                             pDB->JetObjTbl,
                             pDB->Key.pIndex->rgbDBKeyUpper,
                             pDB->Key.pIndex->cbDBKeyUpper,
                             JET_bitNormalizedKey);
                err = JetSetIndexRange(pDB->JetSessID,
                                       pDB->JetObjTbl,
                                       (JET_bitRangeUpperLimit |
                                        JET_bitRangeInclusive ));
                // The only error we allow here should be
                // nocurrentrecord, and we should only hit it if the
                // key we pulled off the object before the
                // setindexrange is greater than the key we are
                // setting in the index range.
                Assert((err == JET_errSuccess) ||
                       ((err == JET_errNoCurrentRecord) &&
                        (0 < memcmp(
                                rgbKey,
                                pDB->Key.pIndex->rgbDBKeyUpper,
                                min(actuallen,
                                    pDB->Key.pIndex->cbDBKeyUpper)))));

            }
            break;
        default:
            break;
        }
    }
    // moving backwards
    else {
        if(pDB->Key.pIndex->cbDBKeyUpper == DB_CB_MAX_KEY &&
           !memcmp(pDB->Key.pIndex->rgbDBKeyUpper,
                   MAX_UPPER_KEY, DB_CB_MAX_KEY)) {
            // We are really moving to the last object.
            err = JetMoveEx(pDB->JetSessID, pDB->JetObjTbl,
                            JET_MoveLast, 0);
        }
        else {
            JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl,
                         pDB->Key.pIndex->rgbDBKeyUpper,
                         pDB->Key.pIndex->cbDBKeyUpper,
                         JET_bitNormalizedKey);

            err = JetSeekEx(pDB->JetSessID, pDB->JetObjTbl,
                            JET_bitSeekLE);
        }

        switch (err) {
        case JET_errSuccess:
        case JET_wrnRecordFoundGreater:
            if(pDB->Key.pIndex->cbDBKeyLower) {
                // Now, set an index range.
#if DBG
                BYTE        rgbKey[DB_CB_MAX_KEY];
                // For the debug case, we're going to do some extra
                // verification.  This is just checking, not necessary
                // for the algorithm.
                JetRetrieveKeyEx(pDB->JetSessID,
                                 pDB->JetObjTbl,
                                 rgbKey,
                                 sizeof(rgbKey),
                                 &actuallen, 0);
#endif                        


                JetMakeKeyEx(pDB->JetSessID,
                             pDB->JetObjTbl,
                             pDB->Key.pIndex->rgbDBKeyLower,
                             pDB->Key.pIndex->cbDBKeyLower,
                             JET_bitNormalizedKey);

                err = JetSetIndexRange(pDB->JetSessID,
                                       pDB->JetObjTbl,
                                       JET_bitRangeInclusive);
                // The only error we allow here should be
                // nocurrentrecord, and we should only hit it if the
                // key we pulled off the object before the
                // setindexrange is greater than the key we are
                // setting in the index range.
                Assert((err == JET_errSuccess) ||
                       ((err == JET_errNoCurrentRecord) &&
                        (0 < memcmp(
                                rgbKey,
                                pDB->Key.pIndex->rgbDBKeyLower,
                                min(actuallen,
                                    pDB->Key.pIndex->cbDBKeyLower)))));
            }
            break;

        default:
            break;
        }

    } // forward / backward

    return err;
} // dbMoveToNextSearchCandidatePositionOnIndex

DWORD
dbMoveToNextSearchCandidate (
        DBPOS *pDB,
        ULONG Flags,
        DWORD StartTick,
        DWORD DeltaTick
        )
/*++

Routine Description:

    Move to the next object on the current index which is a potential search
    result item. Movement is done one object at a time on the current index
    unless otherwise specified (see Flags below).

Arguments:

    pDB - the DBPos to use.

    Flags - flags describing the behaviour.  Values are:

      DB_SEARCH_FORWARD - movement in the database is forward, not backward.

    StartTick - if !0, specifies a time limit is in effect, and this is the tick
            count when the call was started.
    DeltaTick - if a time limit is in effect, this is the maximum number of
            ticks past StartTick to allow.

Return Values:

    0 if all went well and we found a next candidate, DB_ERR_NEXTCHILD_NOTFOUND
    if no next candidate could be found.
    

--*/
{
    THSTATE    *pTHS=pDB->pTHS;
    JET_ERR     err = 0;
    ULONG       PDNT;
    BOOL        fForward = Flags & DB_SEARCH_FORWARD;
    KEY_INDEX  *pTempIndex;
    BOOL        fFirst = TRUE;
   
    
    unsigned char rgbBookmark[JET_cbBookmarkMost];
    unsigned long cbBookmark;
    
    Assert(VALID_DBPOS(pDB));

    pDB->Key.bOnCandidate = FALSE;
    Assert(pDB->Key.indexType != INVALID_INDEX_TYPE);
    
    if (pDB->Key.ulSearchType == SE_CHOICE_BASE_ONLY && !pDB->Key.asqRequest.fPresent) {
        if (pDB->Key.fSearchInProgress) {
            Assert(pDB->Key.indexType == GENERIC_INDEX_TYPE);
            // Hey, this is a base object search, and we're already in
            // progress.  Therefore, we have already looked at the base and
            // there is nothing more to do.
            return DB_ERR_NEXTCHILD_NOTFOUND;
        }
        else {
            // Don't need all the stuff here, just seek to the base
            DBFindDNT(pDB, pDB->Key.ulSearchRootDnt);

            pDB->Key.fSearchInProgress = TRUE;
            Assert(pDB->Key.indexType == UNSET_INDEX_TYPE);
            pDB->Key.indexType = GENERIC_INDEX_TYPE;
            pDB->Key.bOnCandidate = TRUE;

            // PERFINC(pcSearchSubOperations);
            pDB->SearchEntriesVisited += 1;

            return 0;
        }
    }

    while (TRUE) { // Do this always

        PERFINC(pcSearchSubOperations);
        pDB->SearchEntriesVisited += 1;

        if(   eServiceShutdown
           && !(   (eServiceShutdown == eRemovingClients)
                && (pTHS->fDSA)
                && !(pTHS->fSAM))) {
            // Shutting down, bail.
            return DB_ERR_NEXTCHILD_NOTFOUND;
        }
        if(!fFirst) {
            // OK, we've been through at least once, so we made some kind of
            // progress.  See if we hit a time limit.
            if(StartTick) {       // There is a time limit
                if((GetTickCount() - StartTick) > DeltaTick) {
                    return DB_ERR_TIMELIMIT;
                }
            }
        }
        fFirst = FALSE;


        // First, position on the next candidate object.  There are three cases:
        // 1) moving in a temp table or a intersected table
        //    a) sorted or sorted/paged search from a sort table        OR
        //    b) ASQ search without VLV                                 OR
        //    c) VLV or ASQ/VLV                                         OR
        //    d) sorted or sorted/paged search from an in memory array  OR
        //    e) intersected table 
        //
        // 2) search in progress, we've already got an index, just move to the
        //        next object on the index
        //
        // 3) no search in progress, we need to set to the correct index and
        //        seek to the first object.
        
        if(pDB->Key.indexType == TEMP_TABLE_INDEX_TYPE) {
            // CASE 1a: We're moving in a sort table.
            DWORD DNT, dwMove, cbActual;
            
            // We have a sort table we're using
            dwMove = (pDB->Key.fSearchInProgress?JET_MoveNext:JET_MoveFirst);

            do {
                // First, move in the sort table
                err = JetMove(pDB->JetSessID,
                              pDB->JetSortTbl,
                              dwMove,
                              0);
                if(err) {
                    // end of sort table
                    return DB_ERR_NEXTCHILD_NOTFOUND;
                }

                dwMove = JET_MoveNext;

                // OK, pull the DNT out of the sort table
                DBGetDNTSortTable (
                        pDB,
                        &DNT);
                
                // Now move to that DNT in the object table
            } while(DBTryToFindDNT(pDB, DNT));
        }
        else if (pDB->Key.indexType == TEMP_TABLE_MEMORY_ARRAY_TYPE) {

            if (pDB->Key.asqRequest.fPresent && !pDB->Key.pVLV) {
                // CASE 1b: this is an ASQ search without combining VLV
                // so it is either simple, sorted or paged

                if (err = dbMoveToNextSearchCandidateOnASQ (pDB, 
                                                            Flags, 
                                                            StartTick, 
                                                            DeltaTick)) {
                    return DB_ERR_NEXTCHILD_NOTFOUND;
                }
            }
            else if (pDB->Key.pVLV) {
                // CASE 1c: We're moving in a InMemory sorted table.
                // this is either VLV or VLV/ASQ

                if (err = dbMoveToNextSearchCandidateOnInMemoryTempTable(pDB, Flags,
                                                                         StartTick, 
                                                                         DeltaTick)) {
                    return DB_ERR_NEXTCHILD_NOTFOUND;
                }
            }
            else {
                // CASE 1d: We're moving in a InMemory sorted table holding a
                // sorted or sorted/paged search
                DWORD   DNT;
                BOOL    fSearchInProgress;

                fSearchInProgress = pDB->Key.fSearchInProgress;

                do {
                    if (fSearchInProgress) {
                        pDB->Key.currRecPos++;
                    }
                    else {
                        pDB->Key.currRecPos = 1;
                    }

                    if (pDB->Key.currRecPos > pDB->Key.cdwCountDNTs) {
                        pDB->Key.currRecPos = pDB->Key.cdwCountDNTs + 1;
                        return DB_ERR_NEXTCHILD_NOTFOUND;
                    }
                    
                    fSearchInProgress = TRUE;

                    DNT = pDB->Key.pDNTs[pDB->Key.currRecPos - 1];
                } while(DBTryToFindDNT(pDB, DNT));
            }
        }
        else if (pDB->Key.pIndex && pDB->Key.pIndex->bIsIntersection) {
            // CASE 1e: We're moving in a intersected table.

            if (pDB->Key.indexType == UNSET_INDEX_TYPE) {

                if(fForward) {
                    err = JetMoveEx( pDB->JetSessID, pDB->Key.pIndex->tblIntersection, 
                                     JET_MoveFirst, 0 );
                }
                else {
                    err = JetMoveEx( pDB->JetSessID, pDB->Key.pIndex->tblIntersection, 
                                     JET_MoveLast, 0 );
                }

                pDB->Key.indexType = INTERSECT_INDEX_TYPE;
            }
            else {

                if(fForward) {
                    err = JetMoveEx(pDB->JetSessID, pDB->Key.pIndex->tblIntersection,
                                    JET_MoveNext, 0);
                }
                else {
                    err = JetMoveEx(pDB->JetSessID, pDB->Key.pIndex->tblIntersection,
                                    JET_MovePrevious, 0);
                }
            }

            if (err == JET_errSuccess) {
                if (! (err = JetRetrieveColumn(
                                    pDB->JetSessID,
                                    pDB->Key.pIndex->tblIntersection,
                                    pDB->Key.pIndex->columnidBookmark,
                                    rgbBookmark,
                                    sizeof( rgbBookmark ),
                                    &cbBookmark,
                                    0,
                                    NULL )) ) {
    
                    err = JetGotoBookmark( pDB->JetSessID,
                                   pDB->JetObjTbl,
                                   rgbBookmark, 
                                   cbBookmark );
                }
            }
        }
        else if (pDB->Key.fSearchInProgress) {
            Assert(pDB->Key.indexType != INVALID_INDEX_TYPE);
            Assert(pDB->Key.indexType != UNSET_INDEX_TYPE);
            Assert(pDB->Key.indexType != TEMP_TABLE_INDEX_TYPE);

            // Case 2) Normal case of looking for the next search candidate.
            err = dbMoveToNextSearchCandidateOnIndex(pDB, Flags); 
        }
        else {
            Assert(pDB->Key.indexType == UNSET_INDEX_TYPE || pDB->Key.pVLV);

            // Case 3) Looking for the very first search candidate on this index. 
            err = dbMoveToNextSearchCandidatePositionOnIndex(pDB, Flags);
        }
            

        switch (err) {
        case JET_errSuccess:
        case JET_wrnRecordFoundGreater:
            break;
            
        case JET_errNoCurrentRecord:
        case JET_errRecordNotFound:
            // We didn't find anymore children on this index.  If we have more
            // indices, recursively call down using the next index.
            if(pDB->Key.pIndex && pDB->Key.pIndex->pNext) {
                // Yep, more indices
                pTempIndex = pDB->Key.pIndex;
                pDB->Key.pIndex = pDB->Key.pIndex->pNext;
                pTempIndex->pNext = NULL;
                dbFreeKeyIndex(pTHS, pTempIndex);
                pDB->Key.fSearchInProgress = FALSE;
                pDB->Key.indexType = UNSET_INDEX_TYPE;

                return dbMoveToNextSearchCandidate (pDB, Flags, StartTick,
                                                    DeltaTick);
            }
            else {
                // Nope, no more indices.  We're done.
                return DB_ERR_NEXTCHILD_NOTFOUND;
            }
            
        default:
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
        }

        
#if DBG
        // We've moved to an object,  Let's verify that it's in range.
        if(!SORTED_INDEX (pDB->Key.indexType) && 
           !pDB->Key.pIndex->bIsIntersection) {
            BYTE        rgbKey[DB_CB_MAX_KEY];
            int         compareResult;
            ULONG       cb;
            ULONG       actuallen;
            
            Assert(pDB->Key.pIndex);
            // We are using an index of some nature, not the JetSortTable.
            // Lets verify that we're in the right portion of the index.
            JetRetrieveKeyEx(pDB->JetSessID,
                             pDB->JetObjTbl,
                             rgbKey,
                             sizeof(rgbKey),
                             &actuallen, 0);
            
            // check that key is in range
            cb = min(actuallen,pDB->Key.pIndex->cbDBKeyUpper);
            compareResult = memcmp(rgbKey, pDB->Key.pIndex->rgbDBKeyUpper, cb);
            Assert(compareResult <= 0);
        }
#endif            

        // At this point, we've moved to an object that is definitely in the
        // correct place in the index that we are currently walking.
        pDB->Key.fSearchInProgress = TRUE;
        Assert(pDB->Key.indexType != UNSET_INDEX_TYPE);
        Assert(pDB->Key.indexType != INVALID_INDEX_TYPE);
        
        if(DIRERR_NOT_AN_OBJECT == dbMakeCurrent(pDB, NULL)) {
            // Hey, we're not really on an object, so this can't be a candidate
            // unless we are doing ASQ

            if (pDB->Key.asqRequest.fPresent) {
                if (!pDB->Key.asqRequest.Err) {
                    pDB->Key.asqRequest.Err = LDAP_AFFECTS_MULTIPLE_DSAS;
                }
                // this error will bubble all the way up
                // where the current DNT will treated as a referral
                return DB_ERR_NOT_AN_OBJECT;
            }
            else {
                continue;
            }
        }

        if((!(Flags & DB_SEARCH_DELETIONS_VISIBLE)) && // Not interested in
                                                       // deleted objects.
           (DBIsObjDeleted(pDB))) {
            // Don't want deleted objects.
            if(pDB->Key.indexType == ANCESTORS_INDEX_TYPE) {
                // This the ancestors index.  Since we don't allow children of
                // deleted objects, skip the subtree here.
                Assert(fForward);
                dbAdjustCurrentKeyToSkipSubtree(pDB);

                // there is the posibility of bailing out this function due to a time 
                // limit in a paged search operation, leaving partialy complete KEY_INDEX. 
                // this way we force one more loop so as to fix things.
                fFirst = TRUE;
            }
            // ELSE,
            //    Just continue and get the next object.
            continue;
        }
        
        // ok. we have an object. if we are doing ASQ search and we are a GC
        // we want to know if we have the full info for this object, otherwise
        // we will return a referral
        //
        if (pDB->Key.asqRequest.fPresent &&
            !dbIsObjectLocal(pDB, pDB->JetObjTbl)) {


            if (pDB->Key.asqRequest.fMissingAttributesOnGC || pDB->Key.bOneNC) {
                DPRINT (1, "ASQ: found an entry that was missing attributes due to GCness\n");

                if (!pDB->Key.asqRequest.Err) {
                    pDB->Key.asqRequest.Err = LDAP_AFFECTS_MULTIPLE_DSAS;
                }

                if (pDB->Key.bOneNC) {
                    //
                    // We didn't come in through the GC port so this object
                    // shouldn't be visible at all.  
                    // this error will bubble all the way up
                    // where the current DNT will treated as a referral
                    //
                    return DB_ERR_NOT_AN_OBJECT;
                }
            }

        }

        // Ok, at this point we've found an object that seems to be in
        // the correct portion of whatever index we are walking, and is really
        // an object, and is appropriately deleted.  Next, we verify location.
        // In the sort table, we already trimmed out any objects that weren't in
        // the correct DIT location, so don't bother rechecking. 
        if(SORTED_INDEX (pDB->Key.indexType) ||
           dbFObjectInCorrectDITLocation(pDB, pDB->JetObjTbl) ) {
            
            // One more check.  Is the object in the correct NC?
            if(!dbFObjectInCorrectNC(pDB, pDB->DNT, pDB->JetObjTbl)) {
                // Wrong Naming Context.  Skip this object, look at the next
                // object. Note that we explicitly don't skip siblings, as
                // we are interested in the next sibling of this object.
                
                if(pDB->Key.indexType == ANCESTORS_INDEX_TYPE) {
                    // In the case of walking the ancestors index, we skip
                    // entire subtrees.  This should bring us to the next
                    // sibling of this object, skipping all descendants of this
                    // object.
                    Assert(fForward);
                    dbAdjustCurrentKeyToSkipSubtree(pDB);

                    // there is the posibility of bailing out this function due to a time 
                    // limit in a paged search operation, leaving partialy complete KEY_INDEX. 
                    // this way we force one more loop so as to fix things.
                    fFirst = TRUE;
                }
                continue;
            }
            
            // Yes, the object is in the correct NC.
            // This is the success return path for this routine.
            pDB->Key.bOnCandidate = TRUE;
            return 0;
        }
        
        // We found an object that was in the correct part of the index we are
        // walking, but it wasn't in the correct location in the DIT.  This
        // can't happen if we're walking a PDNT based index.  So, assert that we
        // are either using a temp table or that the index we are using is NOT
        // PDNT based.
        Assert(pDB->Key.indexType == TEMP_TABLE_INDEX_TYPE ||
               !pDB->Key.pIndex->bIsPDNTBased);        
    } // while (TRUE)
} // dbMoveToNextSearchCandidate

SIZE_T
dbSearchDuplicateHashDNT(
    IN      ULONG*  pDNT
    )
{
    return *pDNT;
}

BOOLEAN
dbSearchDuplicateCompareDNTs(
    IN      ULONG*  pDNT1,
    IN      ULONG*  pDNT2
    )
{
    return *pDNT1 == *pDNT2;
}

PVOID
dbSearchDuplicateAlloc(
    IN      SIZE_T  cbAlloc
    )
{
    return THAlloc((DWORD)cbAlloc);
}

VOID
dbSearchDuplicateFree(
    IN      PVOID   pvAlloc
    )
{
    THFree(pvAlloc);
}

VOID
dbSearchDuplicateCreateHashTable(
    IN      PLHT*   pplht
    )
{
    LHT_ERR err;
    
    err = LhtCreate(
            sizeof( ULONG ),
            (LHT_PFNHASHKEY)dbSearchDuplicateHashDNT,
            (LHT_PFNHASHENTRY)dbSearchDuplicateHashDNT,
            (LHT_PFNENTRYMATCHESKEY)dbSearchDuplicateCompareDNTs,
            NULL,
            0,
            0,
            (LHT_PFNMALLOC)dbSearchDuplicateAlloc,
            (LHT_PFNFREE)dbSearchDuplicateFree,
            0,
            pplht);
    if (err != LHT_errSuccess) {
        Assert(err == LHT_errOutOfMemory);
        RaiseDsaExcept(
            DSA_MEM_EXCEPTION,
            0,
            0,
            DSID(FILENO, __LINE__),
            DS_EVENT_SEV_MINIMAL);
    }
}


DB_ERR
dbFIsSearchDuplicate(
    IN  DBPOS *pDB,
    OUT BOOL  *pbIsDup)
{
    DB_ERR      dbErr;
    void        *pv;
    ULONG       cb;
    UCHAR       operation;
    UCHAR       syntax;
    ATTCACHE * pAC;
    DWORD       i;
    LHT_ERR     errLHT;
    LHT_POS     posLHT;

    Assert(VALID_DBPOS(pDB));

    // If we are using a temp table, we better be doing a DUP_NEVER style
    // duplicate detection algorithm. Temp table searches are never duplicate,
    // the temp table is set up to forbid them.
    
    Assert(pDB->Key.indexType != TEMP_TABLE_INDEX_TYPE ||
           (pDB->Key.dupDetectionType == DUP_NEVER));

    // Base object  searches are never duplicate, the method of finding them
    // guarantees it.  So, we'd better be using a DUP_NEVER style duplicate
    // detection algorithm.
    Assert((pDB->Key.ulSearchType != SE_CHOICE_BASE_ONLY) ||
           (pDB->Key.dupDetectionType == DUP_NEVER));

    switch(pDB->Key.dupDetectionType) {
    case DUP_NEVER:
        // We believe that we will never find a duplicate, so just return FALSE;
        *pbIsDup = FALSE;
        return DB_success;
        break;

    case DUP_HASH_TABLE:
        // we are tracking duplicates via a hash table.  Try to insert the DNT
        // into the hash table.  If the insert fails with key duplicate then
        // we know that we have seen this DNT before.
        errLHT = LhtFindEntry(
                    pDB->Key.plhtDup,
                    &pDB->DNT,
                    &posLHT);
        if (errLHT == LHT_errSuccess) {
            *pbIsDup = TRUE;
            return DB_success;
        } else {
            errLHT = LhtInsertEntry(
                        &posLHT,
                        &pDB->DNT);
            if (errLHT == LHT_errSuccess) {
                *pbIsDup = FALSE;
                return DB_success;
            } else if (errLHT == LHT_errKeyDuplicate) {
                *pbIsDup = TRUE;
                return DB_success;
            } else {
                Assert(errLHT == LHT_errOutOfMemory);
                RaiseDsaExcept(
                    DSA_MEM_EXCEPTION,
                    0,
                    0,
                    DSID(FILENO, __LINE__),
                    DS_EVENT_SEV_MINIMAL);
                return DB_ERR_UNKNOWN_ERROR;
            }
        }
        break;

    case DUP_MEMORY:
        // We are tracking duplicates via a block of memory.  See if the DNT is
        // in the block.
        for(i=0;i<pDB->Key.cDupBlock;i++) {
            if(pDB->Key.pDupBlock[i] == pDB->DNT) {
                // It's a duplicate
                *pbIsDup = TRUE;
                return DB_success;
            }
        }
        
        // OK, it's not in the block.  Add it.
        // First, is the block full?
        if(pDB->Key.cDupBlock == DUP_BLOCK_SIZE) {
            // Yes, so create a hash table and transfer all the DNTs we already
            // have to the hash table
            dbSearchDuplicateCreateHashTable(&pDB->Key.plhtDup);

            for(i=0;i<pDB->Key.cDupBlock;i++) {
                errLHT = LhtFindEntry(
                            pDB->Key.plhtDup,
                            &pDB->Key.pDupBlock[i],
                            &posLHT);
                Assert( errLHT == LHT_errEntryNotFound );
                errLHT = LhtInsertEntry(
                            &posLHT,
                            &pDB->Key.pDupBlock[i]);
                if (errLHT != LHT_errSuccess) {
                    Assert(errLHT == LHT_errOutOfMemory);
                    RaiseDsaExcept(
                        DSA_MEM_EXCEPTION,
                        0,
                        0,
                        DSID(FILENO, __LINE__),
                        DS_EVENT_SEV_MINIMAL);
                }
            }

            THFreeEx(pDB->pTHS, pDB->Key.pDupBlock);
            pDB->Key.pDupBlock = NULL;
            pDB->Key.cDupBlock = 0;

            // Mark that we are tracking via a hash table now.
            pDB->Key.dupDetectionType = DUP_HASH_TABLE;
        }
        else {
            // No, the block still has room.
            pDB->Key.pDupBlock[pDB->Key.cDupBlock] = pDB->DNT;
            pDB->Key.cDupBlock++;
        }
        *pbIsDup = FALSE;
        return DB_success;
        break;

    default:
        Assert(!"Dup_Detection type unknown!");
        // Huh?
        return DB_ERR_UNKNOWN_ERROR;
    }
} // dbFIsSearchDuplicate

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Determine if the object was deleted by getting the deletion attribute*/
BOOL
DBIsObjDeleted(DBPOS *pDB)
{
    UCHAR  syntax;
    ULONG  len;
    BOOL   Deleted;

    Assert(VALID_DBPOS(pDB));

    if (DBGetSingleValue(pDB, ATT_IS_DELETED, &Deleted, sizeof(Deleted),NULL) ||
        Deleted == FALSE) {
        return FALSE;
    }

    return TRUE;

}/*IsObjDeleted*/

BOOL
dbIsOKForSort (
        DBPOS *pDB
        )
{
    if(!pDB->Key.ulSorted ||
       // We're not sorted.
       SORTED_INDEX (pDB->Key.indexType)) {
       // We are sorted, but it's a temp table sort, which has already been
       // checked. 
        return TRUE;
    }

    // We better have the boolean that controls sorting
    Assert(pDB->Key.pbSortSkip);
    Assert(pDB->Key.pIndex);
    
    // If this is the index for the sort order, then we should skip objects that
    // have no value.  If this isn't the index for the sort, it's the indices
    // designed to pick up NULLs, so we shouldn't skip objects that have no
    // value.
    
    if(*(pDB->Key.pbSortSkip)) {
        // Effectively, no value.
        return !pDB->Key.pIndex->bIsForSort;
    }
    else {
        return (pDB->Key.pIndex->bIsForSort);
    }
}

DB_ERR
DBMatchSearchCriteria (
        DBPOS FAR *pDB,
        PSECURITY_DESCRIPTOR *ppSecurity,
        BOOL *pbIsMatch)
/*++

Routine Description:

    Apply the filter specified in the Key in the pDB to the current object.
    Also, apply security and object checks (i.e. a real object?)
    Returns TRUE if the current object matches all these search criteria.  Also,
    returns the security descriptor of the object if asked and if the object
    matches the search criteria.

Parameters:

    pDB - The DBPOS to use.

    ppSecurity - pointer to pointer to security descriptor.  If NULL, no
    security is evaluated for this call.  If non-null security is evaluated.  If
    the object matches search criteria, the SD is returned to the caller using
    THAlloced memory.

    pbIsMatch - If no error, then set to TRUE if object matches
    search criteria. FALSE if not. If TRUE and ppSecurity != NULL,
    then *ppSecurity is set to a pointer to a THAlloced buffer
    holding the Security Descriptor used in the evaluation.

Return Values:
    DB_success if all went well. *pbIsMatch is set to
        FALSE if the current object cannot be found to match the search criteria.
        TRUE if it can.  If TRUE and ppSecurity != NULL, then *ppSecurity is set to
        a pointer to a THAlloced buffer holding the Security Descriptor used in the
        evaluation.
    DB_ERR_xxx and *pbIsMatch is undefined.

--*/
{
    THSTATE *pTHS=pDB->pTHS;
    ULONG ulLen;
    DWORD err;
    PSECURITY_DESCRIPTOR pSecurity = NULL;
    DSNAME TempDN;
    CLASSCACHE *pCC=NULL;
    BOOL returnVal;
    char objFlag;

    Assert(VALID_DBPOS(pDB));

    // try to use the DN cache to retrieve vital fields.
    if (pTHS->fDRA || pTHS->fDSA || ppSecurity == NULL) {
        // only need to check if it's a phantom
        err = DBGetObjectSecurityInfo(
                pDB,
                pDB->DNT,
                NULL,
                NULL,
                NULL,
                NULL,
                &objFlag,
                DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE
            );
    }
    else {
        // need to grab all data
        if (*ppSecurity) {
            THFreeEx(pTHS, *ppSecurity);
        }
        *ppSecurity = NULL;
        err = DBGetObjectSecurityInfo(
                pDB,
                pDB->DNT,
                &ulLen,
                ppSecurity,
                &pCC,
                &TempDN,
                &objFlag,
                DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE
            );
        pSecurity = *ppSecurity;
    }

    if (err || objFlag == 0) {
        // A phantom never matches the search criteria.
        if (pSecurity) {
            THFreeEx(pTHS, pSecurity);
        }
        if (ppSecurity) {
            *ppSecurity = NULL;
        }
        *pbIsMatch = FALSE;
        return err;
    }

    err = DB_success;
    if(pDB->Key.ulSorted && pDB->Key.indexType == TEMP_TABLE_INDEX_TYPE) {
        // In this case, we've already checked filter security, checked the OK
        // for Sort stuff, evaluated the security, and checked for duplicates.
        returnVal = TRUE;
    }
    else {
        TRIBOOL retfil = eFALSE;

        if (dbEvalFilterSecurity(pDB, pCC, pSecurity, &TempDN)
            && dbIsOKForSort(pDB)
            && ((retfil = DBEvalFilter(pDB, FALSE, pDB->Key.pFilter)) == eTRUE)) {
            err = dbFIsSearchDuplicate(pDB, &returnVal);
            returnVal = !returnVal;
        } else {
            returnVal = FALSE;
        }
        Assert (VALID_TRIBOOL(retfil));
    }

    if(pSecurity && ((!returnVal) || (err != DB_success))) {
        // I got them a security descriptor, but this doesn't match the search
        // criteria  so they can't want the SD I found, so free it.
        THFreeEx(pDB->pTHS, pSecurity);
        if (ppSecurity) {
            *ppSecurity = NULL;
        }
    }

    *pbIsMatch = returnVal;
    return err;
}

BOOL
dbMatchSearchCriteriaForSortedTable (
        DBPOS *pDB,
        BOOL  *pCanRead
        )
/*++

Routine Description:

    Apply the filter specified in the Key in the pDB to the current object.
    Returns TRUE if the current object matches all these search criteria.

    Assumptions: The object we are interested in is on the pDB->ObjTable
                 pDB->DNT
                 pDB->PDNT are pointing to the right values.

Parameters:

    pDB - The DBPOS to use.
    pCanRead - TRUE is the sorted attribute can be read, FALSE otherwise

Return Values:

    FALSE if the current object cannot be found to match the search criteria.
    TRUE if it can.

--*/
{
    ATTRTYP              class;
    JET_ERR              err;
    DSNAME               TempDN;
    PSECURITY_DESCRIPTOR pSec=NULL;
    DWORD                sdLen;
    THSTATE             *pTHS=pDB->pTHS;
    CLASSCACHE          *pCC=NULL;
    BOOL                 returnVal;
    TRIBOOL              retfil;

    Assert(VALID_DBPOS(pDB));

    if(pTHS->fDRA || pTHS->fDSA) {
        *pCanRead = TRUE;

        returnVal = ((retfil = DBEvalFilter(pDB, FALSE, pDB->Key.pFilter)) == eTRUE);

        Assert (VALID_TRIBOOL(retfil));

        return returnVal;
    }

    // check to see whether the object is visible by security
    // otherwise there is no meaning putting the object on the
    // sorted table just to throw it away later
    // PERFHINT: this can be optimized since we are reading the SD in two places
    if(!IsObjVisibleBySecurity(pDB->pTHS, TRUE)) {
        DPRINT (1, "Got an object not visible by security in a sorted search\n");
        *pCanRead = FALSE;
        return FALSE;
    }

    // get SD, Sid, Guid and class
    err = DBGetObjectSecurityInfo(
            pDB,
            pDB->DNT,
            &sdLen,
            &pSec,
            &pCC,
            &TempDN,
            NULL,
            DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE
        );
    if (err || sdLen == 0) {
        // something bad happened or no SD...
        return FALSE;
    }

    // OK, got the data, now make the check.
    retfil = eFALSE;
    returnVal = (dbEvalFilterSecurity(pDB, pCC, pSec, &TempDN) &&
                 ((retfil = DBEvalFilter(pDB, FALSE, pDB->Key.pFilter)) == eTRUE));

    Assert (VALID_TRIBOOL(retfil));

    THFreeEx(pTHS, pSec);

    if(!returnVal) {
        *pCanRead=FALSE;
    }
    else {
        *pCanRead = !(*pDB->Key.pbSortSkip);
    }

    return returnVal;
}

DWORD
DBGetNextSearchObject (
        DBPOS *pDB,
        DWORD StartTick,
        DWORD DeltaTick,
        PSECURITY_DESCRIPTOR *ppSecurity,
        ULONG Flags)
/*++

Routine Description:

    Find the next search object.  This finds objects on the current index,
    applying the filter given.

    Moves to the next object which matches search criteria.  On a non-error
    return from this routine, we have moved forward in whatever index we are
    using to support this search, checked a filter (using security if any should
    be applied), checked for real objectness (not a phantom, deleted only if
    asked, etc.).

    On an error return of DB_ERR_TIMELIMIT, we have at least moved forward,
    although we might not be on a search candidate if the time limit was
    triggered inside of dbMoveToNextSearchCandidate.  We have NOT checked to see
    if we matched the search criteria.  So, if someone ends up repositioning to
    here via a paged search, we need to check the candidacy and then the
    search criteria.


Arguments:
    pDB - the DBPOS to use.
    StartTick - if !0, specifies a time limit is in effect, and this is the tick
            count when the call was started.
    DeltaTick - if a time limit is in effect, this is the maximum number of
            ticks past StartTick to allow.
    ppSecurity - Security Descriptor of the Search object found.
    flags - Flags affecting search behaviour.  May be any combination of the
            following:
            DB_SEARCH_DELETIONS_VISIBLE  1
            DB_SEARCH_FORWARD            2


Return Values:
    0 if all went well, an error code otherwise:
        DB_ERR_TIMELIMIT
        DB_ERR_NEXTCHILD_NOTFOUND
        DB_ERR_NOT_AN_OBJECT

--*/
{
    ULONG       actuallen;
    DWORD       dwStatus;
    BOOL        bIsMatch;


    DPRINT(3,"DBGetNextSearchObject entered\n");

    Assert(VALID_DBPOS(pDB));

    // start by losing the input SD
    if (ppSecurity && *ppSecurity) {
        THFreeEx(pDB->pTHS, *ppSecurity);
        *ppSecurity = NULL;
    }

    while (TRUE) {
        if (dwStatus =
            dbMoveToNextSearchCandidate(pDB, Flags, StartTick, DeltaTick)) {
            // Something wrong in finding the next search candidate.
            return dwStatus;
        }

        // We are on a candidate
        Assert(pDB->Key.bOnCandidate);

        // Base searches should never have a reason to time out.  Therefore
        // don't bother checking for timeout here if it's a base search.  For
        // any other search check for timeout if there is a timelimit.
        if(pDB->Key.ulSearchType != SE_CHOICE_BASE_ONLY &&
           !pDB->Key.asqRequest.fPresent                &&
           StartTick) {
            if((GetTickCount() - StartTick) > DeltaTick) {
                return DB_ERR_TIMELIMIT;
            }
        }

        // OK, we found something, and didn't hit a time limit. See if this is a
        // good object.
        dwStatus = DBMatchSearchCriteria(pDB, ppSecurity, &bIsMatch);
        if (DB_success != dwStatus) {
            return dwStatus;
        }
        if(bIsMatch) {

            // This candidate matches the criteria.  It is no longer a
            // candidate, it is a real search object.

            pDB->SearchEntriesReturned += 1;

            return 0;
        }
    }
}/*DBGetNextSearchObject*/

DWORD APIENTRY
DBRepositionSearch (
        DBPOS FAR *pDB,
        PRESTART pArgRestart,
        DWORD StartTick,
        DWORD DeltaTick,
        PSECURITY_DESCRIPTOR *ppSecurity,
        ULONG Flags
        )
/*++

  Hand unmarshall the data packed into the restart arg

--*/
{
    ULONG      ulDnt;
    JET_ERR    err;
    ULONG      actuallen;
    BYTE       pDBKeyCurrent[DB_CB_MAX_KEY];
    BYTE       rgbKey[DB_CB_MAX_KEY];
    ULONG      cbDBKeyCurrent;
    BOOL       fForwardSeek = Flags & DB_SEARCH_FORWARD;
    DWORD      StartDNT;
    KEY_INDEX  *pTempIndex;

    Assert(VALID_DBPOS(pDB));

    err = dbUnMarshallRestart(pDB,
                              pArgRestart,
                              pDBKeyCurrent,
                              Flags,
                              &cbDBKeyCurrent,
                              &StartDNT);
    if (err) {
        return err;
    }

    if (pDB->Key.pVLV) {
        DPRINT (1, "Repositining on a VLV search.\n");
        return 0;

    } else if (pDB->Key.asqRequest.fPresent) {

        // if we are repositioning on a sorted search, this means that we
        // already have all our data on the array, so we don't have to
        // bring new data from the database
        // otherwise, for simple paged searches, we have to go to the db again

        if (! (pDB->Key.asqMode & ASQ_SORTED)) {
            if (err = dbCreateASQTable(pDB,
                                       StartTick,
                                       DeltaTick,
                                       pDB->Key.ulASQSizeLimit,
                                       FALSE,
                                       0) ) {

                return DB_ERR_NO_CHILD;
            }
        }

        // now that we have data in memory, get the next one.
        err =  DBGetNextSearchObject (pDB,
                                      StartTick,
                                      DeltaTick,
                                      ppSecurity,
                                      Flags);

        if (err && err != DB_ERR_NOT_AN_OBJECT) {
            return DB_ERR_NO_CHILD;
        }
        return err;
    }

    // Get the dnt of the record we need to position on
    if (DBFindDNT(pDB, StartDNT)) {
        DPRINT(1,"DBRepositionSearch: repositioning failed\n");
        return DB_ERR_NO_CHILD;
    }

    if(!SORTED_INDEX(pDB->Key.indexType)) {
        Assert(pDB->Key.pIndex);
        // set to the index we're using for the search, seek for the saved key,
        // and to avoid hitting  the wrong record (due to duplicate keys), we
        // move forward until we hit the correct record. Thus, we maintain our
        // position in the index

        // If this is temp table restart, we are already on the correct index
        // (DBFindDNT put us there).
        JetSetCurrentIndex2Success(pDB->JetSessID,
                                   pDB->JetObjTbl,
                                   pDB->Key.pIndex->szIndexName,
                                   0);

        Assert(strcmp(pDB->Key.pIndex->szIndexName, SZANCESTORSINDEX) ||
               pDB->Key.indexType == ANCESTORS_INDEX_TYPE);


        JetMakeKeyEx(pDB->JetSessID,
                     pDB->JetObjTbl,
                     pDBKeyCurrent,
                     cbDBKeyCurrent,
                     JET_bitNormalizedKey);

        if (err = JetSeekEx(pDB->JetSessID, pDB->JetObjTbl, JET_bitSeekEQ)) {
            DPRINT(1,"DBRepositionSearch: repositioning failed\n");
            return DB_ERR_NO_CHILD;
        }

        while (TRUE) {
            // are we positioned on the right record?

            JetRetrieveColumnSuccess(pDB->JetSessID, pDB->JetObjTbl, dntid,
                                     &ulDnt, sizeof(ulDnt), &actuallen, 0,
                                     NULL);

            if (ulDnt == pDB->DNT)
                break;                      // yes - exit the loop

            // we're not on the right record so move forward

            if (err = JetMoveEx(pDB->JetSessID, pDB->JetObjTbl,
                                JET_MoveNext, 0))  {
                DPRINT(1,"DBRepositionSearch: repositioning failed\n");
                return DB_ERR_NO_CHILD;
            }

            JetRetrieveKeyEx(pDB->JetSessID, pDB->JetObjTbl, rgbKey,
                             sizeof(rgbKey),
                             &actuallen, 0);

            if ((actuallen != cbDBKeyCurrent) ||
                memcmp(rgbKey, pDBKeyCurrent, actuallen)) {

                DPRINT(1,"DBRepositionSearch: repositioning failed\n");
                return DB_ERR_NO_CHILD;
            }
        }

        // We're on the correct record.  Now, set the appropriate index range.
        if(fForwardSeek &&(pDB->Key.pIndex->cbDBKeyUpper)) {
            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetObjTbl,
                         pDB->Key.pIndex->rgbDBKeyUpper,
                         pDB->Key.pIndex->cbDBKeyUpper,
                         JET_bitNormalizedKey);

            err = JetSetIndexRange(pDB->JetSessID,
                                   pDB->JetObjTbl,
                                   (JET_bitRangeUpperLimit |
                                    JET_bitRangeInclusive));
        }
        else if(!fForwardSeek && pDB->Key.pIndex->cbDBKeyLower) {
            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetObjTbl,
                         pDB->Key.pIndex->rgbDBKeyLower,
                         pDB->Key.pIndex->cbDBKeyLower,
                         JET_bitNormalizedKey);

            err = JetSetIndexRange(pDB->JetSessID,
                                   pDB->JetObjTbl,
                                   JET_bitRangeInclusive);
        }
        if(err) {
            // We failed to set the index range.  However, we know that we are
            // on the "correct" object (i.e. correct DNT and correct saved key),
            // and that this is a restart, so the key used to create the index
            // range should be valid, after all we used it last time we were
            // processing part of this paged search.  Therefore, we should never
            // get a failure on the index range.  Since we did, and we don't
            // really know where we are in the search, we're going to fail the
            // search (just as we did for the case where we couldn't find the
            // "correct" search object, above.)

            // Do an assert, since we really shouldn't ever see this failure.
            Assert(!"DBRepositionSearch: setindexrange failed\n");
            DPRINT1(1,"DBRepositionSearch: setindexrange failed, err %d\n",err);
            return DB_ERR_NO_CHILD;
        }
    }

    //  OK, we're here.  But is here where we want to be?

    if(!pDB->Key.bOnCandidate) {
        // We repositioned, but the object we are on was NOT a search
        // candidate, so it's not where we really want to be on return from this
        // routine. Move to the next object which IS where we want to be.
        return DBGetNextSearchObject (pDB,
                                      StartTick,
                                      DeltaTick,
                                      ppSecurity,
                                      Flags);
    }


    if(((Flags & DB_SEARCH_DELETIONS_VISIBLE) || !DBIsObjDeleted(pDB))) {
        BOOL bIsMatch;

        err = DBMatchSearchCriteria(pDB, ppSecurity, &bIsMatch);
        if (DB_success != err) {
            return err;
        }
        if (bIsMatch) {
            // Yep, database currency; it's everywhere you want to be
            return 0;
        }
    }

    if(ppSecurity && *ppSecurity) {
        THFreeEx(pDB->pTHS, *ppSecurity);
        *ppSecurity = NULL;
    }


    // Oh, we aren't really where we wanted to be.  OK, move to the next object
    // which IS where we want to be.
    return DBGetNextSearchObject (pDB,
                                  StartTick,
                                  DeltaTick,
                                  ppSecurity,
                                  Flags);
}

//
// retrieve the key from the current record in obj table and retuen it and
// it's length. errors are handled with exceptions.  Size of buffer handed in is
// in *pcb.  Buffer handed in should be at least DB_CB_MAX_KEY bytes.
//

void
DBGetKeyFromObjTable(DBPOS *pDB, BYTE *rgbKey, ULONG *pcb)
{
    DWORD err;

    Assert(VALID_DBPOS(pDB));

    if(!rgbKey) {
        // NULL key buffer was passed in.  They just want the size of buffer
        // they need.
        err = JetRetrieveKeyWarnings(pDB->JetSessID,
                                     pDB->JetObjTbl,
                                     rgbKey,
                                     *pcb,
                                     pcb,
                                     0);
        switch(err) {
        case JET_errSuccess:
        case JET_wrnBufferTruncated:
            // fine returns
            return;
            break;
        default:
            // Throw the same exception that JetRetrieveKeyException would
            // throw.
            DsaExcept(DSA_DB_EXCEPTION, err, 0);
            return;
            break;
        }
    }
    else {
        JetRetrieveKeyEx(pDB->JetSessID, pDB->JetObjTbl, rgbKey, *pcb,
                         pcb, 0);
    }

}

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

void
DBSetVLVArgs (
    DBPOS       *pDB,
    VLV_REQUEST *pVLVrequest,
    ATTRTYP      SortAtt
    )
{
    VLV_SEARCH *pvlvSearch;

    Assert (pVLVrequest);
    Assert (pVLVrequest->fPresent);
    Assert (pDB->Key.pVLV == NULL);

    if (pVLVrequest->fPresent) {
        pvlvSearch = pDB->Key.pVLV = THAllocEx (pDB->pTHS, sizeof (VLV_SEARCH));

        pvlvSearch->clnContentCount = pVLVrequest->contentCount;
        pvlvSearch->clnCurrPos = pVLVrequest->targetPosition;
        //pvlvSearch->contentCount = 0;
        //pvlvSearch->currPosition = 0;
        //pvlvSearch->foundEntries = 0;
        pvlvSearch->pVLVRequest = pVLVrequest;
        pvlvSearch->requestedEntries =
                pVLVrequest->beforeCount +
                pVLVrequest->afterCount + 1;

        pvlvSearch->SortAttr = SortAtt;
    }
}

void DBSetVLVResult (
            DBPOS       *pDB,
            VLV_REQUEST *pVLVRequest,
            PRESTART    pResRestart
    )
{
    pVLVRequest->fPresent = TRUE;
    pVLVRequest->pVLVRestart = pResRestart;
    pVLVRequest->contentCount = pDB->Key.pVLV->contentCount;
    pVLVRequest->targetPosition = pDB->Key.pVLV->currPosition;

    pVLVRequest->Err = pDB->Key.pVLV->Err;

    DPRINT2 (1, "DBSetVLVResult: targetPos: %d contentCount: %d \n",
                pVLVRequest->targetPosition, pVLVRequest->contentCount);
    DPRINT (1, "====================================\n");

}

void
DBSetASQArgs (
    DBPOS       *pDB,
    ASQ_REQUEST *pASQRequest,
    COMMARG     *pCommArg
    )
{
    pDB->Key.asqRequest = *pASQRequest;
    pDB->Key.ulASQSizeLimit = pCommArg->MaxTempTableSize;

    // set the ASQ mode
    pDB->Key.asqMode = 0;
    if (pCommArg->VLVRequest.fPresent) {
        pDB->Key.asqMode = ASQ_VLV;
    }
    else {
        if (pCommArg->PagedResult.fPresent) {
            pDB->Key.asqMode = ASQ_PAGED;
            pDB->Key.ulASQSizeLimit = pCommArg->ulSizeLimit;
        }

        if (pCommArg->SortAttr) {
            pDB->Key.asqMode |= ASQ_SORTED;
        }
    }
} // DBSetASQArgs

void
DBSetASQResult (
    DBPOS       *pDB,
    ASQ_REQUEST *pASQRequest
    )
{
    *pASQRequest = pDB->Key.asqRequest;
}








/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* dbMakeKeyIndex --
   Given some actual data values, return the keys in the jet index for the
   upper and lower bounds the data describes.  Also, if asked, return a
   GUESS as to the number of records in bounds.

   Called when doing a search optimization.

   Input- DBPOS to use,
          Option of whether this is a PDNT, NCDNT, or unbased index.
          Boolean of whether or not to Guess number of records.
          ULONG * of where to put the guess.

          An array of INDEX_RANGE structures. Each index range structure contains
          a lower bound and an upper bound on one component of the index.


          Place to put key for lower bound.
          Place to put key for upper bound.

   Output-
          The two keys and (if asked) a guess as to the number of records.

*/
KEY_INDEX *
dbMakeKeyIndex(
        DBPOS *pDB,
        DWORD dwSearchType,
        BOOL  bIsSingleValued,
        DWORD Option,
        char * szIndex,
        BOOL fGetNumRecs,
        DWORD cIndexRanges,
        INDEX_RANGE * rgIndexRanges)
{
    THSTATE     *pTHS=pDB->pTHS;
    JET_ERR     err;
    BOOL        fMoveToEnd = FALSE;
    DWORD       grBit;
    KEY_INDEX  *pIndex=NULL;
    BYTE        rgbKey1[DB_CB_MAX_KEY];
    BYTE        rgbKey2[DB_CB_MAX_KEY];
    DWORD       cbActualKey1 = 0;
    DWORD       cbActualKey2 = 0;
    DWORD       BeginNum, BeginDenom;
    DWORD       EndNum, EndDenom;
    DWORD       Denom;
    DWORD       i;
    JET_RECPOS  RecPos;

    JetSetCurrentIndexSuccess(pDB->JetSessID,
                              pDB->JetSearchTbl,
                              szIndex);

    pIndex = dbAlloc(sizeof(KEY_INDEX));
    pIndex->pNext = NULL;
    pIndex->bIsSingleValued = bIsSingleValued;
    // Assume this is not for a sorted search. Caller will change value if necessary
    pIndex->bIsForSort = FALSE;

    // Assume this is not a tuple index search. Caller will change it if necessary
    pIndex->bIsTupleIndex = FALSE;

    pIndex->bIsEqualityBased = (dwSearchType == FI_CHOICE_EQUALITY);

    pIndex->szIndexName = dbAlloc(strlen(szIndex) + 1);
    strcpy(pIndex->szIndexName, szIndex);

    Assert(VALID_DBPOS(pDB));

    // make keys

    // First make the key for the lower bound ( ie key 1 )

    if ((Option == 0) &&  ((0==cIndexRanges) ||
                           (0==rgIndexRanges[0].cbValLower))) {
        // Range starts at beginning of file
        cbActualKey1 = 0;
    }
    else {
        grBit = JET_bitNewKey;

        if(Option == dbmkfir_PDNT) {
            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetSearchTbl,
                         &pDB->Key.ulSearchRootDnt,
                         sizeof(pDB->Key.ulSearchRootDnt),
                         JET_bitNewKey);
            grBit = 0;
        }
        else if(Option == dbmkfir_NCDNT) {
            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetSearchTbl,
                         &pDB->Key.ulSearchRootNcdnt,
                         sizeof(pDB->Key.ulSearchRootNcdnt),
                         JET_bitNewKey);
            grBit = 0;
        }

        //
        // Loop through the passed in index components making the
        // jet key
        //

        for (i=0;i<cIndexRanges;i++)
        {
            // break out of the loop as soon as
            // we encounter the 0 length index component
            if (0==rgIndexRanges[i].cbValLower)
                break;

            Assert(NULL!=rgIndexRanges[i].pvValLower);

            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetSearchTbl,
                         rgIndexRanges[i].pvValLower,
                         rgIndexRanges[i].cbValLower,
                         grBit);
            grBit = 0;
        }


        JetRetrieveKeyEx(pDB->JetSessID,
                         pDB->JetSearchTbl,
                         rgbKey1,
                         sizeof(rgbKey1),
                         &cbActualKey1,
                         JET_bitRetrieveCopy);
    }

    // key 2. This is the key for the upper bound on the
    // index range
    if ((0==cIndexRanges) || (0==rgIndexRanges[0].cbValUpper)) {
        // We want all of the objects in the index.
        switch(Option) {
        case dbmkfir_PDNT:
            // Get all the things with the same PDNT, regardless of the value of
            // the second portion of the index.
            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetSearchTbl,
                         &pDB->Key.ulSearchRootDnt,
                         sizeof(pDB->Key.ulSearchRootDnt),
                         JET_bitNewKey | JET_bitStrLimit);

            JetRetrieveKeyEx(pDB->JetSessID,
                             pDB->JetSearchTbl,
                             rgbKey2,
                             sizeof(rgbKey2),
                             &cbActualKey2,
                             JET_bitRetrieveCopy);
            break;

        case dbmkfir_NCDNT:
            // Get all the things with the same NCDNT, regardless of the value
            // of the second portion of the index.
            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetSearchTbl,
                         &pDB->Key.ulSearchRootNcdnt,
                         sizeof(pDB->Key.ulSearchRootNcdnt),
                         JET_bitNewKey | JET_bitStrLimit);

            JetRetrieveKeyEx(pDB->JetSessID,
                             pDB->JetSearchTbl,
                             rgbKey2,
                             sizeof(rgbKey2),
                             &cbActualKey2,
                             JET_bitRetrieveCopy);
            break;

        default:
            // Range ends at end of file, get all objects.
            cbActualKey2 = sizeof(rgbKey2);
            memset(rgbKey2, 0xff, cbActualKey2);
            fMoveToEnd = TRUE;
            break;

        }
    }
    else {
        DWORD uppergrBit = JET_bitStrLimit;
        if(dwSearchType == FI_CHOICE_SUBSTRING) {
            uppergrBit |= JET_bitSubStrLimit;
        }

        switch(Option) {
        case dbmkfir_PDNT:
            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetSearchTbl,
                         &pDB->Key.ulSearchRootDnt,
                         sizeof(pDB->Key.ulSearchRootDnt),
                         JET_bitNewKey);
            grBit = 0;
            break;

        case dbmkfir_NCDNT:
            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetSearchTbl,
                         &pDB->Key.ulSearchRootNcdnt,
                         sizeof(pDB->Key.ulSearchRootNcdnt),
                         JET_bitNewKey);
            grBit = 0;
            break;

        default:
            grBit = JET_bitNewKey;
        }

        //
        // Loop through the passed in index components making the
        // jet key
        //

        for (i=0;i<cIndexRanges;i++) {
            BOOL LastIndexComponent;

            LastIndexComponent = ((i==(cIndexRanges-1))
                                  || (0==rgIndexRanges[i+1].cbValUpper));

            Assert(0!=rgIndexRanges[i].cbValUpper);
            Assert(NULL!=rgIndexRanges[i].pvValUpper);

            //
            // if it is the last index component on which we want the indes
            // range, then also or in upperbit which indicates string or
            // substring limit
            //

            if (LastIndexComponent)
                grBit |=uppergrBit;

            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetSearchTbl,
                         rgIndexRanges[i].pvValUpper,
                         rgIndexRanges[i].cbValUpper,
                         grBit);

            if (LastIndexComponent)
                break;

            // reset the grbit.
            grBit=0;
        }

        JetRetrieveKeyEx(pDB->JetSessID,
                         pDB->JetSearchTbl,
                         rgbKey2,
                         sizeof(rgbKey2),
                         &cbActualKey2,
                         JET_bitRetrieveCopy);
    }

    pIndex->cbDBKeyLower = cbActualKey1;
    if(cbActualKey1) {
        pIndex->rgbDBKeyLower = dbAlloc(cbActualKey1);
        memcpy(pIndex->rgbDBKeyLower, rgbKey1, cbActualKey1);
    }

    pIndex->cbDBKeyUpper = cbActualKey2;
    if(cbActualKey2) {
        pIndex->rgbDBKeyUpper = dbAlloc(cbActualKey2);
        memcpy(pIndex->rgbDBKeyUpper, rgbKey2, cbActualKey2);
    }

    if (fGetNumRecs) {
        // Get an estimate of the number of objects in the index range.
        // position on first record

        if (cbActualKey1) {

            // key exists - seek to it
            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetSearchTbl,
                         rgbKey1,
                         cbActualKey1,
                         JET_bitNormalizedKey);
            if (((err = JetSeekEx(pDB->JetSessID,
                                  pDB->JetSearchTbl,
                                  JET_bitSeekGE)) != JET_errSuccess) &&
                (err != JET_wrnRecordFoundGreater)) {

                // no records
                pIndex->ulEstimatedRecsInRange = 0;
                return pIndex;
            }
        }
        else if ((err = JetMoveEx(pDB->JetSessID,
                                  pDB->JetSearchTbl,
                                  JET_MoveFirst,
                                  0)) != JET_errSuccess) {
            // no records
            pIndex->ulEstimatedRecsInRange = 0;
            return pIndex;
        }

        JetGetRecordPosition(pDB->JetSessID, pDB->JetSearchTbl, &RecPos,
                             sizeof(JET_RECPOS));
        BeginNum = RecPos.centriesLT;
        BeginDenom = RecPos.centriesTotal;

        // position on last record

        if (!fMoveToEnd) {
            // key exists - seek to it

            JetMakeKeyEx(pDB->JetSessID,
                         pDB->JetSearchTbl,
                         rgbKey2,
                         cbActualKey2,
                         JET_bitNormalizedKey);

            if (((err = JetSeekEx(pDB->JetSessID,
                                  pDB->JetSearchTbl,
                                  JET_bitSeekLE)) != JET_errSuccess) &&
                (err != JET_wrnRecordFoundLess)) {

                // no records
                pIndex->ulEstimatedRecsInRange = 0;
                return pIndex;
            }
        }
        else if ((err = JetMoveEx(pDB->JetSessID,
                                  pDB->JetSearchTbl,
                                  JET_MoveLast,
                                  0)) != JET_errSuccess) {
            // no records
            pIndex->ulEstimatedRecsInRange = 0;
            return pIndex;
        }

        JetGetRecordPosition(pDB->JetSessID, pDB->JetSearchTbl, &RecPos,
                             sizeof(JET_RECPOS));
        EndNum = RecPos.centriesLT;
        EndDenom = RecPos.centriesTotal;

        // Normalize the fractions of the fractional position to the average of
        // the two denominators.
        // denominator
        Denom = (BeginDenom + EndDenom)/2;
        EndNum = MulDiv(EndNum, Denom, EndDenom);
        BeginNum = MulDiv(BeginNum, Denom, BeginDenom);

        if(EndNum <= BeginNum) {
            pIndex->ulEstimatedRecsInRange = 1;
        }
        else {
            pIndex->ulEstimatedRecsInRange = EndNum - BeginNum;
        }
    }
    else {
        pIndex->ulEstimatedRecsInRange = 0;
    }

    return pIndex;
}


DWORD
DBSetSearchScope(DBPOS  *pDB,
                 ULONG ulSearchType,
                 BOOL bOneNC,
                 RESOBJ *pResRoot)
/*
Routine Description:

    Sets the scope of the search on the default KEY on DBPOS.

Arguments:

    pDB - The DBPos to use.

    ulSearchType - the type of the search

    bOneNC - Are results constrained to same NC

    pResRoot - the RESOBJ that contains info about our position in the tree

Return Values:

    0 if all went well.
*/
{
    Assert(VALID_DBPOS(pDB));

    pDB->Key.ulSearchType = ulSearchType;
    pDB->Key.fSearchInProgress = FALSE;
    pDB->Key.indexType = INVALID_INDEX_TYPE;
    pDB->Key.bOnCandidate = FALSE;
    pDB->Key.bOneNC = bOneNC;

    pDB->Key.ulSearchRootDnt = pResRoot->DNT;
    pDB->Key.ulSearchRootPDNT = pResRoot->PDNT;
    pDB->Key.ulSearchRootNcdnt = pResRoot->NCDNT;

    return 0;
}


DWORD
DBFindComputerObj(
        DBPOS *pDB,
        DWORD cchComputerName,
        WCHAR *pComputerName
        )
/*
   Find a computer object.  Does so by taking the unicode string passed in and
   tacking on a $ at the end.  This should be the sam account name of the
   computer.  Then, it uses the NCDT/ACCOUNT TYPE/SAM ACCOUNT NAME index to find
   an object in the default domain with account type SAM_MACHINE_ACCOUNT and the
   computed SAM account name.  If an object is found, DB currency is set to that
   object (and reflected in the DBPOS).

   returns 0 if all went well, a jet error otherwise.
*/
{
    DWORD  acctType = SAM_MACHINE_ACCOUNT;
    WCHAR *pTemp = THAllocEx(pDB->pTHS,((cchComputerName + 1) * sizeof(WCHAR)));
    DWORD err;

    memcpy(pTemp, pComputerName, cchComputerName * sizeof(WCHAR));
    pTemp[cchComputerName] = L'$';
    cchComputerName++;

    JetSetCurrentIndex4Success(pDB->JetSessID,
                               pDB->JetObjTbl,
                               SZ_NC_ACCTYPE_NAME_INDEX,
                               &idxNcAccTypeName,
                               0);

    // First, the NCNDT
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetObjTbl,
                 &gAnchor.ulDNTDomain,
                 sizeof(gAnchor.ulDNTDomain),
                 JET_bitNewKey);

    // Now, the account type.
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetObjTbl,
                 &acctType,
                 sizeof(acctType),
                 0);


    // finally, the sam account name.
    JetMakeKeyEx(pDB->JetSessID,
                 pDB->JetObjTbl,
                 pTemp,
                 cchComputerName * sizeof(WCHAR),
                 0);


    // OK, find it.
    err = JetSeekEx(pDB->JetSessID,
                    pDB->JetObjTbl,
                    JET_bitSeekEQ);

    THFreeEx(pDB->pTHS, pTemp);

    if(!err) {
        // Found it, update the dbpos
        err = dbMakeCurrent(pDB, NULL);
    }
    return err;
}

/*-------------------------------------------------------------------------*/
//
// Position ourselves on the start of the specified VLV search
//
DWORD
DBPositionVLVSearch (
    DBPOS *pDB,
    SEARCHARG *pSearchArg,
    PSECURITY_DESCRIPTOR *ppSecurity
    )
{
    DWORD dwSearchStatus = 0, deltaCount = 0, srvNewPos;
    ULONG SearchFlags = SEARCH_FLAGS(pSearchArg->CommArg);
    int  direction = 0;
    DWORD beforeCount, clnCurrPos, clnContentCount;

    Assert (pDB->Key.pVLV);
    if (!pDB->Key.pVLV) {
        return DB_ERR_SYSERROR;
    }

    beforeCount = pDB->Key.pVLV->pVLVRequest->beforeCount;
    clnCurrPos = pDB->Key.pVLV->clnCurrPos;
    clnContentCount = pDB->Key.pVLV->clnContentCount;

    if (pDB->Key.pVLV->contentCount == 0) {
        DPRINT (1, "VLV: Empty Container\n");
        pDB->Key.pVLV->currPosition = 0;
        return DB_ERR_NEXTCHILD_NOTFOUND;
    }

    if (pDB->Key.pVLV->pVLVRequest->fseekToValue) {
        DPRINT (1, "VLV: Seeking to a Value\n");

        dwSearchStatus =
            DBGetNextSearchObject(pDB,
                                  pSearchArg->CommArg.StartTick,
                                  pSearchArg->CommArg.DeltaTick,
                                  ppSecurity,
                                  SearchFlags);

        DPRINT2 (1, "VLV positioned status: 0x%x / %d\n",
                 dwSearchStatus, pDB->Key.pVLV->clnCurrPos );

        return dwSearchStatus;
    }

    if (clnCurrPos == 1) {
        DPRINT (1, "VLV: Moving to the FIRST entry\n");

        pDB->Key.pVLV->positionOp = VLV_MOVE_FIRST;

        dwSearchStatus =
            DBGetNextSearchObject(pDB,
                                  pSearchArg->CommArg.StartTick,
                                  pSearchArg->CommArg.DeltaTick,
                                  ppSecurity,
                                  SearchFlags);

        DPRINT1 (1, "VLV positioned status: 0x%x / %d\n", dwSearchStatus);

        return dwSearchStatus;
    }
    else if (clnContentCount == clnCurrPos) {
        DPRINT (1, "VLV: Moving to the LAST entry\n");

        pDB->Key.pVLV->positionOp = VLV_MOVE_LAST;

        dwSearchStatus =
            DBGetNextSearchObject(pDB,
                                  pSearchArg->CommArg.StartTick,
                                  pSearchArg->CommArg.DeltaTick,
                                  ppSecurity,
                                  SearchFlags);

        DPRINT1 (1, "VLV positioned status: 0x%x / %d\n", dwSearchStatus);

        return dwSearchStatus;
    }
    else if (clnCurrPos == 0) {

        DPRINT (1, "VLV Client Offset Range Error\n" );

        pDB->Key.pVLV->Err = LDAP_OFFSET_RANGE_ERROR;

        return DB_ERR_VLV_CONTROL;
    }

    // calculate position
    pDB->Key.pVLV->positionOp = VLV_CALC_POSITION;

    dwSearchStatus =
        DBGetNextSearchObject(pDB,
                              pSearchArg->CommArg.StartTick,
                              pSearchArg->CommArg.DeltaTick,
                              ppSecurity,
                              SearchFlags);

    DPRINT1 (1, "VLV positioned status: 0x%x\n", dwSearchStatus);

    return dwSearchStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\ntdsa\dblayer\dbtools.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dbtools.c
//
//--------------------------------------------------------------------------

/*
Description:
    Various tools for the DB layer.

*/
#include <NTDSpch.h>
#pragma  hdrstop

#include <dsjet.h>

#include <ntdsa.h>                      // only needed for ATTRTYP
#include <scache.h>                     //
#include <dbglobal.h>                   //
#include <mdglobal.h>                   // For dsatools.h
#include <mdlocal.h>                    // For dsatools.h
#include <dsatools.h>                   // For pTHStls

#include <dstaskq.h>
#include <crypt.h>                      // for samisrv.h
#include <samrpc.h>                     // for samisrv.h
#include <lsarpc.h>                     // for samisrv.h
#include <samisrv.h>                    // for nlrepl.h
#include <nlrepl.h>                     // For NetLogon notifications
#include <mappings.h>
#include <dsconfig.h>
#include <ntdskcc.h>                    // KccExecuteTask
#include <anchor.h>

// Logging headers.
#include <mdcodes.h>
#include <dsexcept.h>

// Assorted DSA headers
#include "dsevent.h"
#include "objids.h"        /* needed for ATT_MEMBER and ATT_IS_MEMBER_OFDL */
#include <filtypes.h>      /* Def of FI_CHOICE_???                  */
#include   "debug.h"         /* standard debugging header */
#define DEBSUB  "DBTOOLS:" /* define the subsystem for debugging  */

// DBLayer includes
#include "dbintrnl.h"
#include "dbopen.h"
#include "lht.h"

#include <fileno.h>
#define  FILENO FILENO_DBTOOLS

// The maximum time (in msec) that a transaction should be allowed to be open
// during normal operation (e.g., unless we're stress testing huge group
// replication, etc.).
DWORD gcMaxTicksAllowedForTransaction = MAX_TRANSACTION_TIME;

const ULONG csecOnlineDefragPeriodMax   = HOURS_IN_SECS;

/*--------------------------------------------------------------------------- */
/*--------------------------------------------------------------------------- */
/* Find a record by DNT. This record changes the pDB->JetObjTbl currency
   to the specified record, as well as correctly filling in the pDB->DNT,
   pDB->PDNT, and pDB->NCDNT fields.
 */
DWORD APIENTRY
DBFindDNT(DBPOS FAR *pDB, ULONG tag)
{
    JET_ERR  err;
    ULONG    actuallen;

    Assert(VALID_DBPOS(pDB));

    // Since we are moving currency, we have to cancel rec.  Callers should
    // take care of this by either not being in an init rec in the first place,
    // or by doing their own cancel rec or update rec.  This is important since
    // cancelling a rec here leaves the caller under the mistaking impression
    // that a JetSetColumn they've done is just waiting for an update rec to
    // be flushed to disk.  Anyway, assert on it now, but keep going if they
    // have done this.
    // later, we might want to change this to error if we are in a
    // init rec.

    Assert(pDB->JetRetrieveBits == 0);

    DBCancelRec(pDB);
    DBSetCurrentIndex(pDB, Idx_Dnt, NULL, FALSE);

    JetMakeKeyEx(pDB->JetSessID, pDB->JetObjTbl,
        &tag, sizeof(tag), JET_bitNewKey);

    if (err = JetSeekEx(pDB->JetSessID,
        pDB->JetObjTbl, JET_bitSeekEQ))
    {
        DsaExcept(DSA_DB_EXCEPTION, err, 0);
    }

    (pDB)->DNT = tag;

    dbMakeCurrent(pDB, NULL);

    DPRINT1(2, "DBFindDNT complete DNT:%ld\n", (pDB)->DNT);
    return 0;
}

/*++ DBMakeCurrent
 *
 * This routine makes the DBPOS currency information match whatever object
 * the pDB->JetObjTbl is positioned at.
 *
 * The return value is either 0, or DIRRER_NOT_AN_OBJECT if currency has
 * been established on a phantom
 */
DWORD __fastcall
DBMakeCurrent(DBPOS *pDB)
{
    return dbMakeCurrent(pDB, NULL);
}


/*++ dbMakeCurrent
 *
 * This routine makes the DBPOS currency information match whatever object
 * the pDB->JetObjTbl is positioned at.
 *
 * If pname is passed in, that information will be used to update the DBPOS,
 * rather than going to JET.
 *
 * The return value is either 0, or DIRRER_NOT_AN_OBJECT if currency has
 * been established on a phantom
 */
BOOL gfEnableReadOnlyCopy;

DWORD
dbMakeCurrent(DBPOS *pDB, d_memname *pname)
{
    THSTATE     *pTHS = pDB->pTHS;
    JET_RETRIEVECOLUMN jCol[4];
    UCHAR objflag;
    DWORD cb;
    DWORD err;

    // Since we are moving currency, we need to assure that we are not
    // in the middle of an init rec.  If we were, then whatever update
    // we were doing would be lost, because you can't change currency
    // inside of an update.  This assertion frees us from having to
    // set the jCol grbits to pDB->JetRetrieveBits
    Assert(pDB->JetRetrieveBits == 0);

    pDB->JetNewRec = FALSE;
    pDB->fFlushCacheOnUpdate = FALSE;

    //  if we are in a read-only transaction then cache the current record in
    //  Jet to make JetRetrieveColumn calls much faster
    if (    gfEnableReadOnlyCopy &&
            pTHS->fSyncSet &&
            pTHS->transType == SYNC_READ_ONLY &&
            pTHS->transControl == TRANSACT_BEGIN_END &&
            pDB->transincount &&
            !pDB->JetCacheRec)
        {
        JetPrepareUpdateEx( pDB->JetSessID, pDB->JetObjTbl, JET_prepReadOnlyCopy );
        pDB->JetCacheRec = TRUE;
        }

    if (NULL != pname) {
        pDB->DNT = pname->DNT;
        if (pDB->DNT == ROOTTAG) {
            pDB->root = TRUE;
            pDB->PDNT = 0;
            pDB->NCDNT = 0;
        }
        else {
            pDB->root = FALSE;
            pDB->PDNT = pname->tag.PDNT;

            err = JetRetrieveColumnWarnings(pDB->JetSessID, pDB->JetObjTbl,
                                            ncdntid, &pDB->NCDNT,
                                            sizeof(pDB->NCDNT), &cb, 0, NULL);
            // for some reason, this is not true.
            // Assert(pDB->NCDNT == pname->NCDNT);
            Assert(!err || !pname->objflag);
        }

        if (!pname->objflag) {
            return DIRERR_NOT_AN_OBJECT;
        }
        else {
            return 0;
        }
    }

    memset(jCol, 0, sizeof(jCol));

    jCol[0].columnid = dntid;
    jCol[0].pvData = &pDB->DNT;
    jCol[0].cbData = sizeof(ULONG);
    jCol[0].cbActual = sizeof(ULONG);
    jCol[0].itagSequence = 1;

    jCol[1].columnid = pdntid;
    jCol[1].pvData = &pDB->PDNT;
    jCol[1].cbData = sizeof(ULONG);
    jCol[1].cbActual = sizeof(ULONG);
    jCol[1].itagSequence = 1;

    jCol[2].columnid = objid;
    jCol[2].pvData = &objflag;
    jCol[2].cbData = sizeof(objflag);
    jCol[2].cbActual = sizeof(objflag);
    jCol[2].itagSequence = 1;

    jCol[3].columnid = ncdntid;
    jCol[3].pvData = &pDB->NCDNT;
    jCol[3].cbData = sizeof(ULONG);
    jCol[3].cbActual = sizeof(ULONG);
    jCol[3].itagSequence = 1;

    // Jet has better performance if columns are retrieved in id order
    Assert((dntid < pdntid) && "Ignorable assert, performance warning");
    Assert((pdntid < objid) && "Ignorable assert, performance warning");
    Assert((objid < ncdntid) && "Ignorable assert, performance warning");

    JetRetrieveColumnsWarnings(pDB->JetSessID,
                               pDB->JetObjTbl,
                               jCol,
                               4);

    Assert(jCol[2].err == JET_errSuccess);

    if (pDB->DNT == ROOTTAG) {
        pDB->root = TRUE;
        pDB->PDNT = 0;
        pDB->NCDNT = 0;
    }
    else {
        pDB->root = FALSE;
    }

    if ((jCol[3].err == JET_wrnColumnNull) ||
        !objflag) {
        return DIRERR_NOT_AN_OBJECT;
    }
    else {
        return 0;
    }
}

/*++

Routine Descrition:

    Try to find a record by DNT. This record changes the pDB->JetObjTbl
    currency to the specified record, as well as correctly filling in the
    pDB->DNT, pDB->PDNT, and pDB->NCDNT fields.  Unlike DBFindDNT, we return an
    error code if we couldn find the object instead of throwing an exception.

Parameters

    pDB - dbPos to use.

    tag - tag to look up.

Return values:

    0 if all went well, DIRERR_OBJ_NOT_FOUND if we couldn't find the object.
    Note that currency is undefined if we return an error.

 */
DWORD APIENTR